/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 87 "/usr/include/stdint.h"
typedef long intptr_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_3 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_3 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_4 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_4 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_6 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_5 {
   unsigned long long __value64 ;
   struct __anonstruct_6 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_5 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_7 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_7 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_8 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_8 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_9 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_9 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_10 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_10 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_barrierattr_t;
#line 47 "/usr/include/sndfile.h"
enum __anonenum__16 {
    SF_FORMAT_WAV = 65536,
    SF_FORMAT_AIFF = 131072,
    SF_FORMAT_AU = 196608,
    SF_FORMAT_RAW = 262144,
    SF_FORMAT_PAF = 327680,
    SF_FORMAT_SVX = 393216,
    SF_FORMAT_NIST = 458752,
    SF_FORMAT_VOC = 524288,
    SF_FORMAT_IRCAM = 655360,
    SF_FORMAT_W64 = 720896,
    SF_FORMAT_MAT4 = 786432,
    SF_FORMAT_MAT5 = 851968,
    SF_FORMAT_PVF = 917504,
    SF_FORMAT_XI = 983040,
    SF_FORMAT_HTK = 1048576,
    SF_FORMAT_SDS = 1114112,
    SF_FORMAT_AVR = 1179648,
    SF_FORMAT_WAVEX = 1245184,
    SF_FORMAT_SD2 = 1441792,
    SF_FORMAT_FLAC = 1507328,
    SF_FORMAT_CAF = 1572864,
    SF_FORMAT_WVE = 1638400,
    SF_FORMAT_OGG = 2097152,
    SF_FORMAT_MPC2K = 2162688,
    SF_FORMAT_RF64 = 2228224,
    SF_FORMAT_PCM_S8 = 1,
    SF_FORMAT_PCM_16 = 2,
    SF_FORMAT_PCM_24 = 3,
    SF_FORMAT_PCM_32 = 4,
    SF_FORMAT_PCM_U8 = 5,
    SF_FORMAT_FLOAT = 6,
    SF_FORMAT_DOUBLE = 7,
    SF_FORMAT_ULAW = 16,
    SF_FORMAT_ALAW = 17,
    SF_FORMAT_IMA_ADPCM = 18,
    SF_FORMAT_MS_ADPCM = 19,
    SF_FORMAT_GSM610 = 32,
    SF_FORMAT_VOX_ADPCM = 33,
    SF_FORMAT_NMS_ADPCM_16 = 34,
    SF_FORMAT_NMS_ADPCM_24 = 35,
    SF_FORMAT_NMS_ADPCM_32 = 36,
    SF_FORMAT_G721_32 = 48,
    SF_FORMAT_G723_24 = 49,
    SF_FORMAT_G723_40 = 50,
    SF_FORMAT_DWVW_12 = 64,
    SF_FORMAT_DWVW_16 = 65,
    SF_FORMAT_DWVW_24 = 66,
    SF_FORMAT_DWVW_N = 67,
    SF_FORMAT_DPCM_8 = 80,
    SF_FORMAT_DPCM_16 = 81,
    SF_FORMAT_VORBIS = 96,
    SF_FORMAT_OPUS = 100,
    SF_FORMAT_ALAC_16 = 112,
    SF_FORMAT_ALAC_20 = 113,
    SF_FORMAT_ALAC_24 = 114,
    SF_FORMAT_ALAC_32 = 115,
    SF_ENDIAN_FILE = 0,
    SF_ENDIAN_LITTLE = 268435456,
    SF_ENDIAN_BIG = 536870912,
    SF_ENDIAN_CPU = 805306368,
    SF_FORMAT_SUBMASK = 65535,
    SF_FORMAT_TYPEMASK = 268369920,
    SF_FORMAT_ENDMASK = 805306368
} ;
#line 137
enum __anonenum__17 {
    SFC_GET_LIB_VERSION = 4096,
    SFC_GET_LOG_INFO = 4097,
    SFC_GET_CURRENT_SF_INFO = 4098,
    SFC_GET_NORM_DOUBLE = 4112,
    SFC_GET_NORM_FLOAT = 4113,
    SFC_SET_NORM_DOUBLE = 4114,
    SFC_SET_NORM_FLOAT = 4115,
    SFC_SET_SCALE_FLOAT_INT_READ = 4116,
    SFC_SET_SCALE_INT_FLOAT_WRITE = 4117,
    SFC_GET_SIMPLE_FORMAT_COUNT = 4128,
    SFC_GET_SIMPLE_FORMAT = 4129,
    SFC_GET_FORMAT_INFO = 4136,
    SFC_GET_FORMAT_MAJOR_COUNT = 4144,
    SFC_GET_FORMAT_MAJOR = 4145,
    SFC_GET_FORMAT_SUBTYPE_COUNT = 4146,
    SFC_GET_FORMAT_SUBTYPE = 4147,
    SFC_CALC_SIGNAL_MAX = 4160,
    SFC_CALC_NORM_SIGNAL_MAX = 4161,
    SFC_CALC_MAX_ALL_CHANNELS = 4162,
    SFC_CALC_NORM_MAX_ALL_CHANNELS = 4163,
    SFC_GET_SIGNAL_MAX = 4164,
    SFC_GET_MAX_ALL_CHANNELS = 4165,
    SFC_SET_ADD_PEAK_CHUNK = 4176,
    SFC_UPDATE_HEADER_NOW = 4192,
    SFC_SET_UPDATE_HEADER_AUTO = 4193,
    SFC_FILE_TRUNCATE = 4224,
    SFC_SET_RAW_START_OFFSET = 4240,
    SFC_SET_DITHER_ON_WRITE = 4256,
    SFC_SET_DITHER_ON_READ = 4257,
    SFC_GET_DITHER_INFO_COUNT = 4258,
    SFC_GET_DITHER_INFO = 4259,
    SFC_GET_EMBED_FILE_INFO = 4272,
    SFC_SET_CLIPPING = 4288,
    SFC_GET_CLIPPING = 4289,
    SFC_GET_CUE_COUNT = 4301,
    SFC_GET_CUE = 4302,
    SFC_SET_CUE = 4303,
    SFC_GET_INSTRUMENT = 4304,
    SFC_SET_INSTRUMENT = 4305,
    SFC_GET_LOOP_INFO = 4320,
    SFC_GET_BROADCAST_INFO = 4336,
    SFC_SET_BROADCAST_INFO = 4337,
    SFC_GET_CHANNEL_MAP_INFO = 4352,
    SFC_SET_CHANNEL_MAP_INFO = 4353,
    SFC_RAW_DATA_NEEDS_ENDSWAP = 4368,
    SFC_WAVEX_SET_AMBISONIC = 4608,
    SFC_WAVEX_GET_AMBISONIC = 4609,
    SFC_RF64_AUTO_DOWNGRADE = 4624,
    SFC_SET_VBR_ENCODING_QUALITY = 4864,
    SFC_SET_COMPRESSION_LEVEL = 4865,
    SFC_SET_OGG_PAGE_LATENCY_MS = 4866,
    SFC_SET_OGG_PAGE_LATENCY = 4867,
    SFC_SET_CART_INFO = 5120,
    SFC_GET_CART_INFO = 5121,
    SFC_SET_ORIGINAL_SAMPLERATE = 5376,
    SFC_GET_ORIGINAL_SAMPLERATE = 5377,
    SFC_TEST_IEEE_FLOAT_REPLACE = 24577,
    SFC_SET_ADD_HEADER_PAD_CHUNK = 4177,
    SFC_SET_ADD_DITHER_ON_WRITE = 4208,
    SFC_SET_ADD_DITHER_ON_READ = 4209
} ;
#line 250
enum __anonenum__18 {
    SF_STR_TITLE = 1,
    SF_STR_COPYRIGHT = 2,
    SF_STR_SOFTWARE = 3,
    SF_STR_ARTIST = 4,
    SF_STR_COMMENT = 5,
    SF_STR_DATE = 6,
    SF_STR_ALBUM = 7,
    SF_STR_LICENSE = 8,
    SF_STR_TRACKNUMBER = 9,
    SF_STR_GENRE = 16
} ;
#line 271
enum __anonenum__19 {
    SF_FALSE = 0,
    SF_TRUE = 1,
    SFM_READ = 16,
    SFM_WRITE = 32,
    SFM_RDWR = 48,
    SF_AMBISONIC_NONE = 64,
    SF_AMBISONIC_B_FORMAT = 65
} ;
#line 291
enum __anonenum__20 {
    SF_ERR_NO_ERROR = 0,
    SF_ERR_UNRECOGNISED_FORMAT = 1,
    SF_ERR_SYSTEM = 2,
    SF_ERR_MALFORMED_FILE = 3,
    SF_ERR_UNSUPPORTED_ENCODING = 4
} ;
#line 303
enum __anonenum__21 {
    SF_CHANNEL_MAP_INVALID = 0,
    SF_CHANNEL_MAP_MONO = 1,
    SF_CHANNEL_MAP_LEFT = 2,
    SF_CHANNEL_MAP_RIGHT = 3,
    SF_CHANNEL_MAP_CENTER = 4,
    SF_CHANNEL_MAP_FRONT_LEFT = 5,
    SF_CHANNEL_MAP_FRONT_RIGHT = 6,
    SF_CHANNEL_MAP_FRONT_CENTER = 7,
    SF_CHANNEL_MAP_REAR_CENTER = 8,
    SF_CHANNEL_MAP_REAR_LEFT = 9,
    SF_CHANNEL_MAP_REAR_RIGHT = 10,
    SF_CHANNEL_MAP_LFE = 11,
    SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER = 12,
    SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER = 13,
    SF_CHANNEL_MAP_SIDE_LEFT = 14,
    SF_CHANNEL_MAP_SIDE_RIGHT = 15,
    SF_CHANNEL_MAP_TOP_CENTER = 16,
    SF_CHANNEL_MAP_TOP_FRONT_LEFT = 17,
    SF_CHANNEL_MAP_TOP_FRONT_RIGHT = 18,
    SF_CHANNEL_MAP_TOP_FRONT_CENTER = 19,
    SF_CHANNEL_MAP_TOP_REAR_LEFT = 20,
    SF_CHANNEL_MAP_TOP_REAR_RIGHT = 21,
    SF_CHANNEL_MAP_TOP_REAR_CENTER = 22,
    SF_CHANNEL_MAP_AMBISONIC_B_W = 23,
    SF_CHANNEL_MAP_AMBISONIC_B_X = 24,
    SF_CHANNEL_MAP_AMBISONIC_B_Y = 25,
    SF_CHANNEL_MAP_AMBISONIC_B_Z = 26,
    SF_CHANNEL_MAP_MAX = 27
} ;
#line 339
struct SNDFILE_tag ;
#line 339 "/usr/include/sndfile.h"
typedef struct SNDFILE_tag SNDFILE;
#line 348 "/usr/include/sndfile.h"
typedef int64_t sf_count_t;
#line 359 "/usr/include/sndfile.h"
struct SF_INFO {
   sf_count_t frames ;
   int samplerate ;
   int channels ;
   int format ;
   int sections ;
   int seekable ;
};
#line 368 "/usr/include/sndfile.h"
typedef struct SF_INFO SF_INFO;
#line 381 "/usr/include/sndfile.h"
struct __anonstruct_22 {
   int format ;
   char const   *name ;
   char const   *extension ;
};
#line 385 "/usr/include/sndfile.h"
typedef struct __anonstruct_22 SF_FORMAT_INFO;
#line 393
enum __anonenum__23 {
    SFD_DEFAULT_LEVEL = 0,
    SFD_CUSTOM_LEVEL = 1073741824,
    SFD_NO_DITHER = 500,
    SFD_WHITE = 501,
    SFD_TRIANGULAR_PDF = 502
} ;
#line 402 "/usr/include/sndfile.h"
struct __anonstruct_24 {
   int type ;
   double level ;
   char const   *name ;
};
#line 406 "/usr/include/sndfile.h"
typedef struct __anonstruct_24 SF_DITHER_INFO;
#line 412 "/usr/include/sndfile.h"
struct __anonstruct_25 {
   sf_count_t offset ;
   sf_count_t length ;
};
#line 415 "/usr/include/sndfile.h"
typedef struct __anonstruct_25 SF_EMBED_FILE_INFO;
#line 421 "/usr/include/sndfile.h"
struct __anonstruct_26 {
   int32_t indx ;
   uint32_t position ;
   int32_t fcc_chunk ;
   int32_t chunk_start ;
   int32_t block_start ;
   uint32_t sample_offset ;
   char name[256] ;
};
#line 429 "/usr/include/sndfile.h"
typedef struct __anonstruct_26 SF_CUE_POINT;
#line 437 "/usr/include/sndfile.h"
struct __anonstruct_27 {
   uint32_t cue_count ;
   SF_CUE_POINT cue_points[100] ;
};
#line 437 "/usr/include/sndfile.h"
typedef struct __anonstruct_27 SF_CUES;
#line 443
enum __anonenum__28 {
    SF_LOOP_NONE = 800,
    SF_LOOP_FORWARD = 801,
    SF_LOOP_BACKWARD = 802,
    SF_LOOP_ALTERNATING = 803
} ;
#line 460 "/usr/include/sndfile.h"
struct __anonstruct_30 {
   int mode ;
   uint32_t start ;
   uint32_t end ;
   uint32_t count ;
};
#line 453 "/usr/include/sndfile.h"
struct __anonstruct_29 {
   int gain ;
   char basenote ;
   char detune ;
   char velocity_lo ;
   char velocity_hi ;
   char key_lo ;
   char key_hi ;
   int loop_count ;
   struct __anonstruct_30 loops[16] ;
};
#line 466 "/usr/include/sndfile.h"
typedef struct __anonstruct_29 SF_INSTRUMENT;
#line 471 "/usr/include/sndfile.h"
struct __anonstruct_31 {
   short time_sig_num ;
   short time_sig_den ;
   int loop_mode ;
   int num_beats ;
   float bpm ;
   int root_key ;
   int future[6] ;
};
#line 487 "/usr/include/sndfile.h"
typedef struct __anonstruct_31 SF_LOOP_INFO;
#line 515 "/usr/include/sndfile.h"
struct __anonstruct_32 {
   char description[256] ;
   char originator[32] ;
   char originator_reference[32] ;
   char origination_date[10] ;
   char origination_time[8] ;
   uint32_t time_reference_low ;
   uint32_t time_reference_high ;
   short version ;
   char umid[64] ;
   int16_t loudness_value ;
   int16_t loudness_range ;
   int16_t max_true_peak_level ;
   int16_t max_momentary_loudness ;
   int16_t max_shortterm_loudness ;
   char reserved[180] ;
   uint32_t coding_history_size ;
   char coding_history[256] ;
};
#line 515 "/usr/include/sndfile.h"
typedef struct __anonstruct_32 SF_BROADCAST_INFO;
#line 517 "/usr/include/sndfile.h"
struct SF_CART_TIMER {
   char usage[4] ;
   int32_t value ;
};
#line 522 "/usr/include/sndfile.h"
typedef struct SF_CART_TIMER SF_CART_TIMER;
#line 549 "/usr/include/sndfile.h"
struct __anonstruct_33 {
   char version[4] ;
   char title[64] ;
   char artist[64] ;
   char cut_id[64] ;
   char client_id[64] ;
   char category[64] ;
   char classification[64] ;
   char out_cue[64] ;
   char start_date[10] ;
   char start_time[8] ;
   char end_date[10] ;
   char end_time[8] ;
   char producer_app_id[64] ;
   char producer_app_version[64] ;
   char user_def[64] ;
   int32_t level_reference ;
   SF_CART_TIMER post_timers[8] ;
   char reserved[276] ;
   char url[1024] ;
   uint32_t tag_text_size ;
   char tag_text[256] ;
};
#line 549 "/usr/include/sndfile.h"
typedef struct __anonstruct_33 SF_CART_INFO;
#line 553 "/usr/include/sndfile.h"
typedef sf_count_t (*sf_vio_get_filelen)(void * );
#line 554 "/usr/include/sndfile.h"
typedef sf_count_t (*sf_vio_seek)(sf_count_t  , int  , void * );
#line 555 "/usr/include/sndfile.h"
typedef sf_count_t (*sf_vio_read)(void * , sf_count_t  , void * );
#line 556 "/usr/include/sndfile.h"
typedef sf_count_t (*sf_vio_write)(void const   * , sf_count_t  , void * );
#line 557 "/usr/include/sndfile.h"
typedef sf_count_t (*sf_vio_tell)(void * );
#line 559 "/usr/include/sndfile.h"
struct SF_VIRTUAL_IO {
   sf_vio_get_filelen get_filelen ;
   sf_vio_seek seek ;
   sf_vio_read read ;
   sf_vio_write write ;
   sf_vio_tell tell ;
};
#line 567 "/usr/include/sndfile.h"
typedef struct SF_VIRTUAL_IO SF_VIRTUAL_IO;
#line 651
enum __anonenum__34 {
    SF_SEEK_SET = 0,
    SF_SEEK_CUR = 1,
    SF_SEEK_END = 2
} ;
#line 784 "/usr/include/sndfile.h"
struct SF_CHUNK_INFO {
   char id[64] ;
   unsigned int id_size ;
   unsigned int datalen ;
   void *data ;
};
#line 791 "/usr/include/sndfile.h"
typedef struct SF_CHUNK_INFO SF_CHUNK_INFO;
#line 803
struct SF_CHUNK_ITERATOR ;
#line 803 "/usr/include/sndfile.h"
typedef struct SF_CHUNK_ITERATOR SF_CHUNK_ITERATOR;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_35 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_35 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__36 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__37 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 69
enum __anonenum__38 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__39 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__40 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__41 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__42 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__43 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__44 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__45 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_46 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_46 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_47 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_47 max_align_t;
#line 42 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
#line 43 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned char guint8;
#line 45 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef short gint16;
#line 46 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned short guint16;
#line 53 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int gint32;
#line 54 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned int guint32;
#line 63 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gint64;
#line 64 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guint64;
#line 79 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gssize;
#line 80 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long gsize;
#line 90 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef gint64 goffset;
#line 106 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gintptr;
#line 107 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guintptr;
#line 199 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int GPid;
#line 46 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
#line 47 "/usr/include/glib-2.0/glib/gtypes.h"
typedef short gshort;
#line 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef long glong;
#line 49 "/usr/include/glib-2.0/glib/gtypes.h"
typedef int gint;
#line 50 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gboolean;
#line 52 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned char guchar;
#line 53 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned short gushort;
#line 54 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned long gulong;
#line 55 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned int guint;
#line 57 "/usr/include/glib-2.0/glib/gtypes.h"
typedef float gfloat;
#line 58 "/usr/include/glib-2.0/glib/gtypes.h"
typedef double gdouble;
#line 103 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void *gpointer;
#line 104 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void const   *gconstpointer;
#line 106 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareFunc)(gconstpointer  , gconstpointer  );
#line 108 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareDataFunc)(gconstpointer  , gconstpointer  , gpointer  );
#line 111 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gboolean (*GEqualFunc)(gconstpointer  , gconstpointer  );
#line 113 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GDestroyNotify)(gpointer  );
#line 114 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFunc)(gpointer  , gpointer  );
#line 116 "/usr/include/glib-2.0/glib/gtypes.h"
typedef guint (*GHashFunc)(gconstpointer  );
#line 117 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GHFunc)(gpointer  , gpointer  , gpointer  );
#line 133 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gpointer (*GCopyFunc)(gconstpointer  , gpointer  );
#line 143 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFreeFunc)(gpointer  );
#line 157 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gchar *(*GTranslateFunc)(gchar * , gpointer  );
#line 501
union _GDoubleIEEE754 ;
#line 501 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
#line 502
union _GFloatIEEE754 ;
#line 502 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GFloatIEEE754 GFloatIEEE754;
#line 511 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_48 {
   guint mantissa ;
   guint biased_exponent ;
   guint sign ;
};
#line 508 "/usr/include/glib-2.0/glib/gtypes.h"
union _GFloatIEEE754 {
   gfloat v_float ;
   struct __anonstruct_48 mpn ;
};
#line 520 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_49 {
   guint mantissa_low ;
   guint mantissa_high ;
   guint biased_exponent ;
   guint sign ;
};
#line 517 "/usr/include/glib-2.0/glib/gtypes.h"
union _GDoubleIEEE754 {
   gdouble v_double ;
   struct __anonstruct_49 mpn ;
};
#line 551
struct _GTimeVal ;
#line 551 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;
#line 553 "/usr/include/glib-2.0/glib/gtypes.h"
struct _GTimeVal {
   glong tv_sec ;
   glong tv_usec ;
};
#line 559 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint grefcount;
#line 560 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gatomicrefcount;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
struct _GBytes ;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GBytes GBytes;
#line 37
struct _GArray ;
#line 37 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GArray GArray;
#line 38
struct _GByteArray ;
#line 38 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GByteArray GByteArray;
#line 39
struct _GPtrArray ;
#line 39 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GPtrArray GPtrArray;
#line 41 "/usr/include/glib-2.0/glib/garray.h"
struct _GArray {
   gchar *data ;
   guint len ;
};
#line 47 "/usr/include/glib-2.0/glib/garray.h"
struct _GByteArray {
   guint8 *data ;
   guint len ;
};
#line 53 "/usr/include/glib-2.0/glib/garray.h"
struct _GPtrArray {
   gpointer *pdata ;
   guint len ;
};
#line 36 "/usr/include/glib-2.0/glib/gquark.h"
typedef guint32 GQuark;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError ;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;
#line 43 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError {
   GQuark domain ;
   gint code ;
   gchar *message ;
};
#line 140 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorInitFunc)(GError * );
#line 158 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorCopyFunc)(GError * , GError * );
#line 173 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorClearFunc)(GError * );
#line 252 "/usr/include/glib-2.0/glib/gutils.h"
enum __anonenum__50 {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8
} ;
#line 263 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__50 GUserDirectory;
#line 276
struct _GDebugKey ;
#line 276 "/usr/include/glib-2.0/glib/gutils.h"
typedef struct _GDebugKey GDebugKey;
#line 277 "/usr/include/glib-2.0/glib/gutils.h"
struct _GDebugKey {
   gchar *key ;
   guint value ;
};
#line 305
enum __anonenum__51 {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4
} ;
#line 311 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__51 GFormatSizeFlags;
#line 333 "/usr/include/glib-2.0/glib/gutils.h"
typedef void (*GVoidFunc)(void);
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_52 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_52 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_53 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_53 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_54 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_54 lldiv_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 42 "/usr/include/glib-2.0/glib/gthread.h"
enum __anonenum__55 {
    G_THREAD_ERROR_AGAIN = 0
} ;
#line 45 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__55 GThreadError;
#line 47 "/usr/include/glib-2.0/glib/gthread.h"
typedef gpointer (*GThreadFunc)(gpointer  );
#line 49
struct _GThread ;
#line 49 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GThread GThread;
#line 51
union _GMutex ;
#line 51 "/usr/include/glib-2.0/glib/gthread.h"
typedef union _GMutex GMutex;
#line 52
struct _GRecMutex ;
#line 52 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRecMutex GRecMutex;
#line 53
struct _GRWLock ;
#line 53 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRWLock GRWLock;
#line 54
struct _GCond ;
#line 54 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GCond GCond;
#line 55
struct _GPrivate ;
#line 55 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GPrivate GPrivate;
#line 56
struct _GOnce ;
#line 56 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GOnce GOnce;
#line 58 "/usr/include/glib-2.0/glib/gthread.h"
union _GMutex {
   gpointer p ;
   guint i[2] ;
};
#line 65 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRWLock {
   gpointer p ;
   guint i[2] ;
};
#line 72 "/usr/include/glib-2.0/glib/gthread.h"
struct _GCond {
   gpointer p ;
   guint i[2] ;
};
#line 79 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRecMutex {
   gpointer p ;
   guint i[2] ;
};
#line 87 "/usr/include/glib-2.0/glib/gthread.h"
struct _GPrivate {
   gpointer p ;
   GDestroyNotify notify ;
   gpointer future[2] ;
};
#line 95
enum __anonenum__56 {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2
} ;
#line 100 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__56 GOnceStatus;
#line 103 "/usr/include/glib-2.0/glib/gthread.h"
struct _GOnce {
   GOnceStatus status ;
   gpointer retval ;
};
#line 285 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GMutexLocker;
#line 360 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRecMutexLocker;
#line 439 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockWriterLocker;
#line 550 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockReaderLocker;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
struct _GAsyncQueue ;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
typedef struct _GAsyncQueue GAsyncQueue;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_59 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_60 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_61 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_62 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_65 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_64 {
   struct __anonstruct_65 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_63 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_64 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_66 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_67 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_58 {
   int _pad[28] ;
   struct __anonstruct_59 _kill ;
   struct __anonstruct_60 _timer ;
   struct __anonstruct_61 _rt ;
   struct __anonstruct_62 _sigchld ;
   struct __anonstruct_63 _sigfault ;
   struct __anonstruct_66 _sigpoll ;
   struct __anonstruct_67 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_57 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_58 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_57 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__68 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__69 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__70 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__71 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__72 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 176
enum __anonenum__73 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__74 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_76 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_75 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_76 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_75 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__77 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_78 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_78 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_79 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_79  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_80 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_80 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_81 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_81 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__82 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
struct _GTimeZone ;
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef struct _GTimeZone GTimeZone;
#line 49
enum __anonenum__83 {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2
} ;
#line 54 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef enum __anonenum__83 GTimeType;
#line 87 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef gint64 GTimeSpan;
#line 96
struct _GDateTime ;
#line 96 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef struct _GDateTime GDateTime;
#line 58 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
enum __anonenum__84 {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
} ;
#line 68 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef enum __anonenum__84 GBookmarkFileError;
#line 78
struct _GBookmarkFile ;
#line 78 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef struct _GBookmarkFile GBookmarkFile;
#line 47 "/usr/include/glib-2.0/glib/gchecksum.h"
enum __anonenum__85 {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4
} ;
#line 53 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef enum __anonenum__85 GChecksumType;
#line 65
struct _GChecksum ;
#line 65 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef struct _GChecksum GChecksum;
#line 54 "/usr/include/glib-2.0/glib/gconvert.h"
enum __anonenum__86 {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7
} ;
#line 64 "/usr/include/glib-2.0/glib/gconvert.h"
typedef enum __anonenum__86 GConvertError;
#line 83
struct _GIConv ;
#line 83 "/usr/include/glib-2.0/glib/gconvert.h"
typedef struct _GIConv *GIConv;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
struct _GData ;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
typedef struct _GData GData;
#line 38 "/usr/include/glib-2.0/glib/gdataset.h"
typedef void (*GDataForeachFunc)(GQuark  , gpointer  , gpointer  );
#line 57 "/usr/include/glib-2.0/glib/gdataset.h"
typedef gpointer (*GDuplicateFunc)(gpointer  , gpointer  );
#line 48 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
#line 49 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint16 GDateYear;
#line 50 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint8 GDateDay;
#line 51
struct _GDate ;
#line 51 "/usr/include/glib-2.0/glib/gdate.h"
typedef struct _GDate GDate;
#line 54
enum __anonenum__87 {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2
} ;
#line 59 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__87 GDateDMY;
#line 62
enum __anonenum__88 {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__88 GDateWeekday;
#line 73
enum __anonenum__89 {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12
} ;
#line 88 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__89 GDateMonth;
#line 99 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate {
   guint julian_days ;
   guint julian ;
   guint dmy ;
   guint day ;
   guint month ;
   guint year ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__90 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
struct _GDir ;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
typedef struct _GDir GDir;
#line 33 "/usr/include/glib-2.0/glib/gfileutils.h"
enum __anonenum__91 {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24
} ;
#line 60 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__91 GFileError;
#line 66
enum __anonenum__92 {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16
} ;
#line 73 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__92 GFileTest;
#line 99
enum __anonenum__93 {
    G_FILE_SET_CONTENTS_NONE = 0,
    G_FILE_SET_CONTENTS_CONSISTENT = 1,
    G_FILE_SET_CONTENTS_DURABLE = 2,
    G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
} ;
#line 105 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__93 GFileSetContentsFlags;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable ;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
typedef struct _GMemVTable GMemVTable;
#line 380 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable {
   gpointer (*malloc)(gsize  ) ;
   gpointer (*realloc)(gpointer  , gsize  ) ;
   void (*free)(gpointer  ) ;
   gpointer (*calloc)(gsize  , gsize  ) ;
   gpointer (*try_malloc)(gsize  ) ;
   gpointer (*try_realloc)(gpointer  , gsize  ) ;
};
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode ;
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
typedef struct _GNode GNode;
#line 39
enum __anonenum__94 {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
    G_TRAVERSE_MASK = 3,
    G_TRAVERSE_LEAFS = 1,
    G_TRAVERSE_NON_LEAFS = 2
} ;
#line 47 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__94 GTraverseFlags;
#line 50
enum __anonenum__95 {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3
} ;
#line 56 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__95 GTraverseType;
#line 58 "/usr/include/glib-2.0/glib/gnode.h"
typedef gboolean (*GNodeTraverseFunc)(GNode * , gpointer  );
#line 60 "/usr/include/glib-2.0/glib/gnode.h"
typedef void (*GNodeForeachFunc)(GNode * , gpointer  );
#line 65 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode {
   gpointer data ;
   GNode *next ;
   GNode *prev ;
   GNode *parent ;
   GNode *children ;
};
#line 37 "/usr/include/glib-2.0/glib/glist.h"
struct _GList ;
#line 37 "/usr/include/glib-2.0/glib/glist.h"
typedef struct _GList GList;
#line 39 "/usr/include/glib-2.0/glib/glist.h"
struct _GList {
   gpointer data ;
   GList *next ;
   GList *prev ;
};
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTable ;
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTable GHashTable;
#line 39 "/usr/include/glib-2.0/glib/ghash.h"
typedef gboolean (*GHRFunc)(gpointer  , gpointer  , gpointer  );
#line 43
struct _GHashTableIter ;
#line 43 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTableIter GHashTableIter;
#line 45 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTableIter {
   gpointer dummy1 ;
   gpointer dummy2 ;
   gpointer dummy3 ;
   int dummy4 ;
   gboolean dummy5 ;
   gpointer dummy6 ;
};
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
struct _GHmac ;
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
typedef struct _GHmac GHmac;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook ;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHook GHook;
#line 39
struct _GHookList ;
#line 39 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHookList GHookList;
#line 41 "/usr/include/glib-2.0/glib/ghook.h"
typedef gint (*GHookCompareFunc)(GHook * , GHook * );
#line 43 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookFindFunc)(GHook * , gpointer  );
#line 45 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookMarshaller)(GHook * , gpointer  );
#line 47 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckMarshaller)(GHook * , gpointer  );
#line 49 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFunc)(gpointer  );
#line 50 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckFunc)(gpointer  );
#line 51 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFinalizeFunc)(GHookList * , GHook * );
#line 53
enum __anonenum__96 {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15
} ;
#line 58 "/usr/include/glib-2.0/glib/ghook.h"
typedef enum __anonenum__96 GHookFlagMask;
#line 63 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHookList {
   gulong seq_id ;
   guint hook_size ;
   guint is_setup ;
   GHook *hooks ;
   gpointer dummy3 ;
   GHookFinalizeFunc finalize_hook ;
   gpointer dummy[2] ;
};
#line 73 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook {
   gpointer data ;
   GHook *next ;
   GHook *prev ;
   guint ref_count ;
   gulong hook_id ;
   guint flags ;
   gpointer func ;
   GDestroyNotify destroy ;
};
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD ;
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
typedef struct _GPollFD GPollFD;
#line 74 "/usr/include/glib-2.0/glib/gpoll.h"
typedef gint (*GPollFunc)(GPollFD * , guint  , gint  );
#line 91 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD {
   gint fd ;
   gushort events ;
   gushort revents ;
};
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList ;
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
typedef struct _GSList GSList;
#line 39 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList {
   gpointer data ;
   GSList *next ;
};
#line 31 "/usr/include/glib-2.0/glib/gmain.h"
enum __anonenum__97 {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32
} ;
#line 39 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__97 GIOCondition;
#line 55
enum __anonenum__98 {
    G_MAIN_CONTEXT_FLAGS_NONE = 0,
    G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
} ;
#line 59 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__98 GMainContextFlags;
#line 68
struct _GMainContext ;
#line 68 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainContext GMainContext;
#line 76
struct _GMainLoop ;
#line 76 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainLoop GMainLoop;
#line 84
struct _GSource ;
#line 84 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSource GSource;
#line 85
struct _GSourcePrivate ;
#line 85 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourcePrivate GSourcePrivate;
#line 97
struct _GSourceCallbackFuncs ;
#line 97 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
#line 153
struct _GSourceFuncs ;
#line 153 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceFuncs GSourceFuncs;
#line 193 "/usr/include/glib-2.0/glib/gmain.h"
typedef gboolean (*GSourceFunc)(gpointer  );
#line 228 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GChildWatchFunc)(GPid  , gint  , gpointer  );
#line 243 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDisposeFunc)(GSource * );
#line 245 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSource {
   gpointer callback_data ;
   GSourceCallbackFuncs *callback_funcs ;
   GSourceFuncs *source_funcs ;
   guint ref_count ;
   GMainContext *context ;
   gint priority ;
   guint flags ;
   guint source_id ;
   GSList *poll_fds ;
   GSource *prev ;
   GSource *next ;
   char *name ;
   GSourcePrivate *priv ;
};
#line 270 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceCallbackFuncs {
   void (*ref)(gpointer  ) ;
   void (*unref)(gpointer  ) ;
   void (*get)(gpointer  , GSource * , GSourceFunc * , gpointer * ) ;
};
#line 286 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDummyMarshal)(void);
#line 288 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceFuncs {
   gboolean (*prepare)(GSource * , gint * ) ;
   gboolean (*check)(GSource * ) ;
   gboolean (*dispatch)(GSource * , GSourceFunc  , gpointer  ) ;
   void (*finalize)(GSource * ) ;
   GSourceFunc closure_callback ;
   GSourceDummyMarshal closure_marshal ;
};
#line 482 "/usr/include/glib-2.0/glib/gmain.h"
typedef void GMainContextPusher;
#line 741 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GClearHandleFunc)(guint  );
#line 59 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint32 gunichar;
#line 77 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint16 gunichar2;
#line 116
enum __anonenum__99 {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29
} ;
#line 148 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__99 GUnicodeType;
#line 213
enum __anonenum__100 {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
} ;
#line 259 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__100 GUnicodeBreakType;
#line 449
enum __anonenum__101 {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
    G_UNICODE_SCRIPT_ELYMAIC = 149,
    G_UNICODE_SCRIPT_NANDINAGARI = 150,
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151,
    G_UNICODE_SCRIPT_WANCHO = 152,
    G_UNICODE_SCRIPT_CHORASMIAN = 153,
    G_UNICODE_SCRIPT_DIVES_AKURU = 154,
    G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155,
    G_UNICODE_SCRIPT_YEZIDI = 156,
    G_UNICODE_SCRIPT_CYPRO_MINOAN = 157,
    G_UNICODE_SCRIPT_OLD_UYGHUR = 158,
    G_UNICODE_SCRIPT_TANGSA = 159,
    G_UNICODE_SCRIPT_TOTO = 160,
    G_UNICODE_SCRIPT_VITHKUQI = 161,
    G_UNICODE_SCRIPT_MATH = 162
} ;
#line 647 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__101 GUnicodeScript;
#line 930
enum __anonenum__102 {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_NFD = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_NFC = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_NFKD = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
    G_NORMALIZE_NFKC = 3
} ;
#line 939 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__102 GNormalizeMode;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString ;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
typedef struct _GString GString;
#line 41 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString {
   gchar *str ;
   gsize len ;
   gsize allocated_len ;
};
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel ;
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOChannel GIOChannel;
#line 42
struct _GIOFuncs ;
#line 42 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOFuncs GIOFuncs;
#line 44
enum __anonenum__103 {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3
} ;
#line 50 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__103 GIOError;
#line 54
enum __anonenum__104 {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8
} ;
#line 67 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__104 GIOChannelError;
#line 69
enum __anonenum__105 {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3
} ;
#line 75 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__105 GIOStatus;
#line 77
enum __anonenum__106 {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2
} ;
#line 82 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__106 GSeekType;
#line 84
enum __anonenum__107 {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_WRITEABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_GET_MASK = 31,
    G_IO_FLAG_SET_MASK = 3
} ;
#line 95 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__107 GIOFlags;
#line 97 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel {
   gint ref_count ;
   GIOFuncs *funcs ;
   gchar *encoding ;
   GIConv read_cd ;
   GIConv write_cd ;
   gchar *line_term ;
   guint line_term_len ;
   gsize buf_size ;
   GString *read_buf ;
   GString *encoded_read_buf ;
   GString *write_buf ;
   gchar partial_write_buf[6] ;
   guint use_buffer ;
   guint do_encode ;
   guint close_on_unref ;
   guint is_readable ;
   guint is_writeable ;
   guint is_seekable ;
   gpointer reserved1 ;
   gpointer reserved2 ;
};
#line 128 "/usr/include/glib-2.0/glib/giochannel.h"
typedef gboolean (*GIOFunc)(GIOChannel * , GIOCondition  , gpointer  );
#line 131 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOFuncs {
   GIOStatus (*io_read)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_write)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_seek)(GIOChannel * , gint64  , GSeekType  , GError ** ) ;
   GIOStatus (*io_close)(GIOChannel * , GError ** ) ;
   GSource *(*io_create_watch)(GIOChannel * , GIOCondition  ) ;
   void (*io_free)(GIOChannel * ) ;
   GIOStatus (*io_set_flags)(GIOChannel * , GIOFlags  , GError ** ) ;
   GIOFlags (*io_get_flags)(GIOChannel * ) ;
};
#line 33 "/usr/include/glib-2.0/glib/gkeyfile.h"
enum __anonenum__108 {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5
} ;
#line 41 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__108 GKeyFileError;
#line 48
struct _GKeyFile ;
#line 48 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef struct _GKeyFile GKeyFile;
#line 50
enum __anonenum__109 {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2
} ;
#line 55 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__109 GKeyFileFlags;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
struct _GMappedFile ;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
typedef struct _GMappedFile GMappedFile;
#line 49 "/usr/include/glib-2.0/glib/gmarkup.h"
enum __anonenum__110 {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
} ;
#line 61 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__110 GMarkupError;
#line 95
enum __anonenum__111 {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8
} ;
#line 101 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__111 GMarkupParseFlags;
#line 112
struct _GMarkupParseContext ;
#line 112 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParseContext GMarkupParseContext;
#line 113
struct _GMarkupParser ;
#line 113 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParser GMarkupParser;
#line 143 "/usr/include/glib-2.0/glib/gmarkup.h"
struct _GMarkupParser {
   void (*start_element)(GMarkupParseContext * , gchar * , gchar ** , gchar ** , gpointer  ,
                         GError ** ) ;
   void (*end_element)(GMarkupParseContext * , gchar * , gpointer  , GError ** ) ;
   void (*text)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*passthrough)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*error)(GMarkupParseContext * , GError * , gpointer  ) ;
};
#line 237
enum __anonenum__112 {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536
} ;
#line 246 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__112 GMarkupCollectType;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
struct _GVariantType ;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
typedef struct _GVariantType GVariantType;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariant ;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariant GVariant;
#line 36
enum __anonenum__113 {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123
} ;
#line 56 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__113 GVariantClass;
#line 268
struct _GVariantIter ;
#line 268 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantIter GVariantIter;
#line 269 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantIter {
   gsize x[16] ;
};
#line 297
struct _GVariantBuilder ;
#line 297 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantBuilder GVariantBuilder;
#line 302 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_115 {
   gsize partial_magic ;
   GVariantType *type ;
   gsize y[14] ;
};
#line 300 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_114 {
   struct __anonstruct_115 s ;
   gsize x[16] ;
};
#line 298 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantBuilder {
   union __anonunion_114 u ;
};
#line 311
enum __anonenum__116 {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
    G_VARIANT_PARSE_ERROR_RECURSION = 18
} ;
#line 332 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__116 GVariantParseError;
#line 446
struct _GVariantDict ;
#line 446 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantDict GVariantDict;
#line 451 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_118 {
   GVariant *asv ;
   gsize partial_magic ;
   gsize y[14] ;
};
#line 449 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_117 {
   struct __anonstruct_118 s ;
   gsize x[16] ;
};
#line 447 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantDict {
   union __anonunion_117 u ;
};
#line 53 "/usr/include/glib-2.0/glib/gmessages.h"
enum __anonenum__119 {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4
} ;
#line 68 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__119 GLogLevelFlags;
#line 73 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GLogFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 134
enum __anonenum__120 {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0
} ;
#line 138 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__120 GLogWriterOutput;
#line 156
struct _GLogField ;
#line 156 "/usr/include/glib-2.0/glib/gmessages.h"
typedef struct _GLogField GLogField;
#line 157 "/usr/include/glib-2.0/glib/gmessages.h"
struct _GLogField {
   gchar *key ;
   gconstpointer value ;
   gssize length ;
};
#line 195 "/usr/include/glib-2.0/glib/gmessages.h"
typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags  , GLogField * , gsize  ,
                                           gpointer  );
#line 515 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GPrintFunc)(gchar * );
#line 38 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionContext ;
#line 38 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionContext GOptionContext;
#line 51
struct _GOptionGroup ;
#line 51 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionGroup GOptionGroup;
#line 52
struct _GOptionEntry ;
#line 52 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionEntry GOptionEntry;
#line 81
enum __anonenum__121 {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64
} ;
#line 91 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__121 GOptionFlags;
#line 119
enum __anonenum__122 {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8
} ;
#line 130 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__122 GOptionArg;
#line 149 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionArgFunc)(gchar * , gchar * , gpointer  , GError ** );
#line 167 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionParseFunc)(GOptionContext * , GOptionGroup * , gpointer  ,
                                     GError ** );
#line 182 "/usr/include/glib-2.0/glib/goption.h"
typedef void (*GOptionErrorFunc)(GOptionContext * , GOptionGroup * , gpointer  , GError ** );
#line 206
enum __anonenum__123 {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2
} ;
#line 211 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__123 GOptionError;
#line 258 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionEntry {
   gchar *long_name ;
   gchar short_name ;
   gint flags ;
   GOptionArg arg ;
   gpointer arg_data ;
   gchar *description ;
   gchar *arg_description ;
};
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
struct _GPatternSpec ;
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
typedef struct _GPatternSpec GPatternSpec;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue ;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
typedef struct _GQueue GQueue;
#line 47 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue {
   GList *head ;
   GList *tail ;
   guint length ;
};
#line 36 "/usr/include/glib-2.0/glib/grand.h"
struct _GRand ;
#line 36 "/usr/include/glib-2.0/glib/grand.h"
typedef struct _GRand GRand;
#line 55 "/usr/include/glib-2.0/glib/grefstring.h"
typedef char GRefString;
#line 140 "/usr/include/glib-2.0/glib/gregex.h"
enum __anonenum__124 {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} ;
#line 201 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__124 GRegexError;
#line 296
enum __anonenum__125 {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432
} ;
#line 316 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__125 GRegexCompileFlags;
#line 386
enum __anonenum__126 {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_SOFT = 32768,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
} ;
#line 403 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__126 GRegexMatchFlags;
#line 413
struct _GRegex ;
#line 413 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GRegex GRegex;
#line 422
struct _GMatchInfo ;
#line 422 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GMatchInfo GMatchInfo;
#line 441 "/usr/include/glib-2.0/glib/gregex.h"
typedef gboolean (*GRegexEvalCallback)(GMatchInfo * , GString * , gpointer  );
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner ;
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScanner GScanner;
#line 38
struct _GScannerConfig ;
#line 38 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScannerConfig GScannerConfig;
#line 39
union _GTokenValue ;
#line 39 "/usr/include/glib-2.0/glib/gscanner.h"
typedef union _GTokenValue GTokenValue;
#line 41 "/usr/include/glib-2.0/glib/gscanner.h"
typedef void (*GScannerMsgFunc)(GScanner * , gchar * , gboolean  );
#line 62
enum __anonenum__127 {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__127 GErrorType;
#line 75
enum __anonenum__128 {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270
} ;
#line 109 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__128 GTokenType;
#line 111 "/usr/include/glib-2.0/glib/gscanner.h"
union _GTokenValue {
   gpointer v_symbol ;
   gchar *v_identifier ;
   gulong v_binary ;
   gulong v_octal ;
   gulong v_int ;
   guint64 v_int64 ;
   gdouble v_float ;
   gulong v_hex ;
   gchar *v_string ;
   gchar *v_comment ;
   guchar v_char ;
   guint v_error ;
};
#line 127 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScannerConfig {
   gchar *cset_skip_characters ;
   gchar *cset_identifier_first ;
   gchar *cset_identifier_nth ;
   gchar *cpair_comment_single ;
   guint case_sensitive ;
   guint skip_comment_multi ;
   guint skip_comment_single ;
   guint scan_comment_multi ;
   guint scan_identifier ;
   guint scan_identifier_1char ;
   guint scan_identifier_NULL ;
   guint scan_symbols ;
   guint scan_binary ;
   guint scan_octal ;
   guint scan_float ;
   guint scan_hex ;
   guint scan_hex_dollar ;
   guint scan_string_sq ;
   guint scan_string_dq ;
   guint numbers_2_int ;
   guint int_2_float ;
   guint identifier_2_string ;
   guint char_2_token ;
   guint symbol_2_token ;
   guint scope_0_fallback ;
   guint store_int64 ;
   guint padding_dummy ;
};
#line 169 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner {
   gpointer user_data ;
   guint max_parse_errors ;
   guint parse_errors ;
   gchar *input_name ;
   GData *qdata ;
   GScannerConfig *config ;
   GTokenType token ;
   GTokenValue value ;
   guint line ;
   guint position ;
   GTokenType next_token ;
   GTokenValue next_value ;
   guint next_line ;
   guint next_position ;
   GHashTable *symbol_table ;
   gint input_fd ;
   gchar *text ;
   gchar *text_end ;
   gchar *buffer ;
   guint scope_id ;
   GScannerMsgFunc msg_handler ;
};
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
struct _GSequence ;
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequence GSequence;
#line 31
struct _GSequenceNode ;
#line 31 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequenceNode GSequenceIter;
#line 33 "/usr/include/glib-2.0/glib/gsequence.h"
typedef gint (*GSequenceIterCompareFunc)(GSequenceIter * , GSequenceIter * , gpointer  );
#line 32 "/usr/include/glib-2.0/glib/gshell.h"
enum __anonenum__129 {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2
} ;
#line 39 "/usr/include/glib-2.0/glib/gshell.h"
typedef enum __anonenum__129 GShellError;
#line 92 "/usr/include/glib-2.0/glib/gslice.h"
enum __anonenum__130 {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6
} ;
#line 99 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum __anonenum__130 GSliceConfig;
#line 68 "/usr/include/glib-2.0/glib/gspawn.h"
enum __anonenum__131 {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_2BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19
} ;
#line 93 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__131 GSpawnError;
#line 138 "/usr/include/glib-2.0/glib/gspawn.h"
typedef void (*GSpawnChildSetupFunc)(gpointer  );
#line 168
enum __anonenum__132 {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256
} ;
#line 182 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__132 GSpawnFlags;
#line 40 "/usr/include/glib-2.0/glib/gstrfuncs.h"
enum __anonenum__133 {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024
} ;
#line 52 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__133 GAsciiType;
#line 273 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef gchar **GStrv;
#line 329
enum __anonenum__134 {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
} ;
#line 333 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__134 GNumberParserError;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
struct _GStringChunk ;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
typedef struct _GStringChunk GStringChunk;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
struct _GStrvBuilder ;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
typedef struct _GStrvBuilder GStrvBuilder;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
struct GTestCase ;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestCase GTestCase;
#line 36
struct GTestSuite ;
#line 36 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestSuite GTestSuite;
#line 37 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFunc)(void);
#line 38 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestDataFunc)(gconstpointer  );
#line 39 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFixtureFunc)(gpointer  , gconstpointer  );
#line 445
enum __anonenum__135 {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512
} ;
#line 449 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__135 GTestTrapFlags;
#line 459
enum __anonenum__136 {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4
} ;
#line 463 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__136 GTestSubprocessFlags;
#line 590 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_137 {
   gboolean test_initialized ;
   gboolean test_quick ;
   gboolean test_perf ;
   gboolean test_verbose ;
   gboolean test_quiet ;
   gboolean test_undefined ;
};
#line 597 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_137 GTestConfig;
#line 601
enum __anonenum__138 {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3
} ;
#line 606 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__138 GTestResult;
#line 608
enum __anonenum__139 {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11
} ;
#line 621 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__139 GTestLogType;
#line 623 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_140 {
   GTestLogType log_type ;
   guint n_strings ;
   gchar **strings ;
   guint n_nums ;
   long double *nums ;
};
#line 629 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_140 GTestLogMsg;
#line 630 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_141 {
   GString *data ;
   GSList *msgs ;
};
#line 634 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_141 GTestLogBuffer;
#line 664 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef gboolean (*GTestLogFatalFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 683
enum __anonenum__142 {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1
} ;
#line 687 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__142 GTestFileType;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool ;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
typedef struct _GThreadPool GThreadPool;
#line 41 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool {
   GFunc func ;
   gpointer user_data ;
   gboolean exclusive ;
};
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
struct _GTimer ;
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
typedef struct _GTimer GTimer;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack ;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
typedef struct _GTrashStack GTrashStack;
#line 39 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack {
   GTrashStack *next ;
};
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
struct _GTree ;
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTree GTree;
#line 47
struct _GTreeNode ;
#line 47 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTreeNode GTreeNode;
#line 49 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseFunc)(gpointer  , gpointer  , gpointer  );
#line 66 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseNodeFunc)(GTreeNode * , gpointer  );
#line 31 "/usr/include/glib-2.0/glib/guri.h"
struct _GUri ;
#line 31 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUri GUri;
#line 80
enum __anonenum__143 {
    G_URI_FLAGS_NONE = 0,
    G_URI_FLAGS_PARSE_RELAXED = 1,
    G_URI_FLAGS_HAS_PASSWORD = 2,
    G_URI_FLAGS_HAS_AUTH_PARAMS = 4,
    G_URI_FLAGS_ENCODED = 8,
    G_URI_FLAGS_NON_DNS = 16,
    G_URI_FLAGS_ENCODED_QUERY = 32,
    G_URI_FLAGS_ENCODED_PATH = 64,
    G_URI_FLAGS_ENCODED_FRAGMENT = 128,
    G_URI_FLAGS_SCHEME_NORMALIZE = 256
} ;
#line 91 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__143 GUriFlags;
#line 205
enum __anonenum__144 {
    G_URI_HIDE_NONE = 0,
    G_URI_HIDE_USERINFO = 1,
    G_URI_HIDE_PASSWORD = 2,
    G_URI_HIDE_AUTH_PARAMS = 4,
    G_URI_HIDE_QUERY = 8,
    G_URI_HIDE_FRAGMENT = 16
} ;
#line 212 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__144 GUriHideFlags;
#line 257
enum __anonenum__145 {
    G_URI_PARAMS_NONE = 0,
    G_URI_PARAMS_CASE_INSENSITIVE = 1,
    G_URI_PARAMS_WWW_FORM = 2,
    G_URI_PARAMS_PARSE_RELAXED = 4
} ;
#line 262 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__145 GUriParamsFlags;
#line 271
struct _GUriParamsIter ;
#line 271 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUriParamsIter GUriParamsIter;
#line 273 "/usr/include/glib-2.0/glib/guri.h"
struct _GUriParamsIter {
   gint dummy0 ;
   gpointer dummy1 ;
   gpointer dummy2 ;
   guint8 dummy3[256] ;
};
#line 326
enum __anonenum__146 {
    G_URI_ERROR_FAILED = 0,
    G_URI_ERROR_BAD_SCHEME = 1,
    G_URI_ERROR_BAD_USER = 2,
    G_URI_ERROR_BAD_PASSWORD = 3,
    G_URI_ERROR_BAD_AUTH_PARAMS = 4,
    G_URI_ERROR_BAD_HOST = 5,
    G_URI_ERROR_BAD_PORT = 6,
    G_URI_ERROR_BAD_PATH = 7,
    G_URI_ERROR_BAD_QUERY = 8,
    G_URI_ERROR_BAD_FRAGMENT = 9
} ;
#line 337 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__146 GUriError;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
struct _GAllocator ;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GAllocator GAllocator;
#line 28
struct _GMemChunk ;
#line 28 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GMemChunk GMemChunk;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
struct _GCache ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef struct _GCache GCache;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheNewFunc)(gpointer  );
#line 39 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheDupFunc)(gpointer  );
#line 40 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef void (*GCacheDestroyFunc)(gpointer  );
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef struct _GCompletion GCompletion;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gchar *(*GCompletionFunc)(gpointer  );
#line 43 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gint (*GCompletionStrncmpFunc)(gchar * , gchar * , gsize  );
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion {
   GList *items ;
   GCompletionFunc func ;
   gchar *prefix ;
   GList *cache ;
   GCompletionStrncmpFunc strncmp_func ;
};
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GRelation ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GRelation GRelation;
#line 37
struct _GTuples ;
#line 37 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GTuples GTuples;
#line 39 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GTuples {
   guint len ;
};
#line 38 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
enum __anonenum__147 {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3
} ;
#line 44 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef enum __anonenum__147 GThreadPriority;
#line 46 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThread {
   GThreadFunc func ;
   gpointer data ;
   gboolean joinable ;
   GThreadPriority priority ;
};
#line 55
struct _GThreadFunctions ;
#line 55 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GThreadFunctions GThreadFunctions;
#line 56 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThreadFunctions {
   GMutex *(*mutex_new)(void) ;
   void (*mutex_lock)(GMutex * ) ;
   gboolean (*mutex_trylock)(GMutex * ) ;
   void (*mutex_unlock)(GMutex * ) ;
   void (*mutex_free)(GMutex * ) ;
   GCond *(*cond_new)(void) ;
   void (*cond_signal)(GCond * ) ;
   void (*cond_broadcast)(GCond * ) ;
   void (*cond_wait)(GCond * , GMutex * ) ;
   gboolean (*cond_timed_wait)(GCond * , GMutex * , GTimeVal * ) ;
   void (*cond_free)(GCond * ) ;
   GPrivate *(*private_new)(GDestroyNotify  ) ;
   gpointer (*private_get)(GPrivate * ) ;
   void (*private_set)(GPrivate * , gpointer  ) ;
   void (*thread_create)(GThreadFunc  , gpointer  , gulong  , gboolean  , gboolean  ,
                         GThreadPriority  , gpointer  , GError ** ) ;
   void (*thread_yield)(void) ;
   void (*thread_join)(gpointer  ) ;
   void (*thread_exit)(void) ;
   void (*thread_set_priority)(gpointer  , GThreadPriority  ) ;
   void (*thread_self)(gpointer  ) ;
   gboolean (*thread_equal)(gpointer  , gpointer  ) ;
};
#line 133 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct __anonstruct_148 {
   GMutex *mutex ;
   pthread_mutex_t unused ;
};
#line 140 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct __anonstruct_148 GStaticMutex;
#line 156
struct _GStaticRecMutex ;
#line 156 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRecMutex GStaticRecMutex;
#line 164 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
union __anonunion_149 {
   pthread_t owner ;
   gdouble dummy ;
};
#line 157 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRecMutex {
   GStaticMutex mutex ;
   guint depth ;
   union __anonunion_149 unused ;
};
#line 197
struct _GStaticRWLock ;
#line 197 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRWLock GStaticRWLock;
#line 198 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRWLock {
   GStaticMutex mutex ;
   GCond *read_cond ;
   GCond *write_cond ;
   guint read_counter ;
   gboolean have_writer ;
   guint want_to_read ;
   guint want_to_write ;
};
#line 239
struct _GStaticPrivate ;
#line 239 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticPrivate GStaticPrivate;
#line 240 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticPrivate {
   guint index ;
};
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GAsyncQueue *GAsyncQueue_autoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GAsyncQueue_listautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GAsyncQueue_slistautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GAsyncQueue_queueautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBookmarkFile *GBookmarkFile_autoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBookmarkFile_listautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBookmarkFile_slistautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBookmarkFile_queueautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBytes *GBytes_autoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBytes_listautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBytes_slistautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBytes_queueautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GChecksum *GChecksum_autoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GChecksum_listautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GChecksum_slistautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GChecksum_queueautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDateTime *GDateTime_autoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDateTime_listautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDateTime_slistautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDateTime_queueautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDate *GDate_autoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDate_listautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDate_slistautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDate_queueautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDir *GDir_autoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDir_listautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDir_slistautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDir_queueautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GError *GError_autoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GError_listautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GError_slistautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GError_queueautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHashTable *GHashTable_autoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHashTable_listautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHashTable_slistautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHashTable_queueautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHmac *GHmac_autoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHmac_listautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHmac_slistautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHmac_queueautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GIOChannel *GIOChannel_autoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GIOChannel_listautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GIOChannel_slistautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GIOChannel_queueautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GKeyFile *GKeyFile_autoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GKeyFile_listautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GKeyFile_slistautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GKeyFile_queueautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_autoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_listautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GList_slistautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GList_queueautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GArray *GArray_autoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GArray_listautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GArray_slistautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GArray_queueautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPtrArray *GPtrArray_autoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPtrArray_listautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPtrArray_slistautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPtrArray_queueautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GByteArray *GByteArray_autoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GByteArray_listautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GByteArray_slistautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GByteArray_queueautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContext *GMainContext_autoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContext_listautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContext_slistautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContext_queueautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContextPusher *GMainContextPusher_autoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContextPusher_listautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContextPusher_slistautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContextPusher_queueautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainLoop *GMainLoop_autoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainLoop_listautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainLoop_slistautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainLoop_queueautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSource *GSource_autoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSource_listautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSource_slistautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSource_queueautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMappedFile *GMappedFile_autoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMappedFile_listautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMappedFile_slistautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMappedFile_queueautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMarkupParseContext *GMarkupParseContext_autoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMarkupParseContext_listautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMarkupParseContext_slistautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMarkupParseContext_queueautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GNode *GNode_autoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GNode_listautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GNode_slistautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GNode_queueautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionContext *GOptionContext_autoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionContext_listautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionContext_slistautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionContext_queueautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionGroup *GOptionGroup_autoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionGroup_listautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionGroup_slistautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionGroup_queueautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPatternSpec *GPatternSpec_autoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPatternSpec_listautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPatternSpec_slistautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPatternSpec_queueautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_autoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GQueue_listautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GQueue_slistautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_queueautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRand *GRand_autoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRand_listautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRand_slistautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRand_queueautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRegex *GRegex_autoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRegex_listautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRegex_slistautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRegex_queueautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMatchInfo *GMatchInfo_autoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMatchInfo_listautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMatchInfo_slistautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMatchInfo_queueautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GScanner *GScanner_autoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GScanner_listautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GScanner_slistautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GScanner_queueautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSequence *GSequence_autoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSequence_listautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSequence_slistautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSequence_queueautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_autoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSList_listautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_slistautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSList_queueautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GString *GString_autoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GString_listautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GString_slistautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GString_queueautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStringChunk *GStringChunk_autoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStringChunk_listautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStringChunk_slistautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStringChunk_queueautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStrvBuilder *GStrvBuilder_autoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStrvBuilder_listautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStrvBuilder_slistautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStrvBuilder_queueautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GThread *GThread_autoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GThread_listautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GThread_slistautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GThread_queueautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMutexLocker *GMutexLocker_autoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMutexLocker_listautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMutexLocker_slistautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMutexLocker_queueautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRecMutexLocker *GRecMutexLocker_autoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRecMutexLocker_listautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRecMutexLocker_slistautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRecMutexLocker_queueautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockWriterLocker *GRWLockWriterLocker_autoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockWriterLocker_listautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockWriterLocker_slistautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockWriterLocker_queueautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockReaderLocker *GRWLockReaderLocker_autoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockReaderLocker_listautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockReaderLocker_slistautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockReaderLocker_queueautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimer *GTimer_autoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimer_listautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimer_slistautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimer_queueautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimeZone *GTimeZone_autoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimeZone_listautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimeZone_slistautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimeZone_queueautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTree *GTree_autoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTree_listautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTree_slistautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTree_queueautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariant *GVariant_autoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariant_listautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariant_slistautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariant_queueautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantBuilder *GVariantBuilder_autoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantBuilder_listautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantBuilder_slistautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantBuilder_queueautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantIter *GVariantIter_autoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantIter_listautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantIter_slistautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantIter_queueautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantDict *GVariantDict_autoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantDict_listautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantDict_slistautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantDict_queueautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantType *GVariantType_autoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantType_listautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantType_slistautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantType_queueautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRefString *GRefString_autoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRefString_listautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRefString_slistautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRefString_queueautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GUri *GUri_autoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GUri_listautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GUri_slistautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GUri_queueautoptr;
#line 32 "../../include/spd_audio_plugin.h"
enum __anonenum__150 {
    SPD_AUDIO_LE = 0,
    SPD_AUDIO_BE = 1
} ;
#line 32 "../../include/spd_audio_plugin.h"
typedef enum __anonenum__150 AudioFormat;
#line 34 "../../include/spd_audio_plugin.h"
struct __anonstruct_151 {
   int bits ;
   int num_channels ;
   int sample_rate ;
   int num_samples ;
   short *samples ;
};
#line 41 "../../include/spd_audio_plugin.h"
typedef struct __anonstruct_151 AudioTrack;
#line 43
struct spd_audio_plugin ;
#line 45 "../../include/spd_audio_plugin.h"
struct __anonstruct_152 {
   int volume ;
   AudioFormat format ;
   struct spd_audio_plugin *function ;
   void *private_data ;
   int working ;
};
#line 54 "../../include/spd_audio_plugin.h"
typedef struct __anonstruct_152 AudioID;
#line 56 "../../include/spd_audio_plugin.h"
struct spd_audio_plugin {
   char const   *name ;
   AudioID *(*open)(void ** ) ;
   int (*play)(AudioID * , AudioTrack  ) ;
   int (*stop)(AudioID * ) ;
   int (*close)(AudioID * ) ;
   int (*set_volume)(AudioID * , int  ) ;
   void (*set_loglevel)(int  ) ;
   char const   *(*get_playcmd)(void) ;
   int (*begin)(AudioID * , AudioTrack  ) ;
   int (*feed_sync)(AudioID * , AudioTrack  ) ;
   int (*feed_sync_overlap)(AudioID * , AudioTrack  ) ;
   int (*end)(AudioID * ) ;
};
#line 83 "../../include/spd_audio_plugin.h"
typedef struct spd_audio_plugin spd_audio_plugin_t;
#line 138 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
enum __anonenum__153 {
    SPEAK_QUEUE_QET_AUDIO = 0,
    SPEAK_QUEUE_QET_INDEX_MARK = 1,
    SPEAK_QUEUE_QET_SOUND_ICON = 2,
    SPEAK_QUEUE_QET_BEGIN = 3,
    SPEAK_QUEUE_QET_END = 4,
    SPEAK_QUEUE_QET_PAUSE = 5,
    SPEAK_QUEUE_QET_STOP = 6,
    SPEAK_QUEUE_QET_BROKEN = 7
} ;
#line 147 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
typedef enum __anonenum__153 speak_queue_entry_type;
#line 149 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
struct __anonstruct_154 {
   AudioTrack track ;
   AudioFormat format ;
};
#line 152 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
typedef struct __anonstruct_154 speak_queue_audio_chunk;
#line 156 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
union __anonunion_156 {
   char *markId ;
   speak_queue_audio_chunk audio ;
   char *sound_icon_filename ;
};
#line 154 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
struct __anonstruct_155 {
   speak_queue_entry_type type ;
   union __anonunion_156 data ;
};
#line 161 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
typedef struct __anonstruct_155 speak_queue_entry;
#line 34 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
enum __anonenum__157 {
    IDLE = 0,
    BEFORE_SYNTH = 1,
    BEFORE_PLAY = 2,
    SPEAKING___0 = 3
} ;
#line 39 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
typedef enum __anonenum__157 speak_queue_state_t;
#line 41
enum __anonenum__158 {
    SPEAK_QUEUE_PAUSE_OFF = 0,
    SPEAK_QUEUE_PAUSE_REQUESTED = 1,
    SPEAK_QUEUE_PAUSE_MARK_REPORTED = 2
} ;
#line 45 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
typedef enum __anonenum__158 speak_queue_pause_state_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 114
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 130 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 143 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__167 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__168 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum__169 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__182 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum__183 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 69
enum __anonenum__184 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum__185 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum__186 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum__187 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum__188 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum__189 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum__190 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum__191 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__214 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__215 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__216 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__217 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__218 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 176
enum __anonenum__219 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__220 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__223 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__228 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__236 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 68 "/usr/include/libltdl/lt_error.h"
enum __anonenum__295 {
    LT_ERROR_UNKNOWN = 0,
    LT_ERROR_DLOPEN_NOT_SUPPORTED = 1,
    LT_ERROR_INVALID_LOADER = 2,
    LT_ERROR_INIT_LOADER = 3,
    LT_ERROR_REMOVE_LOADER = 4,
    LT_ERROR_FILE_NOT_FOUND = 5,
    LT_ERROR_DEPLIB_NOT_FOUND = 6,
    LT_ERROR_NO_SYMBOLS = 7,
    LT_ERROR_CANNOT_OPEN = 8,
    LT_ERROR_CANNOT_CLOSE = 9,
    LT_ERROR_SYMBOL_NOT_FOUND = 10,
    LT_ERROR_NO_MEMORY = 11,
    LT_ERROR_INVALID_HANDLE = 12,
    LT_ERROR_BUFFER_OVERFLOW = 13,
    LT_ERROR_INVALID_ERRORCODE = 14,
    LT_ERROR_SHUTDOWN = 15,
    LT_ERROR_CLOSE_RESIDENT_MODULE = 16,
    LT_ERROR_INVALID_MUTEX_ARGS = 17,
    LT_ERROR_INVALID_POSITION = 18,
    LT_ERROR_CONFLICTING_FLAGS = 19,
    LT_ERROR_MAX = 20
} ;
#line 39 "/usr/include/libltdl/lt_dlloader.h"
typedef void *lt_dlloader;
#line 40 "/usr/include/libltdl/lt_dlloader.h"
typedef void *lt_module;
#line 41 "/usr/include/libltdl/lt_dlloader.h"
typedef void *lt_user_data;
#line 42
struct lt__advise ;
#line 42 "/usr/include/libltdl/lt_dlloader.h"
typedef struct lt__advise *lt_dladvise;
#line 45 "/usr/include/libltdl/lt_dlloader.h"
typedef lt_module lt_module_open(lt_user_data  , char const   * , lt_dladvise  );
#line 48 "/usr/include/libltdl/lt_dlloader.h"
typedef int lt_module_close(lt_user_data  , lt_module  );
#line 50 "/usr/include/libltdl/lt_dlloader.h"
typedef void *lt_find_sym(lt_user_data  , lt_module  , char const   * );
#line 52 "/usr/include/libltdl/lt_dlloader.h"
typedef int lt_dlloader_init(lt_user_data  );
#line 53 "/usr/include/libltdl/lt_dlloader.h"
typedef int lt_dlloader_exit(lt_user_data  );
#line 56
enum __anonenum__296 {
    LT_DLLOADER_PREPEND = 0,
    LT_DLLOADER_APPEND = 1
} ;
#line 58 "/usr/include/libltdl/lt_dlloader.h"
typedef enum __anonenum__296 lt_dlloader_priority;
#line 62 "/usr/include/libltdl/lt_dlloader.h"
struct __anonstruct_297 {
   char const   *name ;
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_init *dlloader_init ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
   lt_dlloader_priority priority ;
};
#line 72 "/usr/include/libltdl/lt_dlloader.h"
typedef struct __anonstruct_297 lt_dlvtable;
#line 83 "/usr/include/libltdl/lt_dlloader.h"
typedef lt_dlvtable *lt_get_vtable(lt_user_data  );
#line 50 "/usr/include/ltdl.h"
struct lt__handle ;
#line 50 "/usr/include/ltdl.h"
typedef struct lt__handle *lt_dlhandle;
#line 92 "/usr/include/ltdl.h"
struct __anonstruct_298 {
   char const   *name ;
   void *address ;
};
#line 95 "/usr/include/ltdl.h"
typedef struct __anonstruct_298 lt_dlsymlist;
#line 97 "/usr/include/ltdl.h"
typedef int lt_dlpreload_callback_func(lt_dlhandle  );
#line 118 "/usr/include/ltdl.h"
typedef void *lt_dlinterface_id;
#line 119 "/usr/include/ltdl.h"
typedef int lt_dlhandle_interface(lt_dlhandle  , char const   * );
#line 131 "/usr/include/ltdl.h"
struct __anonstruct_299 {
   char *filename ;
   char *name ;
   int ref_count ;
   unsigned int is_resident ;
   unsigned int is_symglobal ;
   unsigned int is_symlocal ;
};
#line 141 "/usr/include/ltdl.h"
typedef struct __anonstruct_299 lt_dlinfo;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__334 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__335 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__336 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__337 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__338 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 176
enum __anonenum__339 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__340 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__343 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__348 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__356 {
    DT_UNKNOWN___1 = 0,
    DT_FIFO___1 = 1,
    DT_CHR___1 = 2,
    DT_DIR___1 = 4,
    DT_BLK___1 = 6,
    DT_REG___1 = 8,
    DT_LNK___1 = 10,
    DT_SOCK___1 = 12,
    DT_WHT___1 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__415 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 47
enum __anonenum__416 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 69
enum __anonenum__417 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 81
enum __anonenum__418 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 104
enum __anonenum__419 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 124
enum __anonenum__420 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 134
enum __anonenum__421 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 144
enum __anonenum__422 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 168
enum __anonenum__423 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 175
enum __anonenum__424 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__334___0 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__335___0 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__336___0 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__337___0 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
#line 142
enum __anonenum__338___0 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 176
enum __anonenum__339___0 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 193
enum __anonenum__340___0 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__343___0 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__348___0 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__356___0 {
    DT_UNKNOWN___2 = 0,
    DT_FIFO___2 = 1,
    DT_CHR___2 = 2,
    DT_DIR___2 = 4,
    DT_BLK___2 = 6,
    DT_REG___2 = 8,
    DT_LNK___2 = 10,
    DT_SOCK___2 = 12,
    DT_WHT___2 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__415___0 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 47
enum __anonenum__416___0 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 69
enum __anonenum__417___0 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 81
enum __anonenum__418___0 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 104
enum __anonenum__419___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 124
enum __anonenum__420___0 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 134
enum __anonenum__421___0 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 144
enum __anonenum__422___0 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 168
enum __anonenum__423___0 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 175
enum __anonenum__424___0 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 24 "../../include/speechd_types.h"
enum __anonenum__432 {
    SPD_PUNCT_ALL = 0,
    SPD_PUNCT_NONE = 1,
    SPD_PUNCT_SOME = 2,
    SPD_PUNCT_MOST = 3
} ;
#line 29 "../../include/speechd_types.h"
typedef enum __anonenum__432 SPDPunctuation;
#line 31
enum __anonenum__433 {
    SPD_CAP_NONE = 0,
    SPD_CAP_SPELL = 1,
    SPD_CAP_ICON = 2
} ;
#line 35 "../../include/speechd_types.h"
typedef enum __anonenum__433 SPDCapitalLetters;
#line 37
enum __anonenum__434 {
    SPD_SPELL_OFF = 0,
    SPD_SPELL_ON = 1
} ;
#line 40 "../../include/speechd_types.h"
typedef enum __anonenum__434 SPDSpelling;
#line 42
enum __anonenum__435 {
    SPD_MALE1 = 1,
    SPD_MALE2 = 2,
    SPD_MALE3 = 3,
    SPD_FEMALE1 = 4,
    SPD_FEMALE2 = 5,
    SPD_FEMALE3 = 6,
    SPD_CHILD_MALE = 7,
    SPD_CHILD_FEMALE = 8,
    SPD_UNSPECIFIED = -1
} ;
#line 52 "../../include/speechd_types.h"
typedef enum __anonenum__435 SPDVoiceType;
#line 54 "../../include/speechd_types.h"
struct __anonstruct_436 {
   char *name ;
   char *language ;
   char *variant ;
};
#line 60 "../../include/speechd_types.h"
typedef struct __anonstruct_436 SPDVoice;
#line 62
enum __anonenum__437 {
    SPD_DATA_TEXT = 0,
    SPD_DATA_SSML = 1
} ;
#line 65 "../../include/speechd_types.h"
typedef enum __anonenum__437 SPDDataMode;
#line 67
enum __anonenum__438 {
    SPD_IMPORTANT = 1,
    SPD_MESSAGE = 2,
    SPD_TEXT = 3,
    SPD_NOTIFICATION = 4,
    SPD_PROGRESS = 5
} ;
#line 73 "../../include/speechd_types.h"
typedef enum __anonenum__438 SPDPriority;
#line 75
enum __anonenum__439 {
    SPD_BEGIN = 1,
    SPD_END = 2,
    SPD_INDEX_MARKS = 4,
    SPD_CANCEL = 8,
    SPD_PAUSE = 16,
    SPD_RESUME = 32,
    SPD_ALL = 63
} ;
#line 84 "../../include/speechd_types.h"
typedef enum __anonenum__439 SPDNotification;
#line 86
enum __anonenum__440 {
    SPD_EVENT_BEGIN = 0,
    SPD_EVENT_END = 1,
    SPD_EVENT_INDEX_MARK = 2,
    SPD_EVENT_CANCEL = 3,
    SPD_EVENT_PAUSE = 4,
    SPD_EVENT_RESUME = 5
} ;
#line 93 "../../include/speechd_types.h"
typedef enum __anonenum__440 SPDNotificationType;
#line 95
enum __anonenum__441 {
    SORT_BY_TIME = 0,
    SORT_BY_ALPHABET = 1
} ;
#line 98 "../../include/speechd_types.h"
typedef enum __anonenum__441 ESort;
#line 100
enum __anonenum__442 {
    SPD_MSGTYPE_TEXT = 0,
    SPD_MSGTYPE_SOUND_ICON = 1,
    SPD_MSGTYPE_CHAR = 2,
    SPD_MSGTYPE_KEY = 3,
    SPD_MSGTYPE_SPELL = 99
} ;
#line 106 "../../include/speechd_types.h"
typedef enum __anonenum__442 SPDMessageType;
#line 108 "../../include/speechd_types.h"
struct __anonstruct_443 {
   int rate ;
   int pitch ;
   int pitch_range ;
   int volume ;
   SPDPunctuation punctuation_mode ;
   SPDSpelling spelling_mode ;
   SPDCapitalLetters cap_let_recogn ;
   SPDVoiceType voice_type ;
   SPDVoice voice ;
};
#line 120 "../../include/speechd_types.h"
typedef struct __anonstruct_443 SPDMsgSettings;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__456 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
#line 71
enum __anonenum__457 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
#line 94
enum __anonenum__458 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
#line 119
enum __anonenum__459 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7,
    SEGV_MTEAERR___3 = 8,
    SEGV_MTESERR___3 = 9
} ;
#line 142
enum __anonenum__460 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
#line 176
enum __anonenum__461 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
#line 193
enum __anonenum__462 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__465 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__470 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__483 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 47
enum __anonenum__484 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 69
enum __anonenum__485 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 81
enum __anonenum__486 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 104
enum __anonenum__487 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 124
enum __anonenum__488 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 134
enum __anonenum__489 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 144
enum __anonenum__490 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 168
enum __anonenum__491 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 175
enum __anonenum__492 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 92 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h"
enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048
} ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 193 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[118] ;
   unsigned long __ss_align ;
};
#line 202
enum __anonenum__507 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_TRYHARD = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824
} ;
#line 259 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 277 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 334
enum __anonenum__508 {
    SCM_RIGHTS = 1,
    SCM_CREDENTIALS = 2
} ;
#line 346 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct_509 {
   unsigned long fds_bits[16] ;
};
#line 27 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct_509 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct_510 {
   int val[2] ;
};
#line 81 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct_510 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 363 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h"
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__511 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2
} ;
#line 79
struct sockaddr_at ;
#line 79
struct sockaddr_ax25 ;
#line 79
struct sockaddr_dl ;
#line 79
struct sockaddr_eon ;
#line 79
struct sockaddr_in ;
#line 79
struct sockaddr_in6 ;
#line 79
struct sockaddr_inarp ;
#line 79
struct sockaddr_ipx ;
#line 79
struct sockaddr_iso ;
#line 79
struct sockaddr_ns ;
#line 79
struct sockaddr_un ;
#line 79
struct sockaddr_x25 ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_512 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 80 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_512 __SOCKADDR_ARG;
#line 83 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_513 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 84 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_513 __CONST_SOCKADDR_ARG;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct mmsghdr {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_opts {
   struct in_addr ip_dst ;
   char ip_opts[40] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 158 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__514 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_ETHERNET = 143,
    IPPROTO_RAW = 255,
    IPPROTO_MPTCP = 262,
    IPPROTO_MAX = 263
} ;
#line 103
enum __anonenum__515 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135
} ;
#line 123 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 126
enum __anonenum__516 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000
} ;
#line 221 "/usr/include/netinet/in.h"
union __anonunion_517 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 219 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_517 __in6_u ;
};
#line 245 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 260 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 272 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 281 "/usr/include/netinet/in.h"
struct ip_mreq_source {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
   struct in_addr imr_sourceaddr ;
};
#line 296 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 308 "/usr/include/netinet/in.h"
struct group_req {
   uint32_t gr_interface ;
   struct sockaddr_storage gr_group ;
};
#line 317 "/usr/include/netinet/in.h"
struct group_source_req {
   uint32_t gsr_interface ;
   struct sockaddr_storage gsr_group ;
   struct sockaddr_storage gsr_source ;
};
#line 331 "/usr/include/netinet/in.h"
struct ip_msfilter {
   struct in_addr imsf_multiaddr ;
   struct in_addr imsf_interface ;
   uint32_t imsf_fmode ;
   uint32_t imsf_numsrc ;
   struct in_addr imsf_slist[1] ;
};
#line 352 "/usr/include/netinet/in.h"
struct group_filter {
   uint32_t gf_interface ;
   struct sockaddr_storage gf_group ;
   uint32_t gf_fmode ;
   uint32_t gf_numsrc ;
   struct sockaddr_storage gf_slist[1] ;
};
#line 544 "/usr/include/netinet/in.h"
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
#line 551 "/usr/include/netinet/in.h"
struct ip6_mtuinfo {
   struct sockaddr_in6 ip6m_addr ;
   uint32_t ip6m_mtu ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__528 {
    SI_ASYNCNL___4 = -60,
    SI_DETHREAD___4 = -7,
    SI_TKILL___4 = -6,
    SI_SIGIO___4 = -5,
    SI_ASYNCIO___4 = -4,
    SI_MESGQ___4 = -3,
    SI_TIMER___4 = -2,
    SI_QUEUE___4 = -1,
    SI_USER___4 = 0,
    SI_KERNEL___4 = 128
} ;
#line 71
enum __anonenum__529 {
    ILL_ILLOPC___4 = 1,
    ILL_ILLOPN___4 = 2,
    ILL_ILLADR___4 = 3,
    ILL_ILLTRP___4 = 4,
    ILL_PRVOPC___4 = 5,
    ILL_PRVREG___4 = 6,
    ILL_COPROC___4 = 7,
    ILL_BADSTK___4 = 8,
    ILL_BADIADDR___4 = 9
} ;
#line 94
enum __anonenum__530 {
    FPE_INTDIV___4 = 1,
    FPE_INTOVF___4 = 2,
    FPE_FLTDIV___4 = 3,
    FPE_FLTOVF___4 = 4,
    FPE_FLTUND___4 = 5,
    FPE_FLTRES___4 = 6,
    FPE_FLTINV___4 = 7,
    FPE_FLTSUB___4 = 8,
    FPE_FLTUNK___4 = 14,
    FPE_CONDTRAP___4 = 15
} ;
#line 119
enum __anonenum__531 {
    SEGV_MAPERR___4 = 1,
    SEGV_ACCERR___4 = 2,
    SEGV_BNDERR___4 = 3,
    SEGV_PKUERR___4 = 4,
    SEGV_ACCADI___4 = 5,
    SEGV_ADIDERR___4 = 6,
    SEGV_ADIPERR___4 = 7,
    SEGV_MTEAERR___4 = 8,
    SEGV_MTESERR___4 = 9
} ;
#line 142
enum __anonenum__532 {
    BUS_ADRALN___4 = 1,
    BUS_ADRERR___4 = 2,
    BUS_OBJERR___4 = 3,
    BUS_MCEERR_AR___4 = 4,
    BUS_MCEERR_AO___4 = 5
} ;
#line 159
enum __anonenum__533 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
#line 176
enum __anonenum__534 {
    CLD_EXITED___4 = 1,
    CLD_KILLED___4 = 2,
    CLD_DUMPED___4 = 3,
    CLD_TRAPPED___4 = 4,
    CLD_STOPPED___4 = 5,
    CLD_CONTINUED___4 = 6
} ;
#line 193
enum __anonenum__535 {
    POLL_IN___4 = 1,
    POLL_OUT___4 = 2,
    POLL_MSG___4 = 3,
    POLL_ERR___4 = 4,
    POLL_PRI___4 = 5,
    POLL_HUP___4 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__538 {
    SIGEV_SIGNAL___4 = 0,
    SIGEV_NONE___4 = 1,
    SIGEV_THREAD___4 = 2,
    SIGEV_THREAD_ID___4 = 4
} ;
#line 188 "/usr/include/signal.h"
typedef __sighandler_t sighandler_t;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__542 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__544 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__545 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum__546 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__547 {
    SS_ONSTACK___4 = 1,
    SS_DISABLE___4 = 2
} ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/wait.h"
enum __anonenum__548 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/wait.h"
typedef enum __anonenum__548 idtype_t;
#line 140
struct rusage ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void * , char * , size_t  );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void * , char const   * , size_t  );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void * , __off64_t * , int  );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void * );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 89 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 850
struct obstack ;
#line 819 "/usr/include/stdlib.h"
typedef __compar_fn_t comparison_fn_t;
#line 823 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h"
typedef int error_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID = 1,
    F_OWNER_PGRP = 2,
    F_OWNER_GID = 2
} ;
#line 274 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
#line 358 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__555 {
    PTHREAD_CREATE_JOINABLE___4 = 0,
    PTHREAD_CREATE_DETACHED___4 = 1
} ;
#line 47
enum __anonenum__556 {
    PTHREAD_MUTEX_TIMED_NP___4 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___4 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___4 = 3,
    PTHREAD_MUTEX_NORMAL___4 = 0,
    PTHREAD_MUTEX_RECURSIVE___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK___4 = 2,
    PTHREAD_MUTEX_DEFAULT___4 = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
#line 69
enum __anonenum__557 {
    PTHREAD_MUTEX_STALLED___4 = 0,
    PTHREAD_MUTEX_STALLED_NP___4 = 0,
    PTHREAD_MUTEX_ROBUST___4 = 1,
    PTHREAD_MUTEX_ROBUST_NP___4 = 1
} ;
#line 81
enum __anonenum__558 {
    PTHREAD_PRIO_NONE___4 = 0,
    PTHREAD_PRIO_INHERIT___4 = 1,
    PTHREAD_PRIO_PROTECT___4 = 2
} ;
#line 104
enum __anonenum__559 {
    PTHREAD_RWLOCK_PREFER_READER_NP___4 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___4 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___4 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___4 = 0
} ;
#line 124
enum __anonenum__560 {
    PTHREAD_INHERIT_SCHED___4 = 0,
    PTHREAD_EXPLICIT_SCHED___4 = 1
} ;
#line 134
enum __anonenum__561 {
    PTHREAD_SCOPE_SYSTEM___4 = 0,
    PTHREAD_SCOPE_PROCESS___4 = 1
} ;
#line 144
enum __anonenum__562 {
    PTHREAD_PROCESS_PRIVATE___4 = 0,
    PTHREAD_PROCESS_SHARED___4 = 1
} ;
#line 168
enum __anonenum__563 {
    PTHREAD_CANCEL_ENABLE___4 = 0,
    PTHREAD_CANCEL_DISABLE___4 = 1
} ;
#line 175
enum __anonenum__564 {
    PTHREAD_CANCEL_DEFERRED___4 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___4 = 1
} ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__580 {
    DT_UNKNOWN___3 = 0,
    DT_FIFO___3 = 1,
    DT_CHR___3 = 2,
    DT_DIR___3 = 4,
    DT_BLK___3 = 6,
    DT_REG___3 = 8,
    DT_LNK___3 = 10,
    DT_SOCK___3 = 12,
    DT_WHT___3 = 14
} ;
#line 95 "/usr/include/glib-2.0/glib-unix.h"
typedef gboolean (*GUnixFDSourceFunc)(gint  , GIOCondition  , gpointer  );
#line 118
struct passwd ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
union __anonunion_640 {
   char __size[32] ;
   long __align ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
typedef union __anonunion_640 sem_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/ipctypes.h"
typedef int __ipc_pid_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/ipc-perm.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   __mode_t mode ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_semid_ds.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __sem_otime_high ;
   __time_t sem_ctime ;
   __syscall_ulong_t __sem_ctime_high ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 40 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 62 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
#line 30 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/module.h"
struct __anonstruct_656 {
   char *name ;
   char *filename ;
   char *configfilename ;
   char *debugfilename ;
   char *progdir ;
   char *configdir ;
   int pipe_in[2] ;
   int pipe_out[2] ;
   int pipe_speak[2] ;
   FILE *stream_out ;
   int stderr_redirect ;
   pid_t pid ;
   int working ;
   AudioID *audio ;
};
#line 45 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/module.h"
typedef struct __anonstruct_656 OutputModule;
#line 75 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct __anonstruct_657 {
   unsigned int uid ;
   int fd ;
   guint fd_source ;
   int active ;
   int paused ;
   int paused_while_speaking ;
   SPDMessageType type ;
   SPDDataMode ssml_mode ;
   gboolean symbols_preprocessing ;
   SPDPriority priority ;
   SPDMsgSettings msg_settings ;
   char *client_name ;
   char *output_module ;
   SPDNotification notification ;
   int reparted ;
   unsigned int min_delay_progress ;
   int pause_context ;
   char *index_mark ;
   char *audio_output_method ;
   char *audio_oss_device ;
   char *audio_alsa_device ;
   char *audio_nas_server ;
   char *audio_pulse_server ;
   char *audio_pulse_device ;
   int audio_pulse_min_length ;
   int log_level ;
   unsigned int hist_cur_uid ;
   int hist_cur_pos ;
   ESort hist_sorted ;
};
#line 112 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef struct __anonstruct_657 TFDSetElement;
#line 114 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct __anonstruct_658 {
   char *pattern ;
   TFDSetElement val ;
};
#line 117 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef struct __anonstruct_658 TFDSetClientSpecific;
#line 123
enum __anonenum__659 {
    SPD_MODE_DAEMON = 0,
    SPD_MODE_SINGLE = 1
} ;
#line 126 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef enum __anonenum__659 TSpeechDMode;
#line 131 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct __anonstruct_660 {
   GList *p1 ;
   GList *p2 ;
   GList *p3 ;
   GList *p4 ;
   GList *p5 ;
};
#line 137 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef struct __anonstruct_660 TSpeechDQueue;
#line 142 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct __anonstruct_661 {
   guint id ;
   time_t time ;
   char *buf ;
   int bytes ;
   TFDSetElement settings ;
};
#line 148 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef struct __anonstruct_661 TSpeechDMessage;
#line 153 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct SpeechdOptions {
   char *communication_method ;
   int communication_method_set ;
   char *socket_path ;
   int socket_path_set ;
   int port ;
   int port_set ;
   int localhost_access_only ;
   int localhost_access_only_set ;
   int log_level ;
   int log_level_set ;
   char *pid_file ;
   char *conf_file ;
   char *conf_dir ;
   char *user_conf_dir ;
   char *runtime_speechd_dir ;
   char *log_dir ;
   char *module_dir ;
   char *user_module_dir ;
   int log_dir_set ;
   int spawn ;
   int debug ;
   char *debug_destination ;
   char *debug_logfile ;
   int max_history_messages ;
   int max_queue_size ;
   int server_timeout ;
   int server_timeout_set ;
};
#line 180 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct SpeechdStatus {
   int max_uid ;
   int max_gid ;
   int max_fd ;
};
#line 222 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct __anonstruct_662 {
   int awaiting_data ;
   int inside_block ;
   size_t o_bytes ;
   GString *o_buf ;
};
#line 227 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
typedef struct __anonstruct_662 TSpeechDSock;
#line 33 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.h"
enum __anonenum__663 {
    SYMLVL_INVALID = -1,
    SYMLVL_NO = 0,
    SYMLVL_NONE = 100,
    SYMLVL_SOME = 200,
    SYMLVL_MOST = 300,
    SYMLVL_ALL = 500,
    SYMLVL_CHAR = 1000
} ;
#line 41 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.h"
typedef enum __anonenum__663 SymLvl;
#line 78 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
struct tags {
   gsize pos ;
   gssize shift ;
   gint deferrable ;
   gchar *tags ;
};
#line 86
enum __anonenum__664 {
    SYMPRES_INVALID = -1,
    SYMPRES_NEVER = 0,
    SYMPRES_ALWAYS = 1,
    SYMPRES_NOREP = 2,
    SYMPRES_LITERAL = 3
} ;
#line 95 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef enum __anonenum__664 SymPresMode;
#line 98 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
struct __anonstruct_665 {
   char *identifier ;
   char *pattern ;
   char *replacement ;
   SymLvl level ;
   SymPresMode preserve ;
   char *display_name ;
};
#line 105 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef struct __anonstruct_665 SpeechSymbol;
#line 109 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
struct __anonstruct_666 {
   gchar *source ;
   GSList *complex_symbols ;
   GHashTable *symbols ;
};
#line 115 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef struct __anonstruct_666 SpeechSymbols;
#line 119 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
struct __anonstruct_667 {
   char const   *name ;
   int value ;
};
#line 122 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef struct __anonstruct_667 IntFieldDesc;
#line 125 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
struct __anonstruct_668 {
   gchar *source ;
   struct tags *tags ;
   gint ntags ;
   GRegex *regex ;
   GHashTable *symbols ;
   GSList *complex_list ;
   SymLvl level ;
   SymLvl support_level ;
};
#line 142 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef struct __anonstruct_668 SpeechSymbolProcessor;
#line 145 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef GHashTable LocaleMap;
#line 146 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
typedef gpointer (*LocaleMapCreateDataFunc)(gchar * , gchar * );
#line 1037
enum group {
    RSTRIPSPACE = 0,
    REPEATED = 1,
    SIMPLE = 2,
    COMPLEX = 3
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__507___0 {
    MSG_OOB___0 = 1,
    MSG_PEEK___0 = 2,
    MSG_DONTROUTE___0 = 4,
    MSG_TRYHARD___0 = 4,
    MSG_CTRUNC___0 = 8,
    MSG_PROXY___0 = 16,
    MSG_TRUNC___0 = 32,
    MSG_DONTWAIT___0 = 64,
    MSG_EOR___0 = 128,
    MSG_WAITALL___0 = 256,
    MSG_FIN___0 = 512,
    MSG_SYN___0 = 1024,
    MSG_CONFIRM___0 = 2048,
    MSG_RST___0 = 4096,
    MSG_ERRQUEUE___0 = 8192,
    MSG_NOSIGNAL___0 = 16384,
    MSG_MORE___0 = 32768,
    MSG_WAITFORONE___0 = 65536,
    MSG_BATCH___0 = 262144,
    MSG_ZEROCOPY___0 = 67108864,
    MSG_FASTOPEN___0 = 536870912,
    MSG_CMSG_CLOEXEC___0 = 1073741824
} ;
#line 334
enum __anonenum__508___0 {
    SCM_RIGHTS___0 = 1,
    SCM_CREDENTIALS___0 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__511___0 {
    SHUT_RD___0 = 0,
    SHUT_WR___0 = 1,
    SHUT_RDWR___0 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__514___0 {
    IPPROTO_IP___0 = 0,
    IPPROTO_ICMP___0 = 1,
    IPPROTO_IGMP___0 = 2,
    IPPROTO_IPIP___0 = 4,
    IPPROTO_TCP___0 = 6,
    IPPROTO_EGP___0 = 8,
    IPPROTO_PUP___0 = 12,
    IPPROTO_UDP___0 = 17,
    IPPROTO_IDP___0 = 22,
    IPPROTO_TP___0 = 29,
    IPPROTO_DCCP___0 = 33,
    IPPROTO_IPV6___0 = 41,
    IPPROTO_RSVP___0 = 46,
    IPPROTO_GRE___0 = 47,
    IPPROTO_ESP___0 = 50,
    IPPROTO_AH___0 = 51,
    IPPROTO_MTP___0 = 92,
    IPPROTO_BEETPH___0 = 94,
    IPPROTO_ENCAP___0 = 98,
    IPPROTO_PIM___0 = 103,
    IPPROTO_COMP___0 = 108,
    IPPROTO_SCTP___0 = 132,
    IPPROTO_UDPLITE___0 = 136,
    IPPROTO_MPLS___0 = 137,
    IPPROTO_ETHERNET___0 = 143,
    IPPROTO_RAW___0 = 255,
    IPPROTO_MPTCP___0 = 262,
    IPPROTO_MAX___0 = 263
} ;
#line 103
enum __anonenum__515___0 {
    IPPROTO_HOPOPTS___0 = 0,
    IPPROTO_ROUTING___0 = 43,
    IPPROTO_FRAGMENT___0 = 44,
    IPPROTO_ICMPV6___0 = 58,
    IPPROTO_NONE___0 = 59,
    IPPROTO_DSTOPTS___0 = 60,
    IPPROTO_MH___0 = 135
} ;
#line 126
enum __anonenum__516___0 {
    IPPORT_ECHO___0 = 7,
    IPPORT_DISCARD___0 = 9,
    IPPORT_SYSTAT___0 = 11,
    IPPORT_DAYTIME___0 = 13,
    IPPORT_NETSTAT___0 = 15,
    IPPORT_FTP___0 = 21,
    IPPORT_TELNET___0 = 23,
    IPPORT_SMTP___0 = 25,
    IPPORT_TIMESERVER___0 = 37,
    IPPORT_NAMESERVER___0 = 42,
    IPPORT_WHOIS___0 = 43,
    IPPORT_MTP___0 = 57,
    IPPORT_TFTP___0 = 69,
    IPPORT_RJE___0 = 77,
    IPPORT_FINGER___0 = 79,
    IPPORT_TTYLINK___0 = 87,
    IPPORT_SUPDUP___0 = 95,
    IPPORT_EXECSERVER___0 = 512,
    IPPORT_LOGINSERVER___0 = 513,
    IPPORT_CMDSERVER___0 = 514,
    IPPORT_EFSSERVER___0 = 520,
    IPPORT_BIFFUDP___0 = 512,
    IPPORT_WHOSERVER___0 = 513,
    IPPORT_ROUTESERVER___0 = 520,
    IPPORT_RESERVED___0 = 1024,
    IPPORT_USERRESERVED___0 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__528___0 {
    SI_ASYNCNL___5 = -60,
    SI_DETHREAD___5 = -7,
    SI_TKILL___5 = -6,
    SI_SIGIO___5 = -5,
    SI_ASYNCIO___5 = -4,
    SI_MESGQ___5 = -3,
    SI_TIMER___5 = -2,
    SI_QUEUE___5 = -1,
    SI_USER___5 = 0,
    SI_KERNEL___5 = 128
} ;
#line 71
enum __anonenum__529___0 {
    ILL_ILLOPC___5 = 1,
    ILL_ILLOPN___5 = 2,
    ILL_ILLADR___5 = 3,
    ILL_ILLTRP___5 = 4,
    ILL_PRVOPC___5 = 5,
    ILL_PRVREG___5 = 6,
    ILL_COPROC___5 = 7,
    ILL_BADSTK___5 = 8,
    ILL_BADIADDR___5 = 9
} ;
#line 94
enum __anonenum__530___0 {
    FPE_INTDIV___5 = 1,
    FPE_INTOVF___5 = 2,
    FPE_FLTDIV___5 = 3,
    FPE_FLTOVF___5 = 4,
    FPE_FLTUND___5 = 5,
    FPE_FLTRES___5 = 6,
    FPE_FLTINV___5 = 7,
    FPE_FLTSUB___5 = 8,
    FPE_FLTUNK___5 = 14,
    FPE_CONDTRAP___5 = 15
} ;
#line 119
enum __anonenum__531___0 {
    SEGV_MAPERR___5 = 1,
    SEGV_ACCERR___5 = 2,
    SEGV_BNDERR___5 = 3,
    SEGV_PKUERR___5 = 4,
    SEGV_ACCADI___5 = 5,
    SEGV_ADIDERR___5 = 6,
    SEGV_ADIPERR___5 = 7,
    SEGV_MTEAERR___5 = 8,
    SEGV_MTESERR___5 = 9
} ;
#line 142
enum __anonenum__532___0 {
    BUS_ADRALN___5 = 1,
    BUS_ADRERR___5 = 2,
    BUS_OBJERR___5 = 3,
    BUS_MCEERR_AR___5 = 4,
    BUS_MCEERR_AO___5 = 5
} ;
#line 159
enum __anonenum__533___0 {
    TRAP_BRKPT___0 = 1,
    TRAP_TRACE___0 = 2,
    TRAP_BRANCH___0 = 3,
    TRAP_HWBKPT___0 = 4,
    TRAP_UNK___0 = 5
} ;
#line 176
enum __anonenum__534___0 {
    CLD_EXITED___5 = 1,
    CLD_KILLED___5 = 2,
    CLD_DUMPED___5 = 3,
    CLD_TRAPPED___5 = 4,
    CLD_STOPPED___5 = 5,
    CLD_CONTINUED___5 = 6
} ;
#line 193
enum __anonenum__535___0 {
    POLL_IN___5 = 1,
    POLL_OUT___5 = 2,
    POLL_MSG___5 = 3,
    POLL_ERR___5 = 4,
    POLL_PRI___5 = 5,
    POLL_HUP___5 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__538___0 {
    SIGEV_SIGNAL___5 = 0,
    SIGEV_NONE___5 = 1,
    SIGEV_THREAD___5 = 2,
    SIGEV_THREAD_ID___5 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__542___0 {
    REG_R8___0 = 0,
    REG_R9___0 = 1,
    REG_R10___0 = 2,
    REG_R11___0 = 3,
    REG_R12___0 = 4,
    REG_R13___0 = 5,
    REG_R14___0 = 6,
    REG_R15___0 = 7,
    REG_RDI___0 = 8,
    REG_RSI___0 = 9,
    REG_RBP___0 = 10,
    REG_RBX___0 = 11,
    REG_RDX___0 = 12,
    REG_RAX___0 = 13,
    REG_RCX___0 = 14,
    REG_RSP___0 = 15,
    REG_RIP___0 = 16,
    REG_EFL___0 = 17,
    REG_CSGSFS___0 = 18,
    REG_ERR___0 = 19,
    REG_TRAPNO___0 = 20,
    REG_OLDMASK___0 = 21,
    REG_CR2___0 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__544___0 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__545___0 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum__546___0 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__547___0 {
    SS_ONSTACK___5 = 1,
    SS_DISABLE___5 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__555___0 {
    PTHREAD_CREATE_JOINABLE___5 = 0,
    PTHREAD_CREATE_DETACHED___5 = 1
} ;
#line 47
enum __anonenum__556___0 {
    PTHREAD_MUTEX_TIMED_NP___5 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___5 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___5 = 3,
    PTHREAD_MUTEX_NORMAL___5 = 0,
    PTHREAD_MUTEX_RECURSIVE___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK___5 = 2,
    PTHREAD_MUTEX_DEFAULT___5 = 0,
    PTHREAD_MUTEX_FAST_NP___0 = 0
} ;
#line 69
enum __anonenum__557___0 {
    PTHREAD_MUTEX_STALLED___5 = 0,
    PTHREAD_MUTEX_STALLED_NP___5 = 0,
    PTHREAD_MUTEX_ROBUST___5 = 1,
    PTHREAD_MUTEX_ROBUST_NP___5 = 1
} ;
#line 81
enum __anonenum__558___0 {
    PTHREAD_PRIO_NONE___5 = 0,
    PTHREAD_PRIO_INHERIT___5 = 1,
    PTHREAD_PRIO_PROTECT___5 = 2
} ;
#line 104
enum __anonenum__559___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___5 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___5 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___5 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___5 = 0
} ;
#line 124
enum __anonenum__560___0 {
    PTHREAD_INHERIT_SCHED___5 = 0,
    PTHREAD_EXPLICIT_SCHED___5 = 1
} ;
#line 134
enum __anonenum__561___0 {
    PTHREAD_SCOPE_SYSTEM___5 = 0,
    PTHREAD_SCOPE_PROCESS___5 = 1
} ;
#line 144
enum __anonenum__562___0 {
    PTHREAD_PROCESS_PRIVATE___5 = 0,
    PTHREAD_PROCESS_SHARED___5 = 1
} ;
#line 168
enum __anonenum__563___0 {
    PTHREAD_CANCEL_ENABLE___5 = 0,
    PTHREAD_CANCEL_DISABLE___5 = 1
} ;
#line 175
enum __anonenum__564___0 {
    PTHREAD_CANCEL_DEFERRED___5 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___5 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__580___0 {
    DT_UNKNOWN___4 = 0,
    DT_FIFO___4 = 1,
    DT_CHR___4 = 2,
    DT_DIR___4 = 4,
    DT_BLK___4 = 6,
    DT_REG___4 = 8,
    DT_LNK___4 = 10,
    DT_SOCK___4 = 12,
    DT_WHT___4 = 14
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__669 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__670 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum__671 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__685 {
    MSG_OOB___1 = 1,
    MSG_PEEK___1 = 2,
    MSG_DONTROUTE___1 = 4,
    MSG_TRYHARD___1 = 4,
    MSG_CTRUNC___1 = 8,
    MSG_PROXY___1 = 16,
    MSG_TRUNC___1 = 32,
    MSG_DONTWAIT___1 = 64,
    MSG_EOR___1 = 128,
    MSG_WAITALL___1 = 256,
    MSG_FIN___1 = 512,
    MSG_SYN___1 = 1024,
    MSG_CONFIRM___1 = 2048,
    MSG_RST___1 = 4096,
    MSG_ERRQUEUE___1 = 8192,
    MSG_NOSIGNAL___1 = 16384,
    MSG_MORE___1 = 32768,
    MSG_WAITFORONE___1 = 65536,
    MSG_BATCH___1 = 262144,
    MSG_ZEROCOPY___1 = 67108864,
    MSG_FASTOPEN___1 = 536870912,
    MSG_CMSG_CLOEXEC___1 = 1073741824
} ;
#line 334
enum __anonenum__686 {
    SCM_RIGHTS___1 = 1,
    SCM_CREDENTIALS___1 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__689 {
    SHUT_RD___1 = 0,
    SHUT_WR___1 = 1,
    SHUT_RDWR___1 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__692 {
    IPPROTO_IP___1 = 0,
    IPPROTO_ICMP___1 = 1,
    IPPROTO_IGMP___1 = 2,
    IPPROTO_IPIP___1 = 4,
    IPPROTO_TCP___1 = 6,
    IPPROTO_EGP___1 = 8,
    IPPROTO_PUP___1 = 12,
    IPPROTO_UDP___1 = 17,
    IPPROTO_IDP___1 = 22,
    IPPROTO_TP___1 = 29,
    IPPROTO_DCCP___1 = 33,
    IPPROTO_IPV6___1 = 41,
    IPPROTO_RSVP___1 = 46,
    IPPROTO_GRE___1 = 47,
    IPPROTO_ESP___1 = 50,
    IPPROTO_AH___1 = 51,
    IPPROTO_MTP___1 = 92,
    IPPROTO_BEETPH___1 = 94,
    IPPROTO_ENCAP___1 = 98,
    IPPROTO_PIM___1 = 103,
    IPPROTO_COMP___1 = 108,
    IPPROTO_SCTP___1 = 132,
    IPPROTO_UDPLITE___1 = 136,
    IPPROTO_MPLS___1 = 137,
    IPPROTO_ETHERNET___1 = 143,
    IPPROTO_RAW___1 = 255,
    IPPROTO_MPTCP___1 = 262,
    IPPROTO_MAX___1 = 263
} ;
#line 103
enum __anonenum__693 {
    IPPROTO_HOPOPTS___1 = 0,
    IPPROTO_ROUTING___1 = 43,
    IPPROTO_FRAGMENT___1 = 44,
    IPPROTO_ICMPV6___1 = 58,
    IPPROTO_NONE___1 = 59,
    IPPROTO_DSTOPTS___1 = 60,
    IPPROTO_MH___1 = 135
} ;
#line 126
enum __anonenum__694 {
    IPPORT_ECHO___1 = 7,
    IPPORT_DISCARD___1 = 9,
    IPPORT_SYSTAT___1 = 11,
    IPPORT_DAYTIME___1 = 13,
    IPPORT_NETSTAT___1 = 15,
    IPPORT_FTP___1 = 21,
    IPPORT_TELNET___1 = 23,
    IPPORT_SMTP___1 = 25,
    IPPORT_TIMESERVER___1 = 37,
    IPPORT_NAMESERVER___1 = 42,
    IPPORT_WHOIS___1 = 43,
    IPPORT_MTP___1 = 57,
    IPPORT_TFTP___1 = 69,
    IPPORT_RJE___1 = 77,
    IPPORT_FINGER___1 = 79,
    IPPORT_TTYLINK___1 = 87,
    IPPORT_SUPDUP___1 = 95,
    IPPORT_EXECSERVER___1 = 512,
    IPPORT_LOGINSERVER___1 = 513,
    IPPORT_CMDSERVER___1 = 514,
    IPPORT_EFSSERVER___1 = 520,
    IPPORT_BIFFUDP___1 = 512,
    IPPORT_WHOSERVER___1 = 513,
    IPPORT_ROUTESERVER___1 = 520,
    IPPORT_RESERVED___1 = 1024,
    IPPORT_USERRESERVED___1 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__707 {
    SI_ASYNCNL___6 = -60,
    SI_DETHREAD___6 = -7,
    SI_TKILL___6 = -6,
    SI_SIGIO___6 = -5,
    SI_ASYNCIO___6 = -4,
    SI_MESGQ___6 = -3,
    SI_TIMER___6 = -2,
    SI_QUEUE___6 = -1,
    SI_USER___6 = 0,
    SI_KERNEL___6 = 128
} ;
#line 71
enum __anonenum__708 {
    ILL_ILLOPC___6 = 1,
    ILL_ILLOPN___6 = 2,
    ILL_ILLADR___6 = 3,
    ILL_ILLTRP___6 = 4,
    ILL_PRVOPC___6 = 5,
    ILL_PRVREG___6 = 6,
    ILL_COPROC___6 = 7,
    ILL_BADSTK___6 = 8,
    ILL_BADIADDR___6 = 9
} ;
#line 94
enum __anonenum__709 {
    FPE_INTDIV___6 = 1,
    FPE_INTOVF___6 = 2,
    FPE_FLTDIV___6 = 3,
    FPE_FLTOVF___6 = 4,
    FPE_FLTUND___6 = 5,
    FPE_FLTRES___6 = 6,
    FPE_FLTINV___6 = 7,
    FPE_FLTSUB___6 = 8,
    FPE_FLTUNK___6 = 14,
    FPE_CONDTRAP___6 = 15
} ;
#line 119
enum __anonenum__710 {
    SEGV_MAPERR___6 = 1,
    SEGV_ACCERR___6 = 2,
    SEGV_BNDERR___6 = 3,
    SEGV_PKUERR___6 = 4,
    SEGV_ACCADI___6 = 5,
    SEGV_ADIDERR___6 = 6,
    SEGV_ADIPERR___6 = 7,
    SEGV_MTEAERR___6 = 8,
    SEGV_MTESERR___6 = 9
} ;
#line 142
enum __anonenum__711 {
    BUS_ADRALN___6 = 1,
    BUS_ADRERR___6 = 2,
    BUS_OBJERR___6 = 3,
    BUS_MCEERR_AR___6 = 4,
    BUS_MCEERR_AO___6 = 5
} ;
#line 159
enum __anonenum__712 {
    TRAP_BRKPT___1 = 1,
    TRAP_TRACE___1 = 2,
    TRAP_BRANCH___1 = 3,
    TRAP_HWBKPT___1 = 4,
    TRAP_UNK___1 = 5
} ;
#line 176
enum __anonenum__713 {
    CLD_EXITED___6 = 1,
    CLD_KILLED___6 = 2,
    CLD_DUMPED___6 = 3,
    CLD_TRAPPED___6 = 4,
    CLD_STOPPED___6 = 5,
    CLD_CONTINUED___6 = 6
} ;
#line 193
enum __anonenum__714 {
    POLL_IN___6 = 1,
    POLL_OUT___6 = 2,
    POLL_MSG___6 = 3,
    POLL_ERR___6 = 4,
    POLL_PRI___6 = 5,
    POLL_HUP___6 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__717 {
    SIGEV_SIGNAL___6 = 0,
    SIGEV_NONE___6 = 1,
    SIGEV_THREAD___6 = 2,
    SIGEV_THREAD_ID___6 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__721 {
    REG_R8___1 = 0,
    REG_R9___1 = 1,
    REG_R10___1 = 2,
    REG_R11___1 = 3,
    REG_R12___1 = 4,
    REG_R13___1 = 5,
    REG_R14___1 = 6,
    REG_R15___1 = 7,
    REG_RDI___1 = 8,
    REG_RSI___1 = 9,
    REG_RBP___1 = 10,
    REG_RBX___1 = 11,
    REG_RDX___1 = 12,
    REG_RAX___1 = 13,
    REG_RCX___1 = 14,
    REG_RSP___1 = 15,
    REG_RIP___1 = 16,
    REG_EFL___1 = 17,
    REG_CSGSFS___1 = 18,
    REG_ERR___1 = 19,
    REG_TRAPNO___1 = 20,
    REG_OLDMASK___1 = 21,
    REG_CR2___1 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__723 {
    SS_ONSTACK___6 = 1,
    SS_DISABLE___6 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__555___1 {
    PTHREAD_CREATE_JOINABLE___6 = 0,
    PTHREAD_CREATE_DETACHED___6 = 1
} ;
#line 47
enum __anonenum__556___1 {
    PTHREAD_MUTEX_TIMED_NP___6 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___6 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___6 = 3,
    PTHREAD_MUTEX_NORMAL___6 = 0,
    PTHREAD_MUTEX_RECURSIVE___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK___6 = 2,
    PTHREAD_MUTEX_DEFAULT___6 = 0,
    PTHREAD_MUTEX_FAST_NP___1 = 0
} ;
#line 69
enum __anonenum__557___1 {
    PTHREAD_MUTEX_STALLED___6 = 0,
    PTHREAD_MUTEX_STALLED_NP___6 = 0,
    PTHREAD_MUTEX_ROBUST___6 = 1,
    PTHREAD_MUTEX_ROBUST_NP___6 = 1
} ;
#line 81
enum __anonenum__558___1 {
    PTHREAD_PRIO_NONE___6 = 0,
    PTHREAD_PRIO_INHERIT___6 = 1,
    PTHREAD_PRIO_PROTECT___6 = 2
} ;
#line 104
enum __anonenum__559___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___6 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___6 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___6 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___6 = 0
} ;
#line 124
enum __anonenum__560___1 {
    PTHREAD_INHERIT_SCHED___6 = 0,
    PTHREAD_EXPLICIT_SCHED___6 = 1
} ;
#line 134
enum __anonenum__561___1 {
    PTHREAD_SCOPE_SYSTEM___6 = 0,
    PTHREAD_SCOPE_PROCESS___6 = 1
} ;
#line 144
enum __anonenum__562___1 {
    PTHREAD_PROCESS_PRIVATE___6 = 0,
    PTHREAD_PROCESS_SHARED___6 = 1
} ;
#line 168
enum __anonenum__563___1 {
    PTHREAD_CANCEL_ENABLE___6 = 0,
    PTHREAD_CANCEL_DISABLE___6 = 1
} ;
#line 175
enum __anonenum__564___1 {
    PTHREAD_CANCEL_DEFERRED___6 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___6 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__580___1 {
    DT_UNKNOWN___5 = 0,
    DT_FIFO___5 = 1,
    DT_CHR___5 = 2,
    DT_DIR___5 = 4,
    DT_BLK___5 = 6,
    DT_REG___5 = 8,
    DT_LNK___5 = 10,
    DT_SOCK___5 = 12,
    DT_WHT___5 = 14
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__742 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__743 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum__744 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__758 {
    MSG_OOB___2 = 1,
    MSG_PEEK___2 = 2,
    MSG_DONTROUTE___2 = 4,
    MSG_TRYHARD___2 = 4,
    MSG_CTRUNC___2 = 8,
    MSG_PROXY___2 = 16,
    MSG_TRUNC___2 = 32,
    MSG_DONTWAIT___2 = 64,
    MSG_EOR___2 = 128,
    MSG_WAITALL___2 = 256,
    MSG_FIN___2 = 512,
    MSG_SYN___2 = 1024,
    MSG_CONFIRM___2 = 2048,
    MSG_RST___2 = 4096,
    MSG_ERRQUEUE___2 = 8192,
    MSG_NOSIGNAL___2 = 16384,
    MSG_MORE___2 = 32768,
    MSG_WAITFORONE___2 = 65536,
    MSG_BATCH___2 = 262144,
    MSG_ZEROCOPY___2 = 67108864,
    MSG_FASTOPEN___2 = 536870912,
    MSG_CMSG_CLOEXEC___2 = 1073741824
} ;
#line 334
enum __anonenum__759 {
    SCM_RIGHTS___2 = 1,
    SCM_CREDENTIALS___2 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__762 {
    SHUT_RD___2 = 0,
    SHUT_WR___2 = 1,
    SHUT_RDWR___2 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__765 {
    IPPROTO_IP___2 = 0,
    IPPROTO_ICMP___2 = 1,
    IPPROTO_IGMP___2 = 2,
    IPPROTO_IPIP___2 = 4,
    IPPROTO_TCP___2 = 6,
    IPPROTO_EGP___2 = 8,
    IPPROTO_PUP___2 = 12,
    IPPROTO_UDP___2 = 17,
    IPPROTO_IDP___2 = 22,
    IPPROTO_TP___2 = 29,
    IPPROTO_DCCP___2 = 33,
    IPPROTO_IPV6___2 = 41,
    IPPROTO_RSVP___2 = 46,
    IPPROTO_GRE___2 = 47,
    IPPROTO_ESP___2 = 50,
    IPPROTO_AH___2 = 51,
    IPPROTO_MTP___2 = 92,
    IPPROTO_BEETPH___2 = 94,
    IPPROTO_ENCAP___2 = 98,
    IPPROTO_PIM___2 = 103,
    IPPROTO_COMP___2 = 108,
    IPPROTO_SCTP___2 = 132,
    IPPROTO_UDPLITE___2 = 136,
    IPPROTO_MPLS___2 = 137,
    IPPROTO_ETHERNET___2 = 143,
    IPPROTO_RAW___2 = 255,
    IPPROTO_MPTCP___2 = 262,
    IPPROTO_MAX___2 = 263
} ;
#line 103
enum __anonenum__766 {
    IPPROTO_HOPOPTS___2 = 0,
    IPPROTO_ROUTING___2 = 43,
    IPPROTO_FRAGMENT___2 = 44,
    IPPROTO_ICMPV6___2 = 58,
    IPPROTO_NONE___2 = 59,
    IPPROTO_DSTOPTS___2 = 60,
    IPPROTO_MH___2 = 135
} ;
#line 126
enum __anonenum__767 {
    IPPORT_ECHO___2 = 7,
    IPPORT_DISCARD___2 = 9,
    IPPORT_SYSTAT___2 = 11,
    IPPORT_DAYTIME___2 = 13,
    IPPORT_NETSTAT___2 = 15,
    IPPORT_FTP___2 = 21,
    IPPORT_TELNET___2 = 23,
    IPPORT_SMTP___2 = 25,
    IPPORT_TIMESERVER___2 = 37,
    IPPORT_NAMESERVER___2 = 42,
    IPPORT_WHOIS___2 = 43,
    IPPORT_MTP___2 = 57,
    IPPORT_TFTP___2 = 69,
    IPPORT_RJE___2 = 77,
    IPPORT_FINGER___2 = 79,
    IPPORT_TTYLINK___2 = 87,
    IPPORT_SUPDUP___2 = 95,
    IPPORT_EXECSERVER___2 = 512,
    IPPORT_LOGINSERVER___2 = 513,
    IPPORT_CMDSERVER___2 = 514,
    IPPORT_EFSSERVER___2 = 520,
    IPPORT_BIFFUDP___2 = 512,
    IPPORT_WHOSERVER___2 = 513,
    IPPORT_ROUTESERVER___2 = 520,
    IPPORT_RESERVED___2 = 1024,
    IPPORT_USERRESERVED___2 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__780 {
    SI_ASYNCNL___7 = -60,
    SI_DETHREAD___7 = -7,
    SI_TKILL___7 = -6,
    SI_SIGIO___7 = -5,
    SI_ASYNCIO___7 = -4,
    SI_MESGQ___7 = -3,
    SI_TIMER___7 = -2,
    SI_QUEUE___7 = -1,
    SI_USER___7 = 0,
    SI_KERNEL___7 = 128
} ;
#line 71
enum __anonenum__781 {
    ILL_ILLOPC___7 = 1,
    ILL_ILLOPN___7 = 2,
    ILL_ILLADR___7 = 3,
    ILL_ILLTRP___7 = 4,
    ILL_PRVOPC___7 = 5,
    ILL_PRVREG___7 = 6,
    ILL_COPROC___7 = 7,
    ILL_BADSTK___7 = 8,
    ILL_BADIADDR___7 = 9
} ;
#line 94
enum __anonenum__782 {
    FPE_INTDIV___7 = 1,
    FPE_INTOVF___7 = 2,
    FPE_FLTDIV___7 = 3,
    FPE_FLTOVF___7 = 4,
    FPE_FLTUND___7 = 5,
    FPE_FLTRES___7 = 6,
    FPE_FLTINV___7 = 7,
    FPE_FLTSUB___7 = 8,
    FPE_FLTUNK___7 = 14,
    FPE_CONDTRAP___7 = 15
} ;
#line 119
enum __anonenum__783 {
    SEGV_MAPERR___7 = 1,
    SEGV_ACCERR___7 = 2,
    SEGV_BNDERR___7 = 3,
    SEGV_PKUERR___7 = 4,
    SEGV_ACCADI___7 = 5,
    SEGV_ADIDERR___7 = 6,
    SEGV_ADIPERR___7 = 7,
    SEGV_MTEAERR___7 = 8,
    SEGV_MTESERR___7 = 9
} ;
#line 142
enum __anonenum__784 {
    BUS_ADRALN___7 = 1,
    BUS_ADRERR___7 = 2,
    BUS_OBJERR___7 = 3,
    BUS_MCEERR_AR___7 = 4,
    BUS_MCEERR_AO___7 = 5
} ;
#line 159
enum __anonenum__785 {
    TRAP_BRKPT___2 = 1,
    TRAP_TRACE___2 = 2,
    TRAP_BRANCH___2 = 3,
    TRAP_HWBKPT___2 = 4,
    TRAP_UNK___2 = 5
} ;
#line 176
enum __anonenum__786 {
    CLD_EXITED___7 = 1,
    CLD_KILLED___7 = 2,
    CLD_DUMPED___7 = 3,
    CLD_TRAPPED___7 = 4,
    CLD_STOPPED___7 = 5,
    CLD_CONTINUED___7 = 6
} ;
#line 193
enum __anonenum__787 {
    POLL_IN___7 = 1,
    POLL_OUT___7 = 2,
    POLL_MSG___7 = 3,
    POLL_ERR___7 = 4,
    POLL_PRI___7 = 5,
    POLL_HUP___7 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__790 {
    SIGEV_SIGNAL___7 = 0,
    SIGEV_NONE___7 = 1,
    SIGEV_THREAD___7 = 2,
    SIGEV_THREAD_ID___7 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__794 {
    REG_R8___2 = 0,
    REG_R9___2 = 1,
    REG_R10___2 = 2,
    REG_R11___2 = 3,
    REG_R12___2 = 4,
    REG_R13___2 = 5,
    REG_R14___2 = 6,
    REG_R15___2 = 7,
    REG_RDI___2 = 8,
    REG_RSI___2 = 9,
    REG_RBP___2 = 10,
    REG_RBX___2 = 11,
    REG_RDX___2 = 12,
    REG_RAX___2 = 13,
    REG_RCX___2 = 14,
    REG_RSP___2 = 15,
    REG_RIP___2 = 16,
    REG_EFL___2 = 17,
    REG_CSGSFS___2 = 18,
    REG_ERR___2 = 19,
    REG_TRAPNO___2 = 20,
    REG_OLDMASK___2 = 21,
    REG_CR2___2 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__796 {
    SS_ONSTACK___7 = 1,
    SS_DISABLE___7 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__802 {
    PTHREAD_CREATE_JOINABLE___7 = 0,
    PTHREAD_CREATE_DETACHED___7 = 1
} ;
#line 47
enum __anonenum__803 {
    PTHREAD_MUTEX_TIMED_NP___7 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___7 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___7 = 3,
    PTHREAD_MUTEX_NORMAL___7 = 0,
    PTHREAD_MUTEX_RECURSIVE___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK___7 = 2,
    PTHREAD_MUTEX_DEFAULT___7 = 0,
    PTHREAD_MUTEX_FAST_NP___2 = 0
} ;
#line 69
enum __anonenum__804 {
    PTHREAD_MUTEX_STALLED___7 = 0,
    PTHREAD_MUTEX_STALLED_NP___7 = 0,
    PTHREAD_MUTEX_ROBUST___7 = 1,
    PTHREAD_MUTEX_ROBUST_NP___7 = 1
} ;
#line 81
enum __anonenum__805 {
    PTHREAD_PRIO_NONE___7 = 0,
    PTHREAD_PRIO_INHERIT___7 = 1,
    PTHREAD_PRIO_PROTECT___7 = 2
} ;
#line 104
enum __anonenum__806 {
    PTHREAD_RWLOCK_PREFER_READER_NP___7 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___7 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___7 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___7 = 0
} ;
#line 124
enum __anonenum__807 {
    PTHREAD_INHERIT_SCHED___7 = 0,
    PTHREAD_EXPLICIT_SCHED___7 = 1
} ;
#line 134
enum __anonenum__808 {
    PTHREAD_SCOPE_SYSTEM___7 = 0,
    PTHREAD_SCOPE_PROCESS___7 = 1
} ;
#line 144
enum __anonenum__809 {
    PTHREAD_PROCESS_PRIVATE___7 = 0,
    PTHREAD_PROCESS_SHARED___7 = 1
} ;
#line 168
enum __anonenum__810 {
    PTHREAD_CANCEL_ENABLE___7 = 0,
    PTHREAD_CANCEL_DISABLE___7 = 1
} ;
#line 175
enum __anonenum__811 {
    PTHREAD_CANCEL_DEFERRED___7 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___7 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__827 {
    DT_UNKNOWN___6 = 0,
    DT_FIFO___6 = 1,
    DT_CHR___6 = 2,
    DT_DIR___6 = 4,
    DT_BLK___6 = 6,
    DT_REG___6 = 8,
    DT_LNK___6 = 10,
    DT_SOCK___6 = 12,
    DT_WHT___6 = 14
} ;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 21 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 24 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 27 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 24 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 25 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 26 "/usr/include/linux/types.h"
typedef __u32 __le32;
#line 27 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 28 "/usr/include/linux/types.h"
typedef __u64 __le64;
#line 29 "/usr/include/linux/types.h"
typedef __u64 __be64;
#line 31 "/usr/include/linux/types.h"
typedef __u16 __sum16;
#line 32 "/usr/include/linux/types.h"
typedef __u32 __wsum;
#line 47 "/usr/include/linux/types.h"
typedef unsigned int __poll_t;
#line 56 "/usr/include/linux/stat.h"
struct statx_timestamp {
   __s64 tv_sec ;
   __u32 tv_nsec ;
   __s32 __reserved ;
};
#line 99 "/usr/include/linux/stat.h"
struct statx {
   __u32 stx_mask ;
   __u32 stx_blksize ;
   __u64 stx_attributes ;
   __u32 stx_nlink ;
   __u32 stx_uid ;
   __u32 stx_gid ;
   __u16 stx_mode ;
   __u16 __spare0[1] ;
   __u64 stx_ino ;
   __u64 stx_size ;
   __u64 stx_blocks ;
   __u64 stx_attributes_mask ;
   struct statx_timestamp stx_atime ;
   struct statx_timestamp stx_btime ;
   struct statx_timestamp stx_ctime ;
   struct statx_timestamp stx_mtime ;
   __u32 stx_rdev_major ;
   __u32 stx_rdev_minor ;
   __u32 stx_dev_major ;
   __u32 stx_dev_minor ;
   __u64 stx_mnt_id ;
   __u64 __spare2 ;
   __u64 __spare3[12] ;
};
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__917 {
    MSG_OOB___3 = 1,
    MSG_PEEK___3 = 2,
    MSG_DONTROUTE___3 = 4,
    MSG_TRYHARD___3 = 4,
    MSG_CTRUNC___3 = 8,
    MSG_PROXY___3 = 16,
    MSG_TRUNC___3 = 32,
    MSG_DONTWAIT___3 = 64,
    MSG_EOR___3 = 128,
    MSG_WAITALL___3 = 256,
    MSG_FIN___3 = 512,
    MSG_SYN___3 = 1024,
    MSG_CONFIRM___3 = 2048,
    MSG_RST___3 = 4096,
    MSG_ERRQUEUE___3 = 8192,
    MSG_NOSIGNAL___3 = 16384,
    MSG_MORE___3 = 32768,
    MSG_WAITFORONE___3 = 65536,
    MSG_BATCH___3 = 262144,
    MSG_ZEROCOPY___3 = 67108864,
    MSG_FASTOPEN___3 = 536870912,
    MSG_CMSG_CLOEXEC___3 = 1073741824
} ;
#line 334
enum __anonenum__918 {
    SCM_RIGHTS___3 = 1,
    SCM_CREDENTIALS___3 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__919 {
    SHUT_RD___3 = 0,
    SHUT_WR___3 = 1,
    SHUT_RDWR___3 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__922 {
    IPPROTO_IP___3 = 0,
    IPPROTO_ICMP___3 = 1,
    IPPROTO_IGMP___3 = 2,
    IPPROTO_IPIP___3 = 4,
    IPPROTO_TCP___3 = 6,
    IPPROTO_EGP___3 = 8,
    IPPROTO_PUP___3 = 12,
    IPPROTO_UDP___3 = 17,
    IPPROTO_IDP___3 = 22,
    IPPROTO_TP___3 = 29,
    IPPROTO_DCCP___3 = 33,
    IPPROTO_IPV6___3 = 41,
    IPPROTO_RSVP___3 = 46,
    IPPROTO_GRE___3 = 47,
    IPPROTO_ESP___3 = 50,
    IPPROTO_AH___3 = 51,
    IPPROTO_MTP___3 = 92,
    IPPROTO_BEETPH___3 = 94,
    IPPROTO_ENCAP___3 = 98,
    IPPROTO_PIM___3 = 103,
    IPPROTO_COMP___3 = 108,
    IPPROTO_SCTP___3 = 132,
    IPPROTO_UDPLITE___3 = 136,
    IPPROTO_MPLS___3 = 137,
    IPPROTO_ETHERNET___3 = 143,
    IPPROTO_RAW___3 = 255,
    IPPROTO_MPTCP___3 = 262,
    IPPROTO_MAX___3 = 263
} ;
#line 103
enum __anonenum__923 {
    IPPROTO_HOPOPTS___3 = 0,
    IPPROTO_ROUTING___3 = 43,
    IPPROTO_FRAGMENT___3 = 44,
    IPPROTO_ICMPV6___3 = 58,
    IPPROTO_NONE___3 = 59,
    IPPROTO_DSTOPTS___3 = 60,
    IPPROTO_MH___3 = 135
} ;
#line 126
enum __anonenum__924 {
    IPPORT_ECHO___3 = 7,
    IPPORT_DISCARD___3 = 9,
    IPPORT_SYSTAT___3 = 11,
    IPPORT_DAYTIME___3 = 13,
    IPPORT_NETSTAT___3 = 15,
    IPPORT_FTP___3 = 21,
    IPPORT_TELNET___3 = 23,
    IPPORT_SMTP___3 = 25,
    IPPORT_TIMESERVER___3 = 37,
    IPPORT_NAMESERVER___3 = 42,
    IPPORT_WHOIS___3 = 43,
    IPPORT_MTP___3 = 57,
    IPPORT_TFTP___3 = 69,
    IPPORT_RJE___3 = 77,
    IPPORT_FINGER___3 = 79,
    IPPORT_TTYLINK___3 = 87,
    IPPORT_SUPDUP___3 = 95,
    IPPORT_EXECSERVER___3 = 512,
    IPPORT_LOGINSERVER___3 = 513,
    IPPORT_CMDSERVER___3 = 514,
    IPPORT_EFSSERVER___3 = 520,
    IPPORT_BIFFUDP___3 = 512,
    IPPORT_WHOSERVER___3 = 513,
    IPPORT_ROUTESERVER___3 = 520,
    IPPORT_RESERVED___3 = 1024,
    IPPORT_USERRESERVED___3 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__937 {
    SI_ASYNCNL___8 = -60,
    SI_DETHREAD___8 = -7,
    SI_TKILL___8 = -6,
    SI_SIGIO___8 = -5,
    SI_ASYNCIO___8 = -4,
    SI_MESGQ___8 = -3,
    SI_TIMER___8 = -2,
    SI_QUEUE___8 = -1,
    SI_USER___8 = 0,
    SI_KERNEL___8 = 128
} ;
#line 71
enum __anonenum__938 {
    ILL_ILLOPC___8 = 1,
    ILL_ILLOPN___8 = 2,
    ILL_ILLADR___8 = 3,
    ILL_ILLTRP___8 = 4,
    ILL_PRVOPC___8 = 5,
    ILL_PRVREG___8 = 6,
    ILL_COPROC___8 = 7,
    ILL_BADSTK___8 = 8,
    ILL_BADIADDR___8 = 9
} ;
#line 94
enum __anonenum__939 {
    FPE_INTDIV___8 = 1,
    FPE_INTOVF___8 = 2,
    FPE_FLTDIV___8 = 3,
    FPE_FLTOVF___8 = 4,
    FPE_FLTUND___8 = 5,
    FPE_FLTRES___8 = 6,
    FPE_FLTINV___8 = 7,
    FPE_FLTSUB___8 = 8,
    FPE_FLTUNK___8 = 14,
    FPE_CONDTRAP___8 = 15
} ;
#line 119
enum __anonenum__940 {
    SEGV_MAPERR___8 = 1,
    SEGV_ACCERR___8 = 2,
    SEGV_BNDERR___8 = 3,
    SEGV_PKUERR___8 = 4,
    SEGV_ACCADI___8 = 5,
    SEGV_ADIDERR___8 = 6,
    SEGV_ADIPERR___8 = 7,
    SEGV_MTEAERR___8 = 8,
    SEGV_MTESERR___8 = 9
} ;
#line 142
enum __anonenum__941 {
    BUS_ADRALN___8 = 1,
    BUS_ADRERR___8 = 2,
    BUS_OBJERR___8 = 3,
    BUS_MCEERR_AR___8 = 4,
    BUS_MCEERR_AO___8 = 5
} ;
#line 159
enum __anonenum__942 {
    TRAP_BRKPT___3 = 1,
    TRAP_TRACE___3 = 2,
    TRAP_BRANCH___3 = 3,
    TRAP_HWBKPT___3 = 4,
    TRAP_UNK___3 = 5
} ;
#line 176
enum __anonenum__943 {
    CLD_EXITED___8 = 1,
    CLD_KILLED___8 = 2,
    CLD_DUMPED___8 = 3,
    CLD_TRAPPED___8 = 4,
    CLD_STOPPED___8 = 5,
    CLD_CONTINUED___8 = 6
} ;
#line 193
enum __anonenum__944 {
    POLL_IN___8 = 1,
    POLL_OUT___8 = 2,
    POLL_MSG___8 = 3,
    POLL_ERR___8 = 4,
    POLL_PRI___8 = 5,
    POLL_HUP___8 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__947 {
    SIGEV_SIGNAL___8 = 0,
    SIGEV_NONE___8 = 1,
    SIGEV_THREAD___8 = 2,
    SIGEV_THREAD_ID___8 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__951 {
    REG_R8___3 = 0,
    REG_R9___3 = 1,
    REG_R10___3 = 2,
    REG_R11___3 = 3,
    REG_R12___3 = 4,
    REG_R13___3 = 5,
    REG_R14___3 = 6,
    REG_R15___3 = 7,
    REG_RDI___3 = 8,
    REG_RSI___3 = 9,
    REG_RBP___3 = 10,
    REG_RBX___3 = 11,
    REG_RDX___3 = 12,
    REG_RAX___3 = 13,
    REG_RCX___3 = 14,
    REG_RSP___3 = 15,
    REG_RIP___3 = 16,
    REG_EFL___3 = 17,
    REG_CSGSFS___3 = 18,
    REG_ERR___3 = 19,
    REG_TRAPNO___3 = 20,
    REG_OLDMASK___3 = 21,
    REG_CR2___3 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__953 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum__954 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4 = 250
} ;
#line 539
enum __anonenum__955 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__956 {
    SS_ONSTACK___8 = 1,
    SS_DISABLE___8 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__964 {
    PTHREAD_CREATE_JOINABLE___8 = 0,
    PTHREAD_CREATE_DETACHED___8 = 1
} ;
#line 47
enum __anonenum__965 {
    PTHREAD_MUTEX_TIMED_NP___8 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___8 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___8 = 3,
    PTHREAD_MUTEX_NORMAL___8 = 0,
    PTHREAD_MUTEX_RECURSIVE___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK___8 = 2,
    PTHREAD_MUTEX_DEFAULT___8 = 0,
    PTHREAD_MUTEX_FAST_NP___3 = 0
} ;
#line 69
enum __anonenum__966 {
    PTHREAD_MUTEX_STALLED___8 = 0,
    PTHREAD_MUTEX_STALLED_NP___8 = 0,
    PTHREAD_MUTEX_ROBUST___8 = 1,
    PTHREAD_MUTEX_ROBUST_NP___8 = 1
} ;
#line 81
enum __anonenum__967 {
    PTHREAD_PRIO_NONE___8 = 0,
    PTHREAD_PRIO_INHERIT___8 = 1,
    PTHREAD_PRIO_PROTECT___8 = 2
} ;
#line 104
enum __anonenum__968 {
    PTHREAD_RWLOCK_PREFER_READER_NP___8 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___8 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___8 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___8 = 0
} ;
#line 124
enum __anonenum__969 {
    PTHREAD_INHERIT_SCHED___8 = 0,
    PTHREAD_EXPLICIT_SCHED___8 = 1
} ;
#line 134
enum __anonenum__970 {
    PTHREAD_SCOPE_SYSTEM___8 = 0,
    PTHREAD_SCOPE_PROCESS___8 = 1
} ;
#line 144
enum __anonenum__971 {
    PTHREAD_PROCESS_PRIVATE___8 = 0,
    PTHREAD_PROCESS_SHARED___8 = 1
} ;
#line 168
enum __anonenum__972 {
    PTHREAD_CANCEL_ENABLE___8 = 0,
    PTHREAD_CANCEL_DISABLE___8 = 1
} ;
#line 175
enum __anonenum__973 {
    PTHREAD_CANCEL_DEFERRED___8 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___8 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__989 {
    DT_UNKNOWN___7 = 0,
    DT_FIFO___7 = 1,
    DT_CHR___7 = 2,
    DT_DIR___7 = 4,
    DT_BLK___7 = 6,
    DT_REG___7 = 8,
    DT_LNK___7 = 10,
    DT_SOCK___7 = 12,
    DT_WHT___7 = 14
} ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1106 {
    SI_ASYNCNL___9 = -60,
    SI_DETHREAD___9 = -7,
    SI_TKILL___9 = -6,
    SI_SIGIO___9 = -5,
    SI_ASYNCIO___9 = -4,
    SI_MESGQ___9 = -3,
    SI_TIMER___9 = -2,
    SI_QUEUE___9 = -1,
    SI_USER___9 = 0,
    SI_KERNEL___9 = 128
} ;
#line 71
enum __anonenum__1107 {
    ILL_ILLOPC___9 = 1,
    ILL_ILLOPN___9 = 2,
    ILL_ILLADR___9 = 3,
    ILL_ILLTRP___9 = 4,
    ILL_PRVOPC___9 = 5,
    ILL_PRVREG___9 = 6,
    ILL_COPROC___9 = 7,
    ILL_BADSTK___9 = 8,
    ILL_BADIADDR___9 = 9
} ;
#line 94
enum __anonenum__1108 {
    FPE_INTDIV___9 = 1,
    FPE_INTOVF___9 = 2,
    FPE_FLTDIV___9 = 3,
    FPE_FLTOVF___9 = 4,
    FPE_FLTUND___9 = 5,
    FPE_FLTRES___9 = 6,
    FPE_FLTINV___9 = 7,
    FPE_FLTSUB___9 = 8,
    FPE_FLTUNK___9 = 14,
    FPE_CONDTRAP___9 = 15
} ;
#line 119
enum __anonenum__1109 {
    SEGV_MAPERR___9 = 1,
    SEGV_ACCERR___9 = 2,
    SEGV_BNDERR___9 = 3,
    SEGV_PKUERR___9 = 4,
    SEGV_ACCADI___9 = 5,
    SEGV_ADIDERR___9 = 6,
    SEGV_ADIPERR___9 = 7,
    SEGV_MTEAERR___9 = 8,
    SEGV_MTESERR___9 = 9
} ;
#line 142
enum __anonenum__1110 {
    BUS_ADRALN___9 = 1,
    BUS_ADRERR___9 = 2,
    BUS_OBJERR___9 = 3,
    BUS_MCEERR_AR___9 = 4,
    BUS_MCEERR_AO___9 = 5
} ;
#line 159
enum __anonenum__1111 {
    TRAP_BRKPT___4 = 1,
    TRAP_TRACE___4 = 2,
    TRAP_BRANCH___4 = 3,
    TRAP_HWBKPT___4 = 4,
    TRAP_UNK___4 = 5
} ;
#line 176
enum __anonenum__1112 {
    CLD_EXITED___9 = 1,
    CLD_KILLED___9 = 2,
    CLD_DUMPED___9 = 3,
    CLD_TRAPPED___9 = 4,
    CLD_STOPPED___9 = 5,
    CLD_CONTINUED___9 = 6
} ;
#line 193
enum __anonenum__1113 {
    POLL_IN___9 = 1,
    POLL_OUT___9 = 2,
    POLL_MSG___9 = 3,
    POLL_ERR___9 = 4,
    POLL_PRI___9 = 5,
    POLL_HUP___9 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1116 {
    SIGEV_SIGNAL___9 = 0,
    SIGEV_NONE___9 = 1,
    SIGEV_THREAD___9 = 2,
    SIGEV_THREAD_ID___9 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1120 {
    REG_R8___4 = 0,
    REG_R9___4 = 1,
    REG_R10___4 = 2,
    REG_R11___4 = 3,
    REG_R12___4 = 4,
    REG_R13___4 = 5,
    REG_R14___4 = 6,
    REG_R15___4 = 7,
    REG_RDI___4 = 8,
    REG_RSI___4 = 9,
    REG_RBP___4 = 10,
    REG_RBX___4 = 11,
    REG_RDX___4 = 12,
    REG_RAX___4 = 13,
    REG_RCX___4 = 14,
    REG_RSP___4 = 15,
    REG_RIP___4 = 16,
    REG_EFL___4 = 17,
    REG_CSGSFS___4 = 18,
    REG_ERR___4 = 19,
    REG_TRAPNO___4 = 20,
    REG_OLDMASK___4 = 21,
    REG_CR2___4 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1122 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum__1123 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5 = 250
} ;
#line 539
enum __anonenum__1124 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1125 {
    SS_ONSTACK___9 = 1,
    SS_DISABLE___9 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1133 {
    DT_UNKNOWN___8 = 0,
    DT_FIFO___8 = 1,
    DT_CHR___8 = 2,
    DT_DIR___8 = 4,
    DT_BLK___8 = 6,
    DT_REG___8 = 8,
    DT_LNK___8 = 10,
    DT_SOCK___8 = 12,
    DT_WHT___8 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1192 {
    PTHREAD_CREATE_JOINABLE___9 = 0,
    PTHREAD_CREATE_DETACHED___9 = 1
} ;
#line 47
enum __anonenum__1193 {
    PTHREAD_MUTEX_TIMED_NP___9 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___9 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___9 = 3,
    PTHREAD_MUTEX_NORMAL___9 = 0,
    PTHREAD_MUTEX_RECURSIVE___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK___9 = 2,
    PTHREAD_MUTEX_DEFAULT___9 = 0,
    PTHREAD_MUTEX_FAST_NP___4 = 0
} ;
#line 69
enum __anonenum__1194 {
    PTHREAD_MUTEX_STALLED___9 = 0,
    PTHREAD_MUTEX_STALLED_NP___9 = 0,
    PTHREAD_MUTEX_ROBUST___9 = 1,
    PTHREAD_MUTEX_ROBUST_NP___9 = 1
} ;
#line 81
enum __anonenum__1195 {
    PTHREAD_PRIO_NONE___9 = 0,
    PTHREAD_PRIO_INHERIT___9 = 1,
    PTHREAD_PRIO_PROTECT___9 = 2
} ;
#line 104
enum __anonenum__1196 {
    PTHREAD_RWLOCK_PREFER_READER_NP___9 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___9 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___9 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___9 = 0
} ;
#line 124
enum __anonenum__1197 {
    PTHREAD_INHERIT_SCHED___9 = 0,
    PTHREAD_EXPLICIT_SCHED___9 = 1
} ;
#line 134
enum __anonenum__1198 {
    PTHREAD_SCOPE_SYSTEM___9 = 0,
    PTHREAD_SCOPE_PROCESS___9 = 1
} ;
#line 144
enum __anonenum__1199 {
    PTHREAD_PROCESS_PRIVATE___9 = 0,
    PTHREAD_PROCESS_SHARED___9 = 1
} ;
#line 168
enum __anonenum__1200 {
    PTHREAD_CANCEL_ENABLE___9 = 0,
    PTHREAD_CANCEL_DISABLE___9 = 1
} ;
#line 175
enum __anonenum__1201 {
    PTHREAD_CANCEL_DEFERRED___9 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___9 = 1
} ;
#line 33 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1205 {
    MSG_OOB___4 = 1,
    MSG_PEEK___4 = 2,
    MSG_DONTROUTE___4 = 4,
    MSG_TRYHARD___4 = 4,
    MSG_CTRUNC___4 = 8,
    MSG_PROXY___4 = 16,
    MSG_TRUNC___4 = 32,
    MSG_DONTWAIT___4 = 64,
    MSG_EOR___4 = 128,
    MSG_WAITALL___4 = 256,
    MSG_FIN___4 = 512,
    MSG_SYN___4 = 1024,
    MSG_CONFIRM___4 = 2048,
    MSG_RST___4 = 4096,
    MSG_ERRQUEUE___4 = 8192,
    MSG_NOSIGNAL___4 = 16384,
    MSG_MORE___4 = 32768,
    MSG_WAITFORONE___4 = 65536,
    MSG_BATCH___4 = 262144,
    MSG_ZEROCOPY___4 = 67108864,
    MSG_FASTOPEN___4 = 536870912,
    MSG_CMSG_CLOEXEC___4 = 1073741824
} ;
#line 334
enum __anonenum__1206 {
    SCM_RIGHTS___4 = 1,
    SCM_CREDENTIALS___4 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1209 {
    SHUT_RD___4 = 0,
    SHUT_WR___4 = 1,
    SHUT_RDWR___4 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1212 {
    IPPROTO_IP___4 = 0,
    IPPROTO_ICMP___4 = 1,
    IPPROTO_IGMP___4 = 2,
    IPPROTO_IPIP___4 = 4,
    IPPROTO_TCP___4 = 6,
    IPPROTO_EGP___4 = 8,
    IPPROTO_PUP___4 = 12,
    IPPROTO_UDP___4 = 17,
    IPPROTO_IDP___4 = 22,
    IPPROTO_TP___4 = 29,
    IPPROTO_DCCP___4 = 33,
    IPPROTO_IPV6___4 = 41,
    IPPROTO_RSVP___4 = 46,
    IPPROTO_GRE___4 = 47,
    IPPROTO_ESP___4 = 50,
    IPPROTO_AH___4 = 51,
    IPPROTO_MTP___4 = 92,
    IPPROTO_BEETPH___4 = 94,
    IPPROTO_ENCAP___4 = 98,
    IPPROTO_PIM___4 = 103,
    IPPROTO_COMP___4 = 108,
    IPPROTO_SCTP___4 = 132,
    IPPROTO_UDPLITE___4 = 136,
    IPPROTO_MPLS___4 = 137,
    IPPROTO_ETHERNET___4 = 143,
    IPPROTO_RAW___4 = 255,
    IPPROTO_MPTCP___4 = 262,
    IPPROTO_MAX___4 = 263
} ;
#line 103
enum __anonenum__1213 {
    IPPROTO_HOPOPTS___4 = 0,
    IPPROTO_ROUTING___4 = 43,
    IPPROTO_FRAGMENT___4 = 44,
    IPPROTO_ICMPV6___4 = 58,
    IPPROTO_NONE___4 = 59,
    IPPROTO_DSTOPTS___4 = 60,
    IPPROTO_MH___4 = 135
} ;
#line 126
enum __anonenum__1214 {
    IPPORT_ECHO___4 = 7,
    IPPORT_DISCARD___4 = 9,
    IPPORT_SYSTAT___4 = 11,
    IPPORT_DAYTIME___4 = 13,
    IPPORT_NETSTAT___4 = 15,
    IPPORT_FTP___4 = 21,
    IPPORT_TELNET___4 = 23,
    IPPORT_SMTP___4 = 25,
    IPPORT_TIMESERVER___4 = 37,
    IPPORT_NAMESERVER___4 = 42,
    IPPORT_WHOIS___4 = 43,
    IPPORT_MTP___4 = 57,
    IPPORT_TFTP___4 = 69,
    IPPORT_RJE___4 = 77,
    IPPORT_FINGER___4 = 79,
    IPPORT_TTYLINK___4 = 87,
    IPPORT_SUPDUP___4 = 95,
    IPPORT_EXECSERVER___4 = 512,
    IPPORT_LOGINSERVER___4 = 513,
    IPPORT_CMDSERVER___4 = 514,
    IPPORT_EFSSERVER___4 = 520,
    IPPORT_BIFFUDP___4 = 512,
    IPPORT_WHOSERVER___4 = 513,
    IPPORT_ROUTESERVER___4 = 520,
    IPPORT_RESERVED___4 = 1024,
    IPPORT_USERRESERVED___4 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1106___0 {
    SI_ASYNCNL___10 = -60,
    SI_DETHREAD___10 = -7,
    SI_TKILL___10 = -6,
    SI_SIGIO___10 = -5,
    SI_ASYNCIO___10 = -4,
    SI_MESGQ___10 = -3,
    SI_TIMER___10 = -2,
    SI_QUEUE___10 = -1,
    SI_USER___10 = 0,
    SI_KERNEL___10 = 128
} ;
#line 71
enum __anonenum__1107___0 {
    ILL_ILLOPC___10 = 1,
    ILL_ILLOPN___10 = 2,
    ILL_ILLADR___10 = 3,
    ILL_ILLTRP___10 = 4,
    ILL_PRVOPC___10 = 5,
    ILL_PRVREG___10 = 6,
    ILL_COPROC___10 = 7,
    ILL_BADSTK___10 = 8,
    ILL_BADIADDR___10 = 9
} ;
#line 94
enum __anonenum__1108___0 {
    FPE_INTDIV___10 = 1,
    FPE_INTOVF___10 = 2,
    FPE_FLTDIV___10 = 3,
    FPE_FLTOVF___10 = 4,
    FPE_FLTUND___10 = 5,
    FPE_FLTRES___10 = 6,
    FPE_FLTINV___10 = 7,
    FPE_FLTSUB___10 = 8,
    FPE_FLTUNK___10 = 14,
    FPE_CONDTRAP___10 = 15
} ;
#line 119
enum __anonenum__1109___0 {
    SEGV_MAPERR___10 = 1,
    SEGV_ACCERR___10 = 2,
    SEGV_BNDERR___10 = 3,
    SEGV_PKUERR___10 = 4,
    SEGV_ACCADI___10 = 5,
    SEGV_ADIDERR___10 = 6,
    SEGV_ADIPERR___10 = 7,
    SEGV_MTEAERR___10 = 8,
    SEGV_MTESERR___10 = 9
} ;
#line 142
enum __anonenum__1110___0 {
    BUS_ADRALN___10 = 1,
    BUS_ADRERR___10 = 2,
    BUS_OBJERR___10 = 3,
    BUS_MCEERR_AR___10 = 4,
    BUS_MCEERR_AO___10 = 5
} ;
#line 159
enum __anonenum__1111___0 {
    TRAP_BRKPT___5 = 1,
    TRAP_TRACE___5 = 2,
    TRAP_BRANCH___5 = 3,
    TRAP_HWBKPT___5 = 4,
    TRAP_UNK___5 = 5
} ;
#line 176
enum __anonenum__1112___0 {
    CLD_EXITED___10 = 1,
    CLD_KILLED___10 = 2,
    CLD_DUMPED___10 = 3,
    CLD_TRAPPED___10 = 4,
    CLD_STOPPED___10 = 5,
    CLD_CONTINUED___10 = 6
} ;
#line 193
enum __anonenum__1113___0 {
    POLL_IN___10 = 1,
    POLL_OUT___10 = 2,
    POLL_MSG___10 = 3,
    POLL_ERR___10 = 4,
    POLL_PRI___10 = 5,
    POLL_HUP___10 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1116___0 {
    SIGEV_SIGNAL___10 = 0,
    SIGEV_NONE___10 = 1,
    SIGEV_THREAD___10 = 2,
    SIGEV_THREAD_ID___10 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1120___0 {
    REG_R8___5 = 0,
    REG_R9___5 = 1,
    REG_R10___5 = 2,
    REG_R11___5 = 3,
    REG_R12___5 = 4,
    REG_R13___5 = 5,
    REG_R14___5 = 6,
    REG_R15___5 = 7,
    REG_RDI___5 = 8,
    REG_RSI___5 = 9,
    REG_RBP___5 = 10,
    REG_RBX___5 = 11,
    REG_RDX___5 = 12,
    REG_RAX___5 = 13,
    REG_RCX___5 = 14,
    REG_RSP___5 = 15,
    REG_RIP___5 = 16,
    REG_EFL___5 = 17,
    REG_CSGSFS___5 = 18,
    REG_ERR___5 = 19,
    REG_TRAPNO___5 = 20,
    REG_OLDMASK___5 = 21,
    REG_CR2___5 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1122___0 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum__1123___0 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6 = 250
} ;
#line 539
enum __anonenum__1124___0 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1125___0 {
    SS_ONSTACK___10 = 1,
    SS_DISABLE___10 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1133___0 {
    DT_UNKNOWN___9 = 0,
    DT_FIFO___9 = 1,
    DT_CHR___9 = 2,
    DT_DIR___9 = 4,
    DT_BLK___9 = 6,
    DT_REG___9 = 8,
    DT_LNK___9 = 10,
    DT_SOCK___9 = 12,
    DT_WHT___9 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1192___0 {
    PTHREAD_CREATE_JOINABLE___10 = 0,
    PTHREAD_CREATE_DETACHED___10 = 1
} ;
#line 47
enum __anonenum__1193___0 {
    PTHREAD_MUTEX_TIMED_NP___10 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___10 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___10 = 3,
    PTHREAD_MUTEX_NORMAL___10 = 0,
    PTHREAD_MUTEX_RECURSIVE___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK___10 = 2,
    PTHREAD_MUTEX_DEFAULT___10 = 0,
    PTHREAD_MUTEX_FAST_NP___5 = 0
} ;
#line 69
enum __anonenum__1194___0 {
    PTHREAD_MUTEX_STALLED___10 = 0,
    PTHREAD_MUTEX_STALLED_NP___10 = 0,
    PTHREAD_MUTEX_ROBUST___10 = 1,
    PTHREAD_MUTEX_ROBUST_NP___10 = 1
} ;
#line 81
enum __anonenum__1195___0 {
    PTHREAD_PRIO_NONE___10 = 0,
    PTHREAD_PRIO_INHERIT___10 = 1,
    PTHREAD_PRIO_PROTECT___10 = 2
} ;
#line 104
enum __anonenum__1196___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___10 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___10 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___10 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___10 = 0
} ;
#line 124
enum __anonenum__1197___0 {
    PTHREAD_INHERIT_SCHED___10 = 0,
    PTHREAD_EXPLICIT_SCHED___10 = 1
} ;
#line 134
enum __anonenum__1198___0 {
    PTHREAD_SCOPE_SYSTEM___10 = 0,
    PTHREAD_SCOPE_PROCESS___10 = 1
} ;
#line 144
enum __anonenum__1199___0 {
    PTHREAD_PROCESS_PRIVATE___10 = 0,
    PTHREAD_PROCESS_SHARED___10 = 1
} ;
#line 168
enum __anonenum__1200___0 {
    PTHREAD_CANCEL_ENABLE___10 = 0,
    PTHREAD_CANCEL_DISABLE___10 = 1
} ;
#line 175
enum __anonenum__1201___0 {
    PTHREAD_CANCEL_DEFERRED___10 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___10 = 1
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1243 {
    MSG_OOB___5 = 1,
    MSG_PEEK___5 = 2,
    MSG_DONTROUTE___5 = 4,
    MSG_TRYHARD___5 = 4,
    MSG_CTRUNC___5 = 8,
    MSG_PROXY___5 = 16,
    MSG_TRUNC___5 = 32,
    MSG_DONTWAIT___5 = 64,
    MSG_EOR___5 = 128,
    MSG_WAITALL___5 = 256,
    MSG_FIN___5 = 512,
    MSG_SYN___5 = 1024,
    MSG_CONFIRM___5 = 2048,
    MSG_RST___5 = 4096,
    MSG_ERRQUEUE___5 = 8192,
    MSG_NOSIGNAL___5 = 16384,
    MSG_MORE___5 = 32768,
    MSG_WAITFORONE___5 = 65536,
    MSG_BATCH___5 = 262144,
    MSG_ZEROCOPY___5 = 67108864,
    MSG_FASTOPEN___5 = 536870912,
    MSG_CMSG_CLOEXEC___5 = 1073741824
} ;
#line 334
enum __anonenum__1244 {
    SCM_RIGHTS___5 = 1,
    SCM_CREDENTIALS___5 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1247 {
    SHUT_RD___5 = 0,
    SHUT_WR___5 = 1,
    SHUT_RDWR___5 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1250 {
    IPPROTO_IP___5 = 0,
    IPPROTO_ICMP___5 = 1,
    IPPROTO_IGMP___5 = 2,
    IPPROTO_IPIP___5 = 4,
    IPPROTO_TCP___5 = 6,
    IPPROTO_EGP___5 = 8,
    IPPROTO_PUP___5 = 12,
    IPPROTO_UDP___5 = 17,
    IPPROTO_IDP___5 = 22,
    IPPROTO_TP___5 = 29,
    IPPROTO_DCCP___5 = 33,
    IPPROTO_IPV6___5 = 41,
    IPPROTO_RSVP___5 = 46,
    IPPROTO_GRE___5 = 47,
    IPPROTO_ESP___5 = 50,
    IPPROTO_AH___5 = 51,
    IPPROTO_MTP___5 = 92,
    IPPROTO_BEETPH___5 = 94,
    IPPROTO_ENCAP___5 = 98,
    IPPROTO_PIM___5 = 103,
    IPPROTO_COMP___5 = 108,
    IPPROTO_SCTP___5 = 132,
    IPPROTO_UDPLITE___5 = 136,
    IPPROTO_MPLS___5 = 137,
    IPPROTO_ETHERNET___5 = 143,
    IPPROTO_RAW___5 = 255,
    IPPROTO_MPTCP___5 = 262,
    IPPROTO_MAX___5 = 263
} ;
#line 103
enum __anonenum__1251 {
    IPPROTO_HOPOPTS___5 = 0,
    IPPROTO_ROUTING___5 = 43,
    IPPROTO_FRAGMENT___5 = 44,
    IPPROTO_ICMPV6___5 = 58,
    IPPROTO_NONE___5 = 59,
    IPPROTO_DSTOPTS___5 = 60,
    IPPROTO_MH___5 = 135
} ;
#line 126
enum __anonenum__1252 {
    IPPORT_ECHO___5 = 7,
    IPPORT_DISCARD___5 = 9,
    IPPORT_SYSTAT___5 = 11,
    IPPORT_DAYTIME___5 = 13,
    IPPORT_NETSTAT___5 = 15,
    IPPORT_FTP___5 = 21,
    IPPORT_TELNET___5 = 23,
    IPPORT_SMTP___5 = 25,
    IPPORT_TIMESERVER___5 = 37,
    IPPORT_NAMESERVER___5 = 42,
    IPPORT_WHOIS___5 = 43,
    IPPORT_MTP___5 = 57,
    IPPORT_TFTP___5 = 69,
    IPPORT_RJE___5 = 77,
    IPPORT_FINGER___5 = 79,
    IPPORT_TTYLINK___5 = 87,
    IPPORT_SUPDUP___5 = 95,
    IPPORT_EXECSERVER___5 = 512,
    IPPORT_LOGINSERVER___5 = 513,
    IPPORT_CMDSERVER___5 = 514,
    IPPORT_EFSSERVER___5 = 520,
    IPPORT_BIFFUDP___5 = 512,
    IPPORT_WHOSERVER___5 = 513,
    IPPORT_ROUTESERVER___5 = 520,
    IPPORT_RESERVED___5 = 1024,
    IPPORT_USERRESERVED___5 = 5000
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__507___1 {
    MSG_OOB___6 = 1,
    MSG_PEEK___6 = 2,
    MSG_DONTROUTE___6 = 4,
    MSG_TRYHARD___6 = 4,
    MSG_CTRUNC___6 = 8,
    MSG_PROXY___6 = 16,
    MSG_TRUNC___6 = 32,
    MSG_DONTWAIT___6 = 64,
    MSG_EOR___6 = 128,
    MSG_WAITALL___6 = 256,
    MSG_FIN___6 = 512,
    MSG_SYN___6 = 1024,
    MSG_CONFIRM___6 = 2048,
    MSG_RST___6 = 4096,
    MSG_ERRQUEUE___6 = 8192,
    MSG_NOSIGNAL___6 = 16384,
    MSG_MORE___6 = 32768,
    MSG_WAITFORONE___6 = 65536,
    MSG_BATCH___6 = 262144,
    MSG_ZEROCOPY___6 = 67108864,
    MSG_FASTOPEN___6 = 536870912,
    MSG_CMSG_CLOEXEC___6 = 1073741824
} ;
#line 334
enum __anonenum__508___1 {
    SCM_RIGHTS___6 = 1,
    SCM_CREDENTIALS___6 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__511___1 {
    SHUT_RD___6 = 0,
    SHUT_WR___6 = 1,
    SHUT_RDWR___6 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__514___1 {
    IPPROTO_IP___6 = 0,
    IPPROTO_ICMP___6 = 1,
    IPPROTO_IGMP___6 = 2,
    IPPROTO_IPIP___6 = 4,
    IPPROTO_TCP___6 = 6,
    IPPROTO_EGP___6 = 8,
    IPPROTO_PUP___6 = 12,
    IPPROTO_UDP___6 = 17,
    IPPROTO_IDP___6 = 22,
    IPPROTO_TP___6 = 29,
    IPPROTO_DCCP___6 = 33,
    IPPROTO_IPV6___6 = 41,
    IPPROTO_RSVP___6 = 46,
    IPPROTO_GRE___6 = 47,
    IPPROTO_ESP___6 = 50,
    IPPROTO_AH___6 = 51,
    IPPROTO_MTP___6 = 92,
    IPPROTO_BEETPH___6 = 94,
    IPPROTO_ENCAP___6 = 98,
    IPPROTO_PIM___6 = 103,
    IPPROTO_COMP___6 = 108,
    IPPROTO_SCTP___6 = 132,
    IPPROTO_UDPLITE___6 = 136,
    IPPROTO_MPLS___6 = 137,
    IPPROTO_ETHERNET___6 = 143,
    IPPROTO_RAW___6 = 255,
    IPPROTO_MPTCP___6 = 262,
    IPPROTO_MAX___6 = 263
} ;
#line 103
enum __anonenum__515___1 {
    IPPROTO_HOPOPTS___6 = 0,
    IPPROTO_ROUTING___6 = 43,
    IPPROTO_FRAGMENT___6 = 44,
    IPPROTO_ICMPV6___6 = 58,
    IPPROTO_NONE___6 = 59,
    IPPROTO_DSTOPTS___6 = 60,
    IPPROTO_MH___6 = 135
} ;
#line 126
enum __anonenum__516___1 {
    IPPORT_ECHO___6 = 7,
    IPPORT_DISCARD___6 = 9,
    IPPORT_SYSTAT___6 = 11,
    IPPORT_DAYTIME___6 = 13,
    IPPORT_NETSTAT___6 = 15,
    IPPORT_FTP___6 = 21,
    IPPORT_TELNET___6 = 23,
    IPPORT_SMTP___6 = 25,
    IPPORT_TIMESERVER___6 = 37,
    IPPORT_NAMESERVER___6 = 42,
    IPPORT_WHOIS___6 = 43,
    IPPORT_MTP___6 = 57,
    IPPORT_TFTP___6 = 69,
    IPPORT_RJE___6 = 77,
    IPPORT_FINGER___6 = 79,
    IPPORT_TTYLINK___6 = 87,
    IPPORT_SUPDUP___6 = 95,
    IPPORT_EXECSERVER___6 = 512,
    IPPORT_LOGINSERVER___6 = 513,
    IPPORT_CMDSERVER___6 = 514,
    IPPORT_EFSSERVER___6 = 520,
    IPPORT_BIFFUDP___6 = 512,
    IPPORT_WHOSERVER___6 = 513,
    IPPORT_ROUTESERVER___6 = 520,
    IPPORT_RESERVED___6 = 1024,
    IPPORT_USERRESERVED___6 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__528___1 {
    SI_ASYNCNL___11 = -60,
    SI_DETHREAD___11 = -7,
    SI_TKILL___11 = -6,
    SI_SIGIO___11 = -5,
    SI_ASYNCIO___11 = -4,
    SI_MESGQ___11 = -3,
    SI_TIMER___11 = -2,
    SI_QUEUE___11 = -1,
    SI_USER___11 = 0,
    SI_KERNEL___11 = 128
} ;
#line 71
enum __anonenum__529___1 {
    ILL_ILLOPC___11 = 1,
    ILL_ILLOPN___11 = 2,
    ILL_ILLADR___11 = 3,
    ILL_ILLTRP___11 = 4,
    ILL_PRVOPC___11 = 5,
    ILL_PRVREG___11 = 6,
    ILL_COPROC___11 = 7,
    ILL_BADSTK___11 = 8,
    ILL_BADIADDR___11 = 9
} ;
#line 94
enum __anonenum__530___1 {
    FPE_INTDIV___11 = 1,
    FPE_INTOVF___11 = 2,
    FPE_FLTDIV___11 = 3,
    FPE_FLTOVF___11 = 4,
    FPE_FLTUND___11 = 5,
    FPE_FLTRES___11 = 6,
    FPE_FLTINV___11 = 7,
    FPE_FLTSUB___11 = 8,
    FPE_FLTUNK___11 = 14,
    FPE_CONDTRAP___11 = 15
} ;
#line 119
enum __anonenum__531___1 {
    SEGV_MAPERR___11 = 1,
    SEGV_ACCERR___11 = 2,
    SEGV_BNDERR___11 = 3,
    SEGV_PKUERR___11 = 4,
    SEGV_ACCADI___11 = 5,
    SEGV_ADIDERR___11 = 6,
    SEGV_ADIPERR___11 = 7,
    SEGV_MTEAERR___11 = 8,
    SEGV_MTESERR___11 = 9
} ;
#line 142
enum __anonenum__532___1 {
    BUS_ADRALN___11 = 1,
    BUS_ADRERR___11 = 2,
    BUS_OBJERR___11 = 3,
    BUS_MCEERR_AR___11 = 4,
    BUS_MCEERR_AO___11 = 5
} ;
#line 159
enum __anonenum__533___1 {
    TRAP_BRKPT___6 = 1,
    TRAP_TRACE___6 = 2,
    TRAP_BRANCH___6 = 3,
    TRAP_HWBKPT___6 = 4,
    TRAP_UNK___6 = 5
} ;
#line 176
enum __anonenum__534___1 {
    CLD_EXITED___11 = 1,
    CLD_KILLED___11 = 2,
    CLD_DUMPED___11 = 3,
    CLD_TRAPPED___11 = 4,
    CLD_STOPPED___11 = 5,
    CLD_CONTINUED___11 = 6
} ;
#line 193
enum __anonenum__535___1 {
    POLL_IN___11 = 1,
    POLL_OUT___11 = 2,
    POLL_MSG___11 = 3,
    POLL_ERR___11 = 4,
    POLL_PRI___11 = 5,
    POLL_HUP___11 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__538___1 {
    SIGEV_SIGNAL___11 = 0,
    SIGEV_NONE___11 = 1,
    SIGEV_THREAD___11 = 2,
    SIGEV_THREAD_ID___11 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__542___1 {
    REG_R8___6 = 0,
    REG_R9___6 = 1,
    REG_R10___6 = 2,
    REG_R11___6 = 3,
    REG_R12___6 = 4,
    REG_R13___6 = 5,
    REG_R14___6 = 6,
    REG_R15___6 = 7,
    REG_RDI___6 = 8,
    REG_RSI___6 = 9,
    REG_RBP___6 = 10,
    REG_RBX___6 = 11,
    REG_RDX___6 = 12,
    REG_RAX___6 = 13,
    REG_RCX___6 = 14,
    REG_RSP___6 = 15,
    REG_RIP___6 = 16,
    REG_EFL___6 = 17,
    REG_CSGSFS___6 = 18,
    REG_ERR___6 = 19,
    REG_TRAPNO___6 = 20,
    REG_OLDMASK___6 = 21,
    REG_CR2___6 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__544___1 {
    _PC_LINK_MAX___7 = 0,
    _PC_MAX_CANON___7 = 1,
    _PC_MAX_INPUT___7 = 2,
    _PC_NAME_MAX___7 = 3,
    _PC_PATH_MAX___7 = 4,
    _PC_PIPE_BUF___7 = 5,
    _PC_CHOWN_RESTRICTED___7 = 6,
    _PC_NO_TRUNC___7 = 7,
    _PC_VDISABLE___7 = 8,
    _PC_SYNC_IO___7 = 9,
    _PC_ASYNC_IO___7 = 10,
    _PC_PRIO_IO___7 = 11,
    _PC_SOCK_MAXBUF___7 = 12,
    _PC_FILESIZEBITS___7 = 13,
    _PC_REC_INCR_XFER_SIZE___7 = 14,
    _PC_REC_MAX_XFER_SIZE___7 = 15,
    _PC_REC_MIN_XFER_SIZE___7 = 16,
    _PC_REC_XFER_ALIGN___7 = 17,
    _PC_ALLOC_SIZE_MIN___7 = 18,
    _PC_SYMLINK_MAX___7 = 19,
    _PC_2_SYMLINKS___7 = 20
} ;
#line 71
enum __anonenum__545___1 {
    _SC_ARG_MAX___7 = 0,
    _SC_CHILD_MAX___7 = 1,
    _SC_CLK_TCK___7 = 2,
    _SC_NGROUPS_MAX___7 = 3,
    _SC_OPEN_MAX___7 = 4,
    _SC_STREAM_MAX___7 = 5,
    _SC_TZNAME_MAX___7 = 6,
    _SC_JOB_CONTROL___7 = 7,
    _SC_SAVED_IDS___7 = 8,
    _SC_REALTIME_SIGNALS___7 = 9,
    _SC_PRIORITY_SCHEDULING___7 = 10,
    _SC_TIMERS___7 = 11,
    _SC_ASYNCHRONOUS_IO___7 = 12,
    _SC_PRIORITIZED_IO___7 = 13,
    _SC_SYNCHRONIZED_IO___7 = 14,
    _SC_FSYNC___7 = 15,
    _SC_MAPPED_FILES___7 = 16,
    _SC_MEMLOCK___7 = 17,
    _SC_MEMLOCK_RANGE___7 = 18,
    _SC_MEMORY_PROTECTION___7 = 19,
    _SC_MESSAGE_PASSING___7 = 20,
    _SC_SEMAPHORES___7 = 21,
    _SC_SHARED_MEMORY_OBJECTS___7 = 22,
    _SC_AIO_LISTIO_MAX___7 = 23,
    _SC_AIO_MAX___7 = 24,
    _SC_AIO_PRIO_DELTA_MAX___7 = 25,
    _SC_DELAYTIMER_MAX___7 = 26,
    _SC_MQ_OPEN_MAX___7 = 27,
    _SC_MQ_PRIO_MAX___7 = 28,
    _SC_VERSION___7 = 29,
    _SC_PAGESIZE___7 = 30,
    _SC_RTSIG_MAX___7 = 31,
    _SC_SEM_NSEMS_MAX___7 = 32,
    _SC_SEM_VALUE_MAX___7 = 33,
    _SC_SIGQUEUE_MAX___7 = 34,
    _SC_TIMER_MAX___7 = 35,
    _SC_BC_BASE_MAX___7 = 36,
    _SC_BC_DIM_MAX___7 = 37,
    _SC_BC_SCALE_MAX___7 = 38,
    _SC_BC_STRING_MAX___7 = 39,
    _SC_COLL_WEIGHTS_MAX___7 = 40,
    _SC_EQUIV_CLASS_MAX___7 = 41,
    _SC_EXPR_NEST_MAX___7 = 42,
    _SC_LINE_MAX___7 = 43,
    _SC_RE_DUP_MAX___7 = 44,
    _SC_CHARCLASS_NAME_MAX___7 = 45,
    _SC_2_VERSION___7 = 46,
    _SC_2_C_BIND___7 = 47,
    _SC_2_C_DEV___7 = 48,
    _SC_2_FORT_DEV___7 = 49,
    _SC_2_FORT_RUN___7 = 50,
    _SC_2_SW_DEV___7 = 51,
    _SC_2_LOCALEDEF___7 = 52,
    _SC_PII___7 = 53,
    _SC_PII_XTI___7 = 54,
    _SC_PII_SOCKET___7 = 55,
    _SC_PII_INTERNET___7 = 56,
    _SC_PII_OSI___7 = 57,
    _SC_POLL___7 = 58,
    _SC_SELECT___7 = 59,
    _SC_UIO_MAXIOV___7 = 60,
    _SC_IOV_MAX___7 = 60,
    _SC_PII_INTERNET_STREAM___7 = 61,
    _SC_PII_INTERNET_DGRAM___7 = 62,
    _SC_PII_OSI_COTS___7 = 63,
    _SC_PII_OSI_CLTS___7 = 64,
    _SC_PII_OSI_M___7 = 65,
    _SC_T_IOV_MAX___7 = 66,
    _SC_THREADS___7 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___7 = 68,
    _SC_GETGR_R_SIZE_MAX___7 = 69,
    _SC_GETPW_R_SIZE_MAX___7 = 70,
    _SC_LOGIN_NAME_MAX___7 = 71,
    _SC_TTY_NAME_MAX___7 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___7 = 73,
    _SC_THREAD_KEYS_MAX___7 = 74,
    _SC_THREAD_STACK_MIN___7 = 75,
    _SC_THREAD_THREADS_MAX___7 = 76,
    _SC_THREAD_ATTR_STACKADDR___7 = 77,
    _SC_THREAD_ATTR_STACKSIZE___7 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___7 = 79,
    _SC_THREAD_PRIO_INHERIT___7 = 80,
    _SC_THREAD_PRIO_PROTECT___7 = 81,
    _SC_THREAD_PROCESS_SHARED___7 = 82,
    _SC_NPROCESSORS_CONF___7 = 83,
    _SC_NPROCESSORS_ONLN___7 = 84,
    _SC_PHYS_PAGES___7 = 85,
    _SC_AVPHYS_PAGES___7 = 86,
    _SC_ATEXIT_MAX___7 = 87,
    _SC_PASS_MAX___7 = 88,
    _SC_XOPEN_VERSION___7 = 89,
    _SC_XOPEN_XCU_VERSION___7 = 90,
    _SC_XOPEN_UNIX___7 = 91,
    _SC_XOPEN_CRYPT___7 = 92,
    _SC_XOPEN_ENH_I18N___7 = 93,
    _SC_XOPEN_SHM___7 = 94,
    _SC_2_CHAR_TERM___7 = 95,
    _SC_2_C_VERSION___7 = 96,
    _SC_2_UPE___7 = 97,
    _SC_XOPEN_XPG2___7 = 98,
    _SC_XOPEN_XPG3___7 = 99,
    _SC_XOPEN_XPG4___7 = 100,
    _SC_CHAR_BIT___7 = 101,
    _SC_CHAR_MAX___7 = 102,
    _SC_CHAR_MIN___7 = 103,
    _SC_INT_MAX___7 = 104,
    _SC_INT_MIN___7 = 105,
    _SC_LONG_BIT___7 = 106,
    _SC_WORD_BIT___7 = 107,
    _SC_MB_LEN_MAX___7 = 108,
    _SC_NZERO___7 = 109,
    _SC_SSIZE_MAX___7 = 110,
    _SC_SCHAR_MAX___7 = 111,
    _SC_SCHAR_MIN___7 = 112,
    _SC_SHRT_MAX___7 = 113,
    _SC_SHRT_MIN___7 = 114,
    _SC_UCHAR_MAX___7 = 115,
    _SC_UINT_MAX___7 = 116,
    _SC_ULONG_MAX___7 = 117,
    _SC_USHRT_MAX___7 = 118,
    _SC_NL_ARGMAX___7 = 119,
    _SC_NL_LANGMAX___7 = 120,
    _SC_NL_MSGMAX___7 = 121,
    _SC_NL_NMAX___7 = 122,
    _SC_NL_SETMAX___7 = 123,
    _SC_NL_TEXTMAX___7 = 124,
    _SC_XBS5_ILP32_OFF32___7 = 125,
    _SC_XBS5_ILP32_OFFBIG___7 = 126,
    _SC_XBS5_LP64_OFF64___7 = 127,
    _SC_XBS5_LPBIG_OFFBIG___7 = 128,
    _SC_XOPEN_LEGACY___7 = 129,
    _SC_XOPEN_REALTIME___7 = 130,
    _SC_XOPEN_REALTIME_THREADS___7 = 131,
    _SC_ADVISORY_INFO___7 = 132,
    _SC_BARRIERS___7 = 133,
    _SC_BASE___7 = 134,
    _SC_C_LANG_SUPPORT___7 = 135,
    _SC_C_LANG_SUPPORT_R___7 = 136,
    _SC_CLOCK_SELECTION___7 = 137,
    _SC_CPUTIME___7 = 138,
    _SC_THREAD_CPUTIME___7 = 139,
    _SC_DEVICE_IO___7 = 140,
    _SC_DEVICE_SPECIFIC___7 = 141,
    _SC_DEVICE_SPECIFIC_R___7 = 142,
    _SC_FD_MGMT___7 = 143,
    _SC_FIFO___7 = 144,
    _SC_PIPE___7 = 145,
    _SC_FILE_ATTRIBUTES___7 = 146,
    _SC_FILE_LOCKING___7 = 147,
    _SC_FILE_SYSTEM___7 = 148,
    _SC_MONOTONIC_CLOCK___7 = 149,
    _SC_MULTI_PROCESS___7 = 150,
    _SC_SINGLE_PROCESS___7 = 151,
    _SC_NETWORKING___7 = 152,
    _SC_READER_WRITER_LOCKS___7 = 153,
    _SC_SPIN_LOCKS___7 = 154,
    _SC_REGEXP___7 = 155,
    _SC_REGEX_VERSION___7 = 156,
    _SC_SHELL___7 = 157,
    _SC_SIGNALS___7 = 158,
    _SC_SPAWN___7 = 159,
    _SC_SPORADIC_SERVER___7 = 160,
    _SC_THREAD_SPORADIC_SERVER___7 = 161,
    _SC_SYSTEM_DATABASE___7 = 162,
    _SC_SYSTEM_DATABASE_R___7 = 163,
    _SC_TIMEOUTS___7 = 164,
    _SC_TYPED_MEMORY_OBJECTS___7 = 165,
    _SC_USER_GROUPS___7 = 166,
    _SC_USER_GROUPS_R___7 = 167,
    _SC_2_PBS___7 = 168,
    _SC_2_PBS_ACCOUNTING___7 = 169,
    _SC_2_PBS_LOCATE___7 = 170,
    _SC_2_PBS_MESSAGE___7 = 171,
    _SC_2_PBS_TRACK___7 = 172,
    _SC_SYMLOOP_MAX___7 = 173,
    _SC_STREAMS___7 = 174,
    _SC_2_PBS_CHECKPOINT___7 = 175,
    _SC_V6_ILP32_OFF32___7 = 176,
    _SC_V6_ILP32_OFFBIG___7 = 177,
    _SC_V6_LP64_OFF64___7 = 178,
    _SC_V6_LPBIG_OFFBIG___7 = 179,
    _SC_HOST_NAME_MAX___7 = 180,
    _SC_TRACE___7 = 181,
    _SC_TRACE_EVENT_FILTER___7 = 182,
    _SC_TRACE_INHERIT___7 = 183,
    _SC_TRACE_LOG___7 = 184,
    _SC_LEVEL1_ICACHE_SIZE___7 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___7 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___7 = 187,
    _SC_LEVEL1_DCACHE_SIZE___7 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___7 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___7 = 190,
    _SC_LEVEL2_CACHE_SIZE___7 = 191,
    _SC_LEVEL2_CACHE_ASSOC___7 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___7 = 193,
    _SC_LEVEL3_CACHE_SIZE___7 = 194,
    _SC_LEVEL3_CACHE_ASSOC___7 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___7 = 196,
    _SC_LEVEL4_CACHE_SIZE___7 = 197,
    _SC_LEVEL4_CACHE_ASSOC___7 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___7 = 199,
    _SC_IPV6___7 = 235,
    _SC_RAW_SOCKETS___7 = 236,
    _SC_V7_ILP32_OFF32___7 = 237,
    _SC_V7_ILP32_OFFBIG___7 = 238,
    _SC_V7_LP64_OFF64___7 = 239,
    _SC_V7_LPBIG_OFFBIG___7 = 240,
    _SC_SS_REPL_MAX___7 = 241,
    _SC_TRACE_EVENT_NAME_MAX___7 = 242,
    _SC_TRACE_NAME_MAX___7 = 243,
    _SC_TRACE_SYS_MAX___7 = 244,
    _SC_TRACE_USER_EVENT_MAX___7 = 245,
    _SC_XOPEN_STREAMS___7 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___7 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___7 = 248,
    _SC_MINSIGSTKSZ___7 = 249,
    _SC_SIGSTKSZ___7 = 250
} ;
#line 539
enum __anonenum__546___1 {
    _CS_PATH___7 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___7 = 1,
    _CS_GNU_LIBC_VERSION___7 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___7 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___7 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___7 = 5,
    _CS_LFS_CFLAGS___7 = 1000,
    _CS_LFS_LDFLAGS___7 = 1001,
    _CS_LFS_LIBS___7 = 1002,
    _CS_LFS_LINTFLAGS___7 = 1003,
    _CS_LFS64_CFLAGS___7 = 1004,
    _CS_LFS64_LDFLAGS___7 = 1005,
    _CS_LFS64_LIBS___7 = 1006,
    _CS_LFS64_LINTFLAGS___7 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___7 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___7 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___7 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___7 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___7 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___7 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___7 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___7 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___7 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___7 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___7 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___7 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___7 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___7 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___7 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___7 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___7 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___7 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___7 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___7 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___7 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___7 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___7 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___7 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___7 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___7 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___7 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___7 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___7 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___7 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___7 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___7 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___7 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___7 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___7 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___7 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___7 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___7 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___7 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___7 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___7 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___7 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___7 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___7 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___7 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___7 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___7 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___7 = 1147,
    _CS_V6_ENV___7 = 1148,
    _CS_V7_ENV___7 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__547___1 {
    SS_ONSTACK___11 = 1,
    SS_DISABLE___11 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__555___2 {
    PTHREAD_CREATE_JOINABLE___11 = 0,
    PTHREAD_CREATE_DETACHED___11 = 1
} ;
#line 47
enum __anonenum__556___2 {
    PTHREAD_MUTEX_TIMED_NP___11 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___11 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___11 = 3,
    PTHREAD_MUTEX_NORMAL___11 = 0,
    PTHREAD_MUTEX_RECURSIVE___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK___11 = 2,
    PTHREAD_MUTEX_DEFAULT___11 = 0,
    PTHREAD_MUTEX_FAST_NP___6 = 0
} ;
#line 69
enum __anonenum__557___2 {
    PTHREAD_MUTEX_STALLED___11 = 0,
    PTHREAD_MUTEX_STALLED_NP___11 = 0,
    PTHREAD_MUTEX_ROBUST___11 = 1,
    PTHREAD_MUTEX_ROBUST_NP___11 = 1
} ;
#line 81
enum __anonenum__558___2 {
    PTHREAD_PRIO_NONE___11 = 0,
    PTHREAD_PRIO_INHERIT___11 = 1,
    PTHREAD_PRIO_PROTECT___11 = 2
} ;
#line 104
enum __anonenum__559___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___11 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___11 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___11 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___11 = 0
} ;
#line 124
enum __anonenum__560___2 {
    PTHREAD_INHERIT_SCHED___11 = 0,
    PTHREAD_EXPLICIT_SCHED___11 = 1
} ;
#line 134
enum __anonenum__561___2 {
    PTHREAD_SCOPE_SYSTEM___11 = 0,
    PTHREAD_SCOPE_PROCESS___11 = 1
} ;
#line 144
enum __anonenum__562___2 {
    PTHREAD_PROCESS_PRIVATE___11 = 0,
    PTHREAD_PROCESS_SHARED___11 = 1
} ;
#line 168
enum __anonenum__563___2 {
    PTHREAD_CANCEL_ENABLE___11 = 0,
    PTHREAD_CANCEL_DISABLE___11 = 1
} ;
#line 175
enum __anonenum__564___2 {
    PTHREAD_CANCEL_DEFERRED___11 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___11 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__580___2 {
    DT_UNKNOWN___10 = 0,
    DT_FIFO___10 = 1,
    DT_CHR___10 = 2,
    DT_DIR___10 = 4,
    DT_BLK___10 = 6,
    DT_REG___10 = 8,
    DT_LNK___10 = 10,
    DT_SOCK___10 = 12,
    DT_WHT___10 = 14
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1293 {
    MSG_OOB___7 = 1,
    MSG_PEEK___7 = 2,
    MSG_DONTROUTE___7 = 4,
    MSG_TRYHARD___7 = 4,
    MSG_CTRUNC___7 = 8,
    MSG_PROXY___7 = 16,
    MSG_TRUNC___7 = 32,
    MSG_DONTWAIT___7 = 64,
    MSG_EOR___7 = 128,
    MSG_WAITALL___7 = 256,
    MSG_FIN___7 = 512,
    MSG_SYN___7 = 1024,
    MSG_CONFIRM___7 = 2048,
    MSG_RST___7 = 4096,
    MSG_ERRQUEUE___7 = 8192,
    MSG_NOSIGNAL___7 = 16384,
    MSG_MORE___7 = 32768,
    MSG_WAITFORONE___7 = 65536,
    MSG_BATCH___7 = 262144,
    MSG_ZEROCOPY___7 = 67108864,
    MSG_FASTOPEN___7 = 536870912,
    MSG_CMSG_CLOEXEC___7 = 1073741824
} ;
#line 334
enum __anonenum__1294 {
    SCM_RIGHTS___7 = 1,
    SCM_CREDENTIALS___7 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1297 {
    SHUT_RD___7 = 0,
    SHUT_WR___7 = 1,
    SHUT_RDWR___7 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1300 {
    IPPROTO_IP___7 = 0,
    IPPROTO_ICMP___7 = 1,
    IPPROTO_IGMP___7 = 2,
    IPPROTO_IPIP___7 = 4,
    IPPROTO_TCP___7 = 6,
    IPPROTO_EGP___7 = 8,
    IPPROTO_PUP___7 = 12,
    IPPROTO_UDP___7 = 17,
    IPPROTO_IDP___7 = 22,
    IPPROTO_TP___7 = 29,
    IPPROTO_DCCP___7 = 33,
    IPPROTO_IPV6___7 = 41,
    IPPROTO_RSVP___7 = 46,
    IPPROTO_GRE___7 = 47,
    IPPROTO_ESP___7 = 50,
    IPPROTO_AH___7 = 51,
    IPPROTO_MTP___7 = 92,
    IPPROTO_BEETPH___7 = 94,
    IPPROTO_ENCAP___7 = 98,
    IPPROTO_PIM___7 = 103,
    IPPROTO_COMP___7 = 108,
    IPPROTO_SCTP___7 = 132,
    IPPROTO_UDPLITE___7 = 136,
    IPPROTO_MPLS___7 = 137,
    IPPROTO_ETHERNET___7 = 143,
    IPPROTO_RAW___7 = 255,
    IPPROTO_MPTCP___7 = 262,
    IPPROTO_MAX___7 = 263
} ;
#line 103
enum __anonenum__1301 {
    IPPROTO_HOPOPTS___7 = 0,
    IPPROTO_ROUTING___7 = 43,
    IPPROTO_FRAGMENT___7 = 44,
    IPPROTO_ICMPV6___7 = 58,
    IPPROTO_NONE___7 = 59,
    IPPROTO_DSTOPTS___7 = 60,
    IPPROTO_MH___7 = 135
} ;
#line 126
enum __anonenum__1302 {
    IPPORT_ECHO___7 = 7,
    IPPORT_DISCARD___7 = 9,
    IPPORT_SYSTAT___7 = 11,
    IPPORT_DAYTIME___7 = 13,
    IPPORT_NETSTAT___7 = 15,
    IPPORT_FTP___7 = 21,
    IPPORT_TELNET___7 = 23,
    IPPORT_SMTP___7 = 25,
    IPPORT_TIMESERVER___7 = 37,
    IPPORT_NAMESERVER___7 = 42,
    IPPORT_WHOIS___7 = 43,
    IPPORT_MTP___7 = 57,
    IPPORT_TFTP___7 = 69,
    IPPORT_RJE___7 = 77,
    IPPORT_FINGER___7 = 79,
    IPPORT_TTYLINK___7 = 87,
    IPPORT_SUPDUP___7 = 95,
    IPPORT_EXECSERVER___7 = 512,
    IPPORT_LOGINSERVER___7 = 513,
    IPPORT_CMDSERVER___7 = 514,
    IPPORT_EFSSERVER___7 = 520,
    IPPORT_BIFFUDP___7 = 512,
    IPPORT_WHOSERVER___7 = 513,
    IPPORT_ROUTESERVER___7 = 520,
    IPPORT_RESERVED___7 = 1024,
    IPPORT_USERRESERVED___7 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1315 {
    SI_ASYNCNL___12 = -60,
    SI_DETHREAD___12 = -7,
    SI_TKILL___12 = -6,
    SI_SIGIO___12 = -5,
    SI_ASYNCIO___12 = -4,
    SI_MESGQ___12 = -3,
    SI_TIMER___12 = -2,
    SI_QUEUE___12 = -1,
    SI_USER___12 = 0,
    SI_KERNEL___12 = 128
} ;
#line 71
enum __anonenum__1316 {
    ILL_ILLOPC___12 = 1,
    ILL_ILLOPN___12 = 2,
    ILL_ILLADR___12 = 3,
    ILL_ILLTRP___12 = 4,
    ILL_PRVOPC___12 = 5,
    ILL_PRVREG___12 = 6,
    ILL_COPROC___12 = 7,
    ILL_BADSTK___12 = 8,
    ILL_BADIADDR___12 = 9
} ;
#line 94
enum __anonenum__1317 {
    FPE_INTDIV___12 = 1,
    FPE_INTOVF___12 = 2,
    FPE_FLTDIV___12 = 3,
    FPE_FLTOVF___12 = 4,
    FPE_FLTUND___12 = 5,
    FPE_FLTRES___12 = 6,
    FPE_FLTINV___12 = 7,
    FPE_FLTSUB___12 = 8,
    FPE_FLTUNK___12 = 14,
    FPE_CONDTRAP___12 = 15
} ;
#line 119
enum __anonenum__1318 {
    SEGV_MAPERR___12 = 1,
    SEGV_ACCERR___12 = 2,
    SEGV_BNDERR___12 = 3,
    SEGV_PKUERR___12 = 4,
    SEGV_ACCADI___12 = 5,
    SEGV_ADIDERR___12 = 6,
    SEGV_ADIPERR___12 = 7,
    SEGV_MTEAERR___12 = 8,
    SEGV_MTESERR___12 = 9
} ;
#line 142
enum __anonenum__1319 {
    BUS_ADRALN___12 = 1,
    BUS_ADRERR___12 = 2,
    BUS_OBJERR___12 = 3,
    BUS_MCEERR_AR___12 = 4,
    BUS_MCEERR_AO___12 = 5
} ;
#line 159
enum __anonenum__1320 {
    TRAP_BRKPT___7 = 1,
    TRAP_TRACE___7 = 2,
    TRAP_BRANCH___7 = 3,
    TRAP_HWBKPT___7 = 4,
    TRAP_UNK___7 = 5
} ;
#line 176
enum __anonenum__535___2 {
    CLD_EXITED___12 = 1,
    CLD_KILLED___12 = 2,
    CLD_DUMPED___12 = 3,
    CLD_TRAPPED___12 = 4,
    CLD_STOPPED___12 = 5,
    CLD_CONTINUED___12 = 6
} ;
#line 193
enum __anonenum__1321 {
    POLL_IN___12 = 1,
    POLL_OUT___12 = 2,
    POLL_MSG___12 = 3,
    POLL_ERR___12 = 4,
    POLL_PRI___12 = 5,
    POLL_HUP___12 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1324 {
    SIGEV_SIGNAL___12 = 0,
    SIGEV_NONE___12 = 1,
    SIGEV_THREAD___12 = 2,
    SIGEV_THREAD_ID___12 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1328 {
    REG_R8___7 = 0,
    REG_R9___7 = 1,
    REG_R10___7 = 2,
    REG_R11___7 = 3,
    REG_R12___7 = 4,
    REG_R13___7 = 5,
    REG_R14___7 = 6,
    REG_R15___7 = 7,
    REG_RDI___7 = 8,
    REG_RSI___7 = 9,
    REG_RBP___7 = 10,
    REG_RBX___7 = 11,
    REG_RDX___7 = 12,
    REG_RAX___7 = 13,
    REG_RCX___7 = 14,
    REG_RSP___7 = 15,
    REG_RIP___7 = 16,
    REG_EFL___7 = 17,
    REG_CSGSFS___7 = 18,
    REG_ERR___7 = 19,
    REG_TRAPNO___7 = 20,
    REG_OLDMASK___7 = 21,
    REG_CR2___7 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1330 {
    _PC_LINK_MAX___8 = 0,
    _PC_MAX_CANON___8 = 1,
    _PC_MAX_INPUT___8 = 2,
    _PC_NAME_MAX___8 = 3,
    _PC_PATH_MAX___8 = 4,
    _PC_PIPE_BUF___8 = 5,
    _PC_CHOWN_RESTRICTED___8 = 6,
    _PC_NO_TRUNC___8 = 7,
    _PC_VDISABLE___8 = 8,
    _PC_SYNC_IO___8 = 9,
    _PC_ASYNC_IO___8 = 10,
    _PC_PRIO_IO___8 = 11,
    _PC_SOCK_MAXBUF___8 = 12,
    _PC_FILESIZEBITS___8 = 13,
    _PC_REC_INCR_XFER_SIZE___8 = 14,
    _PC_REC_MAX_XFER_SIZE___8 = 15,
    _PC_REC_MIN_XFER_SIZE___8 = 16,
    _PC_REC_XFER_ALIGN___8 = 17,
    _PC_ALLOC_SIZE_MIN___8 = 18,
    _PC_SYMLINK_MAX___8 = 19,
    _PC_2_SYMLINKS___8 = 20
} ;
#line 71
enum __anonenum__1331 {
    _SC_ARG_MAX___8 = 0,
    _SC_CHILD_MAX___8 = 1,
    _SC_CLK_TCK___8 = 2,
    _SC_NGROUPS_MAX___8 = 3,
    _SC_OPEN_MAX___8 = 4,
    _SC_STREAM_MAX___8 = 5,
    _SC_TZNAME_MAX___8 = 6,
    _SC_JOB_CONTROL___8 = 7,
    _SC_SAVED_IDS___8 = 8,
    _SC_REALTIME_SIGNALS___8 = 9,
    _SC_PRIORITY_SCHEDULING___8 = 10,
    _SC_TIMERS___8 = 11,
    _SC_ASYNCHRONOUS_IO___8 = 12,
    _SC_PRIORITIZED_IO___8 = 13,
    _SC_SYNCHRONIZED_IO___8 = 14,
    _SC_FSYNC___8 = 15,
    _SC_MAPPED_FILES___8 = 16,
    _SC_MEMLOCK___8 = 17,
    _SC_MEMLOCK_RANGE___8 = 18,
    _SC_MEMORY_PROTECTION___8 = 19,
    _SC_MESSAGE_PASSING___8 = 20,
    _SC_SEMAPHORES___8 = 21,
    _SC_SHARED_MEMORY_OBJECTS___8 = 22,
    _SC_AIO_LISTIO_MAX___8 = 23,
    _SC_AIO_MAX___8 = 24,
    _SC_AIO_PRIO_DELTA_MAX___8 = 25,
    _SC_DELAYTIMER_MAX___8 = 26,
    _SC_MQ_OPEN_MAX___8 = 27,
    _SC_MQ_PRIO_MAX___8 = 28,
    _SC_VERSION___8 = 29,
    _SC_PAGESIZE___8 = 30,
    _SC_RTSIG_MAX___8 = 31,
    _SC_SEM_NSEMS_MAX___8 = 32,
    _SC_SEM_VALUE_MAX___8 = 33,
    _SC_SIGQUEUE_MAX___8 = 34,
    _SC_TIMER_MAX___8 = 35,
    _SC_BC_BASE_MAX___8 = 36,
    _SC_BC_DIM_MAX___8 = 37,
    _SC_BC_SCALE_MAX___8 = 38,
    _SC_BC_STRING_MAX___8 = 39,
    _SC_COLL_WEIGHTS_MAX___8 = 40,
    _SC_EQUIV_CLASS_MAX___8 = 41,
    _SC_EXPR_NEST_MAX___8 = 42,
    _SC_LINE_MAX___8 = 43,
    _SC_RE_DUP_MAX___8 = 44,
    _SC_CHARCLASS_NAME_MAX___8 = 45,
    _SC_2_VERSION___8 = 46,
    _SC_2_C_BIND___8 = 47,
    _SC_2_C_DEV___8 = 48,
    _SC_2_FORT_DEV___8 = 49,
    _SC_2_FORT_RUN___8 = 50,
    _SC_2_SW_DEV___8 = 51,
    _SC_2_LOCALEDEF___8 = 52,
    _SC_PII___8 = 53,
    _SC_PII_XTI___8 = 54,
    _SC_PII_SOCKET___8 = 55,
    _SC_PII_INTERNET___8 = 56,
    _SC_PII_OSI___8 = 57,
    _SC_POLL___8 = 58,
    _SC_SELECT___8 = 59,
    _SC_UIO_MAXIOV___8 = 60,
    _SC_IOV_MAX___8 = 60,
    _SC_PII_INTERNET_STREAM___8 = 61,
    _SC_PII_INTERNET_DGRAM___8 = 62,
    _SC_PII_OSI_COTS___8 = 63,
    _SC_PII_OSI_CLTS___8 = 64,
    _SC_PII_OSI_M___8 = 65,
    _SC_T_IOV_MAX___8 = 66,
    _SC_THREADS___8 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___8 = 68,
    _SC_GETGR_R_SIZE_MAX___8 = 69,
    _SC_GETPW_R_SIZE_MAX___8 = 70,
    _SC_LOGIN_NAME_MAX___8 = 71,
    _SC_TTY_NAME_MAX___8 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___8 = 73,
    _SC_THREAD_KEYS_MAX___8 = 74,
    _SC_THREAD_STACK_MIN___8 = 75,
    _SC_THREAD_THREADS_MAX___8 = 76,
    _SC_THREAD_ATTR_STACKADDR___8 = 77,
    _SC_THREAD_ATTR_STACKSIZE___8 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___8 = 79,
    _SC_THREAD_PRIO_INHERIT___8 = 80,
    _SC_THREAD_PRIO_PROTECT___8 = 81,
    _SC_THREAD_PROCESS_SHARED___8 = 82,
    _SC_NPROCESSORS_CONF___8 = 83,
    _SC_NPROCESSORS_ONLN___8 = 84,
    _SC_PHYS_PAGES___8 = 85,
    _SC_AVPHYS_PAGES___8 = 86,
    _SC_ATEXIT_MAX___8 = 87,
    _SC_PASS_MAX___8 = 88,
    _SC_XOPEN_VERSION___8 = 89,
    _SC_XOPEN_XCU_VERSION___8 = 90,
    _SC_XOPEN_UNIX___8 = 91,
    _SC_XOPEN_CRYPT___8 = 92,
    _SC_XOPEN_ENH_I18N___8 = 93,
    _SC_XOPEN_SHM___8 = 94,
    _SC_2_CHAR_TERM___8 = 95,
    _SC_2_C_VERSION___8 = 96,
    _SC_2_UPE___8 = 97,
    _SC_XOPEN_XPG2___8 = 98,
    _SC_XOPEN_XPG3___8 = 99,
    _SC_XOPEN_XPG4___8 = 100,
    _SC_CHAR_BIT___8 = 101,
    _SC_CHAR_MAX___8 = 102,
    _SC_CHAR_MIN___8 = 103,
    _SC_INT_MAX___8 = 104,
    _SC_INT_MIN___8 = 105,
    _SC_LONG_BIT___8 = 106,
    _SC_WORD_BIT___8 = 107,
    _SC_MB_LEN_MAX___8 = 108,
    _SC_NZERO___8 = 109,
    _SC_SSIZE_MAX___8 = 110,
    _SC_SCHAR_MAX___8 = 111,
    _SC_SCHAR_MIN___8 = 112,
    _SC_SHRT_MAX___8 = 113,
    _SC_SHRT_MIN___8 = 114,
    _SC_UCHAR_MAX___8 = 115,
    _SC_UINT_MAX___8 = 116,
    _SC_ULONG_MAX___8 = 117,
    _SC_USHRT_MAX___8 = 118,
    _SC_NL_ARGMAX___8 = 119,
    _SC_NL_LANGMAX___8 = 120,
    _SC_NL_MSGMAX___8 = 121,
    _SC_NL_NMAX___8 = 122,
    _SC_NL_SETMAX___8 = 123,
    _SC_NL_TEXTMAX___8 = 124,
    _SC_XBS5_ILP32_OFF32___8 = 125,
    _SC_XBS5_ILP32_OFFBIG___8 = 126,
    _SC_XBS5_LP64_OFF64___8 = 127,
    _SC_XBS5_LPBIG_OFFBIG___8 = 128,
    _SC_XOPEN_LEGACY___8 = 129,
    _SC_XOPEN_REALTIME___8 = 130,
    _SC_XOPEN_REALTIME_THREADS___8 = 131,
    _SC_ADVISORY_INFO___8 = 132,
    _SC_BARRIERS___8 = 133,
    _SC_BASE___8 = 134,
    _SC_C_LANG_SUPPORT___8 = 135,
    _SC_C_LANG_SUPPORT_R___8 = 136,
    _SC_CLOCK_SELECTION___8 = 137,
    _SC_CPUTIME___8 = 138,
    _SC_THREAD_CPUTIME___8 = 139,
    _SC_DEVICE_IO___8 = 140,
    _SC_DEVICE_SPECIFIC___8 = 141,
    _SC_DEVICE_SPECIFIC_R___8 = 142,
    _SC_FD_MGMT___8 = 143,
    _SC_FIFO___8 = 144,
    _SC_PIPE___8 = 145,
    _SC_FILE_ATTRIBUTES___8 = 146,
    _SC_FILE_LOCKING___8 = 147,
    _SC_FILE_SYSTEM___8 = 148,
    _SC_MONOTONIC_CLOCK___8 = 149,
    _SC_MULTI_PROCESS___8 = 150,
    _SC_SINGLE_PROCESS___8 = 151,
    _SC_NETWORKING___8 = 152,
    _SC_READER_WRITER_LOCKS___8 = 153,
    _SC_SPIN_LOCKS___8 = 154,
    _SC_REGEXP___8 = 155,
    _SC_REGEX_VERSION___8 = 156,
    _SC_SHELL___8 = 157,
    _SC_SIGNALS___8 = 158,
    _SC_SPAWN___8 = 159,
    _SC_SPORADIC_SERVER___8 = 160,
    _SC_THREAD_SPORADIC_SERVER___8 = 161,
    _SC_SYSTEM_DATABASE___8 = 162,
    _SC_SYSTEM_DATABASE_R___8 = 163,
    _SC_TIMEOUTS___8 = 164,
    _SC_TYPED_MEMORY_OBJECTS___8 = 165,
    _SC_USER_GROUPS___8 = 166,
    _SC_USER_GROUPS_R___8 = 167,
    _SC_2_PBS___8 = 168,
    _SC_2_PBS_ACCOUNTING___8 = 169,
    _SC_2_PBS_LOCATE___8 = 170,
    _SC_2_PBS_MESSAGE___8 = 171,
    _SC_2_PBS_TRACK___8 = 172,
    _SC_SYMLOOP_MAX___8 = 173,
    _SC_STREAMS___8 = 174,
    _SC_2_PBS_CHECKPOINT___8 = 175,
    _SC_V6_ILP32_OFF32___8 = 176,
    _SC_V6_ILP32_OFFBIG___8 = 177,
    _SC_V6_LP64_OFF64___8 = 178,
    _SC_V6_LPBIG_OFFBIG___8 = 179,
    _SC_HOST_NAME_MAX___8 = 180,
    _SC_TRACE___8 = 181,
    _SC_TRACE_EVENT_FILTER___8 = 182,
    _SC_TRACE_INHERIT___8 = 183,
    _SC_TRACE_LOG___8 = 184,
    _SC_LEVEL1_ICACHE_SIZE___8 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___8 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___8 = 187,
    _SC_LEVEL1_DCACHE_SIZE___8 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___8 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___8 = 190,
    _SC_LEVEL2_CACHE_SIZE___8 = 191,
    _SC_LEVEL2_CACHE_ASSOC___8 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___8 = 193,
    _SC_LEVEL3_CACHE_SIZE___8 = 194,
    _SC_LEVEL3_CACHE_ASSOC___8 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___8 = 196,
    _SC_LEVEL4_CACHE_SIZE___8 = 197,
    _SC_LEVEL4_CACHE_ASSOC___8 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___8 = 199,
    _SC_IPV6___8 = 235,
    _SC_RAW_SOCKETS___8 = 236,
    _SC_V7_ILP32_OFF32___8 = 237,
    _SC_V7_ILP32_OFFBIG___8 = 238,
    _SC_V7_LP64_OFF64___8 = 239,
    _SC_V7_LPBIG_OFFBIG___8 = 240,
    _SC_SS_REPL_MAX___8 = 241,
    _SC_TRACE_EVENT_NAME_MAX___8 = 242,
    _SC_TRACE_NAME_MAX___8 = 243,
    _SC_TRACE_SYS_MAX___8 = 244,
    _SC_TRACE_USER_EVENT_MAX___8 = 245,
    _SC_XOPEN_STREAMS___8 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___8 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___8 = 248,
    _SC_MINSIGSTKSZ___8 = 249,
    _SC_SIGSTKSZ___8 = 250
} ;
#line 539
enum __anonenum__1332 {
    _CS_PATH___8 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___8 = 1,
    _CS_GNU_LIBC_VERSION___8 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___8 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___8 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___8 = 5,
    _CS_LFS_CFLAGS___8 = 1000,
    _CS_LFS_LDFLAGS___8 = 1001,
    _CS_LFS_LIBS___8 = 1002,
    _CS_LFS_LINTFLAGS___8 = 1003,
    _CS_LFS64_CFLAGS___8 = 1004,
    _CS_LFS64_LDFLAGS___8 = 1005,
    _CS_LFS64_LIBS___8 = 1006,
    _CS_LFS64_LINTFLAGS___8 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___8 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___8 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___8 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___8 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___8 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___8 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___8 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___8 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___8 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___8 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___8 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___8 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___8 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___8 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___8 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___8 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___8 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___8 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___8 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___8 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___8 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___8 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___8 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___8 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___8 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___8 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___8 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___8 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___8 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___8 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___8 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___8 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___8 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___8 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___8 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___8 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___8 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___8 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___8 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___8 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___8 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___8 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___8 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___8 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___8 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___8 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___8 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___8 = 1147,
    _CS_V6_ENV___8 = 1148,
    _CS_V7_ENV___8 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1333 {
    SS_ONSTACK___12 = 1,
    SS_DISABLE___12 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1341 {
    PTHREAD_CREATE_JOINABLE___12 = 0,
    PTHREAD_CREATE_DETACHED___12 = 1
} ;
#line 47
enum __anonenum__1342 {
    PTHREAD_MUTEX_TIMED_NP___12 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___12 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___12 = 3,
    PTHREAD_MUTEX_NORMAL___12 = 0,
    PTHREAD_MUTEX_RECURSIVE___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK___12 = 2,
    PTHREAD_MUTEX_DEFAULT___12 = 0,
    PTHREAD_MUTEX_FAST_NP___7 = 0
} ;
#line 69
enum __anonenum__1343 {
    PTHREAD_MUTEX_STALLED___12 = 0,
    PTHREAD_MUTEX_STALLED_NP___12 = 0,
    PTHREAD_MUTEX_ROBUST___12 = 1,
    PTHREAD_MUTEX_ROBUST_NP___12 = 1
} ;
#line 81
enum __anonenum__1344 {
    PTHREAD_PRIO_NONE___12 = 0,
    PTHREAD_PRIO_INHERIT___12 = 1,
    PTHREAD_PRIO_PROTECT___12 = 2
} ;
#line 104
enum __anonenum__1345 {
    PTHREAD_RWLOCK_PREFER_READER_NP___12 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___12 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___12 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___12 = 0
} ;
#line 124
enum __anonenum__1346 {
    PTHREAD_INHERIT_SCHED___12 = 0,
    PTHREAD_EXPLICIT_SCHED___12 = 1
} ;
#line 134
enum __anonenum__1347 {
    PTHREAD_SCOPE_SYSTEM___12 = 0,
    PTHREAD_SCOPE_PROCESS___12 = 1
} ;
#line 144
enum __anonenum__1348 {
    PTHREAD_PROCESS_PRIVATE___12 = 0,
    PTHREAD_PROCESS_SHARED___12 = 1
} ;
#line 168
enum __anonenum__1349 {
    PTHREAD_CANCEL_ENABLE___12 = 0,
    PTHREAD_CANCEL_DISABLE___12 = 1
} ;
#line 175
enum __anonenum__1350 {
    PTHREAD_CANCEL_DEFERRED___12 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___12 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1366 {
    DT_UNKNOWN___11 = 0,
    DT_FIFO___11 = 1,
    DT_CHR___11 = 2,
    DT_DIR___11 = 4,
    DT_BLK___11 = 6,
    DT_REG___11 = 8,
    DT_LNK___11 = 10,
    DT_SOCK___11 = 12,
    DT_WHT___11 = 14
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__1449 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1463 {
    MSG_OOB___8 = 1,
    MSG_PEEK___8 = 2,
    MSG_DONTROUTE___8 = 4,
    MSG_TRYHARD___8 = 4,
    MSG_CTRUNC___8 = 8,
    MSG_PROXY___8 = 16,
    MSG_TRUNC___8 = 32,
    MSG_DONTWAIT___8 = 64,
    MSG_EOR___8 = 128,
    MSG_WAITALL___8 = 256,
    MSG_FIN___8 = 512,
    MSG_SYN___8 = 1024,
    MSG_CONFIRM___8 = 2048,
    MSG_RST___8 = 4096,
    MSG_ERRQUEUE___8 = 8192,
    MSG_NOSIGNAL___8 = 16384,
    MSG_MORE___8 = 32768,
    MSG_WAITFORONE___8 = 65536,
    MSG_BATCH___8 = 262144,
    MSG_ZEROCOPY___8 = 67108864,
    MSG_FASTOPEN___8 = 536870912,
    MSG_CMSG_CLOEXEC___8 = 1073741824
} ;
#line 334
enum __anonenum__1464 {
    SCM_RIGHTS___8 = 1,
    SCM_CREDENTIALS___8 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1467 {
    SHUT_RD___8 = 0,
    SHUT_WR___8 = 1,
    SHUT_RDWR___8 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1470 {
    IPPROTO_IP___8 = 0,
    IPPROTO_ICMP___8 = 1,
    IPPROTO_IGMP___8 = 2,
    IPPROTO_IPIP___8 = 4,
    IPPROTO_TCP___8 = 6,
    IPPROTO_EGP___8 = 8,
    IPPROTO_PUP___8 = 12,
    IPPROTO_UDP___8 = 17,
    IPPROTO_IDP___8 = 22,
    IPPROTO_TP___8 = 29,
    IPPROTO_DCCP___8 = 33,
    IPPROTO_IPV6___8 = 41,
    IPPROTO_RSVP___8 = 46,
    IPPROTO_GRE___8 = 47,
    IPPROTO_ESP___8 = 50,
    IPPROTO_AH___8 = 51,
    IPPROTO_MTP___8 = 92,
    IPPROTO_BEETPH___8 = 94,
    IPPROTO_ENCAP___8 = 98,
    IPPROTO_PIM___8 = 103,
    IPPROTO_COMP___8 = 108,
    IPPROTO_SCTP___8 = 132,
    IPPROTO_UDPLITE___8 = 136,
    IPPROTO_MPLS___8 = 137,
    IPPROTO_ETHERNET___8 = 143,
    IPPROTO_RAW___8 = 255,
    IPPROTO_MPTCP___8 = 262,
    IPPROTO_MAX___8 = 263
} ;
#line 103
enum __anonenum__1471 {
    IPPROTO_HOPOPTS___8 = 0,
    IPPROTO_ROUTING___8 = 43,
    IPPROTO_FRAGMENT___8 = 44,
    IPPROTO_ICMPV6___8 = 58,
    IPPROTO_NONE___8 = 59,
    IPPROTO_DSTOPTS___8 = 60,
    IPPROTO_MH___8 = 135
} ;
#line 126
enum __anonenum__1472 {
    IPPORT_ECHO___8 = 7,
    IPPORT_DISCARD___8 = 9,
    IPPORT_SYSTAT___8 = 11,
    IPPORT_DAYTIME___8 = 13,
    IPPORT_NETSTAT___8 = 15,
    IPPORT_FTP___8 = 21,
    IPPORT_TELNET___8 = 23,
    IPPORT_SMTP___8 = 25,
    IPPORT_TIMESERVER___8 = 37,
    IPPORT_NAMESERVER___8 = 42,
    IPPORT_WHOIS___8 = 43,
    IPPORT_MTP___8 = 57,
    IPPORT_TFTP___8 = 69,
    IPPORT_RJE___8 = 77,
    IPPORT_FINGER___8 = 79,
    IPPORT_TTYLINK___8 = 87,
    IPPORT_SUPDUP___8 = 95,
    IPPORT_EXECSERVER___8 = 512,
    IPPORT_LOGINSERVER___8 = 513,
    IPPORT_CMDSERVER___8 = 514,
    IPPORT_EFSSERVER___8 = 520,
    IPPORT_BIFFUDP___8 = 512,
    IPPORT_WHOSERVER___8 = 513,
    IPPORT_ROUTESERVER___8 = 520,
    IPPORT_RESERVED___8 = 1024,
    IPPORT_USERRESERVED___8 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1484 {
    SI_ASYNCNL___13 = -60,
    SI_DETHREAD___13 = -7,
    SI_TKILL___13 = -6,
    SI_SIGIO___13 = -5,
    SI_ASYNCIO___13 = -4,
    SI_MESGQ___13 = -3,
    SI_TIMER___13 = -2,
    SI_QUEUE___13 = -1,
    SI_USER___13 = 0,
    SI_KERNEL___13 = 128
} ;
#line 71
enum __anonenum__1485 {
    ILL_ILLOPC___13 = 1,
    ILL_ILLOPN___13 = 2,
    ILL_ILLADR___13 = 3,
    ILL_ILLTRP___13 = 4,
    ILL_PRVOPC___13 = 5,
    ILL_PRVREG___13 = 6,
    ILL_COPROC___13 = 7,
    ILL_BADSTK___13 = 8,
    ILL_BADIADDR___13 = 9
} ;
#line 94
enum __anonenum__1486 {
    FPE_INTDIV___13 = 1,
    FPE_INTOVF___13 = 2,
    FPE_FLTDIV___13 = 3,
    FPE_FLTOVF___13 = 4,
    FPE_FLTUND___13 = 5,
    FPE_FLTRES___13 = 6,
    FPE_FLTINV___13 = 7,
    FPE_FLTSUB___13 = 8,
    FPE_FLTUNK___13 = 14,
    FPE_CONDTRAP___13 = 15
} ;
#line 119
enum __anonenum__1487 {
    SEGV_MAPERR___13 = 1,
    SEGV_ACCERR___13 = 2,
    SEGV_BNDERR___13 = 3,
    SEGV_PKUERR___13 = 4,
    SEGV_ACCADI___13 = 5,
    SEGV_ADIDERR___13 = 6,
    SEGV_ADIPERR___13 = 7,
    SEGV_MTEAERR___13 = 8,
    SEGV_MTESERR___13 = 9
} ;
#line 142
enum __anonenum__1488 {
    BUS_ADRALN___13 = 1,
    BUS_ADRERR___13 = 2,
    BUS_OBJERR___13 = 3,
    BUS_MCEERR_AR___13 = 4,
    BUS_MCEERR_AO___13 = 5
} ;
#line 159
enum __anonenum__1489 {
    TRAP_BRKPT___8 = 1,
    TRAP_TRACE___8 = 2,
    TRAP_BRANCH___8 = 3,
    TRAP_HWBKPT___8 = 4,
    TRAP_UNK___8 = 5
} ;
#line 176
enum __anonenum__1490 {
    CLD_EXITED___13 = 1,
    CLD_KILLED___13 = 2,
    CLD_DUMPED___13 = 3,
    CLD_TRAPPED___13 = 4,
    CLD_STOPPED___13 = 5,
    CLD_CONTINUED___13 = 6
} ;
#line 193
enum __anonenum__1491 {
    POLL_IN___13 = 1,
    POLL_OUT___13 = 2,
    POLL_MSG___13 = 3,
    POLL_ERR___13 = 4,
    POLL_PRI___13 = 5,
    POLL_HUP___13 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1494 {
    SIGEV_SIGNAL___13 = 0,
    SIGEV_NONE___13 = 1,
    SIGEV_THREAD___13 = 2,
    SIGEV_THREAD_ID___13 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1498 {
    REG_R8___8 = 0,
    REG_R9___8 = 1,
    REG_R10___8 = 2,
    REG_R11___8 = 3,
    REG_R12___8 = 4,
    REG_R13___8 = 5,
    REG_R14___8 = 6,
    REG_R15___8 = 7,
    REG_RDI___8 = 8,
    REG_RSI___8 = 9,
    REG_RBP___8 = 10,
    REG_RBX___8 = 11,
    REG_RDX___8 = 12,
    REG_RAX___8 = 13,
    REG_RCX___8 = 14,
    REG_RSP___8 = 15,
    REG_RIP___8 = 16,
    REG_EFL___8 = 17,
    REG_CSGSFS___8 = 18,
    REG_ERR___8 = 19,
    REG_TRAPNO___8 = 20,
    REG_OLDMASK___8 = 21,
    REG_CR2___8 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1500 {
    _PC_LINK_MAX___9 = 0,
    _PC_MAX_CANON___9 = 1,
    _PC_MAX_INPUT___9 = 2,
    _PC_NAME_MAX___9 = 3,
    _PC_PATH_MAX___9 = 4,
    _PC_PIPE_BUF___9 = 5,
    _PC_CHOWN_RESTRICTED___9 = 6,
    _PC_NO_TRUNC___9 = 7,
    _PC_VDISABLE___9 = 8,
    _PC_SYNC_IO___9 = 9,
    _PC_ASYNC_IO___9 = 10,
    _PC_PRIO_IO___9 = 11,
    _PC_SOCK_MAXBUF___9 = 12,
    _PC_FILESIZEBITS___9 = 13,
    _PC_REC_INCR_XFER_SIZE___9 = 14,
    _PC_REC_MAX_XFER_SIZE___9 = 15,
    _PC_REC_MIN_XFER_SIZE___9 = 16,
    _PC_REC_XFER_ALIGN___9 = 17,
    _PC_ALLOC_SIZE_MIN___9 = 18,
    _PC_SYMLINK_MAX___9 = 19,
    _PC_2_SYMLINKS___9 = 20
} ;
#line 71
enum __anonenum__1501 {
    _SC_ARG_MAX___9 = 0,
    _SC_CHILD_MAX___9 = 1,
    _SC_CLK_TCK___9 = 2,
    _SC_NGROUPS_MAX___9 = 3,
    _SC_OPEN_MAX___9 = 4,
    _SC_STREAM_MAX___9 = 5,
    _SC_TZNAME_MAX___9 = 6,
    _SC_JOB_CONTROL___9 = 7,
    _SC_SAVED_IDS___9 = 8,
    _SC_REALTIME_SIGNALS___9 = 9,
    _SC_PRIORITY_SCHEDULING___9 = 10,
    _SC_TIMERS___9 = 11,
    _SC_ASYNCHRONOUS_IO___9 = 12,
    _SC_PRIORITIZED_IO___9 = 13,
    _SC_SYNCHRONIZED_IO___9 = 14,
    _SC_FSYNC___9 = 15,
    _SC_MAPPED_FILES___9 = 16,
    _SC_MEMLOCK___9 = 17,
    _SC_MEMLOCK_RANGE___9 = 18,
    _SC_MEMORY_PROTECTION___9 = 19,
    _SC_MESSAGE_PASSING___9 = 20,
    _SC_SEMAPHORES___9 = 21,
    _SC_SHARED_MEMORY_OBJECTS___9 = 22,
    _SC_AIO_LISTIO_MAX___9 = 23,
    _SC_AIO_MAX___9 = 24,
    _SC_AIO_PRIO_DELTA_MAX___9 = 25,
    _SC_DELAYTIMER_MAX___9 = 26,
    _SC_MQ_OPEN_MAX___9 = 27,
    _SC_MQ_PRIO_MAX___9 = 28,
    _SC_VERSION___9 = 29,
    _SC_PAGESIZE___9 = 30,
    _SC_RTSIG_MAX___9 = 31,
    _SC_SEM_NSEMS_MAX___9 = 32,
    _SC_SEM_VALUE_MAX___9 = 33,
    _SC_SIGQUEUE_MAX___9 = 34,
    _SC_TIMER_MAX___9 = 35,
    _SC_BC_BASE_MAX___9 = 36,
    _SC_BC_DIM_MAX___9 = 37,
    _SC_BC_SCALE_MAX___9 = 38,
    _SC_BC_STRING_MAX___9 = 39,
    _SC_COLL_WEIGHTS_MAX___9 = 40,
    _SC_EQUIV_CLASS_MAX___9 = 41,
    _SC_EXPR_NEST_MAX___9 = 42,
    _SC_LINE_MAX___9 = 43,
    _SC_RE_DUP_MAX___9 = 44,
    _SC_CHARCLASS_NAME_MAX___9 = 45,
    _SC_2_VERSION___9 = 46,
    _SC_2_C_BIND___9 = 47,
    _SC_2_C_DEV___9 = 48,
    _SC_2_FORT_DEV___9 = 49,
    _SC_2_FORT_RUN___9 = 50,
    _SC_2_SW_DEV___9 = 51,
    _SC_2_LOCALEDEF___9 = 52,
    _SC_PII___9 = 53,
    _SC_PII_XTI___9 = 54,
    _SC_PII_SOCKET___9 = 55,
    _SC_PII_INTERNET___9 = 56,
    _SC_PII_OSI___9 = 57,
    _SC_POLL___9 = 58,
    _SC_SELECT___9 = 59,
    _SC_UIO_MAXIOV___9 = 60,
    _SC_IOV_MAX___9 = 60,
    _SC_PII_INTERNET_STREAM___9 = 61,
    _SC_PII_INTERNET_DGRAM___9 = 62,
    _SC_PII_OSI_COTS___9 = 63,
    _SC_PII_OSI_CLTS___9 = 64,
    _SC_PII_OSI_M___9 = 65,
    _SC_T_IOV_MAX___9 = 66,
    _SC_THREADS___9 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___9 = 68,
    _SC_GETGR_R_SIZE_MAX___9 = 69,
    _SC_GETPW_R_SIZE_MAX___9 = 70,
    _SC_LOGIN_NAME_MAX___9 = 71,
    _SC_TTY_NAME_MAX___9 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___9 = 73,
    _SC_THREAD_KEYS_MAX___9 = 74,
    _SC_THREAD_STACK_MIN___9 = 75,
    _SC_THREAD_THREADS_MAX___9 = 76,
    _SC_THREAD_ATTR_STACKADDR___9 = 77,
    _SC_THREAD_ATTR_STACKSIZE___9 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___9 = 79,
    _SC_THREAD_PRIO_INHERIT___9 = 80,
    _SC_THREAD_PRIO_PROTECT___9 = 81,
    _SC_THREAD_PROCESS_SHARED___9 = 82,
    _SC_NPROCESSORS_CONF___9 = 83,
    _SC_NPROCESSORS_ONLN___9 = 84,
    _SC_PHYS_PAGES___9 = 85,
    _SC_AVPHYS_PAGES___9 = 86,
    _SC_ATEXIT_MAX___9 = 87,
    _SC_PASS_MAX___9 = 88,
    _SC_XOPEN_VERSION___9 = 89,
    _SC_XOPEN_XCU_VERSION___9 = 90,
    _SC_XOPEN_UNIX___9 = 91,
    _SC_XOPEN_CRYPT___9 = 92,
    _SC_XOPEN_ENH_I18N___9 = 93,
    _SC_XOPEN_SHM___9 = 94,
    _SC_2_CHAR_TERM___9 = 95,
    _SC_2_C_VERSION___9 = 96,
    _SC_2_UPE___9 = 97,
    _SC_XOPEN_XPG2___9 = 98,
    _SC_XOPEN_XPG3___9 = 99,
    _SC_XOPEN_XPG4___9 = 100,
    _SC_CHAR_BIT___9 = 101,
    _SC_CHAR_MAX___9 = 102,
    _SC_CHAR_MIN___9 = 103,
    _SC_INT_MAX___9 = 104,
    _SC_INT_MIN___9 = 105,
    _SC_LONG_BIT___9 = 106,
    _SC_WORD_BIT___9 = 107,
    _SC_MB_LEN_MAX___9 = 108,
    _SC_NZERO___9 = 109,
    _SC_SSIZE_MAX___9 = 110,
    _SC_SCHAR_MAX___9 = 111,
    _SC_SCHAR_MIN___9 = 112,
    _SC_SHRT_MAX___9 = 113,
    _SC_SHRT_MIN___9 = 114,
    _SC_UCHAR_MAX___9 = 115,
    _SC_UINT_MAX___9 = 116,
    _SC_ULONG_MAX___9 = 117,
    _SC_USHRT_MAX___9 = 118,
    _SC_NL_ARGMAX___9 = 119,
    _SC_NL_LANGMAX___9 = 120,
    _SC_NL_MSGMAX___9 = 121,
    _SC_NL_NMAX___9 = 122,
    _SC_NL_SETMAX___9 = 123,
    _SC_NL_TEXTMAX___9 = 124,
    _SC_XBS5_ILP32_OFF32___9 = 125,
    _SC_XBS5_ILP32_OFFBIG___9 = 126,
    _SC_XBS5_LP64_OFF64___9 = 127,
    _SC_XBS5_LPBIG_OFFBIG___9 = 128,
    _SC_XOPEN_LEGACY___9 = 129,
    _SC_XOPEN_REALTIME___9 = 130,
    _SC_XOPEN_REALTIME_THREADS___9 = 131,
    _SC_ADVISORY_INFO___9 = 132,
    _SC_BARRIERS___9 = 133,
    _SC_BASE___9 = 134,
    _SC_C_LANG_SUPPORT___9 = 135,
    _SC_C_LANG_SUPPORT_R___9 = 136,
    _SC_CLOCK_SELECTION___9 = 137,
    _SC_CPUTIME___9 = 138,
    _SC_THREAD_CPUTIME___9 = 139,
    _SC_DEVICE_IO___9 = 140,
    _SC_DEVICE_SPECIFIC___9 = 141,
    _SC_DEVICE_SPECIFIC_R___9 = 142,
    _SC_FD_MGMT___9 = 143,
    _SC_FIFO___9 = 144,
    _SC_PIPE___9 = 145,
    _SC_FILE_ATTRIBUTES___9 = 146,
    _SC_FILE_LOCKING___9 = 147,
    _SC_FILE_SYSTEM___9 = 148,
    _SC_MONOTONIC_CLOCK___9 = 149,
    _SC_MULTI_PROCESS___9 = 150,
    _SC_SINGLE_PROCESS___9 = 151,
    _SC_NETWORKING___9 = 152,
    _SC_READER_WRITER_LOCKS___9 = 153,
    _SC_SPIN_LOCKS___9 = 154,
    _SC_REGEXP___9 = 155,
    _SC_REGEX_VERSION___9 = 156,
    _SC_SHELL___9 = 157,
    _SC_SIGNALS___9 = 158,
    _SC_SPAWN___9 = 159,
    _SC_SPORADIC_SERVER___9 = 160,
    _SC_THREAD_SPORADIC_SERVER___9 = 161,
    _SC_SYSTEM_DATABASE___9 = 162,
    _SC_SYSTEM_DATABASE_R___9 = 163,
    _SC_TIMEOUTS___9 = 164,
    _SC_TYPED_MEMORY_OBJECTS___9 = 165,
    _SC_USER_GROUPS___9 = 166,
    _SC_USER_GROUPS_R___9 = 167,
    _SC_2_PBS___9 = 168,
    _SC_2_PBS_ACCOUNTING___9 = 169,
    _SC_2_PBS_LOCATE___9 = 170,
    _SC_2_PBS_MESSAGE___9 = 171,
    _SC_2_PBS_TRACK___9 = 172,
    _SC_SYMLOOP_MAX___9 = 173,
    _SC_STREAMS___9 = 174,
    _SC_2_PBS_CHECKPOINT___9 = 175,
    _SC_V6_ILP32_OFF32___9 = 176,
    _SC_V6_ILP32_OFFBIG___9 = 177,
    _SC_V6_LP64_OFF64___9 = 178,
    _SC_V6_LPBIG_OFFBIG___9 = 179,
    _SC_HOST_NAME_MAX___9 = 180,
    _SC_TRACE___9 = 181,
    _SC_TRACE_EVENT_FILTER___9 = 182,
    _SC_TRACE_INHERIT___9 = 183,
    _SC_TRACE_LOG___9 = 184,
    _SC_LEVEL1_ICACHE_SIZE___9 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___9 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___9 = 187,
    _SC_LEVEL1_DCACHE_SIZE___9 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___9 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___9 = 190,
    _SC_LEVEL2_CACHE_SIZE___9 = 191,
    _SC_LEVEL2_CACHE_ASSOC___9 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___9 = 193,
    _SC_LEVEL3_CACHE_SIZE___9 = 194,
    _SC_LEVEL3_CACHE_ASSOC___9 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___9 = 196,
    _SC_LEVEL4_CACHE_SIZE___9 = 197,
    _SC_LEVEL4_CACHE_ASSOC___9 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___9 = 199,
    _SC_IPV6___9 = 235,
    _SC_RAW_SOCKETS___9 = 236,
    _SC_V7_ILP32_OFF32___9 = 237,
    _SC_V7_ILP32_OFFBIG___9 = 238,
    _SC_V7_LP64_OFF64___9 = 239,
    _SC_V7_LPBIG_OFFBIG___9 = 240,
    _SC_SS_REPL_MAX___9 = 241,
    _SC_TRACE_EVENT_NAME_MAX___9 = 242,
    _SC_TRACE_NAME_MAX___9 = 243,
    _SC_TRACE_SYS_MAX___9 = 244,
    _SC_TRACE_USER_EVENT_MAX___9 = 245,
    _SC_XOPEN_STREAMS___9 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___9 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___9 = 248,
    _SC_MINSIGSTKSZ___9 = 249,
    _SC_SIGSTKSZ___9 = 250
} ;
#line 539
enum __anonenum__1502 {
    _CS_PATH___9 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___9 = 1,
    _CS_GNU_LIBC_VERSION___9 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___9 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___9 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___9 = 5,
    _CS_LFS_CFLAGS___9 = 1000,
    _CS_LFS_LDFLAGS___9 = 1001,
    _CS_LFS_LIBS___9 = 1002,
    _CS_LFS_LINTFLAGS___9 = 1003,
    _CS_LFS64_CFLAGS___9 = 1004,
    _CS_LFS64_LDFLAGS___9 = 1005,
    _CS_LFS64_LIBS___9 = 1006,
    _CS_LFS64_LINTFLAGS___9 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___9 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___9 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___9 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___9 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___9 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___9 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___9 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___9 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___9 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___9 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___9 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___9 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___9 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___9 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___9 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___9 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___9 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___9 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___9 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___9 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___9 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___9 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___9 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___9 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___9 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___9 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___9 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___9 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___9 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___9 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___9 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___9 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___9 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___9 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___9 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___9 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___9 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___9 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___9 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___9 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___9 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___9 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___9 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___9 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___9 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___9 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___9 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___9 = 1147,
    _CS_V6_ENV___9 = 1148,
    _CS_V7_ENV___9 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1503 {
    SS_ONSTACK___13 = 1,
    SS_DISABLE___13 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1511 {
    PTHREAD_CREATE_JOINABLE___13 = 0,
    PTHREAD_CREATE_DETACHED___13 = 1
} ;
#line 47
enum __anonenum__1512 {
    PTHREAD_MUTEX_TIMED_NP___13 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___13 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___13 = 3,
    PTHREAD_MUTEX_NORMAL___13 = 0,
    PTHREAD_MUTEX_RECURSIVE___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK___13 = 2,
    PTHREAD_MUTEX_DEFAULT___13 = 0,
    PTHREAD_MUTEX_FAST_NP___8 = 0
} ;
#line 69
enum __anonenum__1513 {
    PTHREAD_MUTEX_STALLED___13 = 0,
    PTHREAD_MUTEX_STALLED_NP___13 = 0,
    PTHREAD_MUTEX_ROBUST___13 = 1,
    PTHREAD_MUTEX_ROBUST_NP___13 = 1
} ;
#line 81
enum __anonenum__1514 {
    PTHREAD_PRIO_NONE___13 = 0,
    PTHREAD_PRIO_INHERIT___13 = 1,
    PTHREAD_PRIO_PROTECT___13 = 2
} ;
#line 104
enum __anonenum__1515 {
    PTHREAD_RWLOCK_PREFER_READER_NP___13 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___13 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___13 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___13 = 0
} ;
#line 124
enum __anonenum__1516 {
    PTHREAD_INHERIT_SCHED___13 = 0,
    PTHREAD_EXPLICIT_SCHED___13 = 1
} ;
#line 134
enum __anonenum__1517 {
    PTHREAD_SCOPE_SYSTEM___13 = 0,
    PTHREAD_SCOPE_PROCESS___13 = 1
} ;
#line 144
enum __anonenum__1518 {
    PTHREAD_PROCESS_PRIVATE___13 = 0,
    PTHREAD_PROCESS_SHARED___13 = 1
} ;
#line 168
enum __anonenum__1519 {
    PTHREAD_CANCEL_ENABLE___13 = 0,
    PTHREAD_CANCEL_DISABLE___13 = 1
} ;
#line 175
enum __anonenum__1520 {
    PTHREAD_CANCEL_DEFERRED___13 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___13 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1536 {
    DT_UNKNOWN___12 = 0,
    DT_FIFO___12 = 1,
    DT_CHR___12 = 2,
    DT_DIR___12 = 4,
    DT_BLK___12 = 6,
    DT_REG___12 = 8,
    DT_LNK___12 = 10,
    DT_SOCK___12 = 12,
    DT_WHT___12 = 14
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1106___1 {
    SI_ASYNCNL___14 = -60,
    SI_DETHREAD___14 = -7,
    SI_TKILL___14 = -6,
    SI_SIGIO___14 = -5,
    SI_ASYNCIO___14 = -4,
    SI_MESGQ___14 = -3,
    SI_TIMER___14 = -2,
    SI_QUEUE___14 = -1,
    SI_USER___14 = 0,
    SI_KERNEL___14 = 128
} ;
#line 71
enum __anonenum__1107___1 {
    ILL_ILLOPC___14 = 1,
    ILL_ILLOPN___14 = 2,
    ILL_ILLADR___14 = 3,
    ILL_ILLTRP___14 = 4,
    ILL_PRVOPC___14 = 5,
    ILL_PRVREG___14 = 6,
    ILL_COPROC___14 = 7,
    ILL_BADSTK___14 = 8,
    ILL_BADIADDR___14 = 9
} ;
#line 94
enum __anonenum__1108___1 {
    FPE_INTDIV___14 = 1,
    FPE_INTOVF___14 = 2,
    FPE_FLTDIV___14 = 3,
    FPE_FLTOVF___14 = 4,
    FPE_FLTUND___14 = 5,
    FPE_FLTRES___14 = 6,
    FPE_FLTINV___14 = 7,
    FPE_FLTSUB___14 = 8,
    FPE_FLTUNK___14 = 14,
    FPE_CONDTRAP___14 = 15
} ;
#line 119
enum __anonenum__1109___1 {
    SEGV_MAPERR___14 = 1,
    SEGV_ACCERR___14 = 2,
    SEGV_BNDERR___14 = 3,
    SEGV_PKUERR___14 = 4,
    SEGV_ACCADI___14 = 5,
    SEGV_ADIDERR___14 = 6,
    SEGV_ADIPERR___14 = 7,
    SEGV_MTEAERR___14 = 8,
    SEGV_MTESERR___14 = 9
} ;
#line 142
enum __anonenum__1110___1 {
    BUS_ADRALN___14 = 1,
    BUS_ADRERR___14 = 2,
    BUS_OBJERR___14 = 3,
    BUS_MCEERR_AR___14 = 4,
    BUS_MCEERR_AO___14 = 5
} ;
#line 159
enum __anonenum__1111___1 {
    TRAP_BRKPT___9 = 1,
    TRAP_TRACE___9 = 2,
    TRAP_BRANCH___9 = 3,
    TRAP_HWBKPT___9 = 4,
    TRAP_UNK___9 = 5
} ;
#line 176
enum __anonenum__1112___1 {
    CLD_EXITED___14 = 1,
    CLD_KILLED___14 = 2,
    CLD_DUMPED___14 = 3,
    CLD_TRAPPED___14 = 4,
    CLD_STOPPED___14 = 5,
    CLD_CONTINUED___14 = 6
} ;
#line 193
enum __anonenum__1113___1 {
    POLL_IN___14 = 1,
    POLL_OUT___14 = 2,
    POLL_MSG___14 = 3,
    POLL_ERR___14 = 4,
    POLL_PRI___14 = 5,
    POLL_HUP___14 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1116___1 {
    SIGEV_SIGNAL___14 = 0,
    SIGEV_NONE___14 = 1,
    SIGEV_THREAD___14 = 2,
    SIGEV_THREAD_ID___14 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1120___1 {
    REG_R8___9 = 0,
    REG_R9___9 = 1,
    REG_R10___9 = 2,
    REG_R11___9 = 3,
    REG_R12___9 = 4,
    REG_R13___9 = 5,
    REG_R14___9 = 6,
    REG_R15___9 = 7,
    REG_RDI___9 = 8,
    REG_RSI___9 = 9,
    REG_RBP___9 = 10,
    REG_RBX___9 = 11,
    REG_RDX___9 = 12,
    REG_RAX___9 = 13,
    REG_RCX___9 = 14,
    REG_RSP___9 = 15,
    REG_RIP___9 = 16,
    REG_EFL___9 = 17,
    REG_CSGSFS___9 = 18,
    REG_ERR___9 = 19,
    REG_TRAPNO___9 = 20,
    REG_OLDMASK___9 = 21,
    REG_CR2___9 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1122___1 {
    _PC_LINK_MAX___10 = 0,
    _PC_MAX_CANON___10 = 1,
    _PC_MAX_INPUT___10 = 2,
    _PC_NAME_MAX___10 = 3,
    _PC_PATH_MAX___10 = 4,
    _PC_PIPE_BUF___10 = 5,
    _PC_CHOWN_RESTRICTED___10 = 6,
    _PC_NO_TRUNC___10 = 7,
    _PC_VDISABLE___10 = 8,
    _PC_SYNC_IO___10 = 9,
    _PC_ASYNC_IO___10 = 10,
    _PC_PRIO_IO___10 = 11,
    _PC_SOCK_MAXBUF___10 = 12,
    _PC_FILESIZEBITS___10 = 13,
    _PC_REC_INCR_XFER_SIZE___10 = 14,
    _PC_REC_MAX_XFER_SIZE___10 = 15,
    _PC_REC_MIN_XFER_SIZE___10 = 16,
    _PC_REC_XFER_ALIGN___10 = 17,
    _PC_ALLOC_SIZE_MIN___10 = 18,
    _PC_SYMLINK_MAX___10 = 19,
    _PC_2_SYMLINKS___10 = 20
} ;
#line 71
enum __anonenum__1123___1 {
    _SC_ARG_MAX___10 = 0,
    _SC_CHILD_MAX___10 = 1,
    _SC_CLK_TCK___10 = 2,
    _SC_NGROUPS_MAX___10 = 3,
    _SC_OPEN_MAX___10 = 4,
    _SC_STREAM_MAX___10 = 5,
    _SC_TZNAME_MAX___10 = 6,
    _SC_JOB_CONTROL___10 = 7,
    _SC_SAVED_IDS___10 = 8,
    _SC_REALTIME_SIGNALS___10 = 9,
    _SC_PRIORITY_SCHEDULING___10 = 10,
    _SC_TIMERS___10 = 11,
    _SC_ASYNCHRONOUS_IO___10 = 12,
    _SC_PRIORITIZED_IO___10 = 13,
    _SC_SYNCHRONIZED_IO___10 = 14,
    _SC_FSYNC___10 = 15,
    _SC_MAPPED_FILES___10 = 16,
    _SC_MEMLOCK___10 = 17,
    _SC_MEMLOCK_RANGE___10 = 18,
    _SC_MEMORY_PROTECTION___10 = 19,
    _SC_MESSAGE_PASSING___10 = 20,
    _SC_SEMAPHORES___10 = 21,
    _SC_SHARED_MEMORY_OBJECTS___10 = 22,
    _SC_AIO_LISTIO_MAX___10 = 23,
    _SC_AIO_MAX___10 = 24,
    _SC_AIO_PRIO_DELTA_MAX___10 = 25,
    _SC_DELAYTIMER_MAX___10 = 26,
    _SC_MQ_OPEN_MAX___10 = 27,
    _SC_MQ_PRIO_MAX___10 = 28,
    _SC_VERSION___10 = 29,
    _SC_PAGESIZE___10 = 30,
    _SC_RTSIG_MAX___10 = 31,
    _SC_SEM_NSEMS_MAX___10 = 32,
    _SC_SEM_VALUE_MAX___10 = 33,
    _SC_SIGQUEUE_MAX___10 = 34,
    _SC_TIMER_MAX___10 = 35,
    _SC_BC_BASE_MAX___10 = 36,
    _SC_BC_DIM_MAX___10 = 37,
    _SC_BC_SCALE_MAX___10 = 38,
    _SC_BC_STRING_MAX___10 = 39,
    _SC_COLL_WEIGHTS_MAX___10 = 40,
    _SC_EQUIV_CLASS_MAX___10 = 41,
    _SC_EXPR_NEST_MAX___10 = 42,
    _SC_LINE_MAX___10 = 43,
    _SC_RE_DUP_MAX___10 = 44,
    _SC_CHARCLASS_NAME_MAX___10 = 45,
    _SC_2_VERSION___10 = 46,
    _SC_2_C_BIND___10 = 47,
    _SC_2_C_DEV___10 = 48,
    _SC_2_FORT_DEV___10 = 49,
    _SC_2_FORT_RUN___10 = 50,
    _SC_2_SW_DEV___10 = 51,
    _SC_2_LOCALEDEF___10 = 52,
    _SC_PII___10 = 53,
    _SC_PII_XTI___10 = 54,
    _SC_PII_SOCKET___10 = 55,
    _SC_PII_INTERNET___10 = 56,
    _SC_PII_OSI___10 = 57,
    _SC_POLL___10 = 58,
    _SC_SELECT___10 = 59,
    _SC_UIO_MAXIOV___10 = 60,
    _SC_IOV_MAX___10 = 60,
    _SC_PII_INTERNET_STREAM___10 = 61,
    _SC_PII_INTERNET_DGRAM___10 = 62,
    _SC_PII_OSI_COTS___10 = 63,
    _SC_PII_OSI_CLTS___10 = 64,
    _SC_PII_OSI_M___10 = 65,
    _SC_T_IOV_MAX___10 = 66,
    _SC_THREADS___10 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___10 = 68,
    _SC_GETGR_R_SIZE_MAX___10 = 69,
    _SC_GETPW_R_SIZE_MAX___10 = 70,
    _SC_LOGIN_NAME_MAX___10 = 71,
    _SC_TTY_NAME_MAX___10 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___10 = 73,
    _SC_THREAD_KEYS_MAX___10 = 74,
    _SC_THREAD_STACK_MIN___10 = 75,
    _SC_THREAD_THREADS_MAX___10 = 76,
    _SC_THREAD_ATTR_STACKADDR___10 = 77,
    _SC_THREAD_ATTR_STACKSIZE___10 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___10 = 79,
    _SC_THREAD_PRIO_INHERIT___10 = 80,
    _SC_THREAD_PRIO_PROTECT___10 = 81,
    _SC_THREAD_PROCESS_SHARED___10 = 82,
    _SC_NPROCESSORS_CONF___10 = 83,
    _SC_NPROCESSORS_ONLN___10 = 84,
    _SC_PHYS_PAGES___10 = 85,
    _SC_AVPHYS_PAGES___10 = 86,
    _SC_ATEXIT_MAX___10 = 87,
    _SC_PASS_MAX___10 = 88,
    _SC_XOPEN_VERSION___10 = 89,
    _SC_XOPEN_XCU_VERSION___10 = 90,
    _SC_XOPEN_UNIX___10 = 91,
    _SC_XOPEN_CRYPT___10 = 92,
    _SC_XOPEN_ENH_I18N___10 = 93,
    _SC_XOPEN_SHM___10 = 94,
    _SC_2_CHAR_TERM___10 = 95,
    _SC_2_C_VERSION___10 = 96,
    _SC_2_UPE___10 = 97,
    _SC_XOPEN_XPG2___10 = 98,
    _SC_XOPEN_XPG3___10 = 99,
    _SC_XOPEN_XPG4___10 = 100,
    _SC_CHAR_BIT___10 = 101,
    _SC_CHAR_MAX___10 = 102,
    _SC_CHAR_MIN___10 = 103,
    _SC_INT_MAX___10 = 104,
    _SC_INT_MIN___10 = 105,
    _SC_LONG_BIT___10 = 106,
    _SC_WORD_BIT___10 = 107,
    _SC_MB_LEN_MAX___10 = 108,
    _SC_NZERO___10 = 109,
    _SC_SSIZE_MAX___10 = 110,
    _SC_SCHAR_MAX___10 = 111,
    _SC_SCHAR_MIN___10 = 112,
    _SC_SHRT_MAX___10 = 113,
    _SC_SHRT_MIN___10 = 114,
    _SC_UCHAR_MAX___10 = 115,
    _SC_UINT_MAX___10 = 116,
    _SC_ULONG_MAX___10 = 117,
    _SC_USHRT_MAX___10 = 118,
    _SC_NL_ARGMAX___10 = 119,
    _SC_NL_LANGMAX___10 = 120,
    _SC_NL_MSGMAX___10 = 121,
    _SC_NL_NMAX___10 = 122,
    _SC_NL_SETMAX___10 = 123,
    _SC_NL_TEXTMAX___10 = 124,
    _SC_XBS5_ILP32_OFF32___10 = 125,
    _SC_XBS5_ILP32_OFFBIG___10 = 126,
    _SC_XBS5_LP64_OFF64___10 = 127,
    _SC_XBS5_LPBIG_OFFBIG___10 = 128,
    _SC_XOPEN_LEGACY___10 = 129,
    _SC_XOPEN_REALTIME___10 = 130,
    _SC_XOPEN_REALTIME_THREADS___10 = 131,
    _SC_ADVISORY_INFO___10 = 132,
    _SC_BARRIERS___10 = 133,
    _SC_BASE___10 = 134,
    _SC_C_LANG_SUPPORT___10 = 135,
    _SC_C_LANG_SUPPORT_R___10 = 136,
    _SC_CLOCK_SELECTION___10 = 137,
    _SC_CPUTIME___10 = 138,
    _SC_THREAD_CPUTIME___10 = 139,
    _SC_DEVICE_IO___10 = 140,
    _SC_DEVICE_SPECIFIC___10 = 141,
    _SC_DEVICE_SPECIFIC_R___10 = 142,
    _SC_FD_MGMT___10 = 143,
    _SC_FIFO___10 = 144,
    _SC_PIPE___10 = 145,
    _SC_FILE_ATTRIBUTES___10 = 146,
    _SC_FILE_LOCKING___10 = 147,
    _SC_FILE_SYSTEM___10 = 148,
    _SC_MONOTONIC_CLOCK___10 = 149,
    _SC_MULTI_PROCESS___10 = 150,
    _SC_SINGLE_PROCESS___10 = 151,
    _SC_NETWORKING___10 = 152,
    _SC_READER_WRITER_LOCKS___10 = 153,
    _SC_SPIN_LOCKS___10 = 154,
    _SC_REGEXP___10 = 155,
    _SC_REGEX_VERSION___10 = 156,
    _SC_SHELL___10 = 157,
    _SC_SIGNALS___10 = 158,
    _SC_SPAWN___10 = 159,
    _SC_SPORADIC_SERVER___10 = 160,
    _SC_THREAD_SPORADIC_SERVER___10 = 161,
    _SC_SYSTEM_DATABASE___10 = 162,
    _SC_SYSTEM_DATABASE_R___10 = 163,
    _SC_TIMEOUTS___10 = 164,
    _SC_TYPED_MEMORY_OBJECTS___10 = 165,
    _SC_USER_GROUPS___10 = 166,
    _SC_USER_GROUPS_R___10 = 167,
    _SC_2_PBS___10 = 168,
    _SC_2_PBS_ACCOUNTING___10 = 169,
    _SC_2_PBS_LOCATE___10 = 170,
    _SC_2_PBS_MESSAGE___10 = 171,
    _SC_2_PBS_TRACK___10 = 172,
    _SC_SYMLOOP_MAX___10 = 173,
    _SC_STREAMS___10 = 174,
    _SC_2_PBS_CHECKPOINT___10 = 175,
    _SC_V6_ILP32_OFF32___10 = 176,
    _SC_V6_ILP32_OFFBIG___10 = 177,
    _SC_V6_LP64_OFF64___10 = 178,
    _SC_V6_LPBIG_OFFBIG___10 = 179,
    _SC_HOST_NAME_MAX___10 = 180,
    _SC_TRACE___10 = 181,
    _SC_TRACE_EVENT_FILTER___10 = 182,
    _SC_TRACE_INHERIT___10 = 183,
    _SC_TRACE_LOG___10 = 184,
    _SC_LEVEL1_ICACHE_SIZE___10 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___10 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___10 = 187,
    _SC_LEVEL1_DCACHE_SIZE___10 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___10 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___10 = 190,
    _SC_LEVEL2_CACHE_SIZE___10 = 191,
    _SC_LEVEL2_CACHE_ASSOC___10 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___10 = 193,
    _SC_LEVEL3_CACHE_SIZE___10 = 194,
    _SC_LEVEL3_CACHE_ASSOC___10 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___10 = 196,
    _SC_LEVEL4_CACHE_SIZE___10 = 197,
    _SC_LEVEL4_CACHE_ASSOC___10 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___10 = 199,
    _SC_IPV6___10 = 235,
    _SC_RAW_SOCKETS___10 = 236,
    _SC_V7_ILP32_OFF32___10 = 237,
    _SC_V7_ILP32_OFFBIG___10 = 238,
    _SC_V7_LP64_OFF64___10 = 239,
    _SC_V7_LPBIG_OFFBIG___10 = 240,
    _SC_SS_REPL_MAX___10 = 241,
    _SC_TRACE_EVENT_NAME_MAX___10 = 242,
    _SC_TRACE_NAME_MAX___10 = 243,
    _SC_TRACE_SYS_MAX___10 = 244,
    _SC_TRACE_USER_EVENT_MAX___10 = 245,
    _SC_XOPEN_STREAMS___10 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___10 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___10 = 248,
    _SC_MINSIGSTKSZ___10 = 249,
    _SC_SIGSTKSZ___10 = 250
} ;
#line 539
enum __anonenum__1124___1 {
    _CS_PATH___10 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___10 = 1,
    _CS_GNU_LIBC_VERSION___10 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___10 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___10 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___10 = 5,
    _CS_LFS_CFLAGS___10 = 1000,
    _CS_LFS_LDFLAGS___10 = 1001,
    _CS_LFS_LIBS___10 = 1002,
    _CS_LFS_LINTFLAGS___10 = 1003,
    _CS_LFS64_CFLAGS___10 = 1004,
    _CS_LFS64_LDFLAGS___10 = 1005,
    _CS_LFS64_LIBS___10 = 1006,
    _CS_LFS64_LINTFLAGS___10 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___10 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___10 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___10 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___10 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___10 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___10 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___10 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___10 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___10 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___10 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___10 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___10 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___10 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___10 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___10 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___10 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___10 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___10 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___10 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___10 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___10 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___10 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___10 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___10 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___10 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___10 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___10 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___10 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___10 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___10 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___10 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___10 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___10 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___10 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___10 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___10 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___10 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___10 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___10 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___10 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___10 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___10 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___10 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___10 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___10 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___10 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___10 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___10 = 1147,
    _CS_V6_ENV___10 = 1148,
    _CS_V7_ENV___10 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1125___1 {
    SS_ONSTACK___14 = 1,
    SS_DISABLE___14 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1133___1 {
    DT_UNKNOWN___13 = 0,
    DT_FIFO___13 = 1,
    DT_CHR___13 = 2,
    DT_DIR___13 = 4,
    DT_BLK___13 = 6,
    DT_REG___13 = 8,
    DT_LNK___13 = 10,
    DT_SOCK___13 = 12,
    DT_WHT___13 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1192___1 {
    PTHREAD_CREATE_JOINABLE___14 = 0,
    PTHREAD_CREATE_DETACHED___14 = 1
} ;
#line 47
enum __anonenum__1193___1 {
    PTHREAD_MUTEX_TIMED_NP___14 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___14 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___14 = 3,
    PTHREAD_MUTEX_NORMAL___14 = 0,
    PTHREAD_MUTEX_RECURSIVE___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK___14 = 2,
    PTHREAD_MUTEX_DEFAULT___14 = 0,
    PTHREAD_MUTEX_FAST_NP___9 = 0
} ;
#line 69
enum __anonenum__1194___1 {
    PTHREAD_MUTEX_STALLED___14 = 0,
    PTHREAD_MUTEX_STALLED_NP___14 = 0,
    PTHREAD_MUTEX_ROBUST___14 = 1,
    PTHREAD_MUTEX_ROBUST_NP___14 = 1
} ;
#line 81
enum __anonenum__1195___1 {
    PTHREAD_PRIO_NONE___14 = 0,
    PTHREAD_PRIO_INHERIT___14 = 1,
    PTHREAD_PRIO_PROTECT___14 = 2
} ;
#line 104
enum __anonenum__1196___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___14 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___14 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___14 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___14 = 0
} ;
#line 124
enum __anonenum__1197___1 {
    PTHREAD_INHERIT_SCHED___14 = 0,
    PTHREAD_EXPLICIT_SCHED___14 = 1
} ;
#line 134
enum __anonenum__1198___1 {
    PTHREAD_SCOPE_SYSTEM___14 = 0,
    PTHREAD_SCOPE_PROCESS___14 = 1
} ;
#line 144
enum __anonenum__1199___1 {
    PTHREAD_PROCESS_PRIVATE___14 = 0,
    PTHREAD_PROCESS_SHARED___14 = 1
} ;
#line 168
enum __anonenum__1200___1 {
    PTHREAD_CANCEL_ENABLE___14 = 0,
    PTHREAD_CANCEL_DISABLE___14 = 1
} ;
#line 175
enum __anonenum__1201___1 {
    PTHREAD_CANCEL_DEFERRED___14 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___14 = 1
} ;
#line 107 "/usr/include/dotconf.h"
enum callback_types {
    ERROR_HANDLER = 1,
    CONTEXT_CHECKER = 2
} ;
#line 112 "/usr/include/dotconf.h"
typedef enum callback_types callback_types;
#line 113
struct configfile_t ;
#line 113 "/usr/include/dotconf.h"
typedef struct configfile_t configfile_t;
#line 114
struct configoption_t ;
#line 114 "/usr/include/dotconf.h"
typedef struct configoption_t configoption_t;
#line 115 "/usr/include/dotconf.h"
typedef struct configoption_t ConfigOption;
#line 116
struct command_t ;
#line 116 "/usr/include/dotconf.h"
typedef struct command_t command_t;
#line 117 "/usr/include/dotconf.h"
typedef void context_t;
#line 118 "/usr/include/dotconf.h"
typedef void info_t;
#line 120 "/usr/include/dotconf.h"
typedef char const   *(*dotconf_callback_t)(command_t * , context_t * );
#line 121 "/usr/include/dotconf.h"
typedef int (*dotconf_errorhandler_t)(configfile_t * , int  , unsigned long  , char const   * );
#line 123 "/usr/include/dotconf.h"
typedef char const   *(*dotconf_contextchecker_t)(command_t * , unsigned long  );
#line 126 "/usr/include/dotconf.h"
struct configfile_t {
   FILE *stream ;
   char eof ;
   size_t size ;
   context_t *context ;
   configoption_t **config_options ;
   int config_option_count ;
   char *filename ;
   unsigned long line ;
   unsigned long flags ;
   char *includepath ;
   dotconf_errorhandler_t errorhandler ;
   dotconf_contextchecker_t contextchecker ;
   int (*cmp_func)(char const   * , char const   * , size_t  ) ;
};
#line 152 "/usr/include/dotconf.h"
struct configoption_t {
   char const   *name ;
   int type ;
   dotconf_callback_t callback ;
   info_t *info ;
   unsigned long context ;
};
#line 170 "/usr/include/dotconf.h"
struct __anonstruct_1621 {
   long value ;
   char *str ;
   char **list ;
   double dvalue ;
};
#line 160 "/usr/include/dotconf.h"
struct command_t {
   char const   *name ;
   configoption_t *option ;
   configfile_t *configfile ;
   context_t *context ;
   int arg_count ;
   struct __anonstruct_1621 data ;
};
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1622 {
    MSG_OOB___9 = 1,
    MSG_PEEK___9 = 2,
    MSG_DONTROUTE___9 = 4,
    MSG_TRYHARD___9 = 4,
    MSG_CTRUNC___9 = 8,
    MSG_PROXY___9 = 16,
    MSG_TRUNC___9 = 32,
    MSG_DONTWAIT___9 = 64,
    MSG_EOR___9 = 128,
    MSG_WAITALL___9 = 256,
    MSG_FIN___9 = 512,
    MSG_SYN___9 = 1024,
    MSG_CONFIRM___9 = 2048,
    MSG_RST___9 = 4096,
    MSG_ERRQUEUE___9 = 8192,
    MSG_NOSIGNAL___9 = 16384,
    MSG_MORE___9 = 32768,
    MSG_WAITFORONE___9 = 65536,
    MSG_BATCH___9 = 262144,
    MSG_ZEROCOPY___9 = 67108864,
    MSG_FASTOPEN___9 = 536870912,
    MSG_CMSG_CLOEXEC___9 = 1073741824
} ;
#line 334
enum __anonenum__1623 {
    SCM_RIGHTS___9 = 1,
    SCM_CREDENTIALS___9 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1626 {
    SHUT_RD___9 = 0,
    SHUT_WR___9 = 1,
    SHUT_RDWR___9 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1629 {
    IPPROTO_IP___9 = 0,
    IPPROTO_ICMP___9 = 1,
    IPPROTO_IGMP___9 = 2,
    IPPROTO_IPIP___9 = 4,
    IPPROTO_TCP___9 = 6,
    IPPROTO_EGP___9 = 8,
    IPPROTO_PUP___9 = 12,
    IPPROTO_UDP___9 = 17,
    IPPROTO_IDP___9 = 22,
    IPPROTO_TP___9 = 29,
    IPPROTO_DCCP___9 = 33,
    IPPROTO_IPV6___9 = 41,
    IPPROTO_RSVP___9 = 46,
    IPPROTO_GRE___9 = 47,
    IPPROTO_ESP___9 = 50,
    IPPROTO_AH___9 = 51,
    IPPROTO_MTP___9 = 92,
    IPPROTO_BEETPH___9 = 94,
    IPPROTO_ENCAP___9 = 98,
    IPPROTO_PIM___9 = 103,
    IPPROTO_COMP___9 = 108,
    IPPROTO_SCTP___9 = 132,
    IPPROTO_UDPLITE___9 = 136,
    IPPROTO_MPLS___9 = 137,
    IPPROTO_ETHERNET___9 = 143,
    IPPROTO_RAW___9 = 255,
    IPPROTO_MPTCP___9 = 262,
    IPPROTO_MAX___9 = 263
} ;
#line 103
enum __anonenum__1630 {
    IPPROTO_HOPOPTS___9 = 0,
    IPPROTO_ROUTING___9 = 43,
    IPPROTO_FRAGMENT___9 = 44,
    IPPROTO_ICMPV6___9 = 58,
    IPPROTO_NONE___9 = 59,
    IPPROTO_DSTOPTS___9 = 60,
    IPPROTO_MH___9 = 135
} ;
#line 126
enum __anonenum__1631 {
    IPPORT_ECHO___9 = 7,
    IPPORT_DISCARD___9 = 9,
    IPPORT_SYSTAT___9 = 11,
    IPPORT_DAYTIME___9 = 13,
    IPPORT_NETSTAT___9 = 15,
    IPPORT_FTP___9 = 21,
    IPPORT_TELNET___9 = 23,
    IPPORT_SMTP___9 = 25,
    IPPORT_TIMESERVER___9 = 37,
    IPPORT_NAMESERVER___9 = 42,
    IPPORT_WHOIS___9 = 43,
    IPPORT_MTP___9 = 57,
    IPPORT_TFTP___9 = 69,
    IPPORT_RJE___9 = 77,
    IPPORT_FINGER___9 = 79,
    IPPORT_TTYLINK___9 = 87,
    IPPORT_SUPDUP___9 = 95,
    IPPORT_EXECSERVER___9 = 512,
    IPPORT_LOGINSERVER___9 = 513,
    IPPORT_CMDSERVER___9 = 514,
    IPPORT_EFSSERVER___9 = 520,
    IPPORT_BIFFUDP___9 = 512,
    IPPORT_WHOSERVER___9 = 513,
    IPPORT_ROUTESERVER___9 = 520,
    IPPORT_RESERVED___9 = 1024,
    IPPORT_USERRESERVED___9 = 5000
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__507___2 {
    MSG_OOB___10 = 1,
    MSG_PEEK___10 = 2,
    MSG_DONTROUTE___10 = 4,
    MSG_TRYHARD___10 = 4,
    MSG_CTRUNC___10 = 8,
    MSG_PROXY___10 = 16,
    MSG_TRUNC___10 = 32,
    MSG_DONTWAIT___10 = 64,
    MSG_EOR___10 = 128,
    MSG_WAITALL___10 = 256,
    MSG_FIN___10 = 512,
    MSG_SYN___10 = 1024,
    MSG_CONFIRM___10 = 2048,
    MSG_RST___10 = 4096,
    MSG_ERRQUEUE___10 = 8192,
    MSG_NOSIGNAL___10 = 16384,
    MSG_MORE___10 = 32768,
    MSG_WAITFORONE___10 = 65536,
    MSG_BATCH___10 = 262144,
    MSG_ZEROCOPY___10 = 67108864,
    MSG_FASTOPEN___10 = 536870912,
    MSG_CMSG_CLOEXEC___10 = 1073741824
} ;
#line 334
enum __anonenum__508___2 {
    SCM_RIGHTS___10 = 1,
    SCM_CREDENTIALS___10 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__511___2 {
    SHUT_RD___10 = 0,
    SHUT_WR___10 = 1,
    SHUT_RDWR___10 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__514___2 {
    IPPROTO_IP___10 = 0,
    IPPROTO_ICMP___10 = 1,
    IPPROTO_IGMP___10 = 2,
    IPPROTO_IPIP___10 = 4,
    IPPROTO_TCP___10 = 6,
    IPPROTO_EGP___10 = 8,
    IPPROTO_PUP___10 = 12,
    IPPROTO_UDP___10 = 17,
    IPPROTO_IDP___10 = 22,
    IPPROTO_TP___10 = 29,
    IPPROTO_DCCP___10 = 33,
    IPPROTO_IPV6___10 = 41,
    IPPROTO_RSVP___10 = 46,
    IPPROTO_GRE___10 = 47,
    IPPROTO_ESP___10 = 50,
    IPPROTO_AH___10 = 51,
    IPPROTO_MTP___10 = 92,
    IPPROTO_BEETPH___10 = 94,
    IPPROTO_ENCAP___10 = 98,
    IPPROTO_PIM___10 = 103,
    IPPROTO_COMP___10 = 108,
    IPPROTO_SCTP___10 = 132,
    IPPROTO_UDPLITE___10 = 136,
    IPPROTO_MPLS___10 = 137,
    IPPROTO_ETHERNET___10 = 143,
    IPPROTO_RAW___10 = 255,
    IPPROTO_MPTCP___10 = 262,
    IPPROTO_MAX___10 = 263
} ;
#line 103
enum __anonenum__515___2 {
    IPPROTO_HOPOPTS___10 = 0,
    IPPROTO_ROUTING___10 = 43,
    IPPROTO_FRAGMENT___10 = 44,
    IPPROTO_ICMPV6___10 = 58,
    IPPROTO_NONE___10 = 59,
    IPPROTO_DSTOPTS___10 = 60,
    IPPROTO_MH___10 = 135
} ;
#line 126
enum __anonenum__516___2 {
    IPPORT_ECHO___10 = 7,
    IPPORT_DISCARD___10 = 9,
    IPPORT_SYSTAT___10 = 11,
    IPPORT_DAYTIME___10 = 13,
    IPPORT_NETSTAT___10 = 15,
    IPPORT_FTP___10 = 21,
    IPPORT_TELNET___10 = 23,
    IPPORT_SMTP___10 = 25,
    IPPORT_TIMESERVER___10 = 37,
    IPPORT_NAMESERVER___10 = 42,
    IPPORT_WHOIS___10 = 43,
    IPPORT_MTP___10 = 57,
    IPPORT_TFTP___10 = 69,
    IPPORT_RJE___10 = 77,
    IPPORT_FINGER___10 = 79,
    IPPORT_TTYLINK___10 = 87,
    IPPORT_SUPDUP___10 = 95,
    IPPORT_EXECSERVER___10 = 512,
    IPPORT_LOGINSERVER___10 = 513,
    IPPORT_CMDSERVER___10 = 514,
    IPPORT_EFSSERVER___10 = 520,
    IPPORT_BIFFUDP___10 = 512,
    IPPORT_WHOSERVER___10 = 513,
    IPPORT_ROUTESERVER___10 = 520,
    IPPORT_RESERVED___10 = 1024,
    IPPORT_USERRESERVED___10 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__528___2 {
    SI_ASYNCNL___15 = -60,
    SI_DETHREAD___15 = -7,
    SI_TKILL___15 = -6,
    SI_SIGIO___15 = -5,
    SI_ASYNCIO___15 = -4,
    SI_MESGQ___15 = -3,
    SI_TIMER___15 = -2,
    SI_QUEUE___15 = -1,
    SI_USER___15 = 0,
    SI_KERNEL___15 = 128
} ;
#line 71
enum __anonenum__529___2 {
    ILL_ILLOPC___15 = 1,
    ILL_ILLOPN___15 = 2,
    ILL_ILLADR___15 = 3,
    ILL_ILLTRP___15 = 4,
    ILL_PRVOPC___15 = 5,
    ILL_PRVREG___15 = 6,
    ILL_COPROC___15 = 7,
    ILL_BADSTK___15 = 8,
    ILL_BADIADDR___15 = 9
} ;
#line 94
enum __anonenum__530___2 {
    FPE_INTDIV___15 = 1,
    FPE_INTOVF___15 = 2,
    FPE_FLTDIV___15 = 3,
    FPE_FLTOVF___15 = 4,
    FPE_FLTUND___15 = 5,
    FPE_FLTRES___15 = 6,
    FPE_FLTINV___15 = 7,
    FPE_FLTSUB___15 = 8,
    FPE_FLTUNK___15 = 14,
    FPE_CONDTRAP___15 = 15
} ;
#line 119
enum __anonenum__531___2 {
    SEGV_MAPERR___15 = 1,
    SEGV_ACCERR___15 = 2,
    SEGV_BNDERR___15 = 3,
    SEGV_PKUERR___15 = 4,
    SEGV_ACCADI___15 = 5,
    SEGV_ADIDERR___15 = 6,
    SEGV_ADIPERR___15 = 7,
    SEGV_MTEAERR___15 = 8,
    SEGV_MTESERR___15 = 9
} ;
#line 142
enum __anonenum__532___2 {
    BUS_ADRALN___15 = 1,
    BUS_ADRERR___15 = 2,
    BUS_OBJERR___15 = 3,
    BUS_MCEERR_AR___15 = 4,
    BUS_MCEERR_AO___15 = 5
} ;
#line 159
enum __anonenum__533___2 {
    TRAP_BRKPT___10 = 1,
    TRAP_TRACE___10 = 2,
    TRAP_BRANCH___10 = 3,
    TRAP_HWBKPT___10 = 4,
    TRAP_UNK___10 = 5
} ;
#line 176
enum __anonenum__534___2 {
    CLD_EXITED___15 = 1,
    CLD_KILLED___15 = 2,
    CLD_DUMPED___15 = 3,
    CLD_TRAPPED___15 = 4,
    CLD_STOPPED___15 = 5,
    CLD_CONTINUED___15 = 6
} ;
#line 193
enum __anonenum__535___3 {
    POLL_IN___15 = 1,
    POLL_OUT___15 = 2,
    POLL_MSG___15 = 3,
    POLL_ERR___15 = 4,
    POLL_PRI___15 = 5,
    POLL_HUP___15 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__538___2 {
    SIGEV_SIGNAL___15 = 0,
    SIGEV_NONE___15 = 1,
    SIGEV_THREAD___15 = 2,
    SIGEV_THREAD_ID___15 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__542___2 {
    REG_R8___10 = 0,
    REG_R9___10 = 1,
    REG_R10___10 = 2,
    REG_R11___10 = 3,
    REG_R12___10 = 4,
    REG_R13___10 = 5,
    REG_R14___10 = 6,
    REG_R15___10 = 7,
    REG_RDI___10 = 8,
    REG_RSI___10 = 9,
    REG_RBP___10 = 10,
    REG_RBX___10 = 11,
    REG_RDX___10 = 12,
    REG_RAX___10 = 13,
    REG_RCX___10 = 14,
    REG_RSP___10 = 15,
    REG_RIP___10 = 16,
    REG_EFL___10 = 17,
    REG_CSGSFS___10 = 18,
    REG_ERR___10 = 19,
    REG_TRAPNO___10 = 20,
    REG_OLDMASK___10 = 21,
    REG_CR2___10 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__544___2 {
    _PC_LINK_MAX___11 = 0,
    _PC_MAX_CANON___11 = 1,
    _PC_MAX_INPUT___11 = 2,
    _PC_NAME_MAX___11 = 3,
    _PC_PATH_MAX___11 = 4,
    _PC_PIPE_BUF___11 = 5,
    _PC_CHOWN_RESTRICTED___11 = 6,
    _PC_NO_TRUNC___11 = 7,
    _PC_VDISABLE___11 = 8,
    _PC_SYNC_IO___11 = 9,
    _PC_ASYNC_IO___11 = 10,
    _PC_PRIO_IO___11 = 11,
    _PC_SOCK_MAXBUF___11 = 12,
    _PC_FILESIZEBITS___11 = 13,
    _PC_REC_INCR_XFER_SIZE___11 = 14,
    _PC_REC_MAX_XFER_SIZE___11 = 15,
    _PC_REC_MIN_XFER_SIZE___11 = 16,
    _PC_REC_XFER_ALIGN___11 = 17,
    _PC_ALLOC_SIZE_MIN___11 = 18,
    _PC_SYMLINK_MAX___11 = 19,
    _PC_2_SYMLINKS___11 = 20
} ;
#line 71
enum __anonenum__545___2 {
    _SC_ARG_MAX___11 = 0,
    _SC_CHILD_MAX___11 = 1,
    _SC_CLK_TCK___11 = 2,
    _SC_NGROUPS_MAX___11 = 3,
    _SC_OPEN_MAX___11 = 4,
    _SC_STREAM_MAX___11 = 5,
    _SC_TZNAME_MAX___11 = 6,
    _SC_JOB_CONTROL___11 = 7,
    _SC_SAVED_IDS___11 = 8,
    _SC_REALTIME_SIGNALS___11 = 9,
    _SC_PRIORITY_SCHEDULING___11 = 10,
    _SC_TIMERS___11 = 11,
    _SC_ASYNCHRONOUS_IO___11 = 12,
    _SC_PRIORITIZED_IO___11 = 13,
    _SC_SYNCHRONIZED_IO___11 = 14,
    _SC_FSYNC___11 = 15,
    _SC_MAPPED_FILES___11 = 16,
    _SC_MEMLOCK___11 = 17,
    _SC_MEMLOCK_RANGE___11 = 18,
    _SC_MEMORY_PROTECTION___11 = 19,
    _SC_MESSAGE_PASSING___11 = 20,
    _SC_SEMAPHORES___11 = 21,
    _SC_SHARED_MEMORY_OBJECTS___11 = 22,
    _SC_AIO_LISTIO_MAX___11 = 23,
    _SC_AIO_MAX___11 = 24,
    _SC_AIO_PRIO_DELTA_MAX___11 = 25,
    _SC_DELAYTIMER_MAX___11 = 26,
    _SC_MQ_OPEN_MAX___11 = 27,
    _SC_MQ_PRIO_MAX___11 = 28,
    _SC_VERSION___11 = 29,
    _SC_PAGESIZE___11 = 30,
    _SC_RTSIG_MAX___11 = 31,
    _SC_SEM_NSEMS_MAX___11 = 32,
    _SC_SEM_VALUE_MAX___11 = 33,
    _SC_SIGQUEUE_MAX___11 = 34,
    _SC_TIMER_MAX___11 = 35,
    _SC_BC_BASE_MAX___11 = 36,
    _SC_BC_DIM_MAX___11 = 37,
    _SC_BC_SCALE_MAX___11 = 38,
    _SC_BC_STRING_MAX___11 = 39,
    _SC_COLL_WEIGHTS_MAX___11 = 40,
    _SC_EQUIV_CLASS_MAX___11 = 41,
    _SC_EXPR_NEST_MAX___11 = 42,
    _SC_LINE_MAX___11 = 43,
    _SC_RE_DUP_MAX___11 = 44,
    _SC_CHARCLASS_NAME_MAX___11 = 45,
    _SC_2_VERSION___11 = 46,
    _SC_2_C_BIND___11 = 47,
    _SC_2_C_DEV___11 = 48,
    _SC_2_FORT_DEV___11 = 49,
    _SC_2_FORT_RUN___11 = 50,
    _SC_2_SW_DEV___11 = 51,
    _SC_2_LOCALEDEF___11 = 52,
    _SC_PII___11 = 53,
    _SC_PII_XTI___11 = 54,
    _SC_PII_SOCKET___11 = 55,
    _SC_PII_INTERNET___11 = 56,
    _SC_PII_OSI___11 = 57,
    _SC_POLL___11 = 58,
    _SC_SELECT___11 = 59,
    _SC_UIO_MAXIOV___11 = 60,
    _SC_IOV_MAX___11 = 60,
    _SC_PII_INTERNET_STREAM___11 = 61,
    _SC_PII_INTERNET_DGRAM___11 = 62,
    _SC_PII_OSI_COTS___11 = 63,
    _SC_PII_OSI_CLTS___11 = 64,
    _SC_PII_OSI_M___11 = 65,
    _SC_T_IOV_MAX___11 = 66,
    _SC_THREADS___11 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___11 = 68,
    _SC_GETGR_R_SIZE_MAX___11 = 69,
    _SC_GETPW_R_SIZE_MAX___11 = 70,
    _SC_LOGIN_NAME_MAX___11 = 71,
    _SC_TTY_NAME_MAX___11 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___11 = 73,
    _SC_THREAD_KEYS_MAX___11 = 74,
    _SC_THREAD_STACK_MIN___11 = 75,
    _SC_THREAD_THREADS_MAX___11 = 76,
    _SC_THREAD_ATTR_STACKADDR___11 = 77,
    _SC_THREAD_ATTR_STACKSIZE___11 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___11 = 79,
    _SC_THREAD_PRIO_INHERIT___11 = 80,
    _SC_THREAD_PRIO_PROTECT___11 = 81,
    _SC_THREAD_PROCESS_SHARED___11 = 82,
    _SC_NPROCESSORS_CONF___11 = 83,
    _SC_NPROCESSORS_ONLN___11 = 84,
    _SC_PHYS_PAGES___11 = 85,
    _SC_AVPHYS_PAGES___11 = 86,
    _SC_ATEXIT_MAX___11 = 87,
    _SC_PASS_MAX___11 = 88,
    _SC_XOPEN_VERSION___11 = 89,
    _SC_XOPEN_XCU_VERSION___11 = 90,
    _SC_XOPEN_UNIX___11 = 91,
    _SC_XOPEN_CRYPT___11 = 92,
    _SC_XOPEN_ENH_I18N___11 = 93,
    _SC_XOPEN_SHM___11 = 94,
    _SC_2_CHAR_TERM___11 = 95,
    _SC_2_C_VERSION___11 = 96,
    _SC_2_UPE___11 = 97,
    _SC_XOPEN_XPG2___11 = 98,
    _SC_XOPEN_XPG3___11 = 99,
    _SC_XOPEN_XPG4___11 = 100,
    _SC_CHAR_BIT___11 = 101,
    _SC_CHAR_MAX___11 = 102,
    _SC_CHAR_MIN___11 = 103,
    _SC_INT_MAX___11 = 104,
    _SC_INT_MIN___11 = 105,
    _SC_LONG_BIT___11 = 106,
    _SC_WORD_BIT___11 = 107,
    _SC_MB_LEN_MAX___11 = 108,
    _SC_NZERO___11 = 109,
    _SC_SSIZE_MAX___11 = 110,
    _SC_SCHAR_MAX___11 = 111,
    _SC_SCHAR_MIN___11 = 112,
    _SC_SHRT_MAX___11 = 113,
    _SC_SHRT_MIN___11 = 114,
    _SC_UCHAR_MAX___11 = 115,
    _SC_UINT_MAX___11 = 116,
    _SC_ULONG_MAX___11 = 117,
    _SC_USHRT_MAX___11 = 118,
    _SC_NL_ARGMAX___11 = 119,
    _SC_NL_LANGMAX___11 = 120,
    _SC_NL_MSGMAX___11 = 121,
    _SC_NL_NMAX___11 = 122,
    _SC_NL_SETMAX___11 = 123,
    _SC_NL_TEXTMAX___11 = 124,
    _SC_XBS5_ILP32_OFF32___11 = 125,
    _SC_XBS5_ILP32_OFFBIG___11 = 126,
    _SC_XBS5_LP64_OFF64___11 = 127,
    _SC_XBS5_LPBIG_OFFBIG___11 = 128,
    _SC_XOPEN_LEGACY___11 = 129,
    _SC_XOPEN_REALTIME___11 = 130,
    _SC_XOPEN_REALTIME_THREADS___11 = 131,
    _SC_ADVISORY_INFO___11 = 132,
    _SC_BARRIERS___11 = 133,
    _SC_BASE___11 = 134,
    _SC_C_LANG_SUPPORT___11 = 135,
    _SC_C_LANG_SUPPORT_R___11 = 136,
    _SC_CLOCK_SELECTION___11 = 137,
    _SC_CPUTIME___11 = 138,
    _SC_THREAD_CPUTIME___11 = 139,
    _SC_DEVICE_IO___11 = 140,
    _SC_DEVICE_SPECIFIC___11 = 141,
    _SC_DEVICE_SPECIFIC_R___11 = 142,
    _SC_FD_MGMT___11 = 143,
    _SC_FIFO___11 = 144,
    _SC_PIPE___11 = 145,
    _SC_FILE_ATTRIBUTES___11 = 146,
    _SC_FILE_LOCKING___11 = 147,
    _SC_FILE_SYSTEM___11 = 148,
    _SC_MONOTONIC_CLOCK___11 = 149,
    _SC_MULTI_PROCESS___11 = 150,
    _SC_SINGLE_PROCESS___11 = 151,
    _SC_NETWORKING___11 = 152,
    _SC_READER_WRITER_LOCKS___11 = 153,
    _SC_SPIN_LOCKS___11 = 154,
    _SC_REGEXP___11 = 155,
    _SC_REGEX_VERSION___11 = 156,
    _SC_SHELL___11 = 157,
    _SC_SIGNALS___11 = 158,
    _SC_SPAWN___11 = 159,
    _SC_SPORADIC_SERVER___11 = 160,
    _SC_THREAD_SPORADIC_SERVER___11 = 161,
    _SC_SYSTEM_DATABASE___11 = 162,
    _SC_SYSTEM_DATABASE_R___11 = 163,
    _SC_TIMEOUTS___11 = 164,
    _SC_TYPED_MEMORY_OBJECTS___11 = 165,
    _SC_USER_GROUPS___11 = 166,
    _SC_USER_GROUPS_R___11 = 167,
    _SC_2_PBS___11 = 168,
    _SC_2_PBS_ACCOUNTING___11 = 169,
    _SC_2_PBS_LOCATE___11 = 170,
    _SC_2_PBS_MESSAGE___11 = 171,
    _SC_2_PBS_TRACK___11 = 172,
    _SC_SYMLOOP_MAX___11 = 173,
    _SC_STREAMS___11 = 174,
    _SC_2_PBS_CHECKPOINT___11 = 175,
    _SC_V6_ILP32_OFF32___11 = 176,
    _SC_V6_ILP32_OFFBIG___11 = 177,
    _SC_V6_LP64_OFF64___11 = 178,
    _SC_V6_LPBIG_OFFBIG___11 = 179,
    _SC_HOST_NAME_MAX___11 = 180,
    _SC_TRACE___11 = 181,
    _SC_TRACE_EVENT_FILTER___11 = 182,
    _SC_TRACE_INHERIT___11 = 183,
    _SC_TRACE_LOG___11 = 184,
    _SC_LEVEL1_ICACHE_SIZE___11 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___11 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___11 = 187,
    _SC_LEVEL1_DCACHE_SIZE___11 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___11 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___11 = 190,
    _SC_LEVEL2_CACHE_SIZE___11 = 191,
    _SC_LEVEL2_CACHE_ASSOC___11 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___11 = 193,
    _SC_LEVEL3_CACHE_SIZE___11 = 194,
    _SC_LEVEL3_CACHE_ASSOC___11 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___11 = 196,
    _SC_LEVEL4_CACHE_SIZE___11 = 197,
    _SC_LEVEL4_CACHE_ASSOC___11 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___11 = 199,
    _SC_IPV6___11 = 235,
    _SC_RAW_SOCKETS___11 = 236,
    _SC_V7_ILP32_OFF32___11 = 237,
    _SC_V7_ILP32_OFFBIG___11 = 238,
    _SC_V7_LP64_OFF64___11 = 239,
    _SC_V7_LPBIG_OFFBIG___11 = 240,
    _SC_SS_REPL_MAX___11 = 241,
    _SC_TRACE_EVENT_NAME_MAX___11 = 242,
    _SC_TRACE_NAME_MAX___11 = 243,
    _SC_TRACE_SYS_MAX___11 = 244,
    _SC_TRACE_USER_EVENT_MAX___11 = 245,
    _SC_XOPEN_STREAMS___11 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___11 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___11 = 248,
    _SC_MINSIGSTKSZ___11 = 249,
    _SC_SIGSTKSZ___11 = 250
} ;
#line 539
enum __anonenum__546___2 {
    _CS_PATH___11 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___11 = 1,
    _CS_GNU_LIBC_VERSION___11 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___11 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___11 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___11 = 5,
    _CS_LFS_CFLAGS___11 = 1000,
    _CS_LFS_LDFLAGS___11 = 1001,
    _CS_LFS_LIBS___11 = 1002,
    _CS_LFS_LINTFLAGS___11 = 1003,
    _CS_LFS64_CFLAGS___11 = 1004,
    _CS_LFS64_LDFLAGS___11 = 1005,
    _CS_LFS64_LIBS___11 = 1006,
    _CS_LFS64_LINTFLAGS___11 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___11 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___11 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___11 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___11 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___11 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___11 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___11 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___11 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___11 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___11 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___11 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___11 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___11 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___11 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___11 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___11 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___11 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___11 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___11 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___11 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___11 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___11 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___11 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___11 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___11 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___11 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___11 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___11 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___11 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___11 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___11 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___11 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___11 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___11 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___11 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___11 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___11 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___11 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___11 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___11 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___11 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___11 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___11 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___11 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___11 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___11 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___11 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___11 = 1147,
    _CS_V6_ENV___11 = 1148,
    _CS_V7_ENV___11 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__547___2 {
    SS_ONSTACK___15 = 1,
    SS_DISABLE___15 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__555___3 {
    PTHREAD_CREATE_JOINABLE___15 = 0,
    PTHREAD_CREATE_DETACHED___15 = 1
} ;
#line 47
enum __anonenum__556___3 {
    PTHREAD_MUTEX_TIMED_NP___15 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___15 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___15 = 3,
    PTHREAD_MUTEX_NORMAL___15 = 0,
    PTHREAD_MUTEX_RECURSIVE___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK___15 = 2,
    PTHREAD_MUTEX_DEFAULT___15 = 0,
    PTHREAD_MUTEX_FAST_NP___10 = 0
} ;
#line 69
enum __anonenum__557___3 {
    PTHREAD_MUTEX_STALLED___15 = 0,
    PTHREAD_MUTEX_STALLED_NP___15 = 0,
    PTHREAD_MUTEX_ROBUST___15 = 1,
    PTHREAD_MUTEX_ROBUST_NP___15 = 1
} ;
#line 81
enum __anonenum__558___3 {
    PTHREAD_PRIO_NONE___15 = 0,
    PTHREAD_PRIO_INHERIT___15 = 1,
    PTHREAD_PRIO_PROTECT___15 = 2
} ;
#line 104
enum __anonenum__559___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___15 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___15 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___15 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___15 = 0
} ;
#line 124
enum __anonenum__560___3 {
    PTHREAD_INHERIT_SCHED___15 = 0,
    PTHREAD_EXPLICIT_SCHED___15 = 1
} ;
#line 134
enum __anonenum__561___3 {
    PTHREAD_SCOPE_SYSTEM___15 = 0,
    PTHREAD_SCOPE_PROCESS___15 = 1
} ;
#line 144
enum __anonenum__562___3 {
    PTHREAD_PROCESS_PRIVATE___15 = 0,
    PTHREAD_PROCESS_SHARED___15 = 1
} ;
#line 168
enum __anonenum__563___3 {
    PTHREAD_CANCEL_ENABLE___15 = 0,
    PTHREAD_CANCEL_DISABLE___15 = 1
} ;
#line 175
enum __anonenum__564___3 {
    PTHREAD_CANCEL_DEFERRED___15 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___15 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__580___3 {
    DT_UNKNOWN___14 = 0,
    DT_FIFO___14 = 1,
    DT_CHR___14 = 2,
    DT_DIR___14 = 4,
    DT_BLK___14 = 6,
    DT_REG___14 = 8,
    DT_LNK___14 = 10,
    DT_SOCK___14 = 12,
    DT_WHT___14 = 14
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__507___3 {
    MSG_OOB___11 = 1,
    MSG_PEEK___11 = 2,
    MSG_DONTROUTE___11 = 4,
    MSG_TRYHARD___11 = 4,
    MSG_CTRUNC___11 = 8,
    MSG_PROXY___11 = 16,
    MSG_TRUNC___11 = 32,
    MSG_DONTWAIT___11 = 64,
    MSG_EOR___11 = 128,
    MSG_WAITALL___11 = 256,
    MSG_FIN___11 = 512,
    MSG_SYN___11 = 1024,
    MSG_CONFIRM___11 = 2048,
    MSG_RST___11 = 4096,
    MSG_ERRQUEUE___11 = 8192,
    MSG_NOSIGNAL___11 = 16384,
    MSG_MORE___11 = 32768,
    MSG_WAITFORONE___11 = 65536,
    MSG_BATCH___11 = 262144,
    MSG_ZEROCOPY___11 = 67108864,
    MSG_FASTOPEN___11 = 536870912,
    MSG_CMSG_CLOEXEC___11 = 1073741824
} ;
#line 334
enum __anonenum__508___3 {
    SCM_RIGHTS___11 = 1,
    SCM_CREDENTIALS___11 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__511___3 {
    SHUT_RD___11 = 0,
    SHUT_WR___11 = 1,
    SHUT_RDWR___11 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__514___3 {
    IPPROTO_IP___11 = 0,
    IPPROTO_ICMP___11 = 1,
    IPPROTO_IGMP___11 = 2,
    IPPROTO_IPIP___11 = 4,
    IPPROTO_TCP___11 = 6,
    IPPROTO_EGP___11 = 8,
    IPPROTO_PUP___11 = 12,
    IPPROTO_UDP___11 = 17,
    IPPROTO_IDP___11 = 22,
    IPPROTO_TP___11 = 29,
    IPPROTO_DCCP___11 = 33,
    IPPROTO_IPV6___11 = 41,
    IPPROTO_RSVP___11 = 46,
    IPPROTO_GRE___11 = 47,
    IPPROTO_ESP___11 = 50,
    IPPROTO_AH___11 = 51,
    IPPROTO_MTP___11 = 92,
    IPPROTO_BEETPH___11 = 94,
    IPPROTO_ENCAP___11 = 98,
    IPPROTO_PIM___11 = 103,
    IPPROTO_COMP___11 = 108,
    IPPROTO_SCTP___11 = 132,
    IPPROTO_UDPLITE___11 = 136,
    IPPROTO_MPLS___11 = 137,
    IPPROTO_ETHERNET___11 = 143,
    IPPROTO_RAW___11 = 255,
    IPPROTO_MPTCP___11 = 262,
    IPPROTO_MAX___11 = 263
} ;
#line 103
enum __anonenum__515___3 {
    IPPROTO_HOPOPTS___11 = 0,
    IPPROTO_ROUTING___11 = 43,
    IPPROTO_FRAGMENT___11 = 44,
    IPPROTO_ICMPV6___11 = 58,
    IPPROTO_NONE___11 = 59,
    IPPROTO_DSTOPTS___11 = 60,
    IPPROTO_MH___11 = 135
} ;
#line 126
enum __anonenum__516___3 {
    IPPORT_ECHO___11 = 7,
    IPPORT_DISCARD___11 = 9,
    IPPORT_SYSTAT___11 = 11,
    IPPORT_DAYTIME___11 = 13,
    IPPORT_NETSTAT___11 = 15,
    IPPORT_FTP___11 = 21,
    IPPORT_TELNET___11 = 23,
    IPPORT_SMTP___11 = 25,
    IPPORT_TIMESERVER___11 = 37,
    IPPORT_NAMESERVER___11 = 42,
    IPPORT_WHOIS___11 = 43,
    IPPORT_MTP___11 = 57,
    IPPORT_TFTP___11 = 69,
    IPPORT_RJE___11 = 77,
    IPPORT_FINGER___11 = 79,
    IPPORT_TTYLINK___11 = 87,
    IPPORT_SUPDUP___11 = 95,
    IPPORT_EXECSERVER___11 = 512,
    IPPORT_LOGINSERVER___11 = 513,
    IPPORT_CMDSERVER___11 = 514,
    IPPORT_EFSSERVER___11 = 520,
    IPPORT_BIFFUDP___11 = 512,
    IPPORT_WHOSERVER___11 = 513,
    IPPORT_ROUTESERVER___11 = 520,
    IPPORT_RESERVED___11 = 1024,
    IPPORT_USERRESERVED___11 = 5000
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__528___3 {
    SI_ASYNCNL___16 = -60,
    SI_DETHREAD___16 = -7,
    SI_TKILL___16 = -6,
    SI_SIGIO___16 = -5,
    SI_ASYNCIO___16 = -4,
    SI_MESGQ___16 = -3,
    SI_TIMER___16 = -2,
    SI_QUEUE___16 = -1,
    SI_USER___16 = 0,
    SI_KERNEL___16 = 128
} ;
#line 71
enum __anonenum__529___3 {
    ILL_ILLOPC___16 = 1,
    ILL_ILLOPN___16 = 2,
    ILL_ILLADR___16 = 3,
    ILL_ILLTRP___16 = 4,
    ILL_PRVOPC___16 = 5,
    ILL_PRVREG___16 = 6,
    ILL_COPROC___16 = 7,
    ILL_BADSTK___16 = 8,
    ILL_BADIADDR___16 = 9
} ;
#line 94
enum __anonenum__530___3 {
    FPE_INTDIV___16 = 1,
    FPE_INTOVF___16 = 2,
    FPE_FLTDIV___16 = 3,
    FPE_FLTOVF___16 = 4,
    FPE_FLTUND___16 = 5,
    FPE_FLTRES___16 = 6,
    FPE_FLTINV___16 = 7,
    FPE_FLTSUB___16 = 8,
    FPE_FLTUNK___16 = 14,
    FPE_CONDTRAP___16 = 15
} ;
#line 119
enum __anonenum__531___3 {
    SEGV_MAPERR___16 = 1,
    SEGV_ACCERR___16 = 2,
    SEGV_BNDERR___16 = 3,
    SEGV_PKUERR___16 = 4,
    SEGV_ACCADI___16 = 5,
    SEGV_ADIDERR___16 = 6,
    SEGV_ADIPERR___16 = 7,
    SEGV_MTEAERR___16 = 8,
    SEGV_MTESERR___16 = 9
} ;
#line 142
enum __anonenum__532___3 {
    BUS_ADRALN___16 = 1,
    BUS_ADRERR___16 = 2,
    BUS_OBJERR___16 = 3,
    BUS_MCEERR_AR___16 = 4,
    BUS_MCEERR_AO___16 = 5
} ;
#line 159
enum __anonenum__533___3 {
    TRAP_BRKPT___11 = 1,
    TRAP_TRACE___11 = 2,
    TRAP_BRANCH___11 = 3,
    TRAP_HWBKPT___11 = 4,
    TRAP_UNK___11 = 5
} ;
#line 176
enum __anonenum__534___3 {
    CLD_EXITED___16 = 1,
    CLD_KILLED___16 = 2,
    CLD_DUMPED___16 = 3,
    CLD_TRAPPED___16 = 4,
    CLD_STOPPED___16 = 5,
    CLD_CONTINUED___16 = 6
} ;
#line 193
enum __anonenum__535___4 {
    POLL_IN___16 = 1,
    POLL_OUT___16 = 2,
    POLL_MSG___16 = 3,
    POLL_ERR___16 = 4,
    POLL_PRI___16 = 5,
    POLL_HUP___16 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__538___3 {
    SIGEV_SIGNAL___16 = 0,
    SIGEV_NONE___16 = 1,
    SIGEV_THREAD___16 = 2,
    SIGEV_THREAD_ID___16 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__542___3 {
    REG_R8___11 = 0,
    REG_R9___11 = 1,
    REG_R10___11 = 2,
    REG_R11___11 = 3,
    REG_R12___11 = 4,
    REG_R13___11 = 5,
    REG_R14___11 = 6,
    REG_R15___11 = 7,
    REG_RDI___11 = 8,
    REG_RSI___11 = 9,
    REG_RBP___11 = 10,
    REG_RBX___11 = 11,
    REG_RDX___11 = 12,
    REG_RAX___11 = 13,
    REG_RCX___11 = 14,
    REG_RSP___11 = 15,
    REG_RIP___11 = 16,
    REG_EFL___11 = 17,
    REG_CSGSFS___11 = 18,
    REG_ERR___11 = 19,
    REG_TRAPNO___11 = 20,
    REG_OLDMASK___11 = 21,
    REG_CR2___11 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__544___3 {
    _PC_LINK_MAX___12 = 0,
    _PC_MAX_CANON___12 = 1,
    _PC_MAX_INPUT___12 = 2,
    _PC_NAME_MAX___12 = 3,
    _PC_PATH_MAX___12 = 4,
    _PC_PIPE_BUF___12 = 5,
    _PC_CHOWN_RESTRICTED___12 = 6,
    _PC_NO_TRUNC___12 = 7,
    _PC_VDISABLE___12 = 8,
    _PC_SYNC_IO___12 = 9,
    _PC_ASYNC_IO___12 = 10,
    _PC_PRIO_IO___12 = 11,
    _PC_SOCK_MAXBUF___12 = 12,
    _PC_FILESIZEBITS___12 = 13,
    _PC_REC_INCR_XFER_SIZE___12 = 14,
    _PC_REC_MAX_XFER_SIZE___12 = 15,
    _PC_REC_MIN_XFER_SIZE___12 = 16,
    _PC_REC_XFER_ALIGN___12 = 17,
    _PC_ALLOC_SIZE_MIN___12 = 18,
    _PC_SYMLINK_MAX___12 = 19,
    _PC_2_SYMLINKS___12 = 20
} ;
#line 71
enum __anonenum__545___3 {
    _SC_ARG_MAX___12 = 0,
    _SC_CHILD_MAX___12 = 1,
    _SC_CLK_TCK___12 = 2,
    _SC_NGROUPS_MAX___12 = 3,
    _SC_OPEN_MAX___12 = 4,
    _SC_STREAM_MAX___12 = 5,
    _SC_TZNAME_MAX___12 = 6,
    _SC_JOB_CONTROL___12 = 7,
    _SC_SAVED_IDS___12 = 8,
    _SC_REALTIME_SIGNALS___12 = 9,
    _SC_PRIORITY_SCHEDULING___12 = 10,
    _SC_TIMERS___12 = 11,
    _SC_ASYNCHRONOUS_IO___12 = 12,
    _SC_PRIORITIZED_IO___12 = 13,
    _SC_SYNCHRONIZED_IO___12 = 14,
    _SC_FSYNC___12 = 15,
    _SC_MAPPED_FILES___12 = 16,
    _SC_MEMLOCK___12 = 17,
    _SC_MEMLOCK_RANGE___12 = 18,
    _SC_MEMORY_PROTECTION___12 = 19,
    _SC_MESSAGE_PASSING___12 = 20,
    _SC_SEMAPHORES___12 = 21,
    _SC_SHARED_MEMORY_OBJECTS___12 = 22,
    _SC_AIO_LISTIO_MAX___12 = 23,
    _SC_AIO_MAX___12 = 24,
    _SC_AIO_PRIO_DELTA_MAX___12 = 25,
    _SC_DELAYTIMER_MAX___12 = 26,
    _SC_MQ_OPEN_MAX___12 = 27,
    _SC_MQ_PRIO_MAX___12 = 28,
    _SC_VERSION___12 = 29,
    _SC_PAGESIZE___12 = 30,
    _SC_RTSIG_MAX___12 = 31,
    _SC_SEM_NSEMS_MAX___12 = 32,
    _SC_SEM_VALUE_MAX___12 = 33,
    _SC_SIGQUEUE_MAX___12 = 34,
    _SC_TIMER_MAX___12 = 35,
    _SC_BC_BASE_MAX___12 = 36,
    _SC_BC_DIM_MAX___12 = 37,
    _SC_BC_SCALE_MAX___12 = 38,
    _SC_BC_STRING_MAX___12 = 39,
    _SC_COLL_WEIGHTS_MAX___12 = 40,
    _SC_EQUIV_CLASS_MAX___12 = 41,
    _SC_EXPR_NEST_MAX___12 = 42,
    _SC_LINE_MAX___12 = 43,
    _SC_RE_DUP_MAX___12 = 44,
    _SC_CHARCLASS_NAME_MAX___12 = 45,
    _SC_2_VERSION___12 = 46,
    _SC_2_C_BIND___12 = 47,
    _SC_2_C_DEV___12 = 48,
    _SC_2_FORT_DEV___12 = 49,
    _SC_2_FORT_RUN___12 = 50,
    _SC_2_SW_DEV___12 = 51,
    _SC_2_LOCALEDEF___12 = 52,
    _SC_PII___12 = 53,
    _SC_PII_XTI___12 = 54,
    _SC_PII_SOCKET___12 = 55,
    _SC_PII_INTERNET___12 = 56,
    _SC_PII_OSI___12 = 57,
    _SC_POLL___12 = 58,
    _SC_SELECT___12 = 59,
    _SC_UIO_MAXIOV___12 = 60,
    _SC_IOV_MAX___12 = 60,
    _SC_PII_INTERNET_STREAM___12 = 61,
    _SC_PII_INTERNET_DGRAM___12 = 62,
    _SC_PII_OSI_COTS___12 = 63,
    _SC_PII_OSI_CLTS___12 = 64,
    _SC_PII_OSI_M___12 = 65,
    _SC_T_IOV_MAX___12 = 66,
    _SC_THREADS___12 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___12 = 68,
    _SC_GETGR_R_SIZE_MAX___12 = 69,
    _SC_GETPW_R_SIZE_MAX___12 = 70,
    _SC_LOGIN_NAME_MAX___12 = 71,
    _SC_TTY_NAME_MAX___12 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___12 = 73,
    _SC_THREAD_KEYS_MAX___12 = 74,
    _SC_THREAD_STACK_MIN___12 = 75,
    _SC_THREAD_THREADS_MAX___12 = 76,
    _SC_THREAD_ATTR_STACKADDR___12 = 77,
    _SC_THREAD_ATTR_STACKSIZE___12 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___12 = 79,
    _SC_THREAD_PRIO_INHERIT___12 = 80,
    _SC_THREAD_PRIO_PROTECT___12 = 81,
    _SC_THREAD_PROCESS_SHARED___12 = 82,
    _SC_NPROCESSORS_CONF___12 = 83,
    _SC_NPROCESSORS_ONLN___12 = 84,
    _SC_PHYS_PAGES___12 = 85,
    _SC_AVPHYS_PAGES___12 = 86,
    _SC_ATEXIT_MAX___12 = 87,
    _SC_PASS_MAX___12 = 88,
    _SC_XOPEN_VERSION___12 = 89,
    _SC_XOPEN_XCU_VERSION___12 = 90,
    _SC_XOPEN_UNIX___12 = 91,
    _SC_XOPEN_CRYPT___12 = 92,
    _SC_XOPEN_ENH_I18N___12 = 93,
    _SC_XOPEN_SHM___12 = 94,
    _SC_2_CHAR_TERM___12 = 95,
    _SC_2_C_VERSION___12 = 96,
    _SC_2_UPE___12 = 97,
    _SC_XOPEN_XPG2___12 = 98,
    _SC_XOPEN_XPG3___12 = 99,
    _SC_XOPEN_XPG4___12 = 100,
    _SC_CHAR_BIT___12 = 101,
    _SC_CHAR_MAX___12 = 102,
    _SC_CHAR_MIN___12 = 103,
    _SC_INT_MAX___12 = 104,
    _SC_INT_MIN___12 = 105,
    _SC_LONG_BIT___12 = 106,
    _SC_WORD_BIT___12 = 107,
    _SC_MB_LEN_MAX___12 = 108,
    _SC_NZERO___12 = 109,
    _SC_SSIZE_MAX___12 = 110,
    _SC_SCHAR_MAX___12 = 111,
    _SC_SCHAR_MIN___12 = 112,
    _SC_SHRT_MAX___12 = 113,
    _SC_SHRT_MIN___12 = 114,
    _SC_UCHAR_MAX___12 = 115,
    _SC_UINT_MAX___12 = 116,
    _SC_ULONG_MAX___12 = 117,
    _SC_USHRT_MAX___12 = 118,
    _SC_NL_ARGMAX___12 = 119,
    _SC_NL_LANGMAX___12 = 120,
    _SC_NL_MSGMAX___12 = 121,
    _SC_NL_NMAX___12 = 122,
    _SC_NL_SETMAX___12 = 123,
    _SC_NL_TEXTMAX___12 = 124,
    _SC_XBS5_ILP32_OFF32___12 = 125,
    _SC_XBS5_ILP32_OFFBIG___12 = 126,
    _SC_XBS5_LP64_OFF64___12 = 127,
    _SC_XBS5_LPBIG_OFFBIG___12 = 128,
    _SC_XOPEN_LEGACY___12 = 129,
    _SC_XOPEN_REALTIME___12 = 130,
    _SC_XOPEN_REALTIME_THREADS___12 = 131,
    _SC_ADVISORY_INFO___12 = 132,
    _SC_BARRIERS___12 = 133,
    _SC_BASE___12 = 134,
    _SC_C_LANG_SUPPORT___12 = 135,
    _SC_C_LANG_SUPPORT_R___12 = 136,
    _SC_CLOCK_SELECTION___12 = 137,
    _SC_CPUTIME___12 = 138,
    _SC_THREAD_CPUTIME___12 = 139,
    _SC_DEVICE_IO___12 = 140,
    _SC_DEVICE_SPECIFIC___12 = 141,
    _SC_DEVICE_SPECIFIC_R___12 = 142,
    _SC_FD_MGMT___12 = 143,
    _SC_FIFO___12 = 144,
    _SC_PIPE___12 = 145,
    _SC_FILE_ATTRIBUTES___12 = 146,
    _SC_FILE_LOCKING___12 = 147,
    _SC_FILE_SYSTEM___12 = 148,
    _SC_MONOTONIC_CLOCK___12 = 149,
    _SC_MULTI_PROCESS___12 = 150,
    _SC_SINGLE_PROCESS___12 = 151,
    _SC_NETWORKING___12 = 152,
    _SC_READER_WRITER_LOCKS___12 = 153,
    _SC_SPIN_LOCKS___12 = 154,
    _SC_REGEXP___12 = 155,
    _SC_REGEX_VERSION___12 = 156,
    _SC_SHELL___12 = 157,
    _SC_SIGNALS___12 = 158,
    _SC_SPAWN___12 = 159,
    _SC_SPORADIC_SERVER___12 = 160,
    _SC_THREAD_SPORADIC_SERVER___12 = 161,
    _SC_SYSTEM_DATABASE___12 = 162,
    _SC_SYSTEM_DATABASE_R___12 = 163,
    _SC_TIMEOUTS___12 = 164,
    _SC_TYPED_MEMORY_OBJECTS___12 = 165,
    _SC_USER_GROUPS___12 = 166,
    _SC_USER_GROUPS_R___12 = 167,
    _SC_2_PBS___12 = 168,
    _SC_2_PBS_ACCOUNTING___12 = 169,
    _SC_2_PBS_LOCATE___12 = 170,
    _SC_2_PBS_MESSAGE___12 = 171,
    _SC_2_PBS_TRACK___12 = 172,
    _SC_SYMLOOP_MAX___12 = 173,
    _SC_STREAMS___12 = 174,
    _SC_2_PBS_CHECKPOINT___12 = 175,
    _SC_V6_ILP32_OFF32___12 = 176,
    _SC_V6_ILP32_OFFBIG___12 = 177,
    _SC_V6_LP64_OFF64___12 = 178,
    _SC_V6_LPBIG_OFFBIG___12 = 179,
    _SC_HOST_NAME_MAX___12 = 180,
    _SC_TRACE___12 = 181,
    _SC_TRACE_EVENT_FILTER___12 = 182,
    _SC_TRACE_INHERIT___12 = 183,
    _SC_TRACE_LOG___12 = 184,
    _SC_LEVEL1_ICACHE_SIZE___12 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___12 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___12 = 187,
    _SC_LEVEL1_DCACHE_SIZE___12 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___12 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___12 = 190,
    _SC_LEVEL2_CACHE_SIZE___12 = 191,
    _SC_LEVEL2_CACHE_ASSOC___12 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___12 = 193,
    _SC_LEVEL3_CACHE_SIZE___12 = 194,
    _SC_LEVEL3_CACHE_ASSOC___12 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___12 = 196,
    _SC_LEVEL4_CACHE_SIZE___12 = 197,
    _SC_LEVEL4_CACHE_ASSOC___12 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___12 = 199,
    _SC_IPV6___12 = 235,
    _SC_RAW_SOCKETS___12 = 236,
    _SC_V7_ILP32_OFF32___12 = 237,
    _SC_V7_ILP32_OFFBIG___12 = 238,
    _SC_V7_LP64_OFF64___12 = 239,
    _SC_V7_LPBIG_OFFBIG___12 = 240,
    _SC_SS_REPL_MAX___12 = 241,
    _SC_TRACE_EVENT_NAME_MAX___12 = 242,
    _SC_TRACE_NAME_MAX___12 = 243,
    _SC_TRACE_SYS_MAX___12 = 244,
    _SC_TRACE_USER_EVENT_MAX___12 = 245,
    _SC_XOPEN_STREAMS___12 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___12 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___12 = 248,
    _SC_MINSIGSTKSZ___12 = 249,
    _SC_SIGSTKSZ___12 = 250
} ;
#line 539
enum __anonenum__546___3 {
    _CS_PATH___12 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___12 = 1,
    _CS_GNU_LIBC_VERSION___12 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___12 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___12 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___12 = 5,
    _CS_LFS_CFLAGS___12 = 1000,
    _CS_LFS_LDFLAGS___12 = 1001,
    _CS_LFS_LIBS___12 = 1002,
    _CS_LFS_LINTFLAGS___12 = 1003,
    _CS_LFS64_CFLAGS___12 = 1004,
    _CS_LFS64_LDFLAGS___12 = 1005,
    _CS_LFS64_LIBS___12 = 1006,
    _CS_LFS64_LINTFLAGS___12 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___12 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___12 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___12 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___12 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___12 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___12 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___12 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___12 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___12 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___12 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___12 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___12 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___12 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___12 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___12 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___12 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___12 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___12 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___12 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___12 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___12 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___12 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___12 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___12 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___12 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___12 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___12 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___12 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___12 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___12 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___12 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___12 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___12 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___12 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___12 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___12 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___12 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___12 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___12 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___12 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___12 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___12 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___12 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___12 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___12 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___12 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___12 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___12 = 1147,
    _CS_V6_ENV___12 = 1148,
    _CS_V7_ENV___12 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__547___3 {
    SS_ONSTACK___16 = 1,
    SS_DISABLE___16 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__555___4 {
    PTHREAD_CREATE_JOINABLE___16 = 0,
    PTHREAD_CREATE_DETACHED___16 = 1
} ;
#line 47
enum __anonenum__556___4 {
    PTHREAD_MUTEX_TIMED_NP___16 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___16 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___16 = 3,
    PTHREAD_MUTEX_NORMAL___16 = 0,
    PTHREAD_MUTEX_RECURSIVE___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK___16 = 2,
    PTHREAD_MUTEX_DEFAULT___16 = 0,
    PTHREAD_MUTEX_FAST_NP___11 = 0
} ;
#line 69
enum __anonenum__557___4 {
    PTHREAD_MUTEX_STALLED___16 = 0,
    PTHREAD_MUTEX_STALLED_NP___16 = 0,
    PTHREAD_MUTEX_ROBUST___16 = 1,
    PTHREAD_MUTEX_ROBUST_NP___16 = 1
} ;
#line 81
enum __anonenum__558___4 {
    PTHREAD_PRIO_NONE___16 = 0,
    PTHREAD_PRIO_INHERIT___16 = 1,
    PTHREAD_PRIO_PROTECT___16 = 2
} ;
#line 104
enum __anonenum__559___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___16 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___16 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___16 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___16 = 0
} ;
#line 124
enum __anonenum__560___4 {
    PTHREAD_INHERIT_SCHED___16 = 0,
    PTHREAD_EXPLICIT_SCHED___16 = 1
} ;
#line 134
enum __anonenum__561___4 {
    PTHREAD_SCOPE_SYSTEM___16 = 0,
    PTHREAD_SCOPE_PROCESS___16 = 1
} ;
#line 144
enum __anonenum__562___4 {
    PTHREAD_PROCESS_PRIVATE___16 = 0,
    PTHREAD_PROCESS_SHARED___16 = 1
} ;
#line 168
enum __anonenum__563___4 {
    PTHREAD_CANCEL_ENABLE___16 = 0,
    PTHREAD_CANCEL_DISABLE___16 = 1
} ;
#line 175
enum __anonenum__564___4 {
    PTHREAD_CANCEL_DEFERRED___16 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___16 = 1
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__580___4 {
    DT_UNKNOWN___15 = 0,
    DT_FIFO___15 = 1,
    DT_CHR___15 = 2,
    DT_DIR___15 = 4,
    DT_BLK___15 = 6,
    DT_REG___15 = 8,
    DT_LNK___15 = 10,
    DT_SOCK___15 = 12,
    DT_WHT___15 = 14
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__1106___2 {
    SI_ASYNCNL___17 = -60,
    SI_DETHREAD___17 = -7,
    SI_TKILL___17 = -6,
    SI_SIGIO___17 = -5,
    SI_ASYNCIO___17 = -4,
    SI_MESGQ___17 = -3,
    SI_TIMER___17 = -2,
    SI_QUEUE___17 = -1,
    SI_USER___17 = 0,
    SI_KERNEL___17 = 128
} ;
#line 71
enum __anonenum__1107___2 {
    ILL_ILLOPC___17 = 1,
    ILL_ILLOPN___17 = 2,
    ILL_ILLADR___17 = 3,
    ILL_ILLTRP___17 = 4,
    ILL_PRVOPC___17 = 5,
    ILL_PRVREG___17 = 6,
    ILL_COPROC___17 = 7,
    ILL_BADSTK___17 = 8,
    ILL_BADIADDR___17 = 9
} ;
#line 94
enum __anonenum__1108___2 {
    FPE_INTDIV___17 = 1,
    FPE_INTOVF___17 = 2,
    FPE_FLTDIV___17 = 3,
    FPE_FLTOVF___17 = 4,
    FPE_FLTUND___17 = 5,
    FPE_FLTRES___17 = 6,
    FPE_FLTINV___17 = 7,
    FPE_FLTSUB___17 = 8,
    FPE_FLTUNK___17 = 14,
    FPE_CONDTRAP___17 = 15
} ;
#line 119
enum __anonenum__1109___2 {
    SEGV_MAPERR___17 = 1,
    SEGV_ACCERR___17 = 2,
    SEGV_BNDERR___17 = 3,
    SEGV_PKUERR___17 = 4,
    SEGV_ACCADI___17 = 5,
    SEGV_ADIDERR___17 = 6,
    SEGV_ADIPERR___17 = 7,
    SEGV_MTEAERR___17 = 8,
    SEGV_MTESERR___17 = 9
} ;
#line 142
enum __anonenum__1110___2 {
    BUS_ADRALN___17 = 1,
    BUS_ADRERR___17 = 2,
    BUS_OBJERR___17 = 3,
    BUS_MCEERR_AR___17 = 4,
    BUS_MCEERR_AO___17 = 5
} ;
#line 159
enum __anonenum__1111___2 {
    TRAP_BRKPT___12 = 1,
    TRAP_TRACE___12 = 2,
    TRAP_BRANCH___12 = 3,
    TRAP_HWBKPT___12 = 4,
    TRAP_UNK___12 = 5
} ;
#line 176
enum __anonenum__1112___2 {
    CLD_EXITED___17 = 1,
    CLD_KILLED___17 = 2,
    CLD_DUMPED___17 = 3,
    CLD_TRAPPED___17 = 4,
    CLD_STOPPED___17 = 5,
    CLD_CONTINUED___17 = 6
} ;
#line 193
enum __anonenum__1113___2 {
    POLL_IN___17 = 1,
    POLL_OUT___17 = 2,
    POLL_MSG___17 = 3,
    POLL_ERR___17 = 4,
    POLL_PRI___17 = 5,
    POLL_HUP___17 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__1116___2 {
    SIGEV_SIGNAL___17 = 0,
    SIGEV_NONE___17 = 1,
    SIGEV_THREAD___17 = 2,
    SIGEV_THREAD_ID___17 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__1120___2 {
    REG_R8___12 = 0,
    REG_R9___12 = 1,
    REG_R10___12 = 2,
    REG_R11___12 = 3,
    REG_R12___12 = 4,
    REG_R13___12 = 5,
    REG_R14___12 = 6,
    REG_R15___12 = 7,
    REG_RDI___12 = 8,
    REG_RSI___12 = 9,
    REG_RBP___12 = 10,
    REG_RBX___12 = 11,
    REG_RDX___12 = 12,
    REG_RAX___12 = 13,
    REG_RCX___12 = 14,
    REG_RSP___12 = 15,
    REG_RIP___12 = 16,
    REG_EFL___12 = 17,
    REG_CSGSFS___12 = 18,
    REG_ERR___12 = 19,
    REG_TRAPNO___12 = 20,
    REG_OLDMASK___12 = 21,
    REG_CR2___12 = 22
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__1122___2 {
    _PC_LINK_MAX___13 = 0,
    _PC_MAX_CANON___13 = 1,
    _PC_MAX_INPUT___13 = 2,
    _PC_NAME_MAX___13 = 3,
    _PC_PATH_MAX___13 = 4,
    _PC_PIPE_BUF___13 = 5,
    _PC_CHOWN_RESTRICTED___13 = 6,
    _PC_NO_TRUNC___13 = 7,
    _PC_VDISABLE___13 = 8,
    _PC_SYNC_IO___13 = 9,
    _PC_ASYNC_IO___13 = 10,
    _PC_PRIO_IO___13 = 11,
    _PC_SOCK_MAXBUF___13 = 12,
    _PC_FILESIZEBITS___13 = 13,
    _PC_REC_INCR_XFER_SIZE___13 = 14,
    _PC_REC_MAX_XFER_SIZE___13 = 15,
    _PC_REC_MIN_XFER_SIZE___13 = 16,
    _PC_REC_XFER_ALIGN___13 = 17,
    _PC_ALLOC_SIZE_MIN___13 = 18,
    _PC_SYMLINK_MAX___13 = 19,
    _PC_2_SYMLINKS___13 = 20
} ;
#line 71
enum __anonenum__1123___2 {
    _SC_ARG_MAX___13 = 0,
    _SC_CHILD_MAX___13 = 1,
    _SC_CLK_TCK___13 = 2,
    _SC_NGROUPS_MAX___13 = 3,
    _SC_OPEN_MAX___13 = 4,
    _SC_STREAM_MAX___13 = 5,
    _SC_TZNAME_MAX___13 = 6,
    _SC_JOB_CONTROL___13 = 7,
    _SC_SAVED_IDS___13 = 8,
    _SC_REALTIME_SIGNALS___13 = 9,
    _SC_PRIORITY_SCHEDULING___13 = 10,
    _SC_TIMERS___13 = 11,
    _SC_ASYNCHRONOUS_IO___13 = 12,
    _SC_PRIORITIZED_IO___13 = 13,
    _SC_SYNCHRONIZED_IO___13 = 14,
    _SC_FSYNC___13 = 15,
    _SC_MAPPED_FILES___13 = 16,
    _SC_MEMLOCK___13 = 17,
    _SC_MEMLOCK_RANGE___13 = 18,
    _SC_MEMORY_PROTECTION___13 = 19,
    _SC_MESSAGE_PASSING___13 = 20,
    _SC_SEMAPHORES___13 = 21,
    _SC_SHARED_MEMORY_OBJECTS___13 = 22,
    _SC_AIO_LISTIO_MAX___13 = 23,
    _SC_AIO_MAX___13 = 24,
    _SC_AIO_PRIO_DELTA_MAX___13 = 25,
    _SC_DELAYTIMER_MAX___13 = 26,
    _SC_MQ_OPEN_MAX___13 = 27,
    _SC_MQ_PRIO_MAX___13 = 28,
    _SC_VERSION___13 = 29,
    _SC_PAGESIZE___13 = 30,
    _SC_RTSIG_MAX___13 = 31,
    _SC_SEM_NSEMS_MAX___13 = 32,
    _SC_SEM_VALUE_MAX___13 = 33,
    _SC_SIGQUEUE_MAX___13 = 34,
    _SC_TIMER_MAX___13 = 35,
    _SC_BC_BASE_MAX___13 = 36,
    _SC_BC_DIM_MAX___13 = 37,
    _SC_BC_SCALE_MAX___13 = 38,
    _SC_BC_STRING_MAX___13 = 39,
    _SC_COLL_WEIGHTS_MAX___13 = 40,
    _SC_EQUIV_CLASS_MAX___13 = 41,
    _SC_EXPR_NEST_MAX___13 = 42,
    _SC_LINE_MAX___13 = 43,
    _SC_RE_DUP_MAX___13 = 44,
    _SC_CHARCLASS_NAME_MAX___13 = 45,
    _SC_2_VERSION___13 = 46,
    _SC_2_C_BIND___13 = 47,
    _SC_2_C_DEV___13 = 48,
    _SC_2_FORT_DEV___13 = 49,
    _SC_2_FORT_RUN___13 = 50,
    _SC_2_SW_DEV___13 = 51,
    _SC_2_LOCALEDEF___13 = 52,
    _SC_PII___13 = 53,
    _SC_PII_XTI___13 = 54,
    _SC_PII_SOCKET___13 = 55,
    _SC_PII_INTERNET___13 = 56,
    _SC_PII_OSI___13 = 57,
    _SC_POLL___13 = 58,
    _SC_SELECT___13 = 59,
    _SC_UIO_MAXIOV___13 = 60,
    _SC_IOV_MAX___13 = 60,
    _SC_PII_INTERNET_STREAM___13 = 61,
    _SC_PII_INTERNET_DGRAM___13 = 62,
    _SC_PII_OSI_COTS___13 = 63,
    _SC_PII_OSI_CLTS___13 = 64,
    _SC_PII_OSI_M___13 = 65,
    _SC_T_IOV_MAX___13 = 66,
    _SC_THREADS___13 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___13 = 68,
    _SC_GETGR_R_SIZE_MAX___13 = 69,
    _SC_GETPW_R_SIZE_MAX___13 = 70,
    _SC_LOGIN_NAME_MAX___13 = 71,
    _SC_TTY_NAME_MAX___13 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___13 = 73,
    _SC_THREAD_KEYS_MAX___13 = 74,
    _SC_THREAD_STACK_MIN___13 = 75,
    _SC_THREAD_THREADS_MAX___13 = 76,
    _SC_THREAD_ATTR_STACKADDR___13 = 77,
    _SC_THREAD_ATTR_STACKSIZE___13 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___13 = 79,
    _SC_THREAD_PRIO_INHERIT___13 = 80,
    _SC_THREAD_PRIO_PROTECT___13 = 81,
    _SC_THREAD_PROCESS_SHARED___13 = 82,
    _SC_NPROCESSORS_CONF___13 = 83,
    _SC_NPROCESSORS_ONLN___13 = 84,
    _SC_PHYS_PAGES___13 = 85,
    _SC_AVPHYS_PAGES___13 = 86,
    _SC_ATEXIT_MAX___13 = 87,
    _SC_PASS_MAX___13 = 88,
    _SC_XOPEN_VERSION___13 = 89,
    _SC_XOPEN_XCU_VERSION___13 = 90,
    _SC_XOPEN_UNIX___13 = 91,
    _SC_XOPEN_CRYPT___13 = 92,
    _SC_XOPEN_ENH_I18N___13 = 93,
    _SC_XOPEN_SHM___13 = 94,
    _SC_2_CHAR_TERM___13 = 95,
    _SC_2_C_VERSION___13 = 96,
    _SC_2_UPE___13 = 97,
    _SC_XOPEN_XPG2___13 = 98,
    _SC_XOPEN_XPG3___13 = 99,
    _SC_XOPEN_XPG4___13 = 100,
    _SC_CHAR_BIT___13 = 101,
    _SC_CHAR_MAX___13 = 102,
    _SC_CHAR_MIN___13 = 103,
    _SC_INT_MAX___13 = 104,
    _SC_INT_MIN___13 = 105,
    _SC_LONG_BIT___13 = 106,
    _SC_WORD_BIT___13 = 107,
    _SC_MB_LEN_MAX___13 = 108,
    _SC_NZERO___13 = 109,
    _SC_SSIZE_MAX___13 = 110,
    _SC_SCHAR_MAX___13 = 111,
    _SC_SCHAR_MIN___13 = 112,
    _SC_SHRT_MAX___13 = 113,
    _SC_SHRT_MIN___13 = 114,
    _SC_UCHAR_MAX___13 = 115,
    _SC_UINT_MAX___13 = 116,
    _SC_ULONG_MAX___13 = 117,
    _SC_USHRT_MAX___13 = 118,
    _SC_NL_ARGMAX___13 = 119,
    _SC_NL_LANGMAX___13 = 120,
    _SC_NL_MSGMAX___13 = 121,
    _SC_NL_NMAX___13 = 122,
    _SC_NL_SETMAX___13 = 123,
    _SC_NL_TEXTMAX___13 = 124,
    _SC_XBS5_ILP32_OFF32___13 = 125,
    _SC_XBS5_ILP32_OFFBIG___13 = 126,
    _SC_XBS5_LP64_OFF64___13 = 127,
    _SC_XBS5_LPBIG_OFFBIG___13 = 128,
    _SC_XOPEN_LEGACY___13 = 129,
    _SC_XOPEN_REALTIME___13 = 130,
    _SC_XOPEN_REALTIME_THREADS___13 = 131,
    _SC_ADVISORY_INFO___13 = 132,
    _SC_BARRIERS___13 = 133,
    _SC_BASE___13 = 134,
    _SC_C_LANG_SUPPORT___13 = 135,
    _SC_C_LANG_SUPPORT_R___13 = 136,
    _SC_CLOCK_SELECTION___13 = 137,
    _SC_CPUTIME___13 = 138,
    _SC_THREAD_CPUTIME___13 = 139,
    _SC_DEVICE_IO___13 = 140,
    _SC_DEVICE_SPECIFIC___13 = 141,
    _SC_DEVICE_SPECIFIC_R___13 = 142,
    _SC_FD_MGMT___13 = 143,
    _SC_FIFO___13 = 144,
    _SC_PIPE___13 = 145,
    _SC_FILE_ATTRIBUTES___13 = 146,
    _SC_FILE_LOCKING___13 = 147,
    _SC_FILE_SYSTEM___13 = 148,
    _SC_MONOTONIC_CLOCK___13 = 149,
    _SC_MULTI_PROCESS___13 = 150,
    _SC_SINGLE_PROCESS___13 = 151,
    _SC_NETWORKING___13 = 152,
    _SC_READER_WRITER_LOCKS___13 = 153,
    _SC_SPIN_LOCKS___13 = 154,
    _SC_REGEXP___13 = 155,
    _SC_REGEX_VERSION___13 = 156,
    _SC_SHELL___13 = 157,
    _SC_SIGNALS___13 = 158,
    _SC_SPAWN___13 = 159,
    _SC_SPORADIC_SERVER___13 = 160,
    _SC_THREAD_SPORADIC_SERVER___13 = 161,
    _SC_SYSTEM_DATABASE___13 = 162,
    _SC_SYSTEM_DATABASE_R___13 = 163,
    _SC_TIMEOUTS___13 = 164,
    _SC_TYPED_MEMORY_OBJECTS___13 = 165,
    _SC_USER_GROUPS___13 = 166,
    _SC_USER_GROUPS_R___13 = 167,
    _SC_2_PBS___13 = 168,
    _SC_2_PBS_ACCOUNTING___13 = 169,
    _SC_2_PBS_LOCATE___13 = 170,
    _SC_2_PBS_MESSAGE___13 = 171,
    _SC_2_PBS_TRACK___13 = 172,
    _SC_SYMLOOP_MAX___13 = 173,
    _SC_STREAMS___13 = 174,
    _SC_2_PBS_CHECKPOINT___13 = 175,
    _SC_V6_ILP32_OFF32___13 = 176,
    _SC_V6_ILP32_OFFBIG___13 = 177,
    _SC_V6_LP64_OFF64___13 = 178,
    _SC_V6_LPBIG_OFFBIG___13 = 179,
    _SC_HOST_NAME_MAX___13 = 180,
    _SC_TRACE___13 = 181,
    _SC_TRACE_EVENT_FILTER___13 = 182,
    _SC_TRACE_INHERIT___13 = 183,
    _SC_TRACE_LOG___13 = 184,
    _SC_LEVEL1_ICACHE_SIZE___13 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___13 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___13 = 187,
    _SC_LEVEL1_DCACHE_SIZE___13 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___13 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___13 = 190,
    _SC_LEVEL2_CACHE_SIZE___13 = 191,
    _SC_LEVEL2_CACHE_ASSOC___13 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___13 = 193,
    _SC_LEVEL3_CACHE_SIZE___13 = 194,
    _SC_LEVEL3_CACHE_ASSOC___13 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___13 = 196,
    _SC_LEVEL4_CACHE_SIZE___13 = 197,
    _SC_LEVEL4_CACHE_ASSOC___13 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___13 = 199,
    _SC_IPV6___13 = 235,
    _SC_RAW_SOCKETS___13 = 236,
    _SC_V7_ILP32_OFF32___13 = 237,
    _SC_V7_ILP32_OFFBIG___13 = 238,
    _SC_V7_LP64_OFF64___13 = 239,
    _SC_V7_LPBIG_OFFBIG___13 = 240,
    _SC_SS_REPL_MAX___13 = 241,
    _SC_TRACE_EVENT_NAME_MAX___13 = 242,
    _SC_TRACE_NAME_MAX___13 = 243,
    _SC_TRACE_SYS_MAX___13 = 244,
    _SC_TRACE_USER_EVENT_MAX___13 = 245,
    _SC_XOPEN_STREAMS___13 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___13 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___13 = 248,
    _SC_MINSIGSTKSZ___13 = 249,
    _SC_SIGSTKSZ___13 = 250
} ;
#line 539
enum __anonenum__1124___2 {
    _CS_PATH___13 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___13 = 1,
    _CS_GNU_LIBC_VERSION___13 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___13 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___13 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___13 = 5,
    _CS_LFS_CFLAGS___13 = 1000,
    _CS_LFS_LDFLAGS___13 = 1001,
    _CS_LFS_LIBS___13 = 1002,
    _CS_LFS_LINTFLAGS___13 = 1003,
    _CS_LFS64_CFLAGS___13 = 1004,
    _CS_LFS64_LDFLAGS___13 = 1005,
    _CS_LFS64_LIBS___13 = 1006,
    _CS_LFS64_LINTFLAGS___13 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___13 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___13 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___13 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___13 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___13 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___13 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___13 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___13 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___13 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___13 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___13 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___13 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___13 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___13 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___13 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___13 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___13 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___13 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___13 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___13 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___13 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___13 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___13 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___13 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___13 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___13 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___13 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___13 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___13 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___13 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___13 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___13 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___13 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___13 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___13 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___13 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___13 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___13 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___13 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___13 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___13 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___13 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___13 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___13 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___13 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___13 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___13 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___13 = 1147,
    _CS_V6_ENV___13 = 1148,
    _CS_V7_ENV___13 = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__1125___2 {
    SS_ONSTACK___17 = 1,
    SS_DISABLE___17 = 2
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__1133___2 {
    DT_UNKNOWN___16 = 0,
    DT_FIFO___16 = 1,
    DT_CHR___16 = 2,
    DT_DIR___16 = 4,
    DT_BLK___16 = 6,
    DT_REG___16 = 8,
    DT_LNK___16 = 10,
    DT_SOCK___16 = 12,
    DT_WHT___16 = 14
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__1192___2 {
    PTHREAD_CREATE_JOINABLE___17 = 0,
    PTHREAD_CREATE_DETACHED___17 = 1
} ;
#line 47
enum __anonenum__1193___2 {
    PTHREAD_MUTEX_TIMED_NP___17 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___17 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___17 = 3,
    PTHREAD_MUTEX_NORMAL___17 = 0,
    PTHREAD_MUTEX_RECURSIVE___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK___17 = 2,
    PTHREAD_MUTEX_DEFAULT___17 = 0,
    PTHREAD_MUTEX_FAST_NP___12 = 0
} ;
#line 69
enum __anonenum__1194___2 {
    PTHREAD_MUTEX_STALLED___17 = 0,
    PTHREAD_MUTEX_STALLED_NP___17 = 0,
    PTHREAD_MUTEX_ROBUST___17 = 1,
    PTHREAD_MUTEX_ROBUST_NP___17 = 1
} ;
#line 81
enum __anonenum__1195___2 {
    PTHREAD_PRIO_NONE___17 = 0,
    PTHREAD_PRIO_INHERIT___17 = 1,
    PTHREAD_PRIO_PROTECT___17 = 2
} ;
#line 104
enum __anonenum__1196___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___17 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___17 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___17 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___17 = 0
} ;
#line 124
enum __anonenum__1197___2 {
    PTHREAD_INHERIT_SCHED___17 = 0,
    PTHREAD_EXPLICIT_SCHED___17 = 1
} ;
#line 134
enum __anonenum__1198___2 {
    PTHREAD_SCOPE_SYSTEM___17 = 0,
    PTHREAD_SCOPE_PROCESS___17 = 1
} ;
#line 144
enum __anonenum__1199___2 {
    PTHREAD_PROCESS_PRIVATE___17 = 0,
    PTHREAD_PROCESS_SHARED___17 = 1
} ;
#line 168
enum __anonenum__1200___2 {
    PTHREAD_CANCEL_ENABLE___17 = 0,
    PTHREAD_CANCEL_DISABLE___17 = 1
} ;
#line 175
enum __anonenum__1201___2 {
    PTHREAD_CANCEL_DEFERRED___17 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___17 = 1
} ;
#line 58 "/usr/include/glib-2.0/gmodule.h"
enum __anonstruct_1619 {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3
} ;
#line 63 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonstruct_1619 GModuleFlags;
#line 65
struct _GModule ;
#line 65 "/usr/include/glib-2.0/gmodule.h"
typedef struct _GModule GModule;
#line 66 "/usr/include/glib-2.0/gmodule.h"
typedef gchar *(*GModuleCheckInit)(GModule * );
#line 67 "/usr/include/glib-2.0/gmodule.h"
typedef void (*GModuleUnload)(GModule * );
#line 82
enum __anonenum__1658 {
    G_MODULE_ERROR_FAILED = 0,
    G_MODULE_ERROR_CHECK_FAILED = 1
} ;
#line 86 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonenum__1658 GModuleError;
#line 53 "/usr/include/glib-2.0/glib/gstdio.h"
typedef struct stat GStatBuf;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__1663 {
    MSG_OOB___12 = 1,
    MSG_PEEK___12 = 2,
    MSG_DONTROUTE___12 = 4,
    MSG_TRYHARD___12 = 4,
    MSG_CTRUNC___12 = 8,
    MSG_PROXY___12 = 16,
    MSG_TRUNC___12 = 32,
    MSG_DONTWAIT___12 = 64,
    MSG_EOR___12 = 128,
    MSG_WAITALL___12 = 256,
    MSG_FIN___12 = 512,
    MSG_SYN___12 = 1024,
    MSG_CONFIRM___12 = 2048,
    MSG_RST___12 = 4096,
    MSG_ERRQUEUE___12 = 8192,
    MSG_NOSIGNAL___12 = 16384,
    MSG_MORE___12 = 32768,
    MSG_WAITFORONE___12 = 65536,
    MSG_BATCH___12 = 262144,
    MSG_ZEROCOPY___12 = 67108864,
    MSG_FASTOPEN___12 = 536870912,
    MSG_CMSG_CLOEXEC___12 = 1073741824
} ;
#line 334
enum __anonenum__1664 {
    SCM_RIGHTS___12 = 1,
    SCM_CREDENTIALS___12 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__1665 {
    SHUT_RD___12 = 0,
    SHUT_WR___12 = 1,
    SHUT_RDWR___12 = 2
} ;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__1668 {
    IPPROTO_IP___12 = 0,
    IPPROTO_ICMP___12 = 1,
    IPPROTO_IGMP___12 = 2,
    IPPROTO_IPIP___12 = 4,
    IPPROTO_TCP___12 = 6,
    IPPROTO_EGP___12 = 8,
    IPPROTO_PUP___12 = 12,
    IPPROTO_UDP___12 = 17,
    IPPROTO_IDP___12 = 22,
    IPPROTO_TP___12 = 29,
    IPPROTO_DCCP___12 = 33,
    IPPROTO_IPV6___12 = 41,
    IPPROTO_RSVP___12 = 46,
    IPPROTO_GRE___12 = 47,
    IPPROTO_ESP___12 = 50,
    IPPROTO_AH___12 = 51,
    IPPROTO_MTP___12 = 92,
    IPPROTO_BEETPH___12 = 94,
    IPPROTO_ENCAP___12 = 98,
    IPPROTO_PIM___12 = 103,
    IPPROTO_COMP___12 = 108,
    IPPROTO_SCTP___12 = 132,
    IPPROTO_UDPLITE___12 = 136,
    IPPROTO_MPLS___12 = 137,
    IPPROTO_ETHERNET___12 = 143,
    IPPROTO_RAW___12 = 255,
    IPPROTO_MPTCP___12 = 262,
    IPPROTO_MAX___12 = 263
} ;
#line 103
enum __anonenum__1669 {
    IPPROTO_HOPOPTS___12 = 0,
    IPPROTO_ROUTING___12 = 43,
    IPPROTO_FRAGMENT___12 = 44,
    IPPROTO_ICMPV6___12 = 58,
    IPPROTO_NONE___12 = 59,
    IPPROTO_DSTOPTS___12 = 60,
    IPPROTO_MH___12 = 135
} ;
#line 126
enum __anonenum__1670 {
    IPPORT_ECHO___12 = 7,
    IPPORT_DISCARD___12 = 9,
    IPPORT_SYSTAT___12 = 11,
    IPPORT_DAYTIME___12 = 13,
    IPPORT_NETSTAT___12 = 15,
    IPPORT_FTP___12 = 21,
    IPPORT_TELNET___12 = 23,
    IPPORT_SMTP___12 = 25,
    IPPORT_TIMESERVER___12 = 37,
    IPPORT_NAMESERVER___12 = 42,
    IPPORT_WHOIS___12 = 43,
    IPPORT_MTP___12 = 57,
    IPPORT_TFTP___12 = 69,
    IPPORT_RJE___12 = 77,
    IPPORT_FINGER___12 = 79,
    IPPORT_TTYLINK___12 = 87,
    IPPORT_SUPDUP___12 = 95,
    IPPORT_EXECSERVER___12 = 512,
    IPPORT_LOGINSERVER___12 = 513,
    IPPORT_CMDSERVER___12 = 514,
    IPPORT_EFSSERVER___12 = 520,
    IPPORT_BIFFUDP___12 = 512,
    IPPORT_WHOSERVER___12 = 513,
    IPPORT_ROUTESERVER___12 = 520,
    IPPORT_RESERVED___12 = 1024,
    IPPORT_USERRESERVED___12 = 5000
} ;
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 576 "/usr/include/sndfile.h"
SNDFILE *sf_open(char const   *path , int mode , SF_INFO *sfinfo ) ;
#line 591
SNDFILE *sf_open_fd(int fd , int mode , SF_INFO *sfinfo , int close_desc ) ;
#line 593
SNDFILE *sf_open_virtual(SF_VIRTUAL_IO *sfvirtual , int mode , SF_INFO *sfinfo , void *user_data ) ;
#line 600
int sf_error(SNDFILE *sndfile ) ;
#line 607
char const   *sf_strerror(SNDFILE *sndfile ) ;
#line 615
char const   *sf_error_number(int errnum ) ;
#line 623
int sf_perror(SNDFILE *sndfile ) ;
#line 624
int sf_error_str(SNDFILE *sndfile , char *str , size_t len ) ;
#line 631
int sf_command(SNDFILE *sndfile , int command , void *data , int datasize ) ;
#line 636
int sf_format_check(SF_INFO *info ) ;
#line 657
sf_count_t sf_seek(SNDFILE *sndfile , sf_count_t frames , int whence ) ;
#line 668
int sf_set_string(SNDFILE *sndfile , int str_type , char const   *str ) ;
#line 670
char const   *sf_get_string(SNDFILE *sndfile , int str_type ) ;
#line 675
char const   *sf_version_string(void) ;
#line 688
int sf_current_byterate(SNDFILE *sndfile ) ;
#line 693
sf_count_t sf_read_raw(SNDFILE *sndfile , void *ptr , sf_count_t bytes ) ;
#line 694
sf_count_t sf_write_raw(SNDFILE *sndfile , void const   *ptr , sf_count_t bytes ) ;
#line 707
sf_count_t sf_readf_short(SNDFILE *sndfile , short *ptr , sf_count_t frames ) ;
#line 708
sf_count_t sf_writef_short(SNDFILE *sndfile , short const   *ptr , sf_count_t frames ) ;
#line 710
sf_count_t sf_readf_int(SNDFILE *sndfile , int *ptr , sf_count_t frames ) ;
#line 711
sf_count_t sf_writef_int(SNDFILE *sndfile , int const   *ptr , sf_count_t frames ) ;
#line 713
sf_count_t sf_readf_float(SNDFILE *sndfile , float *ptr , sf_count_t frames ) ;
#line 714
sf_count_t sf_writef_float(SNDFILE *sndfile , float const   *ptr , sf_count_t frames ) ;
#line 716
sf_count_t sf_readf_double(SNDFILE *sndfile , double *ptr , sf_count_t frames ) ;
#line 717
sf_count_t sf_writef_double(SNDFILE *sndfile , double const   *ptr , sf_count_t frames ) ;
#line 725
sf_count_t sf_read_short(SNDFILE *sndfile , short *ptr , sf_count_t items ) ;
#line 726
sf_count_t sf_write_short(SNDFILE *sndfile , short const   *ptr , sf_count_t items ) ;
#line 728
sf_count_t sf_read_int(SNDFILE *sndfile , int *ptr , sf_count_t items ) ;
#line 729
sf_count_t sf_write_int(SNDFILE *sndfile , int const   *ptr , sf_count_t items ) ;
#line 731
sf_count_t sf_read_float(SNDFILE *sndfile , float *ptr , sf_count_t items ) ;
#line 732
sf_count_t sf_write_float(SNDFILE *sndfile , float const   *ptr , sf_count_t items ) ;
#line 734
sf_count_t sf_read_double(SNDFILE *sndfile , double *ptr , sf_count_t items ) ;
#line 735
sf_count_t sf_write_double(SNDFILE *sndfile , double const   *ptr , sf_count_t items ) ;
#line 743
int sf_close(SNDFILE *sndfile ) ;
#line 751
void sf_write_sync(SNDFILE *sndfile ) ;
#line 798
int sf_set_chunk(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 822
SF_CHUNK_ITERATOR *sf_get_chunk_iterator(SNDFILE *sndfile , SF_CHUNK_INFO *chunk_info ) ;
#line 836
SF_CHUNK_ITERATOR *sf_next_chunk_iterator(SF_CHUNK_ITERATOR *iterator ) ;
#line 851
int sf_get_chunk_size(SF_CHUNK_ITERATOR *it , SF_CHUNK_INFO *chunk_info ) ;
#line 865
int sf_get_chunk_data(SF_CHUNK_ITERATOR *it , SF_CHUNK_INFO *chunk_info ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 432
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 70 "/usr/include/glib-2.0/glib/garray.h"
extern GArray *g_array_new(gboolean zero_terminated , gboolean clear_ , guint element_size ) ;
#line 74
extern gpointer g_array_steal(GArray *array , gsize *len ) ;
#line 77
extern GArray *g_array_sized_new(gboolean zero_terminated , gboolean clear_ , guint element_size ,
                                 guint reserved_size ) ;
#line 82
extern GArray *g_array_copy(GArray *array ) ;
#line 84
extern gchar *g_array_free(GArray *array , gboolean free_segment ) ;
#line 87
extern GArray *g_array_ref(GArray *array ) ;
#line 89
extern void g_array_unref(GArray *array ) ;
#line 91
extern guint g_array_get_element_size(GArray *array ) ;
#line 93
extern GArray *g_array_append_vals(GArray *array , gconstpointer data , guint len ) ;
#line 97
extern GArray *g_array_prepend_vals(GArray *array , gconstpointer data , guint len ) ;
#line 101
extern GArray *g_array_insert_vals(GArray *array , guint index_ , gconstpointer data ,
                                   guint len ) ;
#line 106
extern GArray *g_array_set_size(GArray *array , guint length ) ;
#line 109
extern GArray *g_array_remove_index(GArray *array , guint index_ ) ;
#line 112
extern GArray *g_array_remove_index_fast(GArray *array , guint index_ ) ;
#line 115
extern GArray *g_array_remove_range(GArray *array , guint index_ , guint length ) ;
#line 119
extern void g_array_sort(GArray *array , GCompareFunc compare_func ) ;
#line 122
extern void g_array_sort_with_data(GArray *array , GCompareDataFunc compare_func ,
                                   gpointer user_data ) ;
#line 126
extern gboolean g_array_binary_search(GArray *array , gconstpointer target , GCompareFunc compare_func ,
                                      guint *out_match_index ) ;
#line 131
extern void g_array_set_clear_func(GArray *array , GDestroyNotify clear_func ) ;
#line 140
extern GPtrArray *g_ptr_array_new(void) ;
#line 142
extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func ) ;
#line 144
extern gpointer *g_ptr_array_steal(GPtrArray *array , gsize *len ) ;
#line 147
extern GPtrArray *g_ptr_array_copy(GPtrArray *array , GCopyFunc func , gpointer user_data ) ;
#line 151
extern GPtrArray *g_ptr_array_sized_new(guint reserved_size ) ;
#line 153
extern GPtrArray *g_ptr_array_new_full(guint reserved_size , GDestroyNotify element_free_func ) ;
#line 156
extern gpointer *g_ptr_array_free(GPtrArray *array , gboolean free_seg ) ;
#line 159
extern GPtrArray *g_ptr_array_ref(GPtrArray *array ) ;
#line 161
extern void g_ptr_array_unref(GPtrArray *array ) ;
#line 163
extern void g_ptr_array_set_free_func(GPtrArray *array , GDestroyNotify element_free_func ) ;
#line 166
extern void g_ptr_array_set_size(GPtrArray *array , gint length ) ;
#line 169
extern gpointer g_ptr_array_remove_index(GPtrArray *array , guint index_ ) ;
#line 172
extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array , guint index_ ) ;
#line 175
extern gpointer g_ptr_array_steal_index(GPtrArray *array , guint index_ ) ;
#line 178
extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array , guint index_ ) ;
#line 181
extern gboolean g_ptr_array_remove(GPtrArray *array , gpointer data ) ;
#line 184
extern gboolean g_ptr_array_remove_fast(GPtrArray *array , gpointer data ) ;
#line 187
extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array , guint index_ , guint length ) ;
#line 191
extern void g_ptr_array_add(GPtrArray *array , gpointer data ) ;
#line 194
extern void g_ptr_array_extend(GPtrArray *array_to_extend , GPtrArray *array , GCopyFunc func ,
                               gpointer user_data ) ;
#line 199
extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend , GPtrArray *array ) ;
#line 202
extern void g_ptr_array_insert(GPtrArray *array , gint index_ , gpointer data ) ;
#line 206
extern void g_ptr_array_sort(GPtrArray *array , GCompareFunc compare_func ) ;
#line 209
extern void g_ptr_array_sort_with_data(GPtrArray *array , GCompareDataFunc compare_func ,
                                       gpointer user_data ) ;
#line 213
extern void g_ptr_array_foreach(GPtrArray *array , GFunc func , gpointer user_data ) ;
#line 217
extern gboolean g_ptr_array_find(GPtrArray *haystack , gconstpointer needle , guint *index_ ) ;
#line 221
extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack , gconstpointer needle ,
                                                 GEqualFunc equal_func , guint *index_ ) ;
#line 232
extern GByteArray *g_byte_array_new(void) ;
#line 234
extern GByteArray *g_byte_array_new_take(guint8 *data , gsize len ) ;
#line 237
extern guint8 *g_byte_array_steal(GByteArray *array , gsize *len ) ;
#line 240
extern GByteArray *g_byte_array_sized_new(guint reserved_size ) ;
#line 242
extern guint8 *g_byte_array_free(GByteArray *array , gboolean free_segment ) ;
#line 245
extern GBytes *g_byte_array_free_to_bytes(GByteArray *array ) ;
#line 247
extern GByteArray *g_byte_array_ref(GByteArray *array ) ;
#line 249
extern void g_byte_array_unref(GByteArray *array ) ;
#line 251
extern GByteArray *g_byte_array_append(GByteArray *array , guint8 *data , guint len ) ;
#line 255
extern GByteArray *g_byte_array_prepend(GByteArray *array , guint8 *data , guint len ) ;
#line 259
extern GByteArray *g_byte_array_set_size(GByteArray *array , guint length ) ;
#line 262
extern GByteArray *g_byte_array_remove_index(GByteArray *array , guint index_ ) ;
#line 265
extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array , guint index_ ) ;
#line 268
extern GByteArray *g_byte_array_remove_range(GByteArray *array , guint index_ , guint length ) ;
#line 272
extern void g_byte_array_sort(GByteArray *array , GCompareFunc compare_func ) ;
#line 275
extern void g_byte_array_sort_with_data(GByteArray *array , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 33 "/usr/include/glib-2.0/glib/gatomic.h"
extern gint g_atomic_int_get(gint *atomic ) ;
#line 35
extern void g_atomic_int_set(gint *atomic , gint newval ) ;
#line 38
extern void g_atomic_int_inc(gint *atomic ) ;
#line 40
extern gboolean g_atomic_int_dec_and_test(gint *atomic ) ;
#line 42
extern gboolean g_atomic_int_compare_and_exchange(gint *atomic , gint oldval , gint newval ) ;
#line 46
extern gint g_atomic_int_add(gint *atomic , gint val ) ;
#line 49
extern guint g_atomic_int_and(guint *atomic , guint val ) ;
#line 52
extern guint g_atomic_int_or(guint *atomic , guint val ) ;
#line 55
extern guint g_atomic_int_xor(guint *atomic , guint val ) ;
#line 59
extern gpointer g_atomic_pointer_get(void const   *atomic ) ;
#line 61
extern void g_atomic_pointer_set(void *atomic , gpointer newval ) ;
#line 64
extern gboolean g_atomic_pointer_compare_and_exchange(void *atomic , gpointer oldval ,
                                                      gpointer newval ) ;
#line 68
extern gssize g_atomic_pointer_add(void *atomic , gssize val ) ;
#line 71
extern gsize g_atomic_pointer_and(void *atomic , gsize val ) ;
#line 74
extern gsize g_atomic_pointer_or(void *atomic , gsize val ) ;
#line 77
extern gsize g_atomic_pointer_xor(void *atomic , gsize val ) ;
#line 81
extern gint g_atomic_int_exchange_and_add(gint *atomic , gint val ) ;
#line 41 "/usr/include/glib-2.0/glib/gquark.h"
extern GQuark g_quark_try_string(gchar *string ) ;
#line 43
extern GQuark g_quark_from_static_string(gchar *string ) ;
#line 45
extern GQuark g_quark_from_string(gchar *string ) ;
#line 47
extern gchar *g_quark_to_string(GQuark quark ) ;
#line 62
extern gchar *g_intern_string(gchar *string ) ;
#line 64
extern gchar *g_intern_static_string(gchar *string ) ;
#line 176 "/usr/include/glib-2.0/glib/gerror.h"
extern GQuark g_error_domain_register_static(char const   *error_type_name , gsize error_type_private_size ,
                                             GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                             GErrorClearFunc error_type_clear ) ;
#line 183
extern GQuark g_error_domain_register(char const   *error_type_name , gsize error_type_private_size ,
                                      GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                      GErrorClearFunc error_type_clear ) ;
#line 190
extern GError *g_error_new(GQuark domain , gint code , gchar *format  , ...) ;
#line 196
extern GError *g_error_new_literal(GQuark domain , gint code , gchar *message ) ;
#line 200
extern GError *g_error_new_valist(GQuark domain , gint code , gchar *format , va_list args ) ;
#line 206
extern void g_error_free(GError *error ) ;
#line 208
extern GError *g_error_copy(GError *error ) ;
#line 211
extern gboolean g_error_matches(GError *error , GQuark domain , gint code ) ;
#line 219
extern void g_set_error(GError **err , GQuark domain , gint code , gchar *format 
                        , ...) ;
#line 226
extern void g_set_error_literal(GError **err , GQuark domain , gint code , gchar *message ) ;
#line 234
extern void g_propagate_error(GError **dest , GError *src ) ;
#line 239
extern void g_clear_error(GError **err ) ;
#line 243
extern void g_prefix_error(GError **err , gchar *format  , ...) ;
#line 249
extern void g_prefix_error_literal(GError **err , gchar *prefix ) ;
#line 254
extern void g_propagate_prefixed_error(GError **dest , GError *src , gchar *format 
                                       , ...) ;
#line 51 "/usr/include/glib-2.0/glib/gutils.h"
extern gchar *g_get_user_name(void) ;
#line 53
extern gchar *g_get_real_name(void) ;
#line 55
extern gchar *g_get_home_dir(void) ;
#line 57
extern gchar *g_get_tmp_dir(void) ;
#line 59
extern gchar *g_get_host_name(void) ;
#line 61
extern gchar *g_get_prgname(void) ;
#line 63
extern void g_set_prgname(gchar *prgname ) ;
#line 65
extern gchar *g_get_application_name(void) ;
#line 67
extern void g_set_application_name(gchar *application_name ) ;
#line 69
extern gchar *g_get_os_info(gchar *key_name ) ;
#line 193
extern void g_reload_user_special_dirs_cache(void) ;
#line 195
extern gchar *g_get_user_data_dir(void) ;
#line 197
extern gchar *g_get_user_config_dir(void) ;
#line 199
extern gchar *g_get_user_cache_dir(void) ;
#line 201
extern gchar *g_get_user_state_dir(void) ;
#line 203
extern gchar * const  *g_get_system_data_dirs(void) ;
#line 225
extern gchar * const  *g_get_system_config_dirs(void) ;
#line 228
extern gchar *g_get_user_runtime_dir(void) ;
#line 266
extern gchar *g_get_user_special_dir(GUserDirectory directory ) ;
#line 286
extern guint g_parse_debug_string(gchar *string , GDebugKey *keys , guint nkeys ) ;
#line 291
extern gint g_snprintf(gchar *string , gulong n , gchar *format  , ...) ;
#line 296
extern gint g_vsnprintf(gchar *string , gulong n , gchar *format , va_list args ) ;
#line 303
extern void g_nullify_pointer(gpointer *nullify_location ) ;
#line 314
extern gchar *g_format_size_full(guint64 size , GFormatSizeFlags flags ) ;
#line 317
extern gchar *g_format_size(guint64 size ) ;
#line 320
extern gchar *g_format_size_for_display(goffset size ) ;
#line 338
extern void g_atexit(GVoidFunc func ) ;
#line 357
extern gchar *g_find_program_in_path(gchar *program ) ;
#line 375
extern gint g_bit_nth_lsf(gulong mask , gint nth_bit ) ;
#line 378
extern gint g_bit_nth_msf(gulong mask , gint nth_bit ) ;
#line 381
extern guint g_bit_storage(gulong number ) ;
#line 384 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_lsf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 387
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 387
  if (__cil_tmp3) {
#line 388
    nth_bit = - 1;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (nth_bit < 63)) {
#line 389
      goto while_break;
    }
#line 391
    nth_bit ++;
#line 392
    if (mask & (1UL << nth_bit)) {
#line 393
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (- 1);
}
}
#line 399 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_msf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 402
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 402
  if (nth_bit < 0) {
#line 403
    nth_bit = 64;
  } else
#line 402
  if (__cil_tmp3) {
#line 403
    nth_bit = 64;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (nth_bit > 0)) {
#line 404
      goto while_break;
    }
#line 406
    __cil_tmp4 = nth_bit;
#line 406
    nth_bit --;
#line 407
    if (mask & (1UL << nth_bit)) {
#line 408
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (- 1);
}
}
#line 414 "/usr/include/glib-2.0/glib/gutils.h"
__inline static guint g_bit_storage_impl(gulong number ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  unsigned int tmp ;

  {
  {
#line 417
  __cil_tmp2 = __builtin_expect((long )0, (long )1);
  }
#line 417
  if (__cil_tmp2) {
    {
#line 417
    __cil_tmp3 = __builtin_clzl(number);
#line 417
    tmp = (63U ^ (guint )__cil_tmp3) + 1U;
    }
  } else {
#line 417
    tmp = (unsigned int )1;
  }
#line 417
  return (tmp);
}
}
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 402
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 791
extern int system(char const   *__command ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 45
  __cil_tmp7 = __builtin_constant_p(4096UL <= sz / sizeof(char ));
  }
  {
#line 45
  __cil_tmp6 = __builtin_constant_p(4096);
  }
#line 45
  if (__cil_tmp6) {
#line 45
    if (__cil_tmp7) {
#line 45
      if (! (4096UL <= sz / sizeof(char ))) {
        {
#line 46
        __cil_tmp8 = __realpath_chk_warn(__name, __resolved, sz);
        }
#line 46
        return (__cil_tmp8);
      }
    }
  }
  {
#line 48
  __cil_tmp9 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 40 "/usr/include/glib-2.0/glib/gthread.h"
extern GQuark g_thread_error_quark(void) ;
#line 141
extern GThread *g_thread_ref(GThread *thread ) ;
#line 143
extern void g_thread_unref(GThread *thread ) ;
#line 145
extern GThread *g_thread_new(gchar *name , GThreadFunc func , gpointer data ) ;
#line 149
extern GThread *g_thread_try_new(gchar *name , GThreadFunc func , gpointer data ,
                                 GError **error ) ;
#line 154
extern GThread *g_thread_self(void) ;
#line 156
extern void g_thread_exit(gpointer retval ) ;
#line 158
extern gpointer g_thread_join(GThread *thread ) ;
#line 160
extern void g_thread_yield(void) ;
#line 164
extern void g_mutex_init(GMutex *mutex ) ;
#line 166
extern void g_mutex_clear(GMutex *mutex ) ;
#line 168
extern void g_mutex_lock(GMutex *mutex ) ;
#line 170
extern gboolean g_mutex_trylock(GMutex *mutex ) ;
#line 172
extern void g_mutex_unlock(GMutex *mutex ) ;
#line 175
extern void g_rw_lock_init(GRWLock *rw_lock ) ;
#line 177
extern void g_rw_lock_clear(GRWLock *rw_lock ) ;
#line 179
extern void g_rw_lock_writer_lock(GRWLock *rw_lock ) ;
#line 181
extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock ) ;
#line 183
extern void g_rw_lock_writer_unlock(GRWLock *rw_lock ) ;
#line 185
extern void g_rw_lock_reader_lock(GRWLock *rw_lock ) ;
#line 187
extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock ) ;
#line 189
extern void g_rw_lock_reader_unlock(GRWLock *rw_lock ) ;
#line 192
extern void g_rec_mutex_init(GRecMutex *rec_mutex ) ;
#line 194
extern void g_rec_mutex_clear(GRecMutex *rec_mutex ) ;
#line 196
extern void g_rec_mutex_lock(GRecMutex *rec_mutex ) ;
#line 198
extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex ) ;
#line 200
extern void g_rec_mutex_unlock(GRecMutex *rec_mutex ) ;
#line 203
extern void g_cond_init(GCond *cond ) ;
#line 205
extern void g_cond_clear(GCond *cond ) ;
#line 207
extern void g_cond_wait(GCond *cond , GMutex *mutex ) ;
#line 210
extern void g_cond_signal(GCond *cond ) ;
#line 212
extern void g_cond_broadcast(GCond *cond ) ;
#line 214
extern gboolean g_cond_wait_until(GCond *cond , GMutex *mutex , gint64 end_time ) ;
#line 219
extern gpointer g_private_get(GPrivate *key ) ;
#line 221
extern void g_private_set(GPrivate *key , gpointer value ) ;
#line 224
extern void g_private_replace(GPrivate *key , gpointer value ) ;
#line 228
extern gpointer g_once_impl(GOnce *once , GThreadFunc func , gpointer arg ) ;
#line 232
extern gboolean g_once_init_enter(void *location ) ;
#line 234
extern void g_once_init_leave(void *location , gsize result ) ;
#line 277
extern guint g_get_num_processors(void) ;
#line 331 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GMutexLocker *g_mutex_locker_new(GMutex *mutex ) 
{ 


  {
  {
#line 333
  g_mutex_lock(mutex);
  }
#line 334
  return ((GMutexLocker *)mutex);
}
}
#line 349 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_mutex_locker_free(GMutexLocker *locker ) 
{ 


  {
  {
#line 351
  g_mutex_unlock((GMutex *)locker);
  }
  return;
}
}
#line 407 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRecMutexLocker *g_rec_mutex_locker_new(GRecMutex *rec_mutex ) 
{ 


  {
  {
#line 409
  g_rec_mutex_lock(rec_mutex);
  }
#line 410
  return ((GRecMutexLocker *)rec_mutex);
}
}
#line 427 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rec_mutex_locker_free(GRecMutexLocker *locker ) 
{ 


  {
  {
#line 429
  g_rec_mutex_unlock((GRecMutex *)locker);
  }
  return;
}
}
#line 517 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockWriterLocker *g_rw_lock_writer_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 519
  g_rw_lock_writer_lock(rw_lock);
  }
#line 520
  return ((GRWLockWriterLocker *)rw_lock);
}
}
#line 538 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_writer_locker_free(GRWLockWriterLocker *locker ) 
{ 


  {
  {
#line 540
  g_rw_lock_writer_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 572 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockReaderLocker *g_rw_lock_reader_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 574
  g_rw_lock_reader_lock(rw_lock);
  }
#line 575
  return ((GRWLockReaderLocker *)rw_lock);
}
}
#line 593 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_reader_locker_free(GRWLockReaderLocker *locker ) 
{ 


  {
  {
#line 595
  g_rw_lock_reader_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/glib/gasyncqueue.h"
extern GAsyncQueue *g_async_queue_new(void) ;
#line 41
extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func ) ;
#line 43
extern void g_async_queue_lock(GAsyncQueue *queue ) ;
#line 45
extern void g_async_queue_unlock(GAsyncQueue *queue ) ;
#line 47
extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue ) ;
#line 49
extern void g_async_queue_unref(GAsyncQueue *queue ) ;
#line 52
extern void g_async_queue_ref_unlocked(GAsyncQueue *queue ) ;
#line 55
extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue ) ;
#line 58
extern void g_async_queue_push(GAsyncQueue *queue , gpointer data ) ;
#line 61
extern void g_async_queue_push_unlocked(GAsyncQueue *queue , gpointer data ) ;
#line 64
extern void g_async_queue_push_sorted(GAsyncQueue *queue , gpointer data , GCompareDataFunc func ,
                                      gpointer user_data ) ;
#line 69
extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue , gpointer data ,
                                               GCompareDataFunc func , gpointer user_data ) ;
#line 74
extern gpointer g_async_queue_pop(GAsyncQueue *queue ) ;
#line 76
extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue ) ;
#line 78
extern gpointer g_async_queue_try_pop(GAsyncQueue *queue ) ;
#line 80
extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue ) ;
#line 82
extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue , guint64 timeout ) ;
#line 85
extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue , guint64 timeout ) ;
#line 88
extern gint g_async_queue_length(GAsyncQueue *queue ) ;
#line 90
extern gint g_async_queue_length_unlocked(GAsyncQueue *queue ) ;
#line 92
extern void g_async_queue_sort(GAsyncQueue *queue , GCompareDataFunc func , gpointer user_data ) ;
#line 96
extern void g_async_queue_sort_unlocked(GAsyncQueue *queue , GCompareDataFunc func ,
                                        gpointer user_data ) ;
#line 101
extern gboolean g_async_queue_remove(GAsyncQueue *queue , gpointer item ) ;
#line 104
extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 107
extern void g_async_queue_push_front(GAsyncQueue *queue , gpointer item ) ;
#line 110
extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 115
extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 118
extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 333
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 41 "/usr/include/glib-2.0/glib/gbacktrace.h"
extern void g_on_error_query(gchar *prg_name ) ;
#line 43
extern void g_on_error_stack_trace(gchar *prg_name ) ;
#line 31 "/usr/include/glib-2.0/glib/gbase64.h"
extern gsize g_base64_encode_step(guchar *in , gsize len , gboolean break_lines ,
                                  gchar *out , gint *state , gint *save ) ;
#line 38
extern gsize g_base64_encode_close(gboolean break_lines , gchar *out , gint *state ,
                                   gint *save ) ;
#line 43
extern gchar *g_base64_encode(guchar *data , gsize len ) ;
#line 46
extern gsize g_base64_decode_step(gchar *in , gsize len , guchar *out , gint *state ,
                                  guint *save ) ;
#line 52
extern guchar *g_base64_decode(gchar *text , gsize *out_len ) ;
#line 55
extern guchar *g_base64_decode_inplace(gchar *text , gsize *out_len ) ;
#line 33 "/usr/include/glib-2.0/glib/gbitlock.h"
extern void g_bit_lock(gint *address , gint lock_bit ) ;
#line 36
extern gboolean g_bit_trylock(gint *address , gint lock_bit ) ;
#line 39
extern void g_bit_unlock(gint *address , gint lock_bit ) ;
#line 43
extern void g_pointer_bit_lock(void *address , gint lock_bit ) ;
#line 46
extern gboolean g_pointer_bit_trylock(void *address , gint lock_bit ) ;
#line 49
extern void g_pointer_bit_unlock(void *address , gint lock_bit ) ;
#line 57 "/usr/include/glib-2.0/glib/gtimezone.h"
extern GTimeZone *g_time_zone_new(gchar *identifier ) ;
#line 59
extern GTimeZone *g_time_zone_new_identifier(gchar *identifier ) ;
#line 61
extern GTimeZone *g_time_zone_new_utc(void) ;
#line 63
extern GTimeZone *g_time_zone_new_local(void) ;
#line 65
extern GTimeZone *g_time_zone_new_offset(gint32 seconds ) ;
#line 68
extern GTimeZone *g_time_zone_ref(GTimeZone *tz ) ;
#line 70
extern void g_time_zone_unref(GTimeZone *tz ) ;
#line 73
extern gint g_time_zone_find_interval(GTimeZone *tz , GTimeType type , gint64 time_ ) ;
#line 78
extern gint g_time_zone_adjust_time(GTimeZone *tz , GTimeType type , gint64 *time_ ) ;
#line 83
extern gchar *g_time_zone_get_abbreviation(GTimeZone *tz , gint interval ) ;
#line 86
extern gint32 g_time_zone_get_offset(GTimeZone *tz , gint interval ) ;
#line 89
extern gboolean g_time_zone_is_dst(GTimeZone *tz , gint interval ) ;
#line 92
extern gchar *g_time_zone_get_identifier(GTimeZone *tz ) ;
#line 99 "/usr/include/glib-2.0/glib/gdatetime.h"
extern void g_date_time_unref(GDateTime *datetime ) ;
#line 101
extern GDateTime *g_date_time_ref(GDateTime *datetime ) ;
#line 104
extern GDateTime *g_date_time_new_now(GTimeZone *tz ) ;
#line 106
extern GDateTime *g_date_time_new_now_local(void) ;
#line 108
extern GDateTime *g_date_time_new_now_utc(void) ;
#line 111
extern GDateTime *g_date_time_new_from_unix_local(gint64 t ) ;
#line 113
extern GDateTime *g_date_time_new_from_unix_utc(gint64 t ) ;
#line 117
extern GDateTime *g_date_time_new_from_timeval_local(GTimeVal *tv ) ;
#line 119
extern GDateTime *g_date_time_new_from_timeval_utc(GTimeVal *tv ) ;
#line 123
extern GDateTime *g_date_time_new_from_iso8601(gchar *text , GTimeZone *default_tz ) ;
#line 127
extern GDateTime *g_date_time_new(GTimeZone *tz , gint year , gint month , gint day ,
                                  gint hour , gint minute , gdouble seconds ) ;
#line 135
extern GDateTime *g_date_time_new_local(gint year , gint month , gint day , gint hour ,
                                        gint minute , gdouble seconds ) ;
#line 142
extern GDateTime *g_date_time_new_utc(gint year , gint month , gint day , gint hour ,
                                      gint minute , gdouble seconds ) ;
#line 151
extern GDateTime *g_date_time_add(GDateTime *datetime , GTimeSpan timespan ) ;
#line 156
extern GDateTime *g_date_time_add_years(GDateTime *datetime , gint years ) ;
#line 160
extern GDateTime *g_date_time_add_months(GDateTime *datetime , gint months ) ;
#line 164
extern GDateTime *g_date_time_add_weeks(GDateTime *datetime , gint weeks ) ;
#line 168
extern GDateTime *g_date_time_add_days(GDateTime *datetime , gint days ) ;
#line 173
extern GDateTime *g_date_time_add_hours(GDateTime *datetime , gint hours ) ;
#line 177
extern GDateTime *g_date_time_add_minutes(GDateTime *datetime , gint minutes ) ;
#line 181
extern GDateTime *g_date_time_add_seconds(GDateTime *datetime , gdouble seconds ) ;
#line 186
extern GDateTime *g_date_time_add_full(GDateTime *datetime , gint years , gint months ,
                                       gint days , gint hours , gint minutes , gdouble seconds ) ;
#line 195
extern gint g_date_time_compare(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 198
extern GTimeSpan g_date_time_difference(GDateTime *end , GDateTime *begin ) ;
#line 201
extern guint g_date_time_hash(gconstpointer datetime ) ;
#line 203
extern gboolean g_date_time_equal(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 207
extern void g_date_time_get_ymd(GDateTime *datetime , gint *year , gint *month , gint *day ) ;
#line 213
extern gint g_date_time_get_year(GDateTime *datetime ) ;
#line 215
extern gint g_date_time_get_month(GDateTime *datetime ) ;
#line 217
extern gint g_date_time_get_day_of_month(GDateTime *datetime ) ;
#line 220
extern gint g_date_time_get_week_numbering_year(GDateTime *datetime ) ;
#line 222
extern gint g_date_time_get_week_of_year(GDateTime *datetime ) ;
#line 224
extern gint g_date_time_get_day_of_week(GDateTime *datetime ) ;
#line 227
extern gint g_date_time_get_day_of_year(GDateTime *datetime ) ;
#line 230
extern gint g_date_time_get_hour(GDateTime *datetime ) ;
#line 232
extern gint g_date_time_get_minute(GDateTime *datetime ) ;
#line 234
extern gint g_date_time_get_second(GDateTime *datetime ) ;
#line 236
extern gint g_date_time_get_microsecond(GDateTime *datetime ) ;
#line 238
extern gdouble g_date_time_get_seconds(GDateTime *datetime ) ;
#line 241
extern gint64 g_date_time_to_unix(GDateTime *datetime ) ;
#line 244
extern gboolean g_date_time_to_timeval(GDateTime *datetime , GTimeVal *tv ) ;
#line 249
extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime ) ;
#line 251
extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime ) ;
#line 253
extern gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime ) ;
#line 255
extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime ) ;
#line 258
extern GDateTime *g_date_time_to_timezone(GDateTime *datetime , GTimeZone *tz ) ;
#line 261
extern GDateTime *g_date_time_to_local(GDateTime *datetime ) ;
#line 263
extern GDateTime *g_date_time_to_utc(GDateTime *datetime ) ;
#line 266
extern gchar *g_date_time_format(GDateTime *datetime , gchar *format ) ;
#line 269
extern gchar *g_date_time_format_iso8601(GDateTime *datetime ) ;
#line 71 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
extern GQuark g_bookmark_file_error_quark(void) ;
#line 81
extern GBookmarkFile *g_bookmark_file_new(void) ;
#line 83
extern void g_bookmark_file_free(GBookmarkFile *bookmark ) ;
#line 86
extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark , gchar *filename ,
                                               GError **error ) ;
#line 90
extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark , gchar *data ,
                                               gsize length , GError **error ) ;
#line 95
extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark , gchar *file ,
                                                    gchar **full_path , GError **error ) ;
#line 100
extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark , gsize *length , GError **error ) ;
#line 104
extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark , gchar *filename ,
                                        GError **error ) ;
#line 109
extern void g_bookmark_file_set_title(GBookmarkFile *bookmark , gchar *uri , gchar *title ) ;
#line 113
extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 117
extern void g_bookmark_file_set_description(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *description ) ;
#line 121
extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark , gchar *uri ,
                                              GError **error ) ;
#line 125
extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark , gchar *uri , gchar *mime_type ) ;
#line 129
extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 133
extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark , gchar *uri , gchar **groups ,
                                       gsize length ) ;
#line 138
extern void g_bookmark_file_add_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ) ;
#line 142
extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ,
                                          GError **error ) ;
#line 147
extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark , gchar *uri , gsize *length ,
                                          GError **error ) ;
#line 152
extern void g_bookmark_file_add_application(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *name , gchar *exec ) ;
#line 157
extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark , gchar *uri ,
                                                gchar *name , GError **error ) ;
#line 162
extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark , gchar *uri ,
                                                gsize *length , GError **error ) ;
#line 167
extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar *exec , gint count ,
                                             time_t stamp , GError **error ) ;
#line 175
extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char const   *exec ,
                                                     int count , GDateTime *stamp ,
                                                     GError **error ) ;
#line 183
extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar **exec , guint *count ,
                                             time_t *stamp , GError **error ) ;
#line 191
extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char **exec ,
                                                     unsigned int *count , GDateTime **stamp ,
                                                     GError **error ) ;
#line 199
extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                           gboolean is_private ) ;
#line 203
extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                               GError **error ) ;
#line 207
extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark , gchar *uri , gchar *href ,
                                     gchar *mime_type ) ;
#line 212
extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark , gchar *uri , gchar **href ,
                                         gchar **mime_type , GError **error ) ;
#line 218
extern void g_bookmark_file_set_added(GBookmarkFile *bookmark , gchar *uri , time_t added ) ;
#line 222
extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                GDateTime *added ) ;
#line 226
extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 230
extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                      GError **error ) ;
#line 234
extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark , gchar *uri , time_t modified ) ;
#line 238
extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                   GDateTime *modified ) ;
#line 242
extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark , gchar *uri ,
                                           GError **error ) ;
#line 246
extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark ,
                                                         char const   *uri , GError **error ) ;
#line 250
extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark , gchar *uri , time_t visited ) ;
#line 254
extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                  GDateTime *visited ) ;
#line 258
extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 262
extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark ,
                                                        char const   *uri , GError **error ) ;
#line 266
extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark , gchar *uri ) ;
#line 269
extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark ) ;
#line 271
extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark , gsize *length ) ;
#line 274
extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *group , GError **error ) ;
#line 279
extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark , gchar *uri ,
                                                   gchar *name , GError **error ) ;
#line 284
extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 288
extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark , gchar *old_uri ,
                                          gchar *new_uri , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gbytes.h"
extern GBytes *g_bytes_new(gconstpointer data , gsize size ) ;
#line 39
extern GBytes *g_bytes_new_take(gpointer data , gsize size ) ;
#line 43
extern GBytes *g_bytes_new_static(gconstpointer data , gsize size ) ;
#line 47
extern GBytes *g_bytes_new_with_free_func(gconstpointer data , gsize size , GDestroyNotify free_func ,
                                          gpointer user_data ) ;
#line 53
extern GBytes *g_bytes_new_from_bytes(GBytes *bytes , gsize offset , gsize length ) ;
#line 58
extern gconstpointer g_bytes_get_data(GBytes *bytes , gsize *size ) ;
#line 62
extern gsize g_bytes_get_size(GBytes *bytes ) ;
#line 65
extern GBytes *g_bytes_ref(GBytes *bytes ) ;
#line 68
extern void g_bytes_unref(GBytes *bytes ) ;
#line 71
extern gpointer g_bytes_unref_to_data(GBytes *bytes , gsize *size ) ;
#line 75
extern GByteArray *g_bytes_unref_to_array(GBytes *bytes ) ;
#line 78
extern guint g_bytes_hash(gconstpointer bytes ) ;
#line 81
extern gboolean g_bytes_equal(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 85
extern gint g_bytes_compare(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 89
extern gconstpointer g_bytes_get_region(GBytes *bytes , gsize element_size , gsize offset ,
                                        gsize n_elements ) ;
#line 31 "/usr/include/glib-2.0/glib/gcharset.h"
extern gboolean g_get_charset(char const   **charset ) ;
#line 33
extern gchar *g_get_codeset(void) ;
#line 35
extern gboolean g_get_console_charset(char const   **charset ) ;
#line 38
extern gchar * const  *g_get_language_names(void) ;
#line 40
extern gchar * const  *g_get_language_names_with_category(gchar *category_name ) ;
#line 43
extern gchar **g_get_locale_variants(gchar *locale ) ;
#line 68 "/usr/include/glib-2.0/glib/gchecksum.h"
extern gssize g_checksum_type_get_length(GChecksumType checksum_type ) ;
#line 71
extern GChecksum *g_checksum_new(GChecksumType checksum_type ) ;
#line 73
extern void g_checksum_reset(GChecksum *checksum ) ;
#line 75
extern GChecksum *g_checksum_copy(GChecksum *checksum ) ;
#line 77
extern void g_checksum_free(GChecksum *checksum ) ;
#line 79
extern void g_checksum_update(GChecksum *checksum , guchar *data , gssize length ) ;
#line 83
extern gchar *g_checksum_get_string(GChecksum *checksum ) ;
#line 85
extern void g_checksum_get_digest(GChecksum *checksum , guint8 *buffer , gsize *digest_len ) ;
#line 90
extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type , guchar *data ,
                                          gsize length ) ;
#line 94
extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type , gchar *str ,
                                            gssize length ) ;
#line 99
extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type , GBytes *data ) ;
#line 75 "/usr/include/glib-2.0/glib/gconvert.h"
extern GQuark g_convert_error_quark(void) ;
#line 86
extern GIConv g_iconv_open(gchar *to_codeset , gchar *from_codeset ) ;
#line 89
extern gsize g_iconv(GIConv converter , gchar **inbuf , gsize *inbytes_left , gchar **outbuf ,
                     gsize *outbytes_left ) ;
#line 95
extern gint g_iconv_close(GIConv converter ) ;
#line 99
extern gchar *g_convert(gchar *str , gssize len , gchar *to_codeset , gchar *from_codeset ,
                        gsize *bytes_read , gsize *bytes_written , GError **error ) ;
#line 107
extern gchar *g_convert_with_iconv(gchar *str , gssize len , GIConv converter , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 114
extern gchar *g_convert_with_fallback(gchar *str , gssize len , gchar *to_codeset ,
                                      gchar *from_codeset , gchar *fallback , gsize *bytes_read ,
                                      gsize *bytes_written , GError **error ) ;
#line 127
extern gchar *g_locale_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                               gsize *bytes_written , GError **error ) ;
#line 133
extern gchar *g_locale_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 143
extern gchar *g_filename_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 149
extern gchar *g_filename_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 156
extern gchar *g_filename_from_uri(gchar *uri , gchar **hostname , GError **error ) ;
#line 161
extern gchar *g_filename_to_uri(gchar *filename , gchar *hostname , GError **error ) ;
#line 165
extern gchar *g_filename_display_name(gchar *filename ) ;
#line 167
extern gboolean g_get_filename_charsets(gchar ***filename_charsets ) ;
#line 170
extern gchar *g_filename_display_basename(gchar *filename ) ;
#line 173
extern gchar **g_uri_list_extract_uris(gchar *uri_list ) ;
#line 45 "/usr/include/glib-2.0/glib/gdataset.h"
extern void g_datalist_init(GData **datalist ) ;
#line 47
extern void g_datalist_clear(GData **datalist ) ;
#line 49
extern gpointer g_datalist_id_get_data(GData **datalist , GQuark key_id ) ;
#line 52
extern void g_datalist_id_set_data_full(GData **datalist , GQuark key_id , gpointer data ,
                                        GDestroyNotify destroy_func ) ;
#line 60
extern gpointer g_datalist_id_dup_data(GData **datalist , GQuark key_id , GDuplicateFunc dup_func ,
                                       gpointer user_data ) ;
#line 65
extern gboolean g_datalist_id_replace_data(GData **datalist , GQuark key_id , gpointer oldval ,
                                           gpointer newval , GDestroyNotify destroy ,
                                           GDestroyNotify *old_destroy ) ;
#line 73
extern gpointer g_datalist_id_remove_no_notify(GData **datalist , GQuark key_id ) ;
#line 76
extern void g_datalist_foreach(GData **datalist , GDataForeachFunc func , gpointer user_data ) ;
#line 90
extern void g_datalist_set_flags(GData **datalist , guint flags ) ;
#line 93
extern void g_datalist_unset_flags(GData **datalist , guint flags ) ;
#line 96
extern guint g_datalist_get_flags(GData **datalist ) ;
#line 114
extern void g_dataset_destroy(gconstpointer dataset_location ) ;
#line 116
extern gpointer g_dataset_id_get_data(gconstpointer dataset_location , GQuark key_id ) ;
#line 119
extern gpointer g_datalist_get_data(GData **datalist , gchar *key ) ;
#line 122
extern void g_dataset_id_set_data_full(gconstpointer dataset_location , GQuark key_id ,
                                       gpointer data , GDestroyNotify destroy_func ) ;
#line 127
extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location , GQuark key_id ) ;
#line 130
extern void g_dataset_foreach(gconstpointer dataset_location , GDataForeachFunc func ,
                              gpointer user_data ) ;
#line 121 "/usr/include/glib-2.0/glib/gdate.h"
extern GDate *g_date_new(void) ;
#line 123
extern GDate *g_date_new_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 127
extern GDate *g_date_new_julian(guint32 julian_day ) ;
#line 129
extern void g_date_free(GDate *date ) ;
#line 131
extern GDate *g_date_copy(GDate *date ) ;
#line 139
extern gboolean g_date_valid(GDate *date ) ;
#line 141
extern gboolean g_date_valid_day(GDateDay day ) ;
#line 143
extern gboolean g_date_valid_month(GDateMonth month ) ;
#line 145
extern gboolean g_date_valid_year(GDateYear year ) ;
#line 147
extern gboolean g_date_valid_weekday(GDateWeekday weekday ) ;
#line 149
extern gboolean g_date_valid_julian(guint32 julian_date ) ;
#line 151
extern gboolean g_date_valid_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 156
extern GDateWeekday g_date_get_weekday(GDate *date ) ;
#line 158
extern GDateMonth g_date_get_month(GDate *date ) ;
#line 160
extern GDateYear g_date_get_year(GDate *date ) ;
#line 162
extern GDateDay g_date_get_day(GDate *date ) ;
#line 164
extern guint32 g_date_get_julian(GDate *date ) ;
#line 166
extern guint g_date_get_day_of_year(GDate *date ) ;
#line 174
extern guint g_date_get_monday_week_of_year(GDate *date ) ;
#line 176
extern guint g_date_get_sunday_week_of_year(GDate *date ) ;
#line 178
extern guint g_date_get_iso8601_week_of_year(GDate *date ) ;
#line 185
extern void g_date_clear(GDate *date , guint n_dates ) ;
#line 193
extern void g_date_set_parse(GDate *date , gchar *str ) ;
#line 196
extern void g_date_set_time_t(GDate *date , time_t timet ) ;
#line 200
extern void g_date_set_time_val(GDate *date , GTimeVal *timeval ) ;
#line 203
extern void g_date_set_time(GDate *date , GTime time_ ) ;
#line 207
extern void g_date_set_month(GDate *date , GDateMonth month ) ;
#line 210
extern void g_date_set_day(GDate *date , GDateDay day ) ;
#line 213
extern void g_date_set_year(GDate *date , GDateYear year ) ;
#line 216
extern void g_date_set_dmy(GDate *date , GDateDay day , GDateMonth month , GDateYear y ) ;
#line 221
extern void g_date_set_julian(GDate *date , guint32 julian_date ) ;
#line 224
extern gboolean g_date_is_first_of_month(GDate *date ) ;
#line 226
extern gboolean g_date_is_last_of_month(GDate *date ) ;
#line 230
extern void g_date_add_days(GDate *date , guint n_days ) ;
#line 233
extern void g_date_subtract_days(GDate *date , guint n_days ) ;
#line 238
extern void g_date_add_months(GDate *date , guint n_months ) ;
#line 241
extern void g_date_subtract_months(GDate *date , guint n_months ) ;
#line 246
extern void g_date_add_years(GDate *date , guint n_years ) ;
#line 249
extern void g_date_subtract_years(GDate *date , guint n_years ) ;
#line 252
extern gboolean g_date_is_leap_year(GDateYear year ) ;
#line 254
extern guint8 g_date_get_days_in_month(GDateMonth month , GDateYear year ) ;
#line 257
extern guint8 g_date_get_monday_weeks_in_year(GDateYear year ) ;
#line 259
extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year ) ;
#line 264
extern gint g_date_days_between(GDate *date1 , GDate *date2 ) ;
#line 269
extern gint g_date_compare(GDate *lhs , GDate *rhs ) ;
#line 272
extern void g_date_to_struct_tm(GDate *date , struct tm *tm ) ;
#line 276
extern void g_date_clamp(GDate *date , GDate *min_date , GDate *max_date ) ;
#line 282
extern void g_date_order(GDate *date1 , GDate *date2 ) ;
#line 288
extern gsize g_date_strftime(gchar *s , gsize slen , gchar *format , GDate *date ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 40 "/usr/include/glib-2.0/glib/gdir.h"
extern GDir *g_dir_open(gchar *path , guint flags , GError **error ) ;
#line 44
extern gchar *g_dir_read_name(GDir *dir ) ;
#line 46
extern void g_dir_rewind(GDir *dir ) ;
#line 48
extern void g_dir_close(GDir *dir ) ;
#line 37 "/usr/include/glib-2.0/glib/genviron.h"
extern gchar *g_getenv(gchar *variable ) ;
#line 39
extern gboolean g_setenv(gchar *variable , gchar *value , gboolean overwrite ) ;
#line 43
extern void g_unsetenv(gchar *variable ) ;
#line 45
extern gchar **g_listenv(void) ;
#line 48
extern gchar **g_get_environ(void) ;
#line 50
extern gchar *g_environ_getenv(gchar **envp , gchar *variable ) ;
#line 53
extern gchar **g_environ_setenv(gchar **envp , gchar *variable , gchar *value , gboolean overwrite ) ;
#line 58
extern gchar **g_environ_unsetenv(gchar **envp , gchar *variable ) ;
#line 109 "/usr/include/glib-2.0/glib/gfileutils.h"
extern GQuark g_file_error_quark(void) ;
#line 112
extern GFileError g_file_error_from_errno(gint err_no ) ;
#line 115
extern gboolean g_file_test(gchar *filename , GFileTest test ) ;
#line 118
extern gboolean g_file_get_contents(gchar *filename , gchar **contents , gsize *length ,
                                    GError **error ) ;
#line 123
extern gboolean g_file_set_contents(gchar *filename , gchar *contents , gssize length ,
                                    GError **error ) ;
#line 129
extern gboolean g_file_set_contents_full(gchar *filename , gchar *contents , gssize length ,
                                         GFileSetContentsFlags flags , int mode ,
                                         GError **error ) ;
#line 137
extern gchar *g_file_read_link(gchar *filename , GError **error ) ;
#line 142
extern gchar *g_mkdtemp(gchar *tmpl ) ;
#line 144
extern gchar *g_mkdtemp_full(gchar *tmpl , gint mode ) ;
#line 149
extern gint g_mkstemp(gchar *tmpl ) ;
#line 151
extern gint g_mkstemp_full(gchar *tmpl , gint flags , gint mode ) ;
#line 157
extern gint g_file_open_tmp(gchar *tmpl , gchar **name_used , GError **error ) ;
#line 161
extern gchar *g_dir_make_tmp(gchar *tmpl , GError **error ) ;
#line 165
extern gchar *g_build_path(gchar *separator , gchar *first_element  , ...) ;
#line 169
extern gchar *g_build_pathv(gchar *separator , gchar **args ) ;
#line 173
extern gchar *g_build_filename(gchar *first_element  , ...) ;
#line 176
extern gchar *g_build_filenamev(gchar **args ) ;
#line 178
extern gchar *g_build_filename_valist(gchar *first_element , va_list *args ) ;
#line 182
extern gint g_mkdir_with_parents(gchar *pathname , gint mode ) ;
#line 200
extern gboolean g_path_is_absolute(gchar *file_name ) ;
#line 202
extern gchar *g_path_skip_root(gchar *file_name ) ;
#line 205
extern gchar *g_basename(gchar *file_name ) ;
#line 209
extern gchar *g_get_current_dir(void) ;
#line 211
extern gchar *g_path_get_basename(gchar *file_name ) ;
#line 213
extern gchar *g_path_get_dirname(gchar *file_name ) ;
#line 216
extern gchar *g_canonicalize_filename(gchar *filename , gchar *relative_to ) ;
#line 37 "/usr/include/glib-2.0/glib/ggettext.h"
extern gchar *g_strip_context(gchar *msgid , gchar *msgval ) ;
#line 41
extern gchar *g_dgettext(gchar *domain , gchar *msgid ) ;
#line 44
extern gchar *g_dcgettext(gchar *domain , gchar *msgid , gint category ) ;
#line 48
extern gchar *g_dngettext(gchar *domain , gchar *msgid , gchar *msgid_plural , gulong n ) ;
#line 53
extern gchar *g_dpgettext(gchar *domain , gchar *msgctxtid , gsize msgidoffset ) ;
#line 57
extern gchar *g_dpgettext2(gchar *domain , gchar *context , gchar *msgid ) ;
#line 72 "/usr/include/glib-2.0/glib/gmem.h"
extern void g_free(gpointer mem ) ;
#line 75
extern void g_clear_pointer(gpointer *pp , GDestroyNotify destroy ) ;
#line 79
extern gpointer g_malloc(gsize n_bytes ) ;
#line 81
extern gpointer g_malloc0(gsize n_bytes ) ;
#line 83
extern gpointer g_realloc(gpointer mem , gsize n_bytes ) ;
#line 86
extern gpointer g_try_malloc(gsize n_bytes ) ;
#line 88
extern gpointer g_try_malloc0(gsize n_bytes ) ;
#line 90
extern gpointer g_try_realloc(gpointer mem , gsize n_bytes ) ;
#line 94
extern gpointer g_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 97
extern gpointer g_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 100
extern gpointer g_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 104
extern gpointer g_try_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 107
extern gpointer g_try_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 110
extern gpointer g_try_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 115
extern gpointer g_aligned_alloc(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 119
extern gpointer g_aligned_alloc0(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 123
extern void g_aligned_free(gpointer mem ) ;
#line 216 "/usr/include/glib-2.0/glib/gmem.h"
__inline static gpointer g_steal_pointer(gpointer pp ) 
{ 
  gpointer *ptr ;
  gpointer ref ;

  {
#line 218
  ptr = (gpointer *)pp;
#line 221
  ref = *ptr;
#line 222
  *ptr = (void *)0;
#line 224
  return (ref);
}
}
#line 393
extern void g_mem_set_vtable(GMemVTable *vtable ) ;
#line 395
extern gboolean g_mem_is_system_malloc(void) ;
#line 397
extern gboolean g_mem_gc_friendly ;
#line 401
extern GMemVTable *glib_mem_profiler_table ;
#line 403
extern void g_mem_profile(void) ;
#line 99 "/usr/include/glib-2.0/glib/gnode.h"
extern GNode *g_node_new(gpointer data ) ;
#line 101
extern void g_node_destroy(GNode *root ) ;
#line 103
extern void g_node_unlink(GNode *node ) ;
#line 105
extern GNode *g_node_copy_deep(GNode *node , GCopyFunc copy_func , gpointer data ) ;
#line 109
extern GNode *g_node_copy(GNode *node ) ;
#line 111
extern GNode *g_node_insert(GNode *parent , gint position , GNode *node ) ;
#line 115
extern GNode *g_node_insert_before(GNode *parent , GNode *sibling , GNode *node ) ;
#line 119
extern GNode *g_node_insert_after(GNode *parent , GNode *sibling , GNode *node ) ;
#line 123
extern GNode *g_node_prepend(GNode *parent , GNode *node ) ;
#line 126
extern guint g_node_n_nodes(GNode *root , GTraverseFlags flags ) ;
#line 129
extern GNode *g_node_get_root(GNode *node ) ;
#line 131
extern gboolean g_node_is_ancestor(GNode *node , GNode *descendant ) ;
#line 134
extern guint g_node_depth(GNode *node ) ;
#line 136
extern GNode *g_node_find(GNode *root , GTraverseType order , GTraverseFlags flags ,
                          gpointer data ) ;
#line 224
extern void g_node_traverse(GNode *root , GTraverseType order , GTraverseFlags flags ,
                            gint max_depth , GNodeTraverseFunc func , gpointer data ) ;
#line 237
extern guint g_node_max_height(GNode *root ) ;
#line 240
extern void g_node_children_foreach(GNode *node , GTraverseFlags flags , GNodeForeachFunc func ,
                                    gpointer data ) ;
#line 245
extern void g_node_reverse_children(GNode *node ) ;
#line 247
extern guint g_node_n_children(GNode *node ) ;
#line 249
extern GNode *g_node_nth_child(GNode *node , guint n ) ;
#line 252
extern GNode *g_node_last_child(GNode *node ) ;
#line 254
extern GNode *g_node_find_child(GNode *node , GTraverseFlags flags , gpointer data ) ;
#line 258
extern gint g_node_child_position(GNode *node , GNode *child ) ;
#line 261
extern gint g_node_child_index(GNode *node , gpointer data ) ;
#line 265
extern GNode *g_node_first_sibling(GNode *node ) ;
#line 267
extern GNode *g_node_last_sibling(GNode *node ) ;
#line 49 "/usr/include/glib-2.0/glib/glist.h"
extern GList *g_list_alloc(void) ;
#line 51
extern void g_list_free(GList *list ) ;
#line 53
extern void g_list_free_1(GList *list ) ;
#line 56
extern void g_list_free_full(GList *list , GDestroyNotify free_func ) ;
#line 59
extern GList *g_list_append(GList *list , gpointer data ) ;
#line 62
extern GList *g_list_prepend(GList *list , gpointer data ) ;
#line 65
extern GList *g_list_insert(GList *list , gpointer data , gint position ) ;
#line 69
extern GList *g_list_insert_sorted(GList *list , gpointer data , GCompareFunc func ) ;
#line 73
extern GList *g_list_insert_sorted_with_data(GList *list , gpointer data , GCompareDataFunc func ,
                                             gpointer user_data ) ;
#line 78
extern GList *g_list_insert_before(GList *list , GList *sibling , gpointer data ) ;
#line 82
extern GList *g_list_insert_before_link(GList *list , GList *sibling , GList *link_ ) ;
#line 86
extern GList *g_list_concat(GList *list1 , GList *list2 ) ;
#line 89
extern GList *g_list_remove(GList *list , gconstpointer data ) ;
#line 92
extern GList *g_list_remove_all(GList *list , gconstpointer data ) ;
#line 95
extern GList *g_list_remove_link(GList *list , GList *llink ) ;
#line 98
extern GList *g_list_delete_link(GList *list , GList *link_ ) ;
#line 101
extern GList *g_list_reverse(GList *list ) ;
#line 103
extern GList *g_list_copy(GList *list ) ;
#line 106
extern GList *g_list_copy_deep(GList *list , GCopyFunc func , gpointer user_data ) ;
#line 111
extern GList *g_list_nth(GList *list , guint n ) ;
#line 114
extern GList *g_list_nth_prev(GList *list , guint n ) ;
#line 117
extern GList *g_list_find(GList *list , gconstpointer data ) ;
#line 120
extern GList *g_list_find_custom(GList *list , gconstpointer data , GCompareFunc func ) ;
#line 124
extern gint g_list_position(GList *list , GList *llink ) ;
#line 127
extern gint g_list_index(GList *list , gconstpointer data ) ;
#line 130
extern GList *g_list_last(GList *list ) ;
#line 132
extern GList *g_list_first(GList *list ) ;
#line 134
extern guint g_list_length(GList *list ) ;
#line 136
extern void g_list_foreach(GList *list , GFunc func , gpointer user_data ) ;
#line 140
extern GList *g_list_sort(GList *list , GCompareFunc compare_func ) ;
#line 143
extern GList *g_list_sort_with_data(GList *list , GCompareDataFunc compare_func ,
                                    gpointer user_data ) ;
#line 147
extern gpointer g_list_nth_data(GList *list , guint n ) ;
#line 151
extern void g_clear_list(GList **list_ptr , GDestroyNotify destroy ) ;
#line 57 "/usr/include/glib-2.0/glib/ghash.h"
extern GHashTable *g_hash_table_new(GHashFunc hash_func , GEqualFunc key_equal_func ) ;
#line 60
extern GHashTable *g_hash_table_new_full(GHashFunc hash_func , GEqualFunc key_equal_func ,
                                         GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 65
extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table ) ;
#line 67
extern void g_hash_table_destroy(GHashTable *hash_table ) ;
#line 69
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 73
extern gboolean g_hash_table_replace(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 77
extern gboolean g_hash_table_add(GHashTable *hash_table , gpointer key ) ;
#line 80
extern gboolean g_hash_table_remove(GHashTable *hash_table , gconstpointer key ) ;
#line 83
extern void g_hash_table_remove_all(GHashTable *hash_table ) ;
#line 85
extern gboolean g_hash_table_steal(GHashTable *hash_table , gconstpointer key ) ;
#line 88
extern gboolean g_hash_table_steal_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                            gpointer *stolen_key , gpointer *stolen_value ) ;
#line 93
extern void g_hash_table_steal_all(GHashTable *hash_table ) ;
#line 95
extern gpointer g_hash_table_lookup(GHashTable *hash_table , gconstpointer key ) ;
#line 98
extern gboolean g_hash_table_contains(GHashTable *hash_table , gconstpointer key ) ;
#line 101
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
#line 106
extern void g_hash_table_foreach(GHashTable *hash_table , GHFunc func , gpointer user_data ) ;
#line 110
extern gpointer g_hash_table_find(GHashTable *hash_table , GHRFunc predicate , gpointer user_data ) ;
#line 114
extern guint g_hash_table_foreach_remove(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 118
extern guint g_hash_table_foreach_steal(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 122
extern guint g_hash_table_size(GHashTable *hash_table ) ;
#line 124
extern GList *g_hash_table_get_keys(GHashTable *hash_table ) ;
#line 126
extern GList *g_hash_table_get_values(GHashTable *hash_table ) ;
#line 128
extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table , guint *length ) ;
#line 132
extern void g_hash_table_iter_init(GHashTableIter *iter , GHashTable *hash_table ) ;
#line 135
extern gboolean g_hash_table_iter_next(GHashTableIter *iter , gpointer *key , gpointer *value ) ;
#line 139
extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter ) ;
#line 141
extern void g_hash_table_iter_remove(GHashTableIter *iter ) ;
#line 143
extern void g_hash_table_iter_replace(GHashTableIter *iter , gpointer value ) ;
#line 146
extern void g_hash_table_iter_steal(GHashTableIter *iter ) ;
#line 149
extern GHashTable *g_hash_table_ref(GHashTable *hash_table ) ;
#line 151
extern void g_hash_table_unref(GHashTable *hash_table ) ;
#line 159
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 162
extern guint g_str_hash(gconstpointer v ) ;
#line 165
extern gboolean g_int_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 168
extern guint g_int_hash(gconstpointer v ) ;
#line 171
extern gboolean g_int64_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 174
extern guint g_int64_hash(gconstpointer v ) ;
#line 177
extern gboolean g_double_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 180
extern guint g_double_hash(gconstpointer v ) ;
#line 183
extern guint g_direct_hash(gconstpointer v ) ;
#line 185
extern gboolean g_direct_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 43 "/usr/include/glib-2.0/glib/ghmac.h"
extern GHmac *g_hmac_new(GChecksumType digest_type , guchar *key , gsize key_len ) ;
#line 47
extern GHmac *g_hmac_copy(GHmac *hmac ) ;
#line 49
extern GHmac *g_hmac_ref(GHmac *hmac ) ;
#line 51
extern void g_hmac_unref(GHmac *hmac ) ;
#line 53
extern void g_hmac_update(GHmac *hmac , guchar *data , gssize length ) ;
#line 57
extern gchar *g_hmac_get_string(GHmac *hmac ) ;
#line 59
extern void g_hmac_get_digest(GHmac *hmac , guint8 *buffer , gsize *digest_len ) ;
#line 64
extern gchar *g_compute_hmac_for_data(GChecksumType digest_type , guchar *key , gsize key_len ,
                                      guchar *data , gsize length ) ;
#line 70
extern gchar *g_compute_hmac_for_string(GChecksumType digest_type , guchar *key ,
                                        gsize key_len , gchar *str , gssize length ) ;
#line 76
extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type , GBytes *key , GBytes *data ) ;
#line 105 "/usr/include/glib-2.0/glib/ghook.h"
extern void g_hook_list_init(GHookList *hook_list , guint hook_size ) ;
#line 108
extern void g_hook_list_clear(GHookList *hook_list ) ;
#line 110
extern GHook *g_hook_alloc(GHookList *hook_list ) ;
#line 112
extern void g_hook_free(GHookList *hook_list , GHook *hook ) ;
#line 115
extern GHook *g_hook_ref(GHookList *hook_list , GHook *hook ) ;
#line 118
extern void g_hook_unref(GHookList *hook_list , GHook *hook ) ;
#line 121
extern gboolean g_hook_destroy(GHookList *hook_list , gulong hook_id ) ;
#line 124
extern void g_hook_destroy_link(GHookList *hook_list , GHook *hook ) ;
#line 127
extern void g_hook_prepend(GHookList *hook_list , GHook *hook ) ;
#line 130
extern void g_hook_insert_before(GHookList *hook_list , GHook *sibling , GHook *hook ) ;
#line 134
extern void g_hook_insert_sorted(GHookList *hook_list , GHook *hook , GHookCompareFunc func ) ;
#line 138
extern GHook *g_hook_get(GHookList *hook_list , gulong hook_id ) ;
#line 141
extern GHook *g_hook_find(GHookList *hook_list , gboolean need_valids , GHookFindFunc func ,
                          gpointer data ) ;
#line 146
extern GHook *g_hook_find_data(GHookList *hook_list , gboolean need_valids , gpointer data ) ;
#line 150
extern GHook *g_hook_find_func(GHookList *hook_list , gboolean need_valids , gpointer func ) ;
#line 154
extern GHook *g_hook_find_func_data(GHookList *hook_list , gboolean need_valids ,
                                    gpointer func , gpointer data ) ;
#line 160
extern GHook *g_hook_first_valid(GHookList *hook_list , gboolean may_be_in_call ) ;
#line 166
extern GHook *g_hook_next_valid(GHookList *hook_list , GHook *hook , gboolean may_be_in_call ) ;
#line 171
extern gint g_hook_compare_ids(GHook *new_hook , GHook *sibling ) ;
#line 179
extern void g_hook_list_invoke(GHookList *hook_list , gboolean may_recurse ) ;
#line 185
extern void g_hook_list_invoke_check(GHookList *hook_list , gboolean may_recurse ) ;
#line 190
extern void g_hook_list_marshal(GHookList *hook_list , gboolean may_recurse , GHookMarshaller marshaller ,
                                gpointer marshal_data ) ;
#line 195
extern void g_hook_list_marshal_check(GHookList *hook_list , gboolean may_recurse ,
                                      GHookCheckMarshaller marshaller , gpointer marshal_data ) ;
#line 30 "/usr/include/glib-2.0/glib/ghostutils.h"
extern gboolean g_hostname_is_non_ascii(gchar *hostname ) ;
#line 32
extern gboolean g_hostname_is_ascii_encoded(gchar *hostname ) ;
#line 34
extern gboolean g_hostname_is_ip_address(gchar *hostname ) ;
#line 37
extern gchar *g_hostname_to_ascii(gchar *hostname ) ;
#line 39
extern gchar *g_hostname_to_unicode(gchar *hostname ) ;
#line 114 "/usr/include/glib-2.0/glib/gpoll.h"
extern gint g_poll(GPollFD *fds , guint nfds , gint timeout ) ;
#line 48 "/usr/include/glib-2.0/glib/gslist.h"
extern GSList *g_slist_alloc(void) ;
#line 50
extern void g_slist_free(GSList *list ) ;
#line 52
extern void g_slist_free_1(GSList *list ) ;
#line 55
extern void g_slist_free_full(GSList *list , GDestroyNotify free_func ) ;
#line 58
extern GSList *g_slist_append(GSList *list , gpointer data ) ;
#line 61
extern GSList *g_slist_prepend(GSList *list , gpointer data ) ;
#line 64
extern GSList *g_slist_insert(GSList *list , gpointer data , gint position ) ;
#line 68
extern GSList *g_slist_insert_sorted(GSList *list , gpointer data , GCompareFunc func ) ;
#line 72
extern GSList *g_slist_insert_sorted_with_data(GSList *list , gpointer data , GCompareDataFunc func ,
                                               gpointer user_data ) ;
#line 77
extern GSList *g_slist_insert_before(GSList *slist , GSList *sibling , gpointer data ) ;
#line 81
extern GSList *g_slist_concat(GSList *list1 , GSList *list2 ) ;
#line 84
extern GSList *g_slist_remove(GSList *list , gconstpointer data ) ;
#line 87
extern GSList *g_slist_remove_all(GSList *list , gconstpointer data ) ;
#line 90
extern GSList *g_slist_remove_link(GSList *list , GSList *link_ ) ;
#line 93
extern GSList *g_slist_delete_link(GSList *list , GSList *link_ ) ;
#line 96
extern GSList *g_slist_reverse(GSList *list ) ;
#line 98
extern GSList *g_slist_copy(GSList *list ) ;
#line 101
extern GSList *g_slist_copy_deep(GSList *list , GCopyFunc func , gpointer user_data ) ;
#line 105
extern GSList *g_slist_nth(GSList *list , guint n ) ;
#line 108
extern GSList *g_slist_find(GSList *list , gconstpointer data ) ;
#line 111
extern GSList *g_slist_find_custom(GSList *list , gconstpointer data , GCompareFunc func ) ;
#line 115
extern gint g_slist_position(GSList *list , GSList *llink ) ;
#line 118
extern gint g_slist_index(GSList *list , gconstpointer data ) ;
#line 121
extern GSList *g_slist_last(GSList *list ) ;
#line 123
extern guint g_slist_length(GSList *list ) ;
#line 125
extern void g_slist_foreach(GSList *list , GFunc func , gpointer user_data ) ;
#line 129
extern GSList *g_slist_sort(GSList *list , GCompareFunc compare_func ) ;
#line 132
extern GSList *g_slist_sort_with_data(GSList *list , GCompareDataFunc compare_func ,
                                      gpointer user_data ) ;
#line 136
extern gpointer g_slist_nth_data(GSList *list , guint n ) ;
#line 140
extern void g_clear_slist(GSList **slist_ptr , GDestroyNotify destroy ) ;
#line 380 "/usr/include/glib-2.0/glib/gmain.h"
extern GMainContext *g_main_context_new(void) ;
#line 383
extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags ) ;
#line 386
extern GMainContext *g_main_context_ref(GMainContext *context ) ;
#line 388
extern void g_main_context_unref(GMainContext *context ) ;
#line 390
extern GMainContext *g_main_context_default(void) ;
#line 393
extern gboolean g_main_context_iteration(GMainContext *context , gboolean may_block ) ;
#line 396
extern gboolean g_main_context_pending(GMainContext *context ) ;
#line 401
extern GSource *g_main_context_find_source_by_id(GMainContext *context , guint source_id ) ;
#line 404
extern GSource *g_main_context_find_source_by_user_data(GMainContext *context , gpointer user_data ) ;
#line 407
extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context ,
                                                              GSourceFuncs *funcs ,
                                                              gpointer user_data ) ;
#line 414
extern void g_main_context_wakeup(GMainContext *context ) ;
#line 416
extern gboolean g_main_context_acquire(GMainContext *context ) ;
#line 418
extern void g_main_context_release(GMainContext *context ) ;
#line 420
extern gboolean g_main_context_is_owner(GMainContext *context ) ;
#line 422
extern gboolean g_main_context_wait(GMainContext *context , GCond *cond , GMutex *mutex ) ;
#line 427
extern gboolean g_main_context_prepare(GMainContext *context , gint *priority ) ;
#line 430
extern gint g_main_context_query(GMainContext *context , gint max_priority , gint *timeout_ ,
                                 GPollFD *fds , gint n_fds ) ;
#line 436
extern gboolean g_main_context_check(GMainContext *context , gint max_priority , GPollFD *fds ,
                                     gint n_fds ) ;
#line 441
extern void g_main_context_dispatch(GMainContext *context ) ;
#line 444
extern void g_main_context_set_poll_func(GMainContext *context , GPollFunc func ) ;
#line 447
extern GPollFunc g_main_context_get_poll_func(GMainContext *context ) ;
#line 452
extern void g_main_context_add_poll(GMainContext *context , GPollFD *fd , gint priority ) ;
#line 456
extern void g_main_context_remove_poll(GMainContext *context , GPollFD *fd ) ;
#line 460
extern gint g_main_depth(void) ;
#line 462
extern GSource *g_main_current_source(void) ;
#line 467
extern void g_main_context_push_thread_default(GMainContext *context ) ;
#line 469
extern void g_main_context_pop_thread_default(GMainContext *context ) ;
#line 471
extern GMainContext *g_main_context_get_thread_default(void) ;
#line 473
extern GMainContext *g_main_context_ref_thread_default(void) ;
#line 532 "/usr/include/glib-2.0/glib/gmain.h"
__inline static GMainContextPusher *g_main_context_pusher_new(GMainContext *main_context ) 
{ 


  {
  {
#line 534
  g_main_context_push_thread_default(main_context);
  }
#line 535
  return ((GMainContextPusher *)main_context);
}
}
#line 554 "/usr/include/glib-2.0/glib/gmain.h"
__inline static void g_main_context_pusher_free(GMainContextPusher *pusher ) 
{ 


  {
  {
#line 556
  g_main_context_pop_thread_default((GMainContext *)pusher);
  }
  return;
}
}
#line 563
extern GMainLoop *g_main_loop_new(GMainContext *context , gboolean is_running ) ;
#line 566
extern void g_main_loop_run(GMainLoop *loop ) ;
#line 568
extern void g_main_loop_quit(GMainLoop *loop ) ;
#line 570
extern GMainLoop *g_main_loop_ref(GMainLoop *loop ) ;
#line 572
extern void g_main_loop_unref(GMainLoop *loop ) ;
#line 574
extern gboolean g_main_loop_is_running(GMainLoop *loop ) ;
#line 576
extern GMainContext *g_main_loop_get_context(GMainLoop *loop ) ;
#line 581
extern GSource *g_source_new(GSourceFuncs *source_funcs , guint struct_size ) ;
#line 586
extern void g_source_set_dispose_function(GSource *source , GSourceDisposeFunc dispose ) ;
#line 591
extern GSource *g_source_ref(GSource *source ) ;
#line 593
extern void g_source_unref(GSource *source ) ;
#line 596
extern guint g_source_attach(GSource *source , GMainContext *context ) ;
#line 599
extern void g_source_destroy(GSource *source ) ;
#line 602
extern void g_source_set_priority(GSource *source , gint priority ) ;
#line 605
extern gint g_source_get_priority(GSource *source ) ;
#line 607
extern void g_source_set_can_recurse(GSource *source , gboolean can_recurse ) ;
#line 610
extern gboolean g_source_get_can_recurse(GSource *source ) ;
#line 612
extern guint g_source_get_id(GSource *source ) ;
#line 615
extern GMainContext *g_source_get_context(GSource *source ) ;
#line 618
extern void g_source_set_callback(GSource *source , GSourceFunc func , gpointer data ,
                                  GDestroyNotify notify ) ;
#line 624
extern void g_source_set_funcs(GSource *source , GSourceFuncs *funcs ) ;
#line 627
extern gboolean g_source_is_destroyed(GSource *source ) ;
#line 630
extern void g_source_set_name(GSource *source , char const   *name ) ;
#line 633
extern void g_source_set_static_name(GSource *source , char const   *name ) ;
#line 636
extern char const   *g_source_get_name(GSource *source ) ;
#line 638
extern void g_source_set_name_by_id(guint tag , char const   *name ) ;
#line 642
extern void g_source_set_ready_time(GSource *source , gint64 ready_time ) ;
#line 645
extern gint64 g_source_get_ready_time(GSource *source ) ;
#line 649
extern gpointer g_source_add_unix_fd(GSource *source , gint fd , GIOCondition events ) ;
#line 653
extern void g_source_modify_unix_fd(GSource *source , gpointer tag , GIOCondition new_events ) ;
#line 657
extern void g_source_remove_unix_fd(GSource *source , gpointer tag ) ;
#line 660
extern GIOCondition g_source_query_unix_fd(GSource *source , gpointer tag ) ;
#line 666
extern void g_source_set_callback_indirect(GSource *source , gpointer callback_data ,
                                           GSourceCallbackFuncs *callback_funcs ) ;
#line 671
extern void g_source_add_poll(GSource *source , GPollFD *fd ) ;
#line 674
extern void g_source_remove_poll(GSource *source , GPollFD *fd ) ;
#line 678
extern void g_source_add_child_source(GSource *source , GSource *child_source ) ;
#line 681
extern void g_source_remove_child_source(GSource *source , GSource *child_source ) ;
#line 686
extern void g_source_get_current_time(GSource *source , GTimeVal *timeval ) ;
#line 691
extern gint64 g_source_get_time(GSource *source ) ;
#line 700
extern GSource *g_idle_source_new(void) ;
#line 702
extern GSource *g_child_watch_source_new(GPid pid ) ;
#line 704
extern GSource *g_timeout_source_new(guint interval ) ;
#line 706
extern GSource *g_timeout_source_new_seconds(guint interval ) ;
#line 712
extern void g_get_current_time(GTimeVal *result ) ;
#line 716
extern gint64 g_get_monotonic_time(void) ;
#line 718
extern gint64 g_get_real_time(void) ;
#line 723
extern gboolean g_source_remove(guint tag ) ;
#line 725
extern gboolean g_source_remove_by_user_data(gpointer user_data ) ;
#line 727
extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs , gpointer user_data ) ;
#line 744
extern void g_clear_handle_id(guint *tag_ptr , GClearHandleFunc clear_func ) ;
#line 764
extern guint g_timeout_add_full(gint priority , guint interval , GSourceFunc function ,
                                gpointer data , GDestroyNotify notify ) ;
#line 770
extern guint g_timeout_add(guint interval , GSourceFunc function , gpointer data ) ;
#line 774
extern guint g_timeout_add_seconds_full(gint priority , guint interval , GSourceFunc function ,
                                        gpointer data , GDestroyNotify notify ) ;
#line 780
extern guint g_timeout_add_seconds(guint interval , GSourceFunc function , gpointer data ) ;
#line 784
extern guint g_child_watch_add_full(gint priority , GPid pid , GChildWatchFunc function ,
                                    gpointer data , GDestroyNotify notify ) ;
#line 790
extern guint g_child_watch_add(GPid pid , GChildWatchFunc function , gpointer data ) ;
#line 794
extern guint g_idle_add(GSourceFunc function , gpointer data ) ;
#line 797
extern guint g_idle_add_full(gint priority , GSourceFunc function , gpointer data ,
                             GDestroyNotify notify ) ;
#line 802
extern gboolean g_idle_remove_by_data(gpointer data ) ;
#line 805
extern void g_main_context_invoke_full(GMainContext *context , gint priority , GSourceFunc function ,
                                       gpointer data , GDestroyNotify notify ) ;
#line 811
extern void g_main_context_invoke(GMainContext *context , GSourceFunc function , gpointer data ) ;
#line 817 "/usr/include/glib-2.0/glib/gmain.h"
__inline static int g_steal_fd(int *fd_ptr ) 
{ 
  int fd ;

  {
#line 819
  fd = *fd_ptr;
#line 820
  *fd_ptr = - 1;
#line 821
  return (fd);
}
}
#line 825
extern GSourceFuncs g_timeout_funcs ;
#line 826
extern GSourceFuncs g_child_watch_funcs ;
#line 827
extern GSourceFuncs g_idle_funcs ;
#line 829
extern GSourceFuncs g_unix_signal_funcs ;
#line 830
extern GSourceFuncs g_unix_fd_source_funcs ;
#line 650 "/usr/include/glib-2.0/glib/gunicode.h"
extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script ) ;
#line 652
extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924 ) ;
#line 657
extern gboolean g_unichar_isalnum(gunichar c ) ;
#line 659
extern gboolean g_unichar_isalpha(gunichar c ) ;
#line 661
extern gboolean g_unichar_iscntrl(gunichar c ) ;
#line 663
extern gboolean g_unichar_isdigit(gunichar c ) ;
#line 665
extern gboolean g_unichar_isgraph(gunichar c ) ;
#line 667
extern gboolean g_unichar_islower(gunichar c ) ;
#line 669
extern gboolean g_unichar_isprint(gunichar c ) ;
#line 671
extern gboolean g_unichar_ispunct(gunichar c ) ;
#line 673
extern gboolean g_unichar_isspace(gunichar c ) ;
#line 675
extern gboolean g_unichar_isupper(gunichar c ) ;
#line 677
extern gboolean g_unichar_isxdigit(gunichar c ) ;
#line 679
extern gboolean g_unichar_istitle(gunichar c ) ;
#line 681
extern gboolean g_unichar_isdefined(gunichar c ) ;
#line 683
extern gboolean g_unichar_iswide(gunichar c ) ;
#line 685
extern gboolean g_unichar_iswide_cjk(gunichar c ) ;
#line 687
extern gboolean g_unichar_iszerowidth(gunichar c ) ;
#line 689
extern gboolean g_unichar_ismark(gunichar c ) ;
#line 694
extern gunichar g_unichar_toupper(gunichar c ) ;
#line 696
extern gunichar g_unichar_tolower(gunichar c ) ;
#line 698
extern gunichar g_unichar_totitle(gunichar c ) ;
#line 703
extern gint g_unichar_digit_value(gunichar c ) ;
#line 706
extern gint g_unichar_xdigit_value(gunichar c ) ;
#line 710
extern GUnicodeType g_unichar_type(gunichar c ) ;
#line 714
extern GUnicodeBreakType g_unichar_break_type(gunichar c ) ;
#line 718
extern gint g_unichar_combining_class(gunichar uc ) ;
#line 721
extern gboolean g_unichar_get_mirror_char(gunichar ch , gunichar *mirrored_ch ) ;
#line 725
extern GUnicodeScript g_unichar_get_script(gunichar ch ) ;
#line 729
extern gboolean g_unichar_validate(gunichar ch ) ;
#line 733
extern gboolean g_unichar_compose(gunichar a , gunichar b , gunichar *ch ) ;
#line 737
extern gboolean g_unichar_decompose(gunichar ch , gunichar *a , gunichar *b ) ;
#line 742
extern gsize g_unichar_fully_decompose(gunichar ch , gboolean compat , gunichar *result ,
                                       gsize result_len ) ;
#line 763
extern void g_unicode_canonical_ordering(gunichar *string , gsize len ) ;
#line 768
extern gunichar *g_unicode_canonical_decomposition(gunichar ch , gsize *result_len ) ;
#line 773
extern gchar * const  g_utf8_skip ;
#line 794
extern gunichar g_utf8_get_char(gchar *p ) ;
#line 796
extern gunichar g_utf8_get_char_validated(gchar *p , gssize max_len ) ;
#line 800
extern gchar *g_utf8_offset_to_pointer(gchar *str , glong offset ) ;
#line 803
extern glong g_utf8_pointer_to_offset(gchar *str , gchar *pos ) ;
#line 806
extern gchar *g_utf8_prev_char(gchar *p ) ;
#line 808
extern gchar *g_utf8_find_next_char(gchar *p , gchar *end ) ;
#line 811
extern gchar *g_utf8_find_prev_char(gchar *str , gchar *p ) ;
#line 815
extern glong g_utf8_strlen(gchar *p , gssize max ) ;
#line 819
extern gchar *g_utf8_substring(gchar *str , glong start_pos , glong end_pos ) ;
#line 824
extern gchar *g_utf8_strncpy(gchar *dest , gchar *src , gsize n ) ;
#line 831
extern gchar *g_utf8_strchr(gchar *p , gssize len , gunichar c ) ;
#line 835
extern gchar *g_utf8_strrchr(gchar *p , gssize len , gunichar c ) ;
#line 839
extern gchar *g_utf8_strreverse(gchar *str , gssize len ) ;
#line 843
extern gunichar2 *g_utf8_to_utf16(gchar *str , glong len , glong *items_read , glong *items_written ,
                                  GError **error ) ;
#line 849
extern gunichar *g_utf8_to_ucs4(gchar *str , glong len , glong *items_read , glong *items_written ,
                                GError **error ) ;
#line 855
extern gunichar *g_utf8_to_ucs4_fast(gchar *str , glong len , glong *items_written ) ;
#line 859
extern gunichar *g_utf16_to_ucs4(gunichar2 *str , glong len , glong *items_read ,
                                 glong *items_written , GError **error ) ;
#line 865
extern gchar *g_utf16_to_utf8(gunichar2 *str , glong len , glong *items_read , glong *items_written ,
                              GError **error ) ;
#line 871
extern gunichar2 *g_ucs4_to_utf16(gunichar *str , glong len , glong *items_read ,
                                  glong *items_written , GError **error ) ;
#line 877
extern gchar *g_ucs4_to_utf8(gunichar *str , glong len , glong *items_read , glong *items_written ,
                             GError **error ) ;
#line 884
extern gint g_unichar_to_utf8(gunichar c , gchar *outbuf ) ;
#line 888
extern gboolean g_utf8_validate(gchar *str , gssize max_len , gchar **end ) ;
#line 892
extern gboolean g_utf8_validate_len(gchar *str , gsize max_len , gchar **end ) ;
#line 897
extern gchar *g_utf8_strup(gchar *str , gssize len ) ;
#line 900
extern gchar *g_utf8_strdown(gchar *str , gssize len ) ;
#line 903
extern gchar *g_utf8_casefold(gchar *str , gssize len ) ;
#line 942
extern gchar *g_utf8_normalize(gchar *str , gssize len , GNormalizeMode mode ) ;
#line 947
extern gint g_utf8_collate(gchar *str1 , gchar *str2 ) ;
#line 950
extern gchar *g_utf8_collate_key(gchar *str , gssize len ) ;
#line 953
extern gchar *g_utf8_collate_key_for_filename(gchar *str , gssize len ) ;
#line 957
extern gchar *g_utf8_make_valid(gchar *str , gssize len ) ;
#line 49 "/usr/include/glib-2.0/glib/gstring.h"
extern GString *g_string_new(gchar *init ) ;
#line 51
extern GString *g_string_new_len(gchar *init , gssize len ) ;
#line 54
extern GString *g_string_sized_new(gsize dfl_size ) ;
#line 56
extern gchar *g_string_free(GString *string , gboolean free_segment ) ;
#line 59
extern GBytes *g_string_free_to_bytes(GString *string ) ;
#line 61
extern gboolean g_string_equal(GString *v , GString *v2 ) ;
#line 64
extern guint g_string_hash(GString *str ) ;
#line 66
extern GString *g_string_assign(GString *string , gchar *rval ) ;
#line 69
extern GString *g_string_truncate(GString *string , gsize len ) ;
#line 72
extern GString *g_string_set_size(GString *string , gsize len ) ;
#line 75
extern GString *g_string_insert_len(GString *string , gssize pos , gchar *val , gssize len ) ;
#line 80
extern GString *g_string_append(GString *string , gchar *val ) ;
#line 83
extern GString *g_string_append_len(GString *string , gchar *val , gssize len ) ;
#line 87
extern GString *g_string_append_c(GString *string , gchar c ) ;
#line 90
extern GString *g_string_append_unichar(GString *string , gunichar wc ) ;
#line 93
extern GString *g_string_prepend(GString *string , gchar *val ) ;
#line 96
extern GString *g_string_prepend_c(GString *string , gchar c ) ;
#line 99
extern GString *g_string_prepend_unichar(GString *string , gunichar wc ) ;
#line 102
extern GString *g_string_prepend_len(GString *string , gchar *val , gssize len ) ;
#line 106
extern GString *g_string_insert(GString *string , gssize pos , gchar *val ) ;
#line 110
extern GString *g_string_insert_c(GString *string , gssize pos , gchar c ) ;
#line 114
extern GString *g_string_insert_unichar(GString *string , gssize pos , gunichar wc ) ;
#line 118
extern GString *g_string_overwrite(GString *string , gsize pos , gchar *val ) ;
#line 122
extern GString *g_string_overwrite_len(GString *string , gsize pos , gchar *val ,
                                       gssize len ) ;
#line 127
extern GString *g_string_erase(GString *string , gssize pos , gssize len ) ;
#line 131
extern guint g_string_replace(GString *string , gchar *find , gchar *replace , guint limit ) ;
#line 136
extern GString *g_string_ascii_down(GString *string ) ;
#line 138
extern GString *g_string_ascii_up(GString *string ) ;
#line 140
extern void g_string_vprintf(GString *string , gchar *format , va_list args ) ;
#line 145
extern void g_string_printf(GString *string , gchar *format  , ...) ;
#line 149
extern void g_string_append_vprintf(GString *string , gchar *format , va_list args ) ;
#line 154
extern void g_string_append_printf(GString *string , gchar *format  , ...) ;
#line 158
extern GString *g_string_append_uri_escaped(GString *string , gchar *unescaped , gchar *reserved_chars_allowed ,
                                            gboolean allow_utf8 ) ;
#line 166 "/usr/include/glib-2.0/glib/gstring.h"
__inline static GString *g_string_append_c_inline(GString *gstring , gchar c ) 
{ 
  gsize __cil_tmp3 ;

  {
#line 169
  if (gstring->len + 1UL < gstring->allocated_len) {
#line 171
    __cil_tmp3 = gstring->len;
#line 171
    (gstring->len) ++;
#line 171
    *(gstring->str + __cil_tmp3) = c;
#line 172
    *(gstring->str + gstring->len) = (gchar )0;
  } else {
    {
#line 175
    g_string_insert_c(gstring, (gssize )(- 1), c);
    }
  }
#line 176
  return (gstring);
}
}
#line 183
extern GString *g_string_down(GString *string ) ;
#line 185
extern GString *g_string_up(GString *string ) ;
#line 159 "/usr/include/glib-2.0/glib/giochannel.h"
extern void g_io_channel_init(GIOChannel *channel ) ;
#line 161
extern GIOChannel *g_io_channel_ref(GIOChannel *channel ) ;
#line 163
extern void g_io_channel_unref(GIOChannel *channel ) ;
#line 166
extern GIOError g_io_channel_read(GIOChannel *channel , gchar *buf , gsize count ,
                                  gsize *bytes_read ) ;
#line 172
extern GIOError g_io_channel_write(GIOChannel *channel , gchar *buf , gsize count ,
                                   gsize *bytes_written ) ;
#line 178
extern GIOError g_io_channel_seek(GIOChannel *channel , gint64 offset , GSeekType type ) ;
#line 183
extern void g_io_channel_close(GIOChannel *channel ) ;
#line 186
extern GIOStatus g_io_channel_shutdown(GIOChannel *channel , gboolean flush , GError **err ) ;
#line 190
extern guint g_io_add_watch_full(GIOChannel *channel , gint priority , GIOCondition condition ,
                                 GIOFunc func , gpointer user_data , GDestroyNotify notify ) ;
#line 197
extern GSource *g_io_create_watch(GIOChannel *channel , GIOCondition condition ) ;
#line 200
extern guint g_io_add_watch(GIOChannel *channel , GIOCondition condition , GIOFunc func ,
                            gpointer user_data ) ;
#line 209
extern void g_io_channel_set_buffer_size(GIOChannel *channel , gsize size ) ;
#line 212
extern gsize g_io_channel_get_buffer_size(GIOChannel *channel ) ;
#line 214
extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel ) ;
#line 216
extern GIOStatus g_io_channel_set_flags(GIOChannel *channel , GIOFlags flags , GError **error ) ;
#line 220
extern GIOFlags g_io_channel_get_flags(GIOChannel *channel ) ;
#line 222
extern void g_io_channel_set_line_term(GIOChannel *channel , gchar *line_term , gint length ) ;
#line 226
extern gchar *g_io_channel_get_line_term(GIOChannel *channel , gint *length ) ;
#line 229
extern void g_io_channel_set_buffered(GIOChannel *channel , gboolean buffered ) ;
#line 232
extern gboolean g_io_channel_get_buffered(GIOChannel *channel ) ;
#line 234
extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel , gchar *encoding ,
                                           GError **error ) ;
#line 238
extern gchar *g_io_channel_get_encoding(GIOChannel *channel ) ;
#line 240
extern void g_io_channel_set_close_on_unref(GIOChannel *channel , gboolean do_close ) ;
#line 243
extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel ) ;
#line 247
extern GIOStatus g_io_channel_flush(GIOChannel *channel , GError **error ) ;
#line 250
extern GIOStatus g_io_channel_read_line(GIOChannel *channel , gchar **str_return ,
                                        gsize *length , gsize *terminator_pos , GError **error ) ;
#line 256
extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel , GString *buffer ,
                                               gsize *terminator_pos , GError **error ) ;
#line 261
extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel , gchar **str_return ,
                                          gsize *length , GError **error ) ;
#line 266
extern GIOStatus g_io_channel_read_chars(GIOChannel *channel , gchar *buf , gsize count ,
                                         gsize *bytes_read , GError **error ) ;
#line 272
extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel , gunichar *thechar ,
                                           GError **error ) ;
#line 276
extern GIOStatus g_io_channel_write_chars(GIOChannel *channel , gchar *buf , gssize count ,
                                          gsize *bytes_written , GError **error ) ;
#line 282
extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel , gunichar thechar ,
                                            GError **error ) ;
#line 286
extern GIOStatus g_io_channel_seek_position(GIOChannel *channel , gint64 offset ,
                                            GSeekType type , GError **error ) ;
#line 291
extern GIOChannel *g_io_channel_new_file(gchar *filename , gchar *mode , GError **error ) ;
#line 298
extern GQuark g_io_channel_error_quark(void) ;
#line 300
extern GIOChannelError g_io_channel_error_from_errno(gint en ) ;
#line 321
extern GIOChannel *g_io_channel_unix_new(int fd ) ;
#line 323
extern gint g_io_channel_unix_get_fd(GIOChannel *channel ) ;
#line 327
extern GSourceFuncs g_io_watch_funcs ;
#line 46 "/usr/include/glib-2.0/glib/gkeyfile.h"
extern GQuark g_key_file_error_quark(void) ;
#line 58
extern GKeyFile *g_key_file_new(void) ;
#line 60
extern GKeyFile *g_key_file_ref(GKeyFile *key_file ) ;
#line 62
extern void g_key_file_unref(GKeyFile *key_file ) ;
#line 64
extern void g_key_file_free(GKeyFile *key_file ) ;
#line 66
extern void g_key_file_set_list_separator(GKeyFile *key_file , gchar separator ) ;
#line 69
extern gboolean g_key_file_load_from_file(GKeyFile *key_file , gchar *file , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 74
extern gboolean g_key_file_load_from_data(GKeyFile *key_file , gchar *data , gsize length ,
                                          GKeyFileFlags flags , GError **error ) ;
#line 80
extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file , GBytes *bytes , GKeyFileFlags flags ,
                                           GError **error ) ;
#line 85
extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file , gchar *file , gchar **search_dirs ,
                                          gchar **full_path , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 92
extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file , gchar *file ,
                                               gchar **full_path , GKeyFileFlags flags ,
                                               GError **error ) ;
#line 98
extern gchar *g_key_file_to_data(GKeyFile *key_file , gsize *length , GError **error ) ;
#line 102
extern gboolean g_key_file_save_to_file(GKeyFile *key_file , gchar *filename , GError **error ) ;
#line 106
extern gchar *g_key_file_get_start_group(GKeyFile *key_file ) ;
#line 108
extern gchar **g_key_file_get_groups(GKeyFile *key_file , gsize *length ) ;
#line 111
extern gchar **g_key_file_get_keys(GKeyFile *key_file , gchar *group_name , gsize *length ,
                                   GError **error ) ;
#line 116
extern gboolean g_key_file_has_group(GKeyFile *key_file , gchar *group_name ) ;
#line 119
extern gboolean g_key_file_has_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 124
extern gchar *g_key_file_get_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 129
extern void g_key_file_set_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gchar *value ) ;
#line 134
extern gchar *g_key_file_get_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                    GError **error ) ;
#line 139
extern void g_key_file_set_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gchar *string ) ;
#line 144
extern gchar *g_key_file_get_locale_string(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gchar *locale , GError **error ) ;
#line 150
extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file , gchar *group_name ,
                                            gchar *key , gchar *locale ) ;
#line 155
extern void g_key_file_set_locale_string(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gchar *locale , gchar *string ) ;
#line 161
extern gboolean g_key_file_get_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       GError **error ) ;
#line 166
extern void g_key_file_set_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gboolean value ) ;
#line 171
extern gint g_key_file_get_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 176
extern void g_key_file_set_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gint value ) ;
#line 181
extern gint64 g_key_file_get_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 186
extern void g_key_file_set_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gint64 value ) ;
#line 191
extern guint64 g_key_file_get_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 196
extern void g_key_file_set_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  guint64 value ) ;
#line 201
extern gdouble g_key_file_get_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 206
extern void g_key_file_set_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gdouble value ) ;
#line 211
extern gchar **g_key_file_get_string_list(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , gsize *length , GError **error ) ;
#line 217
extern void g_key_file_set_string_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar * const  list[] , gsize length ) ;
#line 223
extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                                 gchar *key , gchar *locale , gsize *length ,
                                                 GError **error ) ;
#line 230
extern void g_key_file_set_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                              gchar *key , gchar *locale , gchar * const  list[] ,
                                              gsize length ) ;
#line 237
extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file , gchar *group_name ,
                                             gchar *key , gsize *length , GError **error ) ;
#line 243
extern void g_key_file_set_boolean_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gboolean list[] , gsize length ) ;
#line 249
extern gint *g_key_file_get_integer_list(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gsize *length , GError **error ) ;
#line 255
extern void g_key_file_set_double_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gdouble list[] , gsize length ) ;
#line 261
extern gdouble *g_key_file_get_double_list(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gsize *length , GError **error ) ;
#line 267
extern void g_key_file_set_integer_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gint list[] , gsize length ) ;
#line 273
extern gboolean g_key_file_set_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar *comment , GError **error ) ;
#line 279
extern gchar *g_key_file_get_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 285
extern gboolean g_key_file_remove_comment(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , GError **error ) ;
#line 290
extern gboolean g_key_file_remove_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                      GError **error ) ;
#line 295
extern gboolean g_key_file_remove_group(GKeyFile *key_file , gchar *group_name , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gmappedfile.h"
extern GMappedFile *g_mapped_file_new(gchar *filename , gboolean writable , GError **error ) ;
#line 39
extern GMappedFile *g_mapped_file_new_from_fd(gint fd , gboolean writable , GError **error ) ;
#line 43
extern gsize g_mapped_file_get_length(GMappedFile *file ) ;
#line 45
extern gchar *g_mapped_file_get_contents(GMappedFile *file ) ;
#line 47
extern GBytes *g_mapped_file_get_bytes(GMappedFile *file ) ;
#line 49
extern GMappedFile *g_mapped_file_ref(GMappedFile *file ) ;
#line 51
extern void g_mapped_file_unref(GMappedFile *file ) ;
#line 54
extern void g_mapped_file_free(GMappedFile *file ) ;
#line 73 "/usr/include/glib-2.0/glib/gmarkup.h"
extern GQuark g_markup_error_quark(void) ;
#line 187
extern GMarkupParseContext *g_markup_parse_context_new(GMarkupParser *parser , GMarkupParseFlags flags ,
                                                       gpointer user_data , GDestroyNotify user_data_dnotify ) ;
#line 192
extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context ) ;
#line 194
extern void g_markup_parse_context_unref(GMarkupParseContext *context ) ;
#line 196
extern void g_markup_parse_context_free(GMarkupParseContext *context ) ;
#line 198
extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context , gchar *text ,
                                             gssize text_len , GError **error ) ;
#line 203
extern void g_markup_parse_context_push(GMarkupParseContext *context , GMarkupParser *parser ,
                                        gpointer user_data ) ;
#line 207
extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context ) ;
#line 210
extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context , GError **error ) ;
#line 213
extern gchar *g_markup_parse_context_get_element(GMarkupParseContext *context ) ;
#line 215
extern GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context ) ;
#line 219
extern void g_markup_parse_context_get_position(GMarkupParseContext *context , gint *line_number ,
                                                gint *char_number ) ;
#line 223
extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context ) ;
#line 227
extern gchar *g_markup_escape_text(gchar *text , gssize length ) ;
#line 231
extern gchar *g_markup_printf_escaped(char const   *format  , ...) ;
#line 234
extern gchar *g_markup_vprintf_escaped(char const   *format , va_list args ) ;
#line 251
extern gboolean g_markup_collect_attributes(gchar *element_name , gchar **attribute_names ,
                                            gchar **attribute_values , GError **error ,
                                            GMarkupCollectType first_type , gchar *first_attr 
                                            , ...) ;
#line 296 "/usr/include/glib-2.0/glib/gvarianttype.h"
extern gboolean g_variant_type_string_is_valid(gchar *type_string ) ;
#line 298
extern gboolean g_variant_type_string_scan(gchar *string , gchar *limit , gchar **endptr ) ;
#line 304
extern void g_variant_type_free(GVariantType *type ) ;
#line 306
extern GVariantType *g_variant_type_copy(GVariantType *type ) ;
#line 308
extern GVariantType *g_variant_type_new(gchar *type_string ) ;
#line 312
extern gsize g_variant_type_get_string_length(GVariantType *type ) ;
#line 314
extern gchar *g_variant_type_peek_string(GVariantType *type ) ;
#line 316
extern gchar *g_variant_type_dup_string(GVariantType *type ) ;
#line 320
extern gboolean g_variant_type_is_definite(GVariantType *type ) ;
#line 322
extern gboolean g_variant_type_is_container(GVariantType *type ) ;
#line 324
extern gboolean g_variant_type_is_basic(GVariantType *type ) ;
#line 326
extern gboolean g_variant_type_is_maybe(GVariantType *type ) ;
#line 328
extern gboolean g_variant_type_is_array(GVariantType *type ) ;
#line 330
extern gboolean g_variant_type_is_tuple(GVariantType *type ) ;
#line 332
extern gboolean g_variant_type_is_dict_entry(GVariantType *type ) ;
#line 334
extern gboolean g_variant_type_is_variant(GVariantType *type ) ;
#line 338
extern guint g_variant_type_hash(gconstpointer type ) ;
#line 340
extern gboolean g_variant_type_equal(gconstpointer type1 , gconstpointer type2 ) ;
#line 345
extern gboolean g_variant_type_is_subtype_of(GVariantType *type , GVariantType *supertype ) ;
#line 350
extern GVariantType *g_variant_type_element(GVariantType *type ) ;
#line 352
extern GVariantType *g_variant_type_first(GVariantType *type ) ;
#line 354
extern GVariantType *g_variant_type_next(GVariantType *type ) ;
#line 356
extern gsize g_variant_type_n_items(GVariantType *type ) ;
#line 358
extern GVariantType *g_variant_type_key(GVariantType *type ) ;
#line 360
extern GVariantType *g_variant_type_value(GVariantType *type ) ;
#line 364
extern GVariantType *g_variant_type_new_array(GVariantType *element ) ;
#line 366
extern GVariantType *g_variant_type_new_maybe(GVariantType *element ) ;
#line 368
extern GVariantType *g_variant_type_new_tuple(GVariantType * const  *items , gint length ) ;
#line 371
extern GVariantType *g_variant_type_new_dict_entry(GVariantType *key , GVariantType *value ) ;
#line 376
extern GVariantType *g_variant_type_checked_(gchar * ) ;
#line 378
extern gsize g_variant_type_string_get_depth_(gchar *type_string ) ;
#line 59 "/usr/include/glib-2.0/glib/gvariant.h"
extern void g_variant_unref(GVariant *value ) ;
#line 61
extern GVariant *g_variant_ref(GVariant *value ) ;
#line 63
extern GVariant *g_variant_ref_sink(GVariant *value ) ;
#line 65
extern gboolean g_variant_is_floating(GVariant *value ) ;
#line 67
extern GVariant *g_variant_take_ref(GVariant *value ) ;
#line 70
extern GVariantType *g_variant_get_type(GVariant *value ) ;
#line 72
extern gchar *g_variant_get_type_string(GVariant *value ) ;
#line 74
extern gboolean g_variant_is_of_type(GVariant *value , GVariantType *type ) ;
#line 77
extern gboolean g_variant_is_container(GVariant *value ) ;
#line 79
extern GVariantClass g_variant_classify(GVariant *value ) ;
#line 81
extern GVariant *g_variant_new_boolean(gboolean value ) ;
#line 83
extern GVariant *g_variant_new_byte(guint8 value ) ;
#line 85
extern GVariant *g_variant_new_int16(gint16 value ) ;
#line 87
extern GVariant *g_variant_new_uint16(guint16 value ) ;
#line 89
extern GVariant *g_variant_new_int32(gint32 value ) ;
#line 91
extern GVariant *g_variant_new_uint32(guint32 value ) ;
#line 93
extern GVariant *g_variant_new_int64(gint64 value ) ;
#line 95
extern GVariant *g_variant_new_uint64(guint64 value ) ;
#line 97
extern GVariant *g_variant_new_handle(gint32 value ) ;
#line 99
extern GVariant *g_variant_new_double(gdouble value ) ;
#line 101
extern GVariant *g_variant_new_string(gchar *string ) ;
#line 103
extern GVariant *g_variant_new_take_string(gchar *string ) ;
#line 105
extern GVariant *g_variant_new_printf(gchar *format_string  , ...) ;
#line 108
extern GVariant *g_variant_new_object_path(gchar *object_path ) ;
#line 110
extern gboolean g_variant_is_object_path(gchar *string ) ;
#line 112
extern GVariant *g_variant_new_signature(gchar *signature ) ;
#line 114
extern gboolean g_variant_is_signature(gchar *string ) ;
#line 116
extern GVariant *g_variant_new_variant(GVariant *value ) ;
#line 118
extern GVariant *g_variant_new_strv(gchar * const  *strv , gssize length ) ;
#line 121
extern GVariant *g_variant_new_objv(gchar * const  *strv , gssize length ) ;
#line 124
extern GVariant *g_variant_new_bytestring(gchar *string ) ;
#line 126
extern GVariant *g_variant_new_bytestring_array(gchar * const  *strv , gssize length ) ;
#line 129
extern GVariant *g_variant_new_fixed_array(GVariantType *element_type , gconstpointer elements ,
                                           gsize n_elements , gsize element_size ) ;
#line 134
extern gboolean g_variant_get_boolean(GVariant *value ) ;
#line 136
extern guint8 g_variant_get_byte(GVariant *value ) ;
#line 138
extern gint16 g_variant_get_int16(GVariant *value ) ;
#line 140
extern guint16 g_variant_get_uint16(GVariant *value ) ;
#line 142
extern gint32 g_variant_get_int32(GVariant *value ) ;
#line 144
extern guint32 g_variant_get_uint32(GVariant *value ) ;
#line 146
extern gint64 g_variant_get_int64(GVariant *value ) ;
#line 148
extern guint64 g_variant_get_uint64(GVariant *value ) ;
#line 150
extern gint32 g_variant_get_handle(GVariant *value ) ;
#line 152
extern gdouble g_variant_get_double(GVariant *value ) ;
#line 154
extern GVariant *g_variant_get_variant(GVariant *value ) ;
#line 156
extern gchar *g_variant_get_string(GVariant *value , gsize *length ) ;
#line 159
extern gchar *g_variant_dup_string(GVariant *value , gsize *length ) ;
#line 162
extern gchar **g_variant_get_strv(GVariant *value , gsize *length ) ;
#line 165
extern gchar **g_variant_dup_strv(GVariant *value , gsize *length ) ;
#line 168
extern gchar **g_variant_get_objv(GVariant *value , gsize *length ) ;
#line 171
extern gchar **g_variant_dup_objv(GVariant *value , gsize *length ) ;
#line 174
extern gchar *g_variant_get_bytestring(GVariant *value ) ;
#line 176
extern gchar *g_variant_dup_bytestring(GVariant *value , gsize *length ) ;
#line 179
extern gchar **g_variant_get_bytestring_array(GVariant *value , gsize *length ) ;
#line 182
extern gchar **g_variant_dup_bytestring_array(GVariant *value , gsize *length ) ;
#line 186
extern GVariant *g_variant_new_maybe(GVariantType *child_type , GVariant *child ) ;
#line 189
extern GVariant *g_variant_new_array(GVariantType *child_type , GVariant * const  *children ,
                                     gsize n_children ) ;
#line 193
extern GVariant *g_variant_new_tuple(GVariant * const  *children , gsize n_children ) ;
#line 196
extern GVariant *g_variant_new_dict_entry(GVariant *key , GVariant *value ) ;
#line 200
extern GVariant *g_variant_get_maybe(GVariant *value ) ;
#line 202
extern gsize g_variant_n_children(GVariant *value ) ;
#line 204
extern void g_variant_get_child(GVariant *value , gsize index_ , gchar *format_string 
                                , ...) ;
#line 209
extern GVariant *g_variant_get_child_value(GVariant *value , gsize index_ ) ;
#line 212
extern gboolean g_variant_lookup(GVariant *dictionary , gchar *key , gchar *format_string 
                                 , ...) ;
#line 217
extern GVariant *g_variant_lookup_value(GVariant *dictionary , gchar *key , GVariantType *expected_type ) ;
#line 221
extern gconstpointer g_variant_get_fixed_array(GVariant *value , gsize *n_elements ,
                                               gsize element_size ) ;
#line 226
extern gsize g_variant_get_size(GVariant *value ) ;
#line 228
extern gconstpointer g_variant_get_data(GVariant *value ) ;
#line 230
extern GBytes *g_variant_get_data_as_bytes(GVariant *value ) ;
#line 232
extern void g_variant_store(GVariant *value , gpointer data ) ;
#line 236
extern gchar *g_variant_print(GVariant *value , gboolean type_annotate ) ;
#line 239
extern GString *g_variant_print_string(GVariant *value , GString *string , gboolean type_annotate ) ;
#line 244
extern guint g_variant_hash(gconstpointer value ) ;
#line 246
extern gboolean g_variant_equal(gconstpointer one , gconstpointer two ) ;
#line 250
extern GVariant *g_variant_get_normal_form(GVariant *value ) ;
#line 252
extern gboolean g_variant_is_normal_form(GVariant *value ) ;
#line 254
extern GVariant *g_variant_byteswap(GVariant *value ) ;
#line 257
extern GVariant *g_variant_new_from_bytes(GVariantType *type , GBytes *bytes , gboolean trusted ) ;
#line 261
extern GVariant *g_variant_new_from_data(GVariantType *type , gconstpointer data ,
                                         gsize size , gboolean trusted , GDestroyNotify notify ,
                                         gpointer user_data ) ;
#line 275
extern GVariantIter *g_variant_iter_new(GVariant *value ) ;
#line 277
extern gsize g_variant_iter_init(GVariantIter *iter , GVariant *value ) ;
#line 280
extern GVariantIter *g_variant_iter_copy(GVariantIter *iter ) ;
#line 282
extern gsize g_variant_iter_n_children(GVariantIter *iter ) ;
#line 284
extern void g_variant_iter_free(GVariantIter *iter ) ;
#line 286
extern GVariant *g_variant_iter_next_value(GVariantIter *iter ) ;
#line 288
extern gboolean g_variant_iter_next(GVariantIter *iter , gchar *format_string  , ...) ;
#line 292
extern gboolean g_variant_iter_loop(GVariantIter *iter , gchar *format_string  , ...) ;
#line 336
extern GQuark g_variant_parser_get_error_quark(void) ;
#line 339
extern GQuark g_variant_parse_error_quark(void) ;
#line 375
extern GVariantBuilder *g_variant_builder_new(GVariantType *type ) ;
#line 377
extern void g_variant_builder_unref(GVariantBuilder *builder ) ;
#line 379
extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder ) ;
#line 381
extern void g_variant_builder_init(GVariantBuilder *builder , GVariantType *type ) ;
#line 384
extern GVariant *g_variant_builder_end(GVariantBuilder *builder ) ;
#line 386
extern void g_variant_builder_clear(GVariantBuilder *builder ) ;
#line 388
extern void g_variant_builder_open(GVariantBuilder *builder , GVariantType *type ) ;
#line 391
extern void g_variant_builder_close(GVariantBuilder *builder ) ;
#line 393
extern void g_variant_builder_add_value(GVariantBuilder *builder , GVariant *value ) ;
#line 396
extern void g_variant_builder_add(GVariantBuilder *builder , gchar *format_string 
                                  , ...) ;
#line 400
extern void g_variant_builder_add_parsed(GVariantBuilder *builder , gchar *format 
                                         , ...) ;
#line 405
extern GVariant *g_variant_new(gchar *format_string  , ...) ;
#line 408
extern void g_variant_get(GVariant *value , gchar *format_string  , ...) ;
#line 412
extern GVariant *g_variant_new_va(gchar *format_string , gchar **endptr , va_list *app ) ;
#line 416
extern void g_variant_get_va(GVariant *value , gchar *format_string , gchar **endptr ,
                             va_list *app ) ;
#line 421
extern gboolean g_variant_check_format_string(GVariant *value , gchar *format_string ,
                                              gboolean copy_only ) ;
#line 426
extern GVariant *g_variant_parse(GVariantType *type , gchar *text , gchar *limit ,
                                 gchar **endptr , GError **error ) ;
#line 432
extern GVariant *g_variant_new_parsed(gchar *format  , ...) ;
#line 435
extern GVariant *g_variant_new_parsed_va(gchar *format , va_list *app ) ;
#line 439
extern gchar *g_variant_parse_error_print_context(GError *error , gchar *source_str ) ;
#line 443
extern gint g_variant_compare(gconstpointer one , gconstpointer two ) ;
#line 498
extern GVariantDict *g_variant_dict_new(GVariant *from_asv ) ;
#line 501
extern void g_variant_dict_init(GVariantDict *dict , GVariant *from_asv ) ;
#line 505
extern gboolean g_variant_dict_lookup(GVariantDict *dict , gchar *key , gchar *format_string 
                                      , ...) ;
#line 510
extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict , gchar *key , GVariantType *expected_type ) ;
#line 514
extern gboolean g_variant_dict_contains(GVariantDict *dict , gchar *key ) ;
#line 517
extern void g_variant_dict_insert(GVariantDict *dict , gchar *key , gchar *format_string 
                                  , ...) ;
#line 522
extern void g_variant_dict_insert_value(GVariantDict *dict , gchar *key , GVariant *value ) ;
#line 526
extern gboolean g_variant_dict_remove(GVariantDict *dict , gchar *key ) ;
#line 529
extern void g_variant_dict_clear(GVariantDict *dict ) ;
#line 531
extern GVariant *g_variant_dict_end(GVariantDict *dict ) ;
#line 533
extern GVariantDict *g_variant_dict_ref(GVariantDict *dict ) ;
#line 535
extern void g_variant_dict_unref(GVariantDict *dict ) ;
#line 43 "/usr/include/glib-2.0/glib/gmessages.h"
extern gsize g_printf_string_upper_bound(gchar *format , va_list args ) ;
#line 81
extern guint g_log_set_handler(gchar *log_domain , GLogLevelFlags log_levels , GLogFunc log_func ,
                               gpointer user_data ) ;
#line 86
extern guint g_log_set_handler_full(gchar *log_domain , GLogLevelFlags log_levels ,
                                    GLogFunc log_func , gpointer user_data , GDestroyNotify destroy ) ;
#line 92
extern void g_log_remove_handler(gchar *log_domain , guint handler_id ) ;
#line 95
extern void g_log_default_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                                  gpointer unused_data ) ;
#line 100
extern GLogFunc g_log_set_default_handler(GLogFunc log_func , gpointer user_data ) ;
#line 103
extern void g_log(gchar *log_domain , GLogLevelFlags log_level , gchar *format  , ...) ;
#line 108
extern void g_logv(gchar *log_domain , GLogLevelFlags log_level , gchar *format ,
                   va_list args ) ;
#line 113
extern GLogLevelFlags g_log_set_fatal_mask(gchar *log_domain , GLogLevelFlags fatal_mask ) ;
#line 116
extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask ) ;
#line 201
extern void g_log_structured(gchar *log_domain , GLogLevelFlags log_level  , ...) ;
#line 205
extern void g_log_structured_array(GLogLevelFlags log_level , GLogField *fields ,
                                   gsize n_fields ) ;
#line 210
extern void g_log_variant(gchar *log_domain , GLogLevelFlags log_level , GVariant *fields ) ;
#line 215
extern void g_log_set_writer_func(GLogWriterFunc func , gpointer user_data , GDestroyNotify user_data_free ) ;
#line 220
extern gboolean g_log_writer_supports_color(gint output_fd ) ;
#line 222
extern gboolean g_log_writer_is_journald(gint output_fd ) ;
#line 225
extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level , GLogField *fields ,
                                         gsize n_fields , gboolean use_color ) ;
#line 231
extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level , GLogField *fields ,
                                              gsize n_fields , gpointer user_data ) ;
#line 236
extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level , GLogField *fields ,
                                                      gsize n_fields , gpointer user_data ) ;
#line 241
extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level , GLogField *fields ,
                                             gsize n_fields , gpointer user_data ) ;
#line 247
extern void g_log_writer_default_set_use_stderr(gboolean use_stderr ) ;
#line 249
extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level , char const   *log_domain ) ;
#line 254
extern gboolean g_log_get_debug_enabled(void) ;
#line 256
extern void g_log_set_debug_enabled(gboolean enabled ) ;
#line 276
void _g_log_fallback_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                             gpointer unused_data ) ;
#line 283
extern void g_return_if_fail_warning(char const   *log_domain , char const   *pretty_function ,
                                     char const   *expression ) ;
#line 287
extern void g_warn_message(char const   *domain , char const   *file , int line ,
                           char const   *func , char const   *warnexpr ) ;
#line 294
extern void g_assert_warning(char const   *log_domain , char const   *file , int const   line ,
                             char const   *pretty_function , char const   *expression ) ;
#line 301
extern void g_log_structured_standard(gchar *log_domain , GLogLevelFlags log_level ,
                                      gchar *file , gchar *line , gchar *func , gchar *message_format 
                                      , ...) ;
#line 517
extern void g_print(gchar *format  , ...) ;
#line 520
extern GPrintFunc g_set_print_handler(GPrintFunc func ) ;
#line 522
extern void g_printerr(gchar *format  , ...) ;
#line 525
extern GPrintFunc g_set_printerr_handler(GPrintFunc func ) ;
#line 214 "/usr/include/glib-2.0/glib/goption.h"
extern GQuark g_option_error_quark(void) ;
#line 308
extern GOptionContext *g_option_context_new(gchar *parameter_string ) ;
#line 310
extern void g_option_context_set_summary(GOptionContext *context , gchar *summary ) ;
#line 313
extern gchar *g_option_context_get_summary(GOptionContext *context ) ;
#line 315
extern void g_option_context_set_description(GOptionContext *context , gchar *description ) ;
#line 318
extern gchar *g_option_context_get_description(GOptionContext *context ) ;
#line 320
extern void g_option_context_free(GOptionContext *context ) ;
#line 322
extern void g_option_context_set_help_enabled(GOptionContext *context , gboolean help_enabled ) ;
#line 325
extern gboolean g_option_context_get_help_enabled(GOptionContext *context ) ;
#line 327
extern void g_option_context_set_ignore_unknown_options(GOptionContext *context ,
                                                        gboolean ignore_unknown ) ;
#line 330
extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context ) ;
#line 333
extern void g_option_context_set_strict_posix(GOptionContext *context , gboolean strict_posix ) ;
#line 336
extern gboolean g_option_context_get_strict_posix(GOptionContext *context ) ;
#line 339
extern void g_option_context_add_main_entries(GOptionContext *context , GOptionEntry *entries ,
                                              gchar *translation_domain ) ;
#line 343
extern gboolean g_option_context_parse(GOptionContext *context , gint *argc , gchar ***argv ,
                                       GError **error ) ;
#line 348
extern gboolean g_option_context_parse_strv(GOptionContext *context , gchar ***arguments ,
                                            GError **error ) ;
#line 352
extern void g_option_context_set_translate_func(GOptionContext *context , GTranslateFunc func ,
                                                gpointer data , GDestroyNotify destroy_notify ) ;
#line 357
extern void g_option_context_set_translation_domain(GOptionContext *context , gchar *domain ) ;
#line 361
extern void g_option_context_add_group(GOptionContext *context , GOptionGroup *group ) ;
#line 364
extern void g_option_context_set_main_group(GOptionContext *context , GOptionGroup *group ) ;
#line 367
extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context ) ;
#line 369
extern gchar *g_option_context_get_help(GOptionContext *context , gboolean main_help ,
                                        GOptionGroup *group ) ;
#line 374
extern GOptionGroup *g_option_group_new(gchar *name , gchar *description , gchar *help_description ,
                                        gpointer user_data , GDestroyNotify destroy ) ;
#line 380
extern void g_option_group_set_parse_hooks(GOptionGroup *group , GOptionParseFunc pre_parse_func ,
                                           GOptionParseFunc post_parse_func ) ;
#line 384
extern void g_option_group_set_error_hook(GOptionGroup *group , GOptionErrorFunc error_func ) ;
#line 387
extern void g_option_group_free(GOptionGroup *group ) ;
#line 389
extern GOptionGroup *g_option_group_ref(GOptionGroup *group ) ;
#line 391
extern void g_option_group_unref(GOptionGroup *group ) ;
#line 393
extern void g_option_group_add_entries(GOptionGroup *group , GOptionEntry *entries ) ;
#line 396
extern void g_option_group_set_translate_func(GOptionGroup *group , GTranslateFunc func ,
                                              gpointer data , GDestroyNotify destroy_notify ) ;
#line 401
extern void g_option_group_set_translation_domain(GOptionGroup *group , gchar *domain ) ;
#line 33 "/usr/include/glib-2.0/glib/gpattern.h"
extern GPatternSpec *g_pattern_spec_new(gchar *pattern ) ;
#line 35
extern void g_pattern_spec_free(GPatternSpec *pspec ) ;
#line 37
extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec ) ;
#line 39
extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1 , GPatternSpec *pspec2 ) ;
#line 42
extern gboolean g_pattern_spec_match(GPatternSpec *pspec , gsize string_length , gchar *string ,
                                     gchar *string_reversed ) ;
#line 47
extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 50
extern gboolean g_pattern_match(GPatternSpec *pspec , guint string_length , gchar *string ,
                                gchar *string_reversed ) ;
#line 55
extern gboolean g_pattern_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 58
extern gboolean g_pattern_match_simple(gchar *pattern , gchar *string ) ;
#line 46 "/usr/include/glib-2.0/glib/gprimes.h"
extern guint g_spaced_primes_closest(guint num ) ;
#line 37 "/usr/include/glib-2.0/glib/gqsort.h"
extern void g_qsort_with_data(gconstpointer pbase , gint total_elems , gsize size ,
                              GCompareDataFunc compare_func , gpointer user_data ) ;
#line 73 "/usr/include/glib-2.0/glib/gqueue.h"
extern GQueue *g_queue_new(void) ;
#line 75
extern void g_queue_free(GQueue *queue ) ;
#line 77
extern void g_queue_free_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 80
extern void g_queue_init(GQueue *queue ) ;
#line 82
extern void g_queue_clear(GQueue *queue ) ;
#line 84
extern gboolean g_queue_is_empty(GQueue *queue ) ;
#line 86
extern void g_queue_clear_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 89
extern guint g_queue_get_length(GQueue *queue ) ;
#line 91
extern void g_queue_reverse(GQueue *queue ) ;
#line 93
extern GQueue *g_queue_copy(GQueue *queue ) ;
#line 95
extern void g_queue_foreach(GQueue *queue , GFunc func , gpointer user_data ) ;
#line 99
extern GList *g_queue_find(GQueue *queue , gconstpointer data ) ;
#line 102
extern GList *g_queue_find_custom(GQueue *queue , gconstpointer data , GCompareFunc func ) ;
#line 106
extern void g_queue_sort(GQueue *queue , GCompareDataFunc compare_func , gpointer user_data ) ;
#line 111
extern void g_queue_push_head(GQueue *queue , gpointer data ) ;
#line 114
extern void g_queue_push_tail(GQueue *queue , gpointer data ) ;
#line 117
extern void g_queue_push_nth(GQueue *queue , gpointer data , gint n ) ;
#line 121
extern gpointer g_queue_pop_head(GQueue *queue ) ;
#line 123
extern gpointer g_queue_pop_tail(GQueue *queue ) ;
#line 125
extern gpointer g_queue_pop_nth(GQueue *queue , guint n ) ;
#line 128
extern gpointer g_queue_peek_head(GQueue *queue ) ;
#line 130
extern gpointer g_queue_peek_tail(GQueue *queue ) ;
#line 132
extern gpointer g_queue_peek_nth(GQueue *queue , guint n ) ;
#line 135
extern gint g_queue_index(GQueue *queue , gconstpointer data ) ;
#line 138
extern gboolean g_queue_remove(GQueue *queue , gconstpointer data ) ;
#line 141
extern guint g_queue_remove_all(GQueue *queue , gconstpointer data ) ;
#line 144
extern void g_queue_insert_before(GQueue *queue , GList *sibling , gpointer data ) ;
#line 148
extern void g_queue_insert_before_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 153
extern void g_queue_insert_after(GQueue *queue , GList *sibling , gpointer data ) ;
#line 157
extern void g_queue_insert_after_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 162
extern void g_queue_insert_sorted(GQueue *queue , gpointer data , GCompareDataFunc func ,
                                  gpointer user_data ) ;
#line 168
extern void g_queue_push_head_link(GQueue *queue , GList *link_ ) ;
#line 171
extern void g_queue_push_tail_link(GQueue *queue , GList *link_ ) ;
#line 174
extern void g_queue_push_nth_link(GQueue *queue , gint n , GList *link_ ) ;
#line 178
extern GList *g_queue_pop_head_link(GQueue *queue ) ;
#line 180
extern GList *g_queue_pop_tail_link(GQueue *queue ) ;
#line 182
extern GList *g_queue_pop_nth_link(GQueue *queue , guint n ) ;
#line 185
extern GList *g_queue_peek_head_link(GQueue *queue ) ;
#line 187
extern GList *g_queue_peek_tail_link(GQueue *queue ) ;
#line 189
extern GList *g_queue_peek_nth_link(GQueue *queue , guint n ) ;
#line 192
extern gint g_queue_link_index(GQueue *queue , GList *link_ ) ;
#line 195
extern void g_queue_unlink(GQueue *queue , GList *link_ ) ;
#line 198
extern void g_queue_delete_link(GQueue *queue , GList *link_ ) ;
#line 48 "/usr/include/glib-2.0/glib/grand.h"
extern GRand *g_rand_new_with_seed(guint32 seed ) ;
#line 50
extern GRand *g_rand_new_with_seed_array(guint32 *seed , guint seed_length ) ;
#line 53
extern GRand *g_rand_new(void) ;
#line 55
extern void g_rand_free(GRand *rand_ ) ;
#line 57
extern GRand *g_rand_copy(GRand *rand_ ) ;
#line 59
extern void g_rand_set_seed(GRand *rand_ , guint32 seed ) ;
#line 62
extern void g_rand_set_seed_array(GRand *rand_ , guint32 *seed , guint seed_length ) ;
#line 69
extern guint32 g_rand_int(GRand *rand_ ) ;
#line 71
extern gint32 g_rand_int_range(GRand *rand_ , gint32 begin , gint32 end ) ;
#line 75
extern gdouble g_rand_double(GRand *rand_ ) ;
#line 77
extern gdouble g_rand_double_range(GRand *rand_ , gdouble begin , gdouble end ) ;
#line 81
extern void g_random_set_seed(guint32 seed ) ;
#line 86
extern guint32 g_random_int(void) ;
#line 88
extern gint32 g_random_int_range(gint32 begin , gint32 end ) ;
#line 91
extern gdouble g_random_double(void) ;
#line 93
extern gdouble g_random_double_range(gdouble begin , gdouble end ) ;
#line 31 "/usr/include/glib-2.0/glib/grcbox.h"
extern gpointer g_rc_box_alloc(gsize block_size ) ;
#line 33
extern gpointer g_rc_box_alloc0(gsize block_size ) ;
#line 35
extern gpointer g_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 38
extern gpointer g_rc_box_acquire(gpointer mem_block ) ;
#line 40
extern void g_rc_box_release(gpointer mem_block ) ;
#line 42
extern void g_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 46
extern gsize g_rc_box_get_size(gpointer mem_block ) ;
#line 49
extern gpointer g_atomic_rc_box_alloc(gsize block_size ) ;
#line 51
extern gpointer g_atomic_rc_box_alloc0(gsize block_size ) ;
#line 53
extern gpointer g_atomic_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 56
extern gpointer g_atomic_rc_box_acquire(gpointer mem_block ) ;
#line 58
extern void g_atomic_rc_box_release(gpointer mem_block ) ;
#line 60
extern void g_atomic_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 64
extern gsize g_atomic_rc_box_get_size(gpointer mem_block ) ;
#line 32 "/usr/include/glib-2.0/glib/grefcount.h"
extern void g_ref_count_init(grefcount *rc ) ;
#line 34
extern void g_ref_count_inc(grefcount *rc ) ;
#line 36
extern gboolean g_ref_count_dec(grefcount *rc ) ;
#line 38
extern gboolean g_ref_count_compare(grefcount *rc , gint val ) ;
#line 42
extern void g_atomic_ref_count_init(gatomicrefcount *arc ) ;
#line 44
extern void g_atomic_ref_count_inc(gatomicrefcount *arc ) ;
#line 46
extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc ) ;
#line 48
extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc , gint val ) ;
#line 27 "/usr/include/glib-2.0/glib/grefstring.h"
extern char *g_ref_string_new(char const   *str ) ;
#line 29
extern char *g_ref_string_new_len(char const   *str , gssize len ) ;
#line 32
extern char *g_ref_string_new_intern(char const   *str ) ;
#line 35
extern char *g_ref_string_acquire(char *str ) ;
#line 37
extern void g_ref_string_release(char *str ) ;
#line 40
extern gsize g_ref_string_length(char *str ) ;
#line 215 "/usr/include/glib-2.0/glib/gregex.h"
extern GQuark g_regex_error_quark(void) ;
#line 447
extern GRegex *g_regex_new(gchar *pattern , GRegexCompileFlags compile_options , GRegexMatchFlags match_options ,
                           GError **error ) ;
#line 452
extern GRegex *g_regex_ref(GRegex *regex ) ;
#line 454
extern void g_regex_unref(GRegex *regex ) ;
#line 456
extern gchar *g_regex_get_pattern(GRegex *regex ) ;
#line 458
extern gint g_regex_get_max_backref(GRegex *regex ) ;
#line 460
extern gint g_regex_get_capture_count(GRegex *regex ) ;
#line 462
extern gboolean g_regex_get_has_cr_or_lf(GRegex *regex ) ;
#line 464
extern gint g_regex_get_max_lookbehind(GRegex *regex ) ;
#line 466
extern gint g_regex_get_string_number(GRegex *regex , gchar *name ) ;
#line 469
extern gchar *g_regex_escape_string(gchar *string , gint length ) ;
#line 472
extern gchar *g_regex_escape_nul(gchar *string , gint length ) ;
#line 476
extern GRegexCompileFlags g_regex_get_compile_flags(GRegex *regex ) ;
#line 478
extern GRegexMatchFlags g_regex_get_match_flags(GRegex *regex ) ;
#line 482
extern gboolean g_regex_match_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                     GRegexMatchFlags match_options ) ;
#line 487
extern gboolean g_regex_match(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                              GMatchInfo **match_info ) ;
#line 492
extern gboolean g_regex_match_full(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GMatchInfo **match_info , GError **error ) ;
#line 500
extern gboolean g_regex_match_all(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                                  GMatchInfo **match_info ) ;
#line 505
extern gboolean g_regex_match_all_full(GRegex *regex , gchar *string , gssize string_len ,
                                       gint start_position , GRegexMatchFlags match_options ,
                                       GMatchInfo **match_info , GError **error ) ;
#line 515
extern gchar **g_regex_split_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                    GRegexMatchFlags match_options ) ;
#line 520
extern gchar **g_regex_split(GRegex *regex , gchar *string , GRegexMatchFlags match_options ) ;
#line 524
extern gchar **g_regex_split_full(GRegex *regex , gchar *string , gssize string_len ,
                                  gint start_position , GRegexMatchFlags match_options ,
                                  gint max_tokens , GError **error ) ;
#line 534
extern gchar *g_regex_replace(GRegex *regex , gchar *string , gssize string_len ,
                              gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                              GError **error ) ;
#line 542
extern gchar *g_regex_replace_literal(GRegex *regex , gchar *string , gssize string_len ,
                                      gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                                      GError **error ) ;
#line 550
extern gchar *g_regex_replace_eval(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GRegexEvalCallback eval , gpointer user_data ,
                                   GError **error ) ;
#line 559
extern gboolean g_regex_check_replacement(gchar *replacement , gboolean *has_references ,
                                          GError **error ) ;
#line 565
extern GRegex *g_match_info_get_regex(GMatchInfo *match_info ) ;
#line 567
extern gchar *g_match_info_get_string(GMatchInfo *match_info ) ;
#line 570
extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info ) ;
#line 572
extern void g_match_info_unref(GMatchInfo *match_info ) ;
#line 574
extern void g_match_info_free(GMatchInfo *match_info ) ;
#line 576
extern gboolean g_match_info_next(GMatchInfo *match_info , GError **error ) ;
#line 579
extern gboolean g_match_info_matches(GMatchInfo *match_info ) ;
#line 581
extern gint g_match_info_get_match_count(GMatchInfo *match_info ) ;
#line 583
extern gboolean g_match_info_is_partial_match(GMatchInfo *match_info ) ;
#line 585
extern gchar *g_match_info_expand_references(GMatchInfo *match_info , gchar *string_to_expand ,
                                             GError **error ) ;
#line 589
extern gchar *g_match_info_fetch(GMatchInfo *match_info , gint match_num ) ;
#line 592
extern gboolean g_match_info_fetch_pos(GMatchInfo *match_info , gint match_num , gint *start_pos ,
                                       gint *end_pos ) ;
#line 597
extern gchar *g_match_info_fetch_named(GMatchInfo *match_info , gchar *name ) ;
#line 600
extern gboolean g_match_info_fetch_named_pos(GMatchInfo *match_info , gchar *name ,
                                             gint *start_pos , gint *end_pos ) ;
#line 605
extern gchar **g_match_info_fetch_all(GMatchInfo *match_info ) ;
#line 214 "/usr/include/glib-2.0/glib/gscanner.h"
extern GScanner *g_scanner_new(GScannerConfig *config_templ ) ;
#line 216
extern void g_scanner_destroy(GScanner *scanner ) ;
#line 218
extern void g_scanner_input_file(GScanner *scanner , gint input_fd ) ;
#line 221
extern void g_scanner_sync_file_offset(GScanner *scanner ) ;
#line 223
extern void g_scanner_input_text(GScanner *scanner , gchar *text , guint text_len ) ;
#line 227
extern GTokenType g_scanner_get_next_token(GScanner *scanner ) ;
#line 229
extern GTokenType g_scanner_peek_next_token(GScanner *scanner ) ;
#line 231
extern GTokenType g_scanner_cur_token(GScanner *scanner ) ;
#line 233
extern GTokenValue g_scanner_cur_value(GScanner *scanner ) ;
#line 235
extern guint g_scanner_cur_line(GScanner *scanner ) ;
#line 237
extern guint g_scanner_cur_position(GScanner *scanner ) ;
#line 239
extern gboolean g_scanner_eof(GScanner *scanner ) ;
#line 241
extern guint g_scanner_set_scope(GScanner *scanner , guint scope_id ) ;
#line 244
extern void g_scanner_scope_add_symbol(GScanner *scanner , guint scope_id , gchar *symbol ,
                                       gpointer value ) ;
#line 249
extern void g_scanner_scope_remove_symbol(GScanner *scanner , guint scope_id , gchar *symbol ) ;
#line 253
extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner , guint scope_id ,
                                              gchar *symbol ) ;
#line 257
extern void g_scanner_scope_foreach_symbol(GScanner *scanner , guint scope_id , GHFunc func ,
                                           gpointer user_data ) ;
#line 262
extern gpointer g_scanner_lookup_symbol(GScanner *scanner , gchar *symbol ) ;
#line 265
extern void g_scanner_unexp_token(GScanner *scanner , GTokenType expected_token ,
                                  gchar *identifier_spec , gchar *symbol_spec , gchar *symbol_name ,
                                  gchar *message , gint is_error ) ;
#line 273
extern void g_scanner_error(GScanner *scanner , gchar *format  , ...) ;
#line 277
extern void g_scanner_warn(GScanner *scanner , gchar *format  , ...) ;
#line 40 "/usr/include/glib-2.0/glib/gsequence.h"
extern GSequence *g_sequence_new(GDestroyNotify data_destroy ) ;
#line 42
extern void g_sequence_free(GSequence *seq ) ;
#line 44
extern gint g_sequence_get_length(GSequence *seq ) ;
#line 46
extern void g_sequence_foreach(GSequence *seq , GFunc func , gpointer user_data ) ;
#line 50
extern void g_sequence_foreach_range(GSequenceIter *begin , GSequenceIter *end , GFunc func ,
                                     gpointer user_data ) ;
#line 55
extern void g_sequence_sort(GSequence *seq , GCompareDataFunc cmp_func , gpointer cmp_data ) ;
#line 59
extern void g_sequence_sort_iter(GSequence *seq , GSequenceIterCompareFunc cmp_func ,
                                 gpointer cmp_data ) ;
#line 63
extern gboolean g_sequence_is_empty(GSequence *seq ) ;
#line 68
extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq ) ;
#line 70
extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq ) ;
#line 72
extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq , gint pos ) ;
#line 75
extern GSequenceIter *g_sequence_append(GSequence *seq , gpointer data ) ;
#line 78
extern GSequenceIter *g_sequence_prepend(GSequence *seq , gpointer data ) ;
#line 81
extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter , gpointer data ) ;
#line 84
extern void g_sequence_move(GSequenceIter *src , GSequenceIter *dest ) ;
#line 87
extern void g_sequence_swap(GSequenceIter *a , GSequenceIter *b ) ;
#line 90
extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                               gpointer cmp_data ) ;
#line 95
extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq , gpointer data ,
                                                    GSequenceIterCompareFunc iter_cmp ,
                                                    gpointer cmp_data ) ;
#line 100
extern void g_sequence_sort_changed(GSequenceIter *iter , GCompareDataFunc cmp_func ,
                                    gpointer cmp_data ) ;
#line 104
extern void g_sequence_sort_changed_iter(GSequenceIter *iter , GSequenceIterCompareFunc iter_cmp ,
                                         gpointer cmp_data ) ;
#line 108
extern void g_sequence_remove(GSequenceIter *iter ) ;
#line 110
extern void g_sequence_remove_range(GSequenceIter *begin , GSequenceIter *end ) ;
#line 113
extern void g_sequence_move_range(GSequenceIter *dest , GSequenceIter *begin , GSequenceIter *end ) ;
#line 117
extern GSequenceIter *g_sequence_search(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 122
extern GSequenceIter *g_sequence_search_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 127
extern GSequenceIter *g_sequence_lookup(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 132
extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 140
extern gpointer g_sequence_get(GSequenceIter *iter ) ;
#line 142
extern void g_sequence_set(GSequenceIter *iter , gpointer data ) ;
#line 147
extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter ) ;
#line 149
extern gboolean g_sequence_iter_is_end(GSequenceIter *iter ) ;
#line 151
extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter ) ;
#line 153
extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter ) ;
#line 155
extern gint g_sequence_iter_get_position(GSequenceIter *iter ) ;
#line 157
extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter , gint delta ) ;
#line 160
extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter ) ;
#line 165
extern gint g_sequence_iter_compare(GSequenceIter *a , GSequenceIter *b ) ;
#line 168
extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin , GSequenceIter *end ) ;
#line 42 "/usr/include/glib-2.0/glib/gshell.h"
extern GQuark g_shell_error_quark(void) ;
#line 45
extern gchar *g_shell_quote(gchar *unquoted_string ) ;
#line 47
extern gchar *g_shell_unquote(gchar *quoted_string , GError **error ) ;
#line 50
extern gboolean g_shell_parse_argv(gchar *command_line , gint *argcp , gchar ***argvp ,
                                   GError **error ) ;
#line 33 "/usr/include/glib-2.0/glib/gslice.h"
extern gpointer g_slice_alloc(gsize block_size ) ;
#line 35
extern gpointer g_slice_alloc0(gsize block_size ) ;
#line 37
extern gpointer g_slice_copy(gsize block_size , gconstpointer mem_block ) ;
#line 40
extern void g_slice_free1(gsize block_size , gpointer mem_block ) ;
#line 43
extern void g_slice_free_chain_with_offset(gsize block_size , gpointer mem_chain ,
                                           gsize next_offset ) ;
#line 102
extern void g_slice_set_config(GSliceConfig ckey , gint64 value ) ;
#line 104
extern gint64 g_slice_get_config(GSliceConfig ckey ) ;
#line 106
extern gint64 *g_slice_get_config_state(GSliceConfig ckey , gint64 address , guint *n_values ) ;
#line 185 "/usr/include/glib-2.0/glib/gspawn.h"
extern GQuark g_spawn_error_quark(void) ;
#line 187
extern GQuark g_spawn_exit_error_quark(void) ;
#line 190
extern gboolean g_spawn_async(gchar *working_directory , gchar **argv , gchar **envp ,
                              GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                              gpointer user_data , GPid *child_pid , GError **error ) ;
#line 204
extern gboolean g_spawn_async_with_pipes(gchar *working_directory , gchar **argv ,
                                         gchar **envp , GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                         gpointer user_data , GPid *child_pid , gint *standard_input ,
                                         gint *standard_output , gint *standard_error ,
                                         GError **error ) ;
#line 217
extern gboolean g_spawn_async_with_pipes_and_fds(gchar *working_directory , gchar * const  *argv ,
                                                 gchar * const  *envp , GSpawnFlags flags ,
                                                 GSpawnChildSetupFunc child_setup ,
                                                 gpointer user_data , gint stdin_fd ,
                                                 gint stdout_fd , gint stderr_fd ,
                                                 gint *source_fds , gint *target_fds ,
                                                 gsize n_fds , GPid *child_pid_out ,
                                                 gint *stdin_pipe_out , gint *stdout_pipe_out ,
                                                 gint *stderr_pipe_out , GError **error ) ;
#line 237
extern gboolean g_spawn_async_with_fds(gchar *working_directory , gchar **argv , gchar **envp ,
                                       GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                       gpointer user_data , GPid *child_pid , gint stdin_fd ,
                                       gint stdout_fd , gint stderr_fd , GError **error ) ;
#line 254
extern gboolean g_spawn_sync(gchar *working_directory , gchar **argv , gchar **envp ,
                             GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                             gpointer user_data , gchar **standard_output , gchar **standard_error ,
                             gint *wait_status , GError **error ) ;
#line 266
extern gboolean g_spawn_command_line_sync(gchar *command_line , gchar **standard_output ,
                                          gchar **standard_error , gint *wait_status ,
                                          GError **error ) ;
#line 272
extern gboolean g_spawn_command_line_async(gchar *command_line , GError **error ) ;
#line 276
extern gboolean g_spawn_check_wait_status(gint wait_status , GError **error ) ;
#line 280
extern gboolean g_spawn_check_exit_status(gint wait_status , GError **error ) ;
#line 284
extern void g_spawn_close_pid(GPid pid ) ;
#line 54 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern guint16 * const  g_ascii_table ;
#line 90
extern gchar g_ascii_tolower(gchar c ) ;
#line 92
extern gchar g_ascii_toupper(gchar c ) ;
#line 95
extern gint g_ascii_digit_value(gchar c ) ;
#line 97
extern gint g_ascii_xdigit_value(gchar c ) ;
#line 104
extern gchar *g_strdelimit(gchar *string , gchar *delimiters , gchar new_delimiter ) ;
#line 108
extern gchar *g_strcanon(gchar *string , gchar *valid_chars , gchar substitutor ) ;
#line 112
extern gchar *g_strerror(gint errnum ) ;
#line 114
extern gchar *g_strsignal(gint signum ) ;
#line 116
extern gchar *g_strreverse(gchar *string ) ;
#line 118
extern gsize g_strlcpy(gchar *dest , gchar *src , gsize dest_size ) ;
#line 122
extern gsize g_strlcat(gchar *dest , gchar *src , gsize dest_size ) ;
#line 126
extern gchar *g_strstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 130
extern gchar *g_strrstr(gchar *haystack , gchar *needle ) ;
#line 133
extern gchar *g_strrstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 138
extern gboolean g_str_has_suffix(gchar *str , gchar *suffix ) ;
#line 141
extern gboolean g_str_has_prefix(gchar *str , gchar *prefix ) ;
#line 147
extern gdouble g_strtod(gchar *nptr , gchar **endptr ) ;
#line 150
extern gdouble g_ascii_strtod(gchar *nptr , gchar **endptr ) ;
#line 153
extern guint64 g_ascii_strtoull(gchar *nptr , gchar **endptr , guint base ) ;
#line 157
extern gint64 g_ascii_strtoll(gchar *nptr , gchar **endptr , guint base ) ;
#line 165
extern gchar *g_ascii_dtostr(gchar *buffer , gint buf_len , gdouble d ) ;
#line 169
extern gchar *g_ascii_formatd(gchar *buffer , gint buf_len , gchar *format , gdouble d ) ;
#line 176
extern gchar *g_strchug(gchar *string ) ;
#line 179
extern gchar *g_strchomp(gchar *string ) ;
#line 184
extern gint g_ascii_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 187
extern gint g_ascii_strncasecmp(gchar *s1 , gchar *s2 , gsize n ) ;
#line 191
extern gchar *g_ascii_strdown(gchar *str , gssize len ) ;
#line 194
extern gchar *g_ascii_strup(gchar *str , gssize len ) ;
#line 198
extern gboolean g_str_is_ascii(gchar *str ) ;
#line 201
extern gint g_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 204
extern gint g_strncasecmp(gchar *s1 , gchar *s2 , guint n ) ;
#line 208
extern gchar *g_strdown(gchar *string ) ;
#line 210
extern gchar *g_strup(gchar *string ) ;
#line 217
extern gchar *g_strdup(gchar *str ) ;
#line 219
extern gchar *g_strdup_printf(gchar *format  , ...) ;
#line 222
extern gchar *g_strdup_vprintf(gchar *format , va_list args ) ;
#line 225
extern gchar *g_strndup(gchar *str , gsize n ) ;
#line 228
extern gchar *g_strnfill(gsize length , gchar fill_char ) ;
#line 231
extern gchar *g_strconcat(gchar *string1  , ...) ;
#line 234
extern gchar *g_strjoin(gchar *separator  , ...) ;
#line 242
extern gchar *g_strcompress(gchar *source ) ;
#line 253
extern gchar *g_strescape(gchar *source , gchar *exceptions ) ;
#line 257
extern gpointer g_memdup(gconstpointer mem , guint byte_size ) ;
#line 261
extern gpointer g_memdup2(gconstpointer mem , gsize byte_size ) ;
#line 275
extern gchar **g_strsplit(gchar *string , gchar *delimiter , gint max_tokens ) ;
#line 279
extern gchar **g_strsplit_set(gchar *string , gchar *delimiters , gint max_tokens ) ;
#line 283
extern gchar *g_strjoinv(gchar *separator , gchar **str_array ) ;
#line 286
extern void g_strfreev(gchar **str_array ) ;
#line 288
extern gchar **g_strdupv(gchar **str_array ) ;
#line 290
extern guint g_strv_length(gchar **str_array ) ;
#line 293
extern gchar *g_stpcpy(gchar *dest , char const   *src ) ;
#line 297
extern gchar *g_str_to_ascii(gchar *str , gchar *from_locale ) ;
#line 301
extern gchar **g_str_tokenize_and_fold(gchar *string , gchar *translit_locale , gchar ***ascii_alternates ) ;
#line 306
extern gboolean g_str_match_string(gchar *search_term , gchar *potential_hit , gboolean accept_alternates ) ;
#line 311
extern gboolean g_strv_contains(gchar * const  *strv , gchar *str ) ;
#line 315
extern gboolean g_strv_equal(gchar * const  *strv1 , gchar * const  *strv2 ) ;
#line 346
extern GQuark g_number_parser_error_quark(void) ;
#line 349
extern gboolean g_ascii_string_to_signed(gchar *str , guint base , gint64 min , gint64 max ,
                                         gint64 *out_num , GError **error ) ;
#line 357
extern gboolean g_ascii_string_to_unsigned(gchar *str , guint base , guint64 min ,
                                           guint64 max , guint64 *out_num , GError **error ) ;
#line 39 "/usr/include/glib-2.0/glib/gstringchunk.h"
extern GStringChunk *g_string_chunk_new(gsize size ) ;
#line 41
extern void g_string_chunk_free(GStringChunk *chunk ) ;
#line 43
extern void g_string_chunk_clear(GStringChunk *chunk ) ;
#line 45
extern gchar *g_string_chunk_insert(GStringChunk *chunk , gchar *string ) ;
#line 48
extern gchar *g_string_chunk_insert_len(GStringChunk *chunk , gchar *string , gssize len ) ;
#line 52
extern gchar *g_string_chunk_insert_const(GStringChunk *chunk , gchar *string ) ;
#line 42 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
extern GStrvBuilder *g_strv_builder_new(void) ;
#line 45
extern void g_strv_builder_unref(GStrvBuilder *builder ) ;
#line 48
extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder ) ;
#line 51
extern void g_strv_builder_add(GStrvBuilder *builder , char const   *value ) ;
#line 55
extern void g_strv_builder_addv(GStrvBuilder *builder , char const   **value ) ;
#line 59
extern void g_strv_builder_add_many(GStrvBuilder *builder  , ...) ;
#line 63
extern GStrv g_strv_builder_end(GStrvBuilder *builder ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 239 "/usr/include/glib-2.0/glib/gtestutils.h"
extern int g_strcmp0(char const   *str1 , char const   *str2 ) ;
#line 244
extern void g_test_minimized_result(double minimized_quantity , char const   *format 
                                    , ...) ;
#line 248
extern void g_test_maximized_result(double maximized_quantity , char const   *format 
                                    , ...) ;
#line 254
extern void g_test_init(int *argc , char ***argv  , ...) ;
#line 321
extern gboolean g_test_subprocess(void) ;
#line 325
extern int g_test_run(void) ;
#line 328
extern void g_test_add_func(char const   *testpath , GTestFunc test_func ) ;
#line 332
extern void g_test_add_data_func(char const   *testpath , gconstpointer test_data ,
                                 GTestDataFunc test_func ) ;
#line 337
extern void g_test_add_data_func_full(char const   *testpath , gpointer test_data ,
                                      GTestDataFunc test_func , GDestroyNotify data_free_func ) ;
#line 344
extern char const   *g_test_get_path(void) ;
#line 348
extern void g_test_fail(void) ;
#line 350
extern void g_test_fail_printf(char const   *format  , ...) ;
#line 353
extern void g_test_incomplete(gchar *msg ) ;
#line 355
extern void g_test_incomplete_printf(char const   *format  , ...) ;
#line 358
extern void g_test_skip(gchar *msg ) ;
#line 360
extern void g_test_skip_printf(char const   *format  , ...) ;
#line 363
extern gboolean g_test_failed(void) ;
#line 365
extern void g_test_set_nonfatal_assertions(void) ;
#line 400
extern void g_test_message(char const   *format  , ...) ;
#line 403
extern void g_test_bug_base(char const   *uri_pattern ) ;
#line 405
extern void g_test_bug(char const   *bug_uri_snippet ) ;
#line 407
extern void g_test_summary(char const   *summary ) ;
#line 410
extern void g_test_timer_start(void) ;
#line 412
extern double g_test_timer_elapsed(void) ;
#line 414
extern double g_test_timer_last(void) ;
#line 418
extern void g_test_queue_free(gpointer gfree_pointer ) ;
#line 420
extern void g_test_queue_destroy(GDestroyNotify destroy_func , gpointer destroy_data ) ;
#line 454
extern gboolean g_test_trap_fork(guint64 usec_timeout , GTestTrapFlags test_trap_flags ) ;
#line 466
extern void g_test_trap_subprocess(char const   *test_path , guint64 usec_timeout ,
                                   GTestSubprocessFlags test_flags ) ;
#line 471
extern gboolean g_test_trap_has_passed(void) ;
#line 473
extern gboolean g_test_trap_reached_timeout(void) ;
#line 484
extern gint32 g_test_rand_int(void) ;
#line 486
extern gint32 g_test_rand_int_range(gint32 begin , gint32 end ) ;
#line 489
extern double g_test_rand_double(void) ;
#line 491
extern double g_test_rand_double_range(double range_start , double range_end ) ;
#line 500
extern GTestCase *g_test_create_case(char const   *test_name , gsize data_size , gconstpointer test_data ,
                                     GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                                     GTestFixtureFunc data_teardown ) ;
#line 507
extern GTestSuite *g_test_create_suite(char const   *suite_name ) ;
#line 509
extern GTestSuite *g_test_get_root(void) ;
#line 511
extern void g_test_suite_add(GTestSuite *suite , GTestCase *test_case ) ;
#line 514
extern void g_test_suite_add_suite(GTestSuite *suite , GTestSuite *nestedsuite ) ;
#line 517
extern int g_test_run_suite(GTestSuite *suite ) ;
#line 520
extern void g_test_case_free(GTestCase *test_case ) ;
#line 523
extern void g_test_suite_free(GTestSuite *suite ) ;
#line 526
extern void g_test_trap_assertions(char const   *domain , char const   *file , int line ,
                                   char const   *func , guint64 assertion_flags ,
                                   char const   *pattern ) ;
#line 533
extern void g_assertion_message(char const   *domain , char const   *file , int line ,
                                char const   *func , char const   *message ) ;
#line 540
extern void g_assertion_message_expr(char const   *domain , char const   *file , int line ,
                                     char const   *func , char const   *expr ) ;
#line 546
extern void g_assertion_message_cmpstr(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       char const   *arg1 , char const   *cmp , char const   *arg2 ) ;
#line 556
extern void g_assertion_message_cmpstrv(char const   *domain , char const   *file ,
                                        int line , char const   *func , char const   *expr ,
                                        char const   * const  *arg1 , char const   * const  *arg2 ,
                                        gsize first_wrong_idx ) ;
#line 565
extern void g_assertion_message_cmpnum(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       long double arg1 , char const   *cmp , long double arg2 ,
                                       char numtype ) ;
#line 575
extern void g_assertion_message_error(char const   *domain , char const   *file ,
                                      int line , char const   *func , char const   *expr ,
                                      GError *error , GQuark error_domain , int error_code ) ;
#line 584
extern void g_test_add_vtable(char const   *testpath , gsize data_size , gconstpointer test_data ,
                              GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                              GTestFixtureFunc data_teardown ) ;
#line 598
extern GTestConfig * const  g_test_config_vars ;
#line 637
extern char const   *g_test_log_type_name(GTestLogType log_type ) ;
#line 639
extern GTestLogBuffer *g_test_log_buffer_new(void) ;
#line 641
extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer ) ;
#line 643
extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer , guint n_bytes , guint8 *bytes ) ;
#line 647
extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer ) ;
#line 649
extern void g_test_log_msg_free(GTestLogMsg *tmsg ) ;
#line 670
extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func , gpointer user_data ) ;
#line 674
extern void g_test_expect_message(gchar *log_domain , GLogLevelFlags log_level , gchar *pattern ) ;
#line 678
extern void g_test_assert_expected_messages_internal(char const   *domain , char const   *file ,
                                                     int line , char const   *func ) ;
#line 690
extern gchar *g_test_build_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 694
extern gchar *g_test_get_dir(GTestFileType file_type ) ;
#line 696
extern gchar *g_test_get_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 49 "/usr/include/glib-2.0/glib/gthreadpool.h"
extern GThreadPool *g_thread_pool_new(GFunc func , gpointer user_data , gint max_threads ,
                                      gboolean exclusive , GError **error ) ;
#line 55
extern GThreadPool *g_thread_pool_new_full(GFunc func , gpointer user_data , GDestroyNotify item_free_func ,
                                           gint max_threads , gboolean exclusive ,
                                           GError **error ) ;
#line 62
extern void g_thread_pool_free(GThreadPool *pool , gboolean immediate , gboolean wait_ ) ;
#line 66
extern gboolean g_thread_pool_push(GThreadPool *pool , gpointer data , GError **error ) ;
#line 70
extern guint g_thread_pool_unprocessed(GThreadPool *pool ) ;
#line 72
extern void g_thread_pool_set_sort_function(GThreadPool *pool , GCompareDataFunc func ,
                                            gpointer user_data ) ;
#line 76
extern gboolean g_thread_pool_move_to_front(GThreadPool *pool , gpointer data ) ;
#line 80
extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool , gint max_threads ,
                                              GError **error ) ;
#line 84
extern gint g_thread_pool_get_max_threads(GThreadPool *pool ) ;
#line 86
extern guint g_thread_pool_get_num_threads(GThreadPool *pool ) ;
#line 89
extern void g_thread_pool_set_max_unused_threads(gint max_threads ) ;
#line 91
extern gint g_thread_pool_get_max_unused_threads(void) ;
#line 93
extern guint g_thread_pool_get_num_unused_threads(void) ;
#line 95
extern void g_thread_pool_stop_unused_threads(void) ;
#line 97
extern void g_thread_pool_set_max_idle_time(guint interval ) ;
#line 99
extern guint g_thread_pool_get_max_idle_time(void) ;
#line 45 "/usr/include/glib-2.0/glib/gtimer.h"
extern GTimer *g_timer_new(void) ;
#line 47
extern void g_timer_destroy(GTimer *timer ) ;
#line 49
extern void g_timer_start(GTimer *timer ) ;
#line 51
extern void g_timer_stop(GTimer *timer ) ;
#line 53
extern void g_timer_reset(GTimer *timer ) ;
#line 55
extern void g_timer_continue(GTimer *timer ) ;
#line 57
extern gdouble g_timer_elapsed(GTimer *timer , gulong *microseconds ) ;
#line 60
extern gboolean g_timer_is_active(GTimer *timer ) ;
#line 63
extern void g_usleep(gulong microseconds ) ;
#line 67
extern void g_time_val_add(GTimeVal *time_ , glong microseconds ) ;
#line 70
extern gboolean g_time_val_from_iso8601(gchar *iso_date , GTimeVal *time_ ) ;
#line 73
extern gchar *g_time_val_to_iso8601(GTimeVal *time_ ) ;
#line 45 "/usr/include/glib-2.0/glib/gtrashstack.h"
extern void g_trash_stack_push(GTrashStack **stack_p , gpointer data_p ) ;
#line 48
extern gpointer g_trash_stack_pop(GTrashStack **stack_p ) ;
#line 50
extern gpointer g_trash_stack_peek(GTrashStack **stack_p ) ;
#line 52
extern guint g_trash_stack_height(GTrashStack **stack_p ) ;
#line 72 "/usr/include/glib-2.0/glib/gtree.h"
extern GTree *g_tree_new(GCompareFunc key_compare_func ) ;
#line 74
extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func , gpointer key_compare_data ) ;
#line 77
extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func , gpointer key_compare_data ,
                              GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 82
extern GTreeNode *g_tree_node_first(GTree *tree ) ;
#line 84
extern GTreeNode *g_tree_node_last(GTree *tree ) ;
#line 86
extern GTreeNode *g_tree_node_previous(GTreeNode *node ) ;
#line 88
extern GTreeNode *g_tree_node_next(GTreeNode *node ) ;
#line 90
extern GTree *g_tree_ref(GTree *tree ) ;
#line 92
extern void g_tree_unref(GTree *tree ) ;
#line 94
extern void g_tree_destroy(GTree *tree ) ;
#line 96
extern GTreeNode *g_tree_insert_node(GTree *tree , gpointer key , gpointer value ) ;
#line 100
extern void g_tree_insert(GTree *tree , gpointer key , gpointer value ) ;
#line 104
extern GTreeNode *g_tree_replace_node(GTree *tree , gpointer key , gpointer value ) ;
#line 108
extern void g_tree_replace(GTree *tree , gpointer key , gpointer value ) ;
#line 112
extern gboolean g_tree_remove(GTree *tree , gconstpointer key ) ;
#line 116
extern void g_tree_remove_all(GTree *tree ) ;
#line 119
extern gboolean g_tree_steal(GTree *tree , gconstpointer key ) ;
#line 122
extern gpointer g_tree_node_key(GTreeNode *node ) ;
#line 124
extern gpointer g_tree_node_value(GTreeNode *node ) ;
#line 126
extern GTreeNode *g_tree_lookup_node(GTree *tree , gconstpointer key ) ;
#line 129
extern gpointer g_tree_lookup(GTree *tree , gconstpointer key ) ;
#line 132
extern gboolean g_tree_lookup_extended(GTree *tree , gconstpointer lookup_key , gpointer *orig_key ,
                                       gpointer *value ) ;
#line 137
extern void g_tree_foreach(GTree *tree , GTraverseFunc func , gpointer user_data ) ;
#line 141
extern void g_tree_foreach_node(GTree *tree , GTraverseNodeFunc func , gpointer user_data ) ;
#line 146
extern void g_tree_traverse(GTree *tree , GTraverseFunc traverse_func , GTraverseType traverse_type ,
                            gpointer user_data ) ;
#line 152
extern GTreeNode *g_tree_search_node(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 156
extern gpointer g_tree_search(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 160
extern GTreeNode *g_tree_lower_bound(GTree *tree , gconstpointer key ) ;
#line 163
extern GTreeNode *g_tree_upper_bound(GTree *tree , gconstpointer key ) ;
#line 166
extern gint g_tree_height(GTree *tree ) ;
#line 168
extern gint g_tree_nnodes(GTree *tree ) ;
#line 34 "/usr/include/glib-2.0/glib/guri.h"
extern GUri *g_uri_ref(GUri *uri ) ;
#line 36
extern void g_uri_unref(GUri *uri ) ;
#line 94
extern gboolean g_uri_split(gchar *uri_ref , GUriFlags flags , gchar **scheme , gchar **userinfo ,
                            gchar **host , gint *port , gchar **path , gchar **query ,
                            gchar **fragment , GError **error ) ;
#line 105
extern gboolean g_uri_split_with_user(gchar *uri_ref , GUriFlags flags , gchar **scheme ,
                                      gchar **user , gchar **password , gchar **auth_params ,
                                      gchar **host , gint *port , gchar **path , gchar **query ,
                                      gchar **fragment , GError **error ) ;
#line 118
extern gboolean g_uri_split_network(gchar *uri_string , GUriFlags flags , gchar **scheme ,
                                    gchar **host , gint *port , GError **error ) ;
#line 126
extern gboolean g_uri_is_valid(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 131
extern gchar *g_uri_join(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 140
extern gchar *g_uri_join_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 152
extern GUri *g_uri_parse(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 156
extern GUri *g_uri_parse_relative(GUri *base_uri , gchar *uri_ref , GUriFlags flags ,
                                  GError **error ) ;
#line 162
extern gchar *g_uri_resolve_relative(gchar *base_uri_string , gchar *uri_ref , GUriFlags flags ,
                                     GError **error ) ;
#line 168
extern GUri *g_uri_build(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 177
extern GUri *g_uri_build_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 215
extern char *g_uri_to_string(GUri *uri ) ;
#line 217
extern char *g_uri_to_string_partial(GUri *uri , GUriHideFlags flags ) ;
#line 221
extern gchar *g_uri_get_scheme(GUri *uri ) ;
#line 223
extern gchar *g_uri_get_userinfo(GUri *uri ) ;
#line 225
extern gchar *g_uri_get_user(GUri *uri ) ;
#line 227
extern gchar *g_uri_get_password(GUri *uri ) ;
#line 229
extern gchar *g_uri_get_auth_params(GUri *uri ) ;
#line 231
extern gchar *g_uri_get_host(GUri *uri ) ;
#line 233
extern gint g_uri_get_port(GUri *uri ) ;
#line 235
extern gchar *g_uri_get_path(GUri *uri ) ;
#line 237
extern gchar *g_uri_get_query(GUri *uri ) ;
#line 239
extern gchar *g_uri_get_fragment(GUri *uri ) ;
#line 241
extern GUriFlags g_uri_get_flags(GUri *uri ) ;
#line 265
extern GHashTable *g_uri_parse_params(gchar *params , gssize length , gchar *separators ,
                                      GUriParamsFlags flags , GError **error ) ;
#line 283
extern void g_uri_params_iter_init(GUriParamsIter *iter , gchar *params , gssize length ,
                                   gchar *separators , GUriParamsFlags flags ) ;
#line 290
extern gboolean g_uri_params_iter_next(GUriParamsIter *iter , gchar **attribute ,
                                       gchar **value , GError **error ) ;
#line 306
extern GQuark g_uri_error_quark(void) ;
#line 388
extern char *g_uri_unescape_string(char const   *escaped_string , char const   *illegal_characters ) ;
#line 391
extern char *g_uri_unescape_segment(char const   *escaped_string , char const   *escaped_string_end ,
                                    char const   *illegal_characters ) ;
#line 396
extern char *g_uri_parse_scheme(char const   *uri ) ;
#line 398
extern char const   *g_uri_peek_scheme(char const   *uri ) ;
#line 401
extern char *g_uri_escape_string(char const   *unescaped , char const   *reserved_chars_allowed ,
                                 gboolean allow_utf8 ) ;
#line 406
extern GBytes *g_uri_unescape_bytes(char const   *escaped_string , gssize length ,
                                    char const   *illegal_characters , GError **error ) ;
#line 412
extern char *g_uri_escape_bytes(guint8 *unescaped , gsize length , char const   *reserved_chars_allowed ) ;
#line 35 "/usr/include/glib-2.0/glib/guuid.h"
extern gboolean g_uuid_string_is_valid(gchar *str ) ;
#line 38
extern gchar *g_uuid_string_random(void) ;
#line 36 "/usr/include/glib-2.0/glib/gversion.h"
extern guint glib_major_version ;
#line 37
extern guint glib_minor_version ;
#line 38
extern guint glib_micro_version ;
#line 39
extern guint glib_interface_age ;
#line 40
extern guint glib_binary_age ;
#line 43
extern gchar *glib_check_version(guint required_major , guint required_minor , guint required_micro ) ;
#line 43 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
extern GMemChunk *g_mem_chunk_new(gchar *name , gint atom_size , gsize area_size ,
                                  gint type ) ;
#line 48
extern void g_mem_chunk_destroy(GMemChunk *mem_chunk ) ;
#line 50
extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk ) ;
#line 52
extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk ) ;
#line 54
extern void g_mem_chunk_free(GMemChunk *mem_chunk , gpointer mem ) ;
#line 57
extern void g_mem_chunk_clean(GMemChunk *mem_chunk ) ;
#line 59
extern void g_mem_chunk_reset(GMemChunk *mem_chunk ) ;
#line 61
extern void g_mem_chunk_print(GMemChunk *mem_chunk ) ;
#line 63
extern void g_mem_chunk_info(void) ;
#line 65
extern void g_blow_chunks(void) ;
#line 69
extern GAllocator *g_allocator_new(gchar *name , guint n_preallocs ) ;
#line 72
extern void g_allocator_free(GAllocator *allocator ) ;
#line 74
extern void g_list_push_allocator(GAllocator *allocator ) ;
#line 76
extern void g_list_pop_allocator(void) ;
#line 78
extern void g_slist_push_allocator(GAllocator *allocator ) ;
#line 80
extern void g_slist_pop_allocator(void) ;
#line 82
extern void g_node_push_allocator(GAllocator *allocator ) ;
#line 84
extern void g_node_pop_allocator(void) ;
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
extern GCache *g_cache_new(GCacheNewFunc value_new_func , GCacheDestroyFunc value_destroy_func ,
                           GCacheDupFunc key_dup_func , GCacheDestroyFunc key_destroy_func ,
                           GHashFunc hash_key_func , GHashFunc hash_value_func , GEqualFunc key_equal_func ) ;
#line 55
extern void g_cache_destroy(GCache *cache ) ;
#line 57
extern gpointer g_cache_insert(GCache *cache , gpointer key ) ;
#line 60
extern void g_cache_remove(GCache *cache , gconstpointer value ) ;
#line 63
extern void g_cache_key_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 67
extern void g_cache_value_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 58 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
extern GCompletion *g_completion_new(GCompletionFunc func ) ;
#line 60
extern void g_completion_add_items(GCompletion *cmp , GList *items ) ;
#line 63
extern void g_completion_remove_items(GCompletion *cmp , GList *items ) ;
#line 66
extern void g_completion_clear_items(GCompletion *cmp ) ;
#line 68
extern GList *g_completion_complete(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 72
extern GList *g_completion_complete_utf8(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 76
extern void g_completion_set_compare(GCompletion *cmp , GCompletionStrncmpFunc strncmp_func ) ;
#line 79
extern void g_completion_free(GCompletion *cmp ) ;
#line 68 "/usr/include/glib-2.0/glib/deprecated/grel.h"
extern GRelation *g_relation_new(gint fields ) ;
#line 70
extern void g_relation_destroy(GRelation *relation ) ;
#line 72
extern void g_relation_index(GRelation *relation , gint field , GHashFunc hash_func ,
                             GEqualFunc key_equal_func ) ;
#line 77
extern void g_relation_insert(GRelation *relation  , ...) ;
#line 80
extern gint g_relation_delete(GRelation *relation , gconstpointer key , gint field ) ;
#line 84
extern GTuples *g_relation_select(GRelation *relation , gconstpointer key , gint field ) ;
#line 88
extern gint g_relation_count(GRelation *relation , gconstpointer key , gint field ) ;
#line 92
extern gboolean g_relation_exists(GRelation *relation  , ...) ;
#line 95
extern void g_relation_print(GRelation *relation ) ;
#line 97
extern void g_tuples_destroy(GTuples *tuples ) ;
#line 99
extern gpointer g_tuples_index(GTuples *tuples , gint index_ , gint field ) ;
#line 94 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern GThreadFunctions g_thread_functions_for_glib_use ;
#line 95
extern gboolean g_thread_use_default_impl ;
#line 97
extern guint64 (*g_thread_gettime)(void) ;
#line 100
extern GThread *g_thread_create(GThreadFunc func , gpointer data , gboolean joinable ,
                                GError **error ) ;
#line 106
extern GThread *g_thread_create_full(GThreadFunc func , gpointer data , gulong stack_size ,
                                     gboolean joinable , gboolean bound , GThreadPriority priority ,
                                     GError **error ) ;
#line 115
extern void g_thread_set_priority(GThread *thread , GThreadPriority priority ) ;
#line 119
extern void g_thread_foreach(GFunc thread_func , gpointer user_data ) ;
#line 150
extern void g_static_mutex_init(GStaticMutex *mutex ) ;
#line 152
extern void g_static_mutex_free(GStaticMutex *mutex ) ;
#line 154
extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex ) ;
#line 176
extern void g_static_rec_mutex_init(GStaticRecMutex *mutex ) ;
#line 179
extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex ) ;
#line 182
extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex ) ;
#line 185
extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex ) ;
#line 188
extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex , guint depth ) ;
#line 192
extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex ) ;
#line 195
extern void g_static_rec_mutex_free(GStaticRecMutex *mutex ) ;
#line 213
extern void g_static_rw_lock_init(GStaticRWLock *lock ) ;
#line 216
extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock ) ;
#line 219
extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock ) ;
#line 222
extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock ) ;
#line 225
extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock ) ;
#line 228
extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock ) ;
#line 231
extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock ) ;
#line 234
extern void g_static_rw_lock_free(GStaticRWLock *lock ) ;
#line 237
extern GPrivate *g_private_new(GDestroyNotify notify ) ;
#line 248
extern void g_static_private_init(GStaticPrivate *private_key ) ;
#line 251
extern gpointer g_static_private_get(GStaticPrivate *private_key ) ;
#line 254
extern void g_static_private_set(GStaticPrivate *private_key , gpointer data , GDestroyNotify notify ) ;
#line 259
extern void g_static_private_free(GStaticPrivate *private_key ) ;
#line 262
extern gboolean g_once_init_enter_impl(gsize *location ) ;
#line 265
extern void g_thread_init(gpointer vtable ) ;
#line 267
extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable ) ;
#line 270
extern gboolean g_thread_get_initialized(void) ;
#line 272
extern gboolean g_threads_got_initialized ;
#line 277
extern GMutex *g_mutex_new(void) ;
#line 279
extern void g_mutex_free(GMutex *mutex ) ;
#line 281
extern GCond *g_cond_new(void) ;
#line 283
extern void g_cond_free(GCond *cond ) ;
#line 285
extern gboolean g_cond_timed_wait(GCond *cond , GMutex *mutex , GTimeVal *timeval ) ;
#line 25 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_generic_gfree(void *p ) 
{ 
  void **pp ;

  {
  {
#line 27
  pp = (void **)p;
#line 28
  g_free(*pp);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_gstring_free(GString *string ) 
{ 


  {
#line 34
  if (string) {
    {
#line 35
    g_string_free(string, ! 0);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncQueue(GAsyncQueue *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_async_queue_unref((GAsyncQueue *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncQueue(GAsyncQueue **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GAsyncQueue(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GAsyncQueue(GList **_l ) 
{ 


  {
  {
#line 45
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GAsyncQueue(GSList **_l ) 
{ 


  {
  {
#line 45
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GAsyncQueue(GQueue **_q ) 
{ 


  {
#line 45
  if (*_q) {
    {
#line 45
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBookmarkFile(GBookmarkFile *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_bookmark_file_free((GBookmarkFile *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBookmarkFile(GBookmarkFile **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GBookmarkFile(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBookmarkFile(GList **_l ) 
{ 


  {
  {
#line 46
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBookmarkFile(GSList **_l ) 
{ 


  {
  {
#line 46
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBookmarkFile(GQueue **_q ) 
{ 


  {
#line 46
  if (*_q) {
    {
#line 46
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBytes(GBytes *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_bytes_unref((GBytes *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytes(GBytes **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GBytes(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBytes(GList **_l ) 
{ 


  {
  {
#line 47
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBytes(GSList **_l ) 
{ 


  {
  {
#line 47
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBytes(GQueue **_q ) 
{ 


  {
#line 47
  if (*_q) {
    {
#line 47
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GChecksum(GChecksum *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_checksum_free((GChecksum *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GChecksum(GChecksum **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GChecksum(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GChecksum(GList **_l ) 
{ 


  {
  {
#line 48
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GChecksum(GSList **_l ) 
{ 


  {
  {
#line 48
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GChecksum(GQueue **_q ) 
{ 


  {
#line 48
  if (*_q) {
    {
#line 48
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDateTime(GDateTime *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_date_time_unref((GDateTime *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDateTime(GDateTime **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDateTime(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDateTime(GList **_l ) 
{ 


  {
  {
#line 49
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDateTime(GSList **_l ) 
{ 


  {
  {
#line 49
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDateTime(GQueue **_q ) 
{ 


  {
#line 49
  if (*_q) {
    {
#line 49
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDate(GDate *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_date_free((GDate *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDate(GDate **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDate(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDate(GList **_l ) 
{ 


  {
  {
#line 50
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDate(GSList **_l ) 
{ 


  {
  {
#line 50
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDate(GQueue **_q ) 
{ 


  {
#line 50
  if (*_q) {
    {
#line 50
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_free)));
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDir(GDir *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_dir_close((GDir *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDir(GDir **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDir(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDir(GList **_l ) 
{ 


  {
  {
#line 51
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDir(GSList **_l ) 
{ 


  {
  {
#line 51
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDir(GQueue **_q ) 
{ 


  {
#line 51
  if (*_q) {
    {
#line 51
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GError(GError *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_error_free((GError *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GError(GError **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GError(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GError(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GError(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GError(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_error_free)));
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHashTable(GHashTable *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_hash_table_unref((GHashTable *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHashTable(GHashTable **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GHashTable(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHashTable(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHashTable(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHashTable(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHmac(GHmac *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_hmac_unref((GHmac *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHmac(GHmac **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GHmac(*_ptr);
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHmac(GList **_l ) 
{ 


  {
  {
#line 54
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHmac(GSList **_l ) 
{ 


  {
  {
#line 54
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHmac(GQueue **_q ) 
{ 


  {
#line 54
  if (*_q) {
    {
#line 54
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GIOChannel(GIOChannel *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_io_channel_unref((GIOChannel *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOChannel(GIOChannel **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GIOChannel(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GIOChannel(GList **_l ) 
{ 


  {
  {
#line 55
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GIOChannel(GSList **_l ) 
{ 


  {
  {
#line 55
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GIOChannel(GQueue **_q ) 
{ 


  {
#line 55
  if (*_q) {
    {
#line 55
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GKeyFile(GKeyFile *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_key_file_unref((GKeyFile *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GKeyFile(GKeyFile **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GKeyFile(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GKeyFile(GList **_l ) 
{ 


  {
  {
#line 56
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GKeyFile(GSList **_l ) 
{ 


  {
  {
#line 56
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GKeyFile(GQueue **_q ) 
{ 


  {
#line 56
  if (*_q) {
    {
#line 56
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GList(GList *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_list_free((GList *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GList(GList **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GList(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GList(GList **_l ) 
{ 


  {
  {
#line 57
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GList(GSList **_l ) 
{ 


  {
  {
#line 57
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GList(GQueue **_q ) 
{ 


  {
#line 57
  if (*_q) {
    {
#line 57
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_list_free)));
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GArray(GArray *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_array_unref((GArray *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GArray(GArray **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GArray(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GArray(GList **_l ) 
{ 


  {
  {
#line 58
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GArray(GSList **_l ) 
{ 


  {
  {
#line 58
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GArray(GQueue **_q ) 
{ 


  {
#line 58
  if (*_q) {
    {
#line 58
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPtrArray(GPtrArray *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_ptr_array_unref((GPtrArray *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPtrArray(GPtrArray **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GPtrArray(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPtrArray(GList **_l ) 
{ 


  {
  {
#line 59
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPtrArray(GSList **_l ) 
{ 


  {
  {
#line 59
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPtrArray(GQueue **_q ) 
{ 


  {
#line 59
  if (*_q) {
    {
#line 59
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GByteArray(GByteArray *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_byte_array_unref((GByteArray *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GByteArray(GByteArray **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GByteArray(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GByteArray(GList **_l ) 
{ 


  {
  {
#line 60
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GByteArray(GSList **_l ) 
{ 


  {
  {
#line 60
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GByteArray(GQueue **_q ) 
{ 


  {
#line 60
  if (*_q) {
    {
#line 60
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContext(GMainContext *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_main_context_unref((GMainContext *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContext(GMainContext **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GMainContext(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContext(GList **_l ) 
{ 


  {
  {
#line 61
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContext(GSList **_l ) 
{ 


  {
  {
#line 61
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContext(GQueue **_q ) 
{ 


  {
#line 61
  if (*_q) {
    {
#line 61
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContextPusher(GMainContextPusher *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_main_context_pusher_free((GMainContextPusher *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContextPusher(GMainContextPusher **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GMainContextPusher(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContextPusher(GList **_l ) 
{ 


  {
  {
#line 62
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContextPusher(GSList **_l ) 
{ 


  {
  {
#line 62
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContextPusher(GQueue **_q ) 
{ 


  {
#line 62
  if (*_q) {
    {
#line 62
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainLoop(GMainLoop *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_main_loop_unref((GMainLoop *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainLoop(GMainLoop **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GMainLoop(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainLoop(GList **_l ) 
{ 


  {
  {
#line 63
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainLoop(GSList **_l ) 
{ 


  {
  {
#line 63
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainLoop(GQueue **_q ) 
{ 


  {
#line 63
  if (*_q) {
    {
#line 63
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSource(GSource *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_source_unref((GSource *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSource(GSource **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GSource(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSource(GList **_l ) 
{ 


  {
  {
#line 64
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSource(GSList **_l ) 
{ 


  {
  {
#line 64
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSource(GQueue **_q ) 
{ 


  {
#line 64
  if (*_q) {
    {
#line 64
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMappedFile(GMappedFile *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_mapped_file_unref((GMappedFile *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMappedFile(GMappedFile **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GMappedFile(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMappedFile(GList **_l ) 
{ 


  {
  {
#line 65
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMappedFile(GSList **_l ) 
{ 


  {
  {
#line 65
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMappedFile(GQueue **_q ) 
{ 


  {
#line 65
  if (*_q) {
    {
#line 65
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMarkupParseContext(GMarkupParseContext *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_markup_parse_context_unref((GMarkupParseContext *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMarkupParseContext(GMarkupParseContext **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GMarkupParseContext(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMarkupParseContext(GList **_l ) 
{ 


  {
  {
#line 66
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMarkupParseContext(GSList **_l ) 
{ 


  {
  {
#line 66
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMarkupParseContext(GQueue **_q ) 
{ 


  {
#line 66
  if (*_q) {
    {
#line 66
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GNode(GNode *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_node_destroy((GNode *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNode(GNode **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GNode(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GNode(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GNode(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GNode(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionContext(GOptionContext *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_option_context_free((GOptionContext *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionContext(GOptionContext **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GOptionContext(*_ptr);
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionContext(GList **_l ) 
{ 


  {
  {
#line 68
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionContext(GSList **_l ) 
{ 


  {
  {
#line 68
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionContext(GQueue **_q ) 
{ 


  {
#line 68
  if (*_q) {
    {
#line 68
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionGroup(GOptionGroup *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_option_group_unref((GOptionGroup *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionGroup(GOptionGroup **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GOptionGroup(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionGroup(GList **_l ) 
{ 


  {
  {
#line 69
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionGroup(GSList **_l ) 
{ 


  {
  {
#line 69
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionGroup(GQueue **_q ) 
{ 


  {
#line 69
  if (*_q) {
    {
#line 69
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPatternSpec(GPatternSpec *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_pattern_spec_free((GPatternSpec *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPatternSpec(GPatternSpec **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GPatternSpec(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPatternSpec(GList **_l ) 
{ 


  {
  {
#line 70
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPatternSpec(GSList **_l ) 
{ 


  {
  {
#line 70
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPatternSpec(GQueue **_q ) 
{ 


  {
#line 70
  if (*_q) {
    {
#line 70
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GQueue(GQueue *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_queue_free((GQueue *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GQueue(GQueue **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GQueue(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GQueue(GList **_l ) 
{ 


  {
  {
#line 71
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GQueue(GSList **_l ) 
{ 


  {
  {
#line 71
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GQueue(GQueue **_q ) 
{ 


  {
#line 71
  if (*_q) {
    {
#line 71
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GQueue(GQueue *_ptr ) 
{ 


  {
  {
#line 72
  g_queue_clear(_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRand(GRand *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_rand_free((GRand *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRand(GRand **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GRand(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRand(GList **_l ) 
{ 


  {
  {
#line 73
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRand(GSList **_l ) 
{ 


  {
  {
#line 73
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRand(GQueue **_q ) 
{ 


  {
#line 73
  if (*_q) {
    {
#line 73
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRegex(GRegex *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_regex_unref((GRegex *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRegex(GRegex **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GRegex(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRegex(GList **_l ) 
{ 


  {
  {
#line 74
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRegex(GSList **_l ) 
{ 


  {
  {
#line 74
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRegex(GQueue **_q ) 
{ 


  {
#line 74
  if (*_q) {
    {
#line 74
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMatchInfo(GMatchInfo *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_match_info_unref((GMatchInfo *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMatchInfo(GMatchInfo **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GMatchInfo(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMatchInfo(GList **_l ) 
{ 


  {
  {
#line 75
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMatchInfo(GSList **_l ) 
{ 


  {
  {
#line 75
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMatchInfo(GQueue **_q ) 
{ 


  {
#line 75
  if (*_q) {
    {
#line 75
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GScanner(GScanner *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_scanner_destroy((GScanner *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GScanner(GScanner **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GScanner(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GScanner(GList **_l ) 
{ 


  {
  {
#line 76
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GScanner(GSList **_l ) 
{ 


  {
  {
#line 76
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GScanner(GQueue **_q ) 
{ 


  {
#line 76
  if (*_q) {
    {
#line 76
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSequence(GSequence *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_sequence_free((GSequence *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSequence(GSequence **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GSequence(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSequence(GList **_l ) 
{ 


  {
  {
#line 77
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSequence(GSList **_l ) 
{ 


  {
  {
#line 77
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSequence(GQueue **_q ) 
{ 


  {
#line 77
  if (*_q) {
    {
#line 77
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSList(GSList *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_slist_free((GSList *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSList(GSList **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GSList(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSList(GList **_l ) 
{ 


  {
  {
#line 78
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSList(GSList **_l ) 
{ 


  {
  {
#line 78
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSList(GQueue **_q ) 
{ 


  {
#line 78
  if (*_q) {
    {
#line 78
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GString(GString *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_autoptr_cleanup_gstring_free((GString *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GString(GString **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GString(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GString(GList **_l ) 
{ 


  {
  {
#line 79
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GString(GSList **_l ) 
{ 


  {
  {
#line 79
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GString(GQueue **_q ) 
{ 


  {
#line 79
  if (*_q) {
    {
#line 79
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStringChunk(GStringChunk *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_string_chunk_free((GStringChunk *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStringChunk(GStringChunk **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GStringChunk(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStringChunk(GList **_l ) 
{ 


  {
  {
#line 80
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStringChunk(GSList **_l ) 
{ 


  {
  {
#line 80
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStringChunk(GQueue **_q ) 
{ 


  {
#line 80
  if (*_q) {
    {
#line 80
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStrvBuilder(GStrvBuilder *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_strv_builder_unref((GStrvBuilder *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStrvBuilder(GStrvBuilder **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GStrvBuilder(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStrvBuilder(GList **_l ) 
{ 


  {
  {
#line 81
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStrvBuilder(GSList **_l ) 
{ 


  {
  {
#line 81
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStrvBuilder(GQueue **_q ) 
{ 


  {
#line 81
  if (*_q) {
    {
#line 81
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GThread(GThread *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_thread_unref((GThread *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThread(GThread **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GThread(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GThread(GList **_l ) 
{ 


  {
  {
#line 82
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GThread(GSList **_l ) 
{ 


  {
  {
#line 82
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GThread(GQueue **_q ) 
{ 


  {
#line 82
  if (*_q) {
    {
#line 82
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GMutex(GMutex *_ptr ) 
{ 


  {
  {
#line 83
  g_mutex_clear(_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMutexLocker(GMutexLocker *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_mutex_locker_free((GMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMutexLocker(GMutexLocker **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GMutexLocker(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMutexLocker(GList **_l ) 
{ 


  {
  {
#line 84
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 84
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMutexLocker(GQueue **_q ) 
{ 


  {
#line 84
  if (*_q) {
    {
#line 84
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRecMutexLocker(GRecMutexLocker *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_rec_mutex_locker_free((GRecMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRecMutexLocker(GRecMutexLocker **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GRecMutexLocker(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRecMutexLocker(GList **_l ) 
{ 


  {
  {
#line 85
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRecMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 85
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRecMutexLocker(GQueue **_q ) 
{ 


  {
#line 85
  if (*_q) {
    {
#line 85
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockWriterLocker(GRWLockWriterLocker *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_rw_lock_writer_locker_free((GRWLockWriterLocker *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockWriterLocker(GRWLockWriterLocker **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GRWLockWriterLocker(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockWriterLocker(GList **_l ) 
{ 


  {
  {
#line 86
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockWriterLocker(GSList **_l ) 
{ 


  {
  {
#line 86
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockWriterLocker(GQueue **_q ) 
{ 


  {
#line 86
  if (*_q) {
    {
#line 86
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockReaderLocker(GRWLockReaderLocker *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_rw_lock_reader_locker_free((GRWLockReaderLocker *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockReaderLocker(GRWLockReaderLocker **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GRWLockReaderLocker(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockReaderLocker(GList **_l ) 
{ 


  {
  {
#line 87
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockReaderLocker(GSList **_l ) 
{ 


  {
  {
#line 87
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockReaderLocker(GQueue **_q ) 
{ 


  {
#line 87
  if (*_q) {
    {
#line 87
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GCond(GCond *_ptr ) 
{ 


  {
  {
#line 88
  g_cond_clear(_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimer(GTimer *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_timer_destroy((GTimer *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimer(GTimer **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GTimer(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimer(GList **_l ) 
{ 


  {
  {
#line 89
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimer(GSList **_l ) 
{ 


  {
  {
#line 89
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimer(GQueue **_q ) 
{ 


  {
#line 89
  if (*_q) {
    {
#line 89
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimeZone(GTimeZone *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_time_zone_unref((GTimeZone *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimeZone(GTimeZone **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GTimeZone(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimeZone(GList **_l ) 
{ 


  {
  {
#line 90
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimeZone(GSList **_l ) 
{ 


  {
  {
#line 90
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimeZone(GQueue **_q ) 
{ 


  {
#line 90
  if (*_q) {
    {
#line 90
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTree(GTree *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_tree_unref((GTree *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTree(GTree **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GTree(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTree(GList **_l ) 
{ 


  {
  {
#line 91
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTree(GSList **_l ) 
{ 


  {
  {
#line 91
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTree(GQueue **_q ) 
{ 


  {
#line 91
  if (*_q) {
    {
#line 91
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariant(GVariant *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_variant_unref((GVariant *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariant(GVariant **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GVariant(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariant(GList **_l ) 
{ 


  {
  {
#line 92
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariant(GSList **_l ) 
{ 


  {
  {
#line 92
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariant(GQueue **_q ) 
{ 


  {
#line 92
  if (*_q) {
    {
#line 92
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_variant_builder_unref((GVariantBuilder *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantBuilder(GVariantBuilder **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GVariantBuilder(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantBuilder(GList **_l ) 
{ 


  {
  {
#line 93
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantBuilder(GSList **_l ) 
{ 


  {
  {
#line 93
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantBuilder(GQueue **_q ) 
{ 


  {
#line 93
  if (*_q) {
    {
#line 93
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
  {
#line 94
  g_variant_builder_clear(_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantIter(GVariantIter *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_variant_iter_free((GVariantIter *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantIter(GVariantIter **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GVariantIter(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantIter(GList **_l ) 
{ 


  {
  {
#line 95
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantIter(GSList **_l ) 
{ 


  {
  {
#line 95
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantIter(GQueue **_q ) 
{ 


  {
#line 95
  if (*_q) {
    {
#line 95
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_variant_dict_unref((GVariantDict *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantDict(GVariantDict **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GVariantDict(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantDict(GList **_l ) 
{ 


  {
  {
#line 96
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantDict(GSList **_l ) 
{ 


  {
  {
#line 96
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantDict(GQueue **_q ) 
{ 


  {
#line 96
  if (*_q) {
    {
#line 96
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
  {
#line 97
  g_variant_dict_clear(_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantType(GVariantType *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_variant_type_free((GVariantType *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantType(GVariantType **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GVariantType(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantType(GList **_l ) 
{ 


  {
  {
#line 98
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantType(GSList **_l ) 
{ 


  {
  {
#line 98
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantType(GQueue **_q ) 
{ 


  {
#line 98
  if (*_q) {
    {
#line 98
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GStrv(GStrv *_ptr ) 
{ 


  {
#line 99
  if (*_ptr != (void *)0) {
    {
#line 99
    g_strfreev(*_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRefString(GRefString *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_ref_string_release((GRefString *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRefString(GRefString **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GRefString(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRefString(GList **_l ) 
{ 


  {
  {
#line 100
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRefString(GSList **_l ) 
{ 


  {
  {
#line 100
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRefString(GQueue **_q ) 
{ 


  {
#line 100
  if (*_q) {
    {
#line 100
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GUri(GUri *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_uri_unref((GUri *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GUri(GUri **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GUri(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GUri(GList **_l ) 
{ 


  {
  {
#line 101
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GUri(GSList **_l ) 
{ 


  {
  {
#line 101
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GUri(GQueue **_q ) 
{ 


  {
#line 101
  if (*_q) {
    {
#line 101
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
    }
  }
  return;
}
}
#line 136 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.h"
AudioID *module_audio_id ;
#line 165
int module_speak_queue_init(int maxsize , char **status_info ) ;
#line 169
int module_speak_queue_before_synth(void) ;
#line 173
int module_speak_queue_before_play(void) ;
#line 176
gboolean module_speak_queue_add_audio(AudioTrack *track , AudioFormat format ) ;
#line 177
gboolean module_speak_queue_add_mark(char const   *markId ) ;
#line 178
gboolean module_speak_queue_add_sound_icon(char const   *filename ) ;
#line 180
gboolean module_speak_queue_add_end(void) ;
#line 183
int module_speak_queue_stop_requested(void) ;
#line 187
void module_speak_queue_stop(void) ;
#line 190
void module_speak_queue_pause(void) ;
#line 193
void module_speak_queue_terminate(void) ;
#line 196
void module_speak_queue_free(void) ;
#line 199
void module_speak_queue_flush(void) ;
#line 204
void module_speak_queue_cancel(void) ;
#line 29 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/common.h"
void MSG(int level , char const   *format  , ...) ;
#line 30
void MSG2(int level , char const   *kind , char const   *format  , ...) ;
#line 33
int spd_pthread_create(pthread_t *thread , pthread_attr_t *attr , void *(*start_routine)(void * ) ,
                       void *arg ) ;
#line 36
void set_speaking_thread_parameters(void) ;
#line 39
void module_report_index_mark(char const   *mark ) ;
#line 41
void module_report_event_begin(void) ;
#line 43
void module_report_event_end(void) ;
#line 45
void module_report_event_stop(void) ;
#line 47
void module_report_event_pause(void) ;
#line 49
void module_report_icon(char const   *icon ) ;
#line 51
int module_play_file(char const   *filename ) ;
#line 35 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.h"
AudioID *spd_audio_open(char const   *name , void **pars , char **error ) ;
#line 37
int spd_audio_play(AudioID *id , AudioTrack track , AudioFormat format ) ;
#line 39
int spd_audio_begin(AudioID *id , AudioTrack track , AudioFormat format ) ;
#line 40
int spd_audio_feed_sync(AudioID *id , AudioTrack track , AudioFormat format ) ;
#line 41
int spd_audio_feed_sync_overlap(AudioID *id , AudioTrack track , AudioFormat format ) ;
#line 42
int spd_audio_end(AudioID *id ) ;
#line 44
int spd_audio_stop(AudioID *id ) ;
#line 46
int spd_audio_close(AudioID *id ) ;
#line 48
int spd_audio_set_volume(AudioID *id , int volume ) ;
#line 50
void spd_audio_set_loglevel(AudioID *id , int level ) ;
#line 52
char const   *spd_audio_get_playcmd(AudioID *id ) ;
#line 49 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_mutex_t speak_queue_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 51 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static speak_queue_state_t speak_queue_state  =    (speak_queue_state_t )0;
#line 52 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_configured  =    0;
#line 54
static pthread_t speak_queue_play_thread ;
#line 55
static pthread_t speak_queue_stop_or_pause_thread ;
#line 58 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_cond_t speak_queue_stop_or_pause_cond  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 60
static int speak_queue_stop_or_pause_sleeping ;
#line 63 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_cond_t speak_queue_play_cond  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 65 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_cond_t speak_queue_play_sleeping_cond  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 66
static int speak_queue_play_sleeping ;
#line 68 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_close_requested  =    0;
#line 69 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static speak_queue_pause_state_t speak_queue_pause_state  =    (speak_queue_pause_state_t )0;
#line 70 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_stop_requested  =    0;
#line 71 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_flush_requested  =    0;
#line 73
void module_speak_queue_reset(void) ;
#line 77
static int speak_queue_maxsize ;
#line 79 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static GSList *playback_queue  =    (GSList *)((void *)0);
#line 80 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static int playback_queue_size  =    0;
#line 84 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_cond_t playback_queue_room_condition  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 86 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static pthread_cond_t playback_queue_data_condition  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 89
static gboolean speak_queue_add_flag_to_playback_queue(speak_queue_entry_type type ) ;
#line 90
static void speak_queue_delete_playback_queue_entry(speak_queue_entry *playback_queue_entry ) ;
#line 92
static gboolean speak_queue_send_to_audio(speak_queue_entry *playback_queue_entry ) ;
#line 96
static void speak_queue_clear_playback_queue(void) ;
#line 99
static void *speak_queue_play(void *nothing ) ;
#line 101
static void *speak_queue_stop_or_pause(void *nothing ) ;
#line 103 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
int module_speak_queue_init(int maxsize , char **status_info ) 
{ 
  int ret ;
  int __cil_tmp4 ;
  gchar *__cil_tmp5 ;
  int __cil_tmp6 ;
  gchar *__cil_tmp7 ;

  {
  {
#line 107
  speak_queue_maxsize = maxsize;
#line 110
  module_speak_queue_reset();
#line 112
  MSG(4, "speak_queue Creating new thread for stop or pause.");
#line 113
  speak_queue_stop_or_pause_sleeping = 0;
#line 115
  ret = spd_pthread_create(& speak_queue_stop_or_pause_thread, (pthread_attr_t *)((void *)0),
                           & speak_queue_stop_or_pause, (void *)0);
  }
#line 118
  if (0 != ret) {
    {
#line 119
    MSG(4, "Failed to create stop-or-pause thread.");
#line 120
    *status_info = g_strdup((gchar *)"Failed to create stop-or-pause thread.");
    }
#line 122
    return (- 1);
  }
  {
#line 125
  speak_queue_play_sleeping = 0;
#line 127
  MSG(4, "speak_queue Creating new thread for playback.");
#line 128
  ret = spd_pthread_create(& speak_queue_play_thread, (pthread_attr_t *)((void *)0),
                           & speak_queue_play, (void *)0);
  }
#line 129
  if (ret != 0) {
    {
#line 130
    MSG(4, "Failed to create playback thread.");
#line 131
    *status_info = g_strdup((gchar *)"Failed to create playback thread.");
    }
#line 132
    return (- 1);
  }
#line 135
  return (0);
}
}
#line 138 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_reset(void) 
{ 


  {
#line 140
  speak_queue_state = (speak_queue_state_t )0;
#line 141
  speak_queue_pause_state = (speak_queue_pause_state_t )0;
#line 142
  speak_queue_stop_requested = 0;
#line 143
  speak_queue_flush_requested = 0;
  return;
}
}
#line 146 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
int module_speak_queue_before_synth(void) 
{ 


  {
  {
#line 148
  pthread_mutex_lock(& speak_queue_mutex);
  }
#line 149
  if ((unsigned int )speak_queue_state != 0U) {
    {
#line 150
    MSG(4, "speak_queue Warning, module_speak called when not ready.");
#line 151
    pthread_mutex_unlock(& speak_queue_mutex);
    }
#line 152
    return (0);
  }
  {
#line 155
  module_speak_queue_reset();
#line 156
  speak_queue_state = (speak_queue_state_t )1;
#line 157
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 158
  return (! 0);
}
}
#line 161 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
int module_speak_queue_before_play(void) 
{ 
  int ret ;

  {
  {
#line 163
  ret = 0;
#line 164
  pthread_mutex_lock(& speak_queue_mutex);
  }
#line 165
  if ((unsigned int )speak_queue_state == 1U) {
    {
#line 166
    ret = 1;
#line 167
    speak_queue_state = (speak_queue_state_t )2;
#line 168
    speak_queue_add_flag_to_playback_queue((speak_queue_entry_type )3);
#line 170
    pthread_cond_signal(& speak_queue_play_cond);
    }
  }
  {
#line 172
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 173
  return (ret);
}
}
#line 176 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
gboolean module_speak_queue_add_end(void) 
{ 
  gboolean ret ;
  gboolean __cil_tmp2 ;

  {
  {
#line 178
  pthread_mutex_lock(& speak_queue_mutex);
#line 179
  __cil_tmp2 = speak_queue_add_flag_to_playback_queue((speak_queue_entry_type )4);
#line 179
  ret = __cil_tmp2;
#line 180
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 181
  return (ret);
}
}
#line 184 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static speak_queue_entry *playback_queue_pop(void) 
{ 
  speak_queue_entry *result ;
  GSList *__cil_tmp2 ;

  {
  {
#line 186
  result = (speak_queue_entry *)((void *)0);
#line 187
  pthread_mutex_lock(& speak_queue_mutex);
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! (playback_queue == (void *)0 && ! speak_queue_stop_requested)) {
#line 188
      goto while_break;
    }
    {
#line 189
    pthread_cond_wait(& playback_queue_data_condition, & speak_queue_mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (! speak_queue_stop_requested) {
    {
#line 193
    result = (speak_queue_entry *)playback_queue->data;
#line 194
    playback_queue = g_slist_remove(playback_queue, playback_queue->data);
    }
#line 196
    if ((unsigned int )result->type == 0U) {
      {
#line 197
      playback_queue_size -= result->data.audio.track.num_samples;
#line 198
      pthread_cond_broadcast(& playback_queue_room_condition);
      }
    }
  }
  {
#line 201
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 202
  return (result);
}
}
#line 205 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean playback_queue_push(speak_queue_entry *entry ) 
{ 
  GSList *__cil_tmp2 ;

  {
  {
#line 207
  playback_queue = g_slist_append(playback_queue, entry);
  }
#line 208
  if ((unsigned int )entry->type == 0U) {
#line 209
    playback_queue_size += entry->data.audio.track.num_samples;
  }
  {
#line 211
  pthread_cond_signal(& playback_queue_data_condition);
  }
#line 212
  return (! 0);
}
}
#line 218 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
gboolean module_speak_queue_add_audio(AudioTrack *track , AudioFormat format ) 
{ 
  speak_queue_entry *playback_queue_entry ;
  gint nbytes ;
  gpointer __cil_tmp5 ;

  {
  {
#line 220
  pthread_mutex_lock(& speak_queue_mutex);
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (playback_queue_size > speak_queue_maxsize)) {
#line 221
      goto while_break;
    }
#line 222
    if ((unsigned int )speak_queue_state == 0U) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& speak_queue_mutex);
      }
      }
      }
#line 226
      return (0);
    } else
#line 222
    if (speak_queue_stop_requested) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& speak_queue_mutex);
      }
      }
      }
#line 226
      return (0);
    } else
#line 222
    if (speak_queue_flush_requested) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& speak_queue_mutex);
      }
      }
      }
#line 226
      return (0);
    }
    {
#line 228
    pthread_cond_wait(& playback_queue_room_condition, & speak_queue_mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if ((unsigned int )speak_queue_state == 0U) {
    {
    {
    {
#line 232
    pthread_mutex_unlock(& speak_queue_mutex);
    }
    }
    }
#line 233
    return (0);
  } else
#line 231
  if (speak_queue_stop_requested) {
    {
    {
    {
#line 232
    pthread_mutex_unlock(& speak_queue_mutex);
    }
    }
    }
#line 233
    return (0);
  } else
#line 231
  if (speak_queue_flush_requested) {
    {
    {
    {
#line 232
    pthread_mutex_unlock(& speak_queue_mutex);
    }
    }
    }
#line 233
    return (0);
  }
  {
#line 236
  playback_queue_entry = (speak_queue_entry *)0;
#line 239
  playback_queue_entry->type = (speak_queue_entry_type )0;
#line 240
  playback_queue_entry->data.audio.track = *track;
#line 241
  nbytes = (track->bits / 8) * track->num_samples;
#line 243
  playback_queue_entry->data.audio.track.samples = (short *)g_memdup2(track->samples,
                                                                      (gsize )nbytes);
#line 247
  playback_queue_entry->data.audio.format = format;
#line 249
  playback_queue_push(playback_queue_entry);
#line 250
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 251
  return (! 0);
}
}
#line 255 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
gboolean module_speak_queue_add_mark(char const   *markId ) 
{ 
  speak_queue_entry *playback_queue_entry ;
  gpointer __cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gboolean ret ;
  gboolean __cil_tmp6 ;

  {
  {
#line 257
  __cil_tmp3 = g_malloc(sizeof(speak_queue_entry ));
#line 257
  playback_queue_entry = (speak_queue_entry *)__cil_tmp3;
#line 260
  playback_queue_entry->type = (speak_queue_entry_type )1;
#line 261
  playback_queue_entry->data.markId = g_strdup(markId);
#line 262
  pthread_mutex_lock(& speak_queue_mutex);
#line 263
  __cil_tmp6 = playback_queue_push(playback_queue_entry);
#line 263
  ret = __cil_tmp6;
#line 264
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 265
  return (ret);
}
}
#line 269 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_add_flag_to_playback_queue(speak_queue_entry_type type ) 
{ 
  speak_queue_entry *playback_queue_entry ;
  gpointer __cil_tmp3 ;
  gboolean __cil_tmp4 ;

  {
  {
#line 271
  __cil_tmp3 = g_malloc(sizeof(speak_queue_entry ));
#line 271
  playback_queue_entry = (speak_queue_entry *)__cil_tmp3;
#line 274
  playback_queue_entry->type = type;
#line 275
  __cil_tmp4 = playback_queue_push(playback_queue_entry);
  }
#line 275
  return (__cil_tmp4);
}
}
#line 279 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
gboolean module_speak_queue_add_sound_icon(char const   *filename ) 
{ 
  speak_queue_entry *playback_queue_entry ;
  gpointer __cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gboolean ret ;
  gboolean __cil_tmp6 ;

  {
  {
#line 281
  __cil_tmp3 = g_malloc(sizeof(speak_queue_entry ));
#line 281
  playback_queue_entry = (speak_queue_entry *)__cil_tmp3;
#line 284
  playback_queue_entry->type = (speak_queue_entry_type )2;
#line 285
  playback_queue_entry->data.sound_icon_filename = g_strdup(filename);
#line 286
  pthread_mutex_lock(& speak_queue_mutex);
#line 287
  __cil_tmp6 = playback_queue_push(playback_queue_entry);
#line 287
  ret = __cil_tmp6;
#line 288
  pthread_mutex_unlock(& speak_queue_mutex);
  }
#line 289
  return (ret);
}
}
#line 294 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static void speak_queue_delete_playback_queue_entry(speak_queue_entry *playback_queue_entry ) 
{ 


  {
  {
#line 297
  if ((unsigned int )playback_queue_entry->type == (unsigned int )0) {
#line 297
    goto case_0;
  }
#line 300
  if ((unsigned int )playback_queue_entry->type == (unsigned int )1) {
#line 300
    goto case_1;
  }
#line 303
  if ((unsigned int )playback_queue_entry->type == (unsigned int )2) {
#line 303
    goto case_2;
  }
#line 306
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 298
  g_free(playback_queue_entry->data.audio.track.samples);
  }
#line 299
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 301
  g_free(playback_queue_entry->data.markId);
  }
#line 302
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 304
  g_free(playback_queue_entry->data.sound_icon_filename);
  }
#line 305
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 307
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 309
  g_free(playback_queue_entry);
  }
  return;
}
}
#line 313 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static void speak_queue_clear_playback_queue(void) 
{ 
  speak_queue_entry *playback_queue_entry ;
  GSList *__cil_tmp2 ;

  {
  {
#line 315
  pthread_mutex_lock(& speak_queue_mutex);
  }
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! ((void *)0 != playback_queue)) {
#line 317
      goto while_break;
    }
    {
#line 318
    playback_queue_entry = playback_queue->data;
#line 320
    speak_queue_delete_playback_queue_entry(playback_queue_entry);
#line 321
    playback_queue = g_slist_remove(playback_queue, playback_queue->data);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  playback_queue = (GSList *)((void *)0);
#line 325
  playback_queue_size = 0;
#line 326
  pthread_cond_broadcast(& playback_queue_room_condition);
#line 327
  pthread_mutex_unlock(& speak_queue_mutex);
  }
  return;
}
}
#line 331 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_send_track_to_audio(AudioTrack *track , AudioFormat format ) 
{ 
  int ret ;
  int __cil_tmp4 ;

  {
  {
#line 333
  ret = 0;
#line 334
  MSG(4, "speak_queue Sending %i samples to audio.", track->num_samples);
  }
#line 336
  if (! speak_queue_configured) {
    {
#line 338
    spd_audio_begin(module_audio_id, *track, format);
#line 339
    speak_queue_configured = ! 0;
    }
  }
  {
#line 341
  ret = spd_audio_feed_sync_overlap(module_audio_id, *track, format);
  }
#line 342
  if (ret < 0) {
    {
#line 343
    MSG(4, "ERROR: Can\'t play track for unknown reason.{\332U");
    }
#line 344
    return (0);
  }
  {
#line 346
  MSG(4, "speak_queue Sent to audio.");
  }
#line 347
  return (! 0);
}
}
#line 351 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_send_file_to_audio(char const   *filename ) 
{ 
  gboolean result ;
  int subformat ;
  sf_count_t items ;
  sf_count_t readcount ;
  SNDFILE *sf ;
  SF_INFO sfinfo ;
  SNDFILE *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  AudioTrack track ;
  gpointer __cil_tmp11 ;
  sf_count_t __cil_tmp12 ;
  int ret ;
  gboolean __cil_tmp14 ;

  {
  {
#line 353
  result = 0;
#line 360
  MSG(4, "Playing |%s|", filename);
#line 361
  memset(& sfinfo, 0, sizeof(sfinfo));
#line 362
  sf = sf_open(filename, 16, & sfinfo);
  }
#line 363
  if ((void *)0 == sf) {
    {
#line 364
    __cil_tmp9 = sf_strerror((SNDFILE *)((void *)0));
#line 364
    MSG(4, "%sp{\332U", __cil_tmp9);
    }
#line 365
    return (- 1);
  }
#line 367
  if (sfinfo.channels < 1) {
    {
    {
#line 368
    MSG(4, "ERROR: channels = %d.\n", sfinfo.channels);
    }
#line 369
    result = 0;
    }
#line 370
    goto cleanup1;
  } else
#line 367
  if (sfinfo.channels > 2) {
    {
    {
#line 368
    MSG(4, "ERROR: channels = %d.\n", sfinfo.channels);
    }
#line 369
    result = 0;
    }
#line 370
    goto cleanup1;
  }
#line 372
  if (sfinfo.frames > 2147483647L) {
    {
    {
#line 373
    MSG(4, "ERROR: Unknown number of frames.\220");
    }
#line 374
    result = 0;
    }
#line 375
    goto cleanup1;
  } else
#line 372
  if (sfinfo.frames == 0L) {
    {
    {
#line 373
    MSG(4, "ERROR: Unknown number of frames.\220");
    }
#line 374
    result = 0;
    }
#line 375
    goto cleanup1;
  }
  {
#line 378
  subformat = sfinfo.format & 65535;
#line 379
  items = (long )sfinfo.channels * sfinfo.frames;
#line 380
  MSG(4, "Frames = %jd, channels = %ld\332U", sfinfo.frames, (long )sfinfo.channels);
#line 382
  MSG(4, "Samplerate = %i, items = %lld", sfinfo.samplerate, (long long )items);
#line 384
  MSG(4, "Major format = 0x%08X, subformat = 0x%08X, endian = 0x%08Xp{\332U", sfinfo.format & 268369920,
      subformat, sfinfo.format & 805306368);
  }
#line 388
  if (subformat == 6) {
    {
    {
#line 390
    sf_command(sf, 4116, (void *)0, 1);
    }
    }
  } else
#line 388
  if (subformat == 7) {
    {
    {
#line 390
    sf_command(sf, 4116, (void *)0, 1);
    }
    }
  }
  {
#line 393
  track.num_samples = (int )sfinfo.frames;
#line 394
  track.num_channels = sfinfo.channels;
#line 395
  track.sample_rate = sfinfo.samplerate;
#line 396
  track.bits = 16;
#line 397
  track.samples = (short *)g_malloc((unsigned long )items * sizeof(short ));
#line 398
  readcount = sf_read_short(sf, (short *)track.samples, items);
#line 399
  MSG(4, "Read %lld items from audio file.\230\001", (long long )readcount);
  }
#line 401
  if (readcount > 0L) {
    {
#line 402
    track.num_samples = (int )(readcount / (long )sfinfo.channels);
#line 403
    MSG(4, "Sending %i samples to audio.", track.num_samples);
#line 404
    __cil_tmp14 = speak_queue_send_track_to_audio(& track, (AudioFormat )0);
#line 404
    ret = __cil_tmp14;
    }
#line 405
    if (ret < 0) {
      {
#line 406
      MSG(4, "ERROR: Can\'t play track for unknown reason.");
#line 407
      result = - 1;
      }
#line 408
      goto cleanup2;
    }
    {
#line 410
    MSG(4, "Sent to audio.");
    }
  }
  cleanup2: 
  {
#line 413
  g_free(track.samples);
  }
  cleanup1: 
  {
#line 415
  sf_close(sf);
  }
#line 416
  return (result);
}
}
#line 419 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static gboolean speak_queue_send_to_audio(speak_queue_entry *playback_queue_entry ) 
{ 
  gboolean __cil_tmp2 ;

  {
  {
#line 421
  __cil_tmp2 = speak_queue_send_track_to_audio(& playback_queue_entry->data.audio.track,
                                               playback_queue_entry->data.audio.format);
  }
#line 421
  return (__cil_tmp2);
}
}
#line 426 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static void *speak_queue_play(void *nothing ) 
{ 
  char *markId ;
  speak_queue_entry *playback_queue_entry ;
  gboolean finished ;
  speak_queue_entry *__cil_tmp5 ;
  gboolean __cil_tmp6 ;
  gboolean report_begin___0 ;

  {
  {
#line 429
  playback_queue_entry = (speak_queue_entry *)((void *)0);
#line 431
  MSG(4, "speak_queue Playback thread starting.......");
#line 433
  pthread_mutex_lock(& speak_queue_mutex);
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! (! speak_queue_close_requested)) {
#line 434
      goto while_break;
    }
    {
#line 435
    speak_queue_play_sleeping = 1;
#line 436
    pthread_cond_signal(& speak_queue_play_sleeping_cond);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! ((unsigned int )speak_queue_state < 2U && ! speak_queue_close_requested)) {
#line 437
        goto while_break___0;
      }
      {
#line 438
      pthread_cond_wait(& speak_queue_play_cond, & speak_queue_mutex);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 440
    speak_queue_play_sleeping = 0;
#line 441
    pthread_cond_signal(& speak_queue_play_sleeping_cond);
#line 442
    MSG(4, "speak_queue Playback.");
    }
#line 443
    if (speak_queue_close_requested) {
#line 444
      goto while_break;
    }
    {
#line 445
    pthread_mutex_unlock(& speak_queue_mutex);
    }
    {
#line 447
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 448
      finished = 0;
#line 449
      playback_queue_entry = playback_queue_pop();
      }
#line 450
      if (playback_queue_entry == (void *)0) {
        {
#line 451
        MSG(4, "speak_queue playback thread detected stop.");
        }
#line 452
        goto while_break___1;
      }
      {
#line 456
      if ((unsigned int )playback_queue_entry->type == (unsigned int )0) {
#line 456
        goto case_0;
      }
#line 459
      if ((unsigned int )playback_queue_entry->type == (unsigned int )1) {
#line 459
        goto case_1;
      }
#line 481
      if ((unsigned int )playback_queue_entry->type == (unsigned int )2) {
#line 481
        goto case_2;
      }
#line 489
      if ((unsigned int )playback_queue_entry->type == (unsigned int )3) {
#line 489
        goto case_3;
      }
#line 502
      if ((unsigned int )playback_queue_entry->type == (unsigned int )4) {
#line 502
        goto case_4;
      }
#line 522
      if ((unsigned int )playback_queue_entry->type == (unsigned int )5) {
#line 522
        goto case_5;
      }
#line 525
      if ((unsigned int )playback_queue_entry->type == (unsigned int )6) {
#line 525
        goto case_6;
      }
#line 528
      if ((unsigned int )playback_queue_entry->type == (unsigned int )7) {
#line 528
        goto case_7;
      }
#line 455
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 457
      speak_queue_send_to_audio(playback_queue_entry);
      }
#line 458
      goto switch_break;
      case_1: /* CIL Label */ 
#line 460
      markId = playback_queue_entry->data.markId;
      {
#line 461
      MSG(4, "speak_queue reporting index mark |%s|.", markId);
#line 463
      module_report_index_mark((char const   *)markId);
#line 464
      MSG(4, "speak_queue index mark reported.");
#line 465
      pthread_mutex_lock(& speak_queue_mutex);
#line 466
      __cil_tmp6 = g_str_has_prefix(markId, (gchar *)"__spd_");
      }
#line 466
      if ((unsigned int )speak_queue_state == 3U) {
#line 466
        if ((unsigned int )speak_queue_pause_state == 1U) {
#line 466
          if (speak_queue_stop_or_pause_sleeping) {
#line 466
            if (__cil_tmp6) {
              {
#line 471
              MSG(4, "speak_queue Pause requested in playback thread.  Stopping.");
#line 472
              speak_queue_stop_requested = ! 0;
#line 473
              speak_queue_pause_state = (speak_queue_pause_state_t )2;
#line 475
              pthread_cond_signal(& speak_queue_stop_or_pause_cond);
#line 477
              finished = ! 0;
              }
            }
          }
        }
      }
      {
#line 479
      pthread_mutex_unlock(& speak_queue_mutex);
      }
#line 480
      goto switch_break;
      case_2: /* CIL Label */ 
#line 482
      if (speak_queue_configured) {
        {
#line 483
        spd_audio_end(module_audio_id);
#line 484
        speak_queue_configured = 0;
        }
      }
      {
#line 486
      speak_queue_send_file_to_audio((char const   *)playback_queue_entry->data.sound_icon_filename);
      }
#line 488
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 490
      report_begin___0 = 0;
#line 491
      pthread_mutex_lock(& speak_queue_mutex);
      }
#line 492
      if ((unsigned int )speak_queue_state == 2U) {
#line 493
        speak_queue_state = (speak_queue_state_t )3;
#line 494
        report_begin___0 = ! 0;
      }
      {
#line 496
      pthread_mutex_unlock(& speak_queue_mutex);
      }
#line 498
      if (report_begin___0) {
        {
#line 499
        module_report_event_begin();
        }
      }
#line 500
      goto switch_break;
      case_4: /* CIL Label */ 
#line 503
      if (speak_queue_configured) {
        {
#line 504
        spd_audio_end(module_audio_id);
#line 505
        speak_queue_configured = 0;
        }
      }
      {
#line 507
      pthread_mutex_lock(& speak_queue_mutex);
#line 508
      MSG(4, "speak_queue playback thread got END from queue.");
      }
#line 509
      if ((unsigned int )speak_queue_state == 3U) {
#line 510
        if (! speak_queue_stop_requested) {
          {
#line 511
          MSG(4, "speak_queue playback thread reporting end.");
#line 512
          speak_queue_state = (speak_queue_state_t )0;
#line 513
          speak_queue_pause_state = (speak_queue_pause_state_t )0;
          }
        }
#line 516
        finished = ! 0;
      }
      {
#line 518
      pthread_mutex_unlock(& speak_queue_mutex);
      }
#line 519
      if (finished) {
        {
#line 520
        module_report_event_end();
        }
      }
#line 521
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 523
      MSG(4, "speak_queue ??? got pause in speak queue ???\220");
      }
#line 524
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 526
      MSG(4, "speak_queue ??? got stop in speak queue ???");
      }
#line 527
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 529
      MSG(4, "speak_queue ??? got broken in speak queue ???");
      }
#line 530
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 533
      speak_queue_delete_playback_queue_entry(playback_queue_entry);
      }
#line 535
      if (finished) {
#line 536
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 538
    if (speak_queue_configured) {
      {
#line 539
      spd_audio_end(module_audio_id);
#line 540
      speak_queue_configured = 0;
      }
    }
    {
#line 542
    pthread_mutex_lock(& speak_queue_mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  speak_queue_play_sleeping = 1;
#line 545
  pthread_mutex_unlock(& speak_queue_mutex);
#line 546
  MSG(4, "speak_queue Playback thread ended.......");
  }
#line 547
  return ((void *)0);
}
}
#line 550 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
int module_speak_queue_stop_requested(void) 
{ 


  {
#line 552
  return (speak_queue_stop_requested);
}
}
#line 555 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_flush(void) 
{ 


  {
  {
#line 557
  pthread_mutex_lock(& speak_queue_mutex);
#line 558
  speak_queue_flush_requested = ! 0;
#line 559
  pthread_cond_signal(& playback_queue_room_condition);
#line 560
  pthread_mutex_unlock(& speak_queue_mutex);
  }
  return;
}
}
#line 563 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_stop(void) 
{ 


  {
  {
#line 565
  pthread_mutex_lock(& speak_queue_mutex);
  }
#line 566
  if ((unsigned int )speak_queue_state != 0U) {
#line 566
    if (! speak_queue_stop_requested) {
#line 566
      if (speak_queue_stop_or_pause_sleeping) {
        {
#line 569
        MSG(4, "speak_queue stopping...");
#line 570
        speak_queue_stop_requested = ! 0;
#line 572
        pthread_cond_signal(& speak_queue_stop_or_pause_cond);
#line 574
        pthread_cond_wait(& playback_queue_room_condition, & speak_queue_mutex);
        }
      } else {
        {
        {
        {
#line 577
        MSG(4, "speak_queue Cannot stop now.\220");
        }
        }
        }
      }
    } else {
      {
      {
      {
#line 577
      MSG(4, "speak_queue Cannot stop now.\220");
      }
      }
      }
    }
  } else {
    {
    {
    {
#line 577
    MSG(4, "speak_queue Cannot stop now.\220");
    }
    }
    }
  }
  {
#line 579
  pthread_mutex_unlock(& speak_queue_mutex);
  }
  return;
}
}
#line 582 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_pause(void) 
{ 


  {
  {
#line 584
  pthread_mutex_lock(& speak_queue_mutex);
  }
#line 585
  if ((unsigned int )speak_queue_pause_state == 0U) {
#line 585
    if (! speak_queue_stop_requested) {
#line 586
      speak_queue_pause_state = (speak_queue_pause_state_t )1;
    }
  }
  {
#line 588
  pthread_mutex_unlock(& speak_queue_mutex);
  }
  return;
}
}
#line 591 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_terminate(void) 
{ 


  {
  {
#line 593
  pthread_mutex_lock(& speak_queue_mutex);
#line 594
  speak_queue_stop_requested = ! 0;
#line 595
  speak_queue_close_requested = ! 0;
#line 597
  pthread_cond_broadcast(& playback_queue_room_condition);
#line 598
  pthread_cond_signal(& playback_queue_data_condition);
#line 600
  pthread_cond_signal(& speak_queue_play_cond);
#line 601
  pthread_cond_signal(& speak_queue_stop_or_pause_cond);
#line 602
  pthread_mutex_unlock(& speak_queue_mutex);
#line 604
  MSG(4, "speak_queue Joining play thread.");
#line 605
  pthread_join(speak_queue_play_thread, (void **)((void *)0));
#line 606
  MSG(4, "speak_queue Joining stop thread.");
#line 607
  pthread_join(speak_queue_stop_or_pause_thread, (void **)((void *)0));
  }
  return;
}
}
#line 610 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
void module_speak_queue_free(void) 
{ 


  {
  {
#line 612
  MSG(4, "speak_queue Freeing resources.");
#line 613
  speak_queue_clear_playback_queue();
  }
  return;
}
}
#line 617 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/speak_queue.c"
static void *speak_queue_stop_or_pause(void *nothing ) 
{ 
  int ret ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int save_pause_state ;

  {
  {
#line 621
  MSG(4, "speak_queue Stop or pause thread starting.......");
#line 623
  pthread_mutex_lock(& speak_queue_mutex);
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (! speak_queue_close_requested)) {
#line 624
      goto while_break;
    }
#line 625
    speak_queue_stop_or_pause_sleeping = 1;
    {
#line 626
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 626
      if (! (! speak_queue_stop_requested)) {
#line 626
        goto while_break___0;
      }
      {
#line 627
      pthread_cond_wait(& speak_queue_stop_or_pause_cond, & speak_queue_mutex);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 628
    speak_queue_stop_or_pause_sleeping = 0;
#line 630
    MSG(4, "speak_queue Stop or pause.");
    }
#line 631
    if (speak_queue_close_requested) {
#line 632
      goto while_break;
    }
    {
#line 634
    pthread_cond_signal(& playback_queue_data_condition);
#line 635
    pthread_cond_broadcast(& playback_queue_room_condition);
#line 636
    pthread_mutex_unlock(& speak_queue_mutex);
    }
#line 638
    if (module_audio_id) {
      {
#line 639
      pthread_mutex_lock(& speak_queue_mutex);
#line 640
      speak_queue_state = (speak_queue_state_t )0;
#line 641
      pthread_mutex_unlock(& speak_queue_mutex);
#line 642
      MSG(4, "speak_queue Stopping audio.");
#line 643
      ret = spd_audio_stop(module_audio_id);
      }
#line 644
      if (ret != 0) {
        {
#line 645
        MSG(4, "spd_audio_stop returned non-zero value.");
        }
      }
      {
#line 646
      pthread_mutex_lock(& speak_queue_mutex);
      }
      {
#line 647
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 647
        if (! (! speak_queue_play_sleeping)) {
#line 647
          goto while_break___1;
        }
        {
#line 648
        ret = spd_audio_stop(module_audio_id);
        }
#line 649
        if (ret != 0) {
          {
#line 650
          MSG(4, "spd_audio_stop returned non-zero value.");
          }
        }
        {
#line 651
        pthread_mutex_unlock(& speak_queue_mutex);
#line 652
        g_usleep((gulong )5000);
#line 653
        pthread_mutex_lock(& speak_queue_mutex);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 655
      pthread_mutex_unlock(& speak_queue_mutex);
      }
    } else {
      {
#line 657
      pthread_mutex_lock(& speak_queue_mutex);
      }
      {
#line 658
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 658
        if (! (! speak_queue_play_sleeping)) {
#line 658
          goto while_break___2;
        }
        {
#line 659
        pthread_cond_wait(& speak_queue_play_sleeping_cond, & speak_queue_mutex);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 660
      pthread_mutex_unlock(& speak_queue_mutex);
      }
    }
    {
#line 663
    MSG(4, "speak_queue Waiting for synthesis to stop.");
#line 665
    module_speak_queue_cancel();
#line 667
    MSG(4, "speak_queue Clearing playback queue.\220");
#line 668
    speak_queue_clear_playback_queue();
#line 670
    save_pause_state = (int )speak_queue_pause_state;
#line 671
    pthread_mutex_lock(& speak_queue_mutex);
#line 672
    module_speak_queue_reset();
#line 673
    pthread_mutex_unlock(& speak_queue_mutex);
    }
#line 675
    if (save_pause_state == 2) {
      {
#line 676
      module_report_event_pause();
      }
    } else {
      {
#line 678
      module_report_event_stop();
      }
    }
    {
#line 681
    MSG(4, "speak_queue Stop or pause thread ended.......\n");
#line 682
    pthread_mutex_lock(& speak_queue_mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 684
  pthread_mutex_unlock(& speak_queue_mutex);
#line 685
  pthread_exit((void *)0);
  }
  return ((void *)0);
}
}
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 256
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 42 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 67 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 86
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 94
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 149
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 155
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 162
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 189
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 193
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 309
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 339
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern  __attribute__((__nothrow__)) void closefrom(int __lowfd ) ;
#line 371
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 389
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 437
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 452
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 498
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 503
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 517
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 521
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 531
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 545
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 552
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 555
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 564
extern char **__environ ;
#line 572
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 578
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 589
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 594
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 599
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 605
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 619
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 624
extern void _exit(int __status ) ;
#line 633
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 637
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 640
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 644
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 650
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 653
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 656
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 659
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 661
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 668
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 689
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 697
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 706
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 722
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 732
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 749
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 778
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 799
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 803
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 809
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 814
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 819
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 832
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 838
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 847
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 851
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 858
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 862
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 867
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 871
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 874
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 895
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 911 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 919
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 924
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 930
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 933
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 939
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 942
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 950
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 958
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 962
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 963
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 964
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 970
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 977
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 981
extern char *getpass(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 1011
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 1026
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1049
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1070
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1076
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1091
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1159
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1198
int getentropy(void *__buffer , size_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 29
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 36
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 38
  __cil_tmp7 = __builtin_object_size(__buf, 0);
  }
  {
#line 38
  __cil_tmp5 = __builtin_object_size(__buf, 0);
#line 38
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 38
  __cil_tmp4 = __builtin_constant_p(__nbytes);
  }
#line 38
  if (__cil_tmp6 && (unsigned long )__nbytes <= __cil_tmp7 / sizeof(char )) {
    {
#line 38
    __cil_tmp8 = __read_alias(__fd, __buf, __nbytes);
#line 38
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 38
    __cil_tmp12 = __builtin_object_size(__buf, 0);
    }
    {
#line 38
    __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 38
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 38
    __cil_tmp9 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (__cil_tmp11 && ! ((unsigned long )__nbytes <= __cil_tmp12 / sizeof(char ))) {
      {
#line 38
      __cil_tmp13 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp14 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp13);
#line 38
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 38
      __cil_tmp15 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp16 = __read_chk(__fd, __buf, __nbytes, __cil_tmp15);
#line 38
      tmp = __cil_tmp16;
      }
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  return (tmp___0);
}
}
#line 44
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 47
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 50
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 54
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 74
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 74
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 74
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 74
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 74
    __cil_tmp9 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 74
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 74
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 74
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 74
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 74
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 74
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 74
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp15 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 74
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 74
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp17 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 74
      tmp = __cil_tmp17;
      }
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 100
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 104
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 108
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 119
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 119
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 119
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 119
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 119
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 119
    __cil_tmp8 = __readlink_alias(__path, __buf, __len);
#line 119
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 119
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 119
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 119
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 119
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 119
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp14 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp13);
#line 119
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 119
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp16 = __readlink_chk(__path, __buf, __len, __cil_tmp15);
#line 119
      tmp = __cil_tmp16;
      }
    }
#line 119
    tmp___0 = tmp;
  }
#line 119
  return (tmp___0);
}
}
#line 126
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 130
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 135
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 147
  __cil_tmp8 = __builtin_object_size(__buf, 1);
  }
  {
#line 147
  __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 147
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 147
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 147
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 147
    __cil_tmp9 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 147
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 147
    __cil_tmp13 = __builtin_object_size(__buf, 1);
    }
    {
#line 147
    __cil_tmp11 = __builtin_object_size(__buf, 1);
#line 147
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 147
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 147
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 147
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp15 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp14);
#line 147
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 147
      __cil_tmp16 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp17 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp16);
#line 147
      tmp = __cil_tmp17;
      }
    }
#line 147
    tmp___0 = tmp;
  }
#line 147
  return (tmp___0);
}
}
#line 153
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 155
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 157
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 164
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 164 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 166
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 166
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 166
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 166
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 166
  if (__cil_tmp5 && (unsigned long )__size <= __cil_tmp6 / sizeof(char )) {
    {
#line 166
    __cil_tmp7 = __getcwd_alias(__buf, __size);
#line 166
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 166
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 166
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 166
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 166
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 166
    if (__cil_tmp10 && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(char ))) {
      {
#line 166
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp13 = __getcwd_chk_warn(__buf, __size, __cil_tmp12);
#line 166
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 166
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp15 = __getcwd_chk(__buf, __size, __cil_tmp14);
#line 166
      tmp = __cil_tmp15;
      }
    }
#line 166
    tmp___0 = tmp;
  }
#line 166
  return (tmp___0);
}
}
#line 172
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 174
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 181
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 182
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 182
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 182
    return (__cil_tmp4);
  }
  {
#line 183
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 183
  return (__cil_tmp5);
}
}
#line 187
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 190
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 193
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 202
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 202
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 202
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 202
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 202
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 202
    __cil_tmp8 = __confstr_alias(__name, __buf, __len);
#line 202
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 202
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 202
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 202
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 202
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 202
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 202
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp14 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp13);
#line 202
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 202
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp16 = __confstr_chk(__name, __buf, __len, __cil_tmp15);
#line 202
      tmp = __cil_tmp16;
      }
    }
#line 202
    tmp___0 = tmp;
  }
#line 202
  return (tmp___0);
}
}
#line 208
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 210
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 212
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 219
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 219 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  __cil_tmp6 = __builtin_object_size(__list, 1);
  }
  {
#line 221
  __cil_tmp4 = __builtin_object_size(__list, 1);
#line 221
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(__gid_t ));
  }
  {
#line 221
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 221
  if (((__cil_tmp3 && __size > 0) && __cil_tmp5) && (unsigned long )__size <= __cil_tmp6 / sizeof(__gid_t )) {
    {
#line 221
    __cil_tmp7 = __getgroups_alias(__size, __list);
#line 221
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 221
    __cil_tmp11 = __builtin_object_size(__list, 1);
    }
    {
#line 221
    __cil_tmp9 = __builtin_object_size(__list, 1);
#line 221
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(__gid_t ));
    }
    {
#line 221
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 221
    if (((__cil_tmp8 && __size > 0) && __cil_tmp10) && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(__gid_t ))) {
      {
#line 221
      __cil_tmp12 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp13 = __getgroups_chk_warn(__size, __list, __cil_tmp12);
#line 221
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 221
      __cil_tmp14 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp15 = __getgroups_chk(__size, __list, __cil_tmp14);
#line 221
      tmp = __cil_tmp15;
      }
    }
#line 221
    tmp___0 = tmp;
  }
#line 221
  return (tmp___0);
}
}
#line 227
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 230
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 233
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 242
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 242
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 242
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 242
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 242
    __cil_tmp8 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 242
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 242
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 242
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 242
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 242
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 242
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 242
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp14 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 242
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 242
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp16 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 242
      tmp = __cil_tmp16;
      }
    }
#line 242
    tmp___0 = tmp;
  }
#line 242
  return (tmp___0);
}
}
#line 249
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 251
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 253
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 260
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 260 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 262
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 262
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 262
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 262
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 262
    __cil_tmp7 = __getlogin_r_alias(__buf, __buflen);
#line 262
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 262
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 262
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 262
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 262
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 262
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 262
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp13 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp12);
#line 262
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 262
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp15 = __getlogin_r_chk(__buf, __buflen, __cil_tmp14);
#line 262
      tmp = __cil_tmp15;
      }
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return (tmp___0);
}
}
#line 270
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 272
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 275
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 282
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 284
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 284
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 284
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 284
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 284
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 284
    __cil_tmp7 = __gethostname_alias(__buf, __buflen);
#line 284
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 284
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 284
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 284
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 284
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 284
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 284
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp13 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 284
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 284
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp15 = __gethostname_chk(__buf, __buflen, __cil_tmp14);
#line 284
      tmp = __cil_tmp15;
      }
    }
#line 284
    tmp___0 = tmp;
  }
#line 284
  return (tmp___0);
}
}
#line 292
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 294
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 298
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 306
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 308
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 308
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 308
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 308
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 308
    __cil_tmp7 = __getdomainname_alias(__buf, __buflen);
#line 308
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 308
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 308
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 308
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 308
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 308
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 308
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp13 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 308
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 308
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp15 = __getdomainname_chk(__buf, __buflen, __cil_tmp14);
#line 308
      tmp = __cil_tmp15;
      }
    }
#line 308
    tmp___0 = tmp;
  }
#line 308
  return (tmp___0);
}
}
#line 80 "/usr/include/libltdl/lt_error.h"
extern int lt_dladderror(char const   *diagnostic ) ;
#line 81
extern int lt_dlseterror(int errorcode ) ;
#line 74 "/usr/include/libltdl/lt_dlloader.h"
extern int lt_dlloader_add(lt_dlvtable *vtable ) ;
#line 75
extern lt_dlloader lt_dlloader_next(lt_dlloader loader ) ;
#line 77
extern lt_dlvtable *lt_dlloader_remove(char const   *name ) ;
#line 78
extern lt_dlvtable *lt_dlloader_find(char const   *name ) ;
#line 79
extern lt_dlvtable *lt_dlloader_get(lt_dlloader loader ) ;
#line 53 "/usr/include/ltdl.h"
extern int lt_dlinit(void) ;
#line 54
extern int lt_dlexit(void) ;
#line 57
extern int lt_dladdsearchdir(char const   *search_dir ) ;
#line 58
extern int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) ;
#line 60
extern int lt_dlsetsearchpath(char const   *search_path ) ;
#line 61
extern char const   *lt_dlgetsearchpath(void) ;
#line 62
extern int lt_dlforeachfile(char const   *search_path , int (*func)(char const   * ,
                                                                    void * ) , void *data ) ;
#line 68
extern int lt_dladvise_init(lt_dladvise *advise ) ;
#line 69
extern int lt_dladvise_destroy(lt_dladvise *advise ) ;
#line 70
extern int lt_dladvise_ext(lt_dladvise *advise ) ;
#line 71
extern int lt_dladvise_resident(lt_dladvise *advise ) ;
#line 72
extern int lt_dladvise_local(lt_dladvise *advise ) ;
#line 73
extern int lt_dladvise_global(lt_dladvise *advise ) ;
#line 74
extern int lt_dladvise_preload(lt_dladvise *advise ) ;
#line 77
extern lt_dlhandle lt_dlopen(char const   *filename ) ;
#line 78
extern lt_dlhandle lt_dlopenext(char const   *filename ) ;
#line 79
extern lt_dlhandle lt_dlopenadvise(char const   *filename , lt_dladvise advise ) ;
#line 81
extern void *lt_dlsym(lt_dlhandle handle , char const   *name ) ;
#line 82
extern char const   *lt_dlerror(void) ;
#line 83
extern int lt_dlclose(lt_dlhandle handle ) ;
#line 99
extern int lt_dlpreload(lt_dlsymlist *preloaded ) ;
#line 100
extern int lt_dlpreload_default(lt_dlsymlist *preloaded ) ;
#line 101
extern int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) ;
#line 106
extern lt_dlsymlist lt__PROGRAM__LTX_preloaded_symbols[] ;
#line 121
extern lt_dlinterface_id lt_dlinterface_register(char const   *id_string , lt_dlhandle_interface *iface ) ;
#line 123
extern void lt_dlinterface_free(lt_dlinterface_id key ) ;
#line 124
extern void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) ;
#line 126
extern void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) ;
#line 143
extern lt_dlinfo *lt_dlgetinfo(lt_dlhandle handle ) ;
#line 145
extern lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) ;
#line 147
extern lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) ;
#line 149
extern int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle  , void * ) ,
                           void *data ) ;
#line 156
extern int lt_dlmakeresident(lt_dlhandle handle ) ;
#line 157
extern int lt_dlisresident(lt_dlhandle handle ) ;
#line 52 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
static int spd_audio_log_level ;
#line 53
static lt_dlhandle lt_h ;
#line 61 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
static lt_dlhandle my_dlopenextglobal(char const   *filename ) 
{ 
  lt_dlhandle handle ;
  lt_dladvise advise ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  lt_dlhandle __cil_tmp7 ;

  {
  {
#line 63
  handle = (lt_dlhandle )((void *)0);
#line 66
  __cil_tmp4 = lt_dladvise_init(& advise);
  }
#line 66
  if (__cil_tmp4) {
#line 67
    return (handle);
  }
  {
#line 69
  __cil_tmp6 = lt_dladvise_global(& advise);
  }
  {
#line 69
  __cil_tmp5 = lt_dladvise_ext(& advise);
  }
#line 69
  if (! __cil_tmp5) {
#line 69
    if (! __cil_tmp6) {
      {
#line 70
      handle = lt_dlopenadvise(filename, advise);
      }
    }
  }
  {
#line 72
  lt_dladvise_destroy(& advise);
  }
#line 73
  return (handle);
}
}
#line 92 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
AudioID *spd_audio_open(char const   *name , void **pars , char **error ) 
{ 
  AudioID *id ;
  spd_audio_plugin_t *p ;
  spd_audio_plugin_t *(*fn)(void) ;
  gchar *libname ;
  int ret ;
  char *plugin_dir ;
  int __cil_tmp10 ;
  gchar *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  lt_dlhandle __cil_tmp16 ;
  char const   *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  void *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  spd_audio_plugin_t *__cil_tmp21 ;
  gchar *__cil_tmp22 ;
  AudioID *__cil_tmp23 ;
  gchar *__cil_tmp24 ;

  {
  {
#line 102
  ret = lt_dlinit();
  }
#line 103
  if (ret != 0) {
    {
#line 104
    __cil_tmp11 = g_strdup_printf((gchar *)"lt_dlinit() failed");
#line 104
    *error = (char *)__cil_tmp11;
    }
#line 105
    return ((AudioID *)((void *)0));
  }
  {
#line 108
  plugin_dir = getenv("SPEECHD_PLUGIN_DIR");
  }
#line 109
  if (! plugin_dir) {
#line 110
    plugin_dir = "/usr/lib/x86_64-linux-gnu/speech-dispatcher";
  }
  {
#line 112
  ret = lt_dlsetsearchpath((char const   *)plugin_dir);
  }
#line 113
  if (ret != 0) {
    {
#line 114
    __cil_tmp14 = g_strdup_printf((gchar *)"lt_dlsetsearchpath() failed");
#line 114
    *error = (char *)__cil_tmp14;
    }
#line 115
    return ((AudioID *)((void *)0));
  }
  {
#line 118
  libname = g_strdup_printf((gchar *)"spd_%s", name);
#line 119
  lt_h = my_dlopenextglobal((char const   *)libname);
#line 120
  g_free(libname);
  }
#line 121
  if ((void *)0 == lt_h) {
    {
#line 122
    __cil_tmp17 = lt_dlerror();
#line 122
    __cil_tmp18 = g_strdup_printf((gchar *)"Cannot open plugin %s. error: %s\230\001",
                                  name, __cil_tmp17);
#line 122
    *error = (char *)__cil_tmp18;
    }
#line 125
    return ((AudioID *)((void *)0));
  }
  {
#line 128
  fn = (spd_audio_plugin_t *(*)(void))lt_dlsym(lt_h, "spd_audio_plugin_get");
  }
#line 129
  if ((void *)0 == fn) {
    {
#line 130
    __cil_tmp20 = g_strdup_printf((gchar *)"Cannot find symbol %s", "spd_audio_plugin_get");
#line 130
    *error = (char *)__cil_tmp20;
    }
#line 132
    return ((AudioID *)((void *)0));
  }
  {
#line 135
  p = (*fn)();
  }
#line 136
  if (p == (void *)0) {
    {
    {
#line 137
    __cil_tmp22 = g_strdup_printf((gchar *)"plugin %s not found", name);
    }
#line 137
    *error = (char *)__cil_tmp22;
    }
#line 138
    return ((AudioID *)((void *)0));
  } else
#line 136
  if (p->name == (void *)0) {
    {
    {
#line 137
    __cil_tmp22 = g_strdup_printf((gchar *)"plugin %s not found", name);
    }
#line 137
    *error = (char *)__cil_tmp22;
    }
#line 138
    return ((AudioID *)((void *)0));
  }
  {
#line 141
  id = (*(p->open))(pars);
  }
#line 142
  if (id == (void *)0) {
    {
#line 143
    __cil_tmp24 = g_strdup_printf((gchar *)"Couldn\'t open %s plugin", name);
#line 143
    *error = (char *)__cil_tmp24;
    }
#line 145
    return ((AudioID *)((void *)0));
  }
#line 148
  id->function = p;
#line 152
  id->format = (AudioFormat )0;
#line 155
  *error = (char *)((void *)0);
#line 157
  return (id);
}
}
#line 171 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_begin(AudioID *id , AudioTrack track , AudioFormat format ) 
{ 
  int __cil_tmp4 ;

  {
#line 173
  if (! id) {
    {
#line 174
    fprintf(stderr, "No audio open\n");
    }
#line 175
    return (- 1);
  }
#line 178
  if (! (id->function)->begin) {
#line 180
    return (0);
  }
  {
#line 183
  __cil_tmp4 = (*((id->function)->begin))(id, track);
  }
#line 183
  return (__cil_tmp4);
}
}
#line 187 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
static void spd_audio_convert(AudioID *id , AudioTrack track , AudioFormat format ) 
{ 
  unsigned char *out_ptr ;
  unsigned char *out_end ;
  unsigned char c ;

  {
#line 191
  if ((unsigned int )format != (unsigned int )id->format) {
#line 191
    if (track.bits == 16) {
#line 193
      out_ptr = (unsigned char *)track.samples;
#line 194
      out_end = out_ptr + (track.num_samples * 2) * track.num_channels;
      {
#line 197
      while (1) {
        while_continue: /* CIL Label */ ;
#line 197
        if (! (out_ptr < out_end)) {
#line 197
          goto while_break;
        }
#line 198
        c = *(out_ptr + 0);
#line 199
        *(out_ptr + 0) = *(out_ptr + 1);
#line 200
        *(out_ptr + 1) = c;
#line 201
        out_ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 228 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_feed_sync(AudioID *id , AudioTrack track , AudioFormat format ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 230
  if (! id) {
    {
#line 231
    fprintf(stderr, "No audio open\n");
    }
#line 232
    return (- 1);
  }
  {
#line 235
  spd_audio_convert(id, track, format);
  }
#line 237
  if ((id->function)->feed_sync) {
    {
#line 238
    __cil_tmp4 = (*((id->function)->feed_sync))(id, track);
    }
#line 238
    return (__cil_tmp4);
  }
#line 241
  if ((id->function)->play) {
    {
#line 242
    __cil_tmp5 = (*((id->function)->play))(id, track);
    }
#line 242
    return (__cil_tmp5);
  }
  {
#line 245
  fprintf(stderr, "Play not supported on this device\n");
  }
#line 246
  return (- 1);
}
}
#line 271 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_feed_sync_overlap(AudioID *id , AudioTrack track , AudioFormat format ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 273
  if (! id) {
    {
#line 274
    fprintf(stderr, "No audio open\n");
    }
#line 275
    return (- 1);
  }
  {
#line 278
  spd_audio_convert(id, track, format);
  }
#line 280
  if ((id->function)->feed_sync_overlap) {
    {
#line 281
    __cil_tmp4 = (*((id->function)->feed_sync_overlap))(id, track);
    }
#line 281
    return (__cil_tmp4);
  }
#line 284
  if ((id->function)->feed_sync) {
    {
#line 285
    __cil_tmp5 = (*((id->function)->feed_sync))(id, track);
    }
#line 285
    return (__cil_tmp5);
  }
#line 288
  if ((id->function)->play) {
    {
#line 289
    __cil_tmp6 = (*((id->function)->play))(id, track);
    }
#line 289
    return (__cil_tmp6);
  }
  {
#line 292
  fprintf(stderr, "Play not supported on this device\n");
  }
#line 293
  return (- 1);
}
}
#line 306 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_end(AudioID *id ) 
{ 
  int __cil_tmp2 ;

  {
#line 308
  if (! id) {
    {
#line 309
    fprintf(stderr, "No audio open\n");
    }
#line 310
    return (- 1);
  }
#line 313
  if (! (id->function)->end) {
#line 315
    return (0);
  }
  {
#line 318
  __cil_tmp2 = (*((id->function)->end))(id);
  }
#line 318
  return (__cil_tmp2);
}
}
#line 339 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_play(AudioID *id , AudioTrack track , AudioFormat format ) 
{ 
  int ret ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 343
  ret = spd_audio_begin(id, track, format);
  }
#line 344
  if (ret) {
#line 345
    return (ret);
  }
  {
#line 347
  ret = spd_audio_feed_sync(id, track, format);
  }
#line 348
  if (ret) {
#line 349
    return (ret);
  }
  {
#line 351
  __cil_tmp7 = spd_audio_end(id);
  }
#line 351
  return (__cil_tmp7);
}
}
#line 379 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_stop(AudioID *id ) 
{ 
  int ret ;
  int __cil_tmp3 ;

  {
#line 382
  if (id) {
#line 382
    if ((id->function)->stop) {
      {
#line 383
      ret = (*((id->function)->stop))(id);
      }
    } else {
      {
      {
#line 385
      fprintf(stderr, "Stop not supported on this device\n");
      }
      }
#line 386
      return (- 1);
    }
  } else {
    {
    {
#line 385
    fprintf(stderr, "Stop not supported on this device\n");
    }
    }
#line 386
    return (- 1);
  }
#line 388
  return (ret);
}
}
#line 405 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_close(AudioID *id ) 
{ 
  int ret ;
  int __cil_tmp3 ;

  {
#line 407
  ret = 0;
#line 408
  if (id) {
#line 408
    if ((id->function)->close) {
      {
#line 409
      ret = (*((id->function)->close))(id);
      }
    }
  }
#line 412
  if ((void *)0 != lt_h) {
    {
#line 413
    lt_dlclose(lt_h);
#line 414
    lt_h = (lt_dlhandle )((void *)0);
#line 415
    lt_dlexit();
    }
  }
#line 418
  return (ret);
}
}
#line 443 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
int spd_audio_set_volume(AudioID *id , int volume ) 
{ 


  {
#line 445
  if (volume > 100) {
    {
    {
#line 446
    fprintf(stderr, "Requested volume out of rangeU");
    }
    }
#line 447
    return (- 1);
  } else
#line 445
  if (volume < -100) {
    {
    {
#line 446
    fprintf(stderr, "Requested volume out of rangeU");
    }
    }
#line 447
    return (- 1);
  }
#line 449
  if (id == (void *)0) {
    {
#line 450
    fprintf(stderr, "audio id is NULL in spd_audio_set_volume\n\213\261{\332U");
    }
#line 451
    return (- 1);
  }
#line 453
  id->volume = volume;
#line 454
  return (0);
}
}
#line 457 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
void spd_audio_set_loglevel(AudioID *id , int level ) 
{ 


  {
#line 459
  if (level) {
#line 460
    spd_audio_log_level = level;
#line 461
    if (id != (AudioID *)0) {
#line 461
      if (id->function != (struct spd_audio_plugin *)0) {
        {
#line 462
        (*((id->function)->set_loglevel))(level);
        }
      }
    }
  }
  return;
}
}
#line 466 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/spd_audio.c"
char const   *spd_audio_get_playcmd(AudioID *id ) 
{ 
  char const   *__cil_tmp2 ;

  {
#line 468
  if (id != (AudioID *)0) {
#line 468
    if (id->function != (struct spd_audio_plugin *)0) {
      {
#line 469
      __cil_tmp2 = (*((id->function)->get_playcmd))();
      }
#line 469
      return (__cil_tmp2);
    }
  }
#line 471
  return ((char const   *)((void *)0));
}
}
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid ) ;
#line 44
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid ) ;
#line 46
extern  __attribute__((__nothrow__)) char *__dgettext(char const   *__domainname ,
                                                      char const   *__msgid ) ;
#line 51
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category ) ;
#line 54
extern  __attribute__((__nothrow__)) char *__dcgettext(char const   *__domainname ,
                                                       char const   *__msgid , int __category ) ;
#line 61
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n ) ;
#line 67
extern  __attribute__((__nothrow__)) char *dngettext(char const   *__domainname ,
                                                     char const   *__msgid1 , char const   *__msgid2 ,
                                                     unsigned long __n ) ;
#line 73
extern  __attribute__((__nothrow__)) char *dcngettext(char const   *__domainname ,
                                                      char const   *__msgid1 , char const   *__msgid2 ,
                                                      unsigned long __n , int __category ) ;
#line 82
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 91
extern  __attribute__((__nothrow__)) char *bind_textdomain_codeset(char const   *__domainname ,
                                                                   char const   *__codeset ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 125
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 141
extern  __attribute__((__nothrow__)) locale_t newlocale(int __category_mask , char const   *__locale ,
                                                        locale_t __base ) ;
#line 176
extern  __attribute__((__nothrow__)) locale_t duplocale(locale_t __dataset ) ;
#line 180
extern  __attribute__((__nothrow__)) void freelocale(locale_t __dataset ) ;
#line 187
extern  __attribute__((__nothrow__)) locale_t uselocale(locale_t __dataset ) ;
#line 35 "../../include/i18n.h"
void i18n_init(void) ;
#line 30 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/i18n.c"
void i18n_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp1 = setlocale(6, "@}\351{\332U");
  }
#line 32
  if (__cil_tmp1 == (void *)0) {
    {
#line 33
    perror("setlocale");
#line 34
    exit(1);
    }
  }
  {
#line 37
  __cil_tmp2 = bindtextdomain("speech-dispatcher", "/usr/share/locale");
  }
#line 37
  if (__cil_tmp2 == (void *)0) {
    {
#line 38
    perror("bindtextdomain");
#line 39
    exit(1);
    }
  }
  {
#line 42
  __cil_tmp3 = textdomain("speech-dispatcher");
  }
#line 42
  if (__cil_tmp3 == (void *)0) {
    {
#line 43
    perror("textdomain");
#line 44
    exit(1);
    }
  }
  return;
}
}
#line 27 "../../include/fdsetconv.h"
char *EVoice2str(SPDVoiceType voice ) ;
#line 29
SPDVoiceType str2EVoice(char const   *str ) ;
#line 31
char *EPunctMode2str(SPDPunctuation punct ) ;
#line 33
SPDPunctuation str2EPunctMode(char const   *str ) ;
#line 35
char *ESpellMode2str(SPDSpelling spell ) ;
#line 37
SPDSpelling str2ESpellMode(char const   *str ) ;
#line 39
char *ECapLetRecogn2str(SPDCapitalLetters recogn ) ;
#line 41
SPDCapitalLetters str2ECapLetRecogn(char const   *str ) ;
#line 43
SPDPriority str2intpriority(char const   *str ) ;
#line 30 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
char *EVoice2str(SPDVoiceType voice ) 
{ 
  char *str ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  gchar *__cil_tmp9 ;
  gchar *__cil_tmp10 ;

  {
  {
#line 35
  if ((int )voice == 1) {
#line 35
    goto case_1;
  }
#line 38
  if ((int )voice == 2) {
#line 38
    goto case_2;
  }
#line 41
  if ((int )voice == 3) {
#line 41
    goto case_3;
  }
#line 44
  if ((int )voice == 4) {
#line 44
    goto case_4;
  }
#line 47
  if ((int )voice == 5) {
#line 47
    goto case_5;
  }
#line 50
  if ((int )voice == 6) {
#line 50
    goto case_6;
  }
#line 53
  if ((int )voice == 7) {
#line 53
    goto case_7;
  }
#line 56
  if ((int )voice == 8) {
#line 56
    goto case_8;
  }
#line 59
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 36
  str = g_strdup((gchar *)"male1");
  }
#line 37
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 39
  str = g_strdup((gchar *)"male2");
  }
#line 40
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 42
  str = g_strdup((gchar *)"male3");
  }
#line 43
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 45
  str = g_strdup((gchar *)"female1");
  }
#line 46
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 48
  str = g_strdup((gchar *)"female2");
  }
#line 49
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 51
  str = g_strdup((gchar *)"female3");
  }
#line 52
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 54
  str = g_strdup((gchar *)"child_male");
  }
#line 55
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 57
  str = g_strdup((gchar *)"child_female");
  }
#line 58
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 60
  str = (char *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
#line 63
  return (str);
}
}
#line 66 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
SPDVoiceType str2EVoice(char const   *str ) 
{ 
  SPDVoiceType voice ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 70
  __cil_tmp3 = strcmp(str, "male1");
  }
#line 70
  if (! __cil_tmp3) {
#line 71
    voice = (SPDVoiceType )1;
  } else {
    {
#line 72
    __cil_tmp4 = strcmp(str, "male2");
    }
#line 72
    if (! __cil_tmp4) {
#line 73
      voice = (SPDVoiceType )2;
    } else {
      {
#line 74
      __cil_tmp5 = strcmp(str, "male3");
      }
#line 74
      if (! __cil_tmp5) {
#line 75
        voice = (SPDVoiceType )3;
      } else {
        {
#line 76
        __cil_tmp6 = strcmp(str, "female1");
        }
#line 76
        if (! __cil_tmp6) {
#line 77
          voice = (SPDVoiceType )4;
        } else {
          {
#line 78
          __cil_tmp7 = strcmp(str, "female2");
          }
#line 78
          if (! __cil_tmp7) {
#line 79
            voice = (SPDVoiceType )5;
          } else {
            {
#line 80
            __cil_tmp8 = strcmp(str, "female3");
            }
#line 80
            if (! __cil_tmp8) {
#line 81
              voice = (SPDVoiceType )6;
            } else {
              {
#line 82
              __cil_tmp9 = strcmp(str, "child_male");
              }
#line 82
              if (! __cil_tmp9) {
#line 83
                voice = (SPDVoiceType )7;
              } else {
                {
#line 84
                __cil_tmp10 = strcmp(str, "child_female");
                }
#line 84
                if (! __cil_tmp10) {
#line 85
                  voice = (SPDVoiceType )8;
                } else {
#line 87
                  voice = (SPDVoiceType )(- 1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 89
  return (voice);
}
}
#line 92 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
char *EPunctMode2str(SPDPunctuation punct ) 
{ 
  char *str ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;

  {
  {
#line 97
  if ((unsigned int )punct == (unsigned int )1) {
#line 97
    goto case_1;
  }
#line 100
  if ((unsigned int )punct == (unsigned int )0) {
#line 100
    goto case_0;
  }
#line 103
  if ((unsigned int )punct == (unsigned int )2) {
#line 103
    goto case_2;
  }
#line 106
  if ((unsigned int )punct == (unsigned int )3) {
#line 106
    goto case_3;
  }
#line 109
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 98
  str = g_strdup((gchar *)"none");
  }
#line 99
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 101
  str = g_strdup((gchar *)"all");
  }
#line 102
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 104
  str = g_strdup((gchar *)"some");
  }
#line 105
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 107
  str = g_strdup((gchar *)"most\332U");
  }
#line 108
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 110
  str = (char *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
#line 113
  return (str);
}
}
#line 116 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
SPDPunctuation str2EPunctMode(char const   *str ) 
{ 
  SPDPunctuation punct ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 120
  __cil_tmp3 = strcmp(str, "none\332U");
  }
#line 120
  if (! __cil_tmp3) {
#line 121
    punct = (SPDPunctuation )1;
  } else {
    {
#line 122
    __cil_tmp4 = strcmp(str, "all");
    }
#line 122
    if (! __cil_tmp4) {
#line 123
      punct = (SPDPunctuation )0;
    } else {
      {
#line 124
      __cil_tmp5 = strcmp(str, "some\332U");
      }
#line 124
      if (! __cil_tmp5) {
#line 125
        punct = (SPDPunctuation )2;
      } else {
        {
#line 126
        __cil_tmp6 = strcmp(str, "most");
        }
#line 126
        if (! __cil_tmp6) {
#line 127
          punct = (SPDPunctuation )3;
        } else {
#line 129
          punct = (SPDPunctuation )(- 1);
        }
      }
    }
  }
#line 131
  return (punct);
}
}
#line 134 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
char *ESpellMode2str(SPDSpelling spell ) 
{ 
  char *str ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;

  {
  {
#line 139
  if ((unsigned int )spell == (unsigned int )1) {
#line 139
    goto case_1;
  }
#line 142
  if ((unsigned int )spell == (unsigned int )0) {
#line 142
    goto case_0;
  }
#line 145
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 140
  str = g_strdup((gchar *)"on!|\332U");
  }
#line 141
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 143
  str = g_strdup((gchar *)"off");
  }
#line 144
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 146
  str = (char *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
#line 149
  return (str);
}
}
#line 152 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
SPDSpelling str2ESpellMode(char const   *str ) 
{ 
  SPDSpelling spell ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 156
  __cil_tmp3 = strcmp(str, "on");
  }
#line 156
  if (! __cil_tmp3) {
#line 157
    spell = (SPDSpelling )1;
  } else {
    {
#line 158
    __cil_tmp4 = strcmp(str, "off");
    }
#line 158
    if (! __cil_tmp4) {
#line 159
      spell = (SPDSpelling )0;
    } else {
#line 161
      spell = (SPDSpelling )(- 1);
    }
  }
#line 163
  return (spell);
}
}
#line 166 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
char *ECapLetRecogn2str(SPDCapitalLetters recogn ) 
{ 
  char *str ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
  {
#line 171
  if ((unsigned int )recogn == (unsigned int )0) {
#line 171
    goto case_0;
  }
#line 174
  if ((unsigned int )recogn == (unsigned int )1) {
#line 174
    goto case_1;
  }
#line 177
  if ((unsigned int )recogn == (unsigned int )2) {
#line 177
    goto case_2;
  }
#line 180
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 172
  str = g_strdup((gchar *)"none");
  }
#line 173
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 175
  str = g_strdup((gchar *)"spell");
  }
#line 176
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 178
  str = g_strdup((gchar *)"icon");
  }
#line 179
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 181
  str = (char *)((void *)0);
  switch_break: /* CIL Label */ ;
  }
#line 184
  return (str);
}
}
#line 187 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
SPDCapitalLetters str2ECapLetRecogn(char const   *str ) 
{ 
  SPDCapitalLetters recogn ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 191
  __cil_tmp3 = strcmp(str, "none");
  }
#line 191
  if (! __cil_tmp3) {
#line 192
    recogn = (SPDCapitalLetters )0;
  } else {
    {
#line 193
    __cil_tmp4 = strcmp(str, "spell");
    }
#line 193
    if (! __cil_tmp4) {
#line 194
      recogn = (SPDCapitalLetters )1;
    } else {
      {
#line 195
      __cil_tmp5 = strcmp(str, "icon");
      }
#line 195
      if (! __cil_tmp5) {
#line 196
        recogn = (SPDCapitalLetters )2;
      } else {
#line 198
        recogn = (SPDCapitalLetters )(- 1);
      }
    }
  }
#line 200
  return (recogn);
}
}
#line 203 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/fdsetconv.c"
SPDPriority str2intpriority(char const   *str ) 
{ 
  SPDPriority priority ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 207
  __cil_tmp3 = strcmp(str, "important");
  }
#line 207
  if (! __cil_tmp3) {
#line 208
    priority = (SPDPriority )1;
  } else {
    {
#line 209
    __cil_tmp4 = strcmp(str, "message");
    }
#line 209
    if (! __cil_tmp4) {
#line 210
      priority = (SPDPriority )2;
    } else {
      {
#line 211
      __cil_tmp5 = strcmp(str, "text");
      }
#line 211
      if (! __cil_tmp5) {
#line 212
        priority = (SPDPriority )3;
      } else {
        {
#line 213
        __cil_tmp6 = strcmp(str, "notification");
        }
#line 213
        if (! __cil_tmp6) {
#line 214
          priority = (SPDPriority )4;
        } else {
          {
#line 215
          __cil_tmp7 = strcmp(str, "progress\220");
          }
#line 215
          if (! __cil_tmp7) {
#line 216
            priority = (SPDPriority )5;
          } else {
#line 218
            priority = (SPDPriority )(- 1);
          }
        }
      }
    }
  }
#line 220
  return (priority);
}
}
#line 26 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/common.c"
int spd_pthread_create(pthread_t *thread , pthread_attr_t *attr , void *(*start_routine)(void * ) ,
                       void *arg ) 
{ 
  int retsig ;
  int ret ;
  sigset_t all_signals ;
  sigset_t old_signals ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 33
  retsig = sigfillset(& all_signals);
  }
#line 34
  if (retsig != 0) {
    {
#line 35
    MSG(1, "Can\'t fill signal set (%d), expect problems when terminating!\n", retsig);
    }
  } else {
    {
#line 37
    retsig = pthread_sigmask(0, & all_signals, & old_signals);
    }
#line 38
    if (retsig != 0) {
      {
#line 39
      MSG(1, "Can\'t set signal set (%d), expect problems when terminating!\n", retsig);
      }
    }
  }
  {
#line 42
  ret = pthread_create(thread, attr, start_routine, arg);
  }
#line 44
  if (retsig == 0) {
    {
#line 45
    pthread_sigmask(2, & old_signals, (__sigset_t *)((void *)0));
    }
  }
#line 47
  return (ret);
}
}
#line 50 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/common/common.c"
void set_speaking_thread_parameters(void) 
{ 


  {
  {
#line 52
  pthread_setcancelstate(0, (int *)((void *)0));
#line 53
  pthread_setcanceltype(1, (int *)((void *)0));
  }
  return;
}
}
#line 307 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 316
  if ((size_t )__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 318
    return ((struct cmsghdr *)0);
  }
#line 320
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))));
#line 322
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  } else
#line 322
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  }
#line 328
  return (__cmsg);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 108
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int __fds[2] ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , __CONST_SOCKADDR_ARG __addr ,
                                              socklen_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int getsockname(int __fd , __SOCKADDR_ARG __addr ,
                                                     socklen_t *__len ) ;
#line 126
extern int connect(int __fd , __CONST_SOCKADDR_ARG __addr , socklen_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) int getpeername(int __fd , __SOCKADDR_ARG __addr ,
                                                     socklen_t *__len ) ;
#line 138
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 145
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 152
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      __CONST_SOCKADDR_ARG __addr , socklen_t __addr_len ) ;
#line 163
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 174
extern ssize_t sendmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 195
extern int sendmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags ) ;
#line 216
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 235
extern int recvmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags , struct timespec *__tmo ) ;
#line 255
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void *__optval , socklen_t *__optlen ) ;
#line 277
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 296
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 306
extern int accept(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 314
extern int accept4(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len , int __flags ) ;
#line 324
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 329
extern  __attribute__((__nothrow__)) int sockatmark(int __fd ) ;
#line 337
extern  __attribute__((__nothrow__)) int isfdtype(int __fd , int __fdtype ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) ;
#line 34
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  ssize_t __cil_tmp13 ;

  {
  {
#line 36
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 36
  sz = __cil_tmp6;
#line 37
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 37
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 37
  if (__cil_tmp8) {
#line 37
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 38
      __cil_tmp9 = __recv_alias(__fd, __buf, __n, __flags);
      }
#line 38
      return (__cil_tmp9);
    }
  }
  {
#line 39
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 39
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 39
  if (__cil_tmp11) {
#line 39
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 40
      __cil_tmp12 = __recv_chk_warn(__fd, __buf, __n, sz, __flags);
      }
#line 40
      return (__cil_tmp12);
    }
  }
  {
#line 41
  __cil_tmp13 = __recv_chk(__fd, __buf, __n, sz, __flags);
  }
#line 41
  return (__cil_tmp13);
}
}
#line 44
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 48
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 52
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 61
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__buf, 0);
#line 64
  sz = __cil_tmp8;
#line 65
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 65
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 65
  if (__cil_tmp10) {
#line 65
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 66
      __cil_tmp11 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
      }
#line 66
      return (__cil_tmp11);
    }
  }
  {
#line 67
  __cil_tmp13 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 67
  __cil_tmp12 = __builtin_constant_p(__n);
  }
#line 67
  if (__cil_tmp13) {
#line 67
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 68
      __cil_tmp14 = __recvfrom_chk_warn(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
      }
#line 68
      return (__cil_tmp14);
    }
  }
  {
#line 70
  __cil_tmp15 = __recvfrom_chk(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
  }
#line 70
  return (__cil_tmp15);
}
}
#line 235 "/usr/include/netinet/in.h"
extern struct in6_addr in6addr_any ;
#line 236
extern struct in6_addr in6addr_loopback ;
#line 382
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong ) ;
#line 383
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort ) ;
#line 385
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong ) ;
#line 387
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort ) ;
#line 510
extern  __attribute__((__nothrow__)) int bindresvport(int __sockfd , struct sockaddr_in *__sock_in ) ;
#line 513
extern  __attribute__((__nothrow__)) int bindresvport6(int __sockfd , struct sockaddr_in6 *__sock_in ) ;
#line 559
extern  __attribute__((__nothrow__)) int inet6_option_space(int __nbytes ) ;
#line 561
extern  __attribute__((__nothrow__)) int inet6_option_init(void *__bp , struct cmsghdr **__cmsgp ,
                                                           int __type ) ;
#line 563
extern  __attribute__((__nothrow__)) int inet6_option_append(struct cmsghdr *__cmsg ,
                                                             uint8_t *__typep , int __multx ,
                                                             int __plusy ) ;
#line 566
extern  __attribute__((__nothrow__)) uint8_t *inet6_option_alloc(struct cmsghdr *__cmsg ,
                                                                 int __datalen , int __multx ,
                                                                 int __plusy ) ;
#line 569
extern  __attribute__((__nothrow__)) int inet6_option_next(struct cmsghdr *__cmsg ,
                                                           uint8_t **__tptrp ) ;
#line 572
extern  __attribute__((__nothrow__)) int inet6_option_find(struct cmsghdr *__cmsg ,
                                                           uint8_t **__tptrp , int __type ) ;
#line 578
extern  __attribute__((__nothrow__)) int inet6_opt_init(void *__extbuf , socklen_t __extlen ) ;
#line 579
extern  __attribute__((__nothrow__)) int inet6_opt_append(void *__extbuf , socklen_t __extlen ,
                                                          int __offset , uint8_t __type ,
                                                          socklen_t __len , uint8_t __align ,
                                                          void **__databufp ) ;
#line 582
extern  __attribute__((__nothrow__)) int inet6_opt_finish(void *__extbuf , socklen_t __extlen ,
                                                          int __offset ) ;
#line 584
extern  __attribute__((__nothrow__)) int inet6_opt_set_val(void *__databuf , int __offset ,
                                                           void *__val , socklen_t __vallen ) ;
#line 586
extern  __attribute__((__nothrow__)) int inet6_opt_next(void *__extbuf , socklen_t __extlen ,
                                                        int __offset , uint8_t *__typep ,
                                                        socklen_t *__lenp , void **__databufp ) ;
#line 589
extern  __attribute__((__nothrow__)) int inet6_opt_find(void *__extbuf , socklen_t __extlen ,
                                                        int __offset , uint8_t __type ,
                                                        socklen_t *__lenp , void **__databufp ) ;
#line 592
extern  __attribute__((__nothrow__)) int inet6_opt_get_val(void *__databuf , int __offset ,
                                                           void *__val , socklen_t __vallen ) ;
#line 597
extern  __attribute__((__nothrow__)) socklen_t inet6_rth_space(int __type , int __segments ) ;
#line 598
extern  __attribute__((__nothrow__)) void *inet6_rth_init(void *__bp , socklen_t __bp_len ,
                                                          int __type , int __segments ) ;
#line 600
extern  __attribute__((__nothrow__)) int inet6_rth_add(void *__bp , struct in6_addr *__addr ) ;
#line 601
extern  __attribute__((__nothrow__)) int inet6_rth_reverse(void const   *__in , void *__out ) ;
#line 602
extern  __attribute__((__nothrow__)) int inet6_rth_segments(void const   *__bp ) ;
#line 603
extern  __attribute__((__nothrow__)) struct in6_addr *inet6_rth_getaddr(void const   *__bp ,
                                                                        int __index ) ;
#line 610
extern  __attribute__((__nothrow__)) int getipv4sourcefilter(int __s , struct in_addr __interface_addr ,
                                                             struct in_addr __group ,
                                                             uint32_t *__fmode , uint32_t *__numsrc ,
                                                             struct in_addr *__slist ) ;
#line 616
extern  __attribute__((__nothrow__)) int setipv4sourcefilter(int __s , struct in_addr __interface_addr ,
                                                             struct in_addr __group ,
                                                             uint32_t __fmode , uint32_t __numsrc ,
                                                             struct in_addr *__slist ) ;
#line 624
extern  __attribute__((__nothrow__)) int getsourcefilter(int __s , uint32_t __interface_addr ,
                                                         struct sockaddr *__group ,
                                                         socklen_t __grouplen , uint32_t *__fmode ,
                                                         uint32_t *__numsrc , struct sockaddr_storage *__slist ) ;
#line 631
extern  __attribute__((__nothrow__)) int setsourcefilter(int __s , uint32_t __interface_addr ,
                                                         struct sockaddr *__group ,
                                                         socklen_t __grouplen , uint32_t __fmode ,
                                                         uint32_t __numsrc , struct sockaddr_storage *__slist ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval __tvp[2] ) ;
#line 80 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 151
extern int sigpause(int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigisemptyset(sigset_t *__set ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigandset(sigset_t *__set , sigset_t *__left ,
                                                   sigset_t *__right ) ;
#line 223
extern  __attribute__((__nothrow__)) int sigorset(sigset_t *__set , sigset_t *__left ,
                                                  sigset_t *__right ) ;
#line 292 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type ) ;
#line 296
extern  __attribute__((__nothrow__)) int eaccess(char const   *__name , int __type ) ;
#line 300
extern  __attribute__((__nothrow__)) int execveat(int __fd , char const   *__path ,
                                                  char * const  __argv[] , char * const  __envp[] ,
                                                  int __flags ) ;
#line 350
extern  __attribute__((__nothrow__)) __off64_t lseek64(int __fd , __off64_t __offset ,
                                                       int __whence ) ;
#line 422
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 427
extern ssize_t pwrite64(int __fd , void const   *__buf , size_t __n , __off64_t __offset ) ;
#line 442
extern  __attribute__((__nothrow__)) int pipe2(int __pipedes[2] , int __flags ) ;
#line 537
extern  __attribute__((__nothrow__)) char *get_current_dir_name(void) ;
#line 560
extern  __attribute__((__nothrow__)) int dup3(int __fd , int __fd2 , int __flags ) ;
#line 566
extern char **environ ;
#line 611
extern  __attribute__((__nothrow__)) int execvpe(char const   *__file , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 715
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 755
extern  __attribute__((__nothrow__)) int getresuid(__uid_t *__ruid , __uid_t *__euid ,
                                                   __uid_t *__suid ) ;
#line 760
extern  __attribute__((__nothrow__)) int getresgid(__gid_t *__rgid , __gid_t *__egid ,
                                                   __gid_t *__sgid ) ;
#line 765
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 770
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 793
extern  __attribute__((__nothrow__)) __pid_t _Fork(void) ;
#line 995
extern  __attribute__((__nothrow__)) int syncfs(int __fd ) ;
#line 1038
extern  __attribute__((__nothrow__)) int truncate64(char const   *__file , __off64_t __length ) ;
#line 1059
extern  __attribute__((__nothrow__)) int ftruncate64(int __fd , __off64_t __length ) ;
#line 1124
extern int lockf64(int __fd , int __cmd , __off64_t __len ) ;
#line 1142
ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                        size_t __length , unsigned int __flags ) ;
#line 1168
extern  __attribute__((__nothrow__)) void swab(void const   *__from , void *__to ,
                                               ssize_t __n ) ;
#line 1208
extern  __attribute__((__nothrow__)) int close_range(unsigned int __fd , unsigned int __max_fd ,
                                                     int __flags ) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 92
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 92
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 92
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 92
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 92
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 92
    __cil_tmp9 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 92
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 92
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 92
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 92
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 92
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 92
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 92
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp15 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 92
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 92
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp17 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 92
      tmp = __cil_tmp17;
      }
    }
#line 92
    tmp___0 = tmp;
  }
#line 92
  return (tmp___0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern  __attribute__((__nothrow__)) __pid_t gettid(void) ;
#line 355 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sighold(int __sig ) ;
#line 359
extern  __attribute__((__nothrow__)) int sigrelse(int __sig ) ;
#line 363
extern  __attribute__((__nothrow__)) int sigignore(int __sig ) ;
#line 367
extern  __attribute__((__nothrow__)) __sighandler_t sigset(int __sig , __sighandler_t __disp ) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigqueue(pthread_t __threadid , int __signo ,
                                                          union sigval __value ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 88 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(int *__stat_loc ) ;
#line 111
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 132
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
#line 148
extern  __attribute__((__nothrow__)) __pid_t wait3(int *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 164
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , int *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 170 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int renameat2(int __oldfd , char const   *__old ,
                                                   int __newfd , char const   *__new ,
                                                   unsigned int __flags ) ;
#line 200
extern FILE *tmpfile64(void) ;
#line 249
extern int fcloseall(void) ;
#line 283
extern FILE *fopen64(char const   *__filename , char const   *__modes ) ;
#line 286
extern FILE *freopen64(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 300
extern  __attribute__((__nothrow__)) FILE *fopencookie(void *__magic_cookie , char const   *__modes ,
                                                       cookie_io_functions_t __io_funcs ) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 393
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 396
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 615
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 691
extern int fputs_unlocked(char const   *__s , FILE *__stream ) ;
#line 779
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 780
extern __off64_t ftello64(FILE *__stream ) ;
#line 781
extern int fgetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 782
extern int fsetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 844
extern char *cuserid(char *__s ) ;
#line 853
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 856
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 166 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 169
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 172
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 176
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 184
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 186
  __cil_tmp3 = __builtin_va_arg_pack();
#line 186
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 186
  return (__cil_tmp4);
}
}
#line 199
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_va_arg_pack();
#line 202
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 202
  return (__cil_tmp4);
}
}
#line 215
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 215 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 218
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 218
  return (__cil_tmp4);
}
}
#line 222
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 222 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 225
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 225
  return (__cil_tmp4);
}
}
#line 300
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 307
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 314
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 316
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 316
  sz = __cil_tmp5;
#line 317
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 317
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 317
  if (__cil_tmp6) {
#line 317
    if (__n > 0) {
#line 317
      if (__cil_tmp7) {
#line 317
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 318
          __cil_tmp8 = __fgets_unlocked_alias(__s, __n, __stream);
          }
#line 318
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 319
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 319
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 319
  if (__cil_tmp9) {
#line 319
    if (__n > 0) {
#line 319
      if (__cil_tmp10) {
#line 319
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 320
          __cil_tmp11 = __fgets_unlocked_chk_warn(__s, sz, __n, __stream);
          }
#line 320
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 321
  __cil_tmp12 = __fgets_unlocked_chk(__s, sz, __n, __stream);
  }
#line 321
  return (__cil_tmp12);
}
}
#line 141 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int strtof32(char const   *__nptr , char **__endptr ) ;
#line 147
extern  __attribute__((__nothrow__)) int strtof64(char const   *__nptr , char **__endptr ) ;
#line 153
extern  __attribute__((__nothrow__)) int strtof128(char const   *__nptr , char **__endptr ) ;
#line 159
extern  __attribute__((__nothrow__)) int strtof32x(char const   *__nptr , char **__endptr ) ;
#line 165
extern  __attribute__((__nothrow__)) int strtof64x(char const   *__nptr , char **__endptr ) ;
#line 213
extern  __attribute__((__nothrow__)) int strfromd(char *__dest , size_t __size , char const   *__format ,
                                                  double __f ) ;
#line 217
extern  __attribute__((__nothrow__)) int strfromf(char *__dest , size_t __size , char const   *__format ,
                                                  float __f ) ;
#line 221
extern  __attribute__((__nothrow__)) int strfroml(char *__dest , size_t __size , char const   *__format ,
                                                  long double __f ) ;
#line 233
extern  __attribute__((__nothrow__)) int strfromf32(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 239
extern  __attribute__((__nothrow__)) int strfromf64(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 245
extern  __attribute__((__nothrow__)) int strfromf128(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 251
extern  __attribute__((__nothrow__)) int strfromf32x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 257
extern  __attribute__((__nothrow__)) int strfromf64x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 275
extern  __attribute__((__nothrow__)) long strtol_l(char const   *__nptr , char **__endptr ,
                                                   int __base , locale_t __loc ) ;
#line 279
extern  __attribute__((__nothrow__)) unsigned long strtoul_l(char const   *__nptr ,
                                                             char **__endptr , int __base ,
                                                             locale_t __loc ) ;
#line 285
extern  __attribute__((__nothrow__)) long long strtoll_l(char const   *__nptr , char **__endptr ,
                                                         int __base , locale_t __loc ) ;
#line 291
extern  __attribute__((__nothrow__)) unsigned long long strtoull_l(char const   *__nptr ,
                                                                   char **__endptr ,
                                                                   int __base , locale_t __loc ) ;
#line 296
extern  __attribute__((__nothrow__)) double strtod_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 300
extern  __attribute__((__nothrow__)) float strtof_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 304
extern  __attribute__((__nothrow__)) long double strtold_l(char const   *__nptr ,
                                                           char **__endptr , locale_t __loc ) ;
#line 317
extern  __attribute__((__nothrow__)) int strtof32_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 324
extern  __attribute__((__nothrow__)) int strtof64_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 331
extern  __attribute__((__nothrow__)) int strtof128_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 338
extern  __attribute__((__nothrow__)) int strtof32x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 345
extern  __attribute__((__nothrow__)) int strtof64x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 646
extern  __attribute__((__nothrow__)) char *secure_getenv(char const   *__name ) ;
#line 705
extern int mkstemp64(char *__template ) ;
#line 727
extern int mkstemps64(char *__template , int __suffixlen ) ;
#line 749
extern int mkostemp(char *__template , int __flags ) ;
#line 759
extern int mkostemp64(char *__template , int __flags ) ;
#line 769
extern int mkostemps(char *__template , int __suffixlen , int __flags ) ;
#line 781
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) ;
#line 797
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name ) ;
#line 841
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar ,
                    void *__arg ) ;
#line 978
extern int posix_openpt(int __oflag ) ;
#line 986
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 990
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 1006
extern int getpt(void) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 398 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern  __attribute__((__nothrow__)) __ssize_t readahead(int __fd , __off64_t __offset ,
                                                         size_t __count ) ;
#line 406
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 414
extern __ssize_t vmsplice(int __fdout , struct iovec *__iov , size_t __count , unsigned int __flags ) ;
#line 421
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 429
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
#line 437
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
#line 448
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
#line 454
extern  __attribute__((__nothrow__)) int name_to_handle_at(int __dfd , char const   *__name ,
                                                           struct file_handle *__handle ,
                                                           int *__mnt_id , int __flags ) ;
#line 462
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
#line 158 "/usr/include/fcntl.h"
extern int fcntl64(int __fd , int __cmd  , ...) ;
#line 191
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 216
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 237
extern int creat64(char const   *__file , mode_t __mode ) ;
#line 285
extern  __attribute__((__nothrow__)) int posix_fadvise64(int __fd , off64_t __offset ,
                                                         off64_t __len , int __advise ) ;
#line 306
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open64(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
  {
#line 78
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = __builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = __builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
  {
#line 156
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = __builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = __builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 120 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *rawmemchr(void const   *__s , int __c ) ;
#line 133
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n ) ;
#line 286
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c ) ;
#line 380
extern  __attribute__((__nothrow__)) char *strcasestr(char const   *__haystack , char const   *__needle ) ;
#line 389
extern  __attribute__((__nothrow__)) void *memmem(void const   *__haystack , size_t __haystacklen ,
                                                  void const   *__needle , size_t __needlelen ) ;
#line 397
extern  __attribute__((__nothrow__)) void *__mempcpy(void *__dest , void const   *__src ,
                                                     size_t __n ) ;
#line 400
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 450
extern  __attribute__((__nothrow__)) char const   *strerrordesc_np(int __err ) ;
#line 452
extern  __attribute__((__nothrow__)) char const   *strerrorname_np(int __err ) ;
#line 482
extern  __attribute__((__nothrow__)) char const   *sigabbrev_np(int __sig ) ;
#line 485
extern  __attribute__((__nothrow__)) char const   *sigdescr_np(int __sig ) ;
#line 506
extern  __attribute__((__nothrow__)) int strverscmp(char const   *__s1 , char const   *__s2 ) ;
#line 510
extern  __attribute__((__nothrow__)) char *strfry(char *__string ) ;
#line 513
extern  __attribute__((__nothrow__)) void *memfrob(void *__s , size_t __n ) ;
#line 527
extern  __attribute__((__nothrow__)) char *basename(char const   *__filename ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 45
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 45
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 45
  return (__cil_tmp5);
}
}
#line 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h"
extern  __attribute__((__nothrow__)) long __sysconf(int __name ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern  __attribute__((__nothrow__)) int clone(int (*__fn)(void * ) , void *__child_stack ,
                                               int __flags , void *__arg  , ...) ;
#line 86
extern  __attribute__((__nothrow__)) int unshare(int __flags ) ;
#line 89
extern  __attribute__((__nothrow__)) int sched_getcpu(void) ;
#line 92
extern  __attribute__((__nothrow__)) int getcpu(unsigned int * , unsigned int * ) ;
#line 95
extern  __attribute__((__nothrow__)) int setns(int __fd , int __nstype ) ;
#line 130 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 134
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern  __attribute__((__nothrow__)) int clock_adjtime(__clockid_t __clock_id , struct timex *__utx ) ;
#line 107 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *strptime(char const   *__s , char const   *__fmt ,
                                                    struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) char *strptime_l(char const   *__s , char const   *__fmt ,
                                                      struct tm *__tp , locale_t __loc ) ;
#line 387
extern  __attribute__((__nothrow__)) int timespec_getres(struct timespec *__ts , int __base ) ;
#line 413
extern int getdate_err ;
#line 422
extern struct tm *getdate(char const   *__string ) ;
#line 436
extern int getdate_r(char const   *__string , struct tm *__resbufp ) ;
#line 224 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_tryjoin_np(pthread_t __th , void **__thread_return ) ;
#line 233
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec *__abstime ) ;
#line 243
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec *__abstime ) ;
#line 394
extern  __attribute__((__nothrow__)) int pthread_attr_setaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 401
extern  __attribute__((__nothrow__)) int pthread_attr_getaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 407
extern  __attribute__((__nothrow__)) int pthread_getattr_default_np(pthread_attr_t *__attr ) ;
#line 411
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 417
extern int pthread_attr_getsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 426
extern  __attribute__((__nothrow__)) int pthread_setattr_default_np(pthread_attr_t *__attr ) ;
#line 432
extern  __attribute__((__nothrow__)) int pthread_getattr_np(pthread_t __th , pthread_attr_t *__attr ) ;
#line 458
extern  __attribute__((__nothrow__)) int pthread_getname_np(pthread_t __target_thread ,
                                                            char *__buf , size_t __buflen ) ;
#line 463
extern  __attribute__((__nothrow__)) int pthread_setname_np(pthread_t __target_thread ,
                                                            char const   *__name ) ;
#line 470
extern  __attribute__((__nothrow__)) int pthread_getconcurrency(void) ;
#line 473
extern  __attribute__((__nothrow__)) int pthread_setconcurrency(int __level ) ;
#line 477
extern  __attribute__((__nothrow__)) int pthread_yield(void) ;
#line 489
extern  __attribute__((__nothrow__)) int pthread_setaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 494
extern  __attribute__((__nothrow__)) int pthread_getaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 732
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 745
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 817
extern  __attribute__((__nothrow__)) int pthread_mutex_clocklock(pthread_mutex_t *__mutex ,
                                                                 clockid_t __clockid ,
                                                                 struct timespec *__abstime ) ;
#line 859
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent_np(pthread_mutex_t * ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust_np(pthread_mutexattr_t * ,
                                                                        int * ) ;
#line 951
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * ,
                                                                        int  ) ;
#line 1004
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockrdlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1051
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockwrlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1171
extern int pthread_cond_clockwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  __clockid_t __clock_id , struct timespec *__abstime ) ;
#line 173 "/usr/include/dirent.h"
extern struct dirent64 *readdir64(DIR *__dirp ) ;
#line 201
extern int readdir64_r(DIR *__dirp , struct dirent64 *__entry , struct dirent64 **__result ) ;
#line 278
extern int scandir64(char const   *__dir , struct dirent64 ***__namelist , int (*__selector)(struct dirent64 * ) ,
                     int (*__cmp)(struct dirent64 ** , struct dirent64 ** ) ) ;
#line 293
extern int scandirat(int __dfd , char const   *__dir , struct dirent ***__namelist ,
                     int (*__selector)(struct dirent * ) , int (*__cmp)(struct dirent ** ,
                                                                        struct dirent ** ) ) ;
#line 315
extern int scandirat64(int __dfd , char const   *__dir , struct dirent64 ***__namelist ,
                       int (*__selector)(struct dirent64 * ) , int (*__cmp)(struct dirent64 ** ,
                                                                            struct dirent64 ** ) ) ;
#line 340
extern  __attribute__((__nothrow__)) int alphasort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 370
extern  __attribute__((__nothrow__)) __ssize_t getdirentries64(int __fd , char *__buf ,
                                                               size_t __nbytes , __off64_t *__basep ) ;
#line 380
extern  __attribute__((__nothrow__)) int versionsort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 396
extern  __attribute__((__nothrow__)) int versionsort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h"
extern  __attribute__((__nothrow__)) __ssize_t getdents64(int __fd , void *__buffer ,
                                                          size_t __length ) ;
#line 57 "/usr/include/glib-2.0/glib-unix.h"
extern GQuark g_unix_error_quark(void) ;
#line 60
extern gboolean g_unix_open_pipe(gint *fds , gint flags , GError **error ) ;
#line 65
extern gboolean g_unix_set_fd_nonblocking(gint fd , gboolean nonblock , GError **error ) ;
#line 70
extern GSource *g_unix_signal_source_new(gint signum ) ;
#line 73
extern guint g_unix_signal_add_full(gint priority , gint signum , GSourceFunc handler ,
                                    gpointer user_data , GDestroyNotify notify ) ;
#line 80
extern guint g_unix_signal_add(gint signum , GSourceFunc handler , gpointer user_data ) ;
#line 100
extern GSource *g_unix_fd_source_new(gint fd , GIOCondition condition ) ;
#line 104
extern guint g_unix_fd_add_full(gint priority , gint fd , GIOCondition condition ,
                                GUnixFDSourceFunc function , gpointer user_data ,
                                GDestroyNotify notify ) ;
#line 112
extern guint g_unix_fd_add(gint fd , GIOCondition condition , GUnixFDSourceFunc function ,
                           gpointer user_data ) ;
#line 118
extern struct passwd *g_unix_get_passwd_entry(gchar *user_name , GError **error ) ;
#line 35 "/usr/include/semaphore.h"
extern  __attribute__((__nothrow__)) int sem_init(sem_t *__sem , int __pshared , unsigned int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int sem_destroy(sem_t *__sem ) ;
#line 42
extern  __attribute__((__nothrow__)) sem_t *sem_open(char const   *__name , int __oflag 
                                                     , ...) ;
#line 46
extern  __attribute__((__nothrow__)) int sem_close(sem_t *__sem ) ;
#line 49
extern  __attribute__((__nothrow__)) int sem_unlink(char const   *__name ) ;
#line 55
extern int sem_wait(sem_t *__sem ) ;
#line 63
extern int sem_timedwait(sem_t *__sem , struct timespec *__abstime ) ;
#line 81
extern int sem_clockwait(sem_t *__sem , clockid_t clock , struct timespec *__abstime ) ;
#line 100
extern  __attribute__((__nothrow__)) int sem_trywait(sem_t *__sem ) ;
#line 103
extern  __attribute__((__nothrow__)) int sem_post(sem_t *__sem ) ;
#line 106
extern  __attribute__((__nothrow__)) int sem_getvalue(sem_t *__sem , int *__sval ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ftok(char const   *__pathname , int __proj_id ) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int semctl(int __semid , int __semnum , int __cmd 
                                                , ...) ;
#line 64
extern  __attribute__((__nothrow__)) int semget(key_t __key , int __nsems , int __semflg ) ;
#line 67
extern  __attribute__((__nothrow__)) int semop(int __semid , struct sembuf *__sops ,
                                               size_t __nsops ) ;
#line 72
extern  __attribute__((__nothrow__)) int semtimedop(int __semid , struct sembuf *__sops ,
                                                    size_t __nsops , struct timespec *__timeout ) ;
#line 48 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/module.h"
GList *detect_output_modules(GList *modules , char const   *modules_dirname , char const   *user_config_dirname ,
                             char const   *config_dirname ) ;
#line 49
OutputModule *load_output_module(char const   *mod_name , char const   *mod_prog ,
                                 char const   *mod_cfgfile , char const   *mod_dbgfile ,
                                 char const   *mod_prog_dir , char const   *mod_cfg_dir ) ;
#line 52
int unload_output_module(OutputModule *module ) ;
#line 53
int reload_output_module(OutputModule *old_module ) ;
#line 54
int output_module_debug(OutputModule *module ) ;
#line 55
int output_module_nodebug(OutputModule *module ) ;
#line 56
void destroy_module(OutputModule *module ) ;
#line 58
void module_add_load_request(char *module_name , char *module_cmd , char *module_cfgfile ,
                             char *module_dbgfile , char *module_cmd_dir , char *module_cfg_dir ) ;
#line 61
void module_load_requested_modules(void) ;
#line 62
guint module_number_of_requested_modules(void) ;
#line 26 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/compare.h"
gint compare_message_uid(gconstpointer element , gconstpointer value ) ;
#line 29
GCompareFunc p_msg_lc ;
#line 30
GCompareFunc p_msg_uid_lc ;
#line 128 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
TSpeechDMode spd_mode ;
#line 26 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/alloc.h"
TSpeechDMessage *spd_message_copy(TSpeechDMessage *old ) ;
#line 29
void mem_free_message(TSpeechDMessage *msg ) ;
#line 32
void mem_free_fdset(TFDSetElement *fdset ) ;
#line 29 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.h"
OutputModule *speaking_module ;
#line 30
int speaking_uid ;
#line 31
int speaking_gid ;
#line 34
int pause_requested ;
#line 35
int pause_requested_fd ;
#line 36
int pause_requested_uid ;
#line 37
int resume_requested ;
#line 43
void *speak(void *data ) ;
#line 46
int reload_message(TSpeechDMessage *msg ) ;
#line 49
void speaking_stop(int uid ) ;
#line 50
void speaking_stop_all(void) ;
#line 52
void speaking_cancel(int uid ) ;
#line 53
void speaking_cancel_all(void) ;
#line 55
int speaking_pause(int fd , int uid ) ;
#line 56
int speaking_pause_all(int fd ) ;
#line 58
int speaking_resume(int uid ) ;
#line 59
int speaking_resume_all(void) ;
#line 65
int is_sb_speaking(void) ;
#line 68
void stop_speaking_active_module(void) ;
#line 70
int stop_priority(SPDPriority priority ) ;
#line 72
void stop_from_uid(int uid ) ;
#line 75
gint message_nto_speak(gconstpointer data , gconstpointer nothing ) ;
#line 77
void set_speak_thread_attributes(void) ;
#line 80
void resolve_priorities(SPDPriority priority ) ;
#line 83
TSpeechDMessage *get_message_from_queues(void) ;
#line 84
GList *speaking_get_queue(SPDPriority priority ) ;
#line 85
void speaking_set_queue(SPDPriority priority , GList *queue ) ;
#line 86
gint sortbyuid(gconstpointer a , gconstpointer b ) ;
#line 87
int client_has_messages(int uid ) ;
#line 91
int get_speaking_client_uid(void) ;
#line 93
int socket_send_msg(int fd , char const   *msg ) ;
#line 94
int report_index_mark(TSpeechDMessage *msg , char const   *index_mark ) ;
#line 95
int report_begin(TSpeechDMessage *msg ) ;
#line 96
int report_end(TSpeechDMessage *msg ) ;
#line 97
int report_pause(TSpeechDMessage *msg ) ;
#line 98
int report_resume(TSpeechDMessage *msg ) ;
#line 99
int report_cancel(TSpeechDMessage *msg ) ;
#line 101
GList *empty_queue(GList *queue ) ;
#line 102
GList *empty_queue_by_time(GList *queue , unsigned int uid ) ;
#line 104
int stop_priority_older_than(SPDPriority priority , unsigned int uid ) ;
#line 105
GList *stop_priority_from_uid(GList *queue , int uid ) ;
#line 106
void stop_priority_except_first(SPDPriority priority ) ;
#line 178 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
struct SpeechdOptions SpeechdOptions ;
#line 184
struct SpeechdStatus SpeechdStatus ;
#line 187
pthread_t speak_thread ;
#line 188
pthread_mutex_t logging_mutex ;
#line 189
pthread_mutex_t element_free_mutex ;
#line 190
pthread_mutex_t output_layer_mutex ;
#line 191
pthread_mutex_t socket_com_mutex ;
#line 194
GList *output_modules ;
#line 197
GHashTable *fd_settings ;
#line 199
GHashTable *language_default_modules ;
#line 201
GHashTable *fd_uid ;
#line 204
TSpeechDQueue *MessageQueue ;
#line 206
GList *MessagePausedList ;
#line 209
GList *client_specific_settings ;
#line 212
GList *last_p5_block ;
#line 215
TFDSetElement GlobalFDSet ;
#line 218
int speaking_pipe[2] ;
#line 221
GHashTable *speechd_sockets_status ;
#line 228
int speechd_sockets_status_init(void) ;
#line 229
int speechd_socket_register(int fd ) ;
#line 230
void speechd_socket_free(TSpeechDSock *speechd_socket ) ;
#line 231
int speechd_socket_unregister(int fd ) ;
#line 232
TSpeechDSock *speechd_socket_get_by_fd(int fd ) ;
#line 23 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.h"
char *parse(char const   *buf , int bytes , int fd ) ;
#line 25
char *parse_history(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 27
char *parse_set(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 29
char *parse_stop(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 31
char *parse_cancel(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 33
char *parse_pause(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 35
char *parse_resume(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 37
char *parse_snd_icon(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 39
char *parse_char(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 41
char *parse_key(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 43
char *parse_list(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 45
char *parse_get(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 47
char *parse_help(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 49
char *parse_block(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) ;
#line 52
char *deescape_dot(char const   *orig_text , size_t orig_len ) ;
#line 55
char *get_param(char const   *buf , int n , int bytes , int lower_case ) ;
#line 59
char *parse_general_event(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ,
                          SPDMessageType type ) ;
#line 62
int spd_utf8_read_char(char const   *pointer , char *character ) ;
#line 239 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.h"
FILE *logfile ;
#line 240
FILE *custom_logfile ;
#line 241
char *custom_log_kind ;
#line 242
FILE *debug_logfile ;
#line 245
void fatal_error(void) ;
#line 249
int isanum(char const   *str ) ;
#line 252
int speechd_connection_new(int server_socket___0 ) ;
#line 253
int speechd_connection_destroy(int fd ) ;
#line 254
void speechd_modules_terminate(gpointer data , gpointer user_data ) ;
#line 255
void speechd_modules_reload(gpointer data , gpointer user_data ) ;
#line 256
void speechd_modules_debug(void) ;
#line 257
void speechd_modules_nodebug(void) ;
#line 259
void speechd_options_init(void) ;
#line 260
void speechd_init(void) ;
#line 261
int create_pid_file(void) ;
#line 262
void destroy_pid_file(void) ;
#line 264
void logging_init(void) ;
#line 266
void check_locked(pthread_mutex_t *lock ) ;
#line 27 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.h"
void symbols_preprocessing_add_file(char const   *name ) ;
#line 30
void insert_symbols(TSpeechDMessage *msg , int punct_missing ) ;
#line 44
SymLvl str2SymLvl(char const   *str ) ;
#line 151 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static LocaleMap *G_symbols_dicts  =    (LocaleMap *)((void *)0);
#line 153 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static LocaleMap *G_processors  =    (LocaleMap *)((void *)0);
#line 156
static GSList *symbols_files ;
#line 158 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
SymLvl str2SymLvl(char const   *str ) 
{ 
  SymLvl punct ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 162
  __cil_tmp3 = strcmp(str, "no\b");
  }
#line 162
  if (! __cil_tmp3) {
#line 163
    punct = (SymLvl )0;
  } else {
    {
#line 164
    __cil_tmp4 = strcmp(str, "none\332U");
    }
#line 164
    if (! __cil_tmp4) {
#line 165
      punct = (SymLvl )100;
    } else {
      {
#line 166
      __cil_tmp5 = strcmp(str, "all");
      }
#line 166
      if (! __cil_tmp5) {
#line 167
        punct = (SymLvl )500;
      } else {
        {
#line 168
        __cil_tmp6 = strcmp(str, "char\332U");
        }
#line 168
        if (! __cil_tmp6) {
#line 169
          punct = (SymLvl )1000;
        } else {
#line 171
          punct = (SymLvl )-1;
        }
      }
    }
  }
#line 173
  return (punct);
}
}
#line 178 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static LocaleMap *locale_map_new(GDestroyNotify value_destroy ) 
{ 
  GHashTable *__cil_tmp2 ;

  {
  {
#line 180
  __cil_tmp2 = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, value_destroy);
  }
#line 180
  return (__cil_tmp2);
}
}
#line 183 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gpointer locale_map_lookup(LocaleMap *map , gchar *locale , gchar *file ) 
{ 
  gchar *str ;
  gchar *__cil_tmp5 ;
  gpointer res ;
  gpointer __cil_tmp7 ;
  gpointer __cil_tmp8 ;

  {
#line 185
  if (file) {
    {
#line 186
    __cil_tmp5 = g_strdup_printf((gchar *)"%s %sU", locale, file);
#line 186
    str = __cil_tmp5;
#line 187
    __cil_tmp7 = g_hash_table_lookup(map, str);
#line 187
    res = __cil_tmp7;
#line 188
    g_free(str);
    }
#line 189
    return (res);
  } else {
    {
#line 191
    __cil_tmp8 = g_hash_table_lookup(map, locale);
    }
#line 191
    return (__cil_tmp8);
  }
}
}
#line 198 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gpointer locale_map_fetch(LocaleMap *map , gchar *locale , gchar *file , LocaleMapCreateDataFunc create ) 
{ 
  guint i ;
  gpointer value ;
  gchar *l ;
  gpointer __cil_tmp8 ;
  gchar *__cil_tmp9 ;
  gchar **parts ;
  gchar **__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  gpointer __cil_tmp13 ;
  gpointer __cil_tmp14 ;
  guint __cil_tmp15 ;

  {
#line 203
  i = (guint )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 2U)) {
#line 203
      goto while_break;
    }
#line 207
    if (i == 0U) {
      {
#line 208
      value = locale_map_lookup(map, locale, file);
#line 209
      l = g_strdup(locale);
      }
    } else {
      {
#line 211
      __cil_tmp11 = g_strsplit_set(locale, (gchar *)"_-L|\332U", 2);
#line 211
      parts = __cil_tmp11;
      }
#line 212
      if (! *(parts + 0)) {
        {
        {
#line 214
        g_strfreev(parts);
        }
        }
#line 215
        goto while_continue;
      } else
#line 212
      if (! *(parts + 1)) {
        {
        {
#line 214
        g_strfreev(parts);
        }
        }
#line 215
        goto while_continue;
      }
      {
#line 217
      l = g_strdup(*(parts + 0));
#line 218
      value = locale_map_lookup(map, l, file);
#line 219
      g_strfreev(parts);
      }
    }
#line 221
    if (value) {
      {
#line 222
      g_free(l);
      }
#line 223
      return (value);
    }
    {
#line 226
    value = (*create)(l, file);
    }
#line 227
    if (value) {
      {
#line 228
      g_hash_table_insert(map, l, value);
      }
#line 229
      return (value);
    }
    {
#line 231
    g_free(l);
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return ((void *)0);
}
}
#line 252 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gchar *escape_ssml_text(gchar *text , struct tags **tags_ret , gint *ntags_ret ) 
{ 
  gchar *cur ;
  gchar *curtag ;
  struct tags *tags ;
  GString *str ;
  gchar *result ;
  gchar name[7] ;
  gsize namepos ;
  int filling_tag ;
  int in_tag ;
  int in_tag_name ;
  int in_apos ;
  int in_quote ;
  gint ntags ;
  guchar c ;
  gint __cil_tmp18 ;
  gchar *__cil_tmp19 ;
  void *__cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  GString *__cil_tmp22 ;
  guchar c___0 ;
  gchar *__cil_tmp24 ;
  gint __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  gsize __cil_tmp35 ;
  gchar *__cil_tmp36 ;
  gchar *__cil_tmp37 ;
  gint __cil_tmp38 ;

  {
#line 254
  curtag = (gchar *)((void *)0);
#line 259
  namepos = (gsize )0;
#line 269
  filling_tag = 0;
#line 270
  in_tag = 0;
#line 271
  in_tag_name = 0;
#line 272
  in_apos = 0;
#line 273
  in_quote = 0;
#line 274
  ntags = 0;
#line 276
  cur = text;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! *cur) {
#line 276
      goto while_break;
    }
#line 277
    c = (guchar )*cur;
#line 279
    if (! in_tag) {
#line 280
      if ((int )c == 60) {
#line 281
        in_tag = 1;
#line 282
        if (! filling_tag) {
#line 283
          ntags ++;
#line 284
          filling_tag = 1;
        }
      } else {
#line 288
        filling_tag = 0;
      }
    } else
#line 291
    if (in_apos) {
#line 292
      if ((int )c == 39) {
#line 293
        in_apos = 0;
      }
    } else
#line 294
    if (in_quote) {
#line 295
      if ((int )c == 34) {
#line 296
        in_quote = 0;
      }
    } else
#line 297
    if ((int )c == 39) {
#line 298
      in_apos = 1;
    } else
#line 299
    if ((int )c == 34) {
#line 300
      in_quote = 1;
    } else
#line 301
    if ((int )c == 62) {
#line 302
      in_tag = 0;
    }
#line 276
    cur ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  tags = (struct tags *)malloc((unsigned long )ntags * sizeof(*tags));
#line 310
  filling_tag = 0;
#line 311
  in_tag = 0;
#line 312
  in_apos = 0;
#line 313
  in_quote = 0;
#line 314
  ntags = 0;
#line 316
  __cil_tmp21 = strlen(text);
#line 316
  __cil_tmp22 = g_string_sized_new(__cil_tmp21);
#line 316
  str = __cil_tmp22;
#line 318
  cur = text;
  }
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! *cur) {
#line 318
      goto while_break___0;
    }
#line 319
    c___0 = (guchar )*cur;
#line 321
    if (! in_tag) {
#line 322
      if ((int )c___0 == 60) {
#line 323
        in_tag = 1;
#line 324
        in_tag_name = 1;
#line 325
        namepos = (gsize )0;
#line 326
        if (! filling_tag) {
#line 328
          (tags + ntags)->pos = str->len;
#line 330
          (tags + ntags)->deferrable = 1;
#line 331
          curtag = cur;
#line 332
          filling_tag = 1;
        }
      } else {
#line 335
        if (filling_tag) {
          {
#line 337
          (tags + ntags)->tags = g_strndup(curtag, (gsize )(cur - curtag));
#line 338
          ntags ++;
#line 339
          filling_tag = 0;
          }
        }
#line 342
        if ((int )c___0 == 38) {
          {
#line 344
          __cil_tmp26 = strncmp(cur, "&quot;", (unsigned long )6);
          }
#line 344
          if (! __cil_tmp26) {
            {
#line 345
            cur += 5;
#line 346
            g_string_append_c_inline(str, (gchar )'\"');
            }
          } else {
            {
#line 347
            __cil_tmp27 = strncmp(cur, "&apos;", (unsigned long )6);
            }
#line 347
            if (! __cil_tmp27) {
              {
#line 348
              cur += 5;
#line 349
              g_string_append_c_inline(str, (gchar )'\'');
              }
            } else {
              {
#line 350
              __cil_tmp28 = strncmp(cur, "&lt;", (unsigned long )4);
              }
#line 350
              if (! __cil_tmp28) {
                {
#line 351
                cur += 3;
#line 352
                g_string_append_c_inline(str, (gchar )'<');
                }
              } else {
                {
#line 353
                __cil_tmp29 = strncmp(cur, "&gt;", (unsigned long )4);
                }
#line 353
                if (! __cil_tmp29) {
                  {
#line 354
                  cur += 3;
#line 355
                  g_string_append_c_inline(str, (gchar )'>');
                  }
                } else {
                  {
#line 356
                  __cil_tmp30 = strncmp(cur, "&amp;U", (unsigned long )5);
                  }
#line 356
                  if (! __cil_tmp30) {
                    {
#line 357
                    cur += 4;
#line 358
                    g_string_append_c_inline(str, (gchar )'&');
                    }
                  } else {
                    {
#line 360
                    g_string_append_c_inline(str, (gchar )c___0);
                    }
                  }
                }
              }
            }
          }
        } else {
          {
#line 363
          g_string_append_c_inline(str, (gchar )c___0);
          }
        }
      }
    } else
#line 367
    if (in_apos) {
#line 368
      if ((int )c___0 == 39) {
#line 369
        in_apos = 0;
      }
    } else
#line 370
    if (in_quote) {
#line 371
      if ((int )c___0 == 34) {
#line 372
        in_quote = 0;
      }
    } else
#line 373
    if ((int )c___0 == 39) {
#line 374
      in_apos = 1;
    } else
#line 375
    if ((int )c___0 == 34) {
#line 376
      in_quote = 1;
    } else {
#line 378
      if (in_tag_name) {
#line 379
        if ((int )c___0 == 62) {
          _L: /* CIL Label */ 
          _L___0: /* CIL Label */ 
          _L___1: /* CIL Label */ 
          _L___2: /* CIL Label */ 
          {
#line 380
          in_tag_name = 0;
#line 381
          name[namepos] = (gchar )'\000';
#line 382
          __cil_tmp34 = strcmp((char const   *)((gchar *)name), "!--|\332U");
          }
          {
#line 382
          __cil_tmp33 = strcmp((char const   *)((gchar *)name), "mark/");
          }
          {
#line 382
          __cil_tmp32 = strcmp((char const   *)((gchar *)name), "/markU");
          }
          {
#line 382
          __cil_tmp31 = strcmp((char const   *)((gchar *)name), "mark");
          }
#line 382
          if (__cil_tmp31) {
#line 382
            if (__cil_tmp32) {
#line 382
              if (__cil_tmp33) {
#line 382
                if (__cil_tmp34) {
#line 387
                  (tags + ntags)->deferrable = 0;
                }
              }
            }
          }
        } else
#line 379
        if ((int )c___0 == 32) {
#line 379
          goto _L;
        } else
#line 379
        if ((int )c___0 == 9) {
#line 379
          goto _L;
        } else
#line 379
        if ((int )c___0 == 13) {
#line 379
          goto _L;
        } else
#line 379
        if ((int )c___0 == 10) {
#line 379
          goto _L;
        } else
#line 390
        if (namepos < sizeof(name) - 1UL) {
#line 391
          __cil_tmp35 = namepos;
#line 391
          namepos ++;
#line 391
          name[__cil_tmp35] = (gchar )c___0;
        }
      }
#line 395
      if ((int )c___0 == 62) {
#line 396
        in_tag = 0;
      }
    }
#line 318
    cur ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 401
  if (filling_tag) {
    {
#line 402
    (tags + ntags)->tags = g_strndup(curtag, (gsize )(cur - curtag));
#line 403
    ntags ++;
    }
  }
  {
#line 406
  *tags_ret = tags;
#line 407
  *ntags_ret = ntags;
#line 409
  result = str->str;
#line 410
  g_string_free(str, 0);
  }
#line 412
  return (result);
}
}
#line 416 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gchar *unescape_ssml_text(gchar *text , struct tags *tags , gint ntags ) 
{ 
  GString *str ;
  gchar *cur ;
  gchar *result ;
  struct tags *curtags ;
  unsigned long __cil_tmp8 ;
  GString *__cil_tmp9 ;
  guchar c ;
  struct tags *__cil_tmp11 ;
  gint __cil_tmp12 ;
  gchar *__cil_tmp13 ;
  struct tags *__cil_tmp14 ;
  gint __cil_tmp15 ;

  {
  {
#line 421
  curtags = tags;
#line 423
  __cil_tmp8 = strlen(text);
#line 423
  __cil_tmp9 = g_string_sized_new(__cil_tmp8);
#line 423
  str = __cil_tmp9;
#line 425
  cur = text;
  }
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! *cur) {
#line 425
      goto while_break;
    }
    {
#line 428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 428
      if (! (ntags && (unsigned long )(cur - text) == curtags->pos)) {
#line 428
        goto while_break___0;
      }
      {
#line 430
      g_string_append(str, curtags->tags);
#line 431
      curtags ++;
#line 432
      __cil_tmp12 = ntags;
#line 432
      ntags --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 435
    c = (guchar )*cur;
#line 438
    if ((int )c == 34) {
      {
#line 439
      g_string_append(str, (gchar *)"&quot;");
      }
    } else
#line 440
    if ((int )c == 39) {
      {
#line 441
      g_string_append(str, (gchar *)"&apos;");
      }
    } else
#line 442
    if ((int )c == 60) {
      {
#line 443
      g_string_append(str, (gchar *)"&lt;");
      }
    } else
#line 444
    if ((int )c == 62) {
      {
#line 445
      g_string_append(str, (gchar *)"&gt;");
      }
    } else
#line 446
    if ((int )c == 38) {
      {
#line 447
      g_string_append(str, (gchar *)"&amp;");
      }
    } else {
      {
#line 449
      g_string_append_c_inline(str, (gchar )c);
      }
    }
#line 425
    cur ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    if (! ntags) {
#line 452
      goto while_break___1;
    }
    {
#line 454
    g_string_append(str, curtags->tags);
#line 455
    curtags ++;
#line 456
    __cil_tmp15 = ntags;
#line 456
    ntags --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 459
  free(tags);
#line 461
  result = str->str;
#line 462
  g_string_free(str, 0);
  }
#line 464
  return (result);
}
}
#line 469 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static SpeechSymbol *speech_symbol_new(void) 
{ 
  SpeechSymbol *sym ;
  gpointer __cil_tmp2 ;

  {
  {
#line 471
  __cil_tmp2 = g_slice_alloc(sizeof(*sym));
#line 471
  sym = __cil_tmp2;
#line 473
  sym->identifier = (char *)((void *)0);
#line 474
  sym->pattern = (char *)((void *)0);
#line 475
  sym->replacement = (char *)((void *)0);
#line 476
  sym->level = (SymLvl )-1;
#line 477
  sym->preserve = (SymPresMode )-1;
#line 478
  sym->display_name = (char *)((void *)0);
  }
#line 480
  return (sym);
}
}
#line 483 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static void speech_symbol_free(SpeechSymbol *sym ) 
{ 


  {
  {
#line 486
  g_free(sym->pattern);
#line 487
  g_free(sym->replacement);
#line 488
  g_free(sym->display_name);
#line 489
  g_slice_free1(sizeof(*sym), sym);
  }
  return;
}
}
#line 493 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int skip_line(char const   *line ) 
{ 
  char const   *__cil_tmp2 ;

  {
#line 495
  if ((int )*line == 35) {
#line 496
    return (1);
  }
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (((int )*(g_ascii_table + (guchar )*line) & 256) != 0)) {
#line 497
      goto while_break;
    }
#line 498
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return ((int )*line == 0);
}
}
#line 503 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static void strip_newline(char *line ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (((int )*line && (int )*line != 13) && (int )*line != 10)) {
#line 505
      goto while_break;
    }
#line 506
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  *line = (char )0;
  return;
}
}
#line 511 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int speech_symbols_load_complex_symbol(SpeechSymbols *ss , char const   *line ) 
{ 
  char **parts ;
  gchar **__cil_tmp4 ;
  guint __cil_tmp5 ;
  GSList *__cil_tmp6 ;

  {
  {
#line 513
  __cil_tmp4 = g_strsplit(line, (gchar *)"\t$v|\332U", 2);
#line 513
  parts = __cil_tmp4;
#line 515
  __cil_tmp5 = g_strv_length(parts);
  }
#line 515
  if (__cil_tmp5 != 2U) {
    {
#line 516
    g_strfreev(parts);
    }
#line 517
    return (- 1);
  }
  {
#line 520
  ss->complex_symbols = g_slist_prepend(ss->complex_symbols, parts);
  }
#line 522
  return (0);
}
}
#line 527 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int speech_symbols_load_int_field(IntFieldDesc *map , guint map_len , char const   *name ,
                                         int *value ) 
{ 
  guint i ;
  int __cil_tmp6 ;
  guint __cil_tmp7 ;

  {
#line 532
  i = (guint )0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < map_len)) {
#line 532
      goto while_break;
    }
    {
#line 533
    __cil_tmp6 = strcmp((map + i)->name, name);
    }
#line 533
    if (__cil_tmp6 == 0) {
#line 534
      *value = (map + i)->value;
#line 535
      return (0);
    }
#line 532
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (- 1);
}
}
#line 545 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int speech_symbols_load_symbol(SpeechSymbols *ss , char const   *line ) 
{ 
  char **parts ;
  gchar **__cil_tmp4 ;
  guint len ;
  guint __cil_tmp6 ;
  char *display_name ;
  char *identifier ;
  char *replacement ;
  int level ;
  int pres_mode ;
  SpeechSymbol *sym ;
  char const   *p ;
  char const   *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  IntFieldDesc map[5] ;
  int __cil_tmp17 ;
  IntFieldDesc map___0[6] ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  gchar *__cil_tmp21 ;
  gchar *__cil_tmp22 ;
  gchar *__cil_tmp23 ;
  SpeechSymbol *__cil_tmp24 ;

  {
  {
#line 547
  __cil_tmp4 = g_strsplit(line, (gchar *)"\t\374u|\332U", - 1);
#line 547
  parts = __cil_tmp4;
#line 548
  __cil_tmp6 = g_strv_length(parts);
#line 548
  len = __cil_tmp6;
#line 549
  display_name = (char *)((void *)0);
#line 550
  identifier = (char *)((void *)0);
#line 551
  replacement = (char *)((void *)0);
#line 552
  level = -1;
#line 553
  pres_mode = -1;
  }
#line 557
  if (len > 0U) {
#line 557
    if ((int )*(*(parts + (len - 1U)) + 0) == 35) {
#line 562
      display_name = *(parts + (len - 1U));
#line 563
      len --;
#line 563
      *(parts + len) = (char *)((void *)0);
#line 565
      p = (char const   *)(display_name + 1);
      {
#line 566
      while (1) {
        while_continue: /* CIL Label */ ;
#line 566
        if (! (((int )*(g_ascii_table + (guchar )*p) & 256) != 0)) {
#line 566
          goto while_break;
        }
#line 567
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 568
      __cil_tmp15 = strlen(p);
#line 568
      memmove(display_name, p, __cil_tmp15 + 1UL);
      }
    }
  }
#line 572
  if (len > 3U) {
#line 573
    map[0].name = "-";
#line 573
    map[0].value = 0;
#line 573
    map[1].name = "neverU";
#line 573
    map[1].value = 0;
#line 573
    map[2].name = "always";
#line 573
    map[2].value = 1;
#line 573
    map[3].name = "norep";
#line 573
    map[3].value = 2;
#line 573
    map[4].name = "literal";
    {
#line 573
    map[4].value = 3;
#line 581
    __cil_tmp17 = speech_symbols_load_int_field((IntFieldDesc *)map, (guint )(sizeof(map) / sizeof(map[0])),
                                                (char const   *)*(parts + 3), & pres_mode);
    }
#line 581
    if (__cil_tmp17 < 0) {
#line 583
      goto err;
    }
  }
#line 587
  if (len > 2U) {
#line 588
    map___0[0].name = "-";
#line 588
    map___0[0].value = 100;
#line 588
    map___0[1].name = "none\332U";
#line 588
    map___0[1].value = 100;
#line 588
    map___0[2].name = "some\332U";
#line 588
    map___0[2].value = 200;
#line 588
    map___0[3].name = "most";
#line 588
    map___0[3].value = 300;
#line 588
    map___0[4].name = "all|\332U";
#line 588
    map___0[4].value = 500;
#line 588
    map___0[5].name = "char";
    {
#line 588
    map___0[5].value = 1000;
#line 597
    __cil_tmp19 = speech_symbols_load_int_field((IntFieldDesc *)map___0, (guint )(sizeof(map___0) / sizeof(map___0[0])),
                                                (char const   *)*(parts + 2), & level);
    }
#line 597
    if (__cil_tmp19 < 0) {
#line 599
      goto err;
    }
  }
#line 603
  if (! *(parts + 0)) {
#line 604
    goto err;
  } else
#line 603
  if (len < 2U) {
#line 604
    goto err;
  } else
#line 603
  if (! *(*(parts + 0) + 0)) {
#line 604
    goto err;
  }
  {
#line 607
  __cil_tmp20 = strcmp((char const   *)*(parts + 1), "-\320u|\332U");
  }
#line 607
  if (__cil_tmp20 == 0) {
#line 608
    replacement = (char *)((void *)0);
  } else {
    {
#line 610
    replacement = g_strdup(*(parts + 1));
    }
  }
#line 613
  if ((int )*(*(parts + 0) + 0) == 92) {
#line 613
    if ((int )*(*(parts + 0) + 1)) {
      {
#line 614
      identifier = g_strdup(*(parts + 0) + 1);
      }
      {
#line 616
      if ((int )*(identifier + 0) == '0') {
#line 616
        goto case_48;
      }
#line 622
      if ((int )*(identifier + 0) == 't') {
#line 622
        goto case_116;
      }
#line 623
      if ((int )*(identifier + 0) == 'n') {
#line 623
        goto case_110;
      }
#line 624
      if ((int )*(identifier + 0) == 'r') {
#line 624
        goto case_114;
      }
#line 625
      if ((int )*(identifier + 0) == 'f') {
#line 625
        goto case_102;
      }
#line 626
      if ((int )*(identifier + 0) == 'v') {
#line 626
        goto case_118;
      }
#line 628
      if ((int )*(identifier + 0) == '\\') {
#line 628
        goto case_92;
      }
#line 628
      if ((int )*(identifier + 0) == '#') {
#line 628
        goto case_92;
      }
#line 615
      goto switch_break;
      case_48: /* CIL Label */ 
#line 617
      *(identifier + 0) = (char )'\000';
      {
#line 619
      MSG2(1, "symbols", "Loading NUL byte entry is not yet supported");
      }
#line 620
      goto err;
#line 621
      goto switch_break;
      case_116: /* CIL Label */ 
#line 622
      *(identifier + 0) = (char )'\t';
#line 622
      goto switch_break;
      case_110: /* CIL Label */ 
#line 623
      *(identifier + 0) = (char )'\n';
#line 623
      goto switch_break;
      case_114: /* CIL Label */ 
#line 624
      *(identifier + 0) = (char )'\r';
#line 624
      goto switch_break;
      case_102: /* CIL Label */ 
#line 625
      *(identifier + 0) = (char )'\f';
#line 625
      goto switch_break;
      case_118: /* CIL Label */ 
#line 626
      *(identifier + 0) = (char )'\v';
#line 626
      goto switch_break;
      case_92: /* CIL Label */ 
      case_35: /* CIL Label */ 
#line 630
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 633
      identifier = g_strdup(*(parts + 0));
      }
      }
    }
  } else {
    {
    {
#line 633
    identifier = g_strdup(*(parts + 0));
    }
    }
  }
  {
#line 635
  sym = speech_symbol_new();
#line 636
  sym->identifier = identifier;
#line 637
  sym->replacement = replacement;
#line 638
  sym->level = (SymLvl )level;
#line 639
  sym->preserve = (SymPresMode )pres_mode;
#line 640
  sym->display_name = display_name;
#line 642
  g_hash_table_insert(ss->symbols, sym->identifier, sym);
#line 644
  g_strfreev(parts);
  }
#line 646
  return (0);
  err: 
  {
#line 649
  g_free(display_name);
  }
  {
#line 650
  g_free(identifier);
#line 651
  g_free(replacement);
#line 652
  g_strfreev(parts);
  }
#line 654
  return (- 1);
}
}
#line 658 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int speech_symbols_load(SpeechSymbols *ss , char const   *filename , gboolean allow_complex ) 
{ 
  FILE *fp ;
  char *line ;
  size_t n ;
  unsigned char bom[3] ;
  int (*handler)(SpeechSymbols * , char const   * ) ;
  FILE *__cil_tmp9 ;
  int *__cil_tmp10 ;
  gchar *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  __ssize_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 661
  line = (char *)((void *)0);
#line 662
  n = (size_t )0;
#line 665
  handler = (int (*)(SpeechSymbols * , char const   * ))((void *)0);
#line 667
  fp = fopen(filename, "r");
  }
#line 668
  if (! fp) {
    {
#line 669
    __cil_tmp10 = __errno_location();
#line 669
    __cil_tmp11 = g_strerror(*__cil_tmp10);
#line 669
    MSG2(1, "symbols", "Failed to open file \'%s\': %s", filename, __cil_tmp11);
    }
#line 670
    return (- 1);
  }
  {
#line 674
  __cil_tmp12 = fread((unsigned char *)bom, sizeof(*((unsigned char *)bom)), sizeof(bom),
                      fp);
  }
#line 674
  if (__cil_tmp12 != sizeof(bom)) {
    {
    {
    {
    {
#line 676
    fseek(fp, (long )0, 0);
    }
    }
    }
    }
  } else
#line 674
  if ((int )bom[0] != 239) {
    {
    {
    {
    {
#line 676
    fseek(fp, (long )0, 0);
    }
    }
    }
    }
  } else
#line 674
  if ((int )bom[1] != 187) {
    {
    {
    {
    {
#line 676
    fseek(fp, (long )0, 0);
    }
    }
    }
    }
  } else
#line 674
  if ((int )bom[2] != 191) {
    {
    {
    {
    {
#line 676
    fseek(fp, (long )0, 0);
    }
    }
    }
    }
  }
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 678
    __cil_tmp13 = getline(& line, & n, fp);
    }
#line 678
    if (! (__cil_tmp13 >= 0L)) {
#line 678
      goto while_break;
    }
    {
#line 679
    __cil_tmp14 = skip_line((char const   *)line);
    }
#line 679
    if (__cil_tmp14) {
#line 680
      goto while_continue;
    }
    {
#line 681
    strip_newline(line);
#line 683
    __cil_tmp15 = strcmp((char const   *)line, "complexSymbols:");
    }
#line 683
    if (allow_complex) {
#line 683
      if (__cil_tmp15 == 0) {
#line 684
        handler = & speech_symbols_load_complex_symbol;
      } else {
#line 683
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 685
      __cil_tmp16 = strcmp((char const   *)line, "symbols:\220");
      }
#line 685
      if (__cil_tmp16 == 0) {
#line 686
        handler = & speech_symbols_load_symbol;
      } else {
        {
#line 687
        __cil_tmp17 = (*handler)(ss, (char const   *)line);
        }
#line 687
        if (! handler) {
          {
          {
#line 688
          MSG2(1, "symbols", "Invalid line in file %s: %s", filename, line);
          }
          }
        } else
#line 687
        if (__cil_tmp17 < 0) {
          {
          {
#line 688
          MSG2(1, "symbols", "Invalid line in file %s: %s", filename, line);
          }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  free(line);
#line 694
  fclose(fp);
  }
#line 696
  return (0);
}
}
#line 699 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static void speech_symbols_free(SpeechSymbols *ss ) 
{ 


  {
  {
#line 701
  g_slist_free_full(ss->complex_symbols, (GDestroyNotify )(& g_strfreev));
#line 702
  g_hash_table_destroy(ss->symbols);
#line 703
  g_free(ss->source);
#line 704
  g_free(ss);
  }
  return;
}
}
#line 709 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gpointer speech_symbols_new(gchar *locale , gchar *file ) 
{ 
  SpeechSymbols *ss ;
  gpointer __cil_tmp4 ;
  gchar *path ;
  GHashTable *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  int __cil_tmp8 ;
  GSList *__cil_tmp9 ;
  gchar *__cil_tmp10 ;

  {
  {
#line 711
  __cil_tmp4 = g_malloc(sizeof(*ss));
#line 711
  ss = __cil_tmp4;
#line 714
  ss->complex_symbols = (GSList *)((void *)0);
#line 715
  ss->source = (gchar *)((void *)0);
#line 716
  ss->symbols = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, (GDestroyNotify )(& speech_symbol_free));
#line 720
  path = g_build_filename((gchar *)"/usr/share/speech-dispatcher/locale", locale,
                          file, (void *)0);
#line 721
  MSG2(5, "symbols", "Trying to load %s for \'%s\' from \'%s\'", file, locale, path);
#line 722
  __cil_tmp8 = speech_symbols_load(ss, (char const   *)path, ! 0);
  }
#line 722
  if (__cil_tmp8 >= 0) {
    {
#line 723
    MSG2(5, "symbols", "Successful");
#line 728
    ss->complex_symbols = g_slist_reverse(ss->complex_symbols);
#line 729
    ss->source = g_strdup(file);
    }
  } else {
    {
#line 732
    MSG2(5, "symbols", "Failed");
#line 733
    speech_symbols_free(ss);
#line 734
    ss = (SpeechSymbols *)((void *)0);
    }
  }
  {
#line 736
  g_free(path);
  }
#line 738
  return (ss);
}
}
#line 741 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static SpeechSymbols *get_locale_speech_symbols(gchar *locale , gchar *file ) 
{ 
  LocaleMap *__cil_tmp3 ;
  gpointer __cil_tmp4 ;

  {
#line 743
  if (! G_symbols_dicts) {
    {
#line 744
    G_symbols_dicts = locale_map_new((GDestroyNotify )(& speech_symbols_free));
    }
  }
  {
#line 747
  __cil_tmp4 = locale_map_fetch(G_symbols_dicts, locale, file, & speech_symbols_new);
  }
#line 747
  return (__cil_tmp4);
}
}
#line 750 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
void symbols_preprocessing_add_file(char const   *name ) 
{ 
  gchar *__cil_tmp2 ;
  GSList *__cil_tmp3 ;

  {
  {
#line 752
  MSG2(5, "symbols", "Will load symbol file %s\230\001", name);
#line 753
  __cil_tmp2 = g_strdup(name);
#line 753
  __cil_tmp3 = g_slist_append(symbols_files, __cil_tmp2);
#line 753
  symbols_files = __cil_tmp3;
  }
  return;
}
}
#line 759 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gint list_sort_string_longest_first(gconstpointer a , gconstpointer b ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 761
  __cil_tmp4 = strlen(a);
  }
  {
#line 761
  __cil_tmp3 = strlen(b);
  }
#line 761
  return ((gint )(__cil_tmp3 - __cil_tmp4));
}
}
#line 764 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static void speech_symbols_processor_free(SpeechSymbolProcessor *ssp ) 
{ 


  {
#line 766
  if (ssp->regex) {
    {
#line 767
    g_regex_unref(ssp->regex);
    }
  }
  {
#line 768
  g_slist_free(ssp->complex_list);
  }
#line 769
  if (ssp->symbols) {
    {
#line 770
    g_hash_table_unref(ssp->symbols);
    }
  }
  {
#line 771
  g_free(ssp->source);
#line 772
  g_free(ssp);
  }
  return;
}
}
#line 775 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static void speech_symbols_processor_list_free(GSList *sspl ) 
{ 
  GSList *e ;

  {
#line 778
  e = sspl;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
#line 778
    if (! e) {
#line 778
      goto while_break;
    }
    {
#line 779
    speech_symbols_processor_free(e->data);
    }
#line 778
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 784 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static SpeechSymbolProcessor *speech_symbols_processor_new(char const   *locale ,
                                                           SpeechSymbols *syms ) 
{ 
  SpeechSymbolProcessor *ssp ;
  SpeechSymbols *ssbase ;
  GHashTableIter iter ;
  gpointer key ;
  gpointer value ;
  GString *characters ;
  GSList *multi_chars_list ;
  gchar *escaped ;
  GString *escaped_multi ;
  GString *pattern ;
  GError *error ;
  GSList *sources ;
  GSList *node ;
  int has_dash ;
  int has_rbracket ;
  int has_circum ;
  GSList *__cil_tmp19 ;
  SpeechSymbols *__cil_tmp20 ;
  GSList *__cil_tmp21 ;
  gpointer __cil_tmp22 ;
  gchar *__cil_tmp23 ;
  GHashTable *__cil_tmp24 ;
  SpeechSymbols *syms___3 ;
  GSList *node2 ;
  SpeechSymbol *sym ;
  gchar **key_val ;
  gboolean __cil_tmp29 ;
  SpeechSymbol *__cil_tmp30 ;
  gchar *__cil_tmp31 ;
  gchar *__cil_tmp32 ;
  GSList *__cil_tmp33 ;
  GSList *__cil_tmp34 ;
  GString *__cil_tmp35 ;
  SpeechSymbols *syms___4 ;
  gboolean __cil_tmp37 ;
  SpeechSymbol *source_sym ;
  SpeechSymbol *sym___0 ;
  gpointer __cil_tmp40 ;
  SpeechSymbol *__cil_tmp41 ;
  gchar *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  GSList *__cil_tmp44 ;
  gchar *__cil_tmp45 ;
  gchar *__cil_tmp46 ;
  gboolean __cil_tmp47 ;
  SpeechSymbol *sym___1 ;
  GSList *__cil_tmp49 ;
  gchar *__cil_tmp50 ;
  gchar *__cil_tmp51 ;
  GSList *__cil_tmp52 ;
  GString *__cil_tmp53 ;
  guint i ;
  SpeechSymbol *sym___2 ;
  guint __cil_tmp56 ;
  GString *__cil_tmp57 ;
  gchar *__cil_tmp58 ;
  GRegex *__cil_tmp59 ;

  {
  {
#line 786
  ssp = (SpeechSymbolProcessor *)((void *)0);
#line 791
  multi_chars_list = (GSList *)((void *)0);
#line 795
  error = (GError *)((void *)0);
#line 796
  sources = (GSList *)((void *)0);
#line 798
  has_dash = 0;
#line 799
  has_rbracket = 0;
#line 800
  has_circum = 0;
#line 802
  sources = g_slist_append(sources, syms);
#line 804
  ssbase = get_locale_speech_symbols((gchar *)"base", syms->source);
  }
#line 805
  if (ssbase) {
    {
#line 806
    sources = g_slist_append(sources, ssbase);
    }
  }
  {
#line 808
  ssp = (SpeechSymbolProcessor *)g_malloc(sizeof(*ssp));
#line 809
  ssp->source = g_strdup(syms->source);
#line 811
  ssp->symbols = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, (GDestroyNotify )(& speech_symbol_free));
#line 815
  ssp->complex_list = (GSList *)((void *)0);
#line 818
  node = sources;
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! node) {
#line 818
      goto while_break;
    }
#line 819
    syms___3 = node->data;
#line 822
    node2 = syms___3->complex_symbols;
    {
#line 822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 822
      if (! node2) {
#line 822
        goto while_break___0;
      }
      {
#line 824
      key_val = node2->data;
#line 826
      __cil_tmp29 = g_hash_table_contains(ssp->symbols, *(key_val + 0));
      }
#line 826
      if (__cil_tmp29) {
#line 828
        goto while_continue___0;
      }
      {
#line 831
      sym = speech_symbol_new();
#line 832
      sym->identifier = g_strdup(*(key_val + 0));
#line 833
      sym->pattern = g_strdup(*(key_val + 1));
#line 834
      g_hash_table_insert(ssp->symbols, sym->identifier, sym);
#line 835
      ssp->complex_list = g_slist_prepend(ssp->complex_list, sym);
      }
#line 822
      node2 = node2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 818
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 839
  ssp->complex_list = g_slist_reverse(ssp->complex_list);
#line 842
  characters = g_string_new((gchar *)((void *)0));
#line 843
  node = sources;
  }
  {
#line 843
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 843
    if (! node) {
#line 843
      goto while_break___1;
    }
    {
#line 844
    syms___4 = node->data;
#line 846
    g_hash_table_iter_init(& iter, syms___4->symbols);
    }
    {
#line 847
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 847
      __cil_tmp37 = g_hash_table_iter_next(& iter, & key, & value);
      }
#line 847
      if (! __cil_tmp37) {
#line 847
        goto while_break___2;
      }
      {
#line 848
      source_sym = value;
#line 851
      sym___0 = (SpeechSymbol *)g_hash_table_lookup(ssp->symbols, key);
      }
#line 852
      if (! sym___0) {
        {
#line 855
        sym___0 = speech_symbol_new();
#line 856
        sym___0->identifier = g_strdup(key);
#line 857
        g_hash_table_insert(ssp->symbols, sym___0->identifier, sym___0);
#line 858
        __cil_tmp43 = strlen((char const   *)sym___0->identifier);
        }
#line 858
        if (__cil_tmp43 == 1UL) {
          {
#line 860
          if ((int )*(sym___0->identifier + 0) == '-') {
#line 860
            goto case_45;
          }
#line 863
          if ((int )*(sym___0->identifier + 0) == ']') {
#line 863
            goto case_93;
          }
#line 866
          if ((int )*(sym___0->identifier + 0) == '^') {
#line 866
            goto case_94;
          }
#line 869
          goto switch_default;
          case_45: /* CIL Label */ 
#line 861
          has_dash = 1;
#line 862
          goto switch_break;
          case_93: /* CIL Label */ 
#line 864
          has_rbracket = 1;
#line 865
          goto switch_break;
          case_94: /* CIL Label */ 
#line 867
          has_circum = 1;
#line 868
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 870
          g_string_append_c_inline(characters, *(sym___0->identifier + 0));
          }
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 873
          multi_chars_list = g_slist_prepend(multi_chars_list, sym___0->identifier);
          }
        }
      }
#line 877
      if (sym___0->replacement == (void *)0) {
        {
#line 878
        sym___0->replacement = g_strdup(source_sym->replacement);
        }
      }
#line 879
      if ((int )sym___0->level == -1) {
#line 880
        sym___0->level = source_sym->level;
      }
#line 881
      if ((int )sym___0->preserve == -1) {
#line 882
        sym___0->preserve = source_sym->preserve;
      }
#line 883
      if (sym___0->display_name == (void *)0) {
        {
#line 884
        sym___0->display_name = g_strdup(source_sym->display_name);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 843
    node = node->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 889
  g_hash_table_iter_init(& iter, ssp->symbols);
  }
  {
#line 890
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 890
    __cil_tmp47 = g_hash_table_iter_next(& iter, & key, & value);
    }
#line 890
    if (! __cil_tmp47) {
#line 890
      goto while_break___3;
    }
#line 891
    sym___1 = value;
#line 893
    if (! sym___1->replacement) {
      {
#line 895
      MSG2(2, "symbols", "Replacement not defined in locale %s for symbol: %s", locale,
           sym___1->identifier);
#line 898
      ssp->complex_list = g_slist_remove(ssp->complex_list, sym___1);
#line 899
      g_hash_table_iter_remove(& iter);
      }
#line 900
      goto while_continue___3;
    }
#line 902
    if ((int )sym___1->level == -1) {
#line 903
      sym___1->level = (SymLvl )500;
    }
#line 904
    if ((int )sym___1->preserve == -1) {
#line 905
      sym___1->preserve = (SymPresMode )0;
    }
#line 906
    if (sym___1->display_name == (void *)0) {
      {
#line 907
      sym___1->display_name = g_strdup(sym___1->identifier);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 913
  escaped = g_regex_escape_string(characters->str, (gint )characters->len);
#line 914
  g_string_truncate(characters, (gsize )0);
  }
#line 915
  if ((int )*escaped) {
    _L: /* CIL Label */ 
    _L___5: /* CIL Label */ 
    _L___6: /* CIL Label */ 
    {
#line 916
    g_string_append_printf(characters, (gchar *)"[%s", escaped);
    }
#line 917
    if (has_dash) {
      {
#line 918
      g_string_append_printf(characters, (gchar *)"\\-");
      }
    }
#line 919
    if (has_rbracket) {
      {
#line 920
      g_string_append_printf(characters, (gchar *)"\\]");
      }
    }
#line 921
    if (has_circum) {
      {
#line 922
      g_string_append_printf(characters, (gchar *)"\\^");
      }
    }
    {
#line 923
    g_string_append_c_inline(characters, (gchar )']');
    }
  } else
#line 915
  if (has_dash) {
#line 915
    goto _L;
  } else
#line 915
  if (has_rbracket) {
#line 915
    goto _L;
  } else
#line 915
  if (has_circum) {
#line 915
    goto _L;
  }
  {
#line 925
  g_free(escaped);
#line 928
  multi_chars_list = g_slist_sort(multi_chars_list, & list_sort_string_longest_first);
#line 931
  pattern = g_string_new((gchar *)((void *)0));
#line 933
  g_string_append(pattern, (gchar *)"(?P<rstripSpace>  +$)");
  }
#line 935
  if (characters->len) {
    {
#line 936
    g_string_append_c_inline(pattern, (gchar )'|');
#line 937
    g_string_append_printf(pattern, (gchar *)"(?P<repeated>(?P<repTmp>%s)(?P=repTmp){3,})",
                           characters->str);
    }
  }
#line 941
  i = (guint )0;
#line 942
  node = ssp->complex_list;
  {
#line 942
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 942
    if (! node) {
#line 942
      goto while_break___4;
    }
    {
#line 943
    sym___2 = node->data;
#line 944
    g_string_append_c_inline(pattern, (gchar )'|');
#line 945
    g_string_append_printf(pattern, (gchar *)"(?P<c%u>%s)", i, sym___2->pattern);
    }
#line 942
    __cil_tmp56 = i;
#line 942
    i ++;
#line 942
    node = node->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 950
  escaped_multi = g_string_new((gchar *)((void *)0));
#line 951
  node = multi_chars_list;
  }
  {
#line 951
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 951
    if (! node) {
#line 951
      goto while_break___5;
    }
    {
#line 952
    escaped = g_regex_escape_string(node->data, - 1);
    }
#line 953
    if (escaped_multi->len > 0UL) {
      {
#line 954
      g_string_append_c_inline(escaped_multi, (gchar )'|');
      }
    }
    {
#line 955
    g_string_append(escaped_multi, escaped);
#line 956
    g_free(escaped);
    }
#line 951
    node = node->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 958
  if (escaped_multi->len) {
    _L___7: /* CIL Label */ 
    {
#line 959
    g_string_append_c_inline(pattern, (gchar )'|');
#line 960
    g_string_append_printf(pattern, (gchar *)"(?P<simple>");
    }
#line 961
    if (escaped_multi->len) {
      {
#line 962
      g_string_append_printf(pattern, (gchar *)"%s", escaped_multi->str);
      }
    }
#line 963
    if (escaped_multi->len) {
#line 963
      if (characters->len) {
        {
#line 964
        g_string_append_printf(pattern, (gchar *)"|");
        }
      }
    }
#line 965
    if (characters->len) {
      {
#line 966
      g_string_append_printf(pattern, (gchar *)"%s", characters->str);
      }
    }
    {
#line 967
    g_string_append_printf(pattern, (gchar *)")");
    }
  } else
#line 958
  if (characters->len) {
#line 958
    goto _L___7;
  }
  {
#line 969
  g_string_free(escaped_multi, ! 0);
#line 971
  MSG2(5, "symbols", "building regex: %s", pattern->str);
#line 972
  ssp->regex = g_regex_new(pattern->str, (GRegexCompileFlags )8192, (GRegexMatchFlags )0,
                           & error);
  }
#line 973
  if (! ssp->regex) {
    {
#line 975
    MSG2(1, "symbols", "ERROR compiling regular expression: %s. This is likely due to an invalid complex symbol regular expression in locale %s.\230\001",
         error->message, locale);
#line 979
    g_error_free(error);
#line 980
    speech_symbols_processor_free(ssp);
#line 981
    ssp = (SpeechSymbolProcessor *)((void *)0);
    }
  }
  {
#line 984
  g_string_free(pattern, ! 0);
#line 985
  g_string_free(characters, ! 0);
#line 986
  g_slist_free(multi_chars_list);
#line 987
  g_slist_free(sources);
  }
#line 989
  return (ssp);
}
}
#line 994 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gpointer speech_symbols_processor_list_new(char const   *locale , char const   *file ) 
{ 
  SpeechSymbolProcessor *ssp ;
  SpeechSymbols *ss ;
  GSList *sspl ;
  GSList *node ;
  SpeechSymbols *__cil_tmp7 ;
  SpeechSymbolProcessor *__cil_tmp8 ;
  GSList *__cil_tmp9 ;
  GSList *__cil_tmp10 ;

  {
#line 998
  sspl = (GSList *)((void *)0);
#line 1003
  node = symbols_files;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (! node) {
#line 1003
      goto while_break;
    }
    {
#line 1004
    ss = get_locale_speech_symbols(locale, node->data);
    }
#line 1005
    if (! ss) {
      {
#line 1006
      MSG2(1, "symbols", "Failed to load symbols \'%s\' for locale \'%s\'", (char *)node->data,
           locale);
      }
    } else {
      {
#line 1009
      ssp = speech_symbols_processor_new(locale, ss);
      }
#line 1010
      if (ssp) {
        {
#line 1011
        sspl = g_slist_prepend(sspl, ssp);
        }
      }
    }
#line 1003
    node = node->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1018
  sspl = g_slist_reverse(sspl);
  }
#line 1020
  return (sspl);
}
}
#line 1025 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gchar *fetch_named_matching(GMatchInfo *match_info , gchar *name ) 
{ 
  gchar *capture ;
  gchar *__cil_tmp4 ;

  {
  {
#line 1027
  __cil_tmp4 = g_match_info_fetch_named(match_info, name);
#line 1027
  capture = __cil_tmp4;
  }
#line 1029
  if (capture) {
#line 1029
    if (! *capture) {
      {
#line 1030
      g_free(capture);
#line 1031
      capture = (gchar *)((void *)0);
      }
    }
  }
#line 1034
  return (capture);
}
}
#line 1045 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gint find_nexttag(struct tags *tags , gint pos , gint firsttag , gint endtag ) 
{ 
  gint middletag ;
  gint __cil_tmp6 ;
  gint __cil_tmp7 ;

  {
#line 1049
  if (endtag == firsttag) {
#line 1051
    return (endtag);
  }
#line 1053
  if ((tags + firsttag)->pos > (unsigned long )pos) {
#line 1055
    return (firsttag);
  }
#line 1057
  middletag = ((firsttag + 1) + endtag) / 2;
#line 1058
  if (middletag == endtag) {
#line 1060
    return (endtag);
  }
#line 1062
  if ((tags + middletag)->pos > (unsigned long )pos) {
    {
#line 1063
    __cil_tmp6 = find_nexttag(tags, pos, firsttag, middletag);
    }
#line 1063
    return (__cil_tmp6);
  } else {
    {
#line 1065
    __cil_tmp7 = find_nexttag(tags, pos, middletag, endtag);
    }
#line 1065
    return (__cil_tmp7);
  }
}
}
#line 1068 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static int replace_groups(GMatchInfo *match_info , GString *result , char *replacement ,
                          gint pos ) 
{ 
  int in_escape ;
  char c ;
  char *__cil_tmp7 ;
  gchar *res ;
  gchar *__cil_tmp9 ;

  {
#line 1070
  in_escape = 0;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    __cil_tmp7 = replacement;
#line 1073
    replacement ++;
#line 1073
    c = *__cil_tmp7;
#line 1073
    if (! c) {
#line 1073
      goto while_break;
    }
#line 1074
    if (! in_escape) {
#line 1075
      if ((int )c == 92) {
#line 1076
        in_escape = 1;
      } else {
        {
#line 1078
        g_string_append_c_inline(result, c);
        }
      }
    } else {
#line 1080
      if ((int )c == 92) {
        {
#line 1081
        g_string_append_c_inline(result, (gchar )'\\');
        }
      } else
#line 1082
      if ((int )c >= 48) {
#line 1082
        if ((int )c <= 57) {
          {
#line 1083
          __cil_tmp9 = g_match_info_fetch(match_info, pos + ((int )c - 48));
#line 1083
          res = __cil_tmp9;
          }
#line 1084
          if (res) {
            {
#line 1085
            g_string_append(result, res);
            }
          } else {
            {
#line 1087
            MSG2(1, "symbols", "Unmatched reference \\%c", (int )c);
            }
          }
        } else {
          {
          {
#line 1089
          MSG2(1, "symbols", "Invalid reference \\%cU", (int )c);
          }
          {
#line 1090
          g_string_append_c_inline(result, c);
          }
          }
        }
      } else {
        {
        {
#line 1089
        MSG2(1, "symbols", "Invalid reference \\%cU", (int )c);
        }
        {
#line 1090
        g_string_append_c_inline(result, c);
        }
        }
      }
#line 1092
      in_escape = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  if (in_escape) {
    {
#line 1096
    MSG2(1, "symbols", "Unterminated backslash");
    }
  }
#line 1098
  return (1);
}
}
#line 1102 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gboolean regex_eval(GMatchInfo *match_info , GString *result , gpointer user_data ) 
{ 
  SpeechSymbolProcessor *ssp ;
  gchar *capture ;
  enum group captured_group ;
  gchar *group_0 ;
  gint start ;
  gint end ;
  gint prevlen ;
  gint shift ;
  gint nexttag ;
  gint curtag ;
  gint deferrable ;
  guint i ;
  SpeechSymbol *sym ;
  gint pos ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  GSList *node ;
  gchar *group_name ;
  gchar *__cil_tmp23 ;
  gchar *__cil_tmp24 ;
  gchar **all ;
  gchar **__cil_tmp26 ;
  gint i___8 ;
  gint __cil_tmp28 ;
  guint __cil_tmp29 ;
  gint __cil_tmp30 ;
  gint __cil_tmp31 ;
  gchar *__cil_tmp32 ;
  gint __cil_tmp33 ;
  char ch[2] ;
  SpeechSymbol *sym___9 ;
  gpointer __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  gchar *prefix ;
  gchar *suffix ;
  gpointer __cil_tmp40 ;
  long __cil_tmp41 ;
  gchar *__cil_tmp42 ;
  unsigned long __cil_tmp43 ;

  {
#line 1104
  ssp = user_data;
#line 1108
  start = - 1;
  {
#line 1108
  end = - 1;
#line 1109
  prevlen = (gint )result->len;
#line 1111
  i = (guint )0;
#line 1112
  sym = (SpeechSymbol *)((void *)0);
#line 1113
  pos = 0;
#line 1122
  capture = fetch_named_matching(match_info, (gchar *)"rstripSpace|\332U");
  }
#line 1122
  if (capture) {
#line 1123
    captured_group = (enum group )0;
  } else {
    {
#line 1124
    capture = fetch_named_matching(match_info, (gchar *)"repeated\220");
    }
#line 1124
    if (capture) {
#line 1125
      captured_group = (enum group )1;
    } else {
      {
#line 1126
      capture = fetch_named_matching(match_info, (gchar *)"simple");
      }
#line 1126
      if (capture) {
#line 1127
        captured_group = (enum group )2;
      } else {
#line 1132
        node = ssp->complex_list;
        {
#line 1132
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1132
          if (! (! sym && node)) {
#line 1132
            goto while_break;
          }
          {
#line 1133
          __cil_tmp23 = g_strdup_printf((gchar *)"c%u|\332U", i);
#line 1133
          group_name = __cil_tmp23;
#line 1135
          capture = fetch_named_matching(match_info, group_name);
          }
#line 1135
          if (capture) {
            {
#line 1136
            __cil_tmp26 = g_match_info_fetch_all(match_info);
#line 1136
            all = __cil_tmp26;
#line 1139
            pos = - 1;
#line 1141
            i___8 = 1;
            }
            {
#line 1141
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1141
              if (! *(all + i___8)) {
#line 1141
                goto while_break___0;
              }
#line 1142
              if (*(*(all + i___8) + 0)) {
#line 1143
                pos = i___8;
#line 1144
                goto while_break___0;
              }
#line 1141
              i___8 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 1147
            g_strfreev(all);
            }
#line 1149
            if (pos != -1) {
#line 1150
              sym = node->data;
            }
          }
          {
#line 1152
          g_free(group_name);
          }
#line 1154
          if (sym) {
#line 1155
            goto while_break;
          }
#line 1132
          __cil_tmp29 = i;
#line 1132
          i ++;
#line 1132
          node = node->next;
        }
        while_break: /* CIL Label */ ;
        }
#line 1158
        captured_group = (enum group )3;
      }
    }
  }
  {
#line 1163
  g_match_info_fetch_pos(match_info, 0, & start, & end);
#line 1165
  nexttag = find_nexttag(ssp->tags, start, 0, ssp->ntags);
#line 1168
  deferrable = 1;
#line 1169
  curtag = nexttag;
  }
  {
#line 1169
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1169
    if (! (curtag < ssp->ntags)) {
#line 1169
      goto while_break___1;
    }
#line 1170
    if ((ssp->tags + curtag)->pos >= (unsigned long )end) {
#line 1172
      goto while_break___1;
    }
#line 1174
    if (! (ssp->tags + curtag)->deferrable) {
#line 1176
      deferrable = 0;
#line 1177
      goto while_break___1;
    }
#line 1169
    curtag ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1181
  if (! deferrable) {
    {
#line 1182
    group_0 = g_match_info_fetch(match_info, 0);
#line 1183
    MSG2(1, "symbols", "tags \'%s\' within group |%s| (at %d..%d), not replacing group :/",
         (ssp->tags + curtag)->tags, group_0, start, end);
#line 1185
    g_free(group_0);
#line 1187
    g_string_append(result, capture);
#line 1188
    g_free(capture);
    }
#line 1190
    return (0);
  }
#line 1194
  curtag = nexttag;
  {
#line 1194
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1194
    if (! (curtag < ssp->ntags)) {
#line 1194
      goto while_break___2;
    }
#line 1195
    if ((ssp->tags + curtag)->pos >= (unsigned long )end) {
#line 1197
      goto while_break___2;
    }
    {
#line 1199
    MSG2(5, "symbols", "deferring tags \'%s\' to %d;x|\332U", (ssp->tags + curtag)->tags,
         end);
#line 1200
    (ssp->tags + curtag)->pos = (gsize )end;
    }
#line 1194
    curtag ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1204
  if ((unsigned int )captured_group == 0U) {
    {
#line 1205
    MSG2(5, "symbols", "replacing <rstripSpace>");
    }
  } else
#line 1207
  if ((unsigned int )captured_group == 1U) {
    {
#line 1209
    ch[0] = *(capture + 0);
#line 1209
    ch[1] = (char )0;
#line 1210
    __cil_tmp36 = g_hash_table_lookup(ssp->symbols, (char *)ch);
#line 1210
    sym___9 = __cil_tmp36;
#line 1212
    MSG2(5, "symbols", "replacing <repeated>");
    }
#line 1215
    if (! sym___9) {
#line 1216
      goto symbol_error;
    }
#line 1218
    if ((int )ssp->level >= (int )sym___9->level) {
      {
#line 1219
      __cil_tmp37 = strlen((char const   *)capture);
#line 1219
      g_string_append_printf(result, (gchar *)" %lu %s \230", (unsigned long )__cil_tmp37,
                             sym___9->replacement);
      }
    } else {
      {
#line 1221
      g_string_append_c_inline(result, (gchar )' ');
      }
    }
  } else {
#line 1227
    if ((unsigned int )captured_group == 2U) {
      {
#line 1229
      sym = (SpeechSymbol *)g_hash_table_lookup(ssp->symbols, capture);
#line 1230
      MSG2(5, "symbols", "replacing <simple>w|\332U");
      }
    } else {
      {
#line 1232
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1232
        __cil_tmp41 = __builtin_expect((long )0, (long )1);
        }
#line 1232
        if (__cil_tmp41) {

        } else {
          {
#line 1232
          g_assertion_message_expr((char const   *)((gchar *)0), "./src/server/symbols.c",
                                   1232, (char const   *)"regex_eval", "captured_group == COMPLEX");
          }
        }
#line 1232
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1234
      MSG2(5, "symbols", "replacing <c%u> (complex symbol)\230\001", i);
      }
    }
#line 1238
    if (! sym) {
#line 1239
      goto symbol_error;
    }
    {
#line 1241
    MSG2(5, "symbols", "replacing sym |%s| (lvl=%d, preserve=%d)\230\001", sym->identifier,
         (int )sym->level, (int )sym->preserve);
    }
#line 1244
    if ((int )sym->preserve == 3) {
#line 1245
      prefix = (gchar *)"\220";
    } else {
#line 1247
      prefix = (gchar *)" ";
    }
#line 1249
    if ((int )sym->preserve == 1) {
#line 1251
      suffix = capture;
    } else
#line 1249
    if ((int )sym->preserve == 2) {
#line 1249
      if ((int )ssp->level < (int )sym->level) {
#line 1251
        suffix = capture;
      } else {
#line 1249
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1252
    if ((int )sym->preserve == 3) {
#line 1253
      suffix = (gchar *)"\220";
    } else {
#line 1255
      suffix = (gchar *)" Xw|\332U";
    }
#line 1257
    if ((int )sym->level > (int )ssp->support_level) {
      {
#line 1259
      g_string_append(result, capture);
      }
    } else
#line 1260
    if (sym->replacement) {
#line 1260
      if ((int )ssp->level >= (int )sym->level) {
        {
#line 1261
        g_string_append(result, prefix);
#line 1262
        MSG2(5, "symbols", "replacing with %s", sym->replacement);
#line 1263
        replace_groups(match_info, result, sym->replacement, pos);
#line 1264
        g_string_append(result, suffix);
        }
      } else {
        {
        {
#line 1266
        g_string_append(result, suffix);
        }
        }
      }
    } else {
      {
      {
#line 1266
      g_string_append(result, suffix);
      }
      }
    }
  }
#line 1270
  goto out;
  symbol_error: 
  {
#line 1273
  group_0 = g_match_info_fetch(match_info, 0);
  }
  {
#line 1274
  MSG2(1, "symbols", "WARNING: no symbol for match |%s| (at %d..%d), this shouldn\'t happen.U",
       group_0, start, end);
#line 1276
  g_free(group_0);
  }
  out: 
  {
#line 1280
  __cil_tmp43 = strlen((char const   *)capture);
#line 1280
  shift = (gint )((result->len - (unsigned long )prevlen) - __cil_tmp43);
  }
#line 1282
  if (nexttag < ssp->ntags) {
#line 1284
    (ssp->tags + nexttag)->shift += (long )shift;
  }
  {
#line 1286
  g_free(capture);
  }
#line 1288
  return (0);
}
}
#line 1292 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gchar *speech_symbols_processor_process_text(GSList *sspl , gchar *input ,
                                                    SymLvl level , SymLvl support_level ,
                                                    SPDDataMode ssml_mode ) 
{ 
  gchar *text ;
  gchar *processed ;
  struct tags *tags ;
  gint ntags ;
  gint i ;
  GError *error ;
  gchar *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  SpeechSymbolProcessor *ssp ;
  gint __cil_tmp15 ;
  gchar *__cil_tmp16 ;
  gssize shift ;
  gint __cil_tmp18 ;
  glong __cil_tmp19 ;
  gchar *__cil_tmp20 ;

  {
#line 1296
  tags = (struct tags *)((void *)0);
#line 1297
  ntags = 0;
#line 1298
  error = (GError *)((void *)0);
#line 1300
  if ((unsigned int )ssml_mode == 1U) {
    {
#line 1301
    text = escape_ssml_text(input, & tags, & ntags);
#line 1302
    MSG2(5, "symbols", "escaped ssml \'%s\' to \'%s\'\360\377\377\377\377\377\377\230\001",
         input, text);
    }
  } else {
    {
#line 1304
    text = g_strdup(input);
    }
  }
  {
#line 1307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1307
    if (! sspl) {
#line 1307
      goto while_break;
    }
#line 1308
    ssp = sspl->data;
#line 1310
    if ((unsigned int )ssml_mode == 1U) {
#line 1311
      i = 0;
      {
#line 1311
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1311
        if (! (i < ntags)) {
#line 1311
          goto while_break___0;
        }
#line 1312
        (tags + i)->shift = (gssize )0;
#line 1311
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1313
      ssp->tags = tags;
#line 1314
      ssp->ntags = ntags;
    } else {
#line 1316
      ssp->ntags = 0;
    }
    {
#line 1318
    ssp->level = level;
#line 1319
    ssp->support_level = support_level;
#line 1320
    processed = g_regex_replace_eval(ssp->regex, text, (gssize )(- 1), 0, (GRegexMatchFlags )0,
                                     & regex_eval, ssp, & error);
    }
#line 1321
    if (! processed) {
      {
#line 1322
      MSG2(1, "symbols", "ERROR applying regex: %s\230\001", error->message);
#line 1323
      g_error_free(error);
      }
    } else {
      {
#line 1325
      MSG2(5, "symbols", "\'%s\' translated \'%s\' to \'%s\'", ssp->source, text,
           processed);
#line 1326
      g_free(text);
#line 1327
      text = processed;
      }
#line 1329
      if ((unsigned int )ssml_mode == 1U) {
#line 1331
        shift = (gssize )0;
#line 1334
        i = 0;
        {
#line 1334
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1334
          if (! (i < ntags)) {
#line 1334
            goto while_break___1;
          }
#line 1335
          shift += (tags + i)->shift;
#line 1336
          (tags + i)->pos += (unsigned long )shift;
#line 1334
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 1340
      __cil_tmp19 = g_utf8_strlen(processed, (gssize )(- 1));
      }
#line 1340
      if ((int )level == 1000) {
#line 1340
        if (__cil_tmp19 > 1L) {
#line 1342
          goto while_break;
        }
      }
    }
#line 1307
    sspl = sspl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1346
  if ((unsigned int )ssml_mode == 1U) {
    {
#line 1347
    processed = unescape_ssml_text(text, tags, ntags);
#line 1348
    MSG2(5, "symbols", "unescaped ssml \'%s\' to \'%s\'|\332U", text, processed);
#line 1349
    g_free(text);
    }
  } else {
#line 1351
    processed = text;
  }
#line 1353
  return (processed);
}
}
#line 1357 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static GSList *get_locale_speech_symbols_processor(gchar *locale ) 
{ 
  LocaleMap *__cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
#line 1359
  if (! G_processors) {
    {
#line 1360
    G_processors = locale_map_new((GDestroyNotify )(& speech_symbols_processor_list_free));
    }
  }
  {
#line 1363
  __cil_tmp3 = locale_map_fetch(G_processors, locale, (gchar *)((void *)0), & speech_symbols_processor_list_new);
  }
#line 1363
  return (__cil_tmp3);
}
}
#line 1369 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
static gchar *process_speech_symbols(gchar *locale , gchar *text , SymLvl level ,
                                     SymLvl support_level , SPDDataMode ssml_mode ) 
{ 
  GSList *sspl ;
  GSList *__cil_tmp7 ;
  gboolean __cil_tmp8 ;
  char *__cil_tmp9 ;
  GSList *__cil_tmp10 ;
  gchar *__cil_tmp11 ;

  {
  {
#line 1373
  sspl = get_locale_speech_symbols_processor(locale);
#line 1375
  __cil_tmp9 = strchr("_-x|\332U", (int )*(locale + 2));
  }
  {
#line 1375
  __cil_tmp8 = g_str_has_prefix(locale, (gchar *)"en");
  }
#line 1375
  if (! sspl) {
#line 1375
    if (__cil_tmp8) {
#line 1375
      if (__cil_tmp9) {
        {
#line 1376
        sspl = get_locale_speech_symbols_processor((gchar *)"enx|\332U");
        }
      }
    }
  }
#line 1377
  if (! sspl) {
#line 1378
    return ((gchar *)((void *)0));
  }
  {
#line 1380
  __cil_tmp11 = speech_symbols_processor_process_text(sspl, text, level, support_level,
                                                      ssml_mode);
  }
#line 1380
  return (__cil_tmp11);
}
}
#line 1383 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/symbols.c"
void insert_symbols(TSpeechDMessage *msg , int punct_missing ) 
{ 
  gchar *processed ;
  SymLvl level ;
  SymLvl support_level ;
  gchar *__cil_tmp6 ;
  glong __cil_tmp7 ;

  {
#line 1386
  level = (SymLvl )100;
#line 1387
  support_level = (SymLvl )msg->settings.symbols_preprocessing;
#line 1389
  if (punct_missing) {
#line 1389
    if ((int )support_level < 500) {
#line 1392
      support_level = (SymLvl )500;
    }
  }
  {
#line 1395
  if ((unsigned int )msg->settings.msg_settings.punctuation_mode == (unsigned int )0) {
#line 1395
    goto case_0;
  }
#line 1396
  if ((unsigned int )msg->settings.msg_settings.punctuation_mode == (unsigned int )3) {
#line 1396
    goto case_3;
  }
#line 1397
  if ((unsigned int )msg->settings.msg_settings.punctuation_mode == (unsigned int )2) {
#line 1397
    goto case_2;
  }
#line 1398
  if ((unsigned int )msg->settings.msg_settings.punctuation_mode == (unsigned int )1) {
#line 1398
    goto case_1;
  }
#line 1394
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1395
  level = (SymLvl )500;
#line 1395
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1396
  level = (SymLvl )300;
#line 1396
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1397
  level = (SymLvl )200;
#line 1397
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1398
  level = (SymLvl )100;
#line 1398
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1401
  if ((unsigned int )msg->settings.type == 2U) {
#line 1402
    level = (SymLvl )1000;
  }
  {
#line 1404
  MSG2(5, "symbols", "processing at level %d, supporting level %d|\332U", (int )level,
       (int )support_level);
#line 1405
  processed = process_speech_symbols(msg->settings.msg_settings.voice.language, msg->buf,
                                     level, support_level, msg->settings.ssml_mode);
  }
#line 1407
  if (processed) {
    {
#line 1408
    MSG2(5, "symbols", "before: |%s|\332U", msg->buf);
#line 1409
    g_free(msg->buf);
#line 1410
    msg->buf = processed;
#line 1411
    MSG2(5, "symbols", "after: |%s||\332U", msg->buf);
    }
#line 1412
    if ((int )support_level >= (int )level) {
#line 1414
      msg->settings.msg_settings.punctuation_mode = (SPDPunctuation )1;
    }
#line 1417
    if ((unsigned int )msg->settings.type == 2U) {
      {
#line 1418
      __cil_tmp7 = g_utf8_strlen(processed, (gssize )(- 1));
      }
#line 1418
      if (__cil_tmp7 > 1L) {
#line 1419
        msg->settings.type = (SPDMessageType )0;
      }
    }
  }
  return;
}
}
#line 34 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/index_marking.h"
void insert_index_marks(TSpeechDMessage *msg , SPDDataMode ssml_mode ) ;
#line 38
char *find_index_mark(TSpeechDMessage *msg , int mark ) ;
#line 42
char *strip_index_marks(char const   *buf , SPDDataMode ssml_mode ) ;
#line 30 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/index_marking.c"
void insert_index_marks(TSpeechDMessage *msg , SPDDataMode ssml_mode ) 
{ 
  GString *marked_text ;
  char *pos ;
  char character[6] ;
  char character2[6] ;
  gunichar u_char ;
  int n ;
  int ret ;
  int inside_tag ;
  GString *__cil_tmp11 ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  gunichar __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  gunichar __cil_tmp20 ;
  gboolean __cil_tmp21 ;
  int __cil_tmp22 ;
  gchar *__cil_tmp23 ;

  {
  {
#line 37
  n = 0;
#line 39
  inside_tag = 0;
#line 41
  marked_text = g_string_new((gchar *)"\260F\245|\332U");
#line 46
  MSG2(5, "index_markingU", "MSG before index marking: |%s|, ssml_mode=%d\332U", msg->buf,
       (unsigned int )ssml_mode);
  }
#line 49
  if ((unsigned int )ssml_mode == 0U) {
    {
#line 50
    g_string_printf(marked_text, (gchar *)"<speak>");
    }
  }
#line 52
  pos = msg->buf;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! pos) {
#line 53
      goto while_break;
    }
    {
#line 54
    ret = spd_utf8_read_char((char const   *)pos, (char *)character);
#line 55
    __cil_tmp15 = strlen((char const   *)((char *)character));
    }
#line 55
    if (ret == 0) {
#line 56
      goto while_break;
    } else
#line 55
    if (__cil_tmp15 == 0UL) {
#line 56
      goto while_break;
    }
    {
#line 57
    u_char = g_utf8_get_char((char *)character);
    }
#line 59
    if (u_char == 60U) {
#line 60
      if ((unsigned int )ssml_mode == 1U) {
        {
#line 61
        inside_tag = 1;
#line 62
        g_string_append_printf(marked_text, (gchar *)"%s\b", (char *)character);
        }
      } else {
        {
#line 65
        g_string_append_printf(marked_text, (gchar *)"&lt;\332U");
        }
      }
    } else
#line 66
    if (u_char == 62U) {
#line 67
      if ((unsigned int )ssml_mode == 1U) {
        {
#line 68
        inside_tag = 0;
#line 69
        g_string_append_printf(marked_text, (gchar *)"%s\266|\332U", (char *)character);
        }
      } else {
        {
#line 72
        g_string_append_printf(marked_text, (gchar *)"&gt;\332U");
        }
      }
    } else
#line 73
    if (u_char == 38U) {
#line 74
      if ((unsigned int )ssml_mode == 1U) {
        {
#line 75
        g_string_append_printf(marked_text, (gchar *)"%s\b", (char *)character);
        }
      } else
#line 78
      if (! inside_tag) {
        {
#line 79
        g_string_append_printf(marked_text, (gchar *)"&amp;U");
        }
      }
    } else
#line 83
    if (u_char == 46U) {
      _L: /* CIL Label */ 
      _L___10: /* CIL Label */ 
#line 83
      if (! inside_tag) {
        {
#line 85
        pos = g_utf8_find_next_char(pos, (gchar *)((void *)0));
#line 86
        ret = spd_utf8_read_char((char const   *)pos, (char *)character2);
#line 87
        __cil_tmp19 = strlen((char const   *)((char *)character2));
        }
#line 87
        if (ret == 0) {
          {
          {
#line 88
          g_string_append_printf(marked_text, (gchar *)"%s\271|\332U", (char *)character);
          }
          {
#line 90
          MSG2(6, "index_markingU", "MSG altering 1: |%s|\332U", marked_text->str);
          }
          }
#line 92
          goto while_break;
        } else
#line 87
        if (__cil_tmp19 == 0UL) {
          {
          {
#line 88
          g_string_append_printf(marked_text, (gchar *)"%s\271|\332U", (char *)character);
          }
          {
#line 90
          MSG2(6, "index_markingU", "MSG altering 1: |%s|\332U", marked_text->str);
          }
          }
#line 92
          goto while_break;
        }
        {
#line 94
        u_char = g_utf8_get_char((char *)character2);
#line 95
        __cil_tmp21 = g_unichar_isspace(u_char);
        }
#line 95
        if (__cil_tmp21) {
          {
          {
          {
#line 97
          g_string_append_printf(marked_text, (gchar *)"%s<mark name=\"__spd_%d\"/>\327\272|\332U",
                                 (char *)character, n);
          }
          }
#line 101
          n ++;
          {
          {
#line 102
          MSG2(6, "index_markingU", "MSG altering 2: |%s|\332U", marked_text->str);
          }
          }
          }
#line 104
          goto while_continue;
        } else
#line 95
        if (u_char == 60U) {
          {
          {
          {
#line 97
          g_string_append_printf(marked_text, (gchar *)"%s<mark name=\"__spd_%d\"/>\327\272|\332U",
                                 (char *)character, n);
          }
          }
#line 101
          n ++;
          {
          {
#line 102
          MSG2(6, "index_markingU", "MSG altering 2: |%s|\332U", marked_text->str);
          }
          }
          }
#line 104
          goto while_continue;
        } else
#line 95
        if (u_char == 38U) {
          {
          {
          {
#line 97
          g_string_append_printf(marked_text, (gchar *)"%s<mark name=\"__spd_%d\"/>\327\272|\332U",
                                 (char *)character, n);
          }
          }
#line 101
          n ++;
          {
          {
#line 102
          MSG2(6, "index_markingU", "MSG altering 2: |%s|\332U", marked_text->str);
          }
          }
          }
#line 104
          goto while_continue;
        } else {
          {
#line 106
          g_string_append_printf(marked_text, (gchar *)"%s\273|\332U", (char *)character);
#line 108
          MSG2(6, "index_markingU", "MSG altering 3: |%s|\332U", marked_text->str);
          }
#line 110
          goto while_continue;
        }
      } else {
        {
        {
#line 113
        g_string_append_printf(marked_text, (gchar *)"%s\t", (char *)character);
        }
        }
      }
    } else
#line 83
    if (u_char == 63U) {
#line 83
      goto _L;
    } else
#line 83
    if (u_char == 33U) {
#line 83
      goto _L;
    } else {
      {
      {
#line 113
      g_string_append_printf(marked_text, (gchar *)"%s\t", (char *)character);
      }
      }
    }
    {
#line 116
    pos = g_utf8_find_next_char(pos, (gchar *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if ((unsigned int )ssml_mode == 0U) {
    {
#line 120
    g_string_append_printf(marked_text, (gchar *)"</speak>\220");
    }
  }
  {
#line 122
  g_free(msg->buf);
#line 123
  msg->buf = marked_text->str;
#line 125
  g_string_free(marked_text, 0);
#line 127
  MSG2(5, "index_marking", "MSG after index marking: |%s|", msg->buf);
  }
  return;
}
}
#line 131 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/index_marking.c"
char *find_index_mark(TSpeechDMessage *msg , int mark ) 
{ 
  char str_mark[64] ;
  char *pos ;
  char *p ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
  {
#line 137
  MSG(5, "Trying to find index mark %d", mark);
#line 140
  sprintf((char *)str_mark, "<mark name=\"__spd_%d\"/>", mark);
#line 142
  p = strstr((char const   *)msg->buf, (char const   *)((char *)str_mark));
  }
#line 143
  if (p == (char *)0) {
#line 144
    return ((char *)((void *)0));
  }
  {
#line 146
  __cil_tmp7 = strlen((char const   *)((char *)str_mark));
#line 146
  pos = p + __cil_tmp7;
#line 148
  MSG(5, "Search for index mark sucessfull\220");
  }
#line 150
  return (pos);
}
}
#line 154 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/index_marking.c"
char *strip_index_marks(char const   *buf , SPDDataMode ssml_mode ) 
{ 
  GString *str ;
  char *strret ;
  char str_mark[19] ;
  char const   *p ;
  char const   *p_old ;
  char *p_str ;
  GString *__cil_tmp9 ;
  GString *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 159
  str_mark = "<mark name=\"__spd_";
#line 165
  if ((unsigned int )ssml_mode == 1U) {
    {
#line 166
    str = g_string_new((gchar *)"<speak>");
    }
  } else {
    {
#line 168
    str = g_string_new((gchar *)"\220");
    }
  }
  {
#line 170
  MSG2(5, "index_marking", "Message before stripping index marks: |%s|", buf);
#line 173
  p = buf;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if ((int )*p == 0) {
#line 177
      goto while_break;
    }
    {
#line 178
    p_old = p;
#line 179
    __cil_tmp11 = strstr(p, (char const   *)((char *)str_mark));
#line 179
    p = (char const   *)__cil_tmp11;
    }
#line 180
    if (p != (void *)0) {
      {
#line 181
      g_string_append_len(str, p_old, (gssize )((int )(p - p_old)));
      }
    } else {
      {
#line 183
      g_string_append(str, p_old);
      }
#line 184
      goto while_break;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      p ++;
#line 186
      if (! ((int )*p != 62 && (int )*p != 0)) {
#line 186
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 189
    if ((int )*p == 62) {
#line 190
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if ((unsigned int )ssml_mode == 0U) {
    {
#line 194
    p_str = strstr((char const   *)str->str, "</speak>\220");
    }
#line 195
    if (p_str != (void *)0) {
#line 196
      *p_str = (char )0;
    }
  }
  {
#line 199
  strret = str->str;
#line 200
  g_string_free(str, 0);
#line 202
  MSG2(5, "index_marking", "Message after stripping index marks: |%s|", strret);
  }
#line 205
  return (strret);
}
}
#line 22 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/sem_functions.h"
void speaking_semaphore_post(void) ;
#line 32 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/sem_functions.c"
void speaking_semaphore_post(void) 
{ 
  char buf[1] ;
  ssize_t wr_bytes ;

  {
#line 35
  buf[0] = (char )42;
#line 36
  wr_bytes = 0;
#line 37
  if (wr_bytes != 1L) {
    {
#line 38
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 38
      fatal_error();
#line 38
      MSG(- 1, "Fatal error [%s:%d]:write to polled fd: could not write 1 byte\b",
          "./src/server/sem_functions.c\332U", 38);
#line 38
      exit(1);
      }
#line 38
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 25 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.h"
OutputModule *get_output_module(TSpeechDMessage *message ) ;
#line 27
int output_speak(TSpeechDMessage *msg , OutputModule *output ) ;
#line 28
int output_stop(void) ;
#line 29
size_t output_pause(void) ;
#line 30
int output_is_speaking(char **index_mark ) ;
#line 31
int output_send_debug(OutputModule *output , int flag , char const   *log_path ) ;
#line 33
int output_check_module(OutputModule *output ) ;
#line 35
char *escape_dot(char *otext ) ;
#line 37
void output_set_speaking_monitor(TSpeechDMessage *msg , OutputModule *output ) ;
#line 38
GString *output_read_reply(OutputModule *output ) ;
#line 39
int output_send_data(char const   *cmd , OutputModule *output , int wfr ) ;
#line 40
int output_send_settings(TSpeechDMessage *msg , OutputModule *output ) ;
#line 41
int output_send_audio_settings(OutputModule *output ) ;
#line 42
int output_send_loglevel_setting(OutputModule *output ) ;
#line 43
int waitpid_with_timeout(pid_t pid , int *status_ptr , int options , size_t timeout ) ;
#line 45
int output_close(OutputModule *module ) ;
#line 46
SPDVoice **output_list_voices(char const   *module_name ) ;
#line 58 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static pthread_t output_thread ;
#line 59
static void *output_thread_func(void *data ) ;
#line 60
static int output_end_queued ;
#line 61
static int output_stop_requested ;
#line 62
static int output_pause_requested ;
#line 63
static int output_pause_queued ;
#line 65 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void output_open_audio(OutputModule *output ) 
{ 
  void *pars[9] ;
  unsigned int tmp ;
  char min_length[11] ;
  char *error ;
  gchar **outputs ;
  int i ;
  gchar **__cil_tmp8 ;
  AudioID *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 67
  pars[0] = (void *)0;
#line 67
  tmp = (unsigned int )1;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (tmp >= 9) {
#line 67
      goto while_break;
    }
#line 67
    pars[tmp] = 0;
#line 67
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  pars[0] = GlobalFDSet.audio_oss_device;
#line 74
  pars[1] = GlobalFDSet.audio_alsa_device;
#line 75
  pars[2] = GlobalFDSet.audio_nas_server;
#line 76
  pars[3] = GlobalFDSet.audio_pulse_device;
#line 77
  snprintf((char *)min_length, sizeof(min_length), "%u", GlobalFDSet.audio_pulse_min_length);
#line 78
  pars[4] = (char *)min_length;
#line 79
  pars[5] = output->name;
#line 81
  outputs = g_strsplit(GlobalFDSet.audio_output_method, (gchar *)",", 0);
#line 82
  i = 0;
  }
  {
#line 82
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 82
    if (! ((void *)0 != *(outputs + i))) {
#line 82
      goto while_break___0;
    }
    {
#line 83
    output->audio = spd_audio_open((char const   *)*(outputs + i), (void **)pars,
                                   & error);
    }
#line 85
    if (output->audio) {
      {
#line 86
      MSG(4, "Using %s audio output method", *(outputs + i));
#line 87
      g_strfreev(outputs);
#line 90
      __cil_tmp10 = spd_audio_set_volume(output->audio, 85);
      }
#line 90
      if (__cil_tmp10 < 0) {
        {
#line 91
        MSG(4, "Can\'t set volume. audio not initialized?\220");
        }
      }
#line 94
      return;
    }
#line 82
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 98
  MSG(1, "Opening audio failed: %s\n", error);
#line 99
  g_free(error);
#line 100
  g_strfreev(outputs);
  }
  return;
}
}
#line 103 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void output_set_speaking_monitor(TSpeechDMessage *msg , OutputModule *output ) 
{ 


  {
#line 106
  speaking_module = output;
#line 107
  if (output->audio) {
#line 108
    if (output->audio == (AudioID *)-1) {
      {
#line 109
      output_open_audio(output);
      }
    }
#line 110
    module_audio_id = output->audio;
  }
#line 112
  speaking_uid = (int )msg->settings.uid;
#line 113
  speaking_gid = msg->settings.reparted;
  return;
}
}
#line 116 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
OutputModule *get_output_module_by_name(char const   *name ) 
{ 
  OutputModule *output ;
  int i ;
  guint __cil_tmp4 ;
  gpointer __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned int )i < __cil_tmp4)) {
#line 121
      goto while_break;
    }
    {
#line 122
    output = (OutputModule *)g_list_nth_data(output_modules, (guint )i);
#line 123
    __cil_tmp6 = strcmp((char const   *)output->name, name);
    }
#line 123
    if (! __cil_tmp6) {
#line 124
      if (output->working) {
#line 125
        return (output);
      } else {
#line 127
        return ((OutputModule *)((void *)0));
      }
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return ((OutputModule *)((void *)0));
}
}
#line 134 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
OutputModule *get_some_output_module_by_name(char const   *name ) 
{ 
  OutputModule *output ;
  int i ;
  int len ;
  OutputModule *__cil_tmp5 ;
  OutputModule *__cil_tmp6 ;
  guint __cil_tmp7 ;
  gpointer __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  OutputModule *__cil_tmp11 ;

  {
#line 136
  output = (OutputModule *)((void *)0);
#line 139
  if (name != (void *)0) {
    {
#line 140
    MSG(5, "Desired output module is %s", name);
#line 141
    output = get_output_module_by_name(name);
    }
#line 142
    if (output != (void *)0) {
#line 142
      if (output->working) {
#line 143
        return (output);
      }
    }
  }
  {
#line 146
  MSG(3, "Warning: Didn\'t find preferred output module, using default");
  }
#line 149
  if (GlobalFDSet.output_module != (void *)0) {
    {
#line 150
    output = get_output_module_by_name((char const   *)GlobalFDSet.output_module);
    }
  }
#line 152
  if (output != (void *)0) {
#line 152
    if (output->working) {
#line 153
      return (output);
    }
  }
  {
#line 155
  MSG(3, "Couldn\'t load default output module, trying other modules");
#line 158
  __cil_tmp7 = g_list_length(output_modules);
#line 158
  len = (int )__cil_tmp7;
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < len)) {
#line 159
      goto while_break;
    }
    {
#line 160
    output = (OutputModule *)g_list_nth_data(output_modules, (guint )i);
#line 161
    __cil_tmp9 = strcmp((char const   *)output->name, "dummy");
    }
#line 161
    if (0 == __cil_tmp9) {
#line 162
      goto while_continue;
    }
#line 164
    if (output->working) {
      {
#line 165
      MSG(3, "Output module %s seems to be working, using it", output->name);
      }
#line 167
      return (output);
    }
#line 159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if (output == (void *)0) {
    {
    {
#line 174
    output = get_output_module_by_name("dummy");
    }
    }
  } else
#line 173
  if (! output->working) {
    {
    {
#line 174
    output = get_output_module_by_name("dummy");
    }
    }
  }
#line 176
  return (output);
}
}
#line 192 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
OutputModule *get_output_module(TSpeechDMessage *message ) 
{ 
  OutputModule *output ;
  OutputModule *__cil_tmp3 ;

  {
  {
#line 196
  output = get_some_output_module_by_name((char const   *)message->settings.output_module);
  }
#line 199
  if (output == (void *)0) {
    {
#line 200
    MSG(1, "Error: No output module working, not even dummy, no sound produced!\n");
    }
  }
#line 203
  return (output);
}
}
#line 217
static int oldstate ;
#line 219 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void output_lock(void) 
{ 
  pthread_t __cil_tmp1 ;

  {
  {
#line 221
  __cil_tmp1 = pthread_self();
  }
#line 221
  if (__cil_tmp1 == speak_thread) {
    {
#line 222
    pthread_setcancelstate(1, & oldstate);
    }
  }
  {
#line 223
  pthread_mutex_lock(& output_layer_mutex);
  }
  return;
}
}
#line 227 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void output_unlock(void) 
{ 
  pthread_t __cil_tmp1 ;

  {
  {
#line 229
  pthread_mutex_unlock(& output_layer_mutex);
#line 230
  __cil_tmp1 = pthread_self();
  }
#line 230
  if (__cil_tmp1 == speak_thread) {
    {
#line 231
    pthread_setcancelstate(oldstate, (int *)((void *)0));
    }
  }
  return;
}
}
#line 238 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
GString *output_read_message(OutputModule *output ) 
{ 
  GString *rstr ;
  int bytes ;
  char *line ;
  size_t N ;
  gboolean errors ;
  GString *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  __ssize_t __cil_tmp9 ;

  {
  {
#line 242
  line = (char *)((void *)0);
#line 243
  N = (size_t )0;
#line 244
  errors = 0;
#line 246
  rstr = g_string_new((gchar *)"P9T}\332U");
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 251
    __cil_tmp9 = getline(& line, & N, output->stream_out);
#line 251
    bytes = (int )__cil_tmp9;
    }
#line 252
    if (bytes == -1) {
      {
#line 253
      MSG(2, "Error: Broken pipe to module.");
#line 254
      output->working = 0;
#line 255
      output_check_module(output);
#line 256
      errors = ! 0;
      }
    } else {
      {
#line 258
      MSG(5, "Got %d bytes from output module over socket", bytes);
#line 260
      g_string_append_len(rstr, line, (gssize )bytes);
      }
    }
#line 250
    if (! (! errors && ! (__cil_tmp8 < 4UL || (int )*(line + 3) == 32))) {
#line 250
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 265
  if (line != (void *)0) {
    {
#line 266
    free(line);
    }
  }
#line 268
  if (errors) {
    {
#line 269
    g_string_free(rstr, ! 0);
#line 270
    rstr = (GString *)((void *)0);
    }
  }
#line 273
  return (rstr);
}
}
#line 281 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static pthread_mutex_t output_read_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 282 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static pthread_cond_t output_reply_cond  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 283 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static pthread_cond_t output_event_cond  =    {{{(unsigned long long )0}, {(unsigned long long )0}, {(unsigned int )0, (unsigned int )0},
     {(unsigned int )0, (unsigned int )0}, (unsigned int )0, (unsigned int )0, {(unsigned int )0,
                                                                                (unsigned int )0}}};
#line 284
static GString *output_reply ;
#line 285
static GString *output_event ;
#line 286
static int output_reading_message ;
#line 288 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
GString *output_read_reply(OutputModule *output ) 
{ 
  GString *message ;
  GString *__cil_tmp3 ;

  {
  {
#line 291
  pthread_mutex_lock(& output_read_mutex);
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (! message)) {
#line 292
      goto while_break;
    }
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 293
      if (! (! output_reply && output_reading_message)) {
#line 293
        goto while_break___0;
      }
      {
#line 295
      pthread_cond_wait(& output_reply_cond, & output_read_mutex);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 297
    if (output_reply) {
      {
#line 299
      message = output_reply;
#line 300
      output_reply = (GString *)((void *)0);
#line 302
      pthread_cond_signal(& output_event_cond);
      }
#line 303
      goto while_break;
    }
#line 306
    if (! output_reading_message) {
      {
#line 308
      message = output_read_message(output);
      }
#line 309
      if (! message) {
#line 311
        goto while_break;
      }
#line 312
      if ((int )*(message->str + 0) == 55) {
#line 314
        output_event = message;
#line 315
        message = (GString *)((void *)0);
        {
#line 317
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 317
          if (! output_event) {
#line 317
            goto while_break___1;
          }
          {
#line 318
          pthread_cond_wait(& output_reply_cond, & output_read_mutex);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 322
  pthread_mutex_unlock(& output_read_mutex);
  }
#line 323
  return (message);
}
}
#line 326 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
GString *output_read_event(OutputModule *output ) 
{ 
  GString *message ;
  GString *__cil_tmp3 ;

  {
  {
#line 329
  pthread_mutex_lock(& output_read_mutex);
  }
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (! message)) {
#line 330
      goto while_break;
    }
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! (! output_event && output_reading_message)) {
#line 331
        goto while_break___0;
      }
      {
#line 333
      pthread_cond_wait(& output_event_cond, & output_read_mutex);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 335
    if (output_event) {
      {
#line 337
      message = output_event;
#line 338
      output_event = (GString *)((void *)0);
#line 340
      pthread_cond_signal(& output_reply_cond);
      }
#line 341
      goto while_break;
    }
#line 344
    if (! output_reading_message) {
      {
#line 346
      message = output_read_message(output);
      }
#line 347
      if (! message) {
#line 349
        goto while_break;
      }
#line 350
      if ((int )*(message->str + 0) != 55) {
#line 352
        output_reply = message;
#line 353
        message = (GString *)((void *)0);
        {
#line 355
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 355
          if (! output_reply) {
#line 355
            goto while_break___1;
          }
          {
#line 356
          pthread_cond_wait(& output_event_cond, & output_read_mutex);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  pthread_mutex_unlock(& output_read_mutex);
  }
#line 361
  return (message);
}
}
#line 364 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_send_data(char const   *cmd , OutputModule *output , int wfr ) 
{ 
  int ret ;
  GString *response ;
  int ret___11 ;
  GString *__cil_tmp7 ;

  {
#line 369
  if (output == (void *)0) {
#line 370
    return (- 1);
  }
#line 371
  if (cmd == (void *)0) {
#line 372
    return (- 1);
  }
  {
#line 374
  ret = 0;
#line 375
  fflush((FILE *)((void *)0));
  }
#line 376
  if (ret == -1) {
    {
#line 377
    MSG(2, "Error: Broken pipe to module.");
#line 378
    output->working = 0;
#line 379
    speaking_module = (OutputModule *)((void *)0);
#line 380
    output_check_module(output);
    }
#line 381
    return (- 1);
  }
  {
#line 383
  MSG2(5, "output_module", "Command sent to output module: |%s| (%d)\230\001", cmd,
       wfr);
  }
#line 386
  if (wfr) {
    {
#line 387
    ret___11 = 0;
#line 388
    response = output_read_reply(output);
    }
#line 389
    if (response == (void *)0) {
#line 390
      return (- 1);
    }
    {
#line 392
    MSG2(5, "output_module", "Reply from output module: |%s|", response->str);
    }
    {
#line 396
    if ((int )*(response->str + 0) == '3') {
#line 396
      goto case_51;
    }
#line 403
    if ((int )*(response->str + 0) == '4') {
#line 403
      goto case_52;
    }
#line 410
    if ((int )*(response->str + 0) == '2') {
#line 410
      goto case_50;
    }
#line 413
    goto switch_default;
    case_51: /* CIL Label */ 
    {
#line 397
    MSG(2, "Error: Module reported error in request from speechd (code 3xx): %s.",
        response->str);
    }
#line 400
    ret___11 = - 2;
#line 401
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 404
    MSG(2, "Error: Module reported error in itself (code 4xx): %s", response->str);
    }
#line 407
    ret___11 = - 3;
#line 408
    goto switch_break;
    case_50: /* CIL Label */ 
#line 411
    ret___11 = 0;
#line 412
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 414
    MSG(3, "Unknown response from output module!");
    }
#line 415
    ret___11 = - 3;
#line 416
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 418
    g_string_free(response, ! 0);
    }
#line 419
    return (ret___11);
  }
#line 422
  return (0);
}
}
#line 425 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void free_voice(gpointer data ) 
{ 
  SPDVoice *voice ;

  {
#line 427
  voice = (SPDVoice *)data;
#line 429
  if (voice != (void *)0) {
#line 430
    if (voice->name != (void *)0) {
      {
#line 431
      g_free(voice->name);
      }
    }
#line 432
    if (voice->language != (void *)0) {
      {
#line 433
      g_free(voice->language);
      }
    }
#line 434
    if (voice->variant != (void *)0) {
      {
#line 435
      g_free(voice->variant);
      }
    }
    {
#line 437
    g_free(voice);
    }
  }
  return;
}
}
#line 441 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static SPDVoice **output_get_voices(OutputModule *module ) 
{ 
  SPDVoice **voice_dscr ;
  SPDVoice *voice ;
  GString *reply ;
  gchar **lines ;
  gchar **atoms ;
  GQueue *voices ;
  int i ;
  int numvoices ;
  gboolean errors ;
  int err ;
  int __cil_tmp12 ;
  GString *__cil_tmp13 ;
  gchar **__cil_tmp14 ;
  GQueue *__cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  gchar **__cil_tmp17 ;
  gpointer __cil_tmp18 ;
  gchar *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  gchar *__cil_tmp21 ;
  int __cil_tmp22 ;
  guint __cil_tmp23 ;
  gpointer __cil_tmp24 ;
  gpointer __cil_tmp25 ;
  int __cil_tmp26 ;

  {
  {
#line 450
  numvoices = 0;
#line 451
  errors = 0;
#line 454
  output_lock();
  }
#line 456
  if (module == (void *)0) {
    {
#line 457
    MSG(1, "ERROR: Can\'t list voices for broken output module");
#line 458
    output_unlock();
    }
#line 458
    return ((SPDVoice **)((void *)0));

  }
  {
#line 460
  err = output_send_data("LIST VOICES\n", module, 0);
  }
#line 461
  if (err < 0) {
    {
#line 462
    output_unlock();
    }
#line 463
    return ((SPDVoice **)((void *)0));
  }
  {
#line 465
  reply = output_read_reply(module);
  }
#line 467
  if (reply == (void *)0) {
    {
#line 468
    output_unlock();
    }
#line 469
    return ((SPDVoice **)((void *)0));
  }
  {
#line 472
  lines = g_strsplit(reply->str, (gchar *)"\n", - 1);
#line 473
  g_string_free(reply, ! 0);
#line 474
  voices = g_queue_new();
#line 475
  i = 0;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (*(lines + i) != (void *)0 && ! errors)) {
#line 475
      goto while_break;
    }
    {
#line 476
    MSG(1, "LINE here:|%s|", *(lines + i));
#line 477
    __cil_tmp16 = strlen((char const   *)*(lines + i));
    }
#line 477
    if (__cil_tmp16 <= 4UL) {
      {
#line 478
      MSG(1, "ERROR: Bad communication from driver in synth_voices\332U");
#line 480
      errors = ! 0;
      }
    } else
#line 481
    if ((int )*(*(lines + i) + 3) == 32) {
#line 482
      goto while_break;
    } else
#line 483
    if ((int )*(*(lines + i) + 3) == 45) {
      {
#line 484
      atoms = g_strsplit(*(lines + i) + 4, (gchar *)"\t\322T}\332U", 0);
      }
#line 486
      if (*(atoms + 0) == (void *)0) {
#line 488
        errors = ! 0;
      } else
#line 486
      if (*(atoms + 1) == (void *)0) {
#line 488
        errors = ! 0;
      } else
#line 486
      if (*(atoms + 2) == (void *)0) {
#line 488
        errors = ! 0;
      } else {
        {
#line 491
        voice = (SPDVoice *)g_malloc(sizeof(SPDVoice ));
#line 492
        voice->name = g_strdup(*(atoms + 0));
#line 493
        voice->language = g_strdup(*(atoms + 1));
#line 494
        voice->variant = g_strdup(*(atoms + 2));
#line 495
        g_queue_push_tail(voices, voice);
        }
      }
      {
#line 497
      g_strfreev(atoms);
      }
    }
#line 475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 503
  __cil_tmp23 = g_queue_get_length(voices);
#line 503
  numvoices = (int )__cil_tmp23;
  }
#line 505
  if (errors == 1) {
    {
#line 506
    g_queue_free_full(voices, (GDestroyNotify )(& free_voice));
#line 507
    g_strfreev(lines);
#line 508
    output_unlock();
    }
#line 509
    return ((SPDVoice **)((void *)0));
  }
  {
#line 512
  voice_dscr = (SPDVoice **)g_malloc((unsigned long )(numvoices + 1) * sizeof(SPDVoice *));
#line 514
  i = 0;
  }
  {
#line 514
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 514
    if (! (i < numvoices)) {
#line 514
      goto while_break___0;
    }
    {
#line 515
    *(voice_dscr + i) = (SPDVoice *)g_queue_pop_head(voices);
    }
#line 514
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 518
  *(voice_dscr + i) = (SPDVoice *)((void *)0);
#line 519
  g_queue_free(voices);
#line 520
  g_strfreev(lines);
#line 522
  output_unlock();
  }
#line 523
  return (voice_dscr);
}
}
#line 526 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
SPDVoice **output_list_voices(char const   *module_name ) 
{ 
  OutputModule *module ;
  OutputModule *__cil_tmp3 ;
  char const   *tmp ;
  SPDVoice **__cil_tmp5 ;

  {
  {
#line 528
  __cil_tmp3 = get_some_output_module_by_name(module_name);
#line 528
  module = __cil_tmp3;
  }
#line 529
  if (module == (void *)0) {
#line 530
    if (module_name) {
#line 530
      tmp = module_name;
    } else {
#line 530
      tmp = "default";
    }
    {
#line 530
    MSG(1, "ERROR: Can\'t list voices for module %s", tmp);
    }
#line 531
    return ((SPDVoice **)((void *)0));
  }
  {
#line 533
  __cil_tmp5 = output_get_voices(module);
  }
#line 533
  return (__cil_tmp5);
}
}
#line 571 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_send_settings(TSpeechDMessage *msg , OutputModule *output ) 
{ 
  GString *set_str ;
  char *val ;
  int err ;
  GString *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 577
  MSG(4, "Module set parameters.");
#line 578
  set_str = g_string_new((gchar *)"\220");
#line 579
  g_string_append_printf(set_str, (gchar *)"pitch=%d\n", msg->settings.msg_settings.pitch);
#line 581
  g_string_append_printf(set_str, (gchar *)"pitch_range=%d\n", msg->settings.msg_settings.pitch_range);
#line 583
  g_string_append_printf(set_str, (gchar *)"rate=%d\n\230\001", msg->settings.msg_settings.rate);
#line 585
  g_string_append_printf(set_str, (gchar *)"volume=%d\n", msg->settings.msg_settings.volume);
#line 587
  val = EPunctMode2str(msg->settings.msg_settings.punctuation_mode);
  }
#line 587
  if (val != (void *)0) {
#line 587
    if ((int )*(val + 0) != 0) {
      {
#line 587
      g_string_append_printf(set_str, (gchar *)"punctuation_mode=%s\n\230\001", val);
      }
    }
  }
  {
#line 587
  g_free(val);
#line 588
  val = ESpellMode2str(msg->settings.msg_settings.spelling_mode);
  }
#line 588
  if (val != (void *)0) {
#line 588
    if ((int )*(val + 0) != 0) {
      {
#line 588
      g_string_append_printf(set_str, (gchar *)"spelling_mode=%s\n", val);
      }
    }
  }
  {
#line 588
  g_free(val);
#line 589
  val = ECapLetRecogn2str(msg->settings.msg_settings.cap_let_recogn);
  }
#line 589
  if (val != (void *)0) {
#line 589
    if ((int )*(val + 0) != 0) {
      {
#line 589
      g_string_append_printf(set_str, (gchar *)"cap_let_recogn=%s\n", val);
      }
    }
  }
  {
#line 589
  g_free(val);
#line 590
  val = EVoice2str(msg->settings.msg_settings.voice_type);
  }
#line 591
  if (val != (void *)0) {
#line 591
    if ((int )*(val + 0) != 0) {
      {
#line 592
      g_string_append_printf(set_str, (gchar *)"voice=%s\n\024U}\332U", val);
      }
    }
  }
  {
#line 594
  g_free(val);
  }
#line 595
  if (msg->settings.msg_settings.voice.language != (void *)0) {
#line 595
    if ((int )*(msg->settings.msg_settings.voice.language + 0) != 0) {
      {
#line 597
      g_string_append_printf(set_str, (gchar *)"language=%s\n", msg->settings.msg_settings.voice.language);
      }
    } else {
      {
      {
#line 601
      g_string_append_printf(set_str, (gchar *)"language=NULL\n");
      }
      }
    }
  } else {
    {
    {
#line 601
    g_string_append_printf(set_str, (gchar *)"language=NULL\n");
    }
    }
  }
#line 603
  if (msg->settings.msg_settings.voice.name != (void *)0) {
#line 603
    if ((int )*(msg->settings.msg_settings.voice.name + 0) != 0) {
      {
#line 605
      g_string_append_printf(set_str, (gchar *)"synthesis_voice=%s\n}\332U", msg->settings.msg_settings.voice.name);
      }
    } else {
      {
      {
#line 608
      g_string_append_printf(set_str, (gchar *)"synthesis_voice=NULL\n");
      }
      }
    }
  } else {
    {
    {
#line 608
    g_string_append_printf(set_str, (gchar *)"synthesis_voice=NULL\n");
    }
    }
  }
  {
#line 611
  err = output_send_data("SET\n\230\001", output, 1);
  }
#line 611
  if (err < 0) {
#line 611
    return (err);
  }
  {
#line 612
  err = output_send_data((char const   *)set_str->str, output, 0);
  }
#line 612
  if (err < 0) {
#line 612
    return (err);
  }
  {
#line 613
  err = output_send_data(".\n", output, 1);
  }
#line 613
  if (err < 0) {
#line 613
    return (err);
  }
  {
#line 615
  g_string_free(set_str, 1);
  }
#line 617
  return (0);
}
}
#line 632 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static int output_server_audio(OutputModule *output ) 
{ 
  GString *set_str ;
  int err ;
  GString *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 637
  MSG(4, "Module set parameters.");
#line 638
  set_str = g_string_new((gchar *)"\220");
#line 639
  g_string_append_printf(set_str, (gchar *)"audio_output_method=server\n");
#line 641
  err = output_send_data("AUDIO\n", output, 1);
  }
#line 641
  if (err < 0) {
#line 641
    return (err);
  }
  {
#line 642
  err = output_send_data((char const   *)set_str->str, output, 0);
  }
#line 642
  if (err < 0) {
#line 642
    return (err);
  }
  {
#line 643
  err = output_send_data(".\n", output, 1);
  }
#line 643
  if (err < 0) {
#line 643
    return (err);
  }
  {
#line 645
  g_string_free(set_str, 1);
#line 647
  output->audio = (AudioID *)(- 1);
#line 649
  MSG(3, "Initialized for server audio for %s\n", output->name);
  }
#line 650
  return (0);
}
}
#line 654 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_send_audio_settings(OutputModule *output ) 
{ 
  GString *set_str ;
  int err ;
  int __cil_tmp4 ;
  GString *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 660
  __cil_tmp4 = output_server_audio(output);
  }
#line 660
  if (__cil_tmp4 == 0) {
#line 662
    return (0);
  }
  {
#line 664
  output->audio = (AudioID *)((void *)0);
#line 665
  MSG(4, "Module set parameters.");
#line 666
  set_str = g_string_new((gchar *)"\220");
  }
#line 667
  if (GlobalFDSet.audio_output_method != (void *)0) {
    {
#line 667
    g_string_append_printf(set_str, (gchar *)"audio_output_method=%s\n", GlobalFDSet.audio_output_method);
    }
  } else {
    {
#line 667
    g_string_append_printf(set_str, (gchar *)"audio_output_method=NULL\n");
    }
  }

#line 668
  if (GlobalFDSet.audio_oss_device != (void *)0) {
    {
#line 668
    g_string_append_printf(set_str, (gchar *)"audio_oss_device=%s\n\230\001", GlobalFDSet.audio_oss_device);
    }
  } else {
    {
#line 668
    g_string_append_printf(set_str, (gchar *)"audio_oss_device=NULL\nU}\332U");
    }
  }

#line 669
  if (GlobalFDSet.audio_alsa_device != (void *)0) {
    {
#line 669
    g_string_append_printf(set_str, (gchar *)"audio_alsa_device=%s\n", GlobalFDSet.audio_alsa_device);
    }
  } else {
    {
#line 669
    g_string_append_printf(set_str, (gchar *)"audio_alsa_device=NULL\n");
    }
  }

#line 670
  if (GlobalFDSet.audio_nas_server != (void *)0) {
    {
#line 670
    g_string_append_printf(set_str, (gchar *)"audio_nas_server=%s\n\230\001", GlobalFDSet.audio_nas_server);
    }
  } else {
    {
#line 670
    g_string_append_printf(set_str, (gchar *)"audio_nas_server=NULL\n");
    }
  }

#line 673
  if (GlobalFDSet.audio_pulse_device != (void *)0) {
    {
#line 673
    g_string_append_printf(set_str, (gchar *)"audio_pulse_device=%s\nU}\332U", GlobalFDSet.audio_pulse_device);
    }
  } else {
    {
#line 673
    g_string_append_printf(set_str, (gchar *)"audio_pulse_device=NULL\n");
    }
  }
  {
#line 674
  g_string_append_printf(set_str, (gchar *)"audio_pulse_min_length=%d\n", GlobalFDSet.audio_pulse_min_length);
#line 676
  err = output_send_data("AUDIO\nU}\332U", output, 1);
  }
#line 676
  if (err < 0) {
#line 676
    return (err);
  }
  {
#line 677
  err = output_send_data((char const   *)set_str->str, output, 0);
  }
#line 677
  if (err < 0) {
#line 677
    return (err);
  }
  {
#line 678
  err = output_send_data(".\n", output, 1);
  }
#line 678
  if (err < 0) {
#line 678
    return (err);
  }
  {
#line 680
  g_string_free(set_str, 1);
  }
#line 682
  return (0);
}
}
#line 685 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_send_loglevel_setting(OutputModule *output ) 
{ 
  GString *set_str ;
  int err ;
  GString *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 690
  MSG(4, "Module set parameters.");
#line 691
  set_str = g_string_new((gchar *)"\220");
#line 692
  g_string_append_printf(set_str, (gchar *)"log_level=%d\n", GlobalFDSet.log_level);
#line 694
  err = output_send_data("LOGLEVEL\n", output, 1);
  }
#line 694
  if (err < 0) {
#line 694
    return (err);
  }
  {
#line 695
  err = output_send_data((char const   *)set_str->str, output, 0);
  }
#line 695
  if (err < 0) {
#line 695
    return (err);
  }
  {
#line 696
  err = output_send_data(".\n", output, 1);
  }
#line 696
  if (err < 0) {
#line 696
    return (err);
  }
  {
#line 698
  g_string_free(set_str, 1);
  }
#line 700
  return (0);
}
}
#line 706 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_send_debug(OutputModule *output , int flag , char const   *log_path ) 
{ 
  char *cmd_str ;
  int err ;
  gchar *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 711
  MSG(4, "Module sending debug flag %d with file %s", flag, log_path);
#line 713
  output_lock();
  }
#line 714
  if (flag) {
    {
#line 715
    cmd_str = g_strdup_printf((gchar *)"DEBUG ON %s \n", log_path);
#line 716
    err = output_send_data((char const   *)cmd_str, output, 1);
#line 717
    g_free(cmd_str);
    }
#line 718
    if (err) {
      {
#line 719
      MSG(3, "ERROR: Can\'t set debugging on for output module %s", output->name);
#line 722
      output_unlock();
      }
#line 722
      return (- 1);

    }
  } else {
    {
#line 725
    err = output_send_data("DEBUG OFF \n", output, 1);
    }
#line 726
    if (err) {
      {
#line 727
      MSG(3, "ERROR: Can\'t switch debugging off for output module %s", output->name);
#line 730
      output_unlock();
      }
#line 730
      return (- 1);

    }
  }
  {
#line 735
  output_unlock();
  }
#line 735
  return (0);

}
}
#line 738 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_speak(TSpeechDMessage *msg , OutputModule *output ) 
{ 
  int err ;
  int ret ;
  char *newbuf ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 744
  if (msg == (void *)0) {
#line 745
    return (- 1);
  }
  {
#line 747
  output_lock();
#line 749
  newbuf = escape_dot(msg->buf);
  }
#line 750
  if (newbuf != msg->buf) {
    {
#line 751
    g_free(msg->buf);
#line 752
    msg->buf = newbuf;
    }
  }
  {
#line 754
  msg->bytes = - 1;
#line 756
  output_set_speaking_monitor(msg, output);
  }
#line 758
  if (module_audio_id) {
    {
#line 759
    __cil_tmp7 = module_speak_queue_before_synth();
    }
#line 759
    if (! __cil_tmp7) {
      {
#line 760
      MSG(3, "Warning: couldn\'t begin speak queue");
      }
    }
  }
  {
#line 764
  ret = output_send_settings(msg, output);
  }
#line 765
  if (ret != 0) {
    {
#line 766
    output_unlock();
    }
#line 766
    return (ret);
  }
  {
#line 768
  MSG(4, "Module speak!");
  }
  {
#line 771
  if ((unsigned int )msg->settings.type == (unsigned int )0) {
#line 771
    goto case_0;
  }
#line 773
  if ((unsigned int )msg->settings.type == (unsigned int )1) {
#line 773
    goto case_1;
  }
#line 776
  if ((unsigned int )msg->settings.type == (unsigned int )2) {
#line 776
    goto case_2;
  }
#line 779
  if ((unsigned int )msg->settings.type == (unsigned int )3) {
#line 779
    goto case_3;
  }
#line 782
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 772
  err = output_send_data("SPEAK\n", output, 1);
  }
#line 772
  if (err < 0) {
    {
#line 772
    output_unlock();
    }
#line 772
    return (err);
  }
#line 772
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 774
  err = output_send_data("SOUND_ICON\n", output, 1);
  }
#line 774
  if (err < 0) {
    {
#line 774
    output_unlock();
    }
#line 774
    return (err);
  }

#line 775
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 777
  err = output_send_data("CHAR\n", output, 1);
  }
#line 777
  if (err < 0) {
    {
#line 777
    output_unlock();
    }
#line 777
    return (err);
  }

#line 778
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 780
  err = output_send_data("KEY\n\230\001", output, 1);
  }
#line 780
  if (err < 0) {
    {
#line 780
    output_unlock();
    }
#line 780
    return (err);
  }

#line 781
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 783
  MSG(2, "Invalid message type in output_speak()!");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 786
  err = output_send_data((char const   *)msg->buf, output, 0);
  }
#line 786
  if (err < 0) {
    {
#line 786
    output_unlock();
    }
#line 786
    return (err);
  }
  {
#line 787
  err = output_send_data("\n.\n", output, 1);
  }
#line 787
  if (err < 0) {
    {
#line 787
    output_unlock();
    }
#line 787
    return (err);
  }
  {
#line 790
  output_end_queued = 0;
#line 791
  output_stop_requested = 0;
#line 792
  output_pause_requested = 0;
#line 793
  output_pause_queued = 0;
#line 794
  spd_pthread_create(& output_thread, (pthread_attr_t *)((void *)0), & output_thread_func,
                     output);
#line 796
  output_unlock();
  }
#line 798
  return (0);
}
}
#line 801 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_stop(void) 
{ 
  int err ;
  OutputModule *output ;
  int __cil_tmp3 ;

  {
  {
#line 806
  output_lock();
  }
#line 808
  if (speaking_module == (void *)0) {
    {
#line 809
    output_unlock();
    }
#line 809
    return (0);
  } else {
#line 811
    output = speaking_module;
  }
#line 813
  if (output->audio) {
#line 815
    if (output_end_queued) {
      {
#line 816
      MSG(4, "module is already done, stop speak_queue directly");
#line 817
      module_speak_queue_stop();
#line 818
      output_unlock();
      }
#line 818
      return (0);
    }
    {
#line 820
    MSG(4, "stopping speak_queue");
#line 821
    output_stop_requested = 1;
#line 822
    module_speak_queue_flush();
    }
  }
  {
#line 825
  MSG(4, "Module stop!");
#line 826
  err = output_send_data("STOP\n", output, 0);
  }
#line 826
  if (err < 0) {
    {
#line 826
    output_unlock();
    }
#line 826
    return (err);
  }
  {
#line 828
  output_unlock();
  }
#line 828
  return (0);
}
}
#line 831 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
size_t output_pause(void) 
{ 
  static int err ;
  static OutputModule *output ;
  int __cil_tmp3 ;

  {
  {
#line 836
  output_lock();
  }
#line 838
  if (speaking_module == (void *)0) {
    {
#line 839
    output_unlock();
    }
#line 839
    return ((size_t )0);
  } else {
#line 841
    output = speaking_module;
  }
#line 843
  if (output->audio) {
#line 845
    if (output_end_queued) {
      {
#line 846
      MSG(4, "module is already done, pause speak_queue directlyU}\332U");
#line 847
      module_speak_queue_pause();
#line 848
      output_unlock();
      }
#line 848
      return ((size_t )0);
    }
    {
#line 850
    MSG(4, "pausing speak_queue");
#line 851
    output_pause_requested = 1;
    }
  }
  {
#line 854
  MSG(4, "Module pause!");
#line 855
  err = output_send_data("PAUSE\n", output, 0);
  }
#line 855
  if (err < 0) {
    {
#line 855
    output_unlock();
    }
#line 855
    return ((size_t )err);
  }
  {
#line 857
  output_unlock();
  }
#line 857
  return ((size_t )0);
}
}
#line 860 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static GSList *playback_events  =    (GSList *)((void *)0);
#line 861 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static pthread_mutex_t playback_events_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 863 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static speak_queue_entry *output_new_event(speak_queue_entry_type type ) 
{ 
  speak_queue_entry *entry ;

  {
#line 865
  entry = (speak_queue_entry *)0;
#line 866
  entry->type = type;
#line 867
  return (entry);
}
}
#line 870 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void output_queue_event(speak_queue_entry *entry ) 
{ 
  char c ;
  int ret ;
  GSList *__cil_tmp4 ;
  ssize_t __cil_tmp5 ;
  int *__cil_tmp6 ;
  int *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 872
  c = (char )0;
#line 874
  pthread_mutex_lock(& playback_events_mutex);
#line 875
  playback_events = g_slist_append(playback_events, entry);
#line 876
  pthread_mutex_unlock(& playback_events_mutex);
#line 877
  __cil_tmp5 = write(speaking_module->pipe_speak[1], & c, (size_t )1);
#line 877
  ret = (int )__cil_tmp5;
  }
#line 878
  if (ret != 1) {
    {
#line 879
    __cil_tmp6 = __errno_location();
    }
    {
#line 879
    __cil_tmp7 = __errno_location();
#line 879
    __cil_tmp8 = strerror(*__cil_tmp7);
#line 879
    MSG(1, "Warning: couln\'t write to pipe_speak: %d returned, (errno = %d, %s)\n",
        ret, *__cil_tmp6, __cil_tmp8);
    }
  }
  return;
}
}
#line 882 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void output_queue_new_event(speak_queue_entry_type type ) 
{ 
  speak_queue_entry *entry ;
  speak_queue_entry *__cil_tmp3 ;

  {
  {
#line 884
  __cil_tmp3 = output_new_event(type);
#line 884
  entry = __cil_tmp3;
#line 885
  output_queue_event(entry);
  }
  return;
}
}
#line 888 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_index_mark(char const   *mark ) 
{ 
  speak_queue_entry *entry ;
  speak_queue_entry *__cil_tmp3 ;
  gchar *__cil_tmp4 ;

  {
  {
#line 890
  __cil_tmp3 = output_new_event((speak_queue_entry_type )1);
#line 890
  entry = __cil_tmp3;
#line 891
  entry->data.markId = g_strdup(mark);
#line 892
  output_queue_event(entry);
  }
  return;
}
}
#line 894 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_event_begin(void) 
{ 


  {
  {
#line 896
  output_queue_new_event((speak_queue_entry_type )3);
  }
  return;
}
}
#line 898 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_event_end(void) 
{ 


  {
  {
#line 900
  output_queue_new_event((speak_queue_entry_type )4);
  }
  return;
}
}
#line 902 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_event_broken(void) 
{ 


  {
  {
#line 904
  output_queue_new_event((speak_queue_entry_type )7);
  }
  return;
}
}
#line 906 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_event_stop(void) 
{ 


  {
  {
#line 908
  output_queue_new_event((speak_queue_entry_type )6);
  }
  return;
}
}
#line 910 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_report_event_pause(void) 
{ 


  {
  {
#line 912
  output_queue_new_event((speak_queue_entry_type )5);
  }
  return;
}
}
#line 914 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
void module_speak_queue_cancel(void) 
{ 


  {
  return;
}
}
#line 919 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static int output_module_is_speaking(OutputModule *output ) 
{ 
  GString *response ;
  int retcode ;
  GString *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  gboolean __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  char *p ;
  char *index_mark ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  gboolean __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  char *p___0 ;
  char *icon ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  gboolean __cil_tmp23 ;
  int __cil_tmp24 ;
  AudioTrack track ;
  AudioFormat format ;
  char *p___1 ;
  char *q ;
  char *end ;
  size_t size ;
  size_t filled ;
  int __cil_tmp32 ;
  void *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  unsigned long __cil_tmp38 ;
  int __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  int __cil_tmp43 ;
  unsigned long __cil_tmp44 ;
  int __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  int __cil_tmp49 ;
  unsigned long __cil_tmp50 ;
  int __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  int __cil_tmp55 ;
  unsigned long __cil_tmp56 ;
  int __cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  char *data ;
  char escape ;
  char invert ;
  size_t piece ;
  void *__cil_tmp64 ;
  char *__cil_tmp65 ;
  size_t __cil_tmp66 ;
  char *__cil_tmp67 ;
  gboolean ret ;
  gboolean __cil_tmp69 ;

  {
  {
#line 922
  retcode = - 1;
#line 924
  MSG(5, "output_module_is_speaking()");
  }
#line 926
  if (output == (void *)0) {
    {
#line 927
    MSG(5, "output==NULL in output_module_is_speaking()");
#line 928
    module_report_event_broken();
    }
#line 929
    return (- 1);
  }
  {
#line 932
  response = output_read_event(output);
  }
#line 933
  if (response == (void *)0) {
    {
#line 934
    module_report_event_broken();
    }
#line 935
    return (- 1);
  }
  {
#line 938
  MSG2(5, "output_module", "Event from output module while speaking: |%s|", response->str);
  }
#line 941
  if (response->len < 4UL) {
    {
#line 942
    MSG2(2, "output_module", "Error: Wrong communication from output module! Event less than four bytes.");
#line 944
    g_string_free(response, ! 0);
#line 945
    module_report_event_broken();
    }
#line 946
    return (- 1);
  }
  {
#line 949
  retcode = 1;
#line 950
  MSG2(5, "output_module", "Received event:\n %s", response->str);
#line 951
  __cil_tmp5 = strncmp((char const   *)response->str, "701", (unsigned long )3);
  }
#line 951
  if (! __cil_tmp5) {
    {
#line 953
    MSG2(5, "output_module", "got begin");
    }
#line 954
    if (output->audio) {
      {
#line 955
      __cil_tmp6 = module_speak_queue_before_play();
      }
#line 955
      if (! __cil_tmp6) {
        {
#line 956
        MSG(3, "Warning: couldn\'t add begin to speak queue");
        }
      }
    } else {
      {
#line 958
      module_report_event_begin();
      }
    }
  } else {
    {
#line 961
    __cil_tmp7 = strncmp((char const   *)response->str, "702", (unsigned long )3);
    }
#line 961
    if (! __cil_tmp7) {
      {
#line 963
      MSG2(5, "output_module", "got end");
      }
#line 964
      if (output->audio) {
#line 965
        if (output_stop_requested) {
          {
#line 966
          MSG(4, "we sent STOP too late, now tell the speak queue");
#line 967
          module_speak_queue_stop();
          }
        } else
#line 968
        if (output_pause_requested) {
          {
#line 969
          MSG(4, "we sent PAUSE too late, now tell the speak queue\220");
          }
#line 970
          if (! output_pause_queued) {
            {
#line 971
            module_speak_queue_pause();
            }
          }
        } else {
          {
#line 973
          __cil_tmp8 = module_speak_queue_add_end();
          }
#line 973
          if (! __cil_tmp8) {
            {
#line 974
            MSG(3, "Warning: couldn\'t add end to speak queue\220");
            }
          }
#line 977
          output_end_queued = 1;
        }
      } else {
        {
#line 980
        module_report_event_end();
        }
      }
#line 982
      retcode = 0;
    } else {
      {
#line 984
      __cil_tmp9 = strncmp((char const   *)response->str, "703", (unsigned long )3);
      }
#line 984
      if (! __cil_tmp9) {
        {
#line 986
        MSG2(5, "output_module", "got stopped");
        }
#line 987
        if (output->audio) {
#line 988
          if (! output_pause_queued) {
            {
#line 989
            module_speak_queue_stop();
            }
          }
        } else {
          {
#line 992
          module_report_event_stop();
          }
        }
#line 993
        retcode = 0;
      } else {
        {
#line 995
        __cil_tmp10 = strncmp((char const   *)response->str, "704", (unsigned long )3);
        }
#line 995
        if (! __cil_tmp10) {
          {
#line 997
          MSG2(5, "output_module", "got paused");
          }
#line 998
          if (output->audio) {
#line 999
            if (! output_pause_queued) {
              {
#line 1000
              module_speak_queue_pause();
              }
            }
          } else {
            {
#line 1002
            module_report_event_pause();
            }
          }
#line 1003
          retcode = 0;
        } else {
          {
#line 1005
          __cil_tmp11 = strncmp((char const   *)response->str, "700", (unsigned long )3);
          }
#line 1005
          if (! __cil_tmp11) {
            {
#line 1008
            p = strchr((char const   *)response->str, '\n');
#line 1009
            MSG2(5, "output_module", "response:|%s|\n p:|%s|", response->str, p);
#line 1011
            __cil_tmp15 = strndup((char const   *)(response->str + 4), (unsigned long )((p - response->str) - 4L));
#line 1011
            index_mark = (char *)__cil_tmp15;
#line 1014
            MSG2(5, "output_module", "Detected INDEX MARK: %s", index_mark);
            }
#line 1016
            if (output->audio) {
#line 1017
              if (! (output_stop_requested || (output_pause_requested && output_pause_queued))) {
                {
#line 1018
                __cil_tmp16 = module_speak_queue_add_mark((char const   *)index_mark);
                }
#line 1018
                if (! __cil_tmp16) {
                  {
#line 1019
                  MSG(3, "Warning: couldn\'t add mark to speak queue");
                  }
                }
                {
#line 1020
                __cil_tmp17 = strncmp((char const   *)index_mark, "__spd_", (unsigned long )6);
                }
#line 1020
                if (output_pause_requested) {
#line 1020
                  if (! __cil_tmp17) {
                    {
#line 1022
                    MSG(5, "Pausing the queue at mark %s", index_mark);
#line 1023
                    module_speak_queue_pause();
#line 1024
                    output_pause_queued = 1;
                    }
                  }
                }
              }
            } else {
              {
#line 1028
              module_report_index_mark((char const   *)index_mark);
              }
            }
            {
#line 1030
            free(index_mark);
            }
          } else {
            {
#line 1032
            __cil_tmp18 = strncmp((char const   *)response->str, "706", (unsigned long )3);
            }
#line 1032
            if (! __cil_tmp18) {
              {
#line 1035
              p___0 = strchr((char const   *)response->str, '\n');
#line 1036
              MSG2(5, "output_module", "response:|%s|\n p:|%s|", response->str, p___0);
#line 1038
              __cil_tmp22 = strndup((char const   *)(response->str + 4), (unsigned long )((p___0 - response->str) - 4L));
#line 1038
              icon = (char *)__cil_tmp22;
#line 1041
              MSG2(5, "output_module", "Detected sound icon: %s", icon);
              }
#line 1043
              if (output->audio) {
#line 1043
                if (! (output_stop_requested || (output_pause_requested && output_pause_queued))) {
                  {
#line 1045
                  __cil_tmp23 = module_speak_queue_add_sound_icon((char const   *)icon);
                  }
#line 1045
                  if (! __cil_tmp23) {
                    {
#line 1046
                    MSG(3, "Warning: couldn\'t add icon to speak queue");
                    }
                  }
                }
              }
              {
#line 1048
              free(icon);
              }
            } else {
              {
#line 1050
              __cil_tmp24 = strncmp((char const   *)response->str, "705", (unsigned long )3);
              }
#line 1050
              if (! __cil_tmp24) {
#line 1052
                track.bits = 0;
#line 1052
                track.num_channels = 0;
#line 1052
                track.sample_rate = 0;
#line 1052
                track.num_samples = 0;
                {
#line 1052
                track.samples = (short *)0;
#line 1053
                format = (AudioFormat )0;
#line 1054
                p___1 = response->str;
#line 1055
                end = response->str + response->len;
#line 1058
                MSG2(5, "output_module", "Got audio: %d bytes", (int )response->len);
                }
#line 1061
                if (! output->audio) {
                  {
#line 1062
                  MSG2(2, "output_module", "Audio event but server audio not set up");
#line 1064
                  retcode = - 5;
                  }
#line 1065
                  goto out;
                }
#line 1068
                if (output_stop_requested) {
                  {
                  {
#line 1069
                  MSG2(5, "output_module", "Discarding audio still coming from the synth");
                  }
                  }
#line 1070
                  goto out;
                } else
#line 1068
                if (output_pause_requested) {
#line 1068
                  if (output_pause_queued) {
                    {
                    {
#line 1069
                    MSG2(5, "output_module", "Discarding audio still coming from the synth");
                    }
                    }
#line 1070
                    goto out;
                  }
                }
                {
#line 1073
                while (1) {
                  while_continue: /* CIL Label */ ;
                  {
#line 1074
                  __cil_tmp32 = strncmp((char const   *)p___1, "705-", (unsigned long )4);
                  }
#line 1074
                  if (__cil_tmp32 != 0) {
                    {
#line 1075
                    MSG2(2, "output_module", "ERROR: bogus audio parameter %s", p___1);
#line 1077
                    retcode = - 5;
                    }
#line 1078
                    goto while_break;
                  }
                  {
#line 1080
                  q = (char *)memchr(p___1, '\n', (unsigned long )(end - p___1));
                  }
#line 1081
                  if (! q) {
                    {
#line 1082
                    MSG2(2, "output_module", "ERROR: bogus audio end of line %s",
                         p___1);
#line 1084
                    retcode = - 5;
                    }
#line 1085
                    goto while_break;
                  }
                  {
#line 1088
                  __cil_tmp36 = strlen("705-AUDIO");
                  }
                  {
#line 1088
                  __cil_tmp34 = strlen("705-AUDIO");
#line 1088
                  __cil_tmp35 = strncmp((char const   *)p___1, "705-AUDIO", __cil_tmp34);
                  }
#line 1088
                  if (__cil_tmp35 == 0) {
#line 1088
                    if ((int )*(p___1 + __cil_tmp36) == 0) {
                      {
#line 1089
                      __cil_tmp37 = strlen("705-AUDIO");
                      }
#line 1089
                      p___1 += __cil_tmp37 + 1UL;
#line 1090
                      goto while_break;
                    }
                  }
                  {
#line 1093
                  __cil_tmp38 = strlen("705-big_endian=");
#line 1093
                  __cil_tmp39 = strncmp((char const   *)p___1, "705-big_endian=",
                                        __cil_tmp38);
                  }
#line 1093
                  if (__cil_tmp39 == 0) {
                    {
#line 1094
                    __cil_tmp40 = strlen("705-big_endian=");
#line 1094
                    __cil_tmp41 = atoi((char const   *)(p___1 + __cil_tmp40));
#line 1094
                    format = (AudioFormat )__cil_tmp41;
                    }
                  } else {
                    {
#line 1102
                    __cil_tmp42 = strlen("705-bits=");
#line 1102
                    __cil_tmp43 = strncmp((char const   *)p___1, "705-bits=", __cil_tmp42);
                    }
#line 1102
                    if (__cil_tmp43 == 0) {
                      {
#line 1102
                      __cil_tmp44 = strlen("bits");
#line 1102
                      __cil_tmp45 = atoi((char const   *)(((p___1 + 4) + __cil_tmp44) + 1));
#line 1102
                      track.bits = __cil_tmp45;
#line 1102
                      MSG2(5, "output_module", "Got audio parameter bits %d", track.bits);
                      }
                    } else {
                      {
#line 1103
                      __cil_tmp46 = strlen("705-num_channels=");
#line 1103
                      __cil_tmp47 = strncmp((char const   *)p___1, "705-num_channels=",
                                            __cil_tmp46);
                      }
#line 1103
                      if (__cil_tmp47 == 0) {
                        {
#line 1103
                        __cil_tmp48 = strlen("num_channels");
#line 1103
                        __cil_tmp49 = atoi((char const   *)(((p___1 + 4) + __cil_tmp48) + 1));
#line 1103
                        track.num_channels = __cil_tmp49;
#line 1103
                        MSG2(5, "output_module", "Got audio parameter num_channels %d",
                             track.num_channels);
                        }
                      } else {
                        {
#line 1104
                        __cil_tmp50 = strlen("705-sample_rate=\220");
#line 1104
                        __cil_tmp51 = strncmp((char const   *)p___1, "705-sample_rate=\230",
                                              __cil_tmp50);
                        }
#line 1104
                        if (__cil_tmp51 == 0) {
                          {
#line 1104
                          __cil_tmp52 = strlen("sample_rate");
#line 1104
                          __cil_tmp53 = atoi((char const   *)(((p___1 + 4) + __cil_tmp52) + 1));
#line 1104
                          track.sample_rate = __cil_tmp53;
#line 1104
                          MSG2(5, "output_module", "Got audio parameter sample_rate %d",
                               track.sample_rate);
                          }
                        } else {
                          {
#line 1105
                          __cil_tmp54 = strlen("705-num_samples=\220");
#line 1105
                          __cil_tmp55 = strncmp((char const   *)p___1, "705-num_samples=\230",
                                                __cil_tmp54);
                          }
#line 1105
                          if (__cil_tmp55 == 0) {
                            {
#line 1105
                            __cil_tmp56 = strlen("num_samples");
#line 1105
                            __cil_tmp57 = atoi((char const   *)(((p___1 + 4) + __cil_tmp56) + 1));
#line 1105
                            track.num_samples = __cil_tmp57;
#line 1105
                            MSG2(5, "output_module", "Got audio parameter num_samples %d",
                                 track.num_samples);
                            }
                          } else {
                            {
#line 1107
                            MSG2(2, "output_module", "ERROR: unknown audio parameter %s",
                                 p___1);
#line 1109
                            retcode = - 5;
                            }
#line 1110
                            goto while_break;
                          }
                        }
                      }
                    }
                  }
#line 1112
                  p___1 = q + 1;
                }
                while_break: /* CIL Label */ ;
                }
#line 1115
                if (retcode < 0) {
#line 1116
                  goto out;
                }
                {
#line 1118
                size = (size_t )(((track.num_channels * track.num_samples) * track.bits) / 8);
#line 1119
                track.samples = (short *)malloc(size);
#line 1120
                filled = (size_t )0;
#line 1122
                end = (char *)memchr(p___1, '\n', (unsigned long )(end - p___1));
                }
#line 1123
                if (! end) {
                  {
#line 1124
                  MSG2(2, "output_module", "ERROR: bogus audio end of line %s", p___1);
#line 1126
                  retcode = - 5;
                  }
#line 1127
                  goto out;
                }
#line 1130
                data = (char *)track.samples;
#line 1133
                escape = (char )125;
#line 1134
                invert = (char )(1 << 5);
                {
#line 1136
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 1136
                  if (! (p___1 < end)) {
#line 1136
                    goto while_break___0;
                  }
                  {
#line 1139
                  q = (char *)memchr(p___1, (int )escape, (unsigned long )(end - p___1));
                  }
#line 1140
                  if (! q) {
#line 1141
                    q = end;
                  }
#line 1143
                  piece = (size_t )(q - p___1);
#line 1145
                  if (filled + piece > size) {
                    {
#line 1146
                    MSG2(2, "output_module", "ERROR: bogus audio content: %zd > %zd",
                         filled + piece, size);
#line 1148
                    retcode = - 5;
                    }
#line 1149
                    goto while_break___0;
                  }
                  {
#line 1152
                  memcpy(data + filled, p___1, piece);
#line 1153
                  filled += piece;
#line 1154
                  p___1 = q;
                  }
                  {
#line 1156
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 1156
                    if (! (p___1 < end && (int )*p___1 == (int )escape)) {
#line 1156
                      goto while_break___1;
                    }
#line 1157
                    p___1 ++;
#line 1158
                    if (p___1 == end) {
                      {
#line 1159
                      MSG2(2, "output_module", "ERROR: bogus audio escape at end\220");
#line 1161
                      retcode = - 5;
                      }
#line 1162
                      goto while_break___1;
                    }
#line 1164
                    if (filled + 1UL > size) {
                      {
#line 1165
                      MSG2(2, "output_module", "ERROR: bogus audio content: %zd > %zd",
                           filled + 1UL, size);
#line 1167
                      retcode = - 5;
                      }
#line 1168
                      goto while_break___1;
                    }
#line 1170
                    __cil_tmp66 = filled;
#line 1170
                    filled ++;
#line 1170
                    *(data + __cil_tmp66) = (char )((int )*p___1 ^ (int )invert);
#line 1171
                    p___1 ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
#line 1173
                  if (retcode < 0) {
#line 1174
                    goto while_break___0;
                  }
                }
                while_break___0: /* CIL Label */ ;
                }
#line 1177
                if (filled != size) {
                  {
#line 1178
                  MSG2(2, "output_module", "ERROR: bogus audio content: %zd < %zd",
                       filled, size);
#line 1180
                  retcode = - 5;
                  }
                }
#line 1183
                if (retcode < 0) {
                  {
#line 1184
                  free(track.samples);
                  }
#line 1185
                  goto out;
                }
                {
#line 1188
                MSG2(5, "output_module", "Got audio: eventually %zd bytes", size);
#line 1191
                __cil_tmp69 = module_speak_queue_add_audio(& track, format);
#line 1191
                ret = __cil_tmp69;
#line 1193
                free(track.samples);
                }
#line 1195
                if (! ret) {
                  {
#line 1196
                  MSG2(2, "output_module", "Audio interrupted");
                  }
                }
              } else {
                {
#line 1198
                MSG2(2, "output_module", "ERROR: Unknown event received from output module\220");
#line 1200
                retcode = - 5;
                }
              }
            }
          }
        }
      }
    }
  }
  out: 
#line 1204
  if (retcode < 0) {
    {
#line 1205
    module_report_event_broken();
    }
  }
  {
#line 1206
  g_string_free(response, ! 0);
  }
#line 1207
  return (retcode);
}
}
#line 1212 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
static void *output_thread_func(void *data ) 
{ 
  OutputModule *output ;
  int ret ;
  int __cil_tmp4 ;

  {
#line 1214
  output = data;
  {
#line 1217
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1218
    ret = output_module_is_speaking(output);
    }
#line 1219
    if (ret < 0) {
      {
#line 1220
      MSG2(3, "output_module", "output_module_is_speaking error");
#line 1221
      pthread_exit((void *)0);
      }
    }
#line 1223
    if (ret == 0) {
      {
#line 1224
      MSG2(4, "output_module", "finished getting data from output module\220");
#line 1225
      pthread_exit((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1230 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_is_speaking(char **index_mark ) 
{ 
  OutputModule *output ;
  speak_queue_entry *entry ;
  char c ;
  int end ;
  int ret ;
  ssize_t __cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  char *__cil_tmp10 ;
  GSList *__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  gchar *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  gchar *__cil_tmp16 ;
  gchar *__cil_tmp17 ;

  {
  {
#line 1232
  output = speaking_module;
#line 1236
  end = 0;
#line 1239
  __cil_tmp7 = read(output->pipe_speak[0], & c, (size_t )1);
#line 1239
  ret = (int )__cil_tmp7;
  }
#line 1240
  if (ret != 1) {
    {
#line 1241
    __cil_tmp8 = __errno_location();
    }
    {
#line 1241
    __cil_tmp9 = __errno_location();
#line 1241
    __cil_tmp10 = strerror(*__cil_tmp9);
#line 1241
    MSG(1, "Warning: couln\'t read from pipe_speak: %d returned, (errno = %d, %s)\n",
        ret, *__cil_tmp8, __cil_tmp10);
    }
  }
  {
#line 1243
  pthread_mutex_lock(& playback_events_mutex);
#line 1244
  entry = playback_events->data;
#line 1245
  playback_events = g_slist_remove(playback_events, entry);
#line 1246
  pthread_mutex_unlock(& playback_events_mutex);
  }
  {
#line 1250
  if ((unsigned int )entry->type == (unsigned int )0) {
#line 1250
    goto case_0;
  }
#line 1255
  if ((unsigned int )entry->type == (unsigned int )1) {
#line 1255
    goto case_1;
  }
#line 1258
  if ((unsigned int )entry->type == (unsigned int )2) {
#line 1258
    goto case_2;
  }
#line 1263
  if ((unsigned int )entry->type == (unsigned int )3) {
#line 1263
    goto case_3;
  }
#line 1266
  if ((unsigned int )entry->type == (unsigned int )4) {
#line 1266
    goto case_4;
  }
#line 1270
  if ((unsigned int )entry->type == (unsigned int )5) {
#line 1270
    goto case_5;
  }
#line 1274
  if ((unsigned int )entry->type == (unsigned int )6) {
#line 1274
    goto case_6;
  }
#line 1278
  if ((unsigned int )entry->type == (unsigned int )7) {
#line 1278
    goto case_7;
  }
#line 1249
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1251
  MSG2(3, "output_module", "audio event ??");
  }
  {
#line 1252
  g_free(entry->data.audio.track.samples);
#line 1253
  __cil_tmp12 = g_strdup((gchar *)"no");
#line 1253
  *index_mark = (char *)__cil_tmp12;
  }
#line 1254
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1256
  *index_mark = entry->data.markId;
#line 1257
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1259
  MSG2(3, "output_module", "audio icon event ??");
  }
  {
#line 1260
  g_free(entry->data.sound_icon_filename);
#line 1261
  __cil_tmp13 = g_strdup((gchar *)"no");
#line 1261
  *index_mark = (char *)__cil_tmp13;
  }
#line 1262
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1264
  __cil_tmp14 = g_strdup((gchar *)"__spd_begin");
#line 1264
  *index_mark = (char *)__cil_tmp14;
  }
#line 1265
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1267
  __cil_tmp15 = g_strdup((gchar *)"__spd_end");
#line 1267
  *index_mark = (char *)__cil_tmp15;
  }
#line 1268
  end = 1;
#line 1269
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1271
  __cil_tmp16 = g_strdup((gchar *)"__spd_paused\332U");
#line 1271
  *index_mark = (char *)__cil_tmp16;
  }
#line 1272
  end = 1;
#line 1273
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1275
  __cil_tmp17 = g_strdup((gchar *)"__spd_stoppedU");
#line 1275
  *index_mark = (char *)__cil_tmp17;
  }
#line 1276
  end = 1;
#line 1277
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1279
  *index_mark = (char *)((void *)0);
#line 1280
  end = 1;
#line 1281
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1283
  g_free(entry);
  }
#line 1285
  if (end) {
    {
#line 1288
    pthread_join(output_thread, (void **)((void *)0));
    }
  }
#line 1291
  return (0);
}
}
#line 1298 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int waitpid_with_timeout(pid_t pid , int *status_ptr , int options , size_t timeout ) 
{ 
  size_t i ;
  int ret ;
  __pid_t __cil_tmp7 ;

  {
#line 1302
  i = (size_t )0;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! (i <= timeout)) {
#line 1302
      goto while_break;
    }
    {
#line 1303
    ret = waitpid(pid, status_ptr, options | 1);
    }
#line 1304
    if (ret > 0) {
#line 1305
      return (ret);
    }
#line 1306
    if (ret < 0) {
#line 1307
      return (ret);
    }
    {
#line 1308
    usleep((__useconds_t )100000);
    }
#line 1302
    i += (unsigned long )100;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  return (0);
}
}
#line 1313 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_close(OutputModule *module ) 
{ 
  int err ;
  int ret ;
  OutputModule *output ;
  int tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int ret2 ;
  int __cil_tmp10 ;

  {
#line 1318
  output = module;
#line 1320
  if (output == (void *)0) {
#line 1321
    return (- 1);
  }
  {
#line 1323
  output_lock();
#line 1326
  MSG(3, "Closing module \"%s\"...", output->name);
  }
#line 1327
  if (output->working) {
    {
#line 1328
    err = output_send_data("STOP\n", output, 0);
    }
#line 1328
    if (err < 0) {
      {
#line 1328
      output_unlock();
      }
#line 1328
      return (err);
    }
    {
#line 1329
    err = output_send_data("QUIT\n", output, 1);
    }
#line 1329
    if (err < 0) {
      {
#line 1329
      output_unlock();
      }
#line 1329
      return (err);
    }
    {
#line 1330
    usleep((__useconds_t )100);
    }
  }
  {
#line 1334
  MSG(4, "Waiting for module pid %d", module->pid);
#line 1335
  ret = waitpid_with_timeout(module->pid, (int *)((void *)0), 0, (size_t )1000);
  }
#line 1336
  if (ret > 0) {
    {
#line 1337
    MSG(4, "Ok, module closed successfully.");
    }
  } else
#line 1338
  if (ret == 0) {
    {
#line 1340
    MSG(1, "ERROR: Timed out when waiting for child cancellation");
#line 1341
    MSG(3, "Killing the moduleV}\332U");
#line 1342
    kill(module->pid, 9);
#line 1343
    MSG(4, "Waiting until the child terminates.");
#line 1344
    ret2 = waitpid_with_timeout(module->pid, (int *)((void *)0), 0, (size_t )1000);
    }
#line 1345
    if (ret2 > 0) {
      {
#line 1346
      MSG(3, "Module terminated\234V}\332U");
      }
    } else {
      {
#line 1348
      MSG(1, "ERROR: Module is not able to terminate, giving up.V}\332U");
      }
    }
  } else {
    {
#line 1352
    MSG(1, "ERROR: waitpid() failed when waiting for child (module).\220");
    }
  }
  {
#line 1356
  output_unlock();
  }
#line 1356
  return (0);
}
}
#line 1362 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
int output_check_module(OutputModule *output ) 
{ 
  int ret ;
  int err ;
  int status ;
  __pid_t __cil_tmp5 ;

  {
#line 1368
  if (output == (void *)0) {
#line 1369
    return (- 1);
  }
  {
#line 1371
  MSG(4, "Output module working status: %d (pid:%d)9W}\332U", output->working, output->pid);
  }
#line 1374
  if (output->working == 0) {
    {
#line 1376
    ret = waitpid(output->pid, & status, 1);
    }
#line 1377
    if (ret == 0) {
      {
#line 1378
      MSG(2, "Output module not running.W}\332U");
      }
#line 1379
      return (0);
    }
#line 1381
    ret = (status & 127) == 0;
#line 1385
    if (1) {
      {
#line 1387
      MSG(2, "Output module terminated abnormally, probably crashed.");
      }
    } else {
#line 1391
      err = (status & 65280) >> 8;
#line 1392
      if (err == 0) {
        {
#line 1393
        MSG(2, "Module exited normally");
        }
      }
#line 1394
      if (err == 1) {
        {
#line 1395
        MSG(2, "Internal error in output module!\220");
        }
      }
#line 1396
      if (err == 2) {
        {
#line 1397
        MSG(2, "Output device not working. For software devices, this can meanthat they are not running or they are not accessible due to wrongacces permissions./W}\332U");
        }
      }
#line 1402
      if (err > 2) {
        {
#line 1403
        MSG(2, "Unknown error happened in output module, exit status: %d !", err);
        }
      }
    }
  }
#line 1408
  return (0);
}
}
#line 1411 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/output.c"
char *escape_dot(char *otext ) 
{ 
  char *seq ;
  GString *ntext ;
  char *ootext ;
  char *ret ;
  GString *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1416
  ret = (char *)((void *)0);
#line 1418
  if (otext == (void *)0) {
#line 1419
    return ((char *)((void *)0));
  }
  {
#line 1421
  MSG2(5, "escaping\323\001 |\001", "Incoming text: |%s|\377", otext);
#line 1423
  ootext = otext;
#line 1425
  ntext = g_string_new((gchar *)"\220");
  }
#line 1427
  if ((int )*(otext + 0) == 46) {
    {
#line 1428
    g_string_append(ntext, (gchar *)"..V}\332U");
#line 1429
    otext ++;
    }
  }
  {
#line 1432
  MSG2(6, "escaping\323\001 |\001", "Altering text (I): |%s|", ntext->str);
  }
  {
#line 1434
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1434
    seq = strstr((char const   *)otext, "\n.V}\332U");
    }
#line 1434
    if (! seq) {
#line 1434
      goto while_break;
    }
    {
#line 1435
    *seq = (char )0;
#line 1436
    g_string_append(ntext, otext);
#line 1437
    g_string_append(ntext, (gchar *)"\n..");
#line 1438
    otext = seq + 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1441
  MSG2(6, "escaping\323\001 ", "Altering text (II): |%s|\230\001", ntext->str);
  }
#line 1443
  if (otext == ootext) {
    {
#line 1444
    g_string_free(ntext, 1);
#line 1445
    ret = otext;
    }
  } else {
    {
#line 1447
    g_string_append(ntext, otext);
#line 1448
    g_free(ootext);
#line 1449
    ret = ntext->str;
#line 1450
    g_string_free(ntext, 0);
    }
  }
  {
#line 1453
  MSG2(6, "escaping\323\001 ", "Altered text: |%s|V}\332U", ret);
  }
#line 1455
  return (ret);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat(char const   *__file , struct stat *__buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__buf ) ;
#line 240
extern  __attribute__((__nothrow__)) int stat64(char const   *__file , struct stat64 *__buf ) ;
#line 242
extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__buf ) ;
#line 264
extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__file ,
                                                 struct stat *__buf , int __flag ) ;
#line 291
extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__file ,
                                                   struct stat64 *__buf , int __flag ) ;
#line 313
extern  __attribute__((__nothrow__)) int lstat(char const   *__file , struct stat *__buf ) ;
#line 338
extern  __attribute__((__nothrow__)) int lstat64(char const   *__file , struct stat64 *__buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 359
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 365
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 371
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 380
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 385
extern  __attribute__((__nothrow__)) __mode_t getumask(void) ;
#line 389
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 396
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 404
extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                               __dev_t __dev ) ;
#line 411
extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                 __mode_t __mode , __dev_t __dev ) ;
#line 418
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 425
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 433
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h"
 __attribute__((__nothrow__)) int statx(int __dirfd , char const   *__path , int __flags ,
                                        unsigned int __mask , struct statx *__buf ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option *__longopts ,
                                                     int *__longind ) ;
#line 70
extern  __attribute__((__nothrow__)) int getopt_long_only(int ___argc , char * const  *___argv ,
                                                          char const   *__shortopts ,
                                                          struct option *__longopts ,
                                                          int *__longind ) ;
#line 24 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.h"
void options_print_help(char *argv[] ) ;
#line 25
void options_print_version(void) ;
#line 26
void options_parse(int argc , char *argv[] ) ;
#line 37 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
static struct option spd_long_options[16]  = 
#line 37 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
  {      {"run-daemon", 0, (int *)0, 'd'}, 
        {"run-single", 0, (int *)0, 's'}, 
        {"spawn", 0, (int *)0, 'a'}, 
        {"log-level", 1, (int *)0, 'l'}, 
        {"log-dir", 1, (int *)0, 'L'}, 
        {"communication-method", 1, (int *)0, 'c'}, 
        {"socket-path", 1, (int *)0, 'S'}, 
        {"port", 1, (int *)0, 'p'}, 
        {"pid-file\251", 1, (int *)0, 'P'}, 
        {"config-dir", 1, (int *)0, 'C'}, 
        {"version", 0, (int *)0, 'v'}, 
        {"debug", 0, (int *)0, 'D'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"timeout", 1, (int *)0, 't'}, 
        {"module-dir", 1, (int *)0, 'm'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 56 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
static char const   * const  spd_short_options  =    "dsal:L:c:S:p:P:C:t:vDhm:\220";
#line 58 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
void options_print_help(char *argv[] ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 63
  __cil_tmp4 = dcgettext((char const   *)((void *)0), "%s -- Common interface for Speech Synthesis %s\n\n\251",
                         5);
#line 63
  printf((char const   *)__cil_tmp4, "Speech Dispatcher", "(GNU GPL)");
#line 65
  __cil_tmp5 = dcgettext((char const   *)((void *)0), "Usage: ", 5);
#line 65
  printf((char const   *)__cil_tmp5);
#line 66
  printf("%s [-{d|s}] [-l {1|2|3|4|5}] [-c com_method] [-S socket_path] [-p port] [-t timeout] | [-v] | [-h]\n\n",
         argv[0]);
#line 69
  __cil_tmp6 = dcgettext((char const   *)((void *)0), "Options: \n", 5);
#line 69
  printf((char const   *)__cil_tmp6);
#line 70
  printf("  -d, --run-daemon      \220");
#line 71
  __cil_tmp7 = dcgettext((char const   *)((void *)0), "Run as a daemon\n\251", 5);
#line 71
  printf((char const   *)__cil_tmp7);
#line 72
  printf("  -s, --run-single      \220");
#line 73
  __cil_tmp8 = dcgettext((char const   *)((void *)0), "Run as single application\n",
                         5);
#line 73
  printf((char const   *)__cil_tmp8);
#line 74
  printf("  -a, --spawn           \220");
#line 75
  __cil_tmp9 = dcgettext((char const   *)((void *)0), "Start only if autospawn is not disabled\n\251",
                         5);
#line 75
  printf((char const   *)__cil_tmp9);
#line 76
  printf("  -l, --log-level       \220");
#line 77
  __cil_tmp10 = dcgettext((char const   *)((void *)0), "Set log level (between %d and %d)\n",
                          5);
#line 77
  printf((char const   *)__cil_tmp10, 1, 5);
#line 78
  printf("  -L, --log-dir         \220");
#line 79
  __cil_tmp11 = dcgettext((char const   *)((void *)0), "Set path to logging\n", 5);
#line 79
  printf((char const   *)__cil_tmp11);
#line 80
  printf("  -c, --communication-method\n");
#line 81
  printf("                        \220");
#line 82
  __cil_tmp12 = dcgettext((char const   *)((void *)0), "Communication method to use (\'%s\'\n",
                          5);
#line 82
  printf((char const   *)__cil_tmp12, "unix_socket");
#line 83
  printf("                        \220");
#line 84
  __cil_tmp13 = dcgettext((char const   *)((void *)0), "or \'%s\')\n", 5);
#line 84
  printf((char const   *)__cil_tmp13, "inet_socket");
#line 85
  printf("  -S, --socket-path     \220");
#line 86
  __cil_tmp14 = dcgettext((char const   *)((void *)0), "Socket path to use for \'%s\' method\n",
                          5);
#line 86
  printf((char const   *)__cil_tmp14, "unix_socket");
#line 88
  printf("                        \220");
#line 89
  __cil_tmp15 = dcgettext((char const   *)((void *)0), "(filesystem path or \'%s\')\n",
                          5);
#line 89
  printf((char const   *)__cil_tmp15, "default");
#line 90
  printf("  -p, --port            \220");
#line 91
  __cil_tmp16 = dcgettext((char const   *)((void *)0), "Specify a port number for \'%s\' method\n",
                          5);
#line 91
  printf((char const   *)__cil_tmp16, "inet_socket");
#line 92
  printf("  -t, --timeout         \220");
#line 93
  __cil_tmp17 = dcgettext((char const   *)((void *)0), "Set time in seconds for the server to wait before it\n",
                          5);
#line 93
  printf((char const   *)__cil_tmp17);
#line 94
  printf("                        \220");
#line 95
  __cil_tmp18 = dcgettext((char const   *)((void *)0), "shuts down, if it has no clients connected. Setting to\n",
                          5);
#line 95
  printf((char const   *)__cil_tmp18);
#line 96
  printf("                        \220");
#line 97
  __cil_tmp19 = dcgettext((char const   *)((void *)0), "0 disables such shutdown\n",
                          5);
#line 97
  printf((char const   *)__cil_tmp19);
#line 98
  printf("  -P, --pid-file        \220");
#line 99
  __cil_tmp20 = dcgettext((char const   *)((void *)0), "Set path to pid file\n", 5);
#line 99
  printf((char const   *)__cil_tmp20);
#line 100
  printf("  -C, --config-dir      \220");
#line 101
  __cil_tmp21 = dcgettext((char const   *)((void *)0), "Set path to configuration\n",
                          5);
#line 101
  printf((char const   *)__cil_tmp21);
#line 102
  printf("  -m, --module-dir      \220");
#line 103
  __cil_tmp22 = dcgettext((char const   *)((void *)0), "Set path to modules\n", 5);
#line 103
  printf((char const   *)__cil_tmp22);
#line 104
  printf("  -v, --version         \220");
#line 105
  __cil_tmp23 = dcgettext((char const   *)((void *)0), "Report version of this program\n",
                          5);
#line 105
  printf((char const   *)__cil_tmp23);
#line 106
  printf("  -D, --debug           \220");
#line 107
  __cil_tmp24 = dcgettext((char const   *)((void *)0), "Output debugging information into $TMPDIR/%s\n",
                          5);
#line 107
  printf((char const   *)__cil_tmp24, "speechd-debug");
#line 109
  printf("                        \220");
#line 110
  __cil_tmp25 = dcgettext((char const   *)((void *)0), "if TMPDIR is exported, otherwise to /tmp/%s\n",
                          5);
#line 110
  printf((char const   *)__cil_tmp25, "speechd-debug");
#line 112
  printf("  -h, --help            \220");
#line 113
  __cil_tmp26 = dcgettext((char const   *)((void *)0), "Print this info\n\251", 5);
#line 113
  printf((char const   *)__cil_tmp26);
#line 114
  printf("\n");
#line 115
  __cil_tmp27 = dcgettext((char const   *)((void *)0), "Please report bugs to %s\n\n",
                          5);
#line 115
  printf((char const   *)__cil_tmp27, "speechd-discuss@nongnu.org");
  }
  return;
}
}
#line 118 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
void options_print_version(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 120
  printf("%s %s\n", "speech-dispatcher", "0.11.1-dirty");
#line 121
  __cil_tmp1 = dcgettext((char const   *)((void *)0), "Copyright (C) %d-%d Brailcom, o.p.s.\nThis is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2, or (at your option)\nany later version. Please see COPYING for more details.\n\n",
                         5);
#line 121
  printf((char const   *)__cil_tmp1, 2002, 2012);
  }
  return;
}
}
#line 138 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/options.c"
void options_parse(int argc , char *argv[] ) 
{ 
  char *tail_ptr ;
  int c_opt ;
  int option_index ;
  int val ;
  int ret ;
  char *tmpdir ;
  char *debug_logfile_path ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp12 ;
  long __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  gchar *__cil_tmp16 ;
  long __cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  char *__cil_tmp21 ;
  gchar *__cil_tmp22 ;
  gchar *__cil_tmp23 ;
  gchar *__cil_tmp24 ;
  int __cil_tmp25 ;
  int *__cil_tmp26 ;
  int *__cil_tmp27 ;
  char *__cil_tmp28 ;
  int *__cil_tmp29 ;
  gchar *__cil_tmp30 ;
  FILE *__cil_tmp31 ;
  int *__cil_tmp32 ;
  int *__cil_tmp33 ;
  char *__cil_tmp34 ;
  long __cil_tmp35 ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    option_index = 0;
#line 155
    c_opt = getopt_long(argc, (char * const  *)argv, spd_short_options, (struct option *)spd_long_options,
                        & option_index);
    }
#line 158
    if (c_opt == -1) {
#line 159
      goto while_break;
    }
    {
#line 161
    if (c_opt == 'd') {
#line 161
      goto case_100;
    }
#line 164
    if (c_opt == 's') {
#line 164
      goto case_115;
    }
#line 167
    if (c_opt == 'l') {
#line 167
      goto case_108;
    }
#line 170
    if (c_opt == 'L') {
#line 170
      goto case_76;
    }
#line 174
    if (c_opt == 'c') {
#line 174
      goto case_99;
    }
#line 178
    if (c_opt == 'S') {
#line 178
      goto case_83;
    }
#line 182
    if (c_opt == 'p') {
#line 182
      goto case_112;
    }
#line 185
    if (c_opt == 'a') {
#line 185
      goto case_97;
    }
#line 188
    if (c_opt == 'P') {
#line 188
      goto case_80;
    }
#line 191
    if (c_opt == 'C') {
#line 191
      goto case_67;
    }
#line 194
    if (c_opt == 'm') {
#line 194
      goto case_109;
    }
#line 197
    if (c_opt == 'v') {
#line 197
      goto case_118;
    }
#line 201
    if (c_opt == 'D') {
#line 201
      goto case_68;
    }
#line 237
    if (c_opt == 'h') {
#line 237
      goto case_104;
    }
#line 241
    if (c_opt == 't') {
#line 241
      goto case_116;
    }
#line 244
    goto switch_default;
    case_100: /* CIL Label */ 
#line 162
    spd_mode = (TSpeechDMode )0;
#line 163
    goto switch_break;
    case_115: /* CIL Label */ 
#line 165
    spd_mode = (TSpeechDMode )1;
#line 166
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 168
    __cil_tmp13 = strtol((char const   *)optarg, & tail_ptr, 10);
#line 168
    val = (int )__cil_tmp13;
    }
#line 168
    if (tail_ptr != optarg) {
#line 168
      SpeechdOptions.log_level_set = 1;
#line 168
      SpeechdOptions.log_level = val;
    }

#line 169
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 171
    SpeechdOptions.log_dir = g_strdup(optarg);
    }
#line 172
    SpeechdOptions.log_dir_set = 1;
#line 173
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 175
    SpeechdOptions.communication_method = g_strdup(optarg);
    }
#line 176
    SpeechdOptions.communication_method_set = 1;
#line 177
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 179
    SpeechdOptions.socket_path = g_strdup(optarg);
    }
#line 180
    SpeechdOptions.socket_path_set = 1;
#line 181
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 183
    __cil_tmp17 = strtol((char const   *)optarg, & tail_ptr, 10);
#line 183
    val = (int )__cil_tmp17;
    }
#line 183
    if (tail_ptr != optarg) {
#line 183
      SpeechdOptions.port_set = 1;
#line 183
      SpeechdOptions.port = val;
    }

#line 184
    goto switch_break;
    case_97: /* CIL Label */ 
#line 186
    SpeechdOptions.spawn = ! 0;
#line 187
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 189
    SpeechdOptions.pid_file = g_strdup(optarg);
    }
#line 190
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 192
    SpeechdOptions.conf_dir = g_strdup(optarg);
    }
#line 193
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 195
    SpeechdOptions.module_dir = g_strdup(optarg);
    }
#line 196
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 198
    options_print_version();
    }
    {
#line 199
    exit(0);
    }
#line 200
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 202
    __cil_tmp21 = getenv("TMPDIR");
#line 202
    __cil_tmp22 = g_strdup(__cil_tmp21);
#line 202
    tmpdir = __cil_tmp22;
    }
#line 203
    if (! tmpdir) {
      {
#line 204
      tmpdir = g_strdup((gchar *)"/tmp");
      }
    }
    {
#line 205
    SpeechdOptions.debug_destination = g_strdup_printf((gchar *)"%s/speechd-debug\230\001",
                                                       tmpdir);
#line 207
    g_free(tmpdir);
#line 209
    ret = mkdir((char const   *)SpeechdOptions.debug_destination, (__mode_t )448);
    }
#line 210
    if (ret) {
      {
#line 211
      __cil_tmp26 = __errno_location();
      }
      {
#line 211
      __cil_tmp27 = __errno_location();
#line 211
      __cil_tmp28 = strerror(*__cil_tmp27);
#line 211
      MSG(1, "Can\'t create additional debug destination in %s, reason %d-%s", SpeechdOptions.debug_destination,
          *__cil_tmp26, __cil_tmp28);
#line 215
      __cil_tmp29 = __errno_location();
      }
#line 215
      if (*__cil_tmp29 == 17) {
        {
#line 216
        MSG(1, "Debugging directory %s already exists, please delete it first", SpeechdOptions.debug_destination);
        }
      }
      {
#line 220
      exit(1);
      }
    }
    {
#line 223
    debug_logfile_path = g_strdup_printf((gchar *)"%s/speech-dispatcher.log\230\001",
                                         SpeechdOptions.debug_destination);
#line 227
    debug_logfile = fopen((char const   *)debug_logfile_path, "wx");
#line 228
    g_free(debug_logfile_path);
    }
#line 229
    if (debug_logfile == (void *)0) {
      {
#line 230
      __cil_tmp32 = __errno_location();
      }
      {
#line 230
      __cil_tmp33 = __errno_location();
#line 230
      __cil_tmp34 = strerror(*__cil_tmp33);
#line 230
      MSG(1, "Error: can\'t open additional debug logging file %s [%d-%s]!\n", debug_logfile_path,
          *__cil_tmp32, __cil_tmp34);
#line 233
      exit(1);
      }
    }
#line 235
    SpeechdOptions.debug = 1;
#line 236
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 238
    options_print_help(argv);
    }
    {
#line 239
    exit(0);
    }
#line 240
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 242
    __cil_tmp35 = strtol((char const   *)optarg, & tail_ptr, 10);
#line 242
    val = (int )__cil_tmp35;
    }
#line 242
    if (tail_ptr != optarg) {
#line 242
      SpeechdOptions.server_timeout_set = 1;
#line 242
      SpeechdOptions.server_timeout = val;
    }

#line 243
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 245
    MSG(2, "Unrecognized option\n");
    }
    {
#line 246
    options_print_help(argv);
#line 247
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 54 "/usr/include/x86_64-linux-gnu/sys/poll.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 64
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
extern int __poll_alias(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 28
extern int __poll_chk(struct pollfd *__fds , nfds_t __nfds , int __timeout , unsigned long __fdslen ) ;
#line 31
extern int __poll_chk_warn(struct pollfd *__fds , nfds_t __nfds , int __timeout ,
                           unsigned long __fdslen ) ;
#line 37
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  __cil_tmp7 = __builtin_object_size(__fds, 1);
  }
  {
#line 39
  __cil_tmp5 = __builtin_object_size(__fds, 1);
#line 39
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp5 / sizeof(*__fds));
  }
  {
#line 39
  __cil_tmp4 = __builtin_constant_p(__nfds);
  }
#line 39
  if (__cil_tmp6 && (unsigned long )__nfds <= __cil_tmp7 / sizeof(*__fds)) {
    {
#line 39
    __cil_tmp8 = __poll_alias(__fds, __nfds, __timeout);
#line 39
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 39
    __cil_tmp12 = __builtin_object_size(__fds, 1);
    }
    {
#line 39
    __cil_tmp10 = __builtin_object_size(__fds, 1);
#line 39
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp10 / sizeof(*__fds));
    }
    {
#line 39
    __cil_tmp9 = __builtin_constant_p(__nfds);
    }
#line 39
    if (__cil_tmp11 && ! ((unsigned long )__nfds <= __cil_tmp12 / sizeof(*__fds))) {
      {
#line 39
      __cil_tmp13 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp14 = __poll_chk_warn(__fds, __nfds, __timeout, __cil_tmp13);
#line 39
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 39
      __cil_tmp15 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp16 = __poll_chk(__fds, __nfds, __timeout, __cil_tmp15);
#line 39
      tmp = __cil_tmp16;
      }
    }
#line 39
    tmp___0 = tmp;
  }
#line 39
  return (tmp___0);
}
}
#line 46
extern int __ppoll_alias(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                         __sigset_t *__ss ) ;
#line 49
extern int __ppoll_chk(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                       __sigset_t *__ss , unsigned long __fdslen ) ;
#line 53
extern int __ppoll_chk_warn(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                            __sigset_t *__ss , unsigned long __fdslen ) ;
#line 61
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__fds, 1);
  }
  {
#line 64
  __cil_tmp6 = __builtin_object_size(__fds, 1);
#line 64
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp6 / sizeof(*__fds));
  }
  {
#line 64
  __cil_tmp5 = __builtin_constant_p(__nfds);
  }
#line 64
  if (__cil_tmp7 && (unsigned long )__nfds <= __cil_tmp8 / sizeof(*__fds)) {
    {
#line 64
    __cil_tmp9 = __ppoll_alias(__fds, __nfds, __timeout, __ss);
#line 64
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 64
    __cil_tmp13 = __builtin_object_size(__fds, 1);
    }
    {
#line 64
    __cil_tmp11 = __builtin_object_size(__fds, 1);
#line 64
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp11 / sizeof(*__fds));
    }
    {
#line 64
    __cil_tmp10 = __builtin_constant_p(__nfds);
    }
#line 64
    if (__cil_tmp12 && ! ((unsigned long )__nfds <= __cil_tmp13 / sizeof(*__fds))) {
      {
#line 64
      __cil_tmp14 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp15 = __ppoll_chk_warn(__fds, __nfds, __timeout, __ss, __cil_tmp14);
#line 64
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 64
      __cil_tmp16 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp17 = __ppoll_chk(__fds, __nfds, __timeout, __ss, __cil_tmp16);
#line 64
      tmp = __cil_tmp17;
      }
    }
#line 64
    tmp___0 = tmp;
  }
#line 64
  return (tmp___0);
}
}
#line 27 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.h"
int serve(int fd ) ;
#line 30
void server_data_on(int fd ) ;
#line 31
void server_data_off(int fd ) ;
#line 34
int queue_message(TSpeechDMessage *new , int fd , int history_flag , SPDMessageType type ,
                  int reparted ) ;
#line 28 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.h"
char *history_get_client_list(void) ;
#line 29
char *history_get_message_list(guint client_id , int from , int num ) ;
#line 30
char *history_get_last(int fd ) ;
#line 31
char *history_cursor_set_last(int fd , guint client_id ) ;
#line 32
char *history_cursor_set_first(int fd , guint client_id ) ;
#line 33
char *history_cursor_set_pos(int fd , guint client_id , int pos ) ;
#line 34
char *history_cursor_next(int fd ) ;
#line 35
char *history_cursor_prev(int fd ) ;
#line 36
char *history_cursor_get(int fd ) ;
#line 37
char *history_cursor_forward(int fd ) ;
#line 38
char *history_cursor_backward(int fd ) ;
#line 39
char *history_say_id(int fd , int id ) ;
#line 40
char *history_get_client_id(int fd ) ;
#line 41
char *history_get_message(int uid ) ;
#line 42
int history_add_message(TSpeechDMessage *msg ) ;
#line 45
GList *get_messages_by_client(int uid ) ;
#line 46
gint message_compare_id(gconstpointer element , gconstpointer value ) ;
#line 29 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.h"
TFDSetElement *get_client_settings_by_uid(int uid ) ;
#line 30
TFDSetElement *get_client_settings_by_fd(int fd ) ;
#line 31
void remove_client_settings_by_uid(int uid ) ;
#line 32
int get_client_uid_by_fd(int fd ) ;
#line 34
int set_priority_uid(int uid , SPDPriority priority ) ;
#line 35
int set_language_uid(int uid , char *language ) ;
#line 36
int set_rate_uid(int uid , int rate ) ;
#line 37
int set_pitch_uid(int uid , int pitch ) ;
#line 38
int set_pitch_range_uid(int uid , int pitch_range ) ;
#line 39
int set_volume_uid(int uid , int volume ) ;
#line 40
int set_punct_mode_uid(int uid , int punct ) ;
#line 41
int set_cap_let_recog_uid(int uid , int recog ) ;
#line 42
int set_spelling_uid(int uid , SPDSpelling spelling ) ;
#line 43
int set_output_module_self(int fd , char const   *output_module ) ;
#line 44
int set_voice_uid(int uid , char const   *voice ) ;
#line 45
int set_synthesis_voice_uid(int uid , char const   *synthesis_voice ) ;
#line 46
int set_punctuation_mode_uid(int uid , SPDPunctuation punctuation ) ;
#line 47
int set_capital_letter_recognition_uid(int uid , SPDCapitalLetters recogn ) ;
#line 48
int set_output_module_uid(int uid , char const   *output_module ) ;
#line 49
int set_ssml_mode_uid(int uid , SPDDataMode ssml_mode ) ;
#line 50
int set_symbols_preprocessing_uid(int uid , gboolean symbols_preprocessing ) ;
#line 51
int set_pause_context_uid(int uid , int pause_context ) ;
#line 52
int set_debug_uid(int uid , int debug ) ;
#line 53
int set_debug_destination_uid(int uid , char const   *debug_destination ) ;
#line 55
int set_priority_self(int fd , SPDPriority priority ) ;
#line 56
int set_language_self(int fd , char *language ) ;
#line 57
int set_rate_self(int fd , int rate ) ;
#line 58
int set_pitch_self(int fd , int pitch ) ;
#line 59
int set_pitch_range_self(int fd , int pitch_range ) ;
#line 60
int set_volume_self(int fd , int volume ) ;
#line 61
int set_punct_mode_self(int fd , int punct ) ;
#line 62
int set_cap_let_recog_self(int fd , int recog ) ;
#line 63
int set_spelling_self(int fd , SPDSpelling spelling ) ;
#line 65
int set_client_name_self(int fd , char const   *client_name ) ;
#line 66
int set_voice_self(int fd , char const   *voice ) ;
#line 67
int set_synthesis_voice_self(int fd , char const   *synthesis_voice ) ;
#line 68
int set_punctuation_mode_self(int fd , SPDPunctuation punctuation_mode ) ;
#line 69
int set_capital_letter_recognition_self(int fd , SPDCapitalLetters capital_letter_recognition ) ;
#line 70
int set_ssml_mode_self(int fd , SPDDataMode ssml_mode ) ;
#line 71
int set_symbols_preprocessing_self(int fd , gboolean symbols_preprocessing ) ;
#line 72
int set_notification_self(int fd , char const   *type , int val ) ;
#line 73
int set_pause_context_self(int fd , int pause_context ) ;
#line 74
int set_debug_self(int fd , int debug ) ;
#line 75
int set_debug_destination_self(int fd , char const   *debug_destination ) ;
#line 77
int set_priority_all(SPDPriority priority ) ;
#line 78
int set_language_all(char *language ) ;
#line 79
int set_rate_all(int rate ) ;
#line 80
int set_pitch_all(int pitch ) ;
#line 81
int set_pitch_range_all(int pitch_range ) ;
#line 82
int set_volume_all(int volume ) ;
#line 83
int set_punct_mode_all(int punct ) ;
#line 84
int set_cap_let_recog_all(int recog ) ;
#line 85
int set_spelling_all(SPDSpelling spelling ) ;
#line 86
int set_output_module_all(char const   *output_module ) ;
#line 87
int set_voice_all(char const   *voice ) ;
#line 88
int set_synthesis_voice_all(char const   *synthesis_voice ) ;
#line 89
int set_punctuation_mode_all(SPDPunctuation punctuation_mode ) ;
#line 90
int set_capital_letter_recognition_all(SPDCapitalLetters capital_letter_recognition ) ;
#line 91
int set_ssml_mode_all(SPDDataMode ssml_mode ) ;
#line 92
int set_symbols_preprocessing_all(gboolean symbols_preprocessing ) ;
#line 93
int set_pause_context_all(int pause_context ) ;
#line 94
int set_debug_all(int debug ) ;
#line 95
int set_debug_destination_all(char const   *debug_destination ) ;
#line 97
TFDSetElement *default_fd_set(void) ;
#line 99
char *set_param_str(char *parameter , char const   *value ) ;
#line 101
void update_cl_settings(gpointer data , gpointer user_data ) ;
#line 103
gint spd_str_compare(gconstpointer a , gconstpointer b ) ;
#line 43 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
TSpeechDMessage *current_message  =    (TSpeechDMessage *)((void *)0);
#line 44 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
static SPDPriority highest_priority  =    (SPDPriority )0;
#line 46 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int SPEAKING  =    0;
#line 47
int poll_count ;
#line 65 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void *speak(void *data ) 
{ 
  TSpeechDMessage *message ;
  int ret ;
  struct pollfd poll_fds[2] ;
  int revents ;
  OutputModule *output ;
  int __cil_tmp7 ;
  char buf[1] ;
  ssize_t rd_bytes ;
  GList *gl ;
  guint __cil_tmp11 ;
  GList *__cil_tmp12 ;
  GList *__cil_tmp13 ;
  guint __cil_tmp14 ;
  guint __cil_tmp15 ;
  guint __cil_tmp16 ;
  GList *item ;
  GList *__cil_tmp18 ;
  GList *__cil_tmp19 ;
  GList *__cil_tmp20 ;
  int tmp ;
  TSpeechDMessage *__cil_tmp22 ;
  gint __cil_tmp23 ;
  GList *__cil_tmp24 ;
  OutputModule *__cil_tmp25 ;
  int punct_missing ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  gchar *normalized ;
  gchar *__cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  TFDSetElement *__cil_tmp38 ;
  int __cil_tmp39 ;
  GList *elem ;
  TSpeechDMessage *p5_message ;
  GList *__cil_tmp42 ;

  {
  {
#line 67
  message = (TSpeechDMessage *)((void *)0);
#line 74
  set_speaking_thread_parameters();
#line 77
  poll_fds[0].fd = speaking_pipe[0];
#line 78
  poll_fds[0].events = (short )1;
#line 79
  poll_fds[0].revents = (short )0;
#line 82
  poll_fds[1].fd = - 1;
#line 83
  poll_fds[1].events = (short )1;
#line 84
  poll_fds[1].revents = (short )0;
#line 86
  poll_count = 1;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 89
    ret = poll((struct pollfd *)poll_fds, (nfds_t )poll_count, - 1);
#line 90
    MSG(5, "Poll in speak() returned socket activity, main_pfd revents=%d, poll_pfd revents=%d",
        (int )poll_fds[0].revents, (int )poll_fds[1].revents);
#line 93
    revents = (int )poll_fds[0].revents;
    }
#line 93
    if (revents) {
#line 94
      if (revents & 1) {
        {
#line 96
        MSG(5, "wait_for_poll: activity in Speech Dispatcher");
#line 98
        rd_bytes = 0;
        }
#line 100
        if (rd_bytes != 1L) {
          {
#line 101
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 101
            fatal_error();
#line 101
            MSG(- 1, "Fatal error [%s:%d]:read from polled fd: could not read 1 byte",
                "./src/server/speaking.c", 101);
#line 101
            exit(1);
            }
#line 101
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 105
    if (poll_count > 1) {
#line 106
      revents = (int )poll_fds[1].revents;
#line 106
      if (revents) {
#line 107
        if (revents & 16) {
          {
#line 109
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 109
            fatal_error();
#line 109
            MSG(- 1, "Fatal error [%s:%d]:wait_for_poll: output_module disconnected",
                "./src/server/speaking.c", 109);
#line 109
            exit(1);
            }
#line 109
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else
#line 111
        if (revents & 1) {
          {
          {
#line 113
          MSG(5, "wait_for_poll: activity on output_module: %d", (int )poll_fds[1].revents);
          }
          {
#line 118
          is_sb_speaking();
          }
          }
        } else
#line 111
        if (revents & 2) {
          {
          {
#line 113
          MSG(5, "wait_for_poll: activity on output_module: %d", (int )poll_fds[1].revents);
          }
          {
#line 118
          is_sb_speaking();
          }
          }
        }
      }
    }
#line 124
    if (pause_requested) {
      {
#line 125
      MSG(4, "Trying to pause...");
      }
#line 126
      if (pause_requested == 1) {
        {
#line 127
        speaking_pause_all(pause_requested_fd);
        }
      }
#line 128
      if (pause_requested == 2) {
        {
#line 129
        speaking_pause(pause_requested_fd, pause_requested_uid);
        }
      }
      {
#line 131
      MSG(4, "Paused...");
#line 132
      pause_requested = 0;
      }
#line 133
      goto while_continue;
    }
#line 136
    if (SPEAKING) {
      {
#line 137
      MSG(5, "Continuing because already speaking in speak()");
      }
#line 139
      goto while_continue;
    }
#line 143
    if (resume_requested) {
      {
#line 146
      MSG(5, "Resume requested\220");
#line 149
      __cil_tmp11 = g_list_length(MessagePausedList);
      }
#line 149
      if (__cil_tmp11 != 0U) {
        {
#line 150
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 151
          pthread_mutex_lock(& element_free_mutex);
#line 152
          gl = g_list_find_custom(MessagePausedList, (void *)((void *)0), & message_nto_speak);
#line 155
          MSG(5, "Message insterted back to the queues!");
#line 157
          MessagePausedList = g_list_remove_link(MessagePausedList, gl);
#line 160
          pthread_mutex_unlock(& element_free_mutex);
          }
#line 162
          if (gl != (void *)0) {
#line 162
            if (gl->data != (void *)0) {
              {
#line 163
              MSG(5, "Reloading message");
#line 164
              reload_message((TSpeechDMessage *)gl->data);
              }
#line 171
              if (current_message == gl->data) {
#line 172
                current_message = (TSpeechDMessage *)((void *)0);
              }
            } else {
#line 174
              goto while_break___2;
            }
          } else {
#line 174
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 177
      MSG(5, "End of resume processing\220");
#line 178
      resume_requested = 0;
      }
    }
    {
#line 181
    MSG(5, "Locking element_free_mutex in speak()");
#line 182
    pthread_mutex_lock(& element_free_mutex);
#line 184
    check_locked(& element_free_mutex);
#line 185
    __cil_tmp15 = g_list_length(MessageQueue->p5);
    }
    {
#line 185
    __cil_tmp14 = g_list_length(last_p5_block);
    }
#line 185
    if (__cil_tmp14 != 0U) {
#line 185
      if (__cil_tmp15 == 0U) {
        {
#line 188
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 188
          __cil_tmp16 = g_list_length(last_p5_block);
          }
#line 188
          if (! (__cil_tmp16 != 0U)) {
#line 188
            goto while_break___3;
          }
          {
#line 190
          item = g_list_first(last_p5_block);
#line 191
          message = item->data;
#line 192
          check_locked(& element_free_mutex);
#line 193
          MessageQueue->p2 = g_list_insert_sorted(MessageQueue->p2, message, & sortbyuid);
#line 196
          last_p5_block = g_list_remove_link(last_p5_block, item);
#line 198
          g_list_free_1(item);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 201
        highest_priority = (SPDPriority )2;
#line 202
        stop_priority_older_than((SPDPriority )3, message->id);
#line 203
        stop_priority((SPDPriority )4);
#line 204
        stop_priority((SPDPriority )5);
#line 205
        check_locked(& element_free_mutex);
#line 206
        pthread_mutex_unlock(& element_free_mutex);
#line 207
        speaking_semaphore_post();
        }
#line 208
        goto while_continue;
      } else {
#line 185
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 211
      message = get_message_from_queues();
      }
#line 212
      if (message == (void *)0) {
        {
#line 213
        pthread_mutex_unlock(& element_free_mutex);
#line 214
        MSG(5, "No message in the queue");
        }
#line 215
        goto while_continue;
      }
    }
    {
#line 221
    __cil_tmp23 = message_nto_speak(message, (void *)0);
    }
#line 221
    if (__cil_tmp23) {
      {
#line 222
      MSG(4, "Inserting message to paused list...");
#line 223
      MessagePausedList = g_list_append(MessagePausedList, message);
#line 225
      pthread_mutex_unlock(& element_free_mutex);
      }
#line 226
      goto while_continue;
    }
    {
#line 230
    output = get_output_module(message);
    }
#line 231
    if (output == (void *)0) {
      {
#line 232
      MSG(3, "Output module doesn\'t work...");
#line 233
      output_check_module(output);
#line 234
      pthread_mutex_unlock(& element_free_mutex);
      }
#line 235
      goto while_continue;
    }
    {
#line 238
    punct_missing = 0;
#line 239
    __cil_tmp33 = strcmp((char const   *)output->name, "pico");
    }
    {
#line 239
    __cil_tmp32 = strcmp((char const   *)output->name, "swift-generic");
    }
    {
#line 239
    __cil_tmp31 = strcmp((char const   *)output->name, "mary-generic");
    }
    {
#line 239
    __cil_tmp30 = strcmp((char const   *)output->name, "llia_phon-generic");
    }
    {
#line 239
    __cil_tmp29 = strcmp((char const   *)output->name, "epos-generic");
    }
    {
#line 239
    __cil_tmp28 = strcmp((char const   *)output->name, "dtk-generic");
    }
    {
#line 239
    __cil_tmp27 = strcmp((char const   *)output->name, "flite");
    }
#line 239
    if (__cil_tmp27 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp28 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp29 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp30 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp31 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp32 == 0) {
#line 248
      punct_missing = 1;
    } else
#line 239
    if (__cil_tmp33 == 0) {
#line 248
      punct_missing = 1;
    }
#line 250
    if ((unsigned int )message->settings.type == 0U) {
      _L___12: /* CIL Label */ 
      {
#line 252
      __cil_tmp35 = g_utf8_normalize(message->buf, (gssize )(- 1), (GNormalizeMode )3);
#line 252
      normalized = __cil_tmp35;
      }
#line 254
      if (! normalized) {
        {
#line 255
        MSG(2, "Error: Not UTF-8 valid");
#line 256
        pthread_mutex_unlock(& element_free_mutex);
        }
#line 257
        goto while_continue;
      }
      {
#line 259
      __cil_tmp36 = strcmp((char const   *)message->buf, (char const   *)normalized);
      }
#line 259
      if (__cil_tmp36) {
        {
#line 260
        MSG(5, "text: Normalized \'%s\' to \'%s\'", message->buf, normalized);
        }
      }
      {
#line 262
      g_free(message->buf);
#line 263
      message->buf = normalized;
#line 264
      insert_symbols(message, punct_missing);
      }
    } else
#line 250
    if ((unsigned int )message->settings.type == 2U) {
#line 250
      goto _L___12;
    }
#line 268
    if ((unsigned int )message->settings.type == 0U) {
      {
#line 269
      insert_index_marks(message, message->settings.ssml_mode);
      }
    }
    {
#line 274
    ret = output_speak(message, output);
#line 276
    MSG(4, "Message sent to output module");
    }
#line 277
    if (ret == -1) {
      {
#line 278
      MSG(2, "Error: Output module failed");
#line 279
      output_check_module(output);
#line 280
      pthread_mutex_unlock(& element_free_mutex);
      }
#line 281
      goto while_continue;
    }
#line 283
    if (ret != 0) {
      {
#line 284
      MSG(2, "ERROR: Can\'t say message. Module reported error in speaking: %d", ret);
#line 287
      pthread_mutex_unlock(& element_free_mutex);
      }
#line 288
      goto while_continue;
    }
#line 290
    SPEAKING = 1;
#line 292
    if (speaking_module != (void *)0) {
#line 293
      poll_fds[1].fd = speaking_module->pipe_speak[0];
#line 294
      poll_count = 2;
    }
#line 298
    speaking_uid = (int )message->settings.uid;
#line 299
    if (current_message != (void *)0) {
#line 300
      if (! current_message->settings.paused_while_speaking) {
#line 304
        if (__cil_tmp38->active == 0) {
          {
#line 307
          __cil_tmp39 = client_has_messages((int )current_message->settings.uid);
          }
#line 307
          if (! __cil_tmp39) {
#line 307
            if (current_message->settings.uid != message->settings.uid) {
              {
#line 316
              MSG(4, "Removing client settings for uid %d", current_message->settings.uid);
#line 320
              remove_client_settings_by_uid((int )current_message->settings.uid);
              }
            }
          }
        }
        {
#line 325
        mem_free_message(current_message);
        }
      }
    }
#line 328
    current_message = message;
#line 331
    if (last_p5_block != (void *)0) {
      {
#line 334
      elem = g_list_last(last_p5_block);
      }
#line 335
      if (elem != (void *)0) {
#line 336
        p5_message = (TSpeechDMessage *)elem->data;
#line 337
        if (p5_message->settings.reparted == message->settings.reparted) {
          {
#line 339
          g_list_foreach(last_p5_block, (GFunc )(& mem_free_message), (void *)0);
#line 342
          g_list_free(last_p5_block);
#line 343
          last_p5_block = (GList *)((void *)0);
          }
        }
      }
    }
    {
#line 348
    pthread_mutex_unlock(& element_free_mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 352 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int reload_message(TSpeechDMessage *msg ) 
{ 
  TFDSetElement *client_settings ;
  int im ;
  char *pos ;
  char *newtext ;
  char *tptr ;
  TFDSetElement *__cil_tmp7 ;
  long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 360
  if (msg == (void *)0) {
    {
#line 361
    MSG(4, "Warning: msg == NULL in reload_message()\220");
    }
#line 362
    return (- 1);
  }
#line 365
  if (msg->settings.index_mark != (void *)0) {
    {
#line 366
    MSG(5, "Recovering index mark %s\230\001", msg->settings.index_mark);
#line 367
    client_settings = get_client_settings_by_uid((int )msg->settings.uid);
#line 370
    MSG(5, "Recovering index mark (number)");
#line 371
    __cil_tmp8 = strtol((char const   *)(msg->settings.index_mark + 6), & tptr, 10);
#line 371
    im = (int )__cil_tmp8;
#line 373
    MSG(5, "Recovering index mark (comparing tptr)");
    }
#line 374
    if (msg->settings.index_mark + 6 == tptr) {
      {
#line 375
      MSG2(2, "index_markingU", "ERROR: Invalid index_mark \'%s\'. Message not reloaded.",
           msg->settings.index_mark);
      }
#line 378
      return (- 1);
    }
    {
#line 380
    MSG(5, "Recovered index mark number: %d", im);
#line 382
    im += client_settings->pause_context;
#line 384
    MSG2(5, "index_markingU", "Requested index mark (with context) is %d (%s+%d)\331\356}\332U",
         im, msg->settings.index_mark, client_settings->pause_context);
    }
#line 387
    if (im < 0) {
#line 388
      im = 0;
#line 389
      pos = msg->buf;
    } else {
      {
#line 391
      pos = find_index_mark(msg, im);
      }
#line 392
      if (pos == (void *)0) {
#line 393
        return (- 1);
      }
    }
    {
#line 396
    newtext = strip_index_marks((char const   *)pos, client_settings->ssml_mode);
#line 397
    g_free(msg->buf);
    }
#line 399
    if (newtext == (void *)0) {
#line 400
      return (- 1);
    }
    {
#line 401
    msg->buf = newtext;
#line 402
    __cil_tmp11 = strlen((char const   *)msg->buf);
#line 402
    msg->bytes = (int )__cil_tmp11;
#line 404
    __cil_tmp12 = queue_message(msg, (int )(- msg->settings.uid), 0, (SPDMessageType )0,
                                0);
    }
#line 404
    if (__cil_tmp12 == 0) {
#line 406
      if (0) {
        {
#line 407
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 407
          fatal_error();
#line 407
          MSG(- 1, "Fatal error [%s:%d]:Can\'t queue message\n", "./src/server/speaking.c",
              407);
#line 407
          exit(1);
          }
#line 407
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 408
      g_free(msg->buf);
#line 409
      g_free(msg);
      }
#line 410
      return (- 1);
    }
#line 413
    return (0);
  } else {
    {
#line 415
    MSG(5, "Index mark unknown, inserting the whole message.\220");
#line 417
    __cil_tmp13 = queue_message(msg, (int )(- msg->settings.uid), 0, (SPDMessageType )0,
                                0);
    }
#line 417
    if (__cil_tmp13 == 0) {
#line 419
      if (0) {
        {
#line 420
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 420
          fatal_error();
#line 420
          MSG(- 1, "Fatal error [%s:%d]:Can\'t queue message\n", "./src/server/speaking.c",
              420);
#line 420
          exit(1);
          }
#line 420
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 421
      g_free(msg->buf);
#line 422
      g_free(msg);
      }
#line 423
      return (- 1);
    }
#line 426
    return (0);
  }
#line 428
  return (0);
}
}
#line 431 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void speaking_stop(int uid ) 
{ 
  TSpeechDMessage *msg ;
  GList *gl ;
  GList *queue ;
  int gid ;
  int __cil_tmp6 ;
  GList *__cil_tmp7 ;
  GList *__cil_tmp8 ;
  GList *__cil_tmp9 ;
  GList *__cil_tmp10 ;
  int tmp ;

  {
  {
#line 436
  gid = - 1;
#line 439
  __cil_tmp6 = get_speaking_client_uid();
  }
#line 439
  if (__cil_tmp6 == uid) {
    {
#line 440
    output_stop();
#line 443
    queue = speaking_get_queue(highest_priority);
    }
#line 444
    if (queue == (void *)0) {
#line 445
      return;
    }
    {
#line 448
    gl = g_list_last(queue);
    }
#line 449
    if (gl == (void *)0) {
#line 450
      return;
    }
#line 451
    if (gl->data == (void *)0) {
#line 452
      return;
    }
#line 454
    msg = (TSpeechDMessage *)gl->data;
#line 455
    if (msg->settings.reparted != 0) {
#line 455
      if (msg->settings.uid == (unsigned int )uid) {
#line 456
        gid = msg->settings.reparted;
      } else {
#line 458
        return;
      }
    } else {
#line 458
      return;
    }
    {
#line 461
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 462
      gl = g_list_last(queue);
      }
#line 463
      if (gl == (void *)0) {
        {
#line 464
        speaking_set_queue(highest_priority, queue);
        }
#line 465
        return;
      }
#line 467
      if (gl->data == (void *)0) {
#line 468
        return;
      }
#line 470
      msg = (TSpeechDMessage *)gl->data;
#line 472
      if (msg->settings.reparted == gid) {
#line 472
        if (msg->settings.uid == (unsigned int )uid) {
          {
#line 474
          queue = g_list_remove_link(queue, gl);
#line 476
          mem_free_message(gl->data);
          }
        } else {
          {
          {
#line 478
          speaking_set_queue(highest_priority, queue);
          }
          }
#line 479
          return;
        }
      } else {
        {
        {
#line 478
        speaking_set_queue(highest_priority, queue);
        }
        }
#line 479
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 485 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void speaking_stop_all(void) 
{ 
  TSpeechDMessage *msg ;
  GList *gl ;
  GList *queue ;
  GList *__cil_tmp4 ;
  GList *__cil_tmp5 ;
  int tmp ;
  GList *__cil_tmp7 ;
  int tmp___0 ;
  GList *__cil_tmp9 ;
  int tmp___1 ;

  {
  {
#line 491
  output_stop();
#line 493
  queue = speaking_get_queue(highest_priority);
  }
#line 494
  if (queue == (void *)0) {
#line 495
    return;
  }
  {
#line 497
  gl = g_list_last(queue);
  }
#line 498
  if (gl == (void *)0) {
#line 499
    return;
  }
#line 501
  msg = (TSpeechDMessage *)gl->data;
#line 503
  if (msg->settings.reparted == 0) {
#line 504
    return;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    gl = g_list_last(queue);
    }
#line 509
    if (gl == (void *)0) {
      {
#line 510
      speaking_set_queue(highest_priority, queue);
      }
#line 511
      return;
    }
#line 513
    if (0) {

    }
#line 516
    msg = (TSpeechDMessage *)gl->data;
#line 517
    if (msg->settings.reparted == 1) {
      {
#line 518
      queue = g_list_remove_link(queue, gl);
#line 520
      mem_free_message(gl->data);
      }
    } else {
      {
#line 522
      speaking_set_queue(highest_priority, queue);
      }
#line 523
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 528 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void speaking_cancel(int uid ) 
{ 


  {
  {
#line 530
  pthread_mutex_lock(& element_free_mutex);
#line 531
  speaking_stop(uid);
#line 532
  stop_from_uid(uid);
#line 533
  pthread_mutex_unlock(& element_free_mutex);
  }
  return;
}
}
#line 536 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void speaking_cancel_all(void) 
{ 


  {
  {
#line 538
  output_stop();
#line 539
  pthread_mutex_lock(& element_free_mutex);
#line 540
  stop_priority((SPDPriority )1);
#line 541
  stop_priority((SPDPriority )2);
#line 542
  stop_priority((SPDPriority )3);
#line 543
  stop_priority((SPDPriority )4);
#line 544
  stop_priority((SPDPriority )5);
#line 545
  pthread_mutex_unlock(& element_free_mutex);
  }
  return;
}
}
#line 548 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int speaking_pause_all(int fd ) 
{ 
  int err ;
  int i ;
  int uid ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 550
  err = 0;
#line 554
  i = 1;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (i <= SpeechdStatus.max_fd)) {
#line 554
      goto while_break;
    }
    {
#line 555
    uid = get_client_uid_by_fd(i);
    }
#line 556
    if (uid == 0) {
#line 557
      goto while_continue;
    }
    {
#line 558
    __cil_tmp6 = speaking_pause(i, uid);
    }
#line 558
    err += __cil_tmp6;
#line 554
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  if (err > 0) {
#line 562
    return (1);
  } else {
#line 564
    return (0);
  }
}
}
#line 567 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int speaking_pause(int fd , int uid ) 
{ 
  TFDSetElement *settings ;
  int ret ;
  TFDSetElement *__cil_tmp5 ;
  size_t __cil_tmp6 ;
  GList *__cil_tmp7 ;
  GList *__cil_tmp8 ;

  {
  {
#line 572
  MSG(4, "Pause");
#line 575
  settings = get_client_settings_by_uid(uid);
  }
#line 576
  if (settings == (void *)0) {
    {
#line 577
    MSG(4, "ERROR: Can\'t get settings of active client in speaking_pause()!");
    }
#line 579
    return (1);
  }
#line 581
  settings->paused = 1;
#line 583
  if (speaking_uid != uid) {
    {
#line 584
    MSG(5, "given uid %d not speaking_uid %d\230\001", uid, speaking_uid);
    }
#line 585
    return (0);
  }
#line 588
  if (SPEAKING) {
#line 589
    if (current_message == (void *)0) {
      {
#line 590
      MSG(5, "current_message is null");
      }
#line 591
      return (0);
    }
    {
#line 594
    __cil_tmp6 = output_pause();
#line 594
    ret = (int )__cil_tmp6;
    }
#line 595
    if (ret < 0) {
      {
#line 596
      MSG(5, "output_pause returned %d\230\001", ret);
      }
#line 597
      return (0);
    }
    {
#line 600
    MSG(5, "Including current message into the message paused list");
#line 602
    current_message->settings.paused = 2;
#line 603
    current_message->settings.paused_while_speaking = 1;
#line 604
    __cil_tmp7 = g_list_find(MessagePausedList, current_message);
    }
#line 604
    if (__cil_tmp7 == (void *)0) {
      {
#line 605
      MessagePausedList = g_list_append(MessagePausedList, current_message);
      }
    }
  }
#line 609
  return (0);
}
}
#line 612 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int speaking_resume_all(void) 
{ 
  int err ;
  int i ;
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 614
  err = 0;
#line 618
  i = 1;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i <= SpeechdStatus.max_fd)) {
#line 618
      goto while_break;
    }
    {
#line 619
    uid = get_client_uid_by_fd(i);
    }
#line 620
    if (uid == 0) {
#line 621
      goto while_continue;
    }
    {
#line 622
    __cil_tmp5 = speaking_resume(uid);
    }
#line 622
    err += __cil_tmp5;
#line 618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  if (err > 0) {
#line 626
    return (1);
  } else {
#line 628
    return (0);
  }
}
}
#line 631 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int speaking_resume(int uid ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp3 ;

  {
  {
#line 636
  settings = get_client_settings_by_uid(uid);
  }
#line 637
  if (settings == (void *)0) {
#line 638
    return (1);
  }
  {
#line 640
  settings->paused = 0;
#line 642
  resume_requested = 1;
#line 643
  speaking_semaphore_post();
  }
#line 645
  return (0);
}
}
#line 648 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int socket_send_msg(int fd , char const   *msg ) 
{ 
  int ret ;
  int tmp ;
  unsigned long __cil_tmp5 ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 653
  pthread_mutex_lock(& socket_com_mutex);
#line 654
  MSG2(5, "protocol\323\001 ", "%d:REPLY:|%s|", fd, msg);
#line 655
  __cil_tmp5 = strlen(msg);
#line 655
  __cil_tmp6 = write(fd, msg, __cil_tmp5);
#line 655
  ret = (int )__cil_tmp6;
#line 656
  pthread_mutex_unlock(& socket_com_mutex);
  }
#line 657
  if (ret < 0) {
    {
#line 658
    __cil_tmp7 = __errno_location();
#line 658
    __cil_tmp8 = strerror(*__cil_tmp7);
#line 658
    MSG(1, "write() error: %s", __cil_tmp8);
    }
#line 659
    return (- 1);
  }
#line 661
  return (0);
}
}
#line 664 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_index_mark(TSpeechDMessage *msg , char const   *index_mark ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 669
  cmd = g_strdup_printf((gchar *)"700-%d\r\n700-%d\r\n700-%s\r\n700 INDEX MARK\r\n\230\001",
                        msg->id, msg->settings.uid, index_mark);
#line 674
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 675
  if (ret) {
    {
#line 676
    MSG(1, "ERROR: Can\'t report index mark!");
    }
#line 677
    return (- 1);
  }
  {
#line 679
  g_free(cmd);
  }
#line 680
  return (0);
}
}
#line 700 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_begin(TSpeechDMessage *msg ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 700
  cmd = g_strdup_printf((gchar *)"701-%d\r\n701-%d\r\n701 BEGIN\r\n", msg->id, msg->settings.uid);
#line 700
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 700
  if (ret) {
    {
#line 700
    MSG(2, "ERROR: Can\'t report index mark!");
    }
#line 700
    return (- 1);
  }
  {
#line 700
  g_free(cmd);
  }
#line 700
  return (0);
}
}
#line 701 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_end(TSpeechDMessage *msg ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 701
  cmd = g_strdup_printf((gchar *)"702-%d\r\n702-%d\r\n702 END\r\n", msg->id, msg->settings.uid);
#line 701
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 701
  if (ret) {
    {
#line 701
    MSG(2, "ERROR: Can\'t report index mark!");
    }
#line 701
    return (- 1);
  }
  {
#line 701
  g_free(cmd);
  }
#line 701
  return (0);
}
}
#line 702 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_pause(TSpeechDMessage *msg ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 702
  cmd = g_strdup_printf((gchar *)"704-%d\r\n704-%d\r\n704 PAUSED\r\n", msg->id, msg->settings.uid);
#line 702
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 702
  if (ret) {
    {
#line 702
    MSG(2, "ERROR: Can\'t report index mark!");
    }
#line 702
    return (- 1);
  }
  {
#line 702
  g_free(cmd);
  }
#line 702
  return (0);
}
}
#line 703 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_resume(TSpeechDMessage *msg ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 703
  cmd = g_strdup_printf((gchar *)"705-%d\r\n705-%d\r\n705 RESUMED\r\n", msg->id, msg->settings.uid);
#line 703
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 703
  if (ret) {
    {
#line 703
    MSG(2, "ERROR: Can\'t report index mark!");
    }
#line 703
    return (- 1);
  }
  {
#line 703
  g_free(cmd);
  }
#line 703
  return (0);
}
}
#line 704 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int report_cancel(TSpeechDMessage *msg ) 
{ 
  char *cmd ;
  int ret ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 704
  cmd = g_strdup_printf((gchar *)"703-%d\r\n703-%d\r\n703 CANCELED\r\n", msg->id,
                        msg->settings.uid);
#line 704
  ret = socket_send_msg(msg->settings.fd, (char const   *)cmd);
  }
#line 704
  if (ret) {
    {
#line 704
    MSG(2, "ERROR: Can\'t report index mark!");
    }
#line 704
    return (- 1);
  }
  {
#line 704
  g_free(cmd);
  }
#line 704
  return (0);
}
}
#line 706 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int is_sb_speaking(void) 
{ 
  char *index_mark ;
  TFDSetElement *settings ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  gchar *__cil_tmp9 ;

  {
  {
#line 711
  MSG(5, "is_sb_speaking(), SPEAKING=%d", SPEAKING);
  }
#line 714
  if (speaking_module != (void *)0) {
#line 715
    if (current_message == (void *)0) {
      {
#line 716
      MSG(1, "Error: Current message is NULL in is_sb_speaking()");
      }
#line 718
      return (- 1);
    }
    {
#line 720
    settings = & current_message->settings;
#line 722
    output_is_speaking(& index_mark);
    }
#line 723
    if (index_mark == (void *)0) {
#line 724
      poll_count = 1;
#line 725
      SPEAKING = 0;
#line 725
      return (SPEAKING);
    }
    {
#line 728
    __cil_tmp3 = strcmp((char const   *)index_mark, "no");
    }
#line 728
    if (! __cil_tmp3) {
      {
#line 729
      g_free(index_mark);
      }
#line 730
      return (SPEAKING);
    }
    {
#line 733
    MSG(5, "INDEX MARK: %s", index_mark);
#line 735
    __cil_tmp4 = strcmp((char const   *)index_mark, "__spd_begin");
    }
#line 735
    if (! __cil_tmp4) {
#line 736
      SPEAKING = 1;
#line 737
      if (! settings->paused_while_speaking) {
#line 738
        if ((unsigned int )settings->notification & 1U) {
          {
#line 739
          report_begin(current_message);
          }
        }
      } else {
#line 741
        if ((unsigned int )settings->notification & 32U) {
          {
#line 742
          report_resume(current_message);
          }
        }
#line 743
        settings->paused_while_speaking = 0;
      }
    } else {
      {
#line 745
      __cil_tmp5 = strcmp((char const   *)index_mark, "__spd_end");
      }
#line 745
      if (! __cil_tmp5) {
#line 746
        SPEAKING = 0;
#line 747
        poll_count = 1;
#line 748
        if ((unsigned int )settings->notification & 2U) {
          {
#line 749
          report_end(current_message);
          }
        }
        {
#line 750
        speaking_semaphore_post();
        }
      } else {
        {
#line 751
        __cil_tmp6 = strcmp((char const   *)index_mark, "__spd_paused\220");
        }
#line 751
        if (! __cil_tmp6) {
#line 752
          SPEAKING = 0;
#line 753
          poll_count = 1;
#line 754
          if ((unsigned int )settings->notification & 16U) {
            {
#line 755
            report_pause(current_message);
            }
          }
#line 758
          current_message = (TSpeechDMessage *)((void *)0);
        } else {
          {
#line 759
          __cil_tmp7 = strcmp((char const   *)index_mark, "__spd_stopped");
          }
#line 759
          if (! __cil_tmp7) {
#line 760
            SPEAKING = 0;
#line 761
            poll_count = 1;
#line 762
            if ((unsigned int )settings->notification & 8U) {
              {
#line 763
              report_cancel(current_message);
              }
            }
            {
#line 764
            speaking_semaphore_post();
            }
          } else
#line 765
          if (index_mark != (void *)0) {
            {
#line 766
            __cil_tmp8 = strncmp((char const   *)index_mark, "__spd_", (unsigned long )6);
            }
#line 766
            if (__cil_tmp8) {
#line 767
              if ((unsigned int )settings->notification & 4U) {
                {
#line 768
                report_index_mark(current_message, (char const   *)index_mark);
                }
              }
            } else {
              {
#line 771
              MSG(5, "Setting current index_mark for the message to %s\230\001", index_mark);
              }
#line 774
              if (current_message->settings.index_mark != (void *)0) {
                {
#line 776
                g_free(current_message->settings.index_mark);
                }
              }
              {
#line 778
              current_message->settings.index_mark = g_strdup(index_mark);
              }
            }
          }
        }
      }
    }
    {
#line 783
    g_free(index_mark);
    }
  } else {
    {
#line 785
    MSG(5, "Speaking module is NULL, SPEAKING==%d", SPEAKING);
#line 786
    SPEAKING = 0;
    }
  }
#line 789
  if (SPEAKING == 0) {
#line 790
    speaking_module = (OutputModule *)((void *)0);
  }
#line 792
  return (SPEAKING);
}
}
#line 795 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int get_speaking_client_uid(void) 
{ 
  int speaking ;

  {
#line 797
  speaking = 0;
#line 798
  if (SPEAKING == 0) {
#line 799
    speaking_uid = 0;
#line 800
    return (0);
  }
#line 802
  if (speaking_uid != 0) {
#line 803
    speaking = speaking_uid;
  }
#line 805
  return (speaking);
}
}
#line 808 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
GList *queue_remove_message(GList *queue , GList *gl ) 
{ 
  TSpeechDMessage *msg ;
  int tmp ;
  int tmp___0 ;
  GList *__cil_tmp6 ;

  {
#line 813
  msg = (TSpeechDMessage *)gl->data;
#line 814
  if ((unsigned int )msg->settings.notification & 8U) {
    {
#line 815
    report_cancel(msg);
    }
  }
  {
#line 816
  mem_free_message(gl->data);
#line 817
  queue = g_list_delete_link(queue, gl);
  }
#line 818
  return (queue);
}
}
#line 821 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
GList *empty_queue(GList *queue ) 
{ 
  int num ;
  int i ;
  GList *gl ;
  guint __cil_tmp5 ;
  GList *__cil_tmp6 ;
  GList *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 826
  __cil_tmp5 = g_list_length(queue);
#line 826
  num = (int )__cil_tmp5;
#line 827
  i = 0;
  }
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (i <= num - 1)) {
#line 827
      goto while_break;
    }
    {
#line 828
    gl = g_list_first(queue);
#line 829
    queue = queue_remove_message(queue, gl);
    }
#line 827
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 832
  return (queue);
}
}
#line 835 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
GList *empty_queue_by_time(GList *queue , unsigned int uid ) 
{ 
  int num ;
  int i ;
  GList *gl ;
  GList *gln ;
  TSpeechDMessage *msg ;
  guint __cil_tmp8 ;
  GList *__cil_tmp9 ;
  GList *tmp ;
  int tmp___0 ;
  GList *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 841
  __cil_tmp8 = g_list_length(queue);
#line 841
  num = (int )__cil_tmp8;
#line 842
  gl = g_list_first(queue);
#line 843
  i = 0;
  }
  {
#line 843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 843
    if (! (i <= num - 1)) {
#line 843
      goto while_break;
    }
#line 844
    if (gl) {
#line 844
      tmp = ((GList *)gl)->next;
    } else {
#line 844
      tmp = (GList *)((void *)0);
    }
#line 844
    gln = tmp;
#line 845
    if (gl == (void *)0) {
#line 846
      goto while_break;
    }
#line 848
    msg = gl->data;
#line 849
    if (msg->id < uid) {
      {
#line 850
      queue = queue_remove_message(queue, gl);
      }
    }
#line 852
    gl = gln;
#line 843
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  return (queue);
}
}
#line 858 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int stop_priority(SPDPriority priority ) 
{ 
  GList *queue ;
  GList *__cil_tmp3 ;
  GList *__cil_tmp4 ;

  {
  {
#line 862
  queue = speaking_get_queue(priority);
  }
#line 864
  if ((unsigned int )highest_priority == (unsigned int )priority) {
    {
#line 865
    output_stop();
    }
  }
  {
#line 868
  queue = empty_queue(queue);
#line 870
  speaking_set_queue(priority, queue);
  }
#line 872
  return (0);
}
}
#line 875 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int stop_priority_older_than(SPDPriority priority , unsigned int uid ) 
{ 
  GList *queue ;
  GList *__cil_tmp4 ;
  GList *__cil_tmp5 ;

  {
  {
#line 879
  queue = speaking_get_queue(priority);
  }
#line 881
  if ((unsigned int )highest_priority == (unsigned int )priority) {
    {
#line 882
    output_stop();
    }
  }
  {
#line 885
  queue = empty_queue_by_time(queue, uid);
#line 887
  speaking_set_queue(priority, queue);
  }
#line 889
  return (0);
}
}
#line 892 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
GList *stop_priority_from_uid(GList *queue , int uid ) 
{ 
  GList *ret ;
  GList *gl ;
  GList *__cil_tmp5 ;
  GList *__cil_tmp6 ;

  {
#line 894
  ret = queue;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 897
    gl = g_list_find_custom(ret, & uid, p_msg_uid_lc);
    }
#line 897
    if (! gl) {
#line 897
      goto while_break;
    }
    {
#line 898
    ret = queue_remove_message(ret, gl);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return (ret);
}
}
#line 903 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void stop_from_uid(int uid ) 
{ 
  GList *__cil_tmp2 ;
  GList *__cil_tmp3 ;
  GList *__cil_tmp4 ;
  GList *__cil_tmp5 ;
  GList *__cil_tmp6 ;

  {
  {
#line 905
  check_locked(& element_free_mutex);
#line 906
  MessageQueue->p1 = stop_priority_from_uid(MessageQueue->p1, uid);
#line 907
  MessageQueue->p2 = stop_priority_from_uid(MessageQueue->p2, uid);
#line 908
  MessageQueue->p3 = stop_priority_from_uid(MessageQueue->p3, uid);
#line 909
  MessageQueue->p4 = stop_priority_from_uid(MessageQueue->p4, uid);
#line 910
  MessageQueue->p5 = stop_priority_from_uid(MessageQueue->p5, uid);
  }
  return;
}
}
#line 918 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
gint message_nto_speak(gconstpointer data , gconstpointer nothing ) 
{ 
  TFDSetElement *global_settings ;
  TSpeechDMessage *message ;
  TFDSetElement *__cil_tmp5 ;

  {
#line 921
  message = (TSpeechDMessage *)data;
#line 924
  if (message == (void *)0) {
#line 925
    return (0);
  }
  {
#line 928
  global_settings = get_client_settings_by_fd(message->settings.fd);
  }
#line 929
  if (global_settings == (void *)0) {
#line 930
    return (0);
  }
#line 932
  if (! global_settings->paused) {
#line 933
    return (0);
  } else {
#line 935
    return (1);
  }
}
}
#line 938 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void stop_priority_except_first(SPDPriority priority ) 
{ 
  GList *queue ;
  GList *gl ;
  TSpeechDMessage *msg ;
  GList *gl_next ;
  int gid ;
  GList *__cil_tmp7 ;
  GList *__cil_tmp8 ;
  GList *__cil_tmp9 ;
  GList *__cil_tmp10 ;
  GList *tmp ;
  TSpeechDMessage *msgg ;
  GList *__cil_tmp13 ;

  {
  {
#line 946
  queue = speaking_get_queue(priority);
#line 948
  gl = g_list_last(queue);
  }
#line 950
  if (gl == (void *)0) {
#line 951
    return;
  }
#line 952
  if (gl->data == (void *)0) {
#line 953
    return;
  }
#line 955
  msg = (TSpeechDMessage *)gl->data;
#line 956
  if (msg->settings.reparted <= 0) {
    {
#line 957
    queue = g_list_remove_link(queue, gl);
#line 958
    speaking_set_queue(priority, queue);
#line 960
    stop_priority(priority);
#line 962
    speaking_set_queue(priority, gl);
    }
  } else {
#line 964
    gid = msg->settings.reparted;
#line 966
    if ((unsigned int )highest_priority == (unsigned int )priority) {
#line 966
      if (speaking_gid != gid) {
        {
#line 967
        output_stop();
        }
      }
    }
    {
#line 970
    gl = g_list_first(queue);
    }
    {
#line 971
    while (1) {
      while_continue: /* CIL Label */ ;
#line 971
      if (! gl) {
#line 971
        goto while_break;
      }
#line 972
      if (gl) {
#line 972
        tmp = ((GList *)gl)->next;
      } else {
#line 972
        tmp = (GList *)((void *)0);
      }
#line 972
      gl_next = tmp;
#line 973
      if (gl->data != (void *)0) {
#line 974
        msgg = gl->data;
#line 975
        if (msgg->settings.reparted != gid) {
          {
#line 976
          queue = g_list_remove_link(queue, gl);
#line 977
          mem_free_message(msgg);
          }
        }
      }
#line 980
      gl = gl_next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 982
    speaking_set_queue(priority, queue);
    }
  }
#line 985
  return;
}
}
#line 988 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void resolve_priorities(SPDPriority priority ) 
{ 
  GList *gl ;
  GList *__cil_tmp3 ;
  GList *__cil_tmp4 ;
  GList *__cil_tmp5 ;

  {
#line 990
  if ((unsigned int )priority == 1U) {
#line 991
    if (SPEAKING) {
#line 991
      if ((unsigned int )highest_priority != 1U) {
        {
#line 992
        output_stop();
        }
      }
    }
    {
#line 993
    stop_priority((SPDPriority )4);
#line 994
    stop_priority((SPDPriority )5);
    }
  }
#line 997
  if ((unsigned int )priority == 2U) {
#line 998
    if (SPEAKING) {
#line 998
      if ((unsigned int )highest_priority != 1U) {
#line 998
        if ((unsigned int )highest_priority != 2U) {
          {
#line 1000
          output_stop();
          }
        }
      }
    }
    {
#line 1001
    stop_priority((SPDPriority )3);
#line 1002
    stop_priority((SPDPriority )4);
#line 1003
    stop_priority((SPDPriority )5);
    }
  }
#line 1006
  if ((unsigned int )priority == 3U) {
    {
#line 1007
    stop_priority_except_first((SPDPriority )3);
#line 1008
    stop_priority((SPDPriority )4);
#line 1009
    stop_priority((SPDPriority )5);
    }
  }
#line 1012
  if ((unsigned int )priority == 4U) {
    {
#line 1013
    stop_priority_except_first((SPDPriority )4);
    }
#line 1014
    if (SPEAKING) {
#line 1014
      if ((unsigned int )highest_priority != 4U) {
        {
#line 1015
        stop_priority((SPDPriority )4);
        }
      }
    }
  }
#line 1018
  if ((unsigned int )priority == 5U) {
    {
#line 1019
    stop_priority((SPDPriority )4);
    }
#line 1020
    if (SPEAKING) {
      {
#line 1022
      check_locked(& element_free_mutex);
#line 1023
      gl = g_list_last(MessageQueue->p5);
#line 1024
      check_locked(& element_free_mutex);
#line 1025
      MessageQueue->p5 = g_list_remove_link(MessageQueue->p5, gl);
      }
#line 1027
      if (gl != (void *)0) {
        {
#line 1028
        check_locked(& element_free_mutex);
#line 1029
        MessageQueue->p5 = empty_queue(MessageQueue->p5);
        }
#line 1031
        if (gl->data != (void *)0) {
#line 1032
          MessageQueue->p5 = gl;
        }
      }
    }
  }
  return;
}
}
#line 1040 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
TSpeechDMessage *get_message_from_queues(void) 
{ 
  GList *gl ;
  SPDPriority prio ;
  TSpeechDMessage *message ;
  GList *current_queue ;
  GList *__cil_tmp5 ;
  GList *__cil_tmp6 ;
  gint __cil_tmp7 ;
  GList *tmp ;
  GList *__cil_tmp9 ;
  SPDPriority __cil_tmp10 ;

  {
#line 1048
  prio = (SPDPriority )1;
  {
#line 1048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1048
    if (! ((unsigned int )prio <= 5U)) {
#line 1048
      goto while_break;
    }
    {
#line 1049
    __cil_tmp5 = speaking_get_queue(prio);
#line 1049
    current_queue = __cil_tmp5;
#line 1050
    check_locked(& element_free_mutex);
#line 1051
    gl = g_list_first(current_queue);
    }
    {
#line 1053
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1053
      if (! (gl != (void *)0)) {
#line 1053
        goto while_break___0;
      }
      {
#line 1054
      __cil_tmp7 = message_nto_speak((TSpeechDMessage *)gl->data, (void *)0);
      }
#line 1054
      if (__cil_tmp7) {
#line 1056
        if (gl) {
#line 1056
          tmp = ((GList *)gl)->next;
        } else {
#line 1056
          tmp = (GList *)((void *)0);
        }
#line 1056
        gl = tmp;
#line 1057
        goto while_continue___0;
      }
      {
#line 1059
      __cil_tmp9 = g_list_remove_link(current_queue, gl);
#line 1059
      speaking_set_queue(prio, __cil_tmp9);
#line 1062
      highest_priority = prio;
#line 1063
      message = gl->data;
#line 1064
      g_list_free(gl);
      }
#line 1065
      return ((TSpeechDMessage *)message);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1048
    prio ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return ((TSpeechDMessage *)((void *)0));
}
}
#line 1072 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
gint message_has_uid(gconstpointer msg , gconstpointer uid ) 
{ 


  {
#line 1074
  if (((TSpeechDMessage *)msg)->settings.uid == (unsigned int )*((int *)uid)) {
#line 1075
    return (0);
  } else {
#line 1077
    return (1);
  }
}
}
#line 1082 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
int client_has_messages(int uid ) 
{ 
  GList *__cil_tmp2 ;
  GList *__cil_tmp3 ;
  GList *__cil_tmp4 ;
  GList *__cil_tmp5 ;
  GList *__cil_tmp6 ;

  {
  {
#line 1085
  __cil_tmp6 = g_list_find_custom(MessageQueue->p1, (gconstpointer )(& uid), & message_has_uid);
  }
  {
#line 1085
  __cil_tmp5 = g_list_find_custom(MessageQueue->p2, (gconstpointer )(& uid), & message_has_uid);
  }
  {
#line 1085
  __cil_tmp4 = g_list_find_custom(MessageQueue->p3, (gconstpointer )(& uid), & message_has_uid);
  }
  {
#line 1085
  __cil_tmp3 = g_list_find_custom(MessageQueue->p4, (gconstpointer )(& uid), & message_has_uid);
  }
  {
#line 1085
  __cil_tmp2 = g_list_find_custom(MessageQueue->p5, (gconstpointer )(& uid), & message_has_uid);
  }
#line 1085
  if (__cil_tmp2) {
#line 1095
    return (1);
  } else
#line 1085
  if (__cil_tmp3) {
#line 1095
    return (1);
  } else
#line 1085
  if (__cil_tmp4) {
#line 1095
    return (1);
  } else
#line 1085
  if (__cil_tmp5) {
#line 1095
    return (1);
  } else
#line 1085
  if (__cil_tmp6) {
#line 1095
    return (1);
  } else {
#line 1097
    return (0);
  }
}
}
#line 1100 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
GList *speaking_get_queue(SPDPriority priority ) 
{ 
  GList *queue ;
  int tmp ;

  {
  {
#line 1102
  queue = (GList *)((void *)0);
#line 1106
  check_locked(& element_free_mutex);
  }
  {
#line 1108
  if ((unsigned int )priority == (unsigned int )1) {
#line 1108
    goto case_1;
  }
#line 1111
  if ((unsigned int )priority == (unsigned int )2) {
#line 1111
    goto case_2;
  }
#line 1114
  if ((unsigned int )priority == (unsigned int )3) {
#line 1114
    goto case_3;
  }
#line 1117
  if ((unsigned int )priority == (unsigned int )4) {
#line 1117
    goto case_4;
  }
#line 1120
  if ((unsigned int )priority == (unsigned int )5) {
#line 1120
    goto case_5;
  }
#line 1107
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1109
  queue = MessageQueue->p1;
#line 1110
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1112
  queue = MessageQueue->p2;
#line 1113
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1115
  queue = MessageQueue->p3;
#line 1116
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1118
  queue = MessageQueue->p4;
#line 1119
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1121
  queue = MessageQueue->p5;
#line 1122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1125
  return (queue);
}
}
#line 1128 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
void speaking_set_queue(SPDPriority priority , GList *queue ) 
{ 
  int tmp ;

  {
  {
#line 1132
  check_locked(& element_free_mutex);
  }
  {
#line 1134
  if ((unsigned int )priority == (unsigned int )1) {
#line 1134
    goto case_1;
  }
#line 1137
  if ((unsigned int )priority == (unsigned int )2) {
#line 1137
    goto case_2;
  }
#line 1140
  if ((unsigned int )priority == (unsigned int )3) {
#line 1140
    goto case_3;
  }
#line 1143
  if ((unsigned int )priority == (unsigned int )4) {
#line 1143
    goto case_4;
  }
#line 1146
  if ((unsigned int )priority == (unsigned int )5) {
#line 1146
    goto case_5;
  }
#line 1133
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1135
  MessageQueue->p1 = queue;
#line 1136
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1138
  MessageQueue->p2 = queue;
#line 1139
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1141
  MessageQueue->p3 = queue;
#line 1142
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1144
  MessageQueue->p4 = queue;
#line 1145
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1147
  MessageQueue->p5 = queue;
#line 1148
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1152 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speaking.c"
gint sortbyuid(gconstpointer a , gconstpointer b ) 
{ 
  TSpeechDMessage *msg1 ;
  TSpeechDMessage *msg2 ;

  {
#line 1154
  msg1 = a;
#line 1155
  msg2 = b;
#line 1157
  if (msg1 == (void *)0) {
#line 1157
    if (msg2 != (void *)0) {
#line 1158
      return (- 1);
    }
  }
#line 1159
  if (msg1 != (void *)0) {
#line 1159
    if (msg2 == (void *)0) {
#line 1160
      return (1);
    }
  }
#line 1161
  if (msg1 == (void *)0) {
#line 1161
    if (msg2 == (void *)0) {
#line 1162
      return (0);
    }
  }
#line 1164
  return ((gint )(msg1->id - msg2->id));
}
}
#line 33 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/compare.c"
GCompareFunc p_msg_uid_lc  =    & compare_message_uid;
#line 35 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/compare.c"
gint compare_message_uid(gconstpointer element , gconstpointer value ) 
{ 
  int *uid_val ;
  TSpeechDMessage *message ;
  int tmp ;

  {
#line 40
  uid_val = (int *)value;
#line 42
  message = (TSpeechDMessage *)element;
#line 46
  return ((gint )(message->settings.uid - (unsigned int )*uid_val));
}
}
#line 26 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/alloc.c"
TFDSetElement spd_fdset_copy(TFDSetElement *old ) 
{ 
  TFDSetElement new ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  gchar *__cil_tmp9 ;
  gchar *__cil_tmp10 ;
  gchar *__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  gchar *__cil_tmp13 ;

  {
  {
#line 30
  new = *old;
#line 31
  new.msg_settings.voice.language = g_strdup(old->msg_settings.voice.language);
#line 33
  new.msg_settings.voice.name = g_strdup(old->msg_settings.voice.name);
#line 34
  new.client_name = g_strdup(old->client_name);
#line 35
  new.output_module = g_strdup(old->output_module);
#line 36
  new.index_mark = g_strdup(old->index_mark);
#line 37
  new.audio_output_method = g_strdup(old->audio_output_method);
#line 38
  new.audio_oss_device = g_strdup(old->audio_oss_device);
#line 39
  new.audio_alsa_device = g_strdup(old->audio_alsa_device);
#line 40
  new.audio_nas_server = g_strdup(old->audio_nas_server);
#line 41
  new.audio_pulse_server = g_strdup(old->audio_pulse_server);
#line 42
  new.audio_pulse_device = g_strdup(old->audio_pulse_device);
  }
#line 44
  return (new);
}
}
#line 48 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/alloc.c"
TSpeechDMessage *spd_message_copy(TSpeechDMessage *old ) 
{ 
  TSpeechDMessage *new ;
  gpointer __cil_tmp3 ;
  gpointer __cil_tmp4 ;
  TFDSetElement __cil_tmp5 ;

  {
#line 50
  new = (TSpeechDMessage *)((void *)0);
#line 52
  if (old == (void *)0) {
#line 53
    return ((TSpeechDMessage *)((void *)0));
  }
  {
#line 55
  __cil_tmp3 = g_malloc(sizeof(TSpeechDMessage ));
#line 55
  new = (TSpeechDMessage *)__cil_tmp3;
#line 57
  *new = *old;
#line 58
  new->buf = (char *)g_malloc((unsigned long )(old->bytes + 1) * sizeof(char ));
#line 59
  memcpy(new->buf, old->buf, (unsigned long )old->bytes);
#line 60
  *(new->buf + new->bytes) = (char )0;
#line 61
  new->settings = spd_fdset_copy(& old->settings);
  }
#line 63
  return (new);
}
}
#line 66 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/alloc.c"
void mem_free_fdset(TFDSetElement *fdset ) 
{ 


  {
  {
#line 70
  g_free(fdset->client_name);
#line 71
  g_free(fdset->msg_settings.voice.language);
#line 72
  g_free(fdset->msg_settings.voice.name);
#line 73
  g_free(fdset->output_module);
#line 74
  g_free(fdset->index_mark);
#line 75
  g_free(fdset->audio_output_method);
#line 76
  g_free(fdset->audio_oss_device);
#line 77
  g_free(fdset->audio_alsa_device);
#line 78
  g_free(fdset->audio_nas_server);
#line 79
  g_free(fdset->audio_pulse_server);
#line 80
  g_free(fdset->audio_pulse_device);
  }
  return;
}
}
#line 83 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/alloc.c"
void mem_free_message(TSpeechDMessage *msg ) 
{ 


  {
#line 85
  if (msg == (void *)0) {
#line 86
    return;
  }
  {
#line 87
  g_free(msg->buf);
#line 88
  mem_free_fdset(& msg->settings);
#line 89
  g_free(msg);
  }
  return;
}
}
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 33 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
gint spd_str_compare(gconstpointer a , gconstpointer b ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 35
  __cil_tmp3 = strcmp((char const   *)((char *)a), (char const   *)((char *)b));
  }
#line 35
  return (__cil_tmp3);
}
}
#line 38 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_priority_self(int fd , SPDPriority priority ) 
{ 
  int uid ;
  int ret ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 43
  uid = get_client_uid_by_fd(fd);
  }
#line 44
  if (uid == 0) {
#line 45
    return (1);
  }
  {
#line 46
  ret = set_priority_uid(uid, priority);
  }
#line 48
  return (ret);
}
}
#line 51 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_priority_uid(int uid , SPDPriority priority ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
#line 54
  if ((unsigned int )priority < 1U) {
#line 55
    return (1);
  } else
#line 54
  if ((unsigned int )priority > 5U) {
#line 55
    return (1);
  }
  {
#line 56
  settings = get_client_settings_by_uid(uid);
  }
#line 57
  if (settings == (void *)0) {
#line 58
    return (1);
  }
#line 60
  settings->priority = priority;
#line 61
  return (0);
}
}
#line 88 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_rate_self(int fd , int rate ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 88
  uid = get_client_uid_by_fd(fd);
  }
#line 88
  if (uid == 0) {
#line 88
    return (1);
  }
  {
#line 88
  __cil_tmp5 = set_rate_uid(uid, rate);
  }
#line 88
  return (__cil_tmp5);
}
}
#line 88 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_rate_all(int rate ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 88
  err = 0;
#line 88
  i = 1;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (i <= SpeechdStatus.max_fd)) {
#line 88
      goto while_break;
    }
    {
#line 88
    uid = get_client_uid_by_fd(i);
    }
#line 88
    if (uid == 0) {
#line 88
      goto while_continue;
    }
    {
#line 88
    __cil_tmp6 = set_rate_uid(uid, rate);
    }
#line 88
    err += __cil_tmp6;
#line 88
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  if (err > 0) {
#line 88
    return (1);
  }
#line 88
  return (0);
}
}
#line 90 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_rate_uid(int uid , int rate ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
#line 94
  if (rate > 100) {
#line 95
    return (1);
  } else
#line 94
  if (rate < -100) {
#line 95
    return (1);
  }
  {
#line 97
  settings = get_client_settings_by_uid(uid);
  }
#line 98
  if (settings == (void *)0) {
#line 99
    return (1);
  }
#line 101
  settings->msg_settings.rate = rate;
#line 102
  return (0);
}
}
#line 105 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_self(int fd , int pitch ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 105
  uid = get_client_uid_by_fd(fd);
  }
#line 105
  if (uid == 0) {
#line 105
    return (1);
  }
  {
#line 105
  __cil_tmp5 = set_pitch_uid(uid, pitch);
  }
#line 105
  return (__cil_tmp5);
}
}
#line 105 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_all(int pitch ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 105
  err = 0;
#line 105
  i = 1;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i <= SpeechdStatus.max_fd)) {
#line 105
      goto while_break;
    }
    {
#line 105
    uid = get_client_uid_by_fd(i);
    }
#line 105
    if (uid == 0) {
#line 105
      goto while_continue;
    }
    {
#line 105
    __cil_tmp6 = set_pitch_uid(uid, pitch);
    }
#line 105
    err += __cil_tmp6;
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (err > 0) {
#line 105
    return (1);
  }
#line 105
  return (0);
}
}
#line 107 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_uid(int uid , int pitch ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
#line 111
  if (pitch > 100) {
#line 112
    return (1);
  } else
#line 111
  if (pitch < -100) {
#line 112
    return (1);
  }
  {
#line 114
  settings = get_client_settings_by_uid(uid);
  }
#line 115
  if (settings == (void *)0) {
#line 116
    return (1);
  }
#line 118
  settings->msg_settings.pitch = pitch;
#line 119
  return (0);
}
}
#line 122 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_range_self(int fd , int pitch_range ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 122
  uid = get_client_uid_by_fd(fd);
  }
#line 122
  if (uid == 0) {
#line 122
    return (1);
  }
  {
#line 122
  __cil_tmp5 = set_pitch_range_uid(uid, pitch_range);
  }
#line 122
  return (__cil_tmp5);
}
}
#line 122 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_range_all(int pitch_range ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 122
  err = 0;
#line 122
  i = 1;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i <= SpeechdStatus.max_fd)) {
#line 122
      goto while_break;
    }
    {
#line 122
    uid = get_client_uid_by_fd(i);
    }
#line 122
    if (uid == 0) {
#line 122
      goto while_continue;
    }
    {
#line 122
    __cil_tmp6 = set_pitch_range_uid(uid, pitch_range);
    }
#line 122
    err += __cil_tmp6;
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if (err > 0) {
#line 122
    return (1);
  }
#line 122
  return (0);
}
}
#line 124 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pitch_range_uid(int uid , int pitch_range ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
#line 128
  if (pitch_range > 100) {
#line 129
    return (1);
  } else
#line 128
  if (pitch_range < -100) {
#line 129
    return (1);
  }
  {
#line 131
  settings = get_client_settings_by_uid(uid);
  }
#line 132
  if (settings == (void *)0) {
#line 133
    return (1);
  }
#line 135
  settings->msg_settings.pitch_range = pitch_range;
#line 136
  return (0);
}
}
#line 139 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_volume_self(int fd , int volume ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 139
  uid = get_client_uid_by_fd(fd);
  }
#line 139
  if (uid == 0) {
#line 139
    return (1);
  }
  {
#line 139
  __cil_tmp5 = set_volume_uid(uid, volume);
  }
#line 139
  return (__cil_tmp5);
}
}
#line 139 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_volume_all(int volume ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 139
  err = 0;
#line 139
  i = 1;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i <= SpeechdStatus.max_fd)) {
#line 139
      goto while_break;
    }
    {
#line 139
    uid = get_client_uid_by_fd(i);
    }
#line 139
    if (uid == 0) {
#line 139
      goto while_continue;
    }
    {
#line 139
    __cil_tmp6 = set_volume_uid(uid, volume);
    }
#line 139
    err += __cil_tmp6;
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (err > 0) {
#line 139
    return (1);
  }
#line 139
  return (0);
}
}
#line 141 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_volume_uid(int uid , int volume ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
#line 145
  if (volume > 100) {
#line 146
    return (1);
  } else
#line 145
  if (volume < -100) {
#line 146
    return (1);
  }
  {
#line 148
  settings = get_client_settings_by_uid(uid);
  }
#line 149
  if (settings == (void *)0) {
#line 150
    return (1);
  }
#line 152
  settings->msg_settings.volume = volume;
#line 153
  return (0);
}
}
#line 156 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_voice_self(int fd , char const   *voice ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 156
  uid = get_client_uid_by_fd(fd);
  }
#line 156
  if (uid == 0) {
#line 156
    return (1);
  }
  {
#line 156
  __cil_tmp5 = set_voice_uid(uid, voice);
  }
#line 156
  return (__cil_tmp5);
}
}
#line 156 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_voice_all(char const   *voice ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 156
  err = 0;
#line 156
  i = 1;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i <= SpeechdStatus.max_fd)) {
#line 156
      goto while_break;
    }
    {
#line 156
    uid = get_client_uid_by_fd(i);
    }
#line 156
    if (uid == 0) {
#line 156
      goto while_continue;
    }
    {
#line 156
    __cil_tmp6 = set_voice_uid(uid, voice);
    }
#line 156
    err += __cil_tmp6;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (err > 0) {
#line 156
    return (1);
  }
#line 156
  return (0);
}
}
#line 158 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_voice_uid(int uid , char const   *voice ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 162
  settings = get_client_settings_by_uid(uid);
  }
#line 163
  if (settings == (void *)0) {
#line 164
    return (1);
  }
  {
#line 166
  __cil_tmp5 = strcmp(voice, "male1");
  }
#line 166
  if (! __cil_tmp5) {
#line 167
    settings->msg_settings.voice_type = (SPDVoiceType )1;
  } else {
    {
#line 168
    __cil_tmp6 = strcmp(voice, "male2U");
    }
#line 168
    if (! __cil_tmp6) {
#line 169
      settings->msg_settings.voice_type = (SPDVoiceType )2;
    } else {
      {
#line 170
      __cil_tmp7 = strcmp(voice, "male3U");
      }
#line 170
      if (! __cil_tmp7) {
#line 171
        settings->msg_settings.voice_type = (SPDVoiceType )3;
      } else {
        {
#line 172
        __cil_tmp8 = strcmp(voice, "female1");
        }
#line 172
        if (! __cil_tmp8) {
#line 173
          settings->msg_settings.voice_type = (SPDVoiceType )4;
        } else {
          {
#line 174
          __cil_tmp9 = strcmp(voice, "female2");
          }
#line 174
          if (! __cil_tmp9) {
#line 175
            settings->msg_settings.voice_type = (SPDVoiceType )5;
          } else {
            {
#line 176
            __cil_tmp10 = strcmp(voice, "female3");
            }
#line 176
            if (! __cil_tmp10) {
#line 177
              settings->msg_settings.voice_type = (SPDVoiceType )6;
            } else {
              {
#line 178
              __cil_tmp11 = strcmp(voice, "child_male");
              }
#line 178
              if (! __cil_tmp11) {
#line 179
                settings->msg_settings.voice_type = (SPDVoiceType )7;
              } else {
                {
#line 180
                __cil_tmp12 = strcmp(voice, "child_female");
                }
#line 180
                if (! __cil_tmp12) {
#line 181
                  settings->msg_settings.voice_type = (SPDVoiceType )8;
                } else {
#line 183
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 185
  if (settings->msg_settings.voice.name != (void *)0) {
    {
#line 186
    g_free(settings->msg_settings.voice.name);
#line 187
    settings->msg_settings.voice.name = (char *)((void *)0);
    }
  }
#line 189
  return (0);
}
}
#line 192 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_punctuation_mode_self(int fd , SPDPunctuation punctuation_mode ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 192
  uid = get_client_uid_by_fd(fd);
  }
#line 192
  if (uid == 0) {
#line 192
    return (1);
  }
  {
#line 192
  __cil_tmp5 = set_punctuation_mode_uid(uid, punctuation_mode);
  }
#line 192
  return (__cil_tmp5);
}
}
#line 192 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_punctuation_mode_all(SPDPunctuation punctuation_mode ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 192
  err = 0;
#line 192
  i = 1;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i <= SpeechdStatus.max_fd)) {
#line 192
      goto while_break;
    }
    {
#line 192
    uid = get_client_uid_by_fd(i);
    }
#line 192
    if (uid == 0) {
#line 192
      goto while_continue;
    }
    {
#line 192
    __cil_tmp6 = set_punctuation_mode_uid(uid, punctuation_mode);
    }
#line 192
    err += __cil_tmp6;
#line 192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (err > 0) {
#line 192
    return (1);
  }
#line 192
  return (0);
}
}
#line 194 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_punctuation_mode_uid(int uid , SPDPunctuation punctuation ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
  {
#line 198
  settings = get_client_settings_by_uid(uid);
  }
#line 199
  if (settings == (void *)0) {
#line 200
    return (1);
  }
#line 202
  settings->msg_settings.punctuation_mode = punctuation;
#line 203
  return (0);
}
}
#line 209 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_capital_letter_recognition_self(int fd , SPDCapitalLetters capital_letter_recognition ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 209
  uid = get_client_uid_by_fd(fd);
  }
#line 209
  if (uid == 0) {
#line 209
    return (1);
  }
  {
#line 209
  __cil_tmp5 = set_capital_letter_recognition_uid(uid, capital_letter_recognition);
  }
#line 209
  return (__cil_tmp5);
}
}
#line 209 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_capital_letter_recognition_all(SPDCapitalLetters capital_letter_recognition ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 209
  err = 0;
#line 209
  i = 1;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (i <= SpeechdStatus.max_fd)) {
#line 209
      goto while_break;
    }
    {
#line 209
    uid = get_client_uid_by_fd(i);
    }
#line 209
    if (uid == 0) {
#line 209
      goto while_continue;
    }
    {
#line 209
    __cil_tmp6 = set_capital_letter_recognition_uid(uid, capital_letter_recognition);
    }
#line 209
    err += __cil_tmp6;
#line 209
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (err > 0) {
#line 209
    return (1);
  }
#line 209
  return (0);
}
}
#line 211 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_capital_letter_recognition_uid(int uid , SPDCapitalLetters recogn ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
  {
#line 215
  settings = get_client_settings_by_uid(uid);
  }
#line 216
  if (settings == (void *)0) {
#line 217
    return (1);
  }
#line 219
  settings->msg_settings.cap_let_recogn = recogn;
#line 220
  return (0);
}
}
#line 223 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_spelling_self(int fd , SPDSpelling spelling ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 223
  uid = get_client_uid_by_fd(fd);
  }
#line 223
  if (uid == 0) {
#line 223
    return (1);
  }
  {
#line 223
  __cil_tmp5 = set_spelling_uid(uid, spelling);
  }
#line 223
  return (__cil_tmp5);
}
}
#line 223 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_spelling_all(SPDSpelling spelling ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 223
  err = 0;
#line 223
  i = 1;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i <= SpeechdStatus.max_fd)) {
#line 223
      goto while_break;
    }
    {
#line 223
    uid = get_client_uid_by_fd(i);
    }
#line 223
    if (uid == 0) {
#line 223
      goto while_continue;
    }
    {
#line 223
    __cil_tmp6 = set_spelling_uid(uid, spelling);
    }
#line 223
    err += __cil_tmp6;
#line 223
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (err > 0) {
#line 223
    return (1);
  }
#line 223
  return (0);
}
}
#line 225 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_spelling_uid(int uid , SPDSpelling spelling ) 
{ 
  TFDSetElement *settings ;
  int tmp ;
  TFDSetElement *__cil_tmp5 ;

  {
  {
#line 231
  settings = get_client_settings_by_uid(uid);
  }
#line 232
  if (settings == (void *)0) {
#line 233
    return (1);
  }
#line 235
  settings->msg_settings.spelling_mode = spelling;
#line 236
  return (0);
}
}
#line 239 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_language_self(int fd , char *language ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 239
  uid = get_client_uid_by_fd(fd);
  }
#line 239
  if (uid == 0) {
#line 239
    return (1);
  }
  {
#line 239
  __cil_tmp5 = set_language_uid(uid, language);
  }
#line 239
  return (__cil_tmp5);
}
}
#line 239 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_language_all(char *language ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 239
  err = 0;
#line 239
  i = 1;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i <= SpeechdStatus.max_fd)) {
#line 239
      goto while_break;
    }
    {
#line 239
    uid = get_client_uid_by_fd(i);
    }
#line 239
    if (uid == 0) {
#line 239
      goto while_continue;
    }
    {
#line 239
    __cil_tmp6 = set_language_uid(uid, language);
    }
#line 239
    err += __cil_tmp6;
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (err > 0) {
#line 239
    return (1);
  }
#line 239
  return (0);
}
}
#line 241 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_language_uid(int uid , char *language ) 
{ 
  TFDSetElement *settings ;
  char const   *output_module ;
  TFDSetElement *__cil_tmp5 ;
  char *__cil_tmp6 ;
  gpointer __cil_tmp7 ;
  char *dash ;
  char *__cil_tmp9 ;
  gpointer __cil_tmp10 ;

  {
  {
#line 246
  settings = get_client_settings_by_uid(uid);
  }
#line 247
  if (settings == (void *)0) {
#line 248
    return (1);
  }
  {
#line 250
  settings->msg_settings.voice.language = set_param_str(settings->msg_settings.voice.language,
                                                        (char const   *)language);
#line 254
  output_module = (char const   *)g_hash_table_lookup(language_default_modules, language);
  }
#line 255
  if (output_module != (void *)0) {
    {
#line 256
    set_output_module_uid(uid, output_module);
    }
  } else {
    {
#line 258
    __cil_tmp9 = strchr((char const   *)language, '-');
#line 258
    dash = __cil_tmp9;
    }
#line 260
    if (dash) {
      {
#line 261
      *dash = (char )0;
#line 263
      output_module = (char const   *)g_hash_table_lookup(language_default_modules,
                                                          language);
      }
#line 264
      if (output_module != (void *)0) {
        {
#line 265
        set_output_module_uid(uid, output_module);
        }
      }
    }
  }
#line 270
  return (0);
}
}
#line 273 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_synthesis_voice_self(int fd , char const   *synthesis_voice ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 273
  uid = get_client_uid_by_fd(fd);
  }
#line 273
  if (uid == 0) {
#line 273
    return (1);
  }
  {
#line 273
  __cil_tmp5 = set_synthesis_voice_uid(uid, synthesis_voice);
  }
#line 273
  return (__cil_tmp5);
}
}
#line 273 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_synthesis_voice_all(char const   *synthesis_voice ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 273
  err = 0;
#line 273
  i = 1;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i <= SpeechdStatus.max_fd)) {
#line 273
      goto while_break;
    }
    {
#line 273
    uid = get_client_uid_by_fd(i);
    }
#line 273
    if (uid == 0) {
#line 273
      goto while_continue;
    }
    {
#line 273
    __cil_tmp6 = set_synthesis_voice_uid(uid, synthesis_voice);
    }
#line 273
    err += __cil_tmp6;
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  if (err > 0) {
#line 273
    return (1);
  }
#line 273
  return (0);
}
}
#line 275 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_synthesis_voice_uid(int uid , char const   *synthesis_voice ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 279
  settings = get_client_settings_by_uid(uid);
  }
#line 280
  if (settings == (void *)0) {
#line 281
    return (1);
  }
  {
#line 283
  settings->msg_settings.voice.name = set_param_str(settings->msg_settings.voice.name,
                                                    synthesis_voice);
#line 287
  settings->msg_settings.voice_type = (SPDVoiceType )(- 1);
  }
#line 289
  return (0);
}
}
#line 302 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
void update_cl_settings(gpointer data , gpointer user_data ) 
{ 
  TFDSetClientSpecific *cl_set ;
  TFDSetElement *set ;
  int __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;

  {
  {
#line 304
  cl_set = data;
#line 305
  set = user_data;
#line 307
  MSG(4, "Updating client specific settings %s against %s", set->client_name, cl_set->pattern);
#line 310
  __cil_tmp5 = fnmatch((char const   *)cl_set->pattern, (char const   *)set->client_name,
                       0);
  }
#line 310
  if (__cil_tmp5) {
#line 311
    return;
  }
#line 314
  if (cl_set->val.msg_settings.rate != -101) {
    {
#line 314
    set->msg_settings.rate = cl_set->val.msg_settings.rate;
#line 314
    MSG(4, "parameter msg_settings.rate set to %d", cl_set->val.msg_settings.rate);
    }
  }
#line 315
  if (cl_set->val.msg_settings.pitch != -101) {
    {
#line 315
    set->msg_settings.pitch = cl_set->val.msg_settings.pitch;
#line 315
    MSG(4, "parameter msg_settings.pitch set to %d", cl_set->val.msg_settings.pitch);
    }
  }
#line 316
  if (cl_set->val.msg_settings.pitch_range != -101) {
    {
#line 316
    set->msg_settings.pitch_range = cl_set->val.msg_settings.pitch_range;
#line 316
    MSG(4, "parameter msg_settings.pitch_range set to %d", cl_set->val.msg_settings.pitch_range);
    }
  }
#line 317
  if (cl_set->val.msg_settings.volume != -101) {
    {
#line 317
    set->msg_settings.volume = cl_set->val.msg_settings.volume;
#line 317
    MSG(4, "parameter msg_settings.volume set to %d", cl_set->val.msg_settings.volume);
    }
  }
#line 318
  if ((unsigned int )cl_set->val.msg_settings.punctuation_mode != 4294967295U) {
    {
#line 318
    set->msg_settings.punctuation_mode = cl_set->val.msg_settings.punctuation_mode;
#line 318
    MSG(4, "parameter msg_settings.punctuation_mode set to %d", (unsigned int )cl_set->val.msg_settings.punctuation_mode);
    }
  }
#line 319
  if ((unsigned int )cl_set->val.msg_settings.spelling_mode != 4294967295U) {
    {
#line 319
    set->msg_settings.spelling_mode = cl_set->val.msg_settings.spelling_mode;
#line 319
    MSG(4, "parameter msg_settings.spelling_mode set to %d", (unsigned int )cl_set->val.msg_settings.spelling_mode);
    }
  }
#line 320
  if ((int )cl_set->val.msg_settings.voice_type != -1) {
    {
#line 320
    set->msg_settings.voice_type = cl_set->val.msg_settings.voice_type;
#line 320
    MSG(4, "parameter msg_settings.voice_type set to %d", (int )cl_set->val.msg_settings.voice_type);
    }
  }
#line 321
  if ((unsigned int )cl_set->val.msg_settings.cap_let_recogn != 4294967295U) {
    {
#line 321
    set->msg_settings.cap_let_recogn = cl_set->val.msg_settings.cap_let_recogn;
#line 321
    MSG(4, "parameter msg_settings.cap_let_recogn set to %d", (unsigned int )cl_set->val.msg_settings.cap_let_recogn);
    }
  }
#line 322
  if (cl_set->val.pause_context != -1) {
    {
#line 322
    set->pause_context = cl_set->val.pause_context;
#line 322
    MSG(4, "parameter pause_context set to %d", cl_set->val.pause_context);
    }
  }
#line 323
  if ((unsigned int )cl_set->val.ssml_mode != 4294967295U) {
    {
#line 323
    set->ssml_mode = cl_set->val.ssml_mode;
#line 323
    MSG(4, "parameter ssml_mode set to %d", (unsigned int )cl_set->val.ssml_mode);
    }
  }
#line 324
  if (cl_set->val.symbols_preprocessing != -1) {
    {
#line 324
    set->symbols_preprocessing = cl_set->val.symbols_preprocessing;
#line 324
    MSG(4, "parameter symbols_preprocessing set to %d", cl_set->val.symbols_preprocessing);
    }
  }
#line 325
  if (cl_set->val.msg_settings.voice.language != (void *)0) {
    {
#line 325
    g_free(set->msg_settings.voice.language);
#line 325
    set->msg_settings.voice.language = g_strdup(cl_set->val.msg_settings.voice.language);
#line 325
    MSG(4, "parameter msg_settings.voice.language set to %s", cl_set->val.msg_settings.voice.language);
    }
  }
#line 326
  if (cl_set->val.output_module != (void *)0) {
    {
#line 326
    g_free(set->output_module);
#line 326
    set->output_module = g_strdup(cl_set->val.output_module);
#line 326
    MSG(4, "parameter output_module set to %s", cl_set->val.output_module);
    }
  }
#line 328
  return;
}
}
#line 334 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_client_name_self(int fd , char const   *client_name ) 
{ 
  TFDSetElement *settings ;
  int dividers ;
  int i ;
  int tmp ;
  TFDSetElement *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 337
  dividers = 0;
#line 342
  settings = get_client_settings_by_fd(fd);
  }
#line 343
  if (settings == (void *)0) {
#line 344
    return (1);
  }
#line 347
  i = 0;
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! ((unsigned long )i <= __cil_tmp8 - 1UL)) {
#line 347
      goto while_break;
    }
#line 348
    if ((int )*(client_name + i) == 58) {
#line 349
      dividers ++;
    }
#line 347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (dividers != 2) {
#line 351
    return (1);
  }
  {
#line 353
  settings->client_name = set_param_str(settings->client_name, client_name);
#line 356
  g_list_foreach(client_specific_settings, & update_cl_settings, settings);
  }
#line 358
  return (0);
}
}
#line 361 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_output_module_self(int fd , char const   *output_module ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 361
  uid = get_client_uid_by_fd(fd);
  }
#line 361
  if (uid == 0) {
#line 361
    return (1);
  }
  {
#line 361
  __cil_tmp5 = set_output_module_uid(uid, output_module);
  }
#line 361
  return (__cil_tmp5);
}
}
#line 361 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_output_module_all(char const   *output_module ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 361
  err = 0;
#line 361
  i = 1;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i <= SpeechdStatus.max_fd)) {
#line 361
      goto while_break;
    }
    {
#line 361
    uid = get_client_uid_by_fd(i);
    }
#line 361
    if (uid == 0) {
#line 361
      goto while_continue;
    }
    {
#line 361
    __cil_tmp6 = set_output_module_uid(uid, output_module);
    }
#line 361
    err += __cil_tmp6;
#line 361
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  if (err > 0) {
#line 361
    return (1);
  }
#line 361
  return (0);
}
}
#line 363 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_output_module_uid(int uid , char const   *output_module ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 367
  settings = get_client_settings_by_uid(uid);
  }
#line 368
  if (settings == (void *)0) {
#line 369
    return (1);
  }
#line 370
  if (output_module == (void *)0) {
#line 371
    return (1);
  }
  {
#line 373
  MSG(5, "Setting output module to %s\377\332U", output_module);
#line 375
  MSG(5, "In set_output_module the desired output module is x%s", output_module);
#line 378
  settings->output_module = set_param_str(settings->output_module, output_module);
  }
#line 381
  if (settings->msg_settings.voice.name != (void *)0) {
    {
#line 382
    g_free(settings->msg_settings.voice.name);
#line 383
    settings->msg_settings.voice.name = (char *)((void *)0);
    }
  }
#line 386
  return (0);
}
}
#line 389 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pause_context_self(int fd , int pause_context ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 389
  uid = get_client_uid_by_fd(fd);
  }
#line 389
  if (uid == 0) {
#line 389
    return (1);
  }
  {
#line 389
  __cil_tmp5 = set_pause_context_uid(uid, pause_context);
  }
#line 389
  return (__cil_tmp5);
}
}
#line 389 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pause_context_all(int pause_context ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 389
  err = 0;
#line 389
  i = 1;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (i <= SpeechdStatus.max_fd)) {
#line 389
      goto while_break;
    }
    {
#line 389
    uid = get_client_uid_by_fd(i);
    }
#line 389
    if (uid == 0) {
#line 389
      goto while_continue;
    }
    {
#line 389
    __cil_tmp6 = set_pause_context_uid(uid, pause_context);
    }
#line 389
    err += __cil_tmp6;
#line 389
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (err > 0) {
#line 389
    return (1);
  }
#line 389
  return (0);
}
}
#line 391 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_pause_context_uid(int uid , int pause_context ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
  {
#line 395
  settings = get_client_settings_by_uid(uid);
  }
#line 396
  if (settings == (void *)0) {
#line 397
    return (1);
  }
#line 399
  settings->pause_context = pause_context;
#line 400
  return (0);
}
}
#line 403 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_ssml_mode_self(int fd , SPDDataMode ssml_mode ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 403
  uid = get_client_uid_by_fd(fd);
  }
#line 403
  if (uid == 0) {
#line 403
    return (1);
  }
  {
#line 403
  __cil_tmp5 = set_ssml_mode_uid(uid, ssml_mode);
  }
#line 403
  return (__cil_tmp5);
}
}
#line 403 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_ssml_mode_all(SPDDataMode ssml_mode ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 403
  err = 0;
#line 403
  i = 1;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i <= SpeechdStatus.max_fd)) {
#line 403
      goto while_break;
    }
    {
#line 403
    uid = get_client_uid_by_fd(i);
    }
#line 403
    if (uid == 0) {
#line 403
      goto while_continue;
    }
    {
#line 403
    __cil_tmp6 = set_ssml_mode_uid(uid, ssml_mode);
    }
#line 403
    err += __cil_tmp6;
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  if (err > 0) {
#line 403
    return (1);
  }
#line 403
  return (0);
}
}
#line 405 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_ssml_mode_uid(int uid , SPDDataMode ssml_mode ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
  {
#line 409
  settings = get_client_settings_by_uid(uid);
  }
#line 410
  if (settings == (void *)0) {
#line 411
    return (1);
  }
#line 413
  settings->ssml_mode = ssml_mode;
#line 414
  return (0);
}
}
#line 417 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_symbols_preprocessing_self(int fd , gboolean symbols_preprocessing ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 417
  uid = get_client_uid_by_fd(fd);
  }
#line 417
  if (uid == 0) {
#line 417
    return (1);
  }
  {
#line 417
  __cil_tmp5 = set_symbols_preprocessing_uid(uid, symbols_preprocessing);
  }
#line 417
  return (__cil_tmp5);
}
}
#line 417 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_symbols_preprocessing_all(gboolean symbols_preprocessing ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 417
  err = 0;
#line 417
  i = 1;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (i <= SpeechdStatus.max_fd)) {
#line 417
      goto while_break;
    }
    {
#line 417
    uid = get_client_uid_by_fd(i);
    }
#line 417
    if (uid == 0) {
#line 417
      goto while_continue;
    }
    {
#line 417
    __cil_tmp6 = set_symbols_preprocessing_uid(uid, symbols_preprocessing);
    }
#line 417
    err += __cil_tmp6;
#line 417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  if (err > 0) {
#line 417
    return (1);
  }
#line 417
  return (0);
}
}
#line 419 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_symbols_preprocessing_uid(int uid , gboolean symbols_preprocessing ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;

  {
  {
#line 423
  settings = get_client_settings_by_uid(uid);
  }
#line 424
  if (settings == (void *)0) {
#line 425
    return (1);
  }
#line 427
  settings->symbols_preprocessing = symbols_preprocessing;
#line 428
  return (0);
}
}
#line 431 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_debug_self(int fd , int debug ) 
{ 
  int uid ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 431
  uid = get_client_uid_by_fd(fd);
  }
#line 431
  if (uid == 0) {
#line 431
    return (1);
  }
  {
#line 431
  __cil_tmp5 = set_debug_uid(uid, debug);
  }
#line 431
  return (__cil_tmp5);
}
}
#line 431 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_debug_all(int debug ) 
{ 
  int i ;
  int uid ;
  int err ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 431
  err = 0;
#line 431
  i = 1;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i <= SpeechdStatus.max_fd)) {
#line 431
      goto while_break;
    }
    {
#line 431
    uid = get_client_uid_by_fd(i);
    }
#line 431
    if (uid == 0) {
#line 431
      goto while_continue;
    }
    {
#line 431
    __cil_tmp6 = set_debug_uid(uid, debug);
    }
#line 431
    err += __cil_tmp6;
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  if (err > 0) {
#line 431
    return (1);
  }
#line 431
  return (0);
}
}
#line 433 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_debug_uid(int uid , int debug ) 
{ 
  char *debug_logfile_path ;
  gchar *__cil_tmp4 ;
  FILE *__cil_tmp5 ;

  {
#line 439
  if (SpeechdOptions.debug) {
#line 439
    if (debug) {
#line 440
      return (1);
    }
  }
#line 441
  if (! SpeechdOptions.debug) {
#line 441
    if (! debug) {
#line 442
      return (1);
    }
  }
#line 444
  if (debug) {
    {
#line 445
    debug_logfile_path = g_strdup_printf((gchar *)"%s/speech-dispatcher.log\230\001",
                                         SpeechdOptions.debug_destination);
#line 449
    debug_logfile = fopen((char const   *)debug_logfile_path, "w");
    }
#line 450
    if (debug_logfile == (void *)0) {
      {
#line 451
      MSG(3, "Error: can\'t open additional debug logging file %s!\n", debug_logfile_path);
      }
#line 454
      return (1);
    }
    {
#line 456
    SpeechdOptions.debug = debug;
#line 458
    g_free(debug_logfile_path);
#line 461
    speechd_modules_debug();
    }
  } else {
    {
#line 463
    SpeechdOptions.debug = 0;
#line 464
    speechd_modules_nodebug();
#line 465
    fclose(debug_logfile);
    }
  }
#line 467
  return (0);
}
}
#line 476 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int set_notification_self(int fd , char const   *type , int val ) 
{ 
  TFDSetElement *settings ;
  int uid ;
  int __cil_tmp6 ;
  TFDSetElement *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
  {
#line 481
  uid = get_client_uid_by_fd(fd);
  }
#line 482
  if (uid == 0) {
#line 483
    return (1);
  }
  {
#line 485
  settings = get_client_settings_by_uid(uid);
  }
#line 486
  if (settings == (void *)0) {
#line 487
    return (1);
  }
  {
#line 489
  __cil_tmp8 = strcmp(type, "begin");
  }
#line 489
  if (! __cil_tmp8) {
#line 490
    if (val) {
#line 490
      settings->notification = (SPDNotification )((unsigned int )settings->notification | 1U);
    } else {
#line 490
      settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967294U);
    }

  } else {
    {
#line 491
    __cil_tmp9 = strcmp(type, "end");
    }
#line 491
    if (! __cil_tmp9) {
#line 492
      if (val) {
#line 492
        settings->notification = (SPDNotification )((unsigned int )settings->notification | 2U);
      } else {
#line 492
        settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967293U);
      }

    } else {
      {
#line 493
      __cil_tmp10 = strcmp(type, "index_marks{\332U");
      }
#line 493
      if (! __cil_tmp10) {
#line 494
        if (val) {
#line 494
          settings->notification = (SPDNotification )((unsigned int )settings->notification | 4U);
        } else {
#line 494
          settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967291U);
        }

      } else {
        {
#line 495
        __cil_tmp11 = strcmp(type, "pause");
        }
#line 495
        if (! __cil_tmp11) {
#line 496
          if (val) {
#line 496
            settings->notification = (SPDNotification )((unsigned int )settings->notification | 16U);
          } else {
#line 496
            settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967279U);
          }

        } else {
          {
#line 497
          __cil_tmp12 = strcmp(type, "resume");
          }
#line 497
          if (! __cil_tmp12) {
#line 498
            if (val) {
#line 498
              settings->notification = (SPDNotification )((unsigned int )settings->notification | 32U);
            } else {
#line 498
              settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967263U);
            }

          } else {
            {
#line 499
            __cil_tmp13 = strcmp(type, "cancel");
            }
#line 499
            if (! __cil_tmp13) {
#line 500
              if (val) {
#line 500
                settings->notification = (SPDNotification )((unsigned int )settings->notification | 8U);
              } else {
#line 500
                settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967287U);
              }

            } else {
              {
#line 501
              __cil_tmp14 = strcmp(type, "all");
              }
#line 501
              if (! __cil_tmp14) {
#line 502
                if (val) {
#line 502
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 2U);
                } else {
#line 502
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967293U);
                }

#line 503
                if (val) {
#line 503
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 1U);
                } else {
#line 503
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967294U);
                }

#line 504
                if (val) {
#line 504
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 4U);
                } else {
#line 504
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967291U);
                }

#line 505
                if (val) {
#line 505
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 8U);
                } else {
#line 505
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967287U);
                }

#line 506
                if (val) {
#line 506
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 16U);
                } else {
#line 506
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967279U);
                }

#line 507
                if (val) {
#line 507
                  settings->notification = (SPDNotification )((unsigned int )settings->notification | 32U);
                } else {
#line 507
                  settings->notification = (SPDNotification )((unsigned int )settings->notification & 4294967263U);
                }

              } else {
#line 509
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 511
  return (0);
}
}
#line 515 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
TFDSetElement *default_fd_set(void) 
{ 
  TFDSetElement *new ;
  gpointer __cil_tmp2 ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  gchar *__cil_tmp9 ;
  gchar *__cil_tmp10 ;
  gchar *__cil_tmp11 ;
  gchar *__cil_tmp12 ;

  {
  {
#line 519
  __cil_tmp2 = g_malloc(sizeof(TFDSetElement ));
#line 519
  new = (TFDSetElement *)__cil_tmp2;
#line 521
  new->paused = 0;
#line 526
  new->priority = GlobalFDSet.priority;
#line 527
  new->msg_settings.punctuation_mode = GlobalFDSet.msg_settings.punctuation_mode;
#line 529
  new->msg_settings.rate = GlobalFDSet.msg_settings.rate;
#line 530
  new->msg_settings.pitch = GlobalFDSet.msg_settings.pitch;
#line 531
  new->msg_settings.pitch_range = GlobalFDSet.msg_settings.pitch_range;
#line 532
  new->msg_settings.volume = GlobalFDSet.msg_settings.volume;
#line 533
  new->msg_settings.voice.language = g_strdup(GlobalFDSet.msg_settings.voice.language);
#line 535
  new->output_module = g_strdup(GlobalFDSet.output_module);
#line 536
  new->client_name = g_strdup(GlobalFDSet.client_name);
#line 537
  new->index_mark = g_strdup(GlobalFDSet.index_mark);
#line 538
  new->audio_output_method = g_strdup(GlobalFDSet.audio_output_method);
#line 539
  new->audio_oss_device = g_strdup(GlobalFDSet.audio_oss_device);
#line 540
  new->audio_alsa_device = g_strdup(GlobalFDSet.audio_alsa_device);
#line 541
  new->audio_nas_server = g_strdup(GlobalFDSet.audio_nas_server);
#line 542
  new->audio_pulse_server = g_strdup(GlobalFDSet.audio_pulse_server);
#line 543
  new->audio_pulse_device = g_strdup(GlobalFDSet.audio_pulse_device);
#line 545
  new->msg_settings.voice_type = GlobalFDSet.msg_settings.voice_type;
#line 546
  new->msg_settings.voice.name = (char *)((void *)0);
#line 547
  new->msg_settings.spelling_mode = GlobalFDSet.msg_settings.spelling_mode;
#line 549
  new->msg_settings.cap_let_recogn = GlobalFDSet.msg_settings.cap_let_recogn;
#line 552
  new->pause_context = GlobalFDSet.pause_context;
#line 553
  new->ssml_mode = GlobalFDSet.ssml_mode;
#line 554
  new->symbols_preprocessing = GlobalFDSet.symbols_preprocessing;
#line 555
  new->notification = GlobalFDSet.notification;
#line 557
  new->active = 1;
#line 558
  new->hist_cur_uid = (unsigned int )(- 1);
#line 559
  new->hist_cur_pos = - 1;
#line 560
  new->hist_sorted = (ESort )0;
#line 561
  new->index_mark = (char *)((void *)0);
#line 562
  new->paused_while_speaking = 0;
  }
#line 564
  return (new);
}
}
#line 567 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
int get_client_uid_by_fd(int fd ) 
{ 
  int *uid ;
  gpointer __cil_tmp3 ;

  {
#line 570
  if (fd <= 0) {
#line 571
    return (0);
  }
  {
#line 572
  uid = (int *)g_hash_table_lookup(fd_uid, & fd);
  }
#line 573
  if (uid == (void *)0) {
#line 574
    return (0);
  }
#line 575
  return (*uid);
}
}
#line 578 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
TFDSetElement *get_client_settings_by_fd(int fd ) 
{ 
  TFDSetElement *settings ;
  int uid ;
  int __cil_tmp4 ;
  gpointer __cil_tmp5 ;

  {
  {
#line 583
  uid = get_client_uid_by_fd(fd);
  }
#line 584
  if (uid == 0) {
#line 585
    return ((TFDSetElement *)((void *)0));
  }
  {
#line 587
  settings = (TFDSetElement *)g_hash_table_lookup(fd_settings, & uid);
  }
#line 588
  return (settings);
}
}
#line 591 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
TFDSetElement *get_client_settings_by_uid(int uid ) 
{ 
  TFDSetElement *element ;
  gpointer __cil_tmp3 ;

  {
#line 595
  if (uid < 0) {
#line 596
    return ((TFDSetElement *)((void *)0));
  }
  {
#line 598
  element = (TFDSetElement *)g_hash_table_lookup(fd_settings, & uid);
  }
#line 599
  return (element);
}
}
#line 602 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
void remove_client_settings_by_uid(int uid ) 
{ 
  TFDSetElement *element ;
  int tmp ;
  gpointer __cil_tmp4 ;

  {
  {
#line 606
  __cil_tmp4 = g_hash_table_lookup(fd_settings, & uid);
#line 606
  element = (TFDSetElement *)__cil_tmp4;
  }
#line 607
  if (element) {
    {
#line 608
    mem_free_fdset(element);
#line 609
    g_hash_table_remove(fd_settings, & uid);
#line 610
    g_free(element);
    }
  } else {
    {
#line 612
    MSG(5, "Warning: FDSet element to be removed not found");
    }
  }
  return;
}
}
#line 616 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/set.c"
char *set_param_str(char *parameter , char const   *value ) 
{ 
  char *new ;
  unsigned long __cil_tmp4 ;
  gpointer __cil_tmp5 ;

  {
#line 620
  if (value == (void *)0) {
#line 621
    new = (char *)((void *)0);
#line 622
    return (new);
  }
  {
#line 625
  __cil_tmp4 = strlen(value);
#line 625
  __cil_tmp5 = g_realloc(parameter, (__cil_tmp4 + 1UL) * sizeof(char ));
#line 625
  new = __cil_tmp5;
#line 626
  strcpy(new, value);
  }
#line 628
  return (new);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 135
extern  __attribute__((__nothrow__)) int isctype(int __c , int __mask ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 63 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse(char const   *buf , int bytes , int fd ) 
{ 
  TSpeechDMessage *new ;
  char *command ;
  int end_data ;
  char *pos ;
  int reparted ;
  int msg_uid ;
  GString *ok_queued_reply ;
  char *reply ;
  TSpeechDSock *speechd_socket ;
  TSpeechDSock *__cil_tmp13 ;
  int tmp ;
  gchar *__cil_tmp15 ;
  char *__cil_tmp16 ;
  gchar *__cil_tmp17 ;
  int __cil_tmp18 ;
  gchar *__cil_tmp19 ;
  char *__cil_tmp20 ;
  int __cil_tmp21 ;
  gchar *__cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  gchar *__cil_tmp25 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  gchar *__cil_tmp28 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  gchar *__cil_tmp31 ;
  char *__cil_tmp32 ;
  int __cil_tmp33 ;
  gchar *__cil_tmp34 ;
  char *__cil_tmp35 ;
  int __cil_tmp36 ;
  gchar *__cil_tmp37 ;
  char *__cil_tmp38 ;
  int __cil_tmp39 ;
  gchar *__cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;
  gchar *__cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  gchar *__cil_tmp46 ;
  char *__cil_tmp47 ;
  int __cil_tmp48 ;
  gchar *__cil_tmp49 ;
  char *__cil_tmp50 ;
  int __cil_tmp51 ;
  gchar *__cil_tmp52 ;
  char *__cil_tmp53 ;
  int __cil_tmp54 ;
  gchar *__cil_tmp55 ;
  char *__cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  ssize_t __cil_tmp60 ;
  int *__cil_tmp61 ;
  char *__cil_tmp62 ;
  gchar *__cil_tmp63 ;
  int __cil_tmp64 ;
  gchar *__cil_tmp65 ;
  gchar *__cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  gchar *__cil_tmp69 ;
  gboolean __cil_tmp70 ;
  gchar *__cil_tmp71 ;
  gpointer __cil_tmp72 ;
  int tmp___0 ;
  char *__cil_tmp74 ;
  int __cil_tmp75 ;
  gchar *__cil_tmp76 ;
  GString *__cil_tmp77 ;
  int real_bytes ;
  char *__cil_tmp79 ;
  gchar *__cil_tmp80 ;

  {
  {
#line 73
  __cil_tmp13 = speechd_socket_get_by_fd(fd);
#line 73
  speechd_socket = __cil_tmp13;
#line 76
  end_data = 0;
  }
#line 77
  if (buf == (void *)0) {
    _L: /* CIL Label */ 
#line 78
    if (0) {
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 79
        fatal_error();
#line 79
        MSG(- 1, "Fatal error [%s:%d]:invalid buffer for parse()\n", "./src/server/parse.c",
            79);
#line 79
        exit(1);
        }
#line 79
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 80
    __cil_tmp15 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
    }
#line 80
    return (__cil_tmp15);
  } else
#line 77
  if (bytes == 0) {
#line 77
    goto _L;
  }
#line 85
  if (speechd_socket->awaiting_data == 0) {
    {
#line 87
    command = get_param(buf, 0, bytes, 1);
#line 89
    MSG(5, "Command caught: \"%s\"", command);
    }
#line 94
    if (command == (void *)0) {
#line 95
      if (0) {
        {
#line 96
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 96
          fatal_error();
#line 96
          MSG(- 1, "Fatal error [%s:%d]:Invalid buffer for parse()\n", "./src/server/parse.c",
              96);
#line 96
          exit(1);
          }
#line 96
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 97
      __cil_tmp17 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
      }
#line 97
      return (__cil_tmp17);
    }
    {
#line 100
    __cil_tmp18 = strcmp((char const   *)command, "set");
    }
#line 100
    if (! __cil_tmp18) {
      {
#line 100
      g_free(command);
      }
#line 100
      if (0) {
        {
#line 100
        __cil_tmp19 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 100
        return (__cil_tmp19);
      }
      {
#line 100
      __cil_tmp20 = parse_set(buf, bytes, fd, speechd_socket);
      }
#line 100
      return ((char *)__cil_tmp20);
    }
    {
#line 101
    __cil_tmp21 = strcmp((char const   *)command, "history");
    }
#line 101
    if (! __cil_tmp21) {
      {
#line 101
      g_free(command);
      }
#line 101
      if (speechd_socket->inside_block) {
        {
#line 101
        __cil_tmp22 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 101
        return (__cil_tmp22);
      }
      {
#line 101
      __cil_tmp23 = parse_history(buf, bytes, fd, speechd_socket);
      }
#line 101
      return ((char *)__cil_tmp23);
    }
    {
#line 102
    __cil_tmp24 = strcmp((char const   *)command, "stop");
    }
#line 102
    if (! __cil_tmp24) {
      {
#line 102
      g_free(command);
      }
#line 102
      if (speechd_socket->inside_block) {
        {
#line 102
        __cil_tmp25 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 102
        return (__cil_tmp25);
      }
      {
#line 102
      __cil_tmp26 = parse_stop(buf, bytes, fd, speechd_socket);
      }
#line 102
      return ((char *)__cil_tmp26);
    }
    {
#line 103
    __cil_tmp27 = strcmp((char const   *)command, "cancel");
    }
#line 103
    if (! __cil_tmp27) {
      {
#line 103
      g_free(command);
      }
#line 103
      if (speechd_socket->inside_block) {
        {
#line 103
        __cil_tmp28 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 103
        return (__cil_tmp28);
      }
      {
#line 103
      __cil_tmp29 = parse_cancel(buf, bytes, fd, speechd_socket);
      }
#line 103
      return ((char *)__cil_tmp29);
    }
    {
#line 104
    __cil_tmp30 = strcmp((char const   *)command, "pause");
    }
#line 104
    if (! __cil_tmp30) {
      {
#line 104
      g_free(command);
      }
#line 104
      if (speechd_socket->inside_block) {
        {
#line 104
        __cil_tmp31 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 104
        return (__cil_tmp31);
      }
      {
#line 104
      __cil_tmp32 = parse_pause(buf, bytes, fd, speechd_socket);
      }
#line 104
      return ((char *)__cil_tmp32);
    }
    {
#line 105
    __cil_tmp33 = strcmp((char const   *)command, "resume");
    }
#line 105
    if (! __cil_tmp33) {
      {
#line 105
      g_free(command);
      }
#line 105
      if (speechd_socket->inside_block) {
        {
#line 105
        __cil_tmp34 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 105
        return (__cil_tmp34);
      }
      {
#line 105
      __cil_tmp35 = parse_resume(buf, bytes, fd, speechd_socket);
      }
#line 105
      return ((char *)__cil_tmp35);
    }
    {
#line 106
    __cil_tmp36 = strcmp((char const   *)command, "sound_icon");
    }
#line 106
    if (! __cil_tmp36) {
      {
#line 106
      g_free(command);
      }
#line 106
      if (0) {
        {
#line 106
        __cil_tmp37 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 106
        return (__cil_tmp37);
      }
      {
#line 106
      __cil_tmp38 = parse_snd_icon(buf, bytes, fd, speechd_socket);
      }
#line 106
      return ((char *)__cil_tmp38);
    }
    {
#line 107
    __cil_tmp39 = strcmp((char const   *)command, "char");
    }
#line 107
    if (! __cil_tmp39) {
      {
#line 107
      g_free(command);
      }
#line 107
      if (0) {
        {
#line 107
        __cil_tmp40 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 107
        return (__cil_tmp40);
      }
      {
#line 107
      __cil_tmp41 = parse_char(buf, bytes, fd, speechd_socket);
      }
#line 107
      return ((char *)__cil_tmp41);
    }
    {
#line 108
    __cil_tmp42 = strcmp((char const   *)command, "key");
    }
#line 108
    if (! __cil_tmp42) {
      {
#line 108
      g_free(command);
      }
#line 108
      if (0) {
        {
#line 108
        __cil_tmp43 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 108
        return (__cil_tmp43);
      }
      {
#line 108
      __cil_tmp44 = parse_key(buf, bytes, fd, speechd_socket);
      }
#line 108
      return ((char *)__cil_tmp44);
    }
    {
#line 109
    __cil_tmp45 = strcmp((char const   *)command, "list");
    }
#line 109
    if (! __cil_tmp45) {
      {
#line 109
      g_free(command);
      }
#line 109
      if (speechd_socket->inside_block) {
        {
#line 109
        __cil_tmp46 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 109
        return (__cil_tmp46);
      }
      {
#line 109
      __cil_tmp47 = parse_list(buf, bytes, fd, speechd_socket);
      }
#line 109
      return ((char *)__cil_tmp47);
    }
    {
#line 110
    __cil_tmp48 = strcmp((char const   *)command, "get");
    }
#line 110
    if (! __cil_tmp48) {
      {
#line 110
      g_free(command);
      }
#line 110
      if (speechd_socket->inside_block) {
        {
#line 110
        __cil_tmp49 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 110
        return (__cil_tmp49);
      }
      {
#line 110
      __cil_tmp50 = parse_get(buf, bytes, fd, speechd_socket);
      }
#line 110
      return ((char *)__cil_tmp50);
    }
    {
#line 111
    __cil_tmp51 = strcmp((char const   *)command, "help");
    }
#line 111
    if (! __cil_tmp51) {
      {
#line 111
      g_free(command);
      }
#line 111
      if (speechd_socket->inside_block) {
        {
#line 111
        __cil_tmp52 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 111
        return (__cil_tmp52);
      }
      {
#line 111
      __cil_tmp53 = parse_help(buf, bytes, fd, speechd_socket);
      }
#line 111
      return ((char *)__cil_tmp53);
    }
    {
#line 112
    __cil_tmp54 = strcmp((char const   *)command, "block");
    }
#line 112
    if (! __cil_tmp54) {
      {
#line 112
      g_free(command);
      }
#line 112
      if (0) {
        {
#line 112
        __cil_tmp55 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
        }
#line 112
        return (__cil_tmp55);
      }
      {
#line 112
      __cil_tmp56 = parse_block(buf, bytes, fd, speechd_socket);
      }
#line 112
      return ((char *)__cil_tmp56);
    }
    {
#line 114
    __cil_tmp58 = strcmp((char const   *)command, "quit");
    }
    {
#line 114
    __cil_tmp57 = strcmp((char const   *)command, "bye");
    }
#line 114
    if (! __cil_tmp57) {
      _L___13: /* CIL Label */ 
      {
#line 115
      MSG(4, "Bye received.");
#line 117
      __cil_tmp59 = strlen("231 HAPPY HACKING\r\n");
#line 117
      __cil_tmp60 = write(fd, "231 HAPPY HACKING\r\n", __cil_tmp59);
      }
#line 117
      if (__cil_tmp60) {
        {
#line 118
        __cil_tmp61 = __errno_location();
#line 118
        __cil_tmp62 = strerror(*__cil_tmp61);
#line 118
        MSG(2, "ERROR: Can\'t write OK_BYE message to client socket: %s", __cil_tmp62);
        }
      }
      {
#line 123
      speechd_connection_destroy(fd);
#line 125
      g_free(command);
#line 126
      __cil_tmp63 = g_strdup((gchar *)"999 CLIENT GONE");
      }
#line 126
      return (__cil_tmp63);
    } else
#line 114
    if (! __cil_tmp58) {
#line 114
      goto _L___13;
    }
    {
#line 129
    __cil_tmp64 = strcmp((char const   *)command, "speak");
    }
#line 129
    if (! __cil_tmp64) {
      {
#line 130
      g_free(command);
#line 134
      server_data_on(fd);
#line 135
      __cil_tmp65 = g_strdup((gchar *)"230 OK RECEIVING DATA\r\n");
      }
#line 135
      return (__cil_tmp65);
    }
    {
#line 137
    g_free(command);
#line 138
    __cil_tmp66 = g_strdup((gchar *)"500 ERR INVALID COMMAND\r\n");
    }
#line 138
    return (__cil_tmp66);
  } else {
    enddata: 
    {
#line 145
    MSG(5, "Buffer: |%s| %d bytes:", buf, bytes);
    }
    {
#line 147
    __cil_tmp68 = strncmp(buf, ".\r\n", (unsigned long )bytes);
    }
    {
#line 147
    __cil_tmp67 = strncmp(buf, "\r\n.\r\n", (unsigned long )bytes);
    }
#line 147
    if (bytes >= 5) {
#line 147
      if (! __cil_tmp67) {
        _L___14: /* CIL Label */ 
        _L___15: /* CIL Label */ 
        {
#line 151
        MSG(5, "Finishing data");
#line 152
        end_data = 0;
#line 155
        MSG(5, "Switching back to command mode...");
#line 156
        speechd_socket->awaiting_data = 0;
        }
#line 161
        if (bytes == 3) {
#line 161
          if (speechd_socket->o_bytes > 2UL) {
#line 162
            speechd_socket->o_bytes -= (unsigned long )2;
          }
        }
#line 165
        if (speechd_socket->o_bytes == 0UL) {
          {
#line 166
          __cil_tmp69 = g_strdup((gchar *)"227 OK MESSAGE CANCELED\r\n");
          }
#line 166
          return (__cil_tmp69);
        }
        {
#line 169
        __cil_tmp70 = g_utf8_validate((speechd_socket->o_buf)->str, (gssize )speechd_socket->o_bytes,
                                      (gchar **)((void *)0));
        }
#line 169
        if (! __cil_tmp70) {
          {
#line 172
          MSG(4, "ERROR: Invalid character encoding on input (failed UTF-8 validation)");
#line 174
          MSG(4, "Rejecting this message.");
#line 175
          __cil_tmp71 = g_strdup((gchar *)"501 ERR INVALID ENCODING\r\n");
          }
#line 175
          return (__cil_tmp71);
        }
        {
#line 178
        __cil_tmp72 = g_malloc(sizeof(TSpeechDMessage ));
#line 178
        new = (TSpeechDMessage *)__cil_tmp72;
#line 181
        new->bytes = (int )speechd_socket->o_bytes;
#line 183
        new->buf = deescape_dot((char const   *)(speechd_socket->o_buf)->str, (size_t )new->bytes);
#line 186
        reparted = speechd_socket->inside_block;
#line 187
        MSG(5, "New buf is now: |%s|", new->buf);
#line 188
        msg_uid = queue_message(new, fd, 1, (SPDMessageType )0, reparted);
        }
#line 188
        if (msg_uid == 0) {
#line 191
          if (0) {
            {
#line 192
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 192
              fatal_error();
#line 192
              MSG(- 1, "Fatal error [%s:%d]:Can\'t queue message\n", "./src/server/parse.c",
                  192);
#line 192
              exit(1);
              }
#line 192
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
          {
#line 193
          g_free(new->buf);
#line 194
          g_free(new);
#line 195
          __cil_tmp76 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
          }
#line 195
          return (__cil_tmp76);
        }
        {
#line 199
        server_data_off(fd);
#line 200
        ok_queued_reply = g_string_new((gchar *)" X$\177\332U");
#line 201
        g_string_printf(ok_queued_reply, (gchar *)"225-%d\r\n225 OK MESSAGE QUEUED\r\n",
                        msg_uid);
#line 204
        reply = ok_queued_reply->str;
#line 205
        g_string_free(ok_queued_reply, 0);
        }
#line 206
        return (reply);
      } else {
#line 147
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 147
    if (end_data == 1) {
#line 147
      goto _L___14;
    } else
#line 147
    if (bytes == 3) {
#line 147
      if (! __cil_tmp68) {
#line 147
        goto _L___14;
      }
    }
#line 211
    if (bytes >= 5) {
      {
#line 212
      pos = strstr(buf, "\r\n.\r\n");
      }
#line 212
      if (pos) {
        {
#line 213
        real_bytes = (int )(pos - buf);
#line 214
        end_data = 1;
#line 215
        MSG(5, "Command in data caught");
        }
      } else {
#line 217
        real_bytes = bytes;
      }
    } else {
#line 220
      real_bytes = bytes;
    }
    {
#line 224
    speechd_socket->o_bytes += (unsigned long )real_bytes;
#line 226
    g_string_insert_len(speechd_socket->o_buf, (gssize )(- 1), buf, (gssize )real_bytes);
    }
  }
#line 231
  if (end_data == 1) {
#line 232
    goto enddata;
  }
  {
#line 235
  __cil_tmp80 = g_strdup((gchar *)"999 DATA\220");
  }
#line 235
  return (__cil_tmp80);
}
}
#line 273 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_history(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *cmd_main ;
  char *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  char *hist_get_sub ;
  char *__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___0 ;
  gchar *__cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp___1 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp___2 ;
  int start ;
  int num ;
  char *who ;
  int who_id ;
  int client_id ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  gchar *__cil_tmp28 ;
  int __cil_tmp29 ;
  gchar *__cil_tmp30 ;
  int __cil_tmp31 ;
  gchar *__cil_tmp32 ;
  int __cil_tmp33 ;
  gchar *__cil_tmp34 ;
  int __cil_tmp35 ;
  gchar *__cil_tmp36 ;
  char *helper ;
  char *__cil_tmp38 ;
  gchar *__cil_tmp39 ;
  int __cil_tmp40 ;
  gchar *__cil_tmp41 ;
  int __cil_tmp42 ;
  char *helper___0 ;
  char *__cil_tmp44 ;
  gchar *__cil_tmp45 ;
  int __cil_tmp46 ;
  gchar *__cil_tmp47 ;
  int __cil_tmp48 ;
  char *__cil_tmp49 ;
  int __cil_tmp50 ;
  int tmp___3 ;
  char *__cil_tmp52 ;
  int __cil_tmp53 ;
  int tmp___4 ;
  int msg_id ;
  char *helper___1 ;
  char *__cil_tmp57 ;
  gchar *__cil_tmp58 ;
  int __cil_tmp59 ;
  gchar *__cil_tmp60 ;
  int __cil_tmp61 ;
  char *__cil_tmp62 ;
  gchar *__cil_tmp63 ;
  int __cil_tmp64 ;
  int tmp___5 ;
  char *hist_cur_sub ;
  char *__cil_tmp67 ;
  gchar *__cil_tmp68 ;
  int __cil_tmp69 ;
  int tmp___6 ;
  int who___0 ;
  char *location ;
  char *helper___2 ;
  char *__cil_tmp74 ;
  gchar *__cil_tmp75 ;
  int __cil_tmp76 ;
  gchar *__cil_tmp77 ;
  int __cil_tmp78 ;
  char *__cil_tmp79 ;
  gchar *__cil_tmp80 ;
  int __cil_tmp81 ;
  int tmp___7 ;
  char *__cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___8 ;
  char *__cil_tmp86 ;
  int __cil_tmp87 ;
  int tmp___9 ;
  int pos ;
  char *helper___3 ;
  char *__cil_tmp91 ;
  gchar *__cil_tmp92 ;
  int __cil_tmp93 ;
  gchar *__cil_tmp94 ;
  int __cil_tmp95 ;
  char *__cil_tmp96 ;
  gchar *__cil_tmp97 ;
  int __cil_tmp98 ;
  int tmp___10 ;
  char *__cil_tmp100 ;
  int __cil_tmp101 ;
  int tmp___11 ;
  char *__cil_tmp103 ;
  int __cil_tmp104 ;
  int tmp___12 ;
  char *__cil_tmp106 ;
  gchar *__cil_tmp107 ;
  int __cil_tmp108 ;
  int tmp___13 ;
  int msg_id___0 ;
  char *helper___4 ;
  char *__cil_tmp112 ;
  gchar *__cil_tmp113 ;
  int __cil_tmp114 ;
  gchar *__cil_tmp115 ;
  int __cil_tmp116 ;
  char *__cil_tmp117 ;
  int __cil_tmp118 ;
  int tmp___14 ;
  gchar *__cil_tmp120 ;
  gchar *__cil_tmp121 ;
  gchar *__cil_tmp122 ;

  {
  {
#line 277
  cmd_main = get_param(buf, 1, bytes, 1);
  }
#line 277
  if (cmd_main == (void *)0) {
    {
#line 277
    MSG(4, "Missing parameter from client");
#line 277
    __cil_tmp7 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 277
    return (__cil_tmp7);
  }
  {
#line 279
  __cil_tmp8 = strcmp((char const   *)cmd_main, "get");
  }
#line 279
  if (! __cil_tmp8) {
    {
#line 279
    g_free(cmd_main);
#line 279
    tmp = 1;
    }
  } else {
#line 279
    tmp = 0;
  }
#line 279
  if (tmp) {
    {
#line 281
    hist_get_sub = get_param(buf, 2, bytes, 1);
    }
#line 281
    if (hist_get_sub == (void *)0) {
      {
#line 281
      MSG(4, "Missing parameter from client");
#line 281
      __cil_tmp12 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
      }
#line 281
      return (__cil_tmp12);
    }
    {
#line 283
    __cil_tmp13 = strcmp((char const   *)hist_get_sub, "client_list");
    }
#line 283
    if (! __cil_tmp13) {
      {
#line 283
      g_free(hist_get_sub);
#line 283
      tmp___0 = 1;
      }
    } else {
#line 283
      tmp___0 = 0;
    }
#line 283
    if (tmp___0) {
      {
#line 285
      __cil_tmp15 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n");
      }
#line 285
      return (__cil_tmp15);
    } else {
      {
#line 286
      __cil_tmp16 = strcmp((char const   *)hist_get_sub, "client_id");
      }
#line 286
      if (! __cil_tmp16) {
        {
#line 286
        g_free(hist_get_sub);
#line 286
        tmp___1 = 1;
        }
      } else {
#line 286
        tmp___1 = 0;
      }
#line 286
      if (tmp___1) {
        {
#line 288
        __cil_tmp18 = history_get_client_id(fd);
        }
#line 288
        return ((char *)__cil_tmp18);
      } else {
        {
#line 289
        __cil_tmp19 = strcmp((char const   *)hist_get_sub, "client_messages");
        }
#line 289
        if (! __cil_tmp19) {
          {
#line 289
          g_free(hist_get_sub);
#line 289
          tmp___2 = 1;
          }
        } else {
#line 289
          tmp___2 = 0;
        }
#line 289
        if (tmp___2) {
          {
#line 293
          __cil_tmp26 = get_client_uid_by_fd(fd);
#line 293
          client_id = __cil_tmp26;
#line 296
          who = get_param(buf, 3, bytes, 1);
          }
#line 297
          if (who == (void *)0) {
            {
#line 297
            MSG(4, "Missing parameter from clientU");
#line 297
            __cil_tmp28 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
            }
#line 297
            return (__cil_tmp28);
          }
          {
#line 298
          __cil_tmp29 = strcmp((char const   *)who, "self");
          }
#line 298
          if (! __cil_tmp29) {
            {
#line 300
            __cil_tmp30 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n\355$\177\332U");
            }
#line 300
            return (__cil_tmp30);
          }
          {
#line 301
          __cil_tmp31 = strcmp((char const   *)who, "all\177\332U");
          }
#line 301
          if (! __cil_tmp31) {
            {
#line 303
            __cil_tmp32 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n");
            }
#line 303
            return (__cil_tmp32);
          }
          {
#line 304
          __cil_tmp33 = isanum((char const   *)who);
          }
#line 304
          if (! __cil_tmp33) {
            {
#line 305
            __cil_tmp34 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
            }
#line 305
            return (__cil_tmp34);
          }
          {
#line 306
          who_id = atoi((char const   *)who);
          }
#line 309
          if (who_id != client_id) {
            {
#line 310
            __cil_tmp36 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n");
            }
#line 310
            return (__cil_tmp36);
          }
          {
#line 312
          g_free(who);
#line 313
          helper = get_param(buf, 4, bytes, 0);
          }
#line 313
          if (helper == (void *)0) {
            {
#line 313
            MSG(4, "Missing parameter from clientU");
#line 313
            __cil_tmp39 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
            }
#line 313
            return (__cil_tmp39);
          }
          {
#line 313
          __cil_tmp40 = isanum((char const   *)helper);
          }
#line 313
          if (! __cil_tmp40) {
            {
#line 313
            g_free(helper);
#line 313
            __cil_tmp41 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
            }
#line 313
            return (__cil_tmp41);
          }
          {
#line 313
          start = atoi((char const   *)helper);
#line 313
          g_free(helper);
#line 314
          helper___0 = get_param(buf, 5, bytes, 0);
          }
#line 314
          if (helper___0 == (void *)0) {
            {
#line 314
            MSG(4, "Missing parameter from clientU");
#line 314
            __cil_tmp45 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
            }
#line 314
            return (__cil_tmp45);
          }
          {
#line 314
          __cil_tmp46 = isanum((char const   *)helper___0);
          }
#line 314
          if (! __cil_tmp46) {
            {
#line 314
            g_free(helper___0);
#line 314
            __cil_tmp47 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
            }
#line 314
            return (__cil_tmp47);
          }
          {
#line 314
          num = atoi((char const   *)helper___0);
#line 314
          g_free(helper___0);
#line 315
          __cil_tmp49 = history_get_message_list((guint )who_id, start, num);
          }
#line 315
          return ((char *)__cil_tmp49);
        } else {
          {
#line 317
          __cil_tmp50 = strcmp((char const   *)hist_get_sub, "last");
          }
#line 317
          if (! __cil_tmp50) {
            {
#line 317
            g_free(hist_get_sub);
#line 317
            tmp___3 = 1;
            }
          } else {
#line 317
            tmp___3 = 0;
          }
#line 317
          if (tmp___3) {
            {
#line 318
            __cil_tmp52 = history_get_last(fd);
            }
#line 318
            return ((char *)__cil_tmp52);
          } else {
            {
#line 319
            __cil_tmp53 = strcmp((char const   *)hist_get_sub, "message");
            }
#line 319
            if (! __cil_tmp53) {
              {
#line 319
              g_free(hist_get_sub);
#line 319
              tmp___4 = 1;
              }
            } else {
#line 319
              tmp___4 = 0;
            }
#line 319
            if (tmp___4) {
              {
#line 321
              helper___1 = get_param(buf, 3, bytes, 0);
              }
#line 321
              if (helper___1 == (void *)0) {
                {
#line 321
                MSG(4, "Missing parameter from clientU");
#line 321
                __cil_tmp58 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                }
#line 321
                return (__cil_tmp58);
              }
              {
#line 321
              __cil_tmp59 = isanum((char const   *)helper___1);
              }
#line 321
              if (! __cil_tmp59) {
                {
#line 321
                g_free(helper___1);
#line 321
                __cil_tmp60 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
                }
#line 321
                return (__cil_tmp60);
              }
              {
#line 321
              msg_id = atoi((char const   *)helper___1);
#line 321
              g_free(helper___1);
#line 322
              __cil_tmp62 = history_get_message(msg_id);
              }
#line 322
              return ((char *)__cil_tmp62);
            } else {
              {
#line 324
              __cil_tmp63 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
              }
#line 324
              return (__cil_tmp63);
            }
          }
        }
      }
    }
  } else {
    {
#line 326
    __cil_tmp64 = strcmp((char const   *)cmd_main, "cursor");
    }
#line 326
    if (! __cil_tmp64) {
      {
#line 326
      g_free(cmd_main);
#line 326
      tmp___5 = 1;
      }
    } else {
#line 326
      tmp___5 = 0;
    }
#line 326
    if (tmp___5) {
      {
#line 328
      hist_cur_sub = get_param(buf, 2, bytes, 1);
      }
#line 328
      if (hist_cur_sub == (void *)0) {
        {
#line 328
        MSG(4, "Missing parameter from clientU");
#line 328
        __cil_tmp68 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
        }
#line 328
        return (__cil_tmp68);
      }
      {
#line 330
      __cil_tmp69 = strcmp((char const   *)hist_cur_sub, "set\177\332U");
      }
#line 330
      if (! __cil_tmp69) {
        {
#line 330
        g_free(hist_cur_sub);
#line 330
        tmp___6 = 1;
        }
      } else {
#line 330
        tmp___6 = 0;
      }
#line 330
      if (tmp___6) {
        {
#line 334
        helper___2 = get_param(buf, 3, bytes, 0);
        }
#line 334
        if (helper___2 == (void *)0) {
          {
#line 334
          MSG(4, "Missing parameter from clientU");
#line 334
          __cil_tmp75 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
          }
#line 334
          return (__cil_tmp75);
        }
        {
#line 334
        __cil_tmp76 = isanum((char const   *)helper___2);
        }
#line 334
        if (! __cil_tmp76) {
          {
#line 334
          g_free(helper___2);
#line 334
          __cil_tmp77 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
          }
#line 334
          return (__cil_tmp77);
        }
        {
#line 334
        who___0 = atoi((char const   *)helper___2);
#line 334
        g_free(helper___2);
#line 335
        location = get_param(buf, 4, bytes, 1);
        }
#line 335
        if (location == (void *)0) {
          {
#line 335
          MSG(4, "Missing parameter from clientU");
#line 335
          __cil_tmp80 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
          }
#line 335
          return (__cil_tmp80);
        }
        {
#line 337
        __cil_tmp81 = strcmp((char const   *)location, "last");
        }
#line 337
        if (! __cil_tmp81) {
          {
#line 337
          g_free(location);
#line 337
          tmp___7 = 1;
          }
        } else {
#line 337
          tmp___7 = 0;
        }
#line 337
        if (tmp___7) {
          {
#line 338
          __cil_tmp83 = history_cursor_set_last(fd, (guint )who___0);
          }
#line 338
          return ((char *)__cil_tmp83);
        } else {
          {
#line 339
          __cil_tmp84 = strcmp((char const   *)location, "first");
          }
#line 339
          if (! __cil_tmp84) {
            {
#line 339
            g_free(location);
#line 339
            tmp___8 = 1;
            }
          } else {
#line 339
            tmp___8 = 0;
          }
#line 339
          if (tmp___8) {
            {
#line 340
            __cil_tmp86 = history_cursor_set_first(fd, (guint )who___0);
            }
#line 340
            return ((char *)__cil_tmp86);
          } else {
            {
#line 342
            __cil_tmp87 = strcmp((char const   *)location, "pos\177\332U");
            }
#line 342
            if (! __cil_tmp87) {
              {
#line 342
              g_free(location);
#line 342
              tmp___9 = 1;
              }
            } else {
#line 342
              tmp___9 = 0;
            }
#line 342
            if (tmp___9) {
              {
#line 344
              helper___3 = get_param(buf, 5, bytes, 0);
              }
#line 344
              if (helper___3 == (void *)0) {
                {
#line 344
                MSG(4, "Missing parameter from client");
#line 344
                __cil_tmp92 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                }
#line 344
                return (__cil_tmp92);
              }
              {
#line 344
              __cil_tmp93 = isanum((char const   *)helper___3);
              }
#line 344
              if (! __cil_tmp93) {
                {
#line 344
                g_free(helper___3);
#line 344
                __cil_tmp94 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
                }
#line 344
                return (__cil_tmp94);
              }
              {
#line 344
              pos = atoi((char const   *)helper___3);
#line 344
              g_free(helper___3);
#line 345
              __cil_tmp96 = history_cursor_set_pos(fd, (guint )who___0, pos);
              }
#line 345
              return ((char *)__cil_tmp96);
            } else {
              {
#line 348
              g_free(location);
#line 349
              __cil_tmp97 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
              }
#line 349
              return (__cil_tmp97);
            }
          }
        }
      } else {
        {
#line 351
        __cil_tmp98 = strcmp((char const   *)hist_cur_sub, "forward");
        }
#line 351
        if (! __cil_tmp98) {
          {
#line 351
          g_free(hist_cur_sub);
#line 351
          tmp___10 = 1;
          }
        } else {
#line 351
          tmp___10 = 0;
        }
#line 351
        if (tmp___10) {
          {
#line 352
          __cil_tmp100 = history_cursor_forward(fd);
          }
#line 352
          return ((char *)__cil_tmp100);
        } else {
          {
#line 353
          __cil_tmp101 = strcmp((char const   *)hist_cur_sub, "backward\220");
          }
#line 353
          if (! __cil_tmp101) {
            {
#line 353
            g_free(hist_cur_sub);
#line 353
            tmp___11 = 1;
            }
          } else {
#line 353
            tmp___11 = 0;
          }
#line 353
          if (tmp___11) {
            {
#line 354
            __cil_tmp103 = history_cursor_backward(fd);
            }
#line 354
            return ((char *)__cil_tmp103);
          } else {
            {
#line 355
            __cil_tmp104 = strcmp((char const   *)hist_cur_sub, "get");
            }
#line 355
            if (! __cil_tmp104) {
              {
#line 355
              g_free(hist_cur_sub);
#line 355
              tmp___12 = 1;
              }
            } else {
#line 355
              tmp___12 = 0;
            }
#line 355
            if (tmp___12) {
              {
#line 356
              __cil_tmp106 = history_cursor_get(fd);
              }
#line 356
              return ((char *)__cil_tmp106);
            } else {
              {
#line 358
              g_free(hist_cur_sub);
#line 359
              __cil_tmp107 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
              }
#line 359
              return (__cil_tmp107);
            }
          }
        }
      }
    } else {
      {
#line 362
      __cil_tmp108 = strcmp((char const   *)cmd_main, "say");
      }
#line 362
      if (! __cil_tmp108) {
        {
#line 362
        g_free(cmd_main);
#line 362
        tmp___13 = 1;
        }
      } else {
#line 362
        tmp___13 = 0;
      }
#line 362
      if (tmp___13) {
        {
#line 364
        helper___4 = get_param(buf, 2, bytes, 0);
        }
#line 364
        if (helper___4 == (void *)0) {
          {
#line 364
          MSG(4, "Missing parameter from clientU");
#line 364
          __cil_tmp113 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
          }
#line 364
          return (__cil_tmp113);
        }
        {
#line 364
        __cil_tmp114 = isanum((char const   *)helper___4);
        }
#line 364
        if (! __cil_tmp114) {
          {
#line 364
          g_free(helper___4);
#line 364
          __cil_tmp115 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
          }
#line 364
          return (__cil_tmp115);
        }
        {
#line 364
        msg_id___0 = atoi((char const   *)helper___4);
#line 364
        g_free(helper___4);
#line 365
        __cil_tmp117 = history_say_id(fd, msg_id___0);
        }
#line 365
        return ((char *)__cil_tmp117);
      } else {
        {
#line 366
        __cil_tmp118 = strcmp((char const   *)cmd_main, "sort\332U");
        }
#line 366
        if (! __cil_tmp118) {
          {
#line 366
          g_free(cmd_main);
#line 366
          tmp___14 = 1;
          }
        } else {
#line 366
          tmp___14 = 0;
        }
#line 366
        if (tmp___14) {
          {
#line 368
          __cil_tmp120 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n");
          }
#line 368
          return (__cil_tmp120);
        } else {
          {
#line 370
          g_free(cmd_main);
#line 371
          __cil_tmp121 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
          }
#line 371
          return (__cil_tmp121);
        }
      }
    }
  }
  {
#line 374
  __cil_tmp122 = g_strdup((gchar *)"500 ERR INVALID COMMAND\r\n");
  }
#line 374
  return (__cil_tmp122);
}
}
#line 402 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_set(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  int who ;
  int uid ;
  int ret ;
  char *set_sub ;
  char *who_s ;
  char *__cil_tmp10 ;
  gchar *__cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp ;
  int __cil_tmp14 ;
  int tmp___0 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  gchar *__cil_tmp18 ;
  char *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  int __cil_tmp21 ;
  int tmp___1 ;
  char *priority_s ;
  SPDPriority priority ;
  gchar *__cil_tmp25 ;
  gchar *__cil_tmp26 ;
  char *__cil_tmp27 ;
  gchar *__cil_tmp28 ;
  int __cil_tmp29 ;
  int tmp___2 ;
  int __cil_tmp31 ;
  int tmp___3 ;
  int __cil_tmp33 ;
  int tmp___4 ;
  int __cil_tmp35 ;
  int tmp___5 ;
  int __cil_tmp37 ;
  int tmp___6 ;
  gchar *__cil_tmp39 ;
  int __cil_tmp40 ;
  gchar *__cil_tmp41 ;
  gchar *__cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp___7 ;
  char *language ;
  char *__cil_tmp46 ;
  gchar *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  gchar *__cil_tmp51 ;
  gchar *__cil_tmp52 ;
  int __cil_tmp53 ;
  int tmp___8 ;
  char *synthesis_voice ;
  char *tmp___9 ;
  gchar **split_command ;
  int i ;
  gchar **__cil_tmp59 ;
  gboolean __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  gchar *__cil_tmp62 ;
  gchar *__cil_tmp63 ;
  gboolean __cil_tmp64 ;
  unsigned long __cil_tmp65 ;
  gchar *__cil_tmp66 ;
  gchar *__cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  gchar *__cil_tmp72 ;
  gchar *__cil_tmp73 ;
  int __cil_tmp74 ;
  int tmp___10 ;
  char *client_name ;
  gchar *__cil_tmp77 ;
  gchar *__cil_tmp78 ;
  char *__cil_tmp79 ;
  gchar *__cil_tmp80 ;
  int __cil_tmp81 ;
  gchar *__cil_tmp82 ;
  gchar *__cil_tmp83 ;
  int __cil_tmp84 ;
  int tmp___11 ;
  int rate ;
  char *helper ;
  char *__cil_tmp88 ;
  gchar *__cil_tmp89 ;
  int __cil_tmp90 ;
  gchar *__cil_tmp91 ;
  int __cil_tmp92 ;
  gchar *__cil_tmp93 ;
  gchar *__cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  gchar *__cil_tmp98 ;
  gchar *__cil_tmp99 ;
  int __cil_tmp100 ;
  int tmp___12 ;
  int pitch ;
  char *helper___0 ;
  char *__cil_tmp104 ;
  gchar *__cil_tmp105 ;
  int __cil_tmp106 ;
  gchar *__cil_tmp107 ;
  int __cil_tmp108 ;
  gchar *__cil_tmp109 ;
  gchar *__cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  gchar *__cil_tmp114 ;
  gchar *__cil_tmp115 ;
  int __cil_tmp116 ;
  int tmp___13 ;
  int pitch_range ;
  char *helper___1 ;
  char *__cil_tmp120 ;
  gchar *__cil_tmp121 ;
  int __cil_tmp122 ;
  gchar *__cil_tmp123 ;
  int __cil_tmp124 ;
  gchar *__cil_tmp125 ;
  gchar *__cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  gchar *__cil_tmp130 ;
  gchar *__cil_tmp131 ;
  int __cil_tmp132 ;
  int tmp___14 ;
  int volume ;
  char *helper___2 ;
  char *__cil_tmp136 ;
  gchar *__cil_tmp137 ;
  int __cil_tmp138 ;
  gchar *__cil_tmp139 ;
  int __cil_tmp140 ;
  gchar *__cil_tmp141 ;
  gchar *__cil_tmp142 ;
  int __cil_tmp143 ;
  int __cil_tmp144 ;
  int __cil_tmp145 ;
  gchar *__cil_tmp146 ;
  gchar *__cil_tmp147 ;
  int __cil_tmp148 ;
  int tmp___15 ;
  char *voice ;
  char *__cil_tmp151 ;
  gchar *__cil_tmp152 ;
  int __cil_tmp153 ;
  int __cil_tmp154 ;
  int __cil_tmp155 ;
  gchar *__cil_tmp156 ;
  gchar *__cil_tmp157 ;
  int __cil_tmp158 ;
  int tmp___16 ;
  char *punct_s ;
  SPDPunctuation punctuation_mode ;
  char *__cil_tmp162 ;
  gchar *__cil_tmp163 ;
  int __cil_tmp164 ;
  int tmp___17 ;
  int __cil_tmp166 ;
  int tmp___18 ;
  int __cil_tmp168 ;
  int tmp___19 ;
  int __cil_tmp170 ;
  int tmp___20 ;
  gchar *__cil_tmp172 ;
  int __cil_tmp173 ;
  int __cil_tmp174 ;
  int __cil_tmp175 ;
  gchar *__cil_tmp176 ;
  gchar *__cil_tmp177 ;
  int __cil_tmp178 ;
  int tmp___21 ;
  char *output_module ;
  gchar *__cil_tmp181 ;
  char *__cil_tmp182 ;
  gchar *__cil_tmp183 ;
  int __cil_tmp184 ;
  int __cil_tmp185 ;
  int __cil_tmp186 ;
  gchar *__cil_tmp187 ;
  gchar *__cil_tmp188 ;
  int __cil_tmp189 ;
  int tmp___22 ;
  int capital_letter_recognition ;
  char *recognition ;
  char *__cil_tmp193 ;
  gchar *__cil_tmp194 ;
  int __cil_tmp195 ;
  int tmp___23 ;
  int __cil_tmp197 ;
  int tmp___24 ;
  int __cil_tmp199 ;
  int tmp___25 ;
  gchar *__cil_tmp201 ;
  int __cil_tmp202 ;
  int __cil_tmp203 ;
  int __cil_tmp204 ;
  gchar *__cil_tmp205 ;
  gchar *__cil_tmp206 ;
  int __cil_tmp207 ;
  int tmp___26 ;
  int pause_context ;
  char *helper___3 ;
  char *__cil_tmp211 ;
  gchar *__cil_tmp212 ;
  int __cil_tmp213 ;
  gchar *__cil_tmp214 ;
  int __cil_tmp215 ;
  int __cil_tmp216 ;
  int __cil_tmp217 ;
  int __cil_tmp218 ;
  gchar *__cil_tmp219 ;
  gchar *__cil_tmp220 ;
  int __cil_tmp221 ;
  char *helper_s ;
  int spelling ;
  gchar *__cil_tmp224 ;
  char *__cil_tmp225 ;
  gchar *__cil_tmp226 ;
  int __cil_tmp227 ;
  int tmp___27 ;
  int __cil_tmp229 ;
  int tmp___28 ;
  gchar *__cil_tmp231 ;
  int __cil_tmp232 ;
  int __cil_tmp233 ;
  int __cil_tmp234 ;
  gchar *__cil_tmp235 ;
  gchar *__cil_tmp236 ;
  int __cil_tmp237 ;
  char *helper_s___0 ;
  int ssml_mode ;
  char *__cil_tmp240 ;
  gchar *__cil_tmp241 ;
  int __cil_tmp242 ;
  int tmp___29 ;
  int __cil_tmp244 ;
  int tmp___30 ;
  gchar *__cil_tmp246 ;
  int __cil_tmp247 ;
  int __cil_tmp248 ;
  int __cil_tmp249 ;
  gchar *__cil_tmp250 ;
  gchar *__cil_tmp251 ;
  int __cil_tmp252 ;
  char *helper_s___1 ;
  int debug ;
  char *__cil_tmp255 ;
  gchar *__cil_tmp256 ;
  int __cil_tmp257 ;
  int tmp___31 ;
  int __cil_tmp259 ;
  int tmp___32 ;
  gchar *__cil_tmp261 ;
  int __cil_tmp262 ;
  int __cil_tmp263 ;
  int __cil_tmp264 ;
  gchar *__cil_tmp265 ;
  gchar *__cil_tmp266 ;
  gchar *__cil_tmp267 ;
  int __cil_tmp268 ;
  int tmp___33 ;
  char *scope ;
  char *par_s ;
  int par ;
  gchar *__cil_tmp273 ;
  char *__cil_tmp274 ;
  gchar *__cil_tmp275 ;
  char *__cil_tmp276 ;
  gchar *__cil_tmp277 ;
  int __cil_tmp278 ;
  int tmp___34 ;
  int __cil_tmp280 ;
  int tmp___35 ;
  gchar *__cil_tmp282 ;
  int __cil_tmp283 ;
  gchar *__cil_tmp284 ;
  gchar *__cil_tmp285 ;
  gchar *__cil_tmp286 ;
  gchar *__cil_tmp287 ;

  {
  {
#line 406
  uid = - 1;
#line 408
  ret = - 1;
#line 412
  who_s = get_param(buf, 1, bytes, 1);
  }
#line 412
  if (who_s == (void *)0) {
    {
#line 412
    MSG(4, "Missing parameter from client");
#line 412
    __cil_tmp11 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 412
    return (__cil_tmp11);
  }
  {
#line 414
  __cil_tmp12 = strcmp((char const   *)who_s, "self\332U");
  }
#line 414
  if (! __cil_tmp12) {
    {
#line 414
    g_free(who_s);
#line 414
    tmp = 1;
    }
  } else {
#line 414
    tmp = 0;
  }
#line 414
  if (tmp) {
#line 415
    who = 0;
  } else {
    {
#line 416
    __cil_tmp14 = strcmp((char const   *)who_s, "all");
    }
#line 416
    if (! __cil_tmp14) {
      {
#line 416
      g_free(who_s);
#line 416
      tmp___0 = 1;
      }
    } else {
#line 416
      tmp___0 = 0;
    }
#line 416
    if (tmp___0) {
#line 417
      who = 2;
    } else {
      {
#line 418
      __cil_tmp16 = isanum((char const   *)who_s);
      }
#line 418
      if (__cil_tmp16) {
        {
#line 419
        who = 1;
#line 420
        uid = atoi((char const   *)who_s);
#line 421
        g_free(who_s);
        }
      } else {
        {
#line 423
        g_free(who_s);
#line 424
        __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 424
        return (__cil_tmp18);
      }
    }
  }
  {
#line 427
  set_sub = get_param(buf, 2, bytes, 1);
  }
#line 427
  if (set_sub == (void *)0) {
    {
#line 427
    MSG(4, "Missing parameter from client");
#line 427
    __cil_tmp20 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 427
    return (__cil_tmp20);
  }
  {
#line 429
  __cil_tmp21 = strcmp((char const   *)set_sub, "priority\220");
  }
#line 429
  if (! __cil_tmp21) {
    {
#line 429
    g_free(set_sub);
#line 429
    tmp___1 = 1;
    }
  } else {
#line 429
    tmp___1 = 0;
  }
#line 429
  if (tmp___1) {
#line 432
    if (speechd_socket->inside_block > 0) {
      {
#line 432
      __cil_tmp25 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
      }
#line 432
      return (__cil_tmp25);
    }

#line 435
    if (who != 0) {
      {
#line 436
      __cil_tmp26 = g_strdup((gchar *)"301 ERR COULDNT SET PRIORITY\r\n%\177\332U");
      }
#line 436
      return (__cil_tmp26);
    }
    {
#line 437
    priority_s = get_param(buf, 3, bytes, 1);
    }
#line 437
    if (priority_s == (void *)0) {
      {
#line 437
      MSG(4, "Missing parameter from clientU");
#line 437
      __cil_tmp28 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
      }
#line 437
      return (__cil_tmp28);
    }
    {
#line 439
    __cil_tmp29 = strcmp((char const   *)priority_s, "important");
    }
#line 439
    if (! __cil_tmp29) {
      {
#line 439
      g_free(priority_s);
#line 439
      tmp___2 = 1;
      }
    } else {
#line 439
      tmp___2 = 0;
    }
#line 439
    if (tmp___2) {
#line 440
      priority = (SPDPriority )1;
    } else {
      {
#line 441
      __cil_tmp31 = strcmp((char const   *)priority_s, "message");
      }
#line 441
      if (! __cil_tmp31) {
        {
#line 441
        g_free(priority_s);
#line 441
        tmp___3 = 1;
        }
      } else {
#line 441
        tmp___3 = 0;
      }
#line 441
      if (tmp___3) {
#line 442
        priority = (SPDPriority )2;
      } else {
        {
#line 443
        __cil_tmp33 = strcmp((char const   *)priority_s, "text\332U");
        }
#line 443
        if (! __cil_tmp33) {
          {
#line 443
          g_free(priority_s);
#line 443
          tmp___4 = 1;
          }
        } else {
#line 443
          tmp___4 = 0;
        }
#line 443
        if (tmp___4) {
#line 444
          priority = (SPDPriority )3;
        } else {
          {
#line 445
          __cil_tmp35 = strcmp((char const   *)priority_s, "notification");
          }
#line 445
          if (! __cil_tmp35) {
            {
#line 445
            g_free(priority_s);
#line 445
            tmp___5 = 1;
            }
          } else {
#line 445
            tmp___5 = 0;
          }
#line 445
          if (tmp___5) {
#line 446
            priority = (SPDPriority )4;
          } else {
            {
#line 447
            __cil_tmp37 = strcmp((char const   *)priority_s, "progress\220");
            }
#line 447
            if (! __cil_tmp37) {
              {
#line 447
              g_free(priority_s);
#line 447
              tmp___6 = 1;
              }
            } else {
#line 447
              tmp___6 = 0;
            }
#line 447
            if (tmp___6) {
#line 448
              priority = (SPDPriority )5;
            } else {
              {
#line 450
              g_free(priority_s);
#line 451
              __cil_tmp39 = g_strdup((gchar *)"408 ERR UNKNOWN PRIORITY\r\n");
              }
#line 451
              return (__cil_tmp39);
            }
          }
        }
      }
    }
    {
#line 454
    ret = set_priority_self(fd, priority);
    }
#line 455
    if (ret) {
      {
#line 456
      __cil_tmp41 = g_strdup((gchar *)"301 ERR COULDNT SET PRIORITY\r\n%\177\332U");
      }
#line 456
      return (__cil_tmp41);
    }
    {
#line 457
    __cil_tmp42 = g_strdup((gchar *)"202 OK PRIORITY SET\r\nw%\177\332U");
    }
#line 457
    return (__cil_tmp42);
  } else {
    {
#line 458
    __cil_tmp43 = strcmp((char const   *)set_sub, "language\220");
    }
#line 458
    if (! __cil_tmp43) {
      {
#line 458
      g_free(set_sub);
#line 458
      tmp___7 = 1;
      }
    } else {
#line 458
      tmp___7 = 0;
    }
#line 458
    if (tmp___7) {
      {
#line 461
      language = get_param(buf, 3, bytes, 1);
      }
#line 461
      if (language == (void *)0) {
        {
#line 461
        MSG(4, "Missing parameter from clientU");
#line 461
        __cil_tmp47 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
        }
#line 461
        return (__cil_tmp47);
      }

#line 463
      if (who == 0) {
        {
#line 463
        ret = set_language_self(fd, language);
        }
      } else
#line 463
      if (who == 1) {
        {
#line 463
        ret = set_language_uid(uid, language);
        }
      } else
#line 463
      if (who == 2) {
        {
#line 463
        ret = set_language_all(language);
        }
      }
      {
#line 464
      g_free(language);
      }
#line 466
      if (ret) {
        {
#line 467
        __cil_tmp51 = g_strdup((gchar *)"302 ERR COULDNT SET LANGUAGE\r\n");
        }
#line 467
        return (__cil_tmp51);
      }
      {
#line 468
      __cil_tmp52 = g_strdup((gchar *)"201 OK LANGUAGE SET\r\nm%\177\332U");
      }
#line 468
      return (__cil_tmp52);
    } else {
      {
#line 469
      __cil_tmp53 = strcmp((char const   *)set_sub, "synthesis_voice");
      }
#line 469
      if (! __cil_tmp53) {
        {
#line 469
        g_free(set_sub);
#line 469
        tmp___8 = 1;
        }
      } else {
#line 469
        tmp___8 = 0;
      }
#line 469
      if (tmp___8) {
        {
#line 470
        synthesis_voice = (char *)((void *)0);
#line 471
        tmp___9 = (char *)((void *)0);
#line 475
        split_command = g_strsplit(buf, (gchar *)" ", 0);
#line 476
        i = 0;
        }
        {
#line 476
        while (1) {
          while_continue: /* CIL Label */ ;
#line 476
          if (! (*(split_command + i) != (void *)0)) {
#line 476
            goto while_break;
          }
#line 477
          tmp___9 = (char *)((void *)0);
#line 479
          if (i == 3) {
            {
#line 480
            __cil_tmp60 = g_str_has_suffix(*(split_command + i), (gchar *)"\n\377\377\377");
            }
#line 480
            if (__cil_tmp60) {
              {
#line 481
              __cil_tmp61 = strlen((char const   *)*(split_command + i));
#line 481
              __cil_tmp62 = g_strndup(*(split_command + i), __cil_tmp61 - 2UL);
#line 481
              synthesis_voice = __cil_tmp62;
              }
            } else {
              {
#line 483
              synthesis_voice = g_strdup(*(split_command + i));
              }
            }
          } else
#line 485
          if (i > 3) {
            {
#line 486
            __cil_tmp64 = g_str_has_suffix(*(split_command + i), (gchar *)"\n");
            }
#line 486
            if (__cil_tmp64) {
              {
#line 487
              __cil_tmp65 = strlen((char const   *)*(split_command + i));
#line 487
              __cil_tmp66 = g_strndup(*(split_command + i), __cil_tmp65 - 2UL);
#line 487
              tmp___9 = __cil_tmp66;
#line 488
              g_free(*(split_command + i));
#line 489
              *(split_command + i) = tmp___9;
#line 490
              tmp___9 = (char *)((void *)0);
              }
            }
            {
#line 493
            tmp___9 = g_strjoin((gchar *)" \n\254{\332U", synthesis_voice, *(split_command + i),
                                (void *)0);
#line 494
            g_free(synthesis_voice);
#line 495
            synthesis_voice = tmp___9;
            }
          }
#line 476
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 499
        g_strfreev(split_command);
        }
#line 501
        if (i < 3) {
#line 502
          synthesis_voice = (char *)((void *)0);
        }
#line 504
        if (who == 0) {
          {
#line 504
          ret = set_synthesis_voice_self(fd, (char const   *)synthesis_voice);
          }
        } else
#line 504
        if (who == 1) {
          {
#line 504
          ret = set_synthesis_voice_uid(uid, (char const   *)synthesis_voice);
          }
        } else
#line 504
        if (who == 2) {
          {
#line 504
          ret = set_synthesis_voice_all((char const   *)synthesis_voice);
          }
        }
        {
#line 505
        g_free(synthesis_voice);
        }
#line 507
        if (ret) {
          {
#line 508
          __cil_tmp72 = g_strdup((gchar *)"309 ERR COULDNT SET VOICE\r\n");
          }
#line 508
          return (__cil_tmp72);
        }
        {
#line 509
        __cil_tmp73 = g_strdup((gchar *)"209 OK VOICE SET\r\n");
        }
#line 509
        return (__cil_tmp73);
      } else {
        {
#line 510
        __cil_tmp74 = strcmp((char const   *)set_sub, "client_name\177\332U");
        }
#line 510
        if (! __cil_tmp74) {
          {
#line 510
          g_free(set_sub);
#line 510
          tmp___10 = 1;
          }
        } else {
#line 510
          tmp___10 = 0;
        }
#line 510
        if (tmp___10) {
#line 512
          if (speechd_socket->inside_block > 0) {
            {
#line 512
            __cil_tmp77 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
            }
#line 512
            return (__cil_tmp77);
          }

#line 515
          if (who != 0) {
            {
#line 516
            __cil_tmp78 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
            }
#line 516
            return (__cil_tmp78);
          }
          {
#line 518
          client_name = get_param(buf, 3, bytes, 1);
          }
#line 518
          if (client_name == (void *)0) {
            {
#line 518
            MSG(4, "Missing parameter from client");
#line 518
            __cil_tmp80 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
            }
#line 518
            return (__cil_tmp80);
          }
          {
#line 520
          ret = set_client_name_self(fd, (char const   *)client_name);
#line 521
          g_free(client_name);
          }
#line 523
          if (ret) {
            {
#line 524
            __cil_tmp82 = g_strdup((gchar *)"311 ERR COULDNT SET CLIENT_NAME\r\nU");
            }
#line 524
            return (__cil_tmp82);
          }
          {
#line 525
          __cil_tmp83 = g_strdup((gchar *)"208 OK CLIENT NAME SET\r\n");
          }
#line 525
          return (__cil_tmp83);
        } else {
          {
#line 526
          __cil_tmp84 = strcmp((char const   *)set_sub, "rate");
          }
#line 526
          if (! __cil_tmp84) {
            {
#line 526
            g_free(set_sub);
#line 526
            tmp___11 = 1;
            }
          } else {
#line 526
            tmp___11 = 0;
          }
#line 526
          if (tmp___11) {
            {
#line 528
            helper = get_param(buf, 3, bytes, 0);
            }
#line 528
            if (helper == (void *)0) {
              {
#line 528
              MSG(4, "Missing parameter from clientU");
#line 528
              __cil_tmp89 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
              }
#line 528
              return (__cil_tmp89);
            }
            {
#line 528
            __cil_tmp90 = isanum((char const   *)helper);
            }
#line 528
            if (! __cil_tmp90) {
              {
#line 528
              g_free(helper);
#line 528
              __cil_tmp91 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
              }
#line 528
              return (__cil_tmp91);
            }
            {
#line 528
            rate = atoi((char const   *)helper);
#line 528
            g_free(helper);
            }
#line 530
            if (rate < -100) {
              {
#line 531
              __cil_tmp93 = g_strdup((gchar *)"410 ERR RATE TOO LOW\r\n");
              }
#line 531
              return (__cil_tmp93);
            }
#line 532
            if (rate > 100) {
              {
#line 533
              __cil_tmp94 = g_strdup((gchar *)"409 ERR RATE TOO HIGH\r\n\177\332U");
              }
#line 533
              return (__cil_tmp94);
            }
#line 535
            if (who == 0) {
              {
#line 535
              ret = set_rate_self(fd, rate);
              }
            } else
#line 535
            if (who == 1) {
              {
#line 535
              ret = set_rate_uid(uid, rate);
              }
            } else
#line 535
            if (who == 2) {
              {
#line 535
              ret = set_rate_all(rate);
              }
            }

#line 536
            if (ret) {
              {
#line 537
              __cil_tmp98 = g_strdup((gchar *)"303 ERR COULDNT SET RATE\r\n");
              }
#line 537
              return (__cil_tmp98);
            }
            {
#line 538
            __cil_tmp99 = g_strdup((gchar *)"203 OK RATE SET\r\n");
            }
#line 538
            return (__cil_tmp99);
          } else {
            {
#line 539
            __cil_tmp100 = strcmp((char const   *)set_sub, "pitchU");
            }
#line 539
            if (! __cil_tmp100) {
              {
#line 539
              g_free(set_sub);
#line 539
              tmp___12 = 1;
              }
            } else {
#line 539
              tmp___12 = 0;
            }
#line 539
            if (tmp___12) {
              {
#line 541
              helper___0 = get_param(buf, 3, bytes, 0);
              }
#line 541
              if (helper___0 == (void *)0) {
                {
#line 541
                MSG(4, "Missing parameter from client");
#line 541
                __cil_tmp105 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                }
#line 541
                return (__cil_tmp105);
              }
              {
#line 541
              __cil_tmp106 = isanum((char const   *)helper___0);
              }
#line 541
              if (! __cil_tmp106) {
                {
#line 541
                g_free(helper___0);
#line 541
                __cil_tmp107 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n\332U");
                }
#line 541
                return (__cil_tmp107);
              }
              {
#line 541
              pitch = atoi((char const   *)helper___0);
#line 541
              g_free(helper___0);
              }
#line 543
              if (pitch < -100) {
                {
#line 544
                __cil_tmp109 = g_strdup((gchar *)"412 ERR PITCH TOO LOW\r\n");
                }
#line 544
                return (__cil_tmp109);
              }
#line 545
              if (pitch > 100) {
                {
#line 546
                __cil_tmp110 = g_strdup((gchar *)"411 ERR PITCH TOO HIGH\r\n\332U");
                }
#line 546
                return (__cil_tmp110);
              }
#line 548
              if (who == 0) {
                {
#line 548
                ret = set_pitch_self(fd, pitch);
                }
              } else
#line 548
              if (who == 1) {
                {
#line 548
                ret = set_pitch_uid(uid, pitch);
                }
              } else
#line 548
              if (who == 2) {
                {
#line 548
                ret = set_pitch_all(pitch);
                }
              }

#line 549
              if (ret) {
                {
#line 550
                __cil_tmp114 = g_strdup((gchar *)"304 ERR COULDNT SET PITCH\r\n");
                }
#line 550
                return (__cil_tmp114);
              }
              {
#line 551
              __cil_tmp115 = g_strdup((gchar *)"204 OK PITCH SET\r\n");
              }
#line 551
              return (__cil_tmp115);
            } else {
              {
#line 552
              __cil_tmp116 = strcmp((char const   *)set_sub, "pitch_range");
              }
#line 552
              if (! __cil_tmp116) {
                {
#line 552
                g_free(set_sub);
#line 552
                tmp___13 = 1;
                }
              } else {
#line 552
                tmp___13 = 0;
              }
#line 552
              if (tmp___13) {
                {
#line 554
                helper___1 = get_param(buf, 3, bytes, 0);
                }
#line 554
                if (helper___1 == (void *)0) {
                  {
#line 554
                  MSG(4, "Missing parameter from client");
#line 554
                  __cil_tmp121 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                  }
#line 554
                  return (__cil_tmp121);
                }
                {
#line 554
                __cil_tmp122 = isanum((char const   *)helper___1);
                }
#line 554
                if (! __cil_tmp122) {
                  {
#line 554
                  g_free(helper___1);
#line 554
                  __cil_tmp123 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
                  }
#line 554
                  return (__cil_tmp123);
                }
                {
#line 554
                pitch_range = atoi((char const   *)helper___1);
#line 554
                g_free(helper___1);
                }
#line 556
                if (pitch_range < -100) {
                  {
#line 557
                  __cil_tmp125 = g_strdup((gchar *)"416 ERR PITCH RANGE TOO LOW\r\n");
                  }
#line 557
                  return (__cil_tmp125);
                }
#line 558
                if (pitch_range > 100) {
                  {
#line 559
                  __cil_tmp126 = g_strdup((gchar *)"415 ERR PITCH RANGE TOO HIGH\r\n");
                  }
#line 559
                  return (__cil_tmp126);
                }
#line 561
                if (who == 0) {
                  {
#line 561
                  ret = set_pitch_range_self(fd, pitch_range);
                  }
                } else
#line 561
                if (who == 1) {
                  {
#line 561
                  ret = set_pitch_range_uid(uid, pitch_range);
                  }
                } else
#line 561
                if (who == 2) {
                  {
#line 561
                  ret = set_pitch_range_all(pitch_range);
                  }
                }

#line 562
                if (ret) {
                  {
#line 563
                  __cil_tmp130 = g_strdup((gchar *)"340 ERR COULDNT SET PITCH RANGE\r\nU");
                  }
#line 563
                  return (__cil_tmp130);
                }
                {
#line 564
                __cil_tmp131 = g_strdup((gchar *)"263 OK PITCH RANGE SET\r\n\332U");
                }
#line 564
                return (__cil_tmp131);
              } else {
                {
#line 565
                __cil_tmp132 = strcmp((char const   *)set_sub, "volume");
                }
#line 565
                if (! __cil_tmp132) {
                  {
#line 565
                  g_free(set_sub);
#line 565
                  tmp___14 = 1;
                  }
                } else {
#line 565
                  tmp___14 = 0;
                }
#line 565
                if (tmp___14) {
                  {
#line 567
                  helper___2 = get_param(buf, 3, bytes, 0);
                  }
#line 567
                  if (helper___2 == (void *)0) {
                    {
#line 567
                    MSG(4, "Missing parameter from clientU");
#line 567
                    __cil_tmp137 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                    }
#line 567
                    return (__cil_tmp137);
                  }
                  {
#line 567
                  __cil_tmp138 = isanum((char const   *)helper___2);
                  }
#line 567
                  if (! __cil_tmp138) {
                    {
#line 567
                    g_free(helper___2);
#line 567
                    __cil_tmp139 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
                    }
#line 567
                    return (__cil_tmp139);
                  }
                  {
#line 567
                  volume = atoi((char const   *)helper___2);
#line 567
                  g_free(helper___2);
                  }
#line 569
                  if (volume < -100) {
                    {
#line 570
                    __cil_tmp141 = g_strdup((gchar *)"414 ERR PITCH TOO LOW\r\n");
                    }
#line 570
                    return (__cil_tmp141);
                  }
#line 571
                  if (volume > 100) {
                    {
#line 572
                    __cil_tmp142 = g_strdup((gchar *)"413 ERR PITCH TOO HIGH\r\n");
                    }
#line 572
                    return (__cil_tmp142);
                  }
#line 574
                  if (who == 0) {
                    {
#line 574
                    ret = set_volume_self(fd, volume);
                    }
                  } else
#line 574
                  if (who == 1) {
                    {
#line 574
                    ret = set_volume_uid(uid, volume);
                    }
                  } else
#line 574
                  if (who == 2) {
                    {
#line 574
                    ret = set_volume_all(volume);
                    }
                  }

#line 575
                  if (ret) {
                    {
#line 576
                    __cil_tmp146 = g_strdup((gchar *)"314 ERR COULDNT SET VOLUME\r\n\220");
                    }
#line 576
                    return (__cil_tmp146);
                  }
                  {
#line 577
                  __cil_tmp147 = g_strdup((gchar *)"218 OK VOLUME SET\r\n");
                  }
#line 577
                  return (__cil_tmp147);
                } else {
                  {
#line 578
                  __cil_tmp148 = strcmp((char const   *)set_sub, "voice_type");
                  }
#line 578
                  if (! __cil_tmp148) {
                    {
#line 578
                    g_free(set_sub);
#line 578
                    tmp___15 = 1;
                    }
                  } else {
#line 578
                    tmp___15 = 0;
                  }
#line 578
                  if (tmp___15) {
                    {
#line 580
                    voice = get_param(buf, 3, bytes, 1);
                    }
#line 580
                    if (voice == (void *)0) {
                      {
#line 580
                      MSG(4, "Missing parameter from clientU");
#line 580
                      __cil_tmp152 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                      }
#line 580
                      return (__cil_tmp152);
                    }

#line 582
                    if (who == 0) {
                      {
#line 582
                      ret = set_voice_self(fd, (char const   *)voice);
                      }
                    } else
#line 582
                    if (who == 1) {
                      {
#line 582
                      ret = set_voice_uid(uid, (char const   *)voice);
                      }
                    } else
#line 582
                    if (who == 2) {
                      {
#line 582
                      ret = set_voice_all((char const   *)voice);
                      }
                    }
                    {
#line 583
                    g_free(voice);
                    }
#line 585
                    if (ret) {
                      {
#line 586
                      __cil_tmp156 = g_strdup((gchar *)"309 ERR COULDNT SET VOICE\r\n");
                      }
#line 586
                      return (__cil_tmp156);
                    }
                    {
#line 587
                    __cil_tmp157 = g_strdup((gchar *)"209 OK VOICE SET\r\n");
                    }
#line 587
                    return (__cil_tmp157);
                  } else {
                    {
#line 588
                    __cil_tmp158 = strcmp((char const   *)set_sub, "punctuation");
                    }
#line 588
                    if (! __cil_tmp158) {
                      {
#line 588
                      g_free(set_sub);
#line 588
                      tmp___16 = 1;
                      }
                    } else {
#line 588
                      tmp___16 = 0;
                    }
#line 588
                    if (tmp___16) {
                      {
#line 592
                      punct_s = get_param(buf, 3, bytes, 1);
                      }
#line 592
                      if (punct_s == (void *)0) {
                        {
#line 592
                        MSG(4, "Missing parameter from client");
#line 592
                        __cil_tmp163 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                        }
#line 592
                        return (__cil_tmp163);
                      }
                      {
#line 594
                      __cil_tmp164 = strcmp((char const   *)punct_s, "all");
                      }
#line 594
                      if (! __cil_tmp164) {
                        {
#line 594
                        g_free(punct_s);
#line 594
                        tmp___17 = 1;
                        }
                      } else {
#line 594
                        tmp___17 = 0;
                      }
#line 594
                      if (tmp___17) {
#line 595
                        punctuation_mode = (SPDPunctuation )0;
                      } else {
                        {
#line 596
                        __cil_tmp166 = strcmp((char const   *)punct_s, "most");
                        }
#line 596
                        if (! __cil_tmp166) {
                          {
#line 596
                          g_free(punct_s);
#line 596
                          tmp___18 = 1;
                          }
                        } else {
#line 596
                          tmp___18 = 0;
                        }
#line 596
                        if (tmp___18) {
#line 597
                          punctuation_mode = (SPDPunctuation )3;
                        } else {
                          {
#line 598
                          __cil_tmp168 = strcmp((char const   *)punct_s, "some");
                          }
#line 598
                          if (! __cil_tmp168) {
                            {
#line 598
                            g_free(punct_s);
#line 598
                            tmp___19 = 1;
                            }
                          } else {
#line 598
                            tmp___19 = 0;
                          }
#line 598
                          if (tmp___19) {
#line 599
                            punctuation_mode = (SPDPunctuation )2;
                          } else {
                            {
#line 600
                            __cil_tmp170 = strcmp((char const   *)punct_s, "none\332U");
                            }
#line 600
                            if (! __cil_tmp170) {
                              {
#line 600
                              g_free(punct_s);
#line 600
                              tmp___20 = 1;
                              }
                            } else {
#line 600
                              tmp___20 = 0;
                            }
#line 600
                            if (tmp___20) {
#line 601
                              punctuation_mode = (SPDPunctuation )1;
                            } else {
                              {
#line 603
                              g_free(punct_s);
#line 604
                              __cil_tmp172 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
                              }
#line 604
                              return (__cil_tmp172);
                            }
                          }
                        }
                      }
#line 607
                      if (who == 0) {
                        {
#line 607
                        ret = set_punctuation_mode_self(fd, punctuation_mode);
                        }
                      } else
#line 607
                      if (who == 1) {
                        {
#line 607
                        ret = set_punctuation_mode_uid(uid, punctuation_mode);
                        }
                      } else
#line 607
                      if (who == 2) {
                        {
#line 607
                        ret = set_punctuation_mode_all(punctuation_mode);
                        }
                      }

#line 609
                      if (ret) {
                        {
#line 610
                        __cil_tmp176 = g_strdup((gchar *)"305 ERR COULDNT SET PUNCT MODE\r\n");
                        }
#line 610
                        return (__cil_tmp176);
                      }
                      {
#line 611
                      __cil_tmp177 = g_strdup((gchar *)"205 OK PUNCTUATION SET\r\n\332U");
                      }
#line 611
                      return (__cil_tmp177);
                    } else {
                      {
#line 612
                      __cil_tmp178 = strcmp((char const   *)set_sub, "output_moduleU");
                      }
#line 612
                      if (! __cil_tmp178) {
                        {
#line 612
                        g_free(set_sub);
#line 612
                        tmp___21 = 1;
                        }
                      } else {
#line 612
                        tmp___21 = 0;
                      }
#line 612
                      if (tmp___21) {
#line 614
                        if (speechd_socket->inside_block > 0) {
                          {
#line 614
                          __cil_tmp181 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
                          }
#line 614
                          return (__cil_tmp181);
                        }
                        {
#line 615
                        output_module = get_param(buf, 3, bytes, 1);
                        }
#line 615
                        if (output_module == (void *)0) {
                          {
#line 615
                          MSG(4, "Missing parameter from client");
#line 615
                          __cil_tmp183 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                          }
#line 615
                          return (__cil_tmp183);
                        }

#line 617
                        if (who == 0) {
                          {
#line 617
                          ret = set_output_module_self(fd, (char const   *)output_module);
                          }
                        } else
#line 617
                        if (who == 1) {
                          {
#line 617
                          ret = set_output_module_uid(uid, (char const   *)output_module);
                          }
                        } else
#line 617
                        if (who == 2) {
                          {
#line 617
                          ret = set_output_module_all((char const   *)output_module);
                          }
                        }
                        {
#line 618
                        g_free(output_module);
                        }
#line 620
                        if (ret) {
                          {
#line 621
                          __cil_tmp187 = g_strdup((gchar *)"312 ERR COULDNT SET OUTPUT MODULE\r\n");
                          }
#line 621
                          return (__cil_tmp187);
                        }
                        {
#line 622
                        __cil_tmp188 = g_strdup((gchar *)"216 OK OUTPUT MODULE SET\r\n");
                        }
#line 622
                        return (__cil_tmp188);
                      } else {
                        {
#line 623
                        __cil_tmp189 = strcmp((char const   *)set_sub, "cap_let_recogn");
                        }
#line 623
                        if (! __cil_tmp189) {
                          {
#line 623
                          g_free(set_sub);
#line 623
                          tmp___22 = 1;
                          }
                        } else {
#line 623
                          tmp___22 = 0;
                        }
#line 623
                        if (tmp___22) {
                          {
#line 626
                          recognition = get_param(buf, 3, bytes, 1);
                          }
#line 626
                          if (recognition == (void *)0) {
                            {
#line 626
                            MSG(4, "Missing parameter from client");
#line 626
                            __cil_tmp194 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                            }
#line 626
                            return (__cil_tmp194);
                          }
                          {
#line 628
                          __cil_tmp195 = strcmp((char const   *)recognition, "none");
                          }
#line 628
                          if (! __cil_tmp195) {
                            {
#line 628
                            g_free(recognition);
#line 628
                            tmp___23 = 1;
                            }
                          } else {
#line 628
                            tmp___23 = 0;
                          }
#line 628
                          if (tmp___23) {
#line 629
                            capital_letter_recognition = 0;
                          } else {
                            {
#line 630
                            __cil_tmp197 = strcmp((char const   *)recognition, "spell");
                            }
#line 630
                            if (! __cil_tmp197) {
                              {
#line 630
                              g_free(recognition);
#line 630
                              tmp___24 = 1;
                              }
                            } else {
#line 630
                              tmp___24 = 0;
                            }
#line 630
                            if (tmp___24) {
#line 631
                              capital_letter_recognition = 1;
                            } else {
                              {
#line 632
                              __cil_tmp199 = strcmp((char const   *)recognition, "icon");
                              }
#line 632
                              if (! __cil_tmp199) {
                                {
#line 632
                                g_free(recognition);
#line 632
                                tmp___25 = 1;
                                }
                              } else {
#line 632
                                tmp___25 = 0;
                              }
#line 632
                              if (tmp___25) {
#line 633
                                capital_letter_recognition = 2;
                              } else {
                                {
#line 635
                                g_free(recognition);
#line 636
                                __cil_tmp201 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
                                }
#line 636
                                return (__cil_tmp201);
                              }
                            }
                          }
#line 639
                          if (who == 0) {
                            {
#line 639
                            ret = set_capital_letter_recognition_self(fd, (SPDCapitalLetters )capital_letter_recognition);
                            }
                          } else
#line 639
                          if (who == 1) {
                            {
#line 639
                            ret = set_capital_letter_recognition_uid(uid, (SPDCapitalLetters )capital_letter_recognition);
                            }
                          } else
#line 639
                          if (who == 2) {
                            {
#line 639
                            ret = set_capital_letter_recognition_all((SPDCapitalLetters )capital_letter_recognition);
                            }
                          }

#line 641
                          if (ret) {
                            {
#line 642
                            __cil_tmp205 = g_strdup((gchar *)"306 ERR COULDNT SET CAP LET RECOGNITION\r\n");
                            }
#line 642
                            return (__cil_tmp205);
                          }
                          {
#line 643
                          __cil_tmp206 = g_strdup((gchar *)"206 OK CAP LET RECOGNITION SET\r\n");
                          }
#line 643
                          return (__cil_tmp206);
                        } else {
                          {
#line 644
                          __cil_tmp207 = strcmp((char const   *)set_sub, "pause_context");
                          }
#line 644
                          if (! __cil_tmp207) {
                            {
#line 644
                            g_free(set_sub);
#line 644
                            tmp___26 = 1;
                            }
                          } else {
#line 644
                            tmp___26 = 0;
                          }
#line 644
                          if (tmp___26) {
                            {
#line 646
                            helper___3 = get_param(buf, 3, bytes, 0);
                            }
#line 646
                            if (helper___3 == (void *)0) {
                              {
#line 646
                              MSG(4, "Missing parameter from client");
#line 646
                              __cil_tmp212 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                              }
#line 646
                              return (__cil_tmp212);
                            }
                            {
#line 646
                            __cil_tmp213 = isanum((char const   *)helper___3);
                            }
#line 646
                            if (! __cil_tmp213) {
                              {
#line 646
                              g_free(helper___3);
#line 646
                              __cil_tmp214 = g_strdup((gchar *)"511 ERR PARAMETER NOT A NUMBER\r\n");
                              }
#line 646
                              return (__cil_tmp214);
                            }
                            {
#line 646
                            pause_context = atoi((char const   *)helper___3);
#line 646
                            g_free(helper___3);
                            }
#line 648
                            if (who == 0) {
                              {
#line 648
                              ret = set_pause_context_self(fd, pause_context);
                              }
                            } else
#line 648
                            if (who == 1) {
                              {
#line 648
                              ret = set_pause_context_uid(uid, pause_context);
                              }
                            } else
#line 648
                            if (who == 2) {
                              {
#line 648
                              ret = set_pause_context_all(pause_context);
                              }
                            }

#line 649
                            if (ret) {
                              {
#line 650
                              __cil_tmp219 = g_strdup((gchar *)"313 ERR COULDNT SET PAUSE CONTEXT\r\n");
                              }
#line 650
                              return (__cil_tmp219);
                            }
                            {
#line 651
                            __cil_tmp220 = g_strdup((gchar *)"217 OK PAUSE CONTEXT SET\r\n");
                            }
#line 651
                            return (__cil_tmp220);
                          } else {
                            {
#line 653
                            __cil_tmp221 = strcmp((char const   *)set_sub, "spelling\220");
                            }
#line 653
                            if (! __cil_tmp221) {
#line 653
                              if (speechd_socket->inside_block > 0) {
                                {
#line 653
                                __cil_tmp224 = g_strdup((gchar *)"332 ERR NOT ALLOWED INSIDE BLOCK\r\n");
                                }
#line 653
                                return (__cil_tmp224);
                              }
                              {
#line 653
                              helper_s = get_param(buf, 3, bytes, 1);
                              }
#line 653
                              if (helper_s == (void *)0) {
                                {
#line 653
                                MSG(4, "Missing parameter from client");
#line 653
                                __cil_tmp226 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                                }
#line 653
                                return (__cil_tmp226);
                              }
                              {
#line 653
                              __cil_tmp227 = strcmp((char const   *)helper_s, "on");
                              }
#line 653
                              if (! __cil_tmp227) {
                                {
#line 653
                                g_free(helper_s);
#line 653
                                tmp___27 = 1;
                                }
                              } else {
#line 653
                                tmp___27 = 0;
                              }
#line 653
                              if (tmp___27) {
#line 653
                                spelling = 1;
                              } else {
                                {
#line 653
                                __cil_tmp229 = strcmp((char const   *)helper_s, "off");
                                }
#line 653
                                if (! __cil_tmp229) {
                                  {
#line 653
                                  g_free(helper_s);
#line 653
                                  tmp___28 = 1;
                                  }
                                } else {
#line 653
                                  tmp___28 = 0;
                                }
#line 653
                                if (tmp___28) {
#line 653
                                  spelling = 0;
                                } else {
                                  {
#line 653
                                  g_free(helper_s);
#line 653
                                  __cil_tmp231 = g_strdup((gchar *)"513 ERR PARAMETER NOT ON OR OFF\r\n");
                                  }
#line 653
                                  return (__cil_tmp231);
                                }
                              }
#line 653
                              if (who == 0) {
                                {
#line 653
                                ret = set_spelling_self(fd, (SPDSpelling )spelling);
                                }
                              } else
#line 653
                              if (who == 1) {
                                {
#line 653
                                ret = set_spelling_uid(uid, (SPDSpelling )spelling);
                                }
                              } else
#line 653
                              if (who == 2) {
                                {
#line 653
                                ret = set_spelling_all((SPDSpelling )spelling);
                                }
                              }

#line 653
                              if (ret) {
                                {
#line 653
                                __cil_tmp235 = g_strdup((gchar *)"308 ERR COULDNT SET SPELLING\r\n");
                                }
#line 653
                                return (__cil_tmp235);
                              }
                              {
#line 653
                              __cil_tmp236 = g_strdup((gchar *)"207 OK SPELLING SET\r\n");
                              }
#line 653
                              return (__cil_tmp236);
                            } else {
                              {
#line 657
                              __cil_tmp237 = strcmp((char const   *)set_sub, "ssml_mode");
                              }
#line 657
                              if (! __cil_tmp237) {
                                {
#line 657
                                helper_s___0 = get_param(buf, 3, bytes, 1);
                                }
#line 657
                                if (helper_s___0 == (void *)0) {
                                  {
#line 657
                                  MSG(4, "Missing parameter from client");
#line 657
                                  __cil_tmp241 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                                  }
#line 657
                                  return (__cil_tmp241);
                                }
                                {
#line 657
                                __cil_tmp242 = strcmp((char const   *)helper_s___0,
                                                      "on");
                                }
#line 657
                                if (! __cil_tmp242) {
                                  {
#line 657
                                  g_free(helper_s___0);
#line 657
                                  tmp___29 = 1;
                                  }
                                } else {
#line 657
                                  tmp___29 = 0;
                                }
#line 657
                                if (tmp___29) {
#line 657
                                  ssml_mode = 1;
                                } else {
                                  {
#line 657
                                  __cil_tmp244 = strcmp((char const   *)helper_s___0,
                                                        "off");
                                  }
#line 657
                                  if (! __cil_tmp244) {
                                    {
#line 657
                                    g_free(helper_s___0);
#line 657
                                    tmp___30 = 1;
                                    }
                                  } else {
#line 657
                                    tmp___30 = 0;
                                  }
#line 657
                                  if (tmp___30) {
#line 657
                                    ssml_mode = 0;
                                  } else {
                                    {
#line 657
                                    g_free(helper_s___0);
#line 657
                                    __cil_tmp246 = g_strdup((gchar *)"513 ERR PARAMETER NOT ON OR OFF\r\n");
                                    }
#line 657
                                    return (__cil_tmp246);
                                  }
                                }
#line 657
                                if (who == 0) {
                                  {
#line 657
                                  ret = set_ssml_mode_self(fd, (SPDDataMode )ssml_mode);
                                  }
                                } else
#line 657
                                if (who == 1) {
                                  {
#line 657
                                  ret = set_ssml_mode_uid(uid, (SPDDataMode )ssml_mode);
                                  }
                                } else
#line 657
                                if (who == 2) {
                                  {
#line 657
                                  ret = set_ssml_mode_all((SPDDataMode )ssml_mode);
                                  }
                                }

#line 657
                                if (ret) {
                                  {
#line 657
                                  __cil_tmp250 = g_strdup((gchar *)"315 ERR COULDNT SET SSML MODE\r\n");
                                  }
#line 657
                                  return (__cil_tmp250);
                                }
                                {
#line 657
                                __cil_tmp251 = g_strdup((gchar *)"219 OK SSML MODE SET\r\n");
                                }
#line 657
                                return (__cil_tmp251);
                              } else {
                                {
#line 661
                                __cil_tmp252 = strcmp((char const   *)set_sub, "debug");
                                }
#line 661
                                if (! __cil_tmp252) {
                                  {
#line 661
                                  helper_s___1 = get_param(buf, 3, bytes, 1);
                                  }
#line 661
                                  if (helper_s___1 == (void *)0) {
                                    {
#line 661
                                    MSG(4, "Missing parameter from client");
#line 661
                                    __cil_tmp256 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                                    }
#line 661
                                    return (__cil_tmp256);
                                  }
                                  {
#line 661
                                  __cil_tmp257 = strcmp((char const   *)helper_s___1,
                                                        "on");
                                  }
#line 661
                                  if (! __cil_tmp257) {
                                    {
#line 661
                                    g_free(helper_s___1);
#line 661
                                    tmp___31 = 1;
                                    }
                                  } else {
#line 661
                                    tmp___31 = 0;
                                  }
#line 661
                                  if (tmp___31) {
#line 661
                                    debug = 1;
                                  } else {
                                    {
#line 661
                                    __cil_tmp259 = strcmp((char const   *)helper_s___1,
                                                          "off");
                                    }
#line 661
                                    if (! __cil_tmp259) {
                                      {
#line 661
                                      g_free(helper_s___1);
#line 661
                                      tmp___32 = 1;
                                      }
                                    } else {
#line 661
                                      tmp___32 = 0;
                                    }
#line 661
                                    if (tmp___32) {
#line 661
                                      debug = 0;
                                    } else {
                                      {
#line 661
                                      g_free(helper_s___1);
#line 661
                                      __cil_tmp261 = g_strdup((gchar *)"513 ERR PARAMETER NOT ON OR OFF\r\n");
                                      }
#line 661
                                      return (__cil_tmp261);
                                    }
                                  }
#line 661
                                  if (who == 0) {
                                    {
#line 661
                                    ret = set_debug_self(fd, debug);
                                    }
                                  } else
#line 661
                                  if (who == 1) {
                                    {
#line 661
                                    ret = set_debug_uid(uid, debug);
                                    }
                                  } else
#line 661
                                  if (who == 2) {
                                    {
#line 661
                                    ret = set_debug_all(debug);
                                    }
                                  }

#line 661
                                  if (ret) {
                                    {
#line 661
                                    __cil_tmp265 = g_strdup((gchar *)"317 ERR COULDNT SET DEBUGGING\r\n");
                                    }
#line 661
                                    return (__cil_tmp265);
                                  }
                                  {
#line 661
                                  __cil_tmp266 = g_strdup_printf((gchar *)"262-%s\r\n262 OK DEBUGGING SET\r\n",
                                                                 SpeechdOptions.debug_destination);
#line 661
                                  __cil_tmp267 = g_strdup(__cil_tmp266);
                                  }
#line 661
                                  return (__cil_tmp267);
                                } else {
                                  {
#line 668
                                  __cil_tmp268 = strcmp((char const   *)set_sub, "notification");
                                  }
#line 668
                                  if (! __cil_tmp268) {
                                    {
#line 668
                                    g_free(set_sub);
#line 668
                                    tmp___33 = 1;
                                    }
                                  } else {
#line 668
                                    tmp___33 = 0;
                                  }
#line 668
                                  if (tmp___33) {
#line 673
                                    if (who != 0) {
                                      {
#line 674
                                      __cil_tmp273 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
                                      }
#line 674
                                      return (__cil_tmp273);
                                    }
                                    {
#line 676
                                    scope = get_param(buf, 3, bytes, 1);
                                    }
#line 676
                                    if (scope == (void *)0) {
                                      {
#line 676
                                      MSG(4, "Missing parameter from client");
#line 676
                                      __cil_tmp275 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                                      }
#line 676
                                      return (__cil_tmp275);
                                    }
                                    {
#line 677
                                    par_s = get_param(buf, 4, bytes, 1);
                                    }
#line 677
                                    if (par_s == (void *)0) {
                                      {
#line 677
                                      MSG(4, "Missing parameter from client");
#line 677
                                      __cil_tmp277 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
                                      }
#line 677
                                      return (__cil_tmp277);
                                    }
                                    {
#line 679
                                    __cil_tmp278 = strcmp((char const   *)par_s, "on");
                                    }
#line 679
                                    if (! __cil_tmp278) {
                                      {
#line 679
                                      g_free(par_s);
#line 679
                                      tmp___34 = 1;
                                      }
                                    } else {
#line 679
                                      tmp___34 = 0;
                                    }
#line 679
                                    if (tmp___34) {
#line 680
                                      par = 1;
                                    } else {
                                      {
#line 681
                                      __cil_tmp280 = strcmp((char const   *)par_s,
                                                            "off");
                                      }
#line 681
                                      if (! __cil_tmp280) {
                                        {
#line 681
                                        g_free(par_s);
#line 681
                                        tmp___35 = 1;
                                        }
                                      } else {
#line 681
                                        tmp___35 = 0;
                                      }
#line 681
                                      if (tmp___35) {
#line 682
                                        par = 0;
                                      } else {
                                        {
#line 684
                                        g_free(par_s);
#line 685
                                        __cil_tmp282 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
                                        }
#line 685
                                        return (__cil_tmp282);
                                      }
                                    }
                                    {
#line 688
                                    ret = set_notification_self(fd, (char const   *)scope,
                                                                par);
#line 689
                                    g_free(scope);
                                    }
#line 691
                                    if (ret) {
                                      {
#line 692
                                      __cil_tmp284 = g_strdup((gchar *)"316 ERR COULDNT SET NOTIFICATION\r\n");
                                      }
#line 692
                                      return (__cil_tmp284);
                                    }
                                    {
#line 693
                                    __cil_tmp285 = g_strdup((gchar *)"220 OK NOTIFICATION SET\r\n");
                                    }
#line 693
                                    return (__cil_tmp285);
                                  } else {
                                    {
#line 695
                                    g_free(set_sub);
#line 696
                                    __cil_tmp286 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
                                    }
#line 696
                                    return (__cil_tmp286);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 699
  __cil_tmp287 = g_strdup((gchar *)"500 ERR INVALID COMMAND\r\n");
  }
#line 699
  return (__cil_tmp287);
}
}
#line 704 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_stop(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  int uid ;
  char *who_s ;
  char *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;

  {
  {
#line 707
  uid = 0;
#line 710
  MSG(5, "Stop received from fd %d.", fd);
#line 712
  who_s = get_param(buf, 1, bytes, 1);
  }
#line 712
  if (who_s == (void *)0) {
    {
#line 712
    MSG(4, "Missing parameter from client");
#line 712
    __cil_tmp8 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 712
    return (__cil_tmp8);
  }
  {
#line 714
  __cil_tmp9 = strcmp((char const   *)who_s, "all");
  }
#line 714
  if (! __cil_tmp9) {
    {
#line 714
    g_free(who_s);
#line 714
    tmp = 1;
    }
  } else {
#line 714
    tmp = 0;
  }
#line 714
  if (tmp) {
    {
#line 715
    pthread_mutex_lock(& element_free_mutex);
#line 716
    speaking_stop_all();
#line 717
    pthread_mutex_unlock(& element_free_mutex);
    }
  } else {
    {
#line 718
    __cil_tmp11 = strcmp((char const   *)who_s, "self");
    }
#line 718
    if (! __cil_tmp11) {
      {
#line 718
      g_free(who_s);
#line 718
      tmp___0 = 1;
      }
    } else {
#line 718
      tmp___0 = 0;
    }
#line 718
    if (tmp___0) {
      {
#line 719
      uid = get_client_uid_by_fd(fd);
      }
#line 720
      if (uid == 0) {
        {
#line 721
        __cil_tmp14 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
        }
#line 721
        return (__cil_tmp14);
      }
      {
#line 722
      pthread_mutex_lock(& element_free_mutex);
#line 723
      speaking_stop(uid);
#line 724
      pthread_mutex_unlock(& element_free_mutex);
      }
    } else {
      {
#line 725
      __cil_tmp15 = isanum((char const   *)who_s);
      }
#line 725
      if (__cil_tmp15) {
        {
#line 726
        uid = atoi((char const   *)who_s);
#line 727
        g_free(who_s);
        }
#line 729
        if (uid <= 0) {
          {
#line 730
          __cil_tmp17 = g_strdup((gchar *)"406 ERR ID DOESNT EXIST\r\n");
          }
#line 730
          return (__cil_tmp17);
        }
        {
#line 731
        pthread_mutex_lock(& element_free_mutex);
#line 732
        speaking_stop(uid);
#line 733
        pthread_mutex_unlock(& element_free_mutex);
        }
      } else {
        {
#line 735
        g_free(who_s);
#line 736
        __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 736
        return (__cil_tmp18);
      }
    }
  }
  {
#line 739
  __cil_tmp19 = g_strdup((gchar *)"210 OK STOPPED\r\n");
  }
#line 739
  return (__cil_tmp19);
}
}
#line 742 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_cancel(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  int uid ;
  char *who_s ;
  char *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;

  {
  {
#line 745
  uid = 0;
#line 748
  MSG(4, "Cancel received from fd %d.", fd);
#line 750
  who_s = get_param(buf, 1, bytes, 1);
  }
#line 750
  if (who_s == (void *)0) {
    {
#line 750
    MSG(4, "Missing parameter from client");
#line 750
    __cil_tmp8 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 750
    return (__cil_tmp8);
  }
  {
#line 752
  __cil_tmp9 = strcmp((char const   *)who_s, "all");
  }
#line 752
  if (! __cil_tmp9) {
    {
#line 752
    g_free(who_s);
#line 752
    tmp = 1;
    }
  } else {
#line 752
    tmp = 0;
  }
#line 752
  if (tmp) {
    {
#line 753
    speaking_cancel_all();
    }
  } else {
    {
#line 754
    __cil_tmp11 = strcmp((char const   *)who_s, "self");
    }
#line 754
    if (! __cil_tmp11) {
      {
#line 754
      g_free(who_s);
#line 754
      tmp___0 = 1;
      }
    } else {
#line 754
      tmp___0 = 0;
    }
#line 754
    if (tmp___0) {
      {
#line 755
      uid = get_client_uid_by_fd(fd);
      }
#line 756
      if (uid == 0) {
        {
#line 757
        __cil_tmp14 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
        }
#line 757
        return (__cil_tmp14);
      }
      {
#line 758
      speaking_cancel(uid);
      }
    } else {
      {
#line 759
      __cil_tmp15 = isanum((char const   *)who_s);
      }
#line 759
      if (__cil_tmp15) {
        {
#line 760
        uid = atoi((char const   *)who_s);
#line 761
        g_free(who_s);
        }
#line 763
        if (uid <= 0) {
          {
#line 764
          __cil_tmp17 = g_strdup((gchar *)"406 ERR ID DOESNT EXIST\r\nU");
          }
#line 764
          return (__cil_tmp17);
        }
        {
#line 765
        speaking_cancel(uid);
        }
      } else {
        {
#line 767
        g_free(who_s);
#line 768
        __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 768
        return (__cil_tmp18);
      }
    }
  }
  {
#line 771
  __cil_tmp19 = g_strdup((gchar *)"213 OK CANCELED\r\n");
  }
#line 771
  return (__cil_tmp19);
}
}
#line 774 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_pause(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  int uid ;
  char *who_s ;
  char *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;

  {
  {
#line 777
  uid = 0;
#line 780
  MSG(4, "Pause received from fd %d.", fd);
#line 782
  who_s = get_param(buf, 1, bytes, 1);
  }
#line 782
  if (who_s == (void *)0) {
    {
#line 782
    MSG(4, "Missing parameter from clientU");
#line 782
    __cil_tmp8 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 782
    return (__cil_tmp8);
  }
  {
#line 787
  __cil_tmp9 = strcmp((char const   *)who_s, "all\177\332U");
  }
#line 787
  if (! __cil_tmp9) {
    {
#line 787
    g_free(who_s);
#line 787
    tmp = 1;
    }
  } else {
#line 787
    tmp = 0;
  }
#line 787
  if (tmp) {
    {
#line 788
    pause_requested = 1;
#line 789
    pause_requested_fd = fd;
#line 790
    speaking_semaphore_post();
    }
  } else {
    {
#line 791
    __cil_tmp11 = strcmp((char const   *)who_s, "self");
    }
#line 791
    if (! __cil_tmp11) {
      {
#line 791
      g_free(who_s);
#line 791
      tmp___0 = 1;
      }
    } else {
#line 791
      tmp___0 = 0;
    }
#line 791
    if (tmp___0) {
      {
#line 792
      uid = get_client_uid_by_fd(fd);
      }
#line 793
      if (uid == 0) {
        {
#line 794
        __cil_tmp14 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
        }
#line 794
        return (__cil_tmp14);
      }
      {
#line 795
      pause_requested = 2;
#line 796
      pause_requested_fd = fd;
#line 797
      pause_requested_uid = uid;
#line 798
      speaking_semaphore_post();
      }
    } else {
      {
#line 799
      __cil_tmp15 = isanum((char const   *)who_s);
      }
#line 799
      if (__cil_tmp15) {
        {
#line 800
        uid = atoi((char const   *)who_s);
#line 801
        g_free(who_s);
        }
#line 802
        if (uid <= 0) {
          {
#line 803
          __cil_tmp17 = g_strdup((gchar *)"406 ERR ID DOESNT EXIST\r\nU");
          }
#line 803
          return (__cil_tmp17);
        }
        {
#line 804
        pause_requested = 2;
#line 805
        pause_requested_fd = fd;
#line 806
        pause_requested_uid = uid;
#line 807
        speaking_semaphore_post();
        }
      } else {
        {
#line 809
        g_free(who_s);
#line 810
        __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 810
        return (__cil_tmp18);
      }
    }
  }
  {
#line 813
  __cil_tmp19 = g_strdup((gchar *)"211 OK PAUSED\r\n\177\332U");
  }
#line 813
  return (__cil_tmp19);
}
}
#line 816 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_resume(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  int uid ;
  char *who_s ;
  char *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  gchar *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;

  {
  {
#line 819
  uid = 0;
#line 822
  MSG(4, "Resume received from fd %d.", fd);
#line 824
  who_s = get_param(buf, 1, bytes, 1);
  }
#line 824
  if (who_s == (void *)0) {
    {
#line 824
    MSG(4, "Missing parameter from clientU");
#line 824
    __cil_tmp8 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 824
    return (__cil_tmp8);
  }
  {
#line 826
  __cil_tmp9 = strcmp((char const   *)who_s, "all\177\332U");
  }
#line 826
  if (! __cil_tmp9) {
    {
#line 826
    g_free(who_s);
#line 826
    tmp = 1;
    }
  } else {
#line 826
    tmp = 0;
  }
#line 826
  if (tmp) {
    {
#line 827
    speaking_resume_all();
    }
  } else {
    {
#line 828
    __cil_tmp11 = strcmp((char const   *)who_s, "self\332U");
    }
#line 828
    if (! __cil_tmp11) {
      {
#line 828
      g_free(who_s);
#line 828
      tmp___0 = 1;
      }
    } else {
#line 828
      tmp___0 = 0;
    }
#line 828
    if (tmp___0) {
      {
#line 829
      uid = get_client_uid_by_fd(fd);
      }
#line 830
      if (uid == 0) {
        {
#line 831
        __cil_tmp14 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
        }
#line 831
        return (__cil_tmp14);
      }
      {
#line 832
      speaking_resume(uid);
      }
    } else {
      {
#line 833
      __cil_tmp15 = isanum((char const   *)who_s);
      }
#line 833
      if (__cil_tmp15) {
        {
#line 834
        uid = atoi((char const   *)who_s);
#line 835
        g_free(who_s);
        }
#line 836
        if (uid <= 0) {
          {
#line 837
          __cil_tmp17 = g_strdup((gchar *)"406 ERR ID DOESNT EXIST\r\nU");
          }
#line 837
          return (__cil_tmp17);
        }
        {
#line 838
        speaking_resume(uid);
        }
      } else {
        {
#line 840
        g_free(who_s);
#line 841
        __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 841
        return (__cil_tmp18);
      }
    }
  }
  {
#line 844
  __cil_tmp19 = g_strdup((gchar *)"212 OK RESUMED\r\n\332U");
  }
#line 844
  return (__cil_tmp19);
}
}
#line 847 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_general_event(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ,
                          SPDMessageType type ) 
{ 
  char *param ;
  TSpeechDMessage *msg ;
  int msg_uid ;
  char *__cil_tmp9 ;
  gchar *__cil_tmp10 ;
  gchar *__cil_tmp11 ;
  gboolean __cil_tmp12 ;
  gchar *__cil_tmp13 ;
  gpointer __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  gchar *__cil_tmp16 ;
  int __cil_tmp17 ;
  gchar *__cil_tmp18 ;

  {
  {
#line 855
  param = get_param(buf, 1, bytes, 0);
  }
#line 855
  if (param == (void *)0) {
    {
#line 855
    MSG(4, "Missing parameter from client");
#line 855
    __cil_tmp10 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 855
    return (__cil_tmp10);
  }

#line 857
  if ((int )*(param + 0) == 0) {
    {
#line 858
    g_free(param);
#line 859
    __cil_tmp11 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 859
    return (__cil_tmp11);
  }
  {
#line 864
  __cil_tmp12 = g_utf8_validate(buf, (gssize )bytes, (gchar **)((void *)0));
  }
#line 864
  if (! __cil_tmp12) {
    {
#line 865
    MSG(4, "ERROR: Invalid character encoding on event input (failed UTF-8 validation)");
#line 867
    MSG(4, "Rejecting this event (char/key/sound_icon).");
#line 868
    __cil_tmp13 = g_strdup((gchar *)"501 ERR INVALID ENCODING\r\n");
    }
#line 868
    return (__cil_tmp13);
  }
  {
#line 871
  __cil_tmp14 = g_malloc(sizeof(TSpeechDMessage ));
#line 871
  msg = (TSpeechDMessage *)__cil_tmp14;
#line 872
  __cil_tmp15 = strlen((char const   *)param);
#line 872
  msg->bytes = (int )__cil_tmp15;
#line 873
  msg->buf = g_strdup(param);
#line 875
  msg_uid = queue_message(msg, fd, 1, type, speechd_socket->inside_block);
  }
#line 876
  if (msg_uid == 0) {
#line 877
    if (0) {
      {
#line 878
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 878
        fatal_error();
#line 878
        MSG(- 1, "Fatal error [%s:%d]:Couldn\'t queue message\n", "./src/server/parse.c",
            878);
#line 878
        exit(1);
        }
#line 878
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 879
    MSG(2, "Error: Couldn\'t queue message!\n");
    }
  }
  {
#line 882
  g_free(param);
#line 884
  __cil_tmp18 = g_strdup_printf((gchar *)"225-%d\r\n225 OK MESSAGE QUEUED\r\n", msg_uid);
  }
#line 884
  return (__cil_tmp18);
}
}
#line 888 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_snd_icon(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 891
  __cil_tmp5 = parse_general_event(buf, bytes, fd, speechd_socket, (SPDMessageType )1);
  }
#line 891
  return (__cil_tmp5);
}
}
#line 895 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_char(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 898
  __cil_tmp5 = parse_general_event(buf, bytes, fd, speechd_socket, (SPDMessageType )2);
  }
#line 898
  return (__cil_tmp5);
}
}
#line 902 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_key(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 905
  __cil_tmp5 = parse_general_event(buf, bytes, fd, speechd_socket, (SPDMessageType )3);
  }
#line 905
  return (__cil_tmp5);
}
}
#line 909 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_list(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *list_type ;
  char *voice_list ;
  char *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  gpointer __cil_tmp11 ;
  int __cil_tmp12 ;
  int tmp___0 ;
  GString *result ;
  GString *__cil_tmp15 ;
  char *helper ;
  OutputModule *mod ;
  int i ;
  int len ;
  guint __cil_tmp20 ;
  gpointer __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int tmp___1 ;
  int uid ;
  TFDSetElement *settings ;
  SPDVoice **voices ;
  GString *result___0 ;
  int i___0 ;
  char *helper___0 ;
  int __cil_tmp33 ;
  TFDSetElement *__cil_tmp34 ;
  gchar *__cil_tmp35 ;
  SPDVoice **__cil_tmp36 ;
  gchar *__cil_tmp37 ;
  GString *__cil_tmp38 ;
  int __cil_tmp39 ;
  gchar *__cil_tmp40 ;

  {
  {
#line 915
  list_type = get_param(buf, 1, bytes, 1);
  }
#line 915
  if (list_type == (void *)0) {
    {
#line 915
    MSG(4, "Missing parameter from clientU");
#line 915
    __cil_tmp8 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 915
    return (__cil_tmp8);
  }
  {
#line 917
  __cil_tmp9 = strcmp((char const   *)list_type, "voices");
  }
#line 917
  if (! __cil_tmp9) {
    {
#line 917
    g_free(list_type);
#line 917
    tmp = 1;
    }
  } else {
#line 917
    tmp = 0;
  }
#line 917
  if (tmp) {
    {
#line 918
    __cil_tmp11 = g_malloc((gsize )1024);
#line 918
    voice_list = (char *)__cil_tmp11;
#line 919
    sprintf(voice_list, "249-MALE1\r\n249-MALE2\r\n249-MALE3\r\n249-FEMALE1\r\n249-FEMALE2\r\n249-FEMALE3\r\n249-CHILD_MALE\r\n249-CHILD_FEMALE\r\n249 OK VOICE LIST SENT\r\n");
    }
#line 928
    return (voice_list);
  } else {
    {
#line 929
    __cil_tmp12 = strcmp((char const   *)list_type, "output_modules");
    }
#line 929
    if (! __cil_tmp12) {
      {
#line 929
      g_free(list_type);
#line 929
      tmp___0 = 1;
      }
    } else {
#line 929
      tmp___0 = 0;
    }
#line 929
    if (tmp___0) {
      {
#line 930
      __cil_tmp15 = g_string_new((gchar *)"\220");
#line 930
      result = __cil_tmp15;
#line 935
      __cil_tmp20 = g_list_length(output_modules);
#line 935
      len = (int )__cil_tmp20;
#line 936
      i = 0;
      }
      {
#line 936
      while (1) {
        while_continue: /* CIL Label */ ;
#line 936
        if (! (i < len)) {
#line 936
          goto while_break;
        }
        {
#line 937
        mod = (OutputModule *)g_list_nth_data(output_modules, (guint )i);
#line 938
        __cil_tmp23 = strcmp((char const   *)mod->name, "generic");
        }
        {
#line 938
        __cil_tmp22 = strcmp((char const   *)mod->name, "dummyU");
        }
#line 938
        if (__cil_tmp22) {
#line 938
          if (__cil_tmp23) {
            {
#line 940
            g_string_append_printf(result, (gchar *)"250-%s\r\n\230\001", mod->name);
            }
          }
        }
#line 936
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 945
      g_string_append(result, (gchar *)"250 OK MODULE LIST SENT\r\nU");
#line 946
      helper = result->str;
#line 947
      g_string_free(result, 0);
      }
#line 949
      return (helper);
    } else {
      {
#line 950
      __cil_tmp25 = strcmp((char const   *)list_type, "synthesis_voices\220");
      }
#line 950
      if (! __cil_tmp25) {
        {
#line 950
        g_free(list_type);
#line 950
        tmp___1 = 1;
        }
      } else {
#line 950
        tmp___1 = 0;
      }
#line 950
      if (tmp___1) {
        {
#line 958
        uid = get_client_uid_by_fd(fd);
#line 959
        settings = get_client_settings_by_uid(uid);
        }
#line 960
        if (settings == (void *)0) {
          {
#line 961
          __cil_tmp35 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
          }
#line 961
          return (__cil_tmp35);
        }
        {
#line 962
        voices = output_list_voices((char const   *)settings->output_module);
        }
#line 963
        if (voices == (void *)0) {
          {
#line 964
          __cil_tmp37 = g_strdup((gchar *)"321 ERR MODULE CANT REPORT VOICES\r\n");
          }
#line 964
          return (__cil_tmp37);
        }
        {
#line 966
        result___0 = g_string_new((gchar *)"\220");
#line 967
        i___0 = 0;
        }
        {
#line 967
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 967
          if (! 1) {
#line 967
            goto while_break___0;
          }
#line 968
          if (*(voices + i___0) == (void *)0) {
#line 969
            goto while_break___0;
          }
          {
#line 970
          g_string_append_printf(result___0, (gchar *)"249-%s\t%s\t%s\r\n", (*(voices + i___0))->name,
                                 (*(voices + i___0))->language, (*(voices + i___0))->variant);
#line 975
          g_free((*(voices + i___0))->name);
#line 976
          g_free((*(voices + i___0))->language);
#line 977
          g_free((*(voices + i___0))->variant);
#line 978
          g_free(*(voices + i___0));
          }
#line 967
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 980
        g_string_append(result___0, (gchar *)"249 OK VOICE LIST SENT\r\n");
#line 981
        helper___0 = result___0->str;
#line 982
        g_string_free(result___0, 0);
#line 983
        g_free(voices);
        }
#line 984
        return (helper___0);
      } else {
        {
#line 986
        g_free(list_type);
#line 987
        __cil_tmp40 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
        }
#line 987
        return (__cil_tmp40);
      }
    }
  }
}
}
#line 991 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_get(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *get_type ;
  GString *result ;
  char *helper ;
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp9 ;
  gchar *__cil_tmp10 ;
  GString *__cil_tmp11 ;
  char *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  int tmp___0 ;
  int __cil_tmp18 ;
  int tmp___1 ;
  int __cil_tmp20 ;
  int tmp___2 ;
  int __cil_tmp22 ;
  int tmp___3 ;
  int __cil_tmp24 ;
  int tmp___4 ;
  int __cil_tmp26 ;
  int tmp___5 ;
  char *punct ;
  char *__cil_tmp29 ;

  {
  {
#line 1000
  settings = get_client_settings_by_fd(fd);
  }
#line 1001
  if (settings == (void *)0) {
    {
#line 1002
    __cil_tmp10 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
    }
#line 1002
    return (__cil_tmp10);
  }
  {
#line 1004
  result = g_string_new((gchar *)"\220");
#line 1005
  get_type = get_param(buf, 1, bytes, 1);
  }
#line 1005
  if (get_type == (void *)0) {
    {
#line 1005
    MSG(4, "Missing parameter from clientU");
#line 1005
    __cil_tmp13 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 1005
    return (__cil_tmp13);
  }
  {
#line 1006
  __cil_tmp14 = strcmp((char const   *)get_type, "voice_type(\177\332U");
  }
#line 1006
  if (! __cil_tmp14) {
    {
#line 1006
    g_free(get_type);
#line 1006
    tmp = 1;
    }
  } else {
#line 1006
    tmp = 0;
  }
#line 1006
  if (tmp) {
    {
#line 1008
    if ((int )settings->msg_settings.voice_type == 1) {
#line 1008
      goto case_1;
    }
#line 1011
    if ((int )settings->msg_settings.voice_type == 2) {
#line 1011
      goto case_2;
    }
#line 1014
    if ((int )settings->msg_settings.voice_type == 3) {
#line 1014
      goto case_3;
    }
#line 1017
    if ((int )settings->msg_settings.voice_type == 4) {
#line 1017
      goto case_4;
    }
#line 1020
    if ((int )settings->msg_settings.voice_type == 5) {
#line 1020
      goto case_5;
    }
#line 1023
    if ((int )settings->msg_settings.voice_type == 6) {
#line 1023
      goto case_6;
    }
#line 1026
    if ((int )settings->msg_settings.voice_type == 7) {
#line 1026
      goto case_7;
    }
#line 1030
    if ((int )settings->msg_settings.voice_type == 8) {
#line 1030
      goto case_8;
    }
#line 1034
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1009
    g_string_append(result, (gchar *)"251-MALE1\r\n251 OK GET RETURNED\r\n\220");
    }
#line 1010
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1012
    g_string_append(result, (gchar *)"251-MALE2\r\n251 OK GET RETURNED\r\n\220");
    }
#line 1013
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1015
    g_string_append(result, (gchar *)"251-MALE3\r\n251 OK GET RETURNED\r\n\220");
    }
#line 1016
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1018
    g_string_append(result, (gchar *)"251-FEMALE1\r\n251 OK GET RETURNED\r\n");
    }
#line 1019
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1021
    g_string_append(result, (gchar *)"251-FEMALE2\r\n251 OK GET RETURNED\r\n(\177\332U");
    }
#line 1022
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1024
    g_string_append(result, (gchar *)"251-FEMALE3\r\n251 OK GET RETURNED\r\n\'\177\332U");
    }
#line 1025
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1027
    g_string_append(result, (gchar *)"251-CHILD_MALE\r\n251 OK GET RETURNED\r\nU");
    }
#line 1029
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1031
    g_string_append(result, (gchar *)"251-CHILD_FEMALE\r\n251 OK GET RETURNED\r\n");
    }
#line 1033
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1035
    g_string_append(result, (gchar *)"251-NO_VOICE\r\n251 OK GET RETURNED\r\n\177\332U");
    }
#line 1037
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1039
    __cil_tmp16 = strcmp((char const   *)get_type, "output_moduleU");
    }
#line 1039
    if (! __cil_tmp16) {
      {
#line 1039
      g_free(get_type);
#line 1039
      tmp___0 = 1;
      }
    } else {
#line 1039
      tmp___0 = 0;
    }
#line 1039
    if (tmp___0) {
      {
#line 1040
      g_string_append_printf(result, (gchar *)"251-%s\r\n251 OK GET RETURNED\r\n",
                             settings->output_module);
      }
    } else {
      {
#line 1042
      __cil_tmp18 = strcmp((char const   *)get_type, "language\220");
      }
#line 1042
      if (! __cil_tmp18) {
        {
#line 1042
        g_free(get_type);
#line 1042
        tmp___1 = 1;
        }
      } else {
#line 1042
        tmp___1 = 0;
      }
#line 1042
      if (tmp___1) {
        {
#line 1043
        g_string_append_printf(result, (gchar *)"251-%s\r\n251 OK GET RETURNED\r\nU",
                               settings->msg_settings.voice.language);
        }
      } else {
        {
#line 1045
        __cil_tmp20 = strcmp((char const   *)get_type, "rate\332U");
        }
#line 1045
        if (! __cil_tmp20) {
          {
#line 1045
          g_free(get_type);
#line 1045
          tmp___2 = 1;
          }
        } else {
#line 1045
          tmp___2 = 0;
        }
#line 1045
        if (tmp___2) {
          {
#line 1046
          g_string_append_printf(result, (gchar *)"251-%d\r\n251 OK GET RETURNED\r\nU",
                                 settings->msg_settings.rate);
          }
        } else {
          {
#line 1048
          __cil_tmp22 = strcmp((char const   *)get_type, "pitchU");
          }
#line 1048
          if (! __cil_tmp22) {
            {
#line 1048
            g_free(get_type);
#line 1048
            tmp___3 = 1;
            }
          } else {
#line 1048
            tmp___3 = 0;
          }
#line 1048
          if (tmp___3) {
            {
#line 1049
            g_string_append_printf(result, (gchar *)"251-%d\r\n251 OK GET RETURNED\r\n",
                                   settings->msg_settings.pitch);
            }
          } else {
            {
#line 1051
            __cil_tmp24 = strcmp((char const   *)get_type, "volume");
            }
#line 1051
            if (! __cil_tmp24) {
              {
#line 1051
              g_free(get_type);
#line 1051
              tmp___4 = 1;
              }
            } else {
#line 1051
              tmp___4 = 0;
            }
#line 1051
            if (tmp___4) {
              {
#line 1052
              g_string_append_printf(result, (gchar *)"251-%d\r\n251 OK GET RETURNED\r\nU",
                                     settings->msg_settings.volume);
              }
            } else {
              {
#line 1054
              __cil_tmp26 = strcmp((char const   *)get_type, "punctuation\177\332U");
              }
#line 1054
              if (! __cil_tmp26) {
                {
#line 1054
                g_free(get_type);
#line 1054
                tmp___5 = 1;
                }
              } else {
#line 1054
                tmp___5 = 0;
              }
#line 1054
              if (tmp___5) {
                {
#line 1055
                __cil_tmp29 = EPunctMode2str(settings->msg_settings.punctuation_mode);
#line 1055
                punct = __cil_tmp29;
#line 1056
                g_string_append_printf(result, (gchar *)"251-%s\r\n251 OK GET RETURNED\r\n",
                                       punct);
#line 1058
                g_free(punct);
                }
              } else {
                {
#line 1060
                g_free(get_type);
#line 1061
                g_string_append(result, (gchar *)"514 ERR PARAMETER INVALID\r\n");
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1063
  helper = result->str;
#line 1064
  g_string_free(result, 0);
  }
#line 1065
  return (helper);
}
}
#line 1068 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_help(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *help ;
  gpointer __cil_tmp6 ;

  {
  {
#line 1073
  __cil_tmp6 = g_malloc(1024UL * sizeof(char ));
#line 1073
  help = (char *)__cil_tmp6;
#line 1075
  sprintf(help, "248-  SPEAK           -- say text \r\n248-  KEY             -- say a combination of keys \r\n248-  CHAR            -- say a character \r\n248-  SOUND_ICON      -- execute a sound icon \r\n248-  SET             -- set a parameter \r\n248-  GET             -- get a current parameter \r\n248-  LIST            -- list available arguments \r\n248-  HISTORY         -- commands related to history \r\n248-  QUIT            -- close the connection \r\n248 OK HELP SENT\r\n");
  }
#line 1088
  return (help);
}
}
#line 1091 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *parse_block(char const   *buf , int bytes , int fd , TSpeechDSock *speechd_socket ) 
{ 
  char *cmd_main ;
  char *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  int __cil_tmp8 ;
  int tmp ;
  int tmp___0 ;
  gchar *__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  int __cil_tmp13 ;
  int tmp___1 ;
  int tmp___2 ;
  gchar *__cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;

  {
  {
#line 1095
  cmd_main = get_param(buf, 1, bytes, 1);
  }
#line 1095
  if (cmd_main == (void *)0) {
    {
#line 1095
    MSG(4, "Missing parameter from clientU");
#line 1095
    __cil_tmp7 = g_strdup((gchar *)"510 ERR MISSING PARAMETER\r\n");
    }
#line 1095
    return (__cil_tmp7);
  }
  {
#line 1097
  __cil_tmp8 = strcmp((char const   *)cmd_main, "begin");
  }
#line 1097
  if (! __cil_tmp8) {
    {
#line 1097
    g_free(cmd_main);
#line 1097
    tmp = 1;
    }
  } else {
#line 1097
    tmp = 0;
  }
#line 1097
  if (tmp) {
#line 1099
    if (speechd_socket->inside_block == 0) {
      {
#line 1100
      (SpeechdStatus.max_gid) ++;
#line 1100
      speechd_socket->inside_block = SpeechdStatus.max_gid;
#line 1101
      __cil_tmp11 = g_strdup((gchar *)"260 OK INSIDE BLOCK\r\n");
      }
#line 1101
      return (__cil_tmp11);
    } else {
      {
#line 1103
      __cil_tmp12 = g_strdup((gchar *)"330 ERR ALREADY INSIDE BLOCK\r\n");
      }
#line 1103
      return (__cil_tmp12);
    }
  } else {
    {
#line 1105
    __cil_tmp13 = strcmp((char const   *)cmd_main, "end");
    }
#line 1105
    if (! __cil_tmp13) {
      {
#line 1105
      g_free(cmd_main);
#line 1105
      tmp___1 = 1;
      }
    } else {
#line 1105
      tmp___1 = 0;
    }
#line 1105
    if (tmp___1) {
#line 1107
      if (speechd_socket->inside_block > 0) {
        {
#line 1108
        speechd_socket->inside_block = 0;
#line 1109
        __cil_tmp16 = g_strdup((gchar *)"261 OK OUTSIDE BLOCK\r\n\254{\332U");
        }
#line 1109
        return (__cil_tmp16);
      } else {
        {
#line 1111
        __cil_tmp17 = g_strdup((gchar *)"331 ERR ALREADY OUTSIDE BLOCK\r\n\177\332U");
        }
#line 1111
        return (__cil_tmp17);
      }
    } else {
      {
#line 1114
      g_free(cmd_main);
#line 1115
      __cil_tmp18 = g_strdup((gchar *)"514 ERR PARAMETER INVALID\r\n");
      }
#line 1115
      return (__cil_tmp18);
    }
  }
}
}
#line 1133 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *deescape_dot(char const   *orig_text , size_t orig_len ) 
{ 
  static char const   *DOTLINE ;
  static size_t DOTLINELEN ;
  static size_t ESCAPED_DOTLINELEN ;
  char *out_text ;
  char *out_ptr ;
  char const   *orig_end ;
  gpointer __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {
#line 1140
  DOTLINE = "\r\n.\177\332U";
#line 1141
  DOTLINELEN = (size_t )3;
#line 1142
  ESCAPED_DOTLINELEN = (size_t )4;
#line 1144
  out_text = (char *)((void *)0);
#line 1146
  orig_end = orig_text + orig_len;
#line 1148
  if (orig_text == (void *)0) {
#line 1149
    return ((char *)((void *)0));
  }
  {
#line 1151
  out_text = (char *)g_malloc(orig_len + 1UL);
#line 1156
  out_ptr = out_text;
  }
#line 1157
  if (orig_len >= 2UL) {
#line 1159
    if ((int )*(orig_text + 0) == 46) {
#line 1159
      if ((int )*(orig_text + 1) == 46) {
#line 1160
        __cil_tmp10 = out_ptr;
#line 1160
        out_ptr ++;
#line 1160
        *__cil_tmp10 = (char )'.';
#line 1161
        orig_text += 2;
      }
    }
  }
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (! (orig_text < orig_end)) {
#line 1165
      goto while_break;
    }
#line 1166
    if ((int )*(orig_text + 0) == 13) {
#line 1166
      if ((int )*(orig_text + 1) == 10) {
#line 1166
        if ((int )*(orig_text + 2) == 46) {
#line 1166
          if ((int )*(orig_text + 3) == 46) {
            {
#line 1169
            memcpy(out_ptr, DOTLINE, DOTLINELEN);
#line 1170
            out_ptr += DOTLINELEN;
#line 1171
            orig_text += ESCAPED_DOTLINELEN;
            }
          } else {
#line 1174
            __cil_tmp12 = orig_text;
#line 1174
            orig_text ++;
#line 1174
            __cil_tmp11 = out_ptr;
#line 1174
            out_ptr ++;
#line 1174
            *__cil_tmp11 = *__cil_tmp12;
          }
        } else {
#line 1174
          __cil_tmp12 = orig_text;
#line 1174
          orig_text ++;
#line 1174
          __cil_tmp11 = out_ptr;
#line 1174
          out_ptr ++;
#line 1174
          *__cil_tmp11 = *__cil_tmp12;
        }
      } else {
#line 1174
        __cil_tmp12 = orig_text;
#line 1174
        orig_text ++;
#line 1174
        __cil_tmp11 = out_ptr;
#line 1174
        out_ptr ++;
#line 1174
        *__cil_tmp11 = *__cil_tmp12;
      }
    } else {
#line 1174
      __cil_tmp12 = orig_text;
#line 1174
      orig_text ++;
#line 1174
      __cil_tmp11 = out_ptr;
#line 1174
      out_ptr ++;
#line 1174
      *__cil_tmp11 = *__cil_tmp12;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  *out_ptr = (char )'\000';
#line 1179
  return (out_text);
}
}
#line 1184 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
int isanum(char const   *str ) 
{ 
  int i ;
  unsigned short const   **__cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned short const   **__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1187
  __cil_tmp3 = __ctype_b_loc();
  }
#line 1187
  if (! ((int )*(*__cil_tmp3 + (int )*(str + 0)) & 2048)) {
#line 1187
    if (! ((int )*(str + 0) == 43 || (int )*(str + 0) == 45)) {
#line 1188
      return (0);
    }
  }
#line 1189
  i = 1;
  {
#line 1189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1189
    if (! ((unsigned long )i <= __cil_tmp4 - 1UL)) {
#line 1189
      goto while_break;
    }
    {
#line 1190
    __cil_tmp5 = __ctype_b_loc();
    }
#line 1190
    if (! ((int )*(*__cil_tmp5 + (int )*(str + i)) & 2048)) {
#line 1191
      return (0);
    }
#line 1189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1193
  return (1);
}
}
#line 1199 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
char *get_param(char const   *buf , int n , int bytes , int lower_case ) 
{ 
  char *param ;
  char *par ;
  int i ;
  int y ;
  int z ;
  int tmp ;
  gpointer __cil_tmp11 ;
  int tmp___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp___1 ;
  unsigned long __cil_tmp18 ;
  gchar *__cil_tmp19 ;

  {
  {
#line 1204
  z = 0;
#line 1207
  __cil_tmp11 = g_malloc((gsize )bytes);
#line 1207
  param = (char *)__cil_tmp11;
#line 1210
  strcpy(param, "\220");
#line 1211
  i = 0;
#line 1216
  y = 0;
  }
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (! (y <= n)) {
#line 1216
      goto while_break;
    }
#line 1217
    z = 0;
    {
#line 1218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1218
      if (! (i < bytes)) {
#line 1218
        goto while_break___0;
      }
#line 1219
      if ((int )*(buf + i) == 32) {
#line 1220
        goto while_break___0;
      }
#line 1221
      *(param + z) = *(buf + i);
#line 1222
      z ++;
#line 1218
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1224
    i ++;
#line 1216
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  if (z <= 0) {
    {
#line 1228
    g_free(param);
    }
#line 1229
    return ((char *)((void *)0));
  }
#line 1233
  if (i >= bytes) {
#line 1234
    if (z > 1) {
#line 1234
      tmp___1 = z - 2;
    } else {
#line 1234
      tmp___1 = 0;
    }
#line 1234
    *(param + tmp___1) = (char )0;
  } else {
#line 1236
    *(param + z) = (char )0;
  }
#line 1239
  if (lower_case) {
    {
#line 1240
    __cil_tmp18 = strlen((char const   *)param);
#line 1240
    __cil_tmp19 = g_ascii_strdown(param, (gssize )__cil_tmp18);
#line 1240
    par = __cil_tmp19;
#line 1241
    g_free(param);
    }
  } else {
#line 1243
    par = param;
  }
#line 1246
  return (par);
}
}
#line 1254 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/parse.c"
int spd_utf8_read_char(char const   *pointer , char *character ) 
{ 
  int bytes ;
  gunichar u_char ;
  gunichar __cil_tmp5 ;
  gint __cil_tmp6 ;

  {
  {
#line 1259
  u_char = g_utf8_get_char(pointer);
#line 1260
  bytes = g_unichar_to_utf8(u_char, character);
#line 1261
  *(character + bytes) = (char )0;
  }
#line 1263
  return (bytes);
}
}
#line 179 "/usr/include/dotconf.h"
configfile_t *dotconf_create(char * , configoption_t * , context_t * , unsigned long  ) ;
#line 183
void dotconf_cleanup(configfile_t *configfile ) ;
#line 186
int dotconf_command_loop(configfile_t *configfile ) ;
#line 189
char const   *dotconf_command_loop_until_error(configfile_t *configfile ) ;
#line 192
int dotconf_continue_line(char *buffer , size_t length ) ;
#line 195
int dotconf_get_next_line(char *buffer , size_t bufsize , configfile_t *configfile ) ;
#line 199
char *dotconf_get_here_document(configfile_t *configfile , char const   *delimit ) ;
#line 203
char const   *dotconf_invoke_command(configfile_t *configfile , command_t *cmd ) ;
#line 207
configoption_t *dotconf_find_command(configfile_t *configfile , char const   *command ) ;
#line 215
char *dotconf_read_arg(configfile_t *configfile , signed char **line ) ;
#line 218
char const   *dotconf_handle_command(configfile_t *configfile , char *buffer ) ;
#line 222
int dotconf_register_options(configfile_t *configfile , configoption_t *options ) ;
#line 226
int dotconf_warning(configfile_t *configfile , int level , unsigned long errnum ,
                    char const   *  , ...) ;
#line 230
void dotconf_callback(configfile_t *configfile , callback_types type , dotconf_callback_t  ) ;
#line 234
char *dotconf_substitute_env(configfile_t * , char * ) ;
#line 32 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.h"
configoption_t *spd_options ;
#line 33
int spd_num_options ;
#line 35
configoption_t *load_config_options(int *num_options ) ;
#line 36
void free_config_options(configoption_t *opts , int *num ) ;
#line 37
configoption_t *add_config_option(configoption_t *options , int *num_config_options ,
                                  char const   *name , int type , dotconf_callback_t callback ,
                                  info_t *info , unsigned long context ) ;
#line 42
void load_default_global_set_options(void) ;
#line 39 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
static TFDSetClientSpecific *cl_spec_section ;
#line 46 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
configoption_t *add_config_option(configoption_t *options , int *num_config_options ,
                                  char const   *name , int type , dotconf_callback_t callback ,
                                  info_t *info , unsigned long context ) 
{ 
  configoption_t *opts ;
  int __cil_tmp9 ;
  gpointer __cil_tmp10 ;
  gchar *__cil_tmp11 ;

  {
  {
#line 53
  (*num_config_options) ++;
#line 54
  __cil_tmp10 = g_realloc(options, (unsigned long )*num_config_options * sizeof(configoption_t ));
#line 54
  opts = (configoption_t *)__cil_tmp10;
#line 58
  __cil_tmp11 = g_strdup(name);
#line 58
  (opts + (*num_config_options - 1))->name = (char const   *)__cil_tmp11;
#line 59
  (opts + (*num_config_options - 1))->type = type;
#line 60
  (opts + (*num_config_options - 1))->callback = callback;
#line 61
  (opts + (*num_config_options - 1))->info = info;
#line 62
  (opts + (*num_config_options - 1))->context = context;
  }
#line 63
  return (opts);
}
}
#line 67 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
void free_config_options(configoption_t *opts , int *num ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 69
  i = 0;
#line 71
  if (opts == (void *)0) {
#line 72
    return;
  }
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i <= *num - 1)) {
#line 74
      goto while_break;
    }
    {
#line 75
    g_free((char *)(opts + i)->name);
    }
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 77
  g_free(opts);
#line 78
  *num = 0;
#line 79
  opts = (configoption_t *)((void *)0);
  }
  return;
}
}
#line 179 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultModule(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 179
  if (! cl_spec_section) {
    {
#line 179
    GlobalFDSet.output_module = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 179
    cl_spec_section->val.output_module = g_strdup(cmd->data.str);
    }
  }
#line 179
  return ((char const   *)((void *)0));
}
}
#line 180 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultLanguage(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 180
  if (! cl_spec_section) {
    {
#line 180
    GlobalFDSet.msg_settings.voice.language = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 180
    cl_spec_section->val.msg_settings.voice.language = g_strdup(cmd->data.str);
    }
  }
#line 180
  return ((char const   *)((void *)0));
}
}
#line 181 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultClientName(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 181
  if (! cl_spec_section) {
    {
#line 181
    GlobalFDSet.client_name = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 181
    cl_spec_section->val.client_name = g_strdup(cmd->data.str);
    }
  }
#line 181
  return ((char const   *)((void *)0));
}
}
#line 183 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioOutputMethod(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 183
  if (! cl_spec_section) {
    {
#line 183
    GlobalFDSet.audio_output_method = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 183
    cl_spec_section->val.audio_output_method = g_strdup(cmd->data.str);
    }
  }
#line 183
  return ((char const   *)((void *)0));
}
}
#line 184 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioOSSDevice(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 184
  if (! cl_spec_section) {
    {
#line 184
    GlobalFDSet.audio_oss_device = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 184
    cl_spec_section->val.audio_oss_device = g_strdup(cmd->data.str);
    }
  }
#line 184
  return ((char const   *)((void *)0));
}
}
#line 185 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioALSADevice(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 185
  if (! cl_spec_section) {
    {
#line 185
    GlobalFDSet.audio_alsa_device = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 185
    cl_spec_section->val.audio_alsa_device = g_strdup(cmd->data.str);
    }
  }
#line 185
  return ((char const   *)((void *)0));
}
}
#line 186 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioNASServer(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 186
  if (! cl_spec_section) {
    {
#line 186
    GlobalFDSet.audio_nas_server = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 186
    cl_spec_section->val.audio_nas_server = g_strdup(cmd->data.str);
    }
  }
#line 186
  return ((char const   *)((void *)0));
}
}
#line 187 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioPulseServer(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 187
  if (! cl_spec_section) {
    {
#line 187
    GlobalFDSet.audio_pulse_server = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 187
    cl_spec_section->val.audio_pulse_server = g_strdup(cmd->data.str);
    }
  }
#line 187
  return ((char const   *)((void *)0));
}
}
#line 188 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioPulseDevice(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 188
  if (! cl_spec_section) {
    {
#line 188
    GlobalFDSet.audio_pulse_device = g_strdup(cmd->data.str);
    }
  } else {
    {
#line 188
    cl_spec_section->val.audio_pulse_device = g_strdup(cmd->data.str);
    }
  }
#line 188
  return ((char const   *)((void *)0));
}
}
#line 189 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AudioPulseMinLength(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 189
  val = (int )cmd->data.value;
#line 189
  if (! 1) {
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 189
      fatal_error();
#line 189
      MSG(- 1, "Fatal error [%s:%d]:\323\001 ~\001", "./src/server/configuration.c",
          189);
#line 189
      exit(1);
      }
#line 189
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 189
  if (! cl_spec_section) {
#line 189
    GlobalFDSet.audio_pulse_min_length = val;
  } else {
#line 189
    cl_spec_section->val.audio_pulse_min_length = val;
  }
#line 189
  return ((char const   *)((void *)0));
}
}
#line 191 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultRate(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 191
  val = (int )cmd->data.value;
#line 191
  if (! (val >= -100 && val <= 100)) {
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 191
      fatal_error();
#line 191
      MSG(- 1, "Fatal error [%s:%d]:Rate out of range.", "./src/server/configuration.c",
          191);
#line 191
      exit(1);
      }
#line 191
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 191
  if (! cl_spec_section) {
#line 191
    GlobalFDSet.msg_settings.rate = val;
  } else {
#line 191
    cl_spec_section->val.msg_settings.rate = val;
  }
#line 191
  return ((char const   *)((void *)0));
}
}
#line 193 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultPitch(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 193
  val = (int )cmd->data.value;
#line 193
  if (! (val >= -100 && val <= 100)) {
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 193
      fatal_error();
#line 193
      MSG(- 1, "Fatal error [%s:%d]:Pitch out of range.", "./src/server/configuration.c",
          193);
#line 193
      exit(1);
      }
#line 193
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 193
  if (! cl_spec_section) {
#line 193
    GlobalFDSet.msg_settings.pitch = val;
  } else {
#line 193
    cl_spec_section->val.msg_settings.pitch = val;
  }
#line 193
  return ((char const   *)((void *)0));
}
}
#line 195 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultPitchRange(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 195
  val = (int )cmd->data.value;
#line 195
  if (! (val >= -100 && val <= 100)) {
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 195
      fatal_error();
#line 195
      MSG(- 1, "Fatal error [%s:%d]:Pitch range out of range.", "./src/server/configuration.c",
          195);
#line 195
      exit(1);
      }
#line 195
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 195
  if (! cl_spec_section) {
#line 195
    GlobalFDSet.msg_settings.pitch_range = val;
  } else {
#line 195
    cl_spec_section->val.msg_settings.pitch_range = val;
  }
#line 195
  return ((char const   *)((void *)0));
}
}
#line 198 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultVolume(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 198
  val = (int )cmd->data.value;
#line 198
  if (! (val >= -100 && val <= 100)) {
    {
#line 198
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 198
      fatal_error();
#line 198
      MSG(- 1, "Fatal error [%s:%d]:Volume out of range.", "./src/server/configuration.c",
          198);
#line 198
      exit(1);
      }
#line 198
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 198
  if (! cl_spec_section) {
#line 198
    GlobalFDSet.msg_settings.volume = val;
  } else {
#line 198
    cl_spec_section->val.msg_settings.volume = val;
  }
#line 198
  return ((char const   *)((void *)0));
}
}
#line 200 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultSpelling(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 200
  val = (int )cmd->data.value;
#line 200
  if (! 1) {
    {
#line 200
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 200
      fatal_error();
#line 200
      MSG(- 1, "Fatal error [%s:%d]:Invalid spelling mode", "./src/server/configuration.c",
          200);
#line 200
      exit(1);
      }
#line 200
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 200
  if (! cl_spec_section) {
#line 200
    GlobalFDSet.msg_settings.spelling_mode = (SPDSpelling )val;
  } else {
#line 200
    cl_spec_section->val.msg_settings.spelling_mode = (SPDSpelling )val;
  }
#line 200
  return ((char const   *)((void *)0));
}
}
#line 202 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultPauseContext(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 202
  val = (int )cmd->data.value;
#line 202
  if (! 1) {
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 202
      fatal_error();
#line 202
      MSG(- 1, "Fatal error [%s:%d]:\323\001 ", "./src/server/configuration.c", 202);
#line 202
      exit(1);
      }
#line 202
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 202
  if (! cl_spec_section) {
#line 202
    GlobalFDSet.pause_context = val;
  } else {
#line 202
    cl_spec_section->val.pause_context = val;
  }
#line 202
  return ((char const   *)((void *)0));
}
}
#line 204 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultPriority(command_t *cmd , context_t *ctx ) 
{ 
  char *val_str ;
  SPDPriority val ;
  unsigned long __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  SPDPriority __cil_tmp7 ;

  {
  {
#line 204
  __cil_tmp5 = strlen((char const   *)cmd->data.str);
#line 204
  __cil_tmp6 = g_ascii_strdown(cmd->data.str, (gssize )__cil_tmp5);
#line 204
  val_str = __cil_tmp6;
  }
#line 204
  if (val_str == (void *)0) {
    {
#line 204
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 204
      fatal_error();
#line 204
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration", "./src/server/configuration.c",
          204);
#line 204
      exit(1);
      }
#line 204
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 204
  val = str2intpriority((char const   *)val_str);
#line 204
  g_free(val_str);
  }
#line 204
  if ((unsigned int )val == 4294967295U) {
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 204
      fatal_error();
#line 204
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration.", "./src/server/configuration.c",
          204);
#line 204
      exit(1);
      }
#line 204
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 204
  if (! cl_spec_section) {
#line 204
    GlobalFDSet.priority = val;
  } else {
#line 204
    cl_spec_section->val.priority = val;
  }
#line 204
  return ((char const   *)((void *)0));
}
}
#line 206 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultVoiceType(command_t *cmd , context_t *ctx ) 
{ 
  char *val_str ;
  SPDVoiceType val ;
  unsigned long __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  SPDVoiceType __cil_tmp7 ;

  {
  {
#line 206
  __cil_tmp5 = strlen((char const   *)cmd->data.str);
#line 206
  __cil_tmp6 = g_ascii_strdown(cmd->data.str, (gssize )__cil_tmp5);
#line 206
  val_str = __cil_tmp6;
  }
#line 206
  if (val_str == (void *)0) {
    {
#line 206
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 206
      fatal_error();
#line 206
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration", "./src/server/configuration.c",
          206);
#line 206
      exit(1);
      }
#line 206
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 206
  val = str2EVoice((char const   *)val_str);
#line 206
  g_free(val_str);
  }
#line 206
  if ((int )val == -1) {
    {
#line 206
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 206
      fatal_error();
#line 206
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration.", "./src/server/configuration.c",
          206);
#line 206
      exit(1);
      }
#line 206
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 206
  if (! cl_spec_section) {
#line 206
    GlobalFDSet.msg_settings.voice_type = val;
  } else {
#line 206
    cl_spec_section->val.msg_settings.voice_type = val;
  }
#line 206
  return ((char const   *)((void *)0));
}
}
#line 208 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultPunctuationMode(command_t *cmd , context_t *ctx ) 
{ 
  char *val_str ;
  SPDPunctuation val ;
  unsigned long __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  SPDPunctuation __cil_tmp7 ;

  {
  {
#line 208
  __cil_tmp5 = strlen((char const   *)cmd->data.str);
#line 208
  __cil_tmp6 = g_ascii_strdown(cmd->data.str, (gssize )__cil_tmp5);
#line 208
  val_str = __cil_tmp6;
  }
#line 208
  if (val_str == (void *)0) {
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 208
      fatal_error();
#line 208
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration", "./src/server/configuration.c",
          208);
#line 208
      exit(1);
      }
#line 208
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 208
  val = str2EPunctMode((char const   *)val_str);
#line 208
  g_free(val_str);
  }
#line 208
  if ((unsigned int )val == 4294967295U) {
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 208
      fatal_error();
#line 208
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration.", "./src/server/configuration.c",
          208);
#line 208
      exit(1);
      }
#line 208
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 208
  if (! cl_spec_section) {
#line 208
    GlobalFDSet.msg_settings.punctuation_mode = val;
  } else {
#line 208
    cl_spec_section->val.msg_settings.punctuation_mode = val;
  }
#line 208
  return ((char const   *)((void *)0));
}
}
#line 211 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_SymbolsPreproc(command_t *cmd , context_t *ctx ) 
{ 
  char *val_str ;
  SymLvl val ;
  unsigned long __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  SymLvl __cil_tmp7 ;

  {
  {
#line 211
  __cil_tmp5 = strlen((char const   *)cmd->data.str);
#line 211
  __cil_tmp6 = g_ascii_strdown(cmd->data.str, (gssize )__cil_tmp5);
#line 211
  val_str = __cil_tmp6;
  }
#line 211
  if (val_str == (void *)0) {
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 211
      fatal_error();
#line 211
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration", "./src/server/configuration.c",
          211);
#line 211
      exit(1);
      }
#line 211
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 211
  val = str2SymLvl((char const   *)val_str);
#line 211
  g_free(val_str);
  }
#line 211
  if ((int )val == -1) {
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 211
      fatal_error();
#line 211
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration.", "./src/server/configuration.c",
          211);
#line 211
      exit(1);
      }
#line 211
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 211
  if (! cl_spec_section) {
#line 211
    GlobalFDSet.symbols_preprocessing = (gboolean )val;
  } else {
#line 211
    cl_spec_section->val.symbols_preprocessing = (gboolean )val;
  }
#line 211
  return ((char const   *)((void *)0));
}
}
#line 213 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DefaultCapLetRecognition(command_t *cmd , context_t *ctx ) 
{ 
  char *val_str ;
  SPDCapitalLetters val ;
  unsigned long __cil_tmp5 ;
  gchar *__cil_tmp6 ;
  SPDCapitalLetters __cil_tmp7 ;

  {
  {
#line 213
  __cil_tmp5 = strlen((char const   *)cmd->data.str);
#line 213
  __cil_tmp6 = g_ascii_strdown(cmd->data.str, (gssize )__cil_tmp5);
#line 213
  val_str = __cil_tmp6;
  }
#line 213
  if (val_str == (void *)0) {
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 213
      fatal_error();
#line 213
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration", "./src/server/configuration.c",
          213);
#line 213
      exit(1);
      }
#line 213
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 213
  val = str2ECapLetRecogn((char const   *)val_str);
#line 213
  g_free(val_str);
  }
#line 213
  if ((unsigned int )val == 4294967295U) {
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 213
      fatal_error();
#line 213
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter in configuration.", "./src/server/configuration.c",
          213);
#line 213
      exit(1);
      }
#line 213
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 213
  if (! cl_spec_section) {
#line 213
    GlobalFDSet.msg_settings.cap_let_recogn = val;
  } else {
#line 213
    cl_spec_section->val.msg_settings.cap_let_recogn = val;
  }
#line 213
  return ((char const   *)((void *)0));
}
}
#line 217 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_CommunicationMethod(command_t *cmd , context_t *ctx ) 
{ 
  gchar *__cil_tmp3 ;

  {
#line 217
  if (cl_spec_section) {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 217
      fatal_error();
#line 217
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c", 217);
#line 217
      exit(1);
      }
#line 217
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 217
  if (! SpeechdOptions.communication_method_set) {
    {
#line 217
    SpeechdOptions.communication_method = g_strdup(cmd->data.str);
    }
  }
#line 217
  return ((char const   *)((void *)0));
}
}
#line 218 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_SocketPath(command_t *cmd , context_t *ctx ) 
{ 
  gchar *__cil_tmp3 ;

  {
#line 218
  if (cl_spec_section) {
    {
#line 218
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 218
      fatal_error();
#line 218
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c\001", 218);
#line 218
      exit(1);
      }
#line 218
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 218
  if (! SpeechdOptions.socket_path_set) {
    {
#line 218
    SpeechdOptions.socket_path = g_strdup(cmd->data.str);
    }
  }
#line 218
  return ((char const   *)((void *)0));
}
}
#line 219 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_Port(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 219
  val = (int )cmd->data.value;
#line 219
  if (cl_spec_section) {
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 219
      fatal_error();
#line 219
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 \376\001",
          "./src/server/configuration.c\002", 219);
#line 219
      exit(1);
      }
#line 219
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 219
  if (! (val >= 0)) {
    {
#line 219
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 219
      fatal_error();
#line 219
      MSG(- 1, "Fatal error [%s:%d]:Invalid port number!\002", "./src/server/configuration.c\t",
          219);
#line 219
      exit(1);
      }
#line 219
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 219
  if (! SpeechdOptions.port_set) {
#line 219
    SpeechdOptions.port = val;
  }
#line 219
  return ((char const   *)((void *)0));
}
}
#line 220 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_LocalhostAccessOnly(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 220
  val = (int )cmd->data.value;
#line 220
  if (cl_spec_section) {
    {
#line 220
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 220
      fatal_error();
#line 220
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c\002", 220);
#line 220
      exit(1);
      }
#line 220
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 220
  if (! (val >= 0)) {
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 220
      fatal_error();
#line 220
      MSG(- 1, "Fatal error [%s:%d]:Invalid access control mode!\265\023\001", "./src/server/configuration.c\310\r\001",
          220);
#line 220
      exit(1);
      }
#line 220
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 220
  if (! SpeechdOptions.localhost_access_only_set) {
#line 220
    SpeechdOptions.localhost_access_only = val;
  }
#line 220
  return ((char const   *)((void *)0));
}
}
#line 222 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_LogLevel(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 222
  val = (int )cmd->data.value;
#line 222
  if (cl_spec_section) {
    {
#line 222
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 222
      fatal_error();
#line 222
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c\221\271\001", 222);
#line 222
      exit(1);
      }
#line 222
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 222
  if (! (val >= 0 && val <= 5)) {
    {
#line 222
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 222
      fatal_error();
#line 222
      MSG(- 1, "Fatal error [%s:%d]:Invalid log (verbosity) level!", "./src/server/configuration.c\373\345\001",
          222);
#line 222
      exit(1);
      }
#line 222
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 222
  if (! SpeechdOptions.log_level_set) {
#line 222
    SpeechdOptions.log_level = val;
#line 222
    GlobalFDSet.log_level = val;
  }
#line 222
  return ((char const   *)((void *)0));
}
}
#line 224 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_MaxHistoryMessages(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 224
  val = (int )cmd->data.value;
#line 224
  if (cl_spec_section) {
    {
#line 224
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 224
      fatal_error();
#line 224
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c ", 224);
#line 224
      exit(1);
      }
#line 224
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 224
  if (! (val >= 0)) {
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 224
      fatal_error();
#line 224
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter!\003", "./src/server/configuration.c\024[\003",
          224);
#line 224
      exit(1);
      }
#line 224
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 224
  SpeechdOptions.max_history_messages = val;
#line 224
  return ((char const   *)((void *)0));
}
}
#line 226 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_MaxQueueSize(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 226
  val = (int )cmd->data.value;
#line 226
  if (cl_spec_section) {
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 226
      fatal_error();
#line 226
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c\021\002", 226);
#line 226
      exit(1);
      }
#line 226
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 226
  if (! (val >= 0)) {
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 226
      fatal_error();
#line 226
      MSG(- 1, "Fatal error [%s:%d]:Invalid parameter!\004", "./src/server/configuration.c\362\215\004",
          226);
#line 226
      exit(1);
      }
#line 226
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 226
  SpeechdOptions.max_queue_size = val;
#line 226
  return ((char const   *)((void *)0));
}
}
#line 228 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_Timeout(command_t *cmd , context_t *ctx ) 
{ 
  int val ;

  {
#line 228
  val = (int )cmd->data.value;
#line 228
  if (cl_spec_section) {
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 228
      fatal_error();
#line 228
      MSG(- 1, "Fatal error [%s:%d]:This command isn\'t allowed in a client specific section!\323\001 ",
          "./src/server/configuration.c\034", 228);
#line 228
      exit(1);
      }
#line 228
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 228
  if (! (val >= 0)) {
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 228
      fatal_error();
#line 228
      MSG(- 1, "Fatal error [%s:%d]:Invalid timeout value!", "./src/server/configuration.c\351\004\006",
          228);
#line 228
      exit(1);
      }
#line 228
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 228
  if (! SpeechdOptions.server_timeout_set) {
#line 228
    SpeechdOptions.server_timeout = val;
  }
#line 228
  return ((char const   *)((void *)0));
}
}
#line 230 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_LanguageDefaultModule(command_t *cmd , context_t *ctx ) 
{ 
  char *key ;
  char *value ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;

  {
#line 235
  if (*(cmd->data.list + 0) == (void *)0) {
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 236
      fatal_error();
#line 236
      MSG(- 1, "Fatal error [%s:%d]:No language specified for LanguageDefaultModule",
          "./src/server/configuration.c\030\301\006", 236);
#line 236
      exit(1);
      }
#line 236
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 237
  if (*(cmd->data.list + 0) == (void *)0) {
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 238
      fatal_error();
#line 238
      MSG(- 1, "Fatal error [%s:%d]:No module specified for LanguageDefaultModule/\a",
          "./src/server/configuration.c", 238);
#line 238
      exit(1);
      }
#line 238
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 240
  key = g_strdup(*(cmd->data.list + 0));
#line 241
  value = g_strdup(*(cmd->data.list + 1));
#line 243
  g_hash_table_insert(language_default_modules, key, value);
  }
#line 245
  return ((char const   *)((void *)0));
}
}
#line 248 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_LogFile(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  gchar *__cil_tmp4 ;

  {
  {
#line 252
  SpeechdOptions.log_dir = g_path_get_dirname(cmd->data.str);
#line 253
  logging_init();
#line 255
  MSG(1, "WARNING: The LogFile option is deprecated. Directory accepted but filename ignored");
  }
#line 257
  return ((char const   *)((void *)0));
}
}
#line 260 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_LogDir(command_t *cmd , context_t *ctx ) 
{ 
  int tmp ;
  int __cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
  {
#line 264
  __cil_tmp4 = strcmp((char const   *)cmd->data.str, "default");
  }
#line 264
  if (__cil_tmp4) {
#line 264
    if (! SpeechdOptions.log_dir_set) {
      {
#line 267
      SpeechdOptions.log_dir = g_strdup(cmd->data.str);
      }
    }
  }
  {
#line 269
  logging_init();
  }
#line 270
  return ((char const   *)((void *)0));
}
}
#line 273 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_CustomLogFile(command_t *cmd , context_t *ctx ) 
{ 
  char *kind ;
  char *file ;
  gchar *__cil_tmp5 ;
  int tmp ;
  gchar *__cil_tmp7 ;
  int tmp___0 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  FILE *__cil_tmp11 ;

  {
#line 278
  if (*(cmd->data.list + 0) == (void *)0) {
    {
#line 279
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 279
      fatal_error();
#line 279
      MSG(- 1, "Fatal error [%s:%d]:No log kind specified in CustomLogFile", "./src/server/configuration.c",
          279);
#line 279
      exit(1);
      }
#line 279
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 280
  if (*(cmd->data.list + 1) == (void *)0) {
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 281
      fatal_error();
#line 281
      MSG(- 1, "Fatal error [%s:%d]:No log file specified in CustomLogFile", "./src/server/configuration.c",
          281);
#line 281
      exit(1);
      }
#line 281
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 282
  kind = g_strdup(*(cmd->data.list + 0));
#line 284
  file = g_strdup(*(cmd->data.list + 1));
#line 287
  custom_log_kind = kind;
#line 288
  __cil_tmp9 = strncmp((char const   *)file, "stdout", (unsigned long )6);
  }
#line 288
  if (! __cil_tmp9) {
#line 289
    custom_logfile = stdout;
#line 290
    return ((char const   *)((void *)0));
  }
  {
#line 292
  __cil_tmp10 = strncmp((char const   *)file, "stderr", (unsigned long )6);
  }
#line 292
  if (! __cil_tmp10) {
#line 293
    custom_logfile = stderr;
#line 294
    return ((char const   *)((void *)0));
  }
  {
#line 296
  custom_logfile = fopen((char const   *)file, "a");
  }
#line 297
  if (custom_logfile == (void *)0) {
    {
#line 298
    fprintf(stderr, "Error: can\'t open custom log file, using stdout\n\220");
#line 300
    custom_logfile = stdout;
    }
  }
  {
#line 303
  MSG(2, "Speech Dispatcher custom logging to file %s", file);
  }
#line 304
  return ((char const   *)((void *)0));
}
}
#line 307 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_SymbolsPreprocFile(command_t *cmd , context_t *ctx ) 
{ 


  {
#line 309
  if (*(cmd->data.list + 0) == (void *)0) {
    {
#line 310
    MSG(3, "No symbol preprocessing name specified in configuration under SymbolsPreprocFile\220");
    }
#line 312
    return ((char const   *)((void *)0));
  }
  {
#line 315
  symbols_preprocessing_add_file((char const   *)*(cmd->data.list + 0));
  }
#line 317
  return ((char const   *)((void *)0));
}
}
#line 320 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_AddModule(command_t *cmd , context_t *ctx ) 
{ 
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;

  {
#line 322
  if (*(cmd->data.list + 0) == (void *)0) {
    {
#line 323
    MSG(3, "No output module name specified in configuration under AddModule\220");
    }
#line 325
    return ((char const   *)((void *)0));
  }
  {
#line 328
  __cil_tmp3 = g_strdup(*(cmd->data.list + 0));
  }
  {
#line 328
  __cil_tmp4 = g_strdup(*(cmd->data.list + 1));
  }
  {
#line 328
  __cil_tmp5 = g_strdup(*(cmd->data.list + 2));
  }
  {
#line 328
  __cil_tmp6 = g_strdup_printf((gchar *)"%s/%s.log", SpeechdOptions.log_dir, *(cmd->data.list + 0));
#line 328
  module_add_load_request(__cil_tmp3, __cil_tmp4, __cil_tmp5, __cil_tmp6, (char *)((void *)0),
                          (char *)((void *)0));
  }
#line 337
  return ((char const   *)((void *)0));
}
}
#line 344 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_BeginClient(command_t *cmd , context_t *ctx ) 
{ 
  TFDSetClientSpecific *cl_spec ;
  gpointer __cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
#line 348
  if (cl_spec_section != (void *)0) {
    {
#line 349
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 349
      fatal_error();
#line 349
      MSG(- 1, "Fatal error [%s:%d]:Configuration: Already in client specific section, can\'t open a new one!\323\001 ",
          "./src/server/configuration.c", 349);
#line 349
      exit(1);
      }
#line 349
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 352
  if (cmd->data.str == (void *)0) {
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 353
      fatal_error();
#line 353
      MSG(- 1, "Fatal error [%s:%d]:Configuration: You must specify some client\'s name for BeginClient",
          "./src/server/configuration.c\332U", 353);
#line 353
      exit(1);
      }
#line 353
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 356
  __cil_tmp4 = g_malloc(sizeof(TFDSetClientSpecific ));
#line 356
  cl_spec = (TFDSetClientSpecific *)__cil_tmp4;
#line 358
  cl_spec->pattern = g_strdup(cmd->data.str);
#line 359
  cl_spec_section = cl_spec;
#line 361
  MSG(4, "Reading configuration for pattern %s\332U", cl_spec->pattern);
#line 364
  cl_spec->val.msg_settings.rate = - 101;
#line 365
  cl_spec->val.msg_settings.pitch = - 101;
#line 366
  cl_spec->val.msg_settings.pitch_range = - 101;
#line 367
  cl_spec->val.msg_settings.volume = - 101;
#line 368
  cl_spec->val.msg_settings.punctuation_mode = (SPDPunctuation )(- 1);
#line 369
  cl_spec->val.msg_settings.spelling_mode = (SPDSpelling )(- 1);
#line 370
  cl_spec->val.msg_settings.voice_type = (SPDVoiceType )(- 1);
#line 371
  cl_spec->val.msg_settings.cap_let_recogn = (SPDCapitalLetters )(- 1);
#line 372
  cl_spec->val.pause_context = - 1;
#line 373
  cl_spec->val.ssml_mode = (SPDDataMode )(- 1);
#line 374
  cl_spec->val.symbols_preprocessing = - 1;
#line 375
  cl_spec->val.msg_settings.voice.language = (char *)((void *)0);
#line 376
  cl_spec->val.output_module = (char *)((void *)0);
  }
#line 378
  return ((char const   *)((void *)0));
}
}
#line 384 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_EndClient(command_t *cmd , context_t *ctx ) 
{ 
  GList *__cil_tmp3 ;

  {
#line 386
  if (cl_spec_section == (void *)0) {
    {
#line 387
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 387
      fatal_error();
#line 387
      MSG(- 1, "Fatal error [%s:%d]:Configuration: Already outside the client specific section!",
          "./src/server/configuration.c", 387);
#line 387
      exit(1);
      }
#line 387
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 390
  client_specific_settings = g_list_append(client_specific_settings, cl_spec_section);
#line 393
  cl_spec_section = (TFDSetClientSpecific *)((void *)0);
  }
#line 395
  return ((char const   *)((void *)0));
}
}
#line 400 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_unknown(command_t *cmd , context_t *ctx ) 
{ 


  {
  {
#line 402
  MSG(2, "Unknown option in configuration!\220");
  }
#line 403
  return ((char const   *)((void *)0));
}
}
#line 407 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
char const   *cb_DisableAutoSpawn(command_t *cmd , context_t *ctx ) 
{ 


  {
#line 412
  return ((char const   *)((void *)0));
}
}
#line 423 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
configoption_t *load_config_options(int *num_options ) 
{ 
  configoption_t *options ;
  configoption_t *__cil_tmp3 ;
  configoption_t *__cil_tmp4 ;
  configoption_t *__cil_tmp5 ;
  configoption_t *__cil_tmp6 ;
  configoption_t *__cil_tmp7 ;
  configoption_t *__cil_tmp8 ;
  configoption_t *__cil_tmp9 ;
  configoption_t *__cil_tmp10 ;
  configoption_t *__cil_tmp11 ;
  configoption_t *__cil_tmp12 ;
  configoption_t *__cil_tmp13 ;
  configoption_t *__cil_tmp14 ;
  configoption_t *__cil_tmp15 ;
  configoption_t *__cil_tmp16 ;
  configoption_t *__cil_tmp17 ;
  configoption_t *__cil_tmp18 ;
  configoption_t *__cil_tmp19 ;
  configoption_t *__cil_tmp20 ;
  configoption_t *__cil_tmp21 ;
  configoption_t *__cil_tmp22 ;
  configoption_t *__cil_tmp23 ;
  configoption_t *__cil_tmp24 ;
  configoption_t *__cil_tmp25 ;
  configoption_t *__cil_tmp26 ;
  configoption_t *__cil_tmp27 ;
  configoption_t *__cil_tmp28 ;
  configoption_t *__cil_tmp29 ;
  configoption_t *__cil_tmp30 ;
  configoption_t *__cil_tmp31 ;
  configoption_t *__cil_tmp32 ;
  configoption_t *__cil_tmp33 ;
  configoption_t *__cil_tmp34 ;
  configoption_t *__cil_tmp35 ;
  configoption_t *__cil_tmp36 ;
  configoption_t *__cil_tmp37 ;
  configoption_t *__cil_tmp38 ;
  configoption_t *__cil_tmp39 ;
  configoption_t *__cil_tmp40 ;

  {
  {
#line 425
  options = (configoption_t *)((void *)0);
#line 427
  cl_spec_section = (TFDSetClientSpecific *)((void *)0);
#line 429
  options = add_config_option(options, num_options, "CommunicationMethod", 2, & cb_CommunicationMethod,
                              (info_t *)0, (unsigned long )0);
#line 430
  options = add_config_option(options, num_options, "SocketPath", 2, & cb_SocketPath,
                              (info_t *)0, (unsigned long )0);
#line 431
  options = add_config_option(options, num_options, "Port", 1, & cb_Port, (info_t *)0,
                              (unsigned long )0);
#line 432
  options = add_config_option(options, num_options, "DisableAutoSpawn\251", 6, & cb_DisableAutoSpawn,
                              (info_t *)0, (unsigned long )0);
#line 433
  options = add_config_option(options, num_options, "LocalhostAccessOnly", 1, & cb_LocalhostAccessOnly,
                              (info_t *)0, (unsigned long )0);
#line 434
  options = add_config_option(options, num_options, "LogFile", 2, & cb_LogFile, (info_t *)0,
                              (unsigned long )0);
#line 435
  options = add_config_option(options, num_options, "LogDir", 2, & cb_LogDir, (info_t *)0,
                              (unsigned long )0);
#line 436
  options = add_config_option(options, num_options, "CustomLogFileU", 3, & cb_CustomLogFile,
                              (info_t *)0, (unsigned long )0);
#line 437
  options = add_config_option(options, num_options, "LogLevel\251", 1, & cb_LogLevel,
                              (info_t *)0, (unsigned long )0);
#line 438
  options = add_config_option(options, num_options, "DefaultModule", 2, & cb_DefaultModule,
                              (info_t *)0, (unsigned long )0);
#line 439
  options = add_config_option(options, num_options, "LanguageDefaultModule", 3, & cb_LanguageDefaultModule,
                              (info_t *)0, (unsigned long )0);
#line 440
  options = add_config_option(options, num_options, "DefaultRate", 1, & cb_DefaultRate,
                              (info_t *)0, (unsigned long )0);
#line 441
  options = add_config_option(options, num_options, "DefaultPitch", 1, & cb_DefaultPitch,
                              (info_t *)0, (unsigned long )0);
#line 442
  options = add_config_option(options, num_options, "DefaultPitchRange", 1, & cb_DefaultPitchRange,
                              (info_t *)0, (unsigned long )0);
#line 443
  options = add_config_option(options, num_options, "DefaultVolume", 1, & cb_DefaultVolume,
                              (info_t *)0, (unsigned long )0);
#line 444
  options = add_config_option(options, num_options, "DefaultLanguage", 2, & cb_DefaultLanguage,
                              (info_t *)0, (unsigned long )0);
#line 445
  options = add_config_option(options, num_options, "DefaultPriority", 2, & cb_DefaultPriority,
                              (info_t *)0, (unsigned long )0);
#line 446
  options = add_config_option(options, num_options, "MaxHistoryMessages", 1, & cb_MaxHistoryMessages,
                              (info_t *)0, (unsigned long )0);
#line 447
  options = add_config_option(options, num_options, "MaxQueueSize", 1, & cb_MaxQueueSize,
                              (info_t *)0, (unsigned long )0);
#line 448
  options = add_config_option(options, num_options, "DefaultPunctuationMode", 2, & cb_DefaultPunctuationMode,
                              (info_t *)0, (unsigned long )0);
#line 449
  options = add_config_option(options, num_options, "SymbolsPreproc", 2, & cb_SymbolsPreproc,
                              (info_t *)0, (unsigned long )0);
#line 450
  options = add_config_option(options, num_options, "SymbolsPreprocFile", 2, & cb_SymbolsPreprocFile,
                              (info_t *)0, (unsigned long )0);
#line 451
  options = add_config_option(options, num_options, "DefaultClientName", 2, & cb_DefaultClientName,
                              (info_t *)0, (unsigned long )0);
#line 452
  options = add_config_option(options, num_options, "DefaultVoiceType\251", 2, & cb_DefaultVoiceType,
                              (info_t *)0, (unsigned long )0);
#line 453
  options = add_config_option(options, num_options, "DefaultSpelling", 0, & cb_DefaultSpelling,
                              (info_t *)0, (unsigned long )0);
#line 454
  options = add_config_option(options, num_options, "DefaultCapLetRecognition\251",
                              2, & cb_DefaultCapLetRecognition, (info_t *)0, (unsigned long )0);
#line 455
  options = add_config_option(options, num_options, "DefaultPauseContext", 1, & cb_DefaultPauseContext,
                              (info_t *)0, (unsigned long )0);
#line 456
  options = add_config_option(options, num_options, "Timeout", 1, & cb_Timeout, (info_t *)0,
                              (unsigned long )0);
#line 457
  options = add_config_option(options, num_options, "AddModule", 3, & cb_AddModule,
                              (info_t *)0, (unsigned long )0);
#line 459
  options = add_config_option(options, num_options, "AudioOutputMethod", 2, & cb_AudioOutputMethod,
                              (info_t *)0, (unsigned long )0);
#line 460
  options = add_config_option(options, num_options, "AudioOSSDevice", 2, & cb_AudioOSSDevice,
                              (info_t *)0, (unsigned long )0);
#line 461
  options = add_config_option(options, num_options, "AudioALSADevice", 2, & cb_AudioALSADevice,
                              (info_t *)0, (unsigned long )0);
#line 462
  options = add_config_option(options, num_options, "AudioNASServer", 2, & cb_AudioNASServer,
                              (info_t *)0, (unsigned long )0);
#line 463
  options = add_config_option(options, num_options, "AudioPulseServer\251", 2, & cb_AudioPulseServer,
                              (info_t *)0, (unsigned long )0);
#line 464
  options = add_config_option(options, num_options, "AudioPulseDevice\251", 2, & cb_AudioPulseDevice,
                              (info_t *)0, (unsigned long )0);
#line 465
  options = add_config_option(options, num_options, "AudioPulseMinLength", 1, & cb_AudioPulseMinLength,
                              (info_t *)0, (unsigned long )0);
#line 467
  options = add_config_option(options, num_options, "BeginClient", 2, & cb_BeginClient,
                              (info_t *)0, (unsigned long )0);
#line 468
  options = add_config_option(options, num_options, "EndClient", 6, & cb_EndClient,
                              (info_t *)0, (unsigned long )0);
  }
#line 469
  return (options);
}
}
#line 475 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/configuration.c"
void load_default_global_set_options(void) 
{ 
  gchar *__cil_tmp1 ;
  gchar *__cil_tmp2 ;
  gchar *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  gchar *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  gchar *__cil_tmp9 ;
  gchar *__cil_tmp10 ;

  {
  {
#line 477
  GlobalFDSet.priority = (SPDPriority )2;
#line 478
  GlobalFDSet.msg_settings.punctuation_mode = (SPDPunctuation )1;
#line 479
  GlobalFDSet.symbols_preprocessing = 100;
#line 480
  GlobalFDSet.msg_settings.spelling_mode = (SPDSpelling )0;
#line 481
  GlobalFDSet.msg_settings.rate = 0;
#line 482
  GlobalFDSet.msg_settings.pitch = 0;
#line 483
  GlobalFDSet.msg_settings.pitch_range = 0;
#line 484
  GlobalFDSet.msg_settings.volume = 0;
#line 485
  GlobalFDSet.client_name = g_strdup((gchar *)"unknown:unknown:unknown");
#line 486
  GlobalFDSet.msg_settings.voice.language = g_strdup((gchar *)"en-US");
#line 487
  GlobalFDSet.output_module = (char *)((void *)0);
#line 488
  GlobalFDSet.msg_settings.voice_type = (SPDVoiceType )1;
#line 489
  GlobalFDSet.msg_settings.cap_let_recogn = (SPDCapitalLetters )0;
#line 490
  GlobalFDSet.min_delay_progress = (unsigned int )2000;
#line 491
  GlobalFDSet.pause_context = 0;
#line 492
  GlobalFDSet.ssml_mode = (SPDDataMode )0;
#line 493
  GlobalFDSet.notification = (SPDNotification )0;
#line 495
  GlobalFDSet.audio_output_method = g_strdup((gchar *)"pulse");
#line 496
  GlobalFDSet.audio_oss_device = g_strdup((gchar *)"/dev/dsp\220");
#line 497
  GlobalFDSet.audio_alsa_device = g_strdup((gchar *)"default");
#line 498
  GlobalFDSet.audio_nas_server = g_strdup((gchar *)"tcp/localhost:5450");
#line 499
  GlobalFDSet.audio_pulse_server = g_strdup((gchar *)"default");
#line 500
  GlobalFDSet.audio_pulse_device = g_strdup((gchar *)"default");
#line 501
  GlobalFDSet.audio_pulse_min_length = 10;
#line 503
  SpeechdOptions.max_history_messages = 10000;
#line 504
  SpeechdOptions.max_queue_size = 10000;
  }
#line 508
  if (! SpeechdOptions.log_level_set) {
#line 509
    SpeechdOptions.log_level = 3;
  }
#line 510
  if (! SpeechdOptions.communication_method_set) {
    {
#line 511
    SpeechdOptions.communication_method = g_strdup((gchar *)"unix_socket");
    }
  }
#line 512
  if (! SpeechdOptions.socket_path_set) {
    {
#line 513
    SpeechdOptions.socket_path = g_strdup((gchar *)"default");
    }
  }
#line 514
  if (! SpeechdOptions.port_set) {
#line 515
    SpeechdOptions.port = 6560;
  }
#line 516
  if (! SpeechdOptions.localhost_access_only_set) {
#line 517
    SpeechdOptions.localhost_access_only = 1;
  }
#line 518
  if (! SpeechdOptions.server_timeout_set) {
#line 519
    SpeechdOptions.server_timeout = 5;
  }
#line 522
  logfile = stderr;
#line 523
  custom_logfile = (FILE *)((void *)0);
  return;
}
}
#line 35 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
static GList *message_history ;
#line 39 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
gint message_compare_id(gconstpointer element , gconstpointer value ) 
{ 
  gint ret ;

  {
#line 42
  ret = (gint )(((TSpeechDMessage *)element)->id - (unsigned int )*((int *)value));
#line 43
  return (ret);
}
}
#line 46 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
gint (*p_msg_comp_id)()  =    & message_compare_id;
#line 48 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_get_client_list(void) 
{ 
  TFDSetElement *client ;
  GString *clist ;
  int i ;
  GString *__cil_tmp4 ;
  TFDSetElement *__cil_tmp5 ;
  int tmp ;
  int __cil_tmp7 ;

  {
  {
#line 54
  clist = g_string_new((gchar *)"");
#line 56
  i = 1;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! (i <= SpeechdStatus.max_uid)) {
#line 56
      goto while_break;
    }
    {
#line 57
    MSG(4, "Getting settings for client %d of %d", i, SpeechdStatus.max_uid - 1);
#line 59
    client = get_client_settings_by_uid(i);
#line 61
    g_string_append_printf(clist, (gchar *)"240-P\346\303\177\332U");
#line 62
    g_string_append_printf(clist, (gchar *)"%d ", client->uid);
#line 63
    g_string_append(clist, client->client_name);
#line 64
    g_string_append_printf(clist, (gchar *)" %d", client->active);
#line 65
    g_string_append(clist, (gchar *)"\r\n");
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  g_string_append_printf(clist, (gchar *)"240 OK CLIENTS LIST SENT\r\n");
  }
#line 69
  return (clist->str);
}
}
#line 72 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_get_client_id(int fd ) 
{ 
  GString *cid ;
  int uid ;
  GString *__cil_tmp4 ;
  int __cil_tmp5 ;
  gchar *__cil_tmp6 ;

  {
  {
#line 77
  cid = g_string_new((gchar *)"\220");
#line 79
  uid = get_client_uid_by_fd(fd);
  }
#line 80
  if (uid == 0) {
    {
#line 81
    __cil_tmp6 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
    }
#line 81
    return (__cil_tmp6);
  }
  {
#line 83
  g_string_append_printf(cid, (gchar *)"245-%d\r\n", uid);
#line 84
  g_string_append_printf(cid, (gchar *)"245 OK CLIENT ID SENT\r\n");
  }
#line 86
  return (cid->str);
}
}
#line 89 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_get_message(int uid ) 
{ 
  gchar *__cil_tmp2 ;

  {
  {
#line 128
  __cil_tmp2 = g_strdup((gchar *)"380 ERR NOT YET IMPLEMENTED\r\n");
  }
#line 128
  return (__cil_tmp2);
}
}
#line 131 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_get_message_list(guint client_id , int from , int num ) 
{ 
  TSpeechDMessage *message ;
  GString *mlist ;
  GList *gl ;
  TFDSetElement *client_settings ;
  GList *client_msgs ;
  int i ;
  GString *__cil_tmp10 ;
  TFDSetElement *__cil_tmp11 ;
  gchar *__cil_tmp12 ;
  GList *__cil_tmp13 ;
  GList *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 140
  MSG(4, "message_list: from %d num %d, client %d\n\230\001", from, num, client_id);
#line 143
  mlist = g_string_new((gchar *)"\220");
#line 145
  client_settings = get_client_settings_by_uid((int )client_id);
  }
#line 146
  if (client_settings == (void *)0) {
    {
#line 147
    __cil_tmp12 = g_strdup((gchar *)"402 ERR NO SUCH CLIENT\r\n");
    }
#line 147
    return (__cil_tmp12);
  }
  {
#line 149
  client_msgs = get_messages_by_client((int )client_id);
#line 151
  i = from;
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i <= (from + num) - 1)) {
#line 151
      goto while_break;
    }
    {
#line 152
    gl = g_list_nth(client_msgs, (guint )i);
    }
#line 153
    if (gl == (void *)0) {
      {
#line 154
      g_string_append_printf(mlist, (gchar *)"241 OK MSGS LIST SENT\r\n");
      }
#line 155
      return (mlist->str);
    }
#line 157
    message = gl->data;
#line 159
    if (message == (void *)0) {
#line 160
      if (0) {
        {
#line 161
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 161
          fatal_error();
#line 161
          MSG(- 1, "Fatal error [%s:%d]:Internal error.\n\323\001 ", "./src/server/history.c",
              161);
#line 161
          exit(1);
          }
#line 161
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 162
      __cil_tmp15 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
      }
#line 162
      return (__cil_tmp15);
    }
    {
#line 165
    g_string_append_printf(mlist, (gchar *)"241-\220");
#line 166
    g_string_append_printf(mlist, (gchar *)"%d %s\r\n", message->id, client_settings->client_name);
    }
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  g_string_append_printf(mlist, (gchar *)"241 OK MSGS LIST SENT\r\n");
  }
#line 171
  return (mlist->str);
}
}
#line 174 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_get_last(int fd ) 
{ 
  TSpeechDMessage *message ;
  GString *lastm ;
  GList *gl ;
  GString *__cil_tmp5 ;
  GList *__cil_tmp6 ;
  gchar *__cil_tmp7 ;

  {
  {
#line 180
  lastm = g_string_new((gchar *)"\220");
#line 182
  gl = g_list_last(message_history);
  }
#line 183
  if (gl == (void *)0) {
    {
#line 184
    __cil_tmp7 = g_strdup((gchar *)"403 ERR NO MESSAGE\r\n\220");
    }
#line 184
    return (__cil_tmp7);
  }
  {
#line 185
  message = gl->data;
#line 187
  g_string_append_printf(lastm, (gchar *)"242-%d\r\n", message->id);
#line 188
  g_string_append_printf(lastm, (gchar *)"242 OK LAST MSG SAID\r\n");
  }
#line 189
  return (lastm->str);
}
}
#line 192 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_set_last(int fd , guint client_id ) 
{ 
  GList *client_msgs ;
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp5 ;
  GList *__cil_tmp6 ;
  guint __cil_tmp7 ;
  gchar *__cil_tmp8 ;

  {
  {
#line 197
  settings = get_client_settings_by_fd(fd);
  }
#line 198
  if (settings == (void *)0) {
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 199
      fatal_error();
#line 199
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 199);
#line 199
      exit(1);
      }
#line 199
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 201
  client_msgs = get_messages_by_client((int )client_id);
#line 202
  __cil_tmp7 = g_list_length(client_msgs);
#line 202
  settings->hist_cur_pos = (int )(__cil_tmp7 - 1U);
#line 203
  settings->hist_cur_uid = client_id;
#line 205
  __cil_tmp8 = g_strdup((gchar *)"221 OK CURSOR SET LAST\r\n");
  }
#line 205
  return (__cil_tmp8);
}
}
#line 208 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_set_first(int fd , guint client_id ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp4 ;
  gchar *__cil_tmp5 ;

  {
  {
#line 212
  settings = get_client_settings_by_fd(fd);
  }
#line 213
  if (settings == (void *)0) {
    {
#line 214
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 214
      fatal_error();
#line 214
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 214);
#line 214
      exit(1);
      }
#line 214
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 216
  settings->hist_cur_pos = 0;
#line 217
  settings->hist_cur_uid = client_id;
#line 218
  __cil_tmp5 = g_strdup((gchar *)"220 OK CURSOR SET FIRST\r\n");
  }
#line 218
  return (__cil_tmp5);
}
}
#line 221 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_set_pos(int fd , guint client_id , int pos ) 
{ 
  TFDSetElement *settings ;
  GList *client_msgs ;
  gchar *__cil_tmp6 ;
  GList *__cil_tmp7 ;
  guint __cil_tmp8 ;
  gchar *__cil_tmp9 ;
  TFDSetElement *__cil_tmp10 ;
  gchar *__cil_tmp11 ;

  {
#line 226
  if (pos < 0) {
    {
#line 227
    __cil_tmp6 = g_strdup((gchar *)"404 ERR POSITION TOO LOW\r\n");
    }
#line 227
    return (__cil_tmp6);
  }
  {
#line 229
  client_msgs = get_messages_by_client((int )client_id);
#line 230
  __cil_tmp8 = g_list_length(client_msgs);
  }
#line 230
  if ((unsigned int )pos > __cil_tmp8 - 1U) {
    {
#line 231
    __cil_tmp9 = g_strdup((gchar *)"405 ERR POSITION TOO HIGH\r\n");
    }
#line 231
    return (__cil_tmp9);
  }
  {
#line 233
  settings = get_client_settings_by_fd(fd);
  }
#line 234
  if (settings == (void *)0) {
    {
#line 235
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 235
      fatal_error();
#line 235
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 235);
#line 235
      exit(1);
      }
#line 235
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 237
  settings->hist_cur_pos = pos;
#line 238
  settings->hist_cur_uid = client_id;
#line 239
  MSG(4, "cursor pos:%d\n", settings->hist_cur_pos);
#line 240
  __cil_tmp11 = g_strdup((gchar *)"222 OK CURSOR SET TO POSITION\r\n");
  }
#line 240
  return (__cil_tmp11);
}
}
#line 243 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_forward(int fd ) 
{ 
  TFDSetElement *settings ;
  GList *client_msgs ;
  TFDSetElement *__cil_tmp4 ;
  GList *__cil_tmp5 ;
  guint __cil_tmp6 ;
  gchar *__cil_tmp7 ;
  int __cil_tmp8 ;
  gchar *__cil_tmp9 ;

  {
  {
#line 248
  settings = get_client_settings_by_fd(fd);
  }
#line 249
  if (settings == (void *)0) {
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 250
      fatal_error();
#line 250
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 250);
#line 250
      exit(1);
      }
#line 250
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 252
  client_msgs = get_messages_by_client((int )settings->hist_cur_uid);
#line 253
  __cil_tmp6 = g_list_length(client_msgs);
  }
#line 253
  if ((unsigned int )(settings->hist_cur_pos + 1) > __cil_tmp6 - 1U) {
    {
#line 254
    __cil_tmp7 = g_strdup((gchar *)"405 ERR POSITION TOO HIGH\r\n");
    }
#line 254
    return (__cil_tmp7);
  }
  {
#line 255
  (settings->hist_cur_pos) ++;
#line 257
  __cil_tmp9 = g_strdup((gchar *)"223 OK CURSOR MOVED FORWARD\r\n");
  }
#line 257
  return (__cil_tmp9);
}
}
#line 260 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_backward(int fd ) 
{ 
  TFDSetElement *settings ;
  TFDSetElement *__cil_tmp3 ;
  gchar *__cil_tmp4 ;
  int __cil_tmp5 ;
  gchar *__cil_tmp6 ;

  {
  {
#line 264
  settings = get_client_settings_by_fd(fd);
  }
#line 265
  if (settings == (void *)0) {
    {
#line 266
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 266
      fatal_error();
#line 266
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 266);
#line 266
      exit(1);
      }
#line 266
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 268
  if (settings->hist_cur_pos - 1 < 0) {
    {
#line 269
    __cil_tmp4 = g_strdup((gchar *)"404 ERR POSITION TOO LOW\r\n");
    }
#line 269
    return (__cil_tmp4);
  }
  {
#line 270
  __cil_tmp5 = settings->hist_cur_pos;
#line 270
  (settings->hist_cur_pos) --;
#line 272
  __cil_tmp6 = g_strdup((gchar *)"224 OK CURSOR MOVED BACKWARD\r\n");
  }
#line 272
  return (__cil_tmp6);
}
}
#line 275 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_cursor_get(int fd ) 
{ 
  TFDSetElement *settings ;
  TSpeechDMessage *new ;
  GString *reply ;
  GList *gl ;
  GList *client_msgs ;
  GString *__cil_tmp7 ;
  TFDSetElement *__cil_tmp8 ;
  GList *__cil_tmp9 ;
  GList *__cil_tmp10 ;
  gchar *__cil_tmp11 ;

  {
  {
#line 282
  reply = g_string_new((gchar *)"\220");
#line 284
  settings = get_client_settings_by_fd(fd);
  }
#line 285
  if (settings == (void *)0) {
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 286
      fatal_error();
#line 286
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client\323\001 ",
          "./src/server/history.c", 286);
#line 286
      exit(1);
      }
#line 286
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 288
  client_msgs = get_messages_by_client((int )settings->hist_cur_uid);
#line 289
  gl = g_list_nth(client_msgs, (guint )((int )settings->hist_cur_pos));
  }
#line 290
  if (gl == (void *)0) {
    {
#line 291
    __cil_tmp11 = g_strdup((gchar *)"403 ERR NO MESSAGE\r\n\220");
    }
#line 291
    return (__cil_tmp11);
  }
  {
#line 292
  new = gl->data;
#line 294
  g_string_printf(reply, (gchar *)"243-%d\r\n243 OK CURSOR POSITION RETURNED\r\n",
                  new->id);
  }
#line 295
  return (reply->str);
}
}
#line 298 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
char *history_say_id(int fd , int id ) 
{ 
  TSpeechDMessage *msg ;
  GList *gl ;
  GList *__cil_tmp5 ;
  gchar *__cil_tmp6 ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;

  {
  {
#line 303
  gl = g_list_find_custom(message_history, & id, p_msg_comp_id);
  }
#line 304
  if (gl == (void *)0) {
    {
#line 305
    __cil_tmp6 = g_strdup((gchar *)"406 ERR ID DOESNT EXIST\r\n");
    }
#line 305
    return (__cil_tmp6);
  }
#line 306
  msg = gl->data;
#line 307
  if (msg == (void *)0) {
    {
#line 308
    __cil_tmp7 = g_strdup((gchar *)"300 ERR INTERNAL\r\n");
    }
#line 308
    return (__cil_tmp7);
  }
  {
#line 310
  MSG(4, "putting history message into queue\n\177\332U");
#line 314
  __cil_tmp8 = g_strdup((gchar *)"225 OK MESSAGE QUEUED\r\n\177\332U");
  }
#line 314
  return (__cil_tmp8);
}
}
#line 317 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
int history_add_message(TSpeechDMessage *msg ) 
{ 
  TSpeechDMessage *hist_msg ;
  TSpeechDMessage *__cil_tmp3 ;
  guint __cil_tmp4 ;
  GList *gl ;
  GList *__cil_tmp6 ;
  GList *__cil_tmp7 ;
  GList *__cil_tmp8 ;

  {
  {
#line 322
  __cil_tmp3 = spd_message_copy(msg);
#line 322
  hist_msg = (TSpeechDMessage *)__cil_tmp3;
  }
#line 324
  if (hist_msg == (void *)0) {
#line 325
    if (0) {
      {
#line 326
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 326
        fatal_error();
#line 326
        MSG(- 1, "Fatal error [%s:%d]:Can\'t include message into history\n", "./src/server/history.c",
            326);
#line 326
        exit(1);
        }
#line 326
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 327
    return (- 1);
  }
  {
#line 331
  __cil_tmp4 = g_list_length(message_history);
  }
#line 331
  if (__cil_tmp4 >= (unsigned int )SpeechdOptions.max_history_messages) {
    {
#line 334
    MSG(5, "Discarding older history message, limit reached");
#line 335
    gl = g_list_first(message_history);
    }
#line 336
    if (gl != (void *)0) {
      {
#line 337
      message_history = g_list_remove_link(message_history, gl);
      }
#line 339
      if (gl->data != (void *)0) {
        {
#line 340
        mem_free_message(gl->data);
        }
      }
    }
  }
  {
#line 344
  message_history = g_list_append(message_history, hist_msg);
  }
#line 345
  return (0);
}
}
#line 348 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/history.c"
GList *get_messages_by_client(int uid ) 
{ 
  GList *list ;
  GList *gl ;
  TSpeechDMessage *msg ;
  guint i ;
  guint history_length ;
  guint __cil_tmp7 ;
  GList *__cil_tmp8 ;
  int tmp ;
  GList *__cil_tmp10 ;
  guint __cil_tmp11 ;

  {
  {
#line 350
  list = (GList *)((void *)0);
#line 354
  __cil_tmp7 = g_list_length(message_history);
#line 354
  history_length = __cil_tmp7;
#line 356
  i = (guint )0;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (i < history_length)) {
#line 356
      goto while_break;
    }
    {
#line 357
    gl = g_list_nth(message_history, i);
#line 359
    msg = gl->data;
    }
#line 360
    if (msg->settings.uid == (unsigned int )uid) {
      {
#line 361
      list = g_list_append(list, msg);
      }
    }
#line 356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (list);
}
}
#line 33 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.c"
int last_message_id  =    0;
#line 66 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.c"
int queue_message(TSpeechDMessage *new , int fd , int history_flag , SPDMessageType type ,
                  int reparted ) 
{ 
  TFDSetElement *settings ;
  TSpeechDMessage *message_copy ;
  int id ;
  GList *element ;
  unsigned long __cil_tmp10 ;
  TFDSetElement *__cil_tmp11 ;
  TFDSetElement *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  gchar *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  gchar *__cil_tmp16 ;
  gchar *__cil_tmp17 ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;
  gchar *__cil_tmp20 ;
  gchar *__cil_tmp21 ;
  gchar *__cil_tmp22 ;
  gchar *__cil_tmp23 ;
  int __cil_tmp24 ;
  time_t __cil_tmp25 ;
  GList *__cil_tmp26 ;
  GList *__cil_tmp27 ;
  GList *__cil_tmp28 ;
  GList *__cil_tmp29 ;
  GList *__cil_tmp30 ;
  GList *__cil_tmp31 ;
  TSpeechDMessage *__cil_tmp32 ;
  GList *__cil_tmp33 ;

  {
#line 75
  if (new == (void *)0) {
#line 76
    return (- 1);
  }
#line 77
  if (new->buf == (void *)0) {
#line 78
    return (- 1);
  }
  {
#line 79
  __cil_tmp10 = strlen((char const   *)new->buf);
  }
#line 79
  if (__cil_tmp10 < 1UL) {
#line 80
    return (- 1);
  }
#line 83
  if (fd > 0) {
    {
#line 84
    settings = get_client_settings_by_fd(fd);
    }
#line 85
    if (settings == (void *)0) {
      {
#line 86
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 86
        fatal_error();
#line 86
        MSG(- 1, "Fatal error [%s:%d]:Couldn\'t find settings for active client, internal error.",
            "./src/server/server.c", 86);
#line 86
        exit(1);
        }
#line 86
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 88
  if (fd < 0) {
    {
#line 89
    settings = get_client_settings_by_uid(- fd);
    }
  } else {
#line 91
    if (0) {
      {
#line 92
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 92
        fatal_error();
#line 92
        MSG(- 1, "Fatal error [%s:%d]:fd == 0, this shouldn\'t happen...", "./src/server/server.c",
            92);
#line 92
        exit(1);
        }
#line 92
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 93
    return (- 1);
  }
  {
#line 96
  MSG(5, "In queue_message desired output module is %s", settings->output_module);
  }
#line 99
  if (fd > 0) {
    {
#line 101
    new->settings = *settings;
#line 102
    new->settings.type = type;
#line 103
    new->settings.index_mark = (char *)((void *)0);
#line 104
    __cil_tmp13 = g_strdup(settings->client_name);
#line 104
    new->settings.client_name = (char *)__cil_tmp13;
#line 105
    __cil_tmp14 = g_strdup(settings->output_module);
#line 105
    new->settings.output_module = (char *)__cil_tmp14;
#line 106
    __cil_tmp15 = g_strdup(settings->msg_settings.voice.language);
#line 106
    new->settings.msg_settings.voice.language = (char *)__cil_tmp15;
#line 107
    __cil_tmp16 = g_strdup(settings->msg_settings.voice.name);
#line 107
    new->settings.msg_settings.voice.name = (char *)__cil_tmp16;
#line 109
    __cil_tmp17 = g_strdup(settings->index_mark);
#line 109
    new->settings.index_mark = (char *)__cil_tmp17;
#line 110
    __cil_tmp18 = g_strdup(settings->audio_output_method);
#line 110
    new->settings.audio_output_method = (char *)__cil_tmp18;
#line 111
    __cil_tmp19 = g_strdup(settings->audio_oss_device);
#line 111
    new->settings.audio_oss_device = (char *)__cil_tmp19;
#line 112
    __cil_tmp20 = g_strdup(settings->audio_alsa_device);
#line 112
    new->settings.audio_alsa_device = (char *)__cil_tmp20;
#line 113
    __cil_tmp21 = g_strdup(settings->audio_nas_server);
#line 113
    new->settings.audio_nas_server = (char *)__cil_tmp21;
#line 114
    __cil_tmp22 = g_strdup(settings->audio_pulse_server);
#line 114
    new->settings.audio_pulse_server = (char *)__cil_tmp22;
#line 115
    __cil_tmp23 = g_strdup(settings->audio_pulse_device);
#line 115
    new->settings.audio_pulse_device = (char *)__cil_tmp23;
#line 119
    last_message_id ++;
#line 120
    new->id = (guint )last_message_id;
#line 121
    new->time = time((time_t *)((void *)0));
#line 123
    new->settings.paused_while_speaking = 0;
    }
  }
  {
#line 125
  id = (int )new->id;
#line 127
  new->settings.reparted = reparted;
#line 129
  MSG(5, "Queueing message |%s| with priority %d", new->buf, (unsigned int )settings->priority);
  }
#line 137
  if (0) {
    {
#line 138
    pthread_mutex_lock(& element_free_mutex);
#line 139
    history_add_message(new);
#line 140
    pthread_mutex_unlock(& element_free_mutex);
    }
  }
  {
#line 143
  pthread_mutex_lock(& element_free_mutex);
#line 145
  check_locked(& element_free_mutex);
  }
  {
#line 147
  if ((unsigned int )settings->priority == (unsigned int )1) {
#line 147
    goto case_1;
  }
#line 150
  if ((unsigned int )settings->priority == (unsigned int )2) {
#line 150
    goto case_2;
  }
#line 153
  if ((unsigned int )settings->priority == (unsigned int )3) {
#line 153
    goto case_3;
  }
#line 156
  if ((unsigned int )settings->priority == (unsigned int )4) {
#line 156
    goto case_4;
  }
#line 159
  if ((unsigned int )settings->priority == (unsigned int )5) {
#line 159
    goto case_5;
  }
#line 178
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 148
  MessageQueue->p1 = g_list_append(MessageQueue->p1, new);
  }
#line 149
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 151
  MessageQueue->p2 = g_list_append(MessageQueue->p2, new);
  }
#line 152
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 154
  MessageQueue->p3 = g_list_append(MessageQueue->p3, new);
  }
#line 155
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 157
  MessageQueue->p4 = g_list_append(MessageQueue->p4, new);
  }
#line 158
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 160
  MessageQueue->p5 = g_list_append(MessageQueue->p5, new);
  }
  {
#line 162
  element = g_list_last(last_p5_block);
  }
#line 163
  if (! element) {
    {
    {
    {
#line 166
    g_list_foreach(last_p5_block, (GFunc )(& mem_free_message), (void *)0);
    }
    }
    {
    {
#line 168
    g_list_free(last_p5_block);
    }
    }
#line 169
    last_p5_block = (GList *)((void *)0);
    }
  } else
#line 163
  if (! element->data) {
    {
    {
    {
#line 166
    g_list_foreach(last_p5_block, (GFunc )(& mem_free_message), (void *)0);
    }
    }
    {
    {
#line 168
    g_list_free(last_p5_block);
    }
    }
#line 169
    last_p5_block = (GList *)((void *)0);
    }
  } else
#line 163
  if (((TSpeechDMessage *)element->data)->settings.reparted != new->settings.reparted) {
    {
    {
    {
#line 166
    g_list_foreach(last_p5_block, (GFunc )(& mem_free_message), (void *)0);
    }
    }
    {
    {
#line 168
    g_list_free(last_p5_block);
    }
    }
#line 169
    last_p5_block = (GList *)((void *)0);
    }
  }
  {
#line 172
  message_copy = spd_message_copy(new);
  }
#line 173
  if (message_copy != (void *)0) {
    {
#line 174
    last_p5_block = g_list_append(last_p5_block, message_copy);
    }
  }
#line 177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 179
    fatal_error();
#line 179
    MSG(- 1, "Fatal error [%s:%d]:Nonexistent priority given", "./src/server/server.c",
        179);
#line 179
    exit(1);
    }
#line 179
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 189
  resolve_priorities(settings->priority);
#line 190
  pthread_mutex_unlock(& element_free_mutex);
#line 192
  speaking_semaphore_post();
#line 194
  MSG(5, "Message inserted into queue.");
  }
#line 196
  return (id);
}
}
#line 202 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.c"
void server_data_on(int fd ) 
{ 
  TSpeechDSock *speechd_socket ;
  TSpeechDSock *__cil_tmp3 ;
  int tmp ;
  GString *__cil_tmp5 ;

  {
  {
#line 204
  __cil_tmp3 = speechd_socket_get_by_fd(fd);
#line 204
  speechd_socket = __cil_tmp3;
#line 207
  speechd_socket->awaiting_data = 1;
#line 209
  speechd_socket->o_buf = g_string_new((gchar *)"");
#line 210
  MSG(4, "Switching to data mode...");
  }
#line 211
  return;
}
}
#line 215 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.c"
void server_data_off(int fd ) 
{ 
  TSpeechDSock *speechd_socket ;
  TSpeechDSock *__cil_tmp3 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 217
  __cil_tmp3 = speechd_socket_get_by_fd(fd);
#line 217
  speechd_socket = __cil_tmp3;
#line 220
  speechd_socket->o_bytes = (size_t )0;
#line 221
  g_string_free(speechd_socket->o_buf, 1);
#line 222
  speechd_socket->o_buf = (GString *)((void *)0);
  }
#line 223
  return;
}
}
#line 227 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/server.c"
int serve(int fd ) 
{ 
  char *reply ;
  int ret ;
  size_t bytes ;
  int buflen ;
  char *buf ;
  gpointer __cil_tmp7 ;
  int n ;
  ssize_t __cil_tmp9 ;
  gpointer __cil_tmp10 ;
  char *__cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 233
  bytes = (size_t )0;
#line 234
  buflen = 128;
#line 235
  __cil_tmp7 = g_malloc((gsize )(buflen + 1));
#line 235
  buf = (char *)__cil_tmp7;
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 241
    __cil_tmp9 = read(fd, buf + bytes, (size_t )1);
#line 241
    n = (int )__cil_tmp9;
    }
#line 242
    if (n <= 0) {
      {
#line 243
      g_free(buf);
      }
#line 244
      return (- 1);
    }
#line 247
    if ((int )*(buf + bytes) == 10) {
#line 247
      if (bytes >= 1UL) {
#line 247
        if ((int )*(buf + (bytes - 1UL)) == 13) {
#line 249
          bytes ++;
#line 249
          *(buf + bytes) = (char )'\000';
#line 250
          goto while_break;
        }
      }
    }
#line 252
    if ((int )*(buf + bytes) == 0) {
#line 253
      *(buf + bytes) = (char )'?';
    }
#line 254
    bytes ++;
#line 254
    if (bytes == (unsigned long )buflen) {
      {
#line 255
      buflen *= 2;
#line 256
      buf = (char *)g_realloc(buf, (gsize )(buflen + 1));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 262
  MSG2(5, "protocol\200\321\021\200\332U", "%d:DATA:|%s| (%lu)\020\200\332U", fd,
       buf, (unsigned long )bytes);
#line 263
  reply = parse((char const   *)buf, (int )bytes, fd);
#line 264
  g_free(buf);
  }
#line 267
  if (reply == (void *)0) {
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 268
      fatal_error();
#line 268
      MSG(- 1, "Fatal error [%s:%d]:Internal error, reply from parse() is NULL!\200\332U",
          "./src/server/server.c", 268);
#line 268
      exit(1);
      }
#line 268
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 271
  __cil_tmp12 = strlen((char const   *)reply);
  }
#line 271
  if (__cil_tmp12 == 0UL) {
    {
#line 272
    g_free(reply);
    }
#line 273
    return (0);
  }
#line 275
  if ((int )*(reply + 0) != 57) {
    {
#line 276
    pthread_mutex_lock(& socket_com_mutex);
#line 277
    MSG2(5, "protocol\323\001 ", "%d:REPLY:|%s|", fd, reply);
#line 278
    __cil_tmp13 = strlen((char const   *)reply);
#line 278
    __cil_tmp14 = write(fd, reply, __cil_tmp13);
#line 278
    ret = (int )__cil_tmp14;
#line 279
    g_free(reply);
#line 280
    pthread_mutex_unlock(& socket_com_mutex);
    }
#line 281
    if (ret == -1) {
      {
#line 282
      __cil_tmp15 = __errno_location();
#line 282
      __cil_tmp16 = strerror(*__cil_tmp15);
#line 282
      MSG(5, "write() error: %s", __cil_tmp16);
      }
#line 283
      return (- 1);
    }
  } else {
    {
#line 286
    g_free(reply);
    }
  }
#line 289
  return (0);
}
}
#line 71 "/usr/include/glib-2.0/gmodule.h"
extern GQuark g_module_error_quark(void) ;
#line 91
extern gboolean g_module_supported(void) ;
#line 95
extern GModule *g_module_open(gchar *file_name , GModuleFlags flags ) ;
#line 99
extern GModule *g_module_open_full(gchar *file_name , GModuleFlags flags , GError **error ) ;
#line 105
extern gboolean g_module_close(GModule *module ) ;
#line 109
extern void g_module_make_resident(GModule *module ) ;
#line 113
extern gchar *g_module_error(void) ;
#line 117
extern gboolean g_module_symbol(GModule *module , gchar *symbol_name , gpointer *symbol ) ;
#line 123
extern gchar *g_module_name(GModule *module ) ;
#line 137
extern gchar *g_module_build_path(gchar *directory , gchar *module_name ) ;
#line 28 "/usr/include/glib-2.0/glib/gprintf.h"
extern gint g_printf(gchar *format  , ...) ;
#line 31
extern gint g_fprintf(FILE *file , gchar *format  , ...) ;
#line 35
extern gint g_sprintf(gchar *string , gchar *format  , ...) ;
#line 40
extern gint g_vprintf(gchar *format , va_list args ) ;
#line 43
extern gint g_vfprintf(FILE *file , gchar *format , va_list args ) ;
#line 47
extern gint g_vsprintf(gchar *string , gchar *format , va_list args ) ;
#line 51
extern gint g_vasprintf(gchar **string , gchar *format , va_list args ) ;
#line 84 "/usr/include/glib-2.0/glib/gstdio.h"
extern int g_access(gchar *filename , int mode ) ;
#line 88
extern int g_chdir(gchar *path ) ;
#line 91
extern int g_unlink(gchar *filename ) ;
#line 94
extern int g_rmdir(gchar *filename ) ;
#line 176
extern gboolean g_close(gint fd , GError **error ) ;
#line 62 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int server_socket ;
#line 64 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
GMainLoop *main_loop  =    (GMainLoop *)((void *)0);
#line 65 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
gint server_timeout_source  =    - 1;
#line 67 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int client_count  =    0;
#line 73 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
pthread_mutex_t logging_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 74 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
pthread_mutex_t element_free_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 75 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
pthread_mutex_t output_layer_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 76 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
pthread_mutex_t socket_com_mutex  =    {{0, (unsigned int )0, 0, (unsigned int )0, 0, (short )0, (short )0, {(struct __pthread_internal_list *)0,
                                                                         (struct __pthread_internal_list *)0}}};
#line 102
static gboolean speechd_client_terminate(gpointer key , gpointer value , gpointer user ) ;
#line 103
static gboolean speechd_reload_dead_modules(gpointer user_data ) ;
#line 104
static gboolean speechd_load_configuration(gpointer user_data ) ;
#line 105
static gboolean speechd_quit(gpointer user_data ) ;
#line 107
gboolean server_process_incoming(gint fd , GIOCondition condition , gpointer data ) ;
#line 111
gboolean client_process_incoming(gint fd , GIOCondition condition , gpointer data ) ;
#line 115
void check_client_count(void) ;
#line 158 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void fatal_error(void) 
{ 
  int i ;
  int __cil_tmp2 ;

  {
#line 160
  i = 0;
#line 161
  i ++;
  return;
}
}
#line 166 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void MSG2(int level , char const   *kind , char const   *format  , ...) 
{ 
  int std_log ;
  int custom_log ;
  int __cil_tmp6 ;
  va_list args ;
  int i ;
  time_t t ;
  char *tstr ;
  struct timeval tv ;
  time_t __cil_tmp12 ;
  char *__cil_tmp13 ;
  gchar *__cil_tmp14 ;
  int tmp ;
  unsigned long __cil_tmp16 ;
  int tmp___0 ;
  unsigned long __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 168
  std_log = level <= SpeechdOptions.log_level;
#line 169
  __cil_tmp6 = strcmp(kind, (char const   *)custom_log_kind);
#line 169
  custom_log = ((kind != (void *)0 && custom_log_kind != (void *)0) && ! __cil_tmp6) && custom_logfile != (void *)0;
  }
#line 173
  if (std_log) {
    _L: /* CIL Label */ 
    {
#line 177
    pthread_mutex_lock(& logging_mutex);
#line 185
    t = time((time_t *)((void *)0));
#line 186
    __cil_tmp13 = ctime(& t);
#line 186
    __cil_tmp14 = g_strdup(__cil_tmp13);
#line 186
    tstr = __cil_tmp14;
#line 187
    gettimeofday(& tv, (void *)0);
#line 191
    __cil_tmp18 = strlen((char const   *)tstr);
#line 191
    *(tstr + (__cil_tmp18 - 1UL)) = (char )0;
    }
#line 192
    if (std_log) {
      {
#line 193
      fprintf(logfile, "[%s : %d] speechd: ", tstr, (int )tv.tv_usec);
      }
    }
#line 198
    if (custom_log) {
      {
#line 199
      fprintf(custom_logfile, "[%s : %d] speechd: ", tstr, (int )tv.tv_usec);
      }
    }
#line 203
    if (SpeechdOptions.debug) {
      {
#line 204
      fprintf(debug_logfile, "[%s : %d] speechd: ", tstr, (int )tv.tv_usec);
      }
    }
    {
#line 208
    g_free(tstr);
#line 210
    i = 1;
    }
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 210
      if (! (i < level)) {
#line 210
        goto while_break;
      }
#line 211
      if (std_log) {
        {
#line 212
        fprintf(logfile, " ");
        }
      }
#line 214
      if (custom_log) {
        {
#line 215
        fprintf(custom_logfile, " ");
        }
      }
#line 210
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 218
    if (std_log) {
      {
#line 219
      __builtin_va_start((void *)args, format);
#line 220
      vfprintf(logfile, format, (void *)args);
#line 221
      __builtin_va_end((void *)args);
#line 222
      fprintf(logfile, "\n");
#line 223
      fflush(logfile);
      }
    }
#line 225
    if (custom_log) {
      {
#line 226
      __builtin_va_start((void *)args, format);
#line 227
      vfprintf(custom_logfile, format, (void *)args);
#line 228
      __builtin_va_end((void *)args);
#line 229
      fprintf(custom_logfile, "\n");
#line 230
      fflush(custom_logfile);
      }
    }
#line 232
    if (SpeechdOptions.debug) {
      {
#line 233
      __builtin_va_start((void *)args, format);
#line 234
      vfprintf(debug_logfile, format, (void *)args);
#line 235
      __builtin_va_end((void *)args);
#line 236
      fprintf(debug_logfile, "\n");
#line 237
      fflush(debug_logfile);
      }
    }
    {
#line 240
    pthread_mutex_unlock(& logging_mutex);
    }
  } else
#line 173
  if (custom_log) {
#line 173
    goto _L;
  }
  return;
}
}
#line 251 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void MSG(int level , char const   *format  , ...) 
{ 
  va_list args ;
  int i ;
  time_t t ;
  char *tstr ;
  struct timeval tv ;
  time_t __cil_tmp8 ;
  char *__cil_tmp9 ;
  gchar *__cil_tmp10 ;
  int tmp ;
  unsigned long __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 254
  if (level <= SpeechdOptions.log_level) {
    _L: /* CIL Label */ 
    {
#line 258
    pthread_mutex_lock(& logging_mutex);
#line 265
    t = time((time_t *)((void *)0));
#line 266
    __cil_tmp9 = ctime(& t);
#line 266
    __cil_tmp10 = g_strdup(__cil_tmp9);
#line 266
    tstr = __cil_tmp10;
#line 267
    gettimeofday(& tv, (void *)0);
#line 272
    __cil_tmp15 = strlen((char const   *)tstr);
#line 272
    *(tstr + (__cil_tmp15 - 1UL)) = (char )0;
    }
#line 274
    if (level <= SpeechdOptions.log_level) {
      {
#line 275
      fprintf(logfile, "[%s : %d] speechd: ", tstr, (int )tv.tv_usec);
      }
    }
#line 277
    if (SpeechdOptions.debug) {
      {
#line 278
      fprintf(debug_logfile, "[%s : %d] speechd: ", tstr, (int )tv.tv_usec);
      }
    }
    {
#line 283
    g_free(tstr);
#line 286
    i = 1;
    }
    {
#line 286
    while (1) {
      while_continue: /* CIL Label */ ;
#line 286
      if (! (i < level)) {
#line 286
        goto while_break;
      }
      {
#line 287
      fprintf(logfile, " ");
      }
#line 286
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 290
    if (level <= SpeechdOptions.log_level) {
      {
#line 291
      __builtin_va_start((void *)args, format);
#line 292
      vfprintf(logfile, format, (void *)args);
#line 293
      __builtin_va_end((void *)args);
#line 294
      fprintf(logfile, "\n");
#line 295
      fflush(logfile);
      }
    }
#line 298
    if (SpeechdOptions.debug) {
      {
#line 299
      __builtin_va_start((void *)args, format);
#line 300
      vfprintf(debug_logfile, format, (void *)args);
#line 301
      __builtin_va_end((void *)args);
#line 302
      fprintf(debug_logfile, "\n");
#line 303
      fflush(debug_logfile);
      }
    }
#line 306
    if (level == -1) {
      {
#line 307
      __builtin_va_start((void *)args, format);
#line 308
      vfprintf(stderr, format, (void *)args);
#line 309
      __builtin_va_end((void *)args);
#line 310
      fprintf(stderr, "\n");
#line 311
      fflush(stderr);
      }
    }
    {
#line 314
    pthread_mutex_unlock(& logging_mutex);
    }
  } else
#line 254
  if (SpeechdOptions.debug) {
#line 254
    goto _L;
  }
  return;
}
}
#line 321 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int speechd_sockets_status_init(void) 
{ 
  GHashTable *__cil_tmp1 ;

  {
  {
#line 323
  speechd_sockets_status = g_hash_table_new_full(& g_int_hash, & g_int_equal, (GDestroyNotify )(& g_free),
                                                 (GDestroyNotify )(& speechd_socket_free));
  }
#line 327
  if (speechd_sockets_status) {
#line 328
    return (0);
  } else {
#line 330
    return (1);
  }
}
}
#line 334 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int speechd_socket_register(int fd ) 
{ 
  int *fd_key ;
  TSpeechDSock *speechd_socket ;
  gpointer __cil_tmp4 ;
  gpointer __cil_tmp5 ;

  {
  {
#line 338
  speechd_socket = (TSpeechDSock *)g_malloc(sizeof(TSpeechDSock ));
#line 339
  speechd_socket->o_buf = (GString *)((void *)0);
#line 340
  speechd_socket->o_bytes = (size_t )0;
#line 341
  speechd_socket->awaiting_data = 0;
#line 342
  speechd_socket->inside_block = 0;
#line 343
  fd_key = (int *)g_malloc(sizeof(int ));
#line 344
  *fd_key = fd;
#line 345
  g_hash_table_insert(speechd_sockets_status, fd_key, speechd_socket);
  }
#line 346
  return (0);
}
}
#line 350 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_socket_free(TSpeechDSock *speechd_socket ) 
{ 


  {
#line 352
  if (speechd_socket->o_buf) {
    {
#line 353
    g_string_free(speechd_socket->o_buf, 1);
    }
  }
  {
#line 354
  g_free(speechd_socket);
  }
  return;
}
}
#line 358 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int speechd_socket_unregister(int fd ) 
{ 
  gboolean __cil_tmp2 ;

  {
  {
#line 360
  __cil_tmp2 = g_hash_table_remove(speechd_sockets_status, & fd);
  }
#line 360
  return (! __cil_tmp2);
}
}
#line 364 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
TSpeechDSock *speechd_socket_get_by_fd(int fd ) 
{ 
  gpointer __cil_tmp2 ;

  {
  {
#line 366
  __cil_tmp2 = g_hash_table_lookup(speechd_sockets_status, & fd);
  }
#line 366
  return (__cil_tmp2);
}
}
#line 370 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int speechd_connection_new(int server_socket___0 ) 
{ 
  TFDSetElement *new_fd_set ;
  struct sockaddr_in client_address ;
  unsigned int client_len ;
  int client_socket ;
  int *p_client_socket ;
  int *p_client_uid ;
  int *p_client_uid2 ;
  __SOCKADDR_ARG tmp ;
  int __cil_tmp10 ;
  TFDSetElement *__cil_tmp11 ;
  int __cil_tmp12 ;
  gpointer __cil_tmp13 ;
  gpointer __cil_tmp14 ;
  gpointer __cil_tmp15 ;
  guint __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 374
  client_len = (unsigned int )sizeof(client_address);
#line 378
  tmp.__sockaddr__ = (struct sockaddr *)(& client_address);
#line 378
  __cil_tmp10 = accept(server_socket___0, tmp, & client_len);
#line 378
  client_socket = __cil_tmp10;
  }
#line 382
  if (client_socket == -1) {
    {
#line 383
    MSG(2, "Error: Can\'t handle connection request of a new client");
    }
#line 385
    return (- 1);
  }
#line 389
  if (client_socket > SpeechdStatus.max_fd) {
#line 390
    SpeechdStatus.max_fd = client_socket;
  }
  {
#line 391
  MSG(4, "Adding client on fd %d", client_socket);
#line 393
  speechd_socket_register(client_socket);
#line 396
  __cil_tmp11 = default_fd_set();
#line 396
  new_fd_set = (TFDSetElement *)__cil_tmp11;
  }
#line 397
  if (new_fd_set == (void *)0) {
    {
#line 398
    MSG(2, "Error: Failed to create a record in fd_settings for the new client");
    }
#line 400
    if (SpeechdStatus.max_fd == client_socket) {
#line 401
      __cil_tmp12 = SpeechdStatus.max_fd;
#line 401
      (SpeechdStatus.max_fd) --;
    }
#line 402
    return (- 1);
  }
  {
#line 404
  new_fd_set->fd = client_socket;
#line 405
  (SpeechdStatus.max_uid) ++;
#line 405
  new_fd_set->uid = (unsigned int )SpeechdStatus.max_uid;
#line 406
  __cil_tmp13 = g_malloc(sizeof(int ));
#line 406
  p_client_socket = (int *)__cil_tmp13;
#line 407
  __cil_tmp14 = g_malloc(sizeof(int ));
#line 407
  p_client_uid = (int *)__cil_tmp14;
#line 408
  __cil_tmp15 = g_malloc(sizeof(int ));
#line 408
  p_client_uid2 = (int *)__cil_tmp15;
#line 409
  *p_client_socket = client_socket;
#line 410
  *p_client_uid = SpeechdStatus.max_uid;
#line 411
  *p_client_uid2 = SpeechdStatus.max_uid;
#line 413
  g_hash_table_insert(fd_settings, p_client_uid, new_fd_set);
#line 414
  g_hash_table_insert(fd_uid, p_client_socket, p_client_uid2);
#line 416
  new_fd_set->fd_source = g_unix_fd_add(client_socket, (GIOCondition )1, & client_process_incoming,
                                        (void *)0);
#line 418
  MSG(4, "Data structures for client on fd %d created", client_socket);
#line 420
  client_count ++;
#line 421
  check_client_count();
  }
#line 423
  return (0);
}
}
#line 427 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int speechd_connection_destroy(int fd ) 
{ 
  TFDSetElement *fdset_element ;
  TFDSetElement *__cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 432
  MSG(4, "Removing client on fd %d\230\001", fd);
#line 434
  MSG(4, "Tagging client as inactive in settings\003");
#line 435
  fdset_element = get_client_settings_by_fd(fd);
  }
#line 436
  if (fdset_element != (void *)0) {
    {
#line 437
    fdset_element->fd = - 1;
#line 438
    fdset_element->active = 0;
#line 439
    g_source_remove(fdset_element->fd_source);
    }
  } else
#line 443
  if (0) {
    {
#line 444
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 444
      MSG(0, "Error [%s:%d]:Can\'t find settings for this client\n\003", "./src/server/speechd.c",
          444);
#line 444
      exit(1);
      }
#line 444
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 447
  MSG(4, "Removing client from the fd->uid table.");
#line 449
  g_hash_table_remove(fd_uid, & fd);
#line 451
  speechd_socket_unregister(fd);
#line 453
  MSG(4, "Closing clients file descriptor %d\004", fd);
#line 455
  __cil_tmp4 = close(fd);
  }
#line 455
  if (__cil_tmp4 != 0) {
#line 456
    if (0) {
      {
#line 457
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 457
        MSG(0, "Error [%s:%d]:Can\'t close file descriptor associated to this client",
            "./src/server/speechd.c", 457);
#line 457
        exit(1);
        }
#line 457
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 459
  if (fd == SpeechdStatus.max_fd) {
#line 460
    __cil_tmp5 = SpeechdStatus.max_fd;
#line 460
    (SpeechdStatus.max_fd) --;
  }
  {
#line 462
  MSG(4, "Connection closed=H\200\332U");
#line 464
  __cil_tmp6 = client_count;
#line 464
  client_count --;
#line 465
  check_client_count();
  }
#line 467
  return (0);
}
}
#line 470 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
static gboolean speechd_client_terminate(gpointer key , gpointer value , gpointer user ) 
{ 
  TFDSetElement *set ;

  {
#line 474
  set = (TFDSetElement *)value;
#line 475
  if (set == (void *)0) {
    {
#line 476
    MSG(2, "Error: Empty connection, internal error");
    }
#line 477
    if (0) {
      {
#line 478
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 478
        fatal_error();
#line 478
        MSG(- 1, "Fatal error [%s:%d]:Internal error", "./src/server/speechd.c", 478);
#line 478
        exit(1);
        }
#line 478
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 479
    return (! 0);
  }
#line 482
  if (set->fd > 0) {
    {
#line 483
    MSG(4, "Closing connection on fd %d\n\332U", set->fd);
#line 484
    speechd_connection_destroy(set->fd);
    }
  }
  {
#line 486
  mem_free_fdset(set);
#line 487
  g_free(set);
  }
#line 488
  return (! 0);
}
}
#line 493 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_modules_terminate(gpointer data , gpointer user_data ) 
{ 
  OutputModule *module ;

  {
#line 497
  module = (OutputModule *)data;
#line 498
  if (module == (void *)0) {
    {
#line 499
    MSG(2, "Error: Empty module, internal error\200\332U");
    }
#line 500
    return;
  }
  {
#line 502
  unload_output_module(module);
  }
#line 504
  return;
}
}
#line 507 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_modules_reload(gpointer data , gpointer user_data ) 
{ 
  OutputModule *module ;

  {
#line 511
  module = (OutputModule *)data;
#line 512
  if (module == (void *)0) {
    {
#line 513
    MSG(2, "Empty module, internal error-/\a");
    }
#line 514
    return;
  }
  {
#line 517
  reload_output_module(module);
  }
#line 519
  return;
}
}
#line 522 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_module_debug(gpointer data , gpointer user_data ) 
{ 
  OutputModule *module ;

  {
#line 526
  module = (OutputModule *)data;
#line 527
  if (module == (void *)0) {
    {
#line 528
    MSG(2, "Empty module, internal errorP");
    }
#line 529
    return;
  }
  {
#line 532
  output_module_debug(module);
  }
#line 534
  return;
}
}
#line 537 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_module_nodebug(gpointer data , gpointer user_data ) 
{ 
  OutputModule *module ;

  {
#line 541
  module = (OutputModule *)data;
#line 542
  if (module == (void *)0) {
    {
#line 543
    MSG(2, "Empty module, internal error");
    }
#line 544
    return;
  }
  {
#line 547
  output_module_nodebug(module);
  }
#line 549
  return;
}
}
#line 552 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
static gboolean speechd_reload_dead_modules(gpointer user_data ) 
{ 
  __pid_t __cil_tmp2 ;

  {
  {
#line 555
  g_list_foreach(output_modules, & speechd_modules_reload, (void *)0);
  }
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 558
    __cil_tmp2 = waitpid(- 1, (int *)((void *)0), 1);
    }
#line 558
    if (! (__cil_tmp2 > 0)) {
#line 558
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
#line 559
  return (! 0);
}
}
#line 562 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_modules_debug(void) 
{ 


  {
  {
#line 565
  g_list_foreach(output_modules, & speechd_module_debug, (void *)0);
  }
  return;
}
}
#line 569 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_modules_nodebug(void) 
{ 


  {
  {
#line 572
  g_list_foreach(output_modules, & speechd_module_nodebug, (void *)0);
  }
  return;
}
}
#line 577 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_options_init(void) 
{ 


  {
#line 579
  SpeechdOptions.spawn = 0;
#line 580
  SpeechdOptions.log_level_set = 0;
#line 581
  SpeechdOptions.communication_method = (char *)((void *)0);
#line 582
  SpeechdOptions.socket_path = (char *)((void *)0);
#line 583
  SpeechdOptions.port_set = 0;
#line 584
  SpeechdOptions.localhost_access_only_set = 0;
#line 585
  SpeechdOptions.pid_file = (char *)((void *)0);
#line 586
  SpeechdOptions.conf_file = (char *)((void *)0);
#line 587
  SpeechdOptions.conf_dir = (char *)((void *)0);
#line 588
  SpeechdOptions.user_conf_dir = (char *)((void *)0);
#line 589
  SpeechdOptions.runtime_speechd_dir = (char *)((void *)0);
#line 590
  SpeechdOptions.module_dir = "/usr/libexec/speech-dispatcher-modules";
#line 591
  SpeechdOptions.user_module_dir = (char *)((void *)0);
#line 592
  SpeechdOptions.log_dir = (char *)((void *)0);
#line 593
  SpeechdOptions.log_dir_set = 0;
#line 594
  SpeechdOptions.debug = 0;
#line 595
  SpeechdOptions.debug_destination = (char *)((void *)0);
#line 596
  debug_logfile = (FILE *)((void *)0);
#line 597
  spd_mode = (TSpeechDMode )0;
  return;
}
}
#line 600 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void speechd_init(void) 
{ 
  int __cil_tmp1 ;
  int *__cil_tmp2 ;
  char *__cil_tmp3 ;
  gpointer __cil_tmp4 ;
  GHashTable *__cil_tmp5 ;
  int tmp ;
  GHashTable *__cil_tmp7 ;
  int tmp___0 ;
  GHashTable *__cil_tmp9 ;
  int tmp___1 ;
  gboolean __cil_tmp11 ;
  gchar *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  guint __cil_tmp14 ;
  guint __cil_tmp15 ;
  guint __cil_tmp16 ;
  char const   *tmp___2 ;

  {
  {
#line 602
  SpeechdStatus.max_uid = 0;
#line 603
  SpeechdStatus.max_gid = 0;
#line 606
  __cil_tmp1 = pipe((int *)speaking_pipe);
  }
#line 606
  if (__cil_tmp1) {
    {
#line 607
    __cil_tmp2 = __errno_location();
#line 607
    __cil_tmp3 = strerror(*__cil_tmp2);
#line 607
    MSG(1, "Speaking pipe creation failed (%s)", __cil_tmp3);
    }
    {
#line 608
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 608
      fatal_error();
#line 608
      MSG(- 1, "Fatal error [%s:%d]:Can\'t create pipe", "./src/server/speechd.c",
          608);
#line 608
      exit(1);
      }
#line 608
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 612
  MessageQueue = (TSpeechDQueue *)g_malloc0(sizeof(TSpeechDQueue ));
  }
#line 613
  if (MessageQueue == (void *)0) {
    {
#line 614
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 614
      fatal_error();
#line 614
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t allocate memory for MessageQueue.",
          "./src/server/speechd.c", 614);
#line 614
      exit(1);
      }
#line 614
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 617
  MessagePausedList = (GList *)((void *)0);
#line 620
  fd_settings = g_hash_table_new_full(& g_int_hash, & g_int_equal, (GDestroyNotify )(& g_free),
                                      (GDestroyNotify )((void *)0));
#line 624
  fd_uid = g_hash_table_new_full(& g_int_hash, & g_int_equal, (GDestroyNotify )(& g_free),
                                 (GDestroyNotify )(& g_free));
#line 629
  language_default_modules = g_hash_table_new(& g_str_hash, & g_str_equal);
#line 632
  speechd_sockets_status_init();
#line 634
  pause_requested = 0;
#line 635
  resume_requested = 0;
#line 638
  __cil_tmp11 = g_module_supported();
  }
#line 638
  if (__cil_tmp11 == 0) {
    {
#line 639
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 639
      MSG(0, "Error [%s:%d]:Loadable modules not supported by current platform.\n",
          "./src/server/speechd.c", 639);
#line 639
      exit(1);
      }
#line 639
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 641
  if (0) {
    {
#line 642
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 642
      MSG(0, "Error [%s:%d]:This system doesn\'t support POSIX.1c threads\n", "./src/server/speechd.c",
          642);
#line 642
      exit(1);
      }
#line 642
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 645
  GlobalFDSet.min_delay_progress = (unsigned int )2000;
#line 648
  client_specific_settings = (GList *)((void *)0);
#line 650
  if (SpeechdOptions.log_dir == (void *)0) {
    {
#line 651
    SpeechdOptions.log_dir = g_strdup_printf((gchar *)"%s/log/", SpeechdOptions.runtime_speechd_dir);
#line 654
    mkdir((char const   *)SpeechdOptions.log_dir, (__mode_t )448);
    }
#line 655
    if (! SpeechdOptions.debug_destination) {
      {
#line 656
      SpeechdOptions.debug_destination = g_strdup_printf((gchar *)"%s/log/debug",
                                                         SpeechdOptions.runtime_speechd_dir);
#line 659
      mkdir((char const   *)SpeechdOptions.debug_destination, (__mode_t )448);
      }
    }
  }
  {
#line 664
  MSG(4, "Reading Speech Dispatcher configuration from %s", SpeechdOptions.conf_file);
#line 666
  speechd_load_configuration((void *)0);
#line 668
  logging_init();
#line 671
  __cil_tmp14 = g_list_length(output_modules);
  }
#line 671
  if (__cil_tmp14 == 0U) {
    {
#line 672
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 672
      MSG(0, "Error [%s:%d]:No speech output modules were loaded - aborting...", "./src/server/speechd.c",
          672);
#line 672
      exit(1);
      }
#line 672
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 674
    __cil_tmp15 = g_list_length(output_modules);
    }
    {
#line 674
    __cil_tmp16 = g_list_length(output_modules);
    }
#line 674
    if (__cil_tmp16 > 1U) {
#line 674
      tmp___2 = "s";
    } else {
#line 674
      tmp___2 = "\220";
    }
    {
#line 674
    MSG(3, "Speech Dispatcher started with %d output module%s", __cil_tmp15, tmp___2);
    }
  }
#line 679
  last_p5_block = (GList *)((void *)0);
  return;
}
}
#line 682 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
static gint modules_compare(gconstpointer a , gconstpointer b ) 
{ 
  char const   **params_a ;
  char const   *name_a ;
  char const   **params_b ;
  char const   *name_b ;
  unsigned int index_a ;
  unsigned int index_b ;
  static char const   *modules_order[16] ;
  static int index_max ;
  int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 684
  params_a = (char const   **)a;
#line 685
  name_a = *(params_a + 0);
#line 686
  params_b = (char const   **)b;
#line 687
  name_b = *(params_b + 0);
#line 692
  modules_order[0] = "voxin";
#line 692
  modules_order[1] = "ivona";
#line 692
  modules_order[2] = "pico";
#line 692
  modules_order[3] = "pico-generic";
#line 692
  modules_order[4] = "rhvoice";
#line 692
  modules_order[5] = "cicero";
#line 692
  modules_order[6] = "kali";
#line 692
  modules_order[7] = "ibmtts";
#line 692
  modules_order[8] = "festival\323\001 ";
#line 692
  modules_order[9] = "flite";
#line 692
  modules_order[10] = "espeak-ng-mbrola\323\001 ";
#line 692
  modules_order[11] = "espeak-ng-mbrola-generic\323\001 ";
#line 692
  modules_order[12] = "espeak-ng";
#line 692
  modules_order[13] = "espeak-mbrola-generic";
#line 692
  modules_order[14] = "espeak";
#line 692
  modules_order[15] = "espeak-generic";
#line 710
  index_max = (int )(sizeof(modules_order) / sizeof(*((char const   **)modules_order)));
#line 712
  index_a = (unsigned int )0;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (index_a < (unsigned int )index_max)) {
#line 712
      goto while_break;
    }
    {
#line 713
    __cil_tmp11 = strcmp(modules_order[index_a], name_a);
    }
#line 713
    if (! __cil_tmp11) {
#line 714
      goto while_break;
    }
#line 712
    index_a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  index_b = (unsigned int )0;
  {
#line 717
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 717
    if (! (index_b < (unsigned int )index_max)) {
#line 717
      goto while_break___0;
    }
    {
#line 718
    __cil_tmp13 = strcmp(modules_order[index_b], name_b);
    }
#line 718
    if (! __cil_tmp13) {
#line 719
      goto while_break___0;
    }
#line 717
    index_b ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 722
  if (index_a != (unsigned int )index_max) {
#line 722
    if (index_b == (unsigned int )index_max) {
#line 724
      return (- 1);
    }
  }
#line 726
  if (index_a == (unsigned int )index_max) {
#line 726
    if (index_b != (unsigned int )index_max) {
#line 728
      return (1);
    }
  }
#line 730
  if (index_a != (unsigned int )index_max) {
#line 730
    if (index_b != (unsigned int )index_max) {
#line 732
      return ((gint )(index_a - index_b));
    }
  }
  {
#line 735
  __cil_tmp15 = strcmp(name_a, name_b);
  }
#line 735
  return (__cil_tmp15);
}
}
#line 738 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
static gboolean speechd_load_configuration(gpointer user_data ) 
{ 
  configfile_t *configfile ;
  GList *detected_modules ;
  __pid_t __cil_tmp4 ;
  configoption_t *__cil_tmp5 ;
  configoption_t *__cil_tmp6 ;
  configfile_t *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  int __cil_tmp9 ;
  guint __cil_tmp10 ;
  GList *__cil_tmp11 ;
  GList *__cil_tmp12 ;
  GList *__cil_tmp13 ;
  GList *__cil_tmp14 ;
  char **parameters ;
  GList *__cil_tmp16 ;

  {
#line 740
  configfile = (configfile_t *)((void *)0);
#line 741
  detected_modules = (GList *)((void *)0);
#line 744
  if (output_modules != (void *)0) {
    {
#line 745
    g_list_foreach(output_modules, & speechd_modules_terminate, (void *)0);
#line 746
    g_list_free(output_modules);
#line 747
    output_modules = (GList *)((void *)0);
    }
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 751
    __cil_tmp4 = waitpid(- 1, (int *)((void *)0), 1);
    }
#line 751
    if (! (__cil_tmp4 > 0)) {
#line 751
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 754
  load_default_global_set_options();
#line 756
  spd_num_options = 0;
#line 757
  spd_options = load_config_options(& spd_num_options);
#line 760
  spd_options = add_config_option(spd_options, & spd_num_options, "\251", 0, (dotconf_callback_t )((void *)0),
                                  (void *)0, (unsigned long )0);
#line 763
  configfile = dotconf_create(SpeechdOptions.conf_file, spd_options, (context_t *)0,
                              (unsigned long )1);
  }
#line 766
  if (configfile) {
    {
#line 767
    free(configfile->includepath);
#line 768
    configfile->includepath = g_strdup(SpeechdOptions.conf_dir);
#line 769
    MSG(5, "Config file include path is: %s", configfile->includepath);
#line 771
    __cil_tmp9 = dotconf_command_loop(configfile);
    }
#line 771
    if (__cil_tmp9 == 0) {
      {
#line 772
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 772
        MSG(0, "Error [%s:%d]:Error reading config file\n", "./src/server/speechd.c",
            772);
#line 772
        exit(1);
        }
#line 772
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 773
    dotconf_cleanup(configfile);
#line 774
    MSG(2, "Configuration has been read from \"%s\"U", SpeechdOptions.conf_file);
#line 779
    __cil_tmp10 = module_number_of_requested_modules();
    }
#line 779
    if (__cil_tmp10 < 1U) {
      {
#line 780
      detected_modules = detect_output_modules((GList *)((void *)0), (char const   *)SpeechdOptions.user_module_dir,
                                               (char const   *)SpeechdOptions.user_conf_dir,
                                               (char const   *)SpeechdOptions.conf_dir);
#line 784
      detected_modules = detect_output_modules(detected_modules, (char const   *)SpeechdOptions.module_dir,
                                               (char const   *)SpeechdOptions.user_conf_dir,
                                               (char const   *)SpeechdOptions.conf_dir);
#line 788
      detected_modules = detect_output_modules(detected_modules, "/usr/lib/x86_64-linux-gnu/speech-dispatcher-modules\200\332U",
                                               (char const   *)SpeechdOptions.user_conf_dir,
                                               (char const   *)SpeechdOptions.conf_dir);
#line 793
      detected_modules = g_list_sort(detected_modules, & modules_compare);
      }
      {
#line 795
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 795
        if (! (detected_modules != (void *)0)) {
#line 795
          goto while_break___1;
        }
        {
#line 796
        parameters = detected_modules->data;
#line 797
        module_add_load_request(*(parameters + 0), *(parameters + 1), *(parameters + 2),
                                *(parameters + 3), *(parameters + 4), *(parameters + 5));
#line 803
        g_free(detected_modules->data);
#line 804
        detected_modules->data = (void *)0;
#line 805
        detected_modules = g_list_delete_link(detected_modules, detected_modules);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 811
    module_load_requested_modules();
    }
  } else {
    {
#line 813
    MSG(1, "Can\'t open %s", SpeechdOptions.conf_file);
    }
  }
  {
#line 816
  free_config_options(spd_options, & spd_num_options);
  }
#line 818
  return (! 0);
}
}
#line 821 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
static gboolean speechd_quit(gpointer user_data ) 
{ 


  {
  {
#line 823
  g_main_loop_quit(main_loop);
  }
#line 824
  return (0);
}
}
#line 829 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int create_pid_file(void) 
{ 
  FILE *pid_file ;
  int pid_fd ;
  struct flock lock ;
  int ret ;
  FILE *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  FILE *__cil_tmp8 ;
  __pid_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 837
  pid_file = fopen((char const   *)SpeechdOptions.pid_file, "r");
  }
#line 838
  if (pid_file != (void *)0) {
    {
#line 839
    pid_fd = fileno(pid_file);
#line 841
    lock.l_type = (short )1;
#line 842
    lock.l_whence = (short )0;
#line 843
    lock.l_start = (__off_t )1;
#line 844
    lock.l_len = (__off_t )3;
#line 847
    ret = fcntl(pid_fd, 5, & lock);
    }
#line 848
    if (ret == -1) {
      {
#line 849
      MSG(- 1, "Can\'t check lock status of an existing pid file.\n");
      }
#line 851
      return (- 1);
    }
    {
#line 854
    fclose(pid_file);
    }
#line 855
    if ((int )lock.l_type != 2) {
      {
#line 856
      MSG(- 1, "Speech Dispatcher already running.\n");
      }
#line 857
      return (- 1);
    }
    {
#line 860
    unlink((char const   *)SpeechdOptions.pid_file);
    }
  }
  {
#line 864
  pid_file = fopen((char const   *)SpeechdOptions.pid_file, "w");
  }
#line 865
  if (pid_file == (void *)0) {
    {
#line 866
    MSG(- 1, "Can\'t create pid file in %s, wrong permissions?\n\230\001", SpeechdOptions.pid_file);
    }
#line 868
    return (- 1);
  }
  {
#line 870
  __cil_tmp9 = getpid();
#line 870
  fprintf(pid_file, "%d\n\200\332U", __cil_tmp9);
#line 871
  fflush(pid_file);
#line 873
  pid_fd = fileno(pid_file);
#line 874
  lock.l_type = (short )1;
#line 875
  lock.l_whence = (short )0;
#line 876
  lock.l_start = (__off_t )1;
#line 877
  lock.l_len = (__off_t )3;
#line 879
  ret = fcntl(pid_fd, 6, & lock);
  }
#line 880
  if (ret == -1) {
    {
#line 881
    MSG(- 1, "Can\'t set lock on pid file.\n\332U");
    }
#line 882
    return (- 1);
  }
#line 885
  return (0);
}
}
#line 888 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void destroy_pid_file(void) 
{ 


  {
  {
#line 890
  unlink((char const   *)SpeechdOptions.pid_file);
  }
  return;
}
}
#line 893 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void logging_init(void) 
{ 
  char *file_name ;
  gchar *__cil_tmp2 ;
  int tmp ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  FILE *__cil_tmp6 ;

  {
  {
#line 895
  __cil_tmp2 = g_strdup_printf((gchar *)"%s/speech-dispatcher.log\230\001", SpeechdOptions.log_dir);
#line 895
  file_name = __cil_tmp2;
#line 898
  __cil_tmp4 = strncmp((char const   *)file_name, "stdout", (unsigned long )6);
  }
#line 898
  if (! __cil_tmp4) {
#line 899
    logfile = stdout;
  } else {
    {
#line 900
    __cil_tmp5 = strncmp((char const   *)file_name, "stderr", (unsigned long )6);
    }
#line 900
    if (! __cil_tmp5) {
#line 901
      logfile = stderr;
    } else {
      {
#line 903
      logfile = fopen((char const   *)file_name, "a\330a\200\332U");
      }
#line 904
      if (logfile == (void *)0) {
        {
#line 905
        fprintf(stderr, "Error: can\'t open logging file %s! Using stdout.\n", file_name);
#line 908
        logfile = stdout;
        }
      } else {
        {
#line 910
        MSG(3, "Speech Dispatcher Logging to file %s", file_name);
        }
      }
    }
  }
#line 915
  if (! debug_logfile) {
#line 916
    debug_logfile = stdout;
  }
  {
#line 918
  g_free(file_name);
  }
#line 919
  return;
}
}
#line 924 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int make_local_socket(char const   *filename ) 
{ 
  struct sockaddr_un name ;
  int sock ;
  size_t size ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  __CONST_SOCKADDR_ARG tmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 931
  sock = socket(1, 1, 0);
  }
#line 932
  if (sock < 0) {
    {
#line 933
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 933
      fatal_error();
#line 933
      MSG(- 1, "Fatal error [%s:%d]:Can\'t create local socket\317a\200\332U", "./src/server/speechd.c",
          933);
#line 933
      exit(1);
      }
#line 933
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 937
  name.sun_family = (sa_family_t )1;
#line 938
  strncpy((char *)name.sun_path, filename, sizeof(name.sun_path));
#line 939
  name.sun_path[sizeof(name.sun_path) - 1UL] = (char )'\000';
#line 940
  __cil_tmp6 = strlen((char const   *)((char *)name.sun_path));
#line 940
  size = (size_t )((char *)((struct sockaddr_un *)0)->sun_path) + __cil_tmp6;
#line 942
  tmp.__sockaddr__ = (struct sockaddr *)(& name);
#line 942
  __cil_tmp8 = bind(sock, tmp, (socklen_t )size);
  }
#line 942
  if (__cil_tmp8 < 0) {
    {
#line 943
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 943
      fatal_error();
#line 943
      MSG(- 1, "Fatal error [%s:%d]:Can\'t bind local socket", "./src/server/speechd.c",
          943);
#line 943
      exit(1);
      }
#line 943
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 946
  __cil_tmp9 = listen(sock, 50);
  }
#line 946
  if (__cil_tmp9 == -1) {
    {
#line 947
    __cil_tmp10 = __errno_location();
#line 947
    __cil_tmp11 = strerror(*__cil_tmp10);
#line 947
    MSG(2, "listen failed: ERRNO:%s", __cil_tmp11);
    }
    {
#line 948
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 948
      fatal_error();
#line 948
      MSG(- 1, "Fatal error [%s:%d]:listen() failed for local socket\323\001 ", "./src/server/speechd.c",
          948);
#line 948
      exit(1);
      }
#line 948
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 951
  return (sock);
}
}
#line 954 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int make_inet_socket(int port ) 
{ 
  struct sockaddr_in server_address ;
  int server_socket___17 ;
  int __cil_tmp4 ;
  int flag ;
  int __cil_tmp6 ;
  __uint32_t __cil_tmp7 ;
  __uint32_t __cil_tmp8 ;
  __uint16_t __cil_tmp9 ;
  __CONST_SOCKADDR_ARG tmp ;
  int __cil_tmp11 ;
  int *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 960
  server_socket___17 = socket(2, 1, 0);
  }
#line 961
  if (server_socket___17 < 0) {
    {
#line 962
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 962
      fatal_error();
#line 962
      MSG(- 1, "Fatal error [%s:%d]:Can\'t create inet socket\323\001 ", "./src/server/speechd.c",
          962);
#line 962
      exit(1);
      }
#line 962
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 966
  flag = 1;
#line 967
  __cil_tmp6 = setsockopt(server_socket___17, 1, 2, & flag, (socklen_t )sizeof(int ));
  }
#line 967
  if (__cil_tmp6) {
    {
#line 969
    MSG(2, "Error: Setting socket option failed!\332U");
    }
  }
#line 971
  server_address.sin_family = (sa_family_t )2;
#line 975
  if (SpeechdOptions.localhost_access_only) {
    {
#line 976
    server_address.sin_addr.s_addr = __bswap_32((in_addr_t )2130706433);
    }
  } else {
    {
#line 978
    server_address.sin_addr.s_addr = __bswap_32((in_addr_t )0);
    }
  }
  {
#line 980
  server_address.sin_port = __bswap_16((__uint16_t )port);
#line 982
  MSG(4, "Opening inet socket connection");
#line 983
  tmp.__sockaddr__ = (struct sockaddr *)(& server_address);
#line 983
  __cil_tmp11 = bind(server_socket___17, tmp, (socklen_t )sizeof(server_address));
  }
#line 983
  if (__cil_tmp11 == -1) {
    {
#line 985
    __cil_tmp12 = __errno_location();
#line 985
    __cil_tmp13 = strerror(*__cil_tmp12);
#line 985
    MSG(- 1, "bind() failed: %s", __cil_tmp13);
    }
    {
#line 986
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 986
      fatal_error();
#line 986
      MSG(- 1, "Fatal error [%s:%d]:Couldn\'t open inet socket, try a few minutes later.",
          "./src/server/speechd.c", 986);
#line 986
      exit(1);
      }
#line 986
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 989
  __cil_tmp14 = listen(server_socket___17, 50);
  }
#line 989
  if (__cil_tmp14 == -1) {
    {
#line 990
    __cil_tmp15 = __errno_location();
#line 990
    __cil_tmp16 = strerror(*__cil_tmp15);
#line 990
    MSG(2, "ERRNO:%s\230", __cil_tmp16);
    }
    {
#line 991
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 991
      fatal_error();
#line 991
      MSG(- 1, "Fatal error [%s:%d]:listen() failed for inet socket, another Speech Dispatcher running?",
          "./src/server/speechd.c", 991);
#line 991
      exit(1);
      }
#line 991
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 995
  return (server_socket___17);
}
}
#line 998 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
gboolean server_process_incoming(gint fd , GIOCondition condition , gpointer data ) 
{ 
  int ret ;
  int __cil_tmp5 ;

  {
  {
#line 1004
  ret = speechd_connection_new(fd);
  }
#line 1005
  if (ret != 0) {
    {
#line 1006
    MSG(2, "Error: Failed to add new client!\220");
    }
#line 1007
    if (0) {
      {
#line 1008
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1008
        fatal_error();
#line 1008
        MSG(- 1, "Fatal error [%s:%d]:Failed to add new client\323\001 ", "./src/server/speechd.c",
            1008);
#line 1008
        exit(1);
        }
#line 1008
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1012
  return (! 0);
}
}
#line 1015 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
gboolean client_process_incoming(gint fd , GIOCondition condition , gpointer data ) 
{ 
  int ret ;
  int nread ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1022
  ioctl(fd, (unsigned long )21531, & nread);
  }
#line 1024
  if (nread == 0) {
    {
#line 1026
    ret = speechd_connection_destroy(fd);
    }
#line 1027
    if (ret != 0) {
      {
#line 1028
      MSG(2, "Error: Failed to close the client!");
      }
    }
#line 1030
    return (0);
  }
  {
#line 1034
  __cil_tmp7 = serve(fd);
  }
#line 1034
  if (__cil_tmp7 == -1) {
    {
#line 1035
    MSG(2, "Error: Failed to serve client on fd %d!", fd);
    }
  }
#line 1038
  return (! 0);
}
}
#line 1041 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void check_client_count(void) 
{ 
  guint __cil_tmp1 ;

  {
#line 1043
  if (client_count <= 0) {
#line 1043
    if (SpeechdOptions.server_timeout > 0) {
      {
#line 1045
      MSG(4, "Currently no clients connected, enabling shutdown timer.\220");
#line 1046
      __cil_tmp1 = g_timeout_add_seconds((guint )SpeechdOptions.server_timeout, & speechd_quit,
                                         (void *)0);
#line 1046
      server_timeout_source = (gint )__cil_tmp1;
      }
    } else {
#line 1043
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1050
  if (server_timeout_source >= 0) {
    {
#line 1051
    MSG(4, "Clients connected, disabling shutdown timer.");
#line 1052
    g_source_remove((guint )server_timeout_source);
#line 1053
    server_timeout_source = - 1;
    }
  }
  return;
}
}
#line 1060 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
int main(int argc , char *argv[] ) 
{ 
  int ret ;
  char *spawn_communication_method ;
  int spawn_port ;
  char *spawn_socket_path ;
  gchar *__cil_tmp7 ;
  gchar *__cil_tmp8 ;
  char const   *user_runtime_dir ;
  char const   *user_config_dir ;
  char const   *user_data_dir ;
  gchar *__cil_tmp12 ;
  gchar *__cil_tmp13 ;
  gchar *__cil_tmp14 ;
  gchar *__cil_tmp15 ;
  gchar *__cil_tmp16 ;
  gchar *dirname ;
  gchar *__cil_tmp18 ;
  gchar *__cil_tmp19 ;
  int __cil_tmp20 ;
  gchar *__cil_tmp21 ;
  gchar *__cil_tmp22 ;
  gchar *__cil_tmp23 ;
  gchar *__cil_tmp24 ;
  gboolean __cil_tmp25 ;
  gchar *__cil_tmp26 ;
  gchar *__cil_tmp27 ;
  int __cil_tmp28 ;
  gchar *config_contents ;
  int err ;
  GRegex *regexp ;
  int result ;
  gboolean __cil_tmp33 ;
  GRegex *__cil_tmp34 ;
  gboolean __cil_tmp35 ;
  int __cil_tmp36 ;
  GString *socket_filename ;
  GString *__cil_tmp38 ;
  gchar *__cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int tmp ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  gboolean __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  GMainContext *__cil_tmp53 ;
  GMainLoop *__cil_tmp54 ;
  int __cil_tmp55 ;
  char *status ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 1064
  spawn_communication_method = (char *)((void *)0);
#line 1065
  spawn_port = 0;
#line 1066
  spawn_socket_path = (char *)((void *)0);
#line 1069
  umask((__mode_t )7);
#line 1072
  logfile = stdout;
#line 1073
  SpeechdOptions.log_level = 1;
#line 1074
  custom_logfile = (FILE *)((void *)0);
#line 1075
  custom_log_kind = (char *)((void *)0);
#line 1078
  i18n_init();
#line 1080
  speechd_options_init();
#line 1082
  options_parse(argc, argv);
  }
#line 1084
  if (SpeechdOptions.spawn) {
#line 1088
    if (SpeechdOptions.communication_method_set) {
      {
#line 1089
      spawn_communication_method = g_strdup(SpeechdOptions.communication_method);
#line 1091
      g_free(SpeechdOptions.communication_method);
#line 1092
      SpeechdOptions.communication_method_set = 0;
      }
    }
#line 1094
    if (SpeechdOptions.port_set) {
#line 1095
      spawn_port = SpeechdOptions.port;
#line 1096
      SpeechdOptions.port_set = 0;
    }
#line 1098
    if (SpeechdOptions.socket_path_set) {
      {
#line 1099
      spawn_socket_path = g_strdup(SpeechdOptions.socket_path);
#line 1101
      g_free(SpeechdOptions.socket_path);
#line 1102
      SpeechdOptions.socket_path_set = 0;
      }
    }
  }
  {
#line 1106
  MSG(1, "Speech Dispatcher 0.11.1-dirty starting");
#line 1115
  user_runtime_dir = (char const   *)g_get_user_runtime_dir();
#line 1116
  user_config_dir = (char const   *)g_get_user_config_dir();
#line 1117
  user_data_dir = (char const   *)g_get_user_data_dir();
#line 1120
  SpeechdOptions.runtime_speechd_dir = g_strdup_printf((gchar *)"%s/speech-dispatcher",
                                                       user_runtime_dir);
#line 1122
  MSG(4, "Trying to find %s", SpeechdOptions.runtime_speechd_dir);
#line 1123
  g_mkdir_with_parents(SpeechdOptions.runtime_speechd_dir, 448);
#line 1125
  MSG(4, "Using directory: %s for pidfile and logging", SpeechdOptions.runtime_speechd_dir);
  }
#line 1128
  if (SpeechdOptions.pid_file == (void *)0) {
    {
#line 1130
    SpeechdOptions.pid_file = g_strdup_printf((gchar *)"%s/pid/speech-dispatcher.pid",
                                              SpeechdOptions.runtime_speechd_dir);
#line 1133
    __cil_tmp18 = g_path_get_dirname(SpeechdOptions.pid_file);
#line 1133
    dirname = __cil_tmp18;
#line 1134
    mkdir((char const   *)dirname, (__mode_t )448);
#line 1135
    g_free(dirname);
    }
  }
#line 1138
  if (SpeechdOptions.conf_dir) {
    {
#line 1139
    SpeechdOptions.conf_file = g_strdup_printf((gchar *)"%s/speechd.conf", SpeechdOptions.conf_dir);
    }
  } else {
    {
#line 1143
    __cil_tmp20 = strcmp("/etc/speech-dispatcher", "\220");
    }
#line 1143
    if (__cil_tmp20) {
      {
#line 1144
      SpeechdOptions.conf_dir = g_strdup((gchar *)"/etc/speech-dispatcher");
      }
    } else {
      {
#line 1147
      SpeechdOptions.conf_dir = g_strdup((gchar *)"/etc/speech-dispatcher/");
      }
    }
    {
#line 1149
    SpeechdOptions.user_conf_dir = g_build_filename(user_config_dir, "speech-dispatcher",
                                                    (void *)0);
#line 1153
    MSG(4, "Looking for configuration in %s", SpeechdOptions.user_conf_dir);
#line 1154
    SpeechdOptions.conf_file = g_strdup_printf((gchar *)"%s/speechd.conf", SpeechdOptions.user_conf_dir);
#line 1156
    __cil_tmp25 = g_file_test(SpeechdOptions.conf_file, (GFileTest )1);
    }
#line 1156
    if (! __cil_tmp25) {
      {
#line 1159
      g_free(SpeechdOptions.conf_file);
#line 1160
      SpeechdOptions.conf_file = g_strdup_printf((gchar *)"%s/speechd.conf", SpeechdOptions.conf_dir);
      }
    }
  }
  {
#line 1165
  SpeechdOptions.user_module_dir = g_strdup_printf((gchar *)"%s/../libexec/speech-dispatcher-modules",
                                                   user_data_dir);
#line 1167
  MSG(4, "User module dir is %s", SpeechdOptions.user_module_dir);
#line 1172
  __cil_tmp28 = create_pid_file();
  }
#line 1172
  if (__cil_tmp28 != 0) {
    {
#line 1173
    exit(1);
    }
  }
#line 1176
  if (SpeechdOptions.spawn) {
    {
#line 1183
    err = g_file_get_contents(SpeechdOptions.conf_file, & config_contents, (gsize *)((void *)0),
                              (GError **)((void *)0));
    }
#line 1186
    if (err == 0) {
      {
#line 1187
      MSG(- 1, "Error opening %s\230\001", SpeechdOptions.conf_file);
      }
      {
#line 1188
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1188
        fatal_error();
#line 1188
        MSG(- 1, "Fatal error [%s:%d]:Can\'t open conf file", "./src/server/speechd.c",
            1188);
#line 1188
        exit(1);
        }
#line 1188
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1190
    regexp = g_regex_new((gchar *)"^[ ]*DisableAutoSpawn", (GRegexCompileFlags )2,
                         (GRegexMatchFlags )0, (GError **)((void *)0));
#line 1193
    result = g_regex_match(regexp, config_contents, (GRegexMatchFlags )0, (GMatchInfo **)((void *)0));
    }
#line 1194
    if (result) {
      {
#line 1195
      MSG(- 1, "Autospawn requested but disabled in configuration");
#line 1197
      exit(1);
      }
    }
    {
#line 1199
    g_free(config_contents);
#line 1200
    g_regex_unref(regexp);
#line 1201
    MSG(2, "Starting Speech Dispatcher due to auto-spawn");
    }
  }
  {
#line 1204
  speechd_init();
#line 1208
  __cil_tmp36 = strcmp((char const   *)SpeechdOptions.socket_path, "default");
  }
#line 1208
  if (! __cil_tmp36) {
    {
#line 1212
    socket_filename = g_string_new((gchar *)"\320\351b\200\332U");
    }
#line 1213
    if (SpeechdOptions.runtime_speechd_dir) {
      {
#line 1214
      g_string_printf(socket_filename, (gchar *)"%s/speechd.sock", SpeechdOptions.runtime_speechd_dir);
      }
    } else {
      {
#line 1217
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1217
        fatal_error();
#line 1217
        MSG(- 1, "Fatal error [%s:%d]:Socket name file not set and user has no runtime directory",
            "./src/server/speechd.c", 1217);
#line 1217
        exit(1);
        }
#line 1217
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1220
    g_free(SpeechdOptions.socket_path);
#line 1221
    SpeechdOptions.socket_path = g_strdup(socket_filename->str);
#line 1222
    g_string_free(socket_filename, 1);
    }
  }
#line 1228
  if (SpeechdOptions.spawn) {
#line 1229
    if (spawn_communication_method) {
      {
#line 1230
      __cil_tmp40 = strcmp((char const   *)spawn_communication_method, (char const   *)SpeechdOptions.communication_method);
      }
#line 1230
      if (__cil_tmp40) {
        {
#line 1233
        MSG(- 1, "Autospawn failed: Mismatch in communication methods. Client requests %s, most probably due to its configuration or the value of the SPEECHD_ADDRESS environment variable, but the server is configured to provide the %s method.",
            spawn_communication_method, SpeechdOptions.communication_method);
#line 1240
        exit(1);
        }
      } else {
        {
#line 1242
        __cil_tmp41 = strcmp((char const   *)SpeechdOptions.communication_method,
                             "inet_socket");
        }
#line 1242
        if (! __cil_tmp41) {
#line 1246
          if (spawn_port != 0) {
#line 1247
            if (spawn_port != SpeechdOptions.port) {
              {
#line 1249
              MSG(- 1, "Autospawn failed: Mismatch in port numbers. Server is configured to use the inet_socket method on the port %d while the client requests port %d, most probably due to its configuration or the value of the SPEECHD_ADDRESS environment variable.",
                  SpeechdOptions.port, spawn_port);
#line 1257
              exit(1);
              }
            }
          }
        } else {
          {
#line 1259
          __cil_tmp42 = strcmp((char const   *)SpeechdOptions.communication_method,
                               "unix_socket");
          }
#line 1259
          if (! __cil_tmp42) {
#line 1263
            if (spawn_socket_path) {
              {
#line 1264
              __cil_tmp43 = strcmp((char const   *)spawn_socket_path, (char const   *)SpeechdOptions.socket_path);
              }
#line 1264
              if (__cil_tmp43) {
                {
#line 1268
                MSG(- 1, "Autospawn failed: Mismatch in socket names. The server is configured to provide a socket interface in %s, but the client requests a different path: %s. This is most probably due to the client application configuration or the value of the SPEECHD_ADDRESS environment variable.",
                    SpeechdOptions.socket_path, spawn_socket_path);
#line 1276
                exit(1);
                }
              }
            }
          }
        }
      }
    }
    {
#line 1282
    g_free(spawn_communication_method);
#line 1283
    g_free(spawn_socket_path);
    }
  }
  {
#line 1286
  __cil_tmp45 = strcmp((char const   *)SpeechdOptions.communication_method, "inet_socket");
  }
#line 1286
  if (! __cil_tmp45) {
    {
#line 1287
    MSG(4, "Speech Dispatcher will use inet port %d", SpeechdOptions.port);
#line 1290
    server_socket = make_inet_socket(SpeechdOptions.port);
    }
  } else {
    {
#line 1291
    __cil_tmp47 = strcmp((char const   *)SpeechdOptions.communication_method, "unix_socket");
    }
#line 1291
    if (! __cil_tmp47) {
      {
#line 1293
      MSG(4, "Speech Dispatcher will use local unix socket: %s\230\001", SpeechdOptions.socket_path);
#line 1296
      __cil_tmp48 = g_file_test(SpeechdOptions.socket_path, (GFileTest )16);
      }
#line 1296
      if (__cil_tmp48) {
        {
#line 1297
        __cil_tmp49 = g_unlink(SpeechdOptions.socket_path);
        }
#line 1297
        if (__cil_tmp49 == -1) {
          {
#line 1298
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1298
            fatal_error();
#line 1298
            MSG(- 1, "Fatal error [%s:%d]:Local socket file exists but impossible to delete. Wrong permissions?",
                "./src/server/speechd.c", 1298);
#line 1298
            exit(1);
            }
#line 1298
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
      {
#line 1301
      server_socket = make_local_socket((char const   *)SpeechdOptions.socket_path);
      }
    } else {
      {
#line 1303
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1303
        fatal_error();
#line 1303
        MSG(- 1, "Fatal error [%s:%d]:Unknown communication method", "./src/server/speechd.c",
            1303);
#line 1303
        exit(1);
        }
#line 1303
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1307
  if ((unsigned int )spd_mode == 0U) {
    {
#line 1308
    __cil_tmp51 = daemon(0, 0);
    }
#line 1308
    if (__cil_tmp51) {
      {
#line 1309
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1309
        fatal_error();
#line 1309
        MSG(- 1, "Fatal error [%s:%d]:Can\'t fork child process\323\001 ", "./src/server/speechd.c",
            1309);
#line 1309
        exit(1);
        }
#line 1309
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 1312
    unlink((char const   *)SpeechdOptions.pid_file);
#line 1313
    __cil_tmp52 = create_pid_file();
    }
#line 1313
    if (__cil_tmp52 == -1) {
#line 1314
      return (- 1);
    }
  }
  {
#line 1318
  __cil_tmp53 = g_main_context_default();
#line 1318
  __cil_tmp54 = g_main_loop_new(__cil_tmp53, 0);
#line 1318
  main_loop = __cil_tmp54;
#line 1319
  g_unix_signal_add(2, & speechd_quit, (void *)0);
#line 1320
  g_unix_signal_add(15, & speechd_quit, (void *)0);
#line 1321
  g_unix_signal_add(1, & speechd_load_configuration, (void *)0);
#line 1322
  g_unix_signal_add(10, & speechd_reload_dead_modules, (void *)0);
#line 1323
  signal(13, (__sighandler_t )1);
#line 1325
  MSG(4, "Creating new thread for speak()");
#line 1326
  ret = pthread_create(& speak_thread, (pthread_attr_t *)((void *)0), & speak, (void *)0);
  }
#line 1327
  if (ret != 0) {
    {
#line 1328
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1328
      fatal_error();
#line 1328
      MSG(- 1, "Fatal error [%s:%d]:Speak thread failed!\n", "./src/server/speechd.c",
          1328);
#line 1328
      exit(1);
      }
#line 1328
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1331
  ret = module_speak_queue_init(SpeechdOptions.max_queue_size, & status);
  }
#line 1332
  if (ret != 0) {
    {
#line 1333
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1333
      fatal_error();
#line 1333
      MSG(- 1, "Fatal error [%s:%d]:Speak queue thread failed: %s!\n", "./src/server/speechd.c",
          1333, status);
#line 1333
      exit(1);
      }
#line 1333
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 1335
  SpeechdStatus.max_fd = server_socket;
#line 1337
  g_unix_fd_add(server_socket, (GIOCondition )1, & server_process_incoming, (void *)0);
#line 1341
  MSG(1, "Speech Dispatcher started and waiting for clients ...");
#line 1343
  check_client_count();
#line 1345
  g_main_loop_run(main_loop);
#line 1347
  MSG(1, "Terminating...");
#line 1349
  MSG(2, "Closing open connections...");
#line 1351
  g_hash_table_foreach_remove(fd_settings, & speechd_client_terminate, (void *)0);
#line 1353
  g_hash_table_destroy(fd_settings);
#line 1355
  MSG(4, "Closing speak() thread...");
#line 1356
  ret = pthread_cancel(speak_thread);
  }
#line 1357
  if (ret != 0) {
    {
#line 1358
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 1358
      fatal_error();
#line 1358
      MSG(- 1, "Fatal error [%s:%d]:Speak thread failed to cancel!\n", "./src/server/speechd.c",
          1358);
#line 1358
      exit(1);
      }
#line 1358
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1360
  ret = pthread_join(speak_thread, (void **)((void *)0));
  }
#line 1361
  if (ret != 0) {
    {
#line 1362
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1362
      fatal_error();
#line 1362
      MSG(- 1, "Fatal error [%s:%d]:Speak thread failed to join!\n", "./src/server/speechd.c",
          1362);
#line 1362
      exit(1);
      }
#line 1362
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 1364
  MSG(4, "Closing play() thread...\220");
#line 1365
  module_speak_queue_terminate();
#line 1367
  MSG(2, "Closing open output modules...");
#line 1369
  g_list_foreach(output_modules, & speechd_modules_terminate, (void *)0);
#line 1370
  g_list_free(output_modules);
#line 1372
  MSG(2, "Closing server connection...");
#line 1373
  __cil_tmp60 = close(server_socket);
  }
#line 1373
  if (__cil_tmp60 == -1) {
    {
#line 1374
    __cil_tmp61 = __errno_location();
#line 1374
    __cil_tmp62 = strerror(*__cil_tmp61);
#line 1374
    MSG(2, "close() failed: %s", __cil_tmp62);
    }
  }
  {
#line 1376
  MSG(4, "Removing pid file");
#line 1377
  destroy_pid_file();
#line 1379
  fflush((FILE *)((void *)0));
#line 1381
  g_main_loop_unref(main_loop);
#line 1382
  main_loop = (GMainLoop *)((void *)0);
#line 1384
  MSG(2, "Speech Dispatcher terminated correctly");
#line 1386
  exit(0);
  }
}
}
#line 1389 "/root/patron-artifact/pkg/i_files/speech-dispatcher-ibmtts_tmp/speech-dispatcher-contrib-0.11.1/src/server/speechd.c"
void check_locked(pthread_mutex_t *lock ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 1391
  __cil_tmp2 = pthread_mutex_trylock(lock);
  }
#line 1391
  if (__cil_tmp2 == 0) {
    {
#line 1392
    MSG(1, "CRITICAL ERROR: Not locked but accessing structure data!\220");
#line 1394
    fprintf(stderr, "WARNING! WARNING! MUTEX CHECK FAILED!\n");
#line 1395
    fflush(stderr);
#line 1396
    exit(0);
    }
  }
  return;
}
}
