/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 63 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_6 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_6 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_7 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_7 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_8 {
   unsigned long long __value64 ;
   struct __anonstruct_9 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_8 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_10 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrierattr_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__20 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum__21 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h"
enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048
} ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 193 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[118] ;
   unsigned long __ss_align ;
};
#line 202
enum __anonenum__22 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824
} ;
#line 259 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 277 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 334
enum __anonenum__23 {
    SCM_RIGHTS = 1
} ;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct_24 {
   unsigned long fds_bits[16] ;
};
#line 27 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct_24 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct_25 {
   int val[2] ;
};
#line 81 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct_25 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 363 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h"
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2
} ;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_opts {
   struct in_addr ip_dst ;
   char ip_opts[40] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 158 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_ETHERNET = 143,
    IPPROTO_RAW = 255,
    IPPROTO_MPTCP = 262,
    IPPROTO_MAX = 263
} ;
#line 103
enum __anonenum__28 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135
} ;
#line 123 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 126
enum __anonenum__29 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000
} ;
#line 221 "/usr/include/netinet/in.h"
union __anonunion_30 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 219 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_30 __in6_u ;
};
#line 245 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 260 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 272 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 281 "/usr/include/netinet/in.h"
struct ip_mreq_source {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
   struct in_addr imr_sourceaddr ;
};
#line 296 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 308 "/usr/include/netinet/in.h"
struct group_req {
   uint32_t gr_interface ;
   struct sockaddr_storage gr_group ;
};
#line 317 "/usr/include/netinet/in.h"
struct group_source_req {
   uint32_t gsr_interface ;
   struct sockaddr_storage gsr_group ;
   struct sockaddr_storage gsr_source ;
};
#line 331 "/usr/include/netinet/in.h"
struct ip_msfilter {
   struct in_addr imsf_multiaddr ;
   struct in_addr imsf_interface ;
   uint32_t imsf_fmode ;
   uint32_t imsf_numsrc ;
   struct in_addr imsf_slist[1] ;
};
#line 352 "/usr/include/netinet/in.h"
struct group_filter {
   uint32_t gf_interface ;
   struct sockaddr_storage gf_group ;
   uint32_t gf_fmode ;
   uint32_t gf_numsrc ;
   struct sockaddr_storage gf_slist[1] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 114
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 130 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 143 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_31 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_31 cpu_set_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__32 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__33 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 69
enum __anonenum__34 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__35 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__36 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__37 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__38 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__39 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__40 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__41 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_42 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_42 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_46 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_47 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_48 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_51 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_50 {
   struct __anonstruct_51 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_49 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_50 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_52 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_53 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_44 {
   int _pad[28] ;
   struct __anonstruct_45 _kill ;
   struct __anonstruct_46 _timer ;
   struct __anonstruct_47 _rt ;
   struct __anonstruct_48 _sigchld ;
   struct __anonstruct_49 _sigfault ;
   struct __anonstruct_52 _sigpoll ;
   struct __anonstruct_53 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_43 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_44 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_43 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__55 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__56 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__57 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__58 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 176
enum __anonenum__59 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__60 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_62 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_61 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_62 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_61 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_64 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_64 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_65 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_65  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_66 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_66 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_67 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_67 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 310 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef u_int8_t u8_t;
#line 311 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef u_int16_t u16_t;
#line 312 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef u_int32_t u32_t;
#line 313 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef u_int64_t u64_t;
#line 315 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef int16_t s16_t;
#line 316 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef int32_t s32_t;
#line 317 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef int64_t s64_t;
#line 381 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef u32_t frames_t;
#line 382 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef int sockfd;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69 {
    EFD_SEMAPHORE = 1,
    EFD_CLOEXEC = 524288,
    EFD_NONBLOCK = 2048
} ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
typedef uint64_t eventfd_t;
#line 440 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
enum __anonenum__70 {
    lERROR = 0,
    lWARN = 1,
    lINFO = 2,
    lDEBUG = 3,
    lSDEBUG = 4
} ;
#line 440 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__70 log_level;
#line 452
enum __anonenum__71 {
    EVENT_TIMEOUT = 0,
    EVENT_READ = 1,
    EVENT_WAKE = 2
} ;
#line 452 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__71 event_type;
#line 491 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
struct buffer {
   u8_t *buf ;
   u8_t *readp ;
   u8_t *writep ;
   u8_t *wrap ;
   size_t size ;
   size_t base_size ;
   pthread_mutex_t mutex ;
};
#line 521
enum __anonenum__72 {
    STOPPED = 0,
    DISCONNECT = 1,
    STREAMING_WAIT = 2,
    STREAMING_BUFFERING = 3,
    STREAMING_FILE = 4,
    STREAMING_HTTP = 5,
    SEND_HEADERS = 6,
    RECV_HEADERS = 7
} ;
#line 522 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__72 stream_state;
#line 523
enum __anonenum__73 {
    DISCONNECT_OK = 0,
    LOCAL_DISCONNECT = 1,
    REMOTE_DISCONNECT = 2,
    UNREACHABLE = 3,
    TIMEOUT = 4
} ;
#line 523 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__73 disconnect_code;
#line 525 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
struct streamstate {
   stream_state state ;
   disconnect_code disconnect ;
   char *header ;
   size_t header_len ;
   int sent_headers ;
   int cont_wait ;
   u64_t bytes ;
   unsigned int threshold ;
   u32_t meta_interval ;
   u32_t meta_next ;
   u32_t meta_left ;
   int meta_send ;
};
#line 547
enum __anonenum__74 {
    DECODE_STOPPED = 0,
    DECODE_READY = 1,
    DECODE_RUNNING = 2,
    DECODE_COMPLETE = 3,
    DECODE_ERROR = 4
} ;
#line 547 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__74 decode_state;
#line 549 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
struct decodestate {
   decode_state state ;
   int new_stream ;
   pthread_mutex_t mutex ;
};
#line 569 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
struct codec {
   char id ;
   char *types ;
   unsigned int min_read_bytes ;
   unsigned int min_space ;
   void (*open)(u8_t  , u8_t  , u8_t  , u8_t  ) ;
   void (*close)(void) ;
   decode_state (*decode)(void) ;
};
#line 604
enum __anonenum__75 {
    OUTPUT_OFF = -1,
    OUTPUT_STOPPED = 0,
    OUTPUT_BUFFER = 1,
    OUTPUT_RUNNING = 2,
    OUTPUT_PAUSE_FRAMES = 3,
    OUTPUT_SKIP_FRAMES = 4,
    OUTPUT_START_AT = 5
} ;
#line 605 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__75 output_state;
#line 611
enum __anonenum__76 {
    S32_LE = 0,
    S24_LE = 1,
    S24_3LE = 2,
    S16_LE = 3
} ;
#line 611 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__76 output_format;
#line 614
enum __anonenum__77 {
    FADE_INACTIVE = 0,
    FADE_DUE = 1,
    FADE_ACTIVE = 2
} ;
#line 614 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__77 fade_state;
#line 615
enum __anonenum__78 {
    FADE_UP = 1,
    FADE_DOWN = 2,
    FADE_CROSS = 3
} ;
#line 615 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__78 fade_dir;
#line 616
enum __anonenum__79 {
    FADE_NONE = 0,
    FADE_CROSSFADE = 1,
    FADE_IN = 2,
    FADE_OUT = 3,
    FADE_INOUT = 4
} ;
#line 616 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
typedef enum __anonenum__79 fade_mode;
#line 650 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
union __anonunion_80 {
   u32_t pause_frames ;
   u32_t skip_frames ;
   u32_t start_at ;
};
#line 623 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
struct outputstate {
   output_state state ;
   output_format format ;
   u8_t channels ;
   char const   *device ;
   unsigned int buffer ;
   unsigned int period ;
   int track_started ;
   int (*write_cb)(frames_t  , int  , s32_t  , s32_t  , u8_t  , s32_t  , s32_t  ,
                   s32_t ** ) ;
   unsigned int start_frames ;
   unsigned int frames_played ;
   unsigned int frames_played_dmp ;
   unsigned int current_sample_rate ;
   unsigned int supported_rates[20] ;
   unsigned int default_sample_rate ;
   int error_opening ;
   unsigned int device_frames ;
   u32_t updated ;
   u32_t track_start_time ;
   u32_t current_replay_gain ;
   union __anonunion_80  ;
   u32_t pause_frames ;
   u32_t skip_frames ;
   u32_t start_at ;
   unsigned int next_sample_rate ;
   u8_t *track_start ;
   u32_t gainL ;
   u32_t gainR ;
   int invert ;
   u32_t next_replay_gain ;
   unsigned int threshold ;
   fade_state fade ;
   u8_t *fade_start ;
   u8_t *fade_end ;
   fade_dir fade_dir ;
   fade_mode fade_mode ;
   unsigned int fade_secs ;
   unsigned int rate_delay ;
   int delay_active ;
   u32_t stop_time ;
   u32_t idle_to ;
};
#line 136 "/usr/include/neaacdec.h"
typedef void *NeAACDecHandle;
#line 138 "/usr/include/neaacdec.h"
struct mp4AudioSpecificConfig {
   unsigned char objectTypeIndex ;
   unsigned char samplingFrequencyIndex ;
   unsigned long samplingFrequency ;
   unsigned char channelsConfiguration ;
   unsigned char frameLengthFlag ;
   unsigned char dependsOnCoreCoder ;
   unsigned short coreCoderDelay ;
   unsigned char extensionFlag ;
   unsigned char aacSectionDataResilienceFlag ;
   unsigned char aacScalefactorDataResilienceFlag ;
   unsigned char aacSpectralDataResilienceFlag ;
   unsigned char epConfig ;
   char sbr_present_flag ;
   char forceUpSampling ;
   char downSampledSBR ;
};
#line 159 "/usr/include/neaacdec.h"
typedef struct mp4AudioSpecificConfig mp4AudioSpecificConfig;
#line 161 "/usr/include/neaacdec.h"
struct NeAACDecConfiguration {
   unsigned char defObjectType ;
   unsigned long defSampleRate ;
   unsigned char outputFormat ;
   unsigned char downMatrix ;
   unsigned char useOldADTSFormat ;
   unsigned char dontUpSampleImplicitSBR ;
};
#line 169 "/usr/include/neaacdec.h"
typedef struct NeAACDecConfiguration NeAACDecConfiguration;
#line 169 "/usr/include/neaacdec.h"
typedef struct NeAACDecConfiguration *NeAACDecConfigurationPtr;
#line 171 "/usr/include/neaacdec.h"
struct NeAACDecFrameInfo {
   unsigned long bytesconsumed ;
   unsigned long samples ;
   unsigned char channels ;
   unsigned char error ;
   unsigned long samplerate ;
   unsigned char sbr ;
   unsigned char object_type ;
   unsigned char header_type ;
   unsigned char num_front_channels ;
   unsigned char num_side_channels ;
   unsigned char num_back_channels ;
   unsigned char num_lfe_channels ;
   unsigned char channel_position[64] ;
   unsigned char ps ;
};
#line 197 "/usr/include/neaacdec.h"
typedef struct NeAACDecFrameInfo NeAACDecFrameInfo;
#line 34 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
struct chunk_table {
   u32_t sample ;
   u32_t offset ;
};
#line 38 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
struct faad {
   NeAACDecHandle hAac ;
   u8_t type ;
   u32_t consume ;
   u32_t pos ;
   u32_t sample ;
   u32_t nextchunk ;
   void *stsc ;
   u32_t skip ;
   u64_t samples ;
   u64_t sttssamples ;
   int empty ;
   struct chunk_table *chunkinfo ;
   NeAACDecConfigurationPtr (*NeAACDecGetCurrentConfiguration)(NeAACDecHandle  ) ;
   unsigned char (*NeAACDecSetConfiguration)(NeAACDecHandle  , NeAACDecConfigurationPtr  ) ;
   NeAACDecHandle (*NeAACDecOpen)(void) ;
   void (*NeAACDecClose)(NeAACDecHandle  ) ;
   long (*NeAACDecInit)(NeAACDecHandle  , unsigned char * , unsigned long  , unsigned long * ,
                        unsigned char * ) ;
   char (*NeAACDecInit2)(NeAACDecHandle  , unsigned char * , unsigned long  , unsigned long * ,
                         unsigned char * ) ;
   void *(*NeAACDecDecode)(NeAACDecHandle  , NeAACDecFrameInfo * , unsigned char * ,
                           unsigned long  ) ;
   char *(*NeAACDecGetErrorMessage)(unsigned char  ) ;
};
#line 74
struct processstate ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___0 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__20___0 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum__21___0 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___0 {
    MSG_OOB___0 = 1,
    MSG_PEEK___0 = 2,
    MSG_DONTROUTE___0 = 4,
    MSG_CTRUNC___0 = 8,
    MSG_PROXY___0 = 16,
    MSG_TRUNC___0 = 32,
    MSG_DONTWAIT___0 = 64,
    MSG_EOR___0 = 128,
    MSG_WAITALL___0 = 256,
    MSG_FIN___0 = 512,
    MSG_SYN___0 = 1024,
    MSG_CONFIRM___0 = 2048,
    MSG_RST___0 = 4096,
    MSG_ERRQUEUE___0 = 8192,
    MSG_NOSIGNAL___0 = 16384,
    MSG_MORE___0 = 32768,
    MSG_WAITFORONE___0 = 65536,
    MSG_BATCH___0 = 262144,
    MSG_ZEROCOPY___0 = 67108864,
    MSG_FASTOPEN___0 = 536870912,
    MSG_CMSG_CLOEXEC___0 = 1073741824
} ;
#line 334
enum __anonenum__23___0 {
    SCM_RIGHTS___0 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___0 {
    SHUT_RD___0 = 0,
    SHUT_WR___0 = 1,
    SHUT_RDWR___0 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___0 {
    IPPROTO_IP___0 = 0,
    IPPROTO_ICMP___0 = 1,
    IPPROTO_IGMP___0 = 2,
    IPPROTO_IPIP___0 = 4,
    IPPROTO_TCP___0 = 6,
    IPPROTO_EGP___0 = 8,
    IPPROTO_PUP___0 = 12,
    IPPROTO_UDP___0 = 17,
    IPPROTO_IDP___0 = 22,
    IPPROTO_TP___0 = 29,
    IPPROTO_DCCP___0 = 33,
    IPPROTO_IPV6___0 = 41,
    IPPROTO_RSVP___0 = 46,
    IPPROTO_GRE___0 = 47,
    IPPROTO_ESP___0 = 50,
    IPPROTO_AH___0 = 51,
    IPPROTO_MTP___0 = 92,
    IPPROTO_BEETPH___0 = 94,
    IPPROTO_ENCAP___0 = 98,
    IPPROTO_PIM___0 = 103,
    IPPROTO_COMP___0 = 108,
    IPPROTO_SCTP___0 = 132,
    IPPROTO_UDPLITE___0 = 136,
    IPPROTO_MPLS___0 = 137,
    IPPROTO_ETHERNET___0 = 143,
    IPPROTO_RAW___0 = 255,
    IPPROTO_MPTCP___0 = 262,
    IPPROTO_MAX___0 = 263
} ;
#line 103
enum __anonenum__28___0 {
    IPPROTO_HOPOPTS___0 = 0,
    IPPROTO_ROUTING___0 = 43,
    IPPROTO_FRAGMENT___0 = 44,
    IPPROTO_ICMPV6___0 = 58,
    IPPROTO_NONE___0 = 59,
    IPPROTO_DSTOPTS___0 = 60,
    IPPROTO_MH___0 = 135
} ;
#line 126
enum __anonenum__29___0 {
    IPPORT_ECHO___0 = 7,
    IPPORT_DISCARD___0 = 9,
    IPPORT_SYSTAT___0 = 11,
    IPPORT_DAYTIME___0 = 13,
    IPPORT_NETSTAT___0 = 15,
    IPPORT_FTP___0 = 21,
    IPPORT_TELNET___0 = 23,
    IPPORT_SMTP___0 = 25,
    IPPORT_TIMESERVER___0 = 37,
    IPPORT_NAMESERVER___0 = 42,
    IPPORT_WHOIS___0 = 43,
    IPPORT_MTP___0 = 57,
    IPPORT_TFTP___0 = 69,
    IPPORT_RJE___0 = 77,
    IPPORT_FINGER___0 = 79,
    IPPORT_TTYLINK___0 = 87,
    IPPORT_SUPDUP___0 = 95,
    IPPORT_EXECSERVER___0 = 512,
    IPPORT_LOGINSERVER___0 = 513,
    IPPORT_CMDSERVER___0 = 514,
    IPPORT_EFSSERVER___0 = 520,
    IPPORT_BIFFUDP___0 = 512,
    IPPORT_WHOSERVER___0 = 513,
    IPPORT_ROUTESERVER___0 = 520,
    IPPORT_RESERVED___0 = 1024,
    IPPORT_USERRESERVED___0 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___0 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum__33___0 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 69
enum __anonenum__34___0 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum__35___0 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum__36___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum__37___0 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum__38___0 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum__39___0 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum__40___0 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum__41___0 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___0 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__55___0 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__56___0 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__57___0 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__58___0 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 176
enum __anonenum__59___0 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__60___0 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___0 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___0 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___0 {
    EFD_SEMAPHORE___0 = 1,
    EFD_CLOEXEC___0 = 524288,
    EFD_NONBLOCK___0 = 2048
} ;
#line 43 "/usr/include/fmt123.h"
enum mpg123_enc_enum {
    MPG123_ENC_8 = 15,
    MPG123_ENC_16 = 64,
    MPG123_ENC_24 = 16384,
    MPG123_ENC_32 = 256,
    MPG123_ENC_SIGNED = 128,
    MPG123_ENC_FLOAT = 3584,
    MPG123_ENC_SIGNED_16 = 208,
    MPG123_ENC_UNSIGNED_16 = 96,
    MPG123_ENC_UNSIGNED_8 = 1,
    MPG123_ENC_SIGNED_8 = 130,
    MPG123_ENC_ULAW_8 = 4,
    MPG123_ENC_ALAW_8 = 8,
    MPG123_ENC_SIGNED_32 = 4480,
    MPG123_ENC_UNSIGNED_32 = 8448,
    MPG123_ENC_SIGNED_24 = 20608,
    MPG123_ENC_UNSIGNED_24 = 24576,
    MPG123_ENC_FLOAT_32 = 512,
    MPG123_ENC_FLOAT_64 = 1024,
    MPG123_ENC_ANY = 30719
} ;
#line 147 "/usr/include/fmt123.h"
struct mpg123_fmt {
   long rate ;
   int channels ;
   int encoding ;
};
#line 87 "/usr/include/mpg123.h"
typedef ssize_t mpg123_ssize_t;
#line 170
struct mpg123_handle_struct ;
#line 175 "/usr/include/mpg123.h"
typedef struct mpg123_handle_struct mpg123_handle;
#line 222
enum mpg123_parms {
    MPG123_VERBOSE = 0,
    MPG123_FLAGS = 1,
    MPG123_ADD_FLAGS = 2,
    MPG123_FORCE_RATE = 3,
    MPG123_DOWN_SAMPLE = 4,
    MPG123_RVA = 5,
    MPG123_DOWNSPEED = 6,
    MPG123_UPSPEED = 7,
    MPG123_START_FRAME = 8,
    MPG123_DECODE_FRAMES = 9,
    MPG123_ICY_INTERVAL = 10,
    MPG123_OUTSCALE = 11,
    MPG123_TIMEOUT = 12,
    MPG123_REMOVE_FLAGS = 13,
    MPG123_RESYNC_LIMIT = 14,
    MPG123_INDEX_SIZE = 15,
    MPG123_PREFRAMES = 16,
    MPG123_FEEDPOOL = 17,
    MPG123_FEEDBUFFER = 18,
    MPG123_FREEFORMAT_SIZE = 19
} ;
#line 252
enum mpg123_param_flags {
    MPG123_FORCE_MONO = 7,
    MPG123_MONO_LEFT = 1,
    MPG123_MONO_RIGHT = 2,
    MPG123_MONO_MIX = 4,
    MPG123_FORCE_STEREO = 8,
    MPG123_FORCE_8BIT = 16,
    MPG123_QUIET = 32,
    MPG123_GAPLESS = 64,
    MPG123_NO_RESYNC = 128,
    MPG123_SEEKBUFFER = 256,
    MPG123_FUZZY = 512,
    MPG123_FORCE_FLOAT = 1024,
    MPG123_PLAIN_ID3TEXT = 2048,
    MPG123_IGNORE_STREAMLENGTH = 4096,
    MPG123_SKIP_ID3V2 = 8192,
    MPG123_IGNORE_INFOFRAME = 16384,
    MPG123_AUTO_RESAMPLE = 32768,
    MPG123_PICTURE = 65536,
    MPG123_NO_PEEK_END = 131072,
    MPG123_FORCE_SEEKABLE = 262144,
    MPG123_STORE_RAW_ID3 = 524288,
    MPG123_FORCE_ENDIAN = 1048576,
    MPG123_BIG_ENDIAN = 2097152,
    MPG123_NO_READAHEAD = 4194304,
    MPG123_FLOAT_FALLBACK = 8388608,
    MPG123_NO_FRANKENSTEIN = 16777216
} ;
#line 313
enum mpg123_param_rva {
    MPG123_RVA_OFF = 0,
    MPG123_RVA_MIX = 1,
    MPG123_RVA_ALBUM = 2,
    MPG123_RVA_MAX = 2
} ;
#line 382
enum mpg123_feature_set {
    MPG123_FEATURE_ABI_UTF8OPEN = 0,
    MPG123_FEATURE_OUTPUT_8BIT = 1,
    MPG123_FEATURE_OUTPUT_16BIT = 2,
    MPG123_FEATURE_OUTPUT_32BIT = 3,
    MPG123_FEATURE_INDEX = 4,
    MPG123_FEATURE_PARSE_ID3V2 = 5,
    MPG123_FEATURE_DECODE_LAYER1 = 6,
    MPG123_FEATURE_DECODE_LAYER2 = 7,
    MPG123_FEATURE_DECODE_LAYER3 = 8,
    MPG123_FEATURE_DECODE_ACCURATE = 9,
    MPG123_FEATURE_DECODE_DOWNSAMPLE = 10,
    MPG123_FEATURE_DECODE_NTOM = 11,
    MPG123_FEATURE_PARSE_ICY = 12,
    MPG123_FEATURE_TIMEOUT_READ = 13,
    MPG123_FEATURE_EQUALIZER = 14,
    MPG123_FEATURE_MOREINFO = 15,
    MPG123_FEATURE_OUTPUT_FLOAT32 = 16,
    MPG123_FEATURE_OUTPUT_FLOAT64 = 17
} ;
#line 461
enum mpg123_errors {
    MPG123_DONE = -12,
    MPG123_NEW_FORMAT = -11,
    MPG123_NEED_MORE = -10,
    MPG123_ERR = -1,
    MPG123_OK = 0,
    MPG123_BAD_OUTFORMAT = 1,
    MPG123_BAD_CHANNEL = 2,
    MPG123_BAD_RATE = 3,
    MPG123_ERR_16TO8TABLE = 4,
    MPG123_BAD_PARAM = 5,
    MPG123_BAD_BUFFER = 6,
    MPG123_OUT_OF_MEM = 7,
    MPG123_NOT_INITIALIZED = 8,
    MPG123_BAD_DECODER = 9,
    MPG123_BAD_HANDLE = 10,
    MPG123_NO_BUFFERS = 11,
    MPG123_BAD_RVA = 12,
    MPG123_NO_GAPLESS = 13,
    MPG123_NO_SPACE = 14,
    MPG123_BAD_TYPES = 15,
    MPG123_BAD_BAND = 16,
    MPG123_ERR_NULL = 17,
    MPG123_ERR_READER = 18,
    MPG123_NO_SEEK_FROM_END = 19,
    MPG123_BAD_WHENCE = 20,
    MPG123_NO_TIMEOUT = 21,
    MPG123_BAD_FILE = 22,
    MPG123_NO_SEEK = 23,
    MPG123_NO_READER = 24,
    MPG123_BAD_PARS = 25,
    MPG123_BAD_INDEX_PAR = 26,
    MPG123_OUT_OF_SYNC = 27,
    MPG123_RESYNC_FAIL = 28,
    MPG123_NO_8BIT = 29,
    MPG123_BAD_ALIGN = 30,
    MPG123_NULL_BUFFER = 31,
    MPG123_NO_RELSEEK = 32,
    MPG123_NULL_POINTER = 33,
    MPG123_BAD_KEY = 34,
    MPG123_NO_INDEX = 35,
    MPG123_INDEX_FAIL = 36,
    MPG123_BAD_DECODER_SETUP = 37,
    MPG123_MISSING_FEATURE = 38,
    MPG123_BAD_VALUE = 39,
    MPG123_LSEEK_FAILED = 40,
    MPG123_BAD_CUSTOM_IO = 41,
    MPG123_LFS_OVERFLOW = 42,
    MPG123_INT_OVERFLOW = 43,
    MPG123_BAD_FLOAT = 44
} ;
#line 604
enum mpg123_channelcount {
    MPG123_MONO = 1,
    MPG123_STEREO = 2
} ;
#line 1057
enum mpg123_channels {
    MPG123_LEFT = 1,
    MPG123_RIGHT = 2,
    MPG123_LR = 3
} ;
#line 1167
enum mpg123_vbr {
    MPG123_CBR = 0,
    MPG123_VBR = 1,
    MPG123_ABR = 2
} ;
#line 1174
enum mpg123_version {
    MPG123_1_0 = 0,
    MPG123_2_0 = 1,
    MPG123_2_5 = 2
} ;
#line 1183
enum mpg123_mode {
    MPG123_M_STEREO = 0,
    MPG123_M_JOINT = 1,
    MPG123_M_DUAL = 2,
    MPG123_M_MONO = 3
} ;
#line 1192
enum mpg123_flags {
    MPG123_CRC = 1,
    MPG123_COPYRIGHT = 2,
    MPG123_PRIVATE = 4,
    MPG123_ORIGINAL = 8
} ;
#line 1218 "/usr/include/mpg123.h"
struct mpg123_frameinfo2 {
   int version ;
   int layer ;
   long rate ;
   int mode ;
   int mode_ext ;
   int framesize ;
   int flags ;
   int emphasis ;
   int bitrate ;
   int abr_rate ;
   int vbr ;
};
#line 1238 "/usr/include/mpg123.h"
struct mpg123_moreinfo {
   double xr[2][2][576] ;
   double sfb[2][2][22] ;
   double sfb_s[2][2][39] ;
   int qss[2][2] ;
   int big_values[2][2] ;
   int sub_gain[2][2][3] ;
   int scalefac_scale[2][2] ;
   int preflag[2][2] ;
   int blocktype[2][2] ;
   int mixed[2][2] ;
   int mainbits[2][2] ;
   int sfbits[2][2] ;
   int scfsi[2] ;
   int maindata ;
   int padding ;
};
#line 1356
enum mpg123_state {
    MPG123_ACCURATE = 1,
    MPG123_BUFFERFILL = 2,
    MPG123_FRANKENSTEIN = 3,
    MPG123_FRESH_DECODER = 4,
    MPG123_ENC_DELAY = 5,
    MPG123_ENC_PADDING = 6,
    MPG123_DEC_DELAY = 7
} ;
#line 1410 "/usr/include/mpg123.h"
struct __anonstruct_81 {
   char *p ;
   size_t size ;
   size_t fill ;
};
#line 1415 "/usr/include/mpg123.h"
typedef struct __anonstruct_81 mpg123_string;
#line 1541
enum mpg123_text_encoding {
    mpg123_text_unknown = 0,
    mpg123_text_utf8 = 1,
    mpg123_text_latin1 = 2,
    mpg123_text_icy = 3,
    mpg123_text_cp1252 = 4,
    mpg123_text_utf16 = 5,
    mpg123_text_utf16bom = 6,
    mpg123_text_utf16be = 7,
    mpg123_text_max = 7
} ;
#line 1561
enum mpg123_id3_enc {
    mpg123_id3_latin1 = 0,
    mpg123_id3_utf16bom = 1,
    mpg123_id3_utf16be = 2,
    mpg123_id3_utf8 = 3,
    mpg123_id3_enc_max = 3
} ;
#line 1631 "/usr/include/mpg123.h"
struct __anonstruct_82 {
   char lang[3] ;
   char id[4] ;
   mpg123_string description ;
   mpg123_string text ;
};
#line 1637 "/usr/include/mpg123.h"
typedef struct __anonstruct_82 mpg123_text;
#line 1640
enum mpg123_id3_pic_type {
    mpg123_id3_pic_other = 0,
    mpg123_id3_pic_icon = 1,
    mpg123_id3_pic_other_icon = 2,
    mpg123_id3_pic_front_cover = 3,
    mpg123_id3_pic_back_cover = 4,
    mpg123_id3_pic_leaflet = 5,
    mpg123_id3_pic_media = 6,
    mpg123_id3_pic_lead = 7,
    mpg123_id3_pic_artist = 8,
    mpg123_id3_pic_conductor = 9,
    mpg123_id3_pic_orchestra = 10,
    mpg123_id3_pic_composer = 11,
    mpg123_id3_pic_lyricist = 12,
    mpg123_id3_pic_location = 13,
    mpg123_id3_pic_recording = 14,
    mpg123_id3_pic_performance = 15,
    mpg123_id3_pic_video = 16,
    mpg123_id3_pic_fish = 17,
    mpg123_id3_pic_illustration = 18,
    mpg123_id3_pic_artist_logo = 19,
    mpg123_id3_pic_publisher_logo = 20
} ;
#line 1669 "/usr/include/mpg123.h"
struct __anonstruct_83 {
   char type ;
   mpg123_string description ;
   mpg123_string mime_type ;
   size_t size ;
   unsigned char *data ;
};
#line 1676 "/usr/include/mpg123.h"
typedef struct __anonstruct_83 mpg123_picture;
#line 1683 "/usr/include/mpg123.h"
struct __anonstruct_84 {
   unsigned char version ;
   mpg123_string *title ;
   mpg123_string *artist ;
   mpg123_string *album ;
   mpg123_string *year ;
   mpg123_string *genre ;
   mpg123_string *comment ;
   mpg123_text *comment_list ;
   size_t comments ;
   mpg123_text *text ;
   size_t texts ;
   mpg123_text *extra ;
   size_t extras ;
   mpg123_picture *picture ;
   size_t pictures ;
};
#line 1703 "/usr/include/mpg123.h"
typedef struct __anonstruct_84 mpg123_id3v2;
#line 1709 "/usr/include/mpg123.h"
struct __anonstruct_85 {
   char tag[3] ;
   char title[30] ;
   char artist[30] ;
   char album[30] ;
   char year[4] ;
   char comment[30] ;
   unsigned char genre ;
};
#line 1718 "/usr/include/mpg123.h"
typedef struct __anonstruct_85 mpg123_id3v1;
#line 1793
struct mpg123_pars_struct ;
#line 1796 "/usr/include/mpg123.h"
typedef struct mpg123_pars_struct mpg123_pars;
#line 29 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
struct mpg {
   mpg123_handle *h ;
   int use16bit ;
   int (*mpg123_init)(void) ;
   int (*mpg123_feature2)(enum mpg123_feature_set  ) ;
   void (*mpg123_rates)(long const   ** , size_t * ) ;
   int (*mpg123_format_none)(mpg123_handle * ) ;
   int (*mpg123_format)(mpg123_handle * , long  , int  , int  ) ;
   mpg123_handle *(*mpg123_new)(char const   * , int * ) ;
   void (*mpg123_delete)(mpg123_handle * ) ;
   int (*mpg123_open_feed)(mpg123_handle * ) ;
   int (*mpg123_decode)(mpg123_handle * , unsigned char const   * , size_t  , unsigned char * ,
                        size_t  , size_t * ) ;
   int (*mpg123_getformat)(mpg123_handle * , long * , int * , int * ) ;
   char const   *(*mpg123_plain_strerror)(int  ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___1 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__20___1 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum__21___1 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___1 {
    MSG_OOB___1 = 1,
    MSG_PEEK___1 = 2,
    MSG_DONTROUTE___1 = 4,
    MSG_CTRUNC___1 = 8,
    MSG_PROXY___1 = 16,
    MSG_TRUNC___1 = 32,
    MSG_DONTWAIT___1 = 64,
    MSG_EOR___1 = 128,
    MSG_WAITALL___1 = 256,
    MSG_FIN___1 = 512,
    MSG_SYN___1 = 1024,
    MSG_CONFIRM___1 = 2048,
    MSG_RST___1 = 4096,
    MSG_ERRQUEUE___1 = 8192,
    MSG_NOSIGNAL___1 = 16384,
    MSG_MORE___1 = 32768,
    MSG_WAITFORONE___1 = 65536,
    MSG_BATCH___1 = 262144,
    MSG_ZEROCOPY___1 = 67108864,
    MSG_FASTOPEN___1 = 536870912,
    MSG_CMSG_CLOEXEC___1 = 1073741824
} ;
#line 334
enum __anonenum__23___1 {
    SCM_RIGHTS___1 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___1 {
    SHUT_RD___1 = 0,
    SHUT_WR___1 = 1,
    SHUT_RDWR___1 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___1 {
    IPPROTO_IP___1 = 0,
    IPPROTO_ICMP___1 = 1,
    IPPROTO_IGMP___1 = 2,
    IPPROTO_IPIP___1 = 4,
    IPPROTO_TCP___1 = 6,
    IPPROTO_EGP___1 = 8,
    IPPROTO_PUP___1 = 12,
    IPPROTO_UDP___1 = 17,
    IPPROTO_IDP___1 = 22,
    IPPROTO_TP___1 = 29,
    IPPROTO_DCCP___1 = 33,
    IPPROTO_IPV6___1 = 41,
    IPPROTO_RSVP___1 = 46,
    IPPROTO_GRE___1 = 47,
    IPPROTO_ESP___1 = 50,
    IPPROTO_AH___1 = 51,
    IPPROTO_MTP___1 = 92,
    IPPROTO_BEETPH___1 = 94,
    IPPROTO_ENCAP___1 = 98,
    IPPROTO_PIM___1 = 103,
    IPPROTO_COMP___1 = 108,
    IPPROTO_SCTP___1 = 132,
    IPPROTO_UDPLITE___1 = 136,
    IPPROTO_MPLS___1 = 137,
    IPPROTO_ETHERNET___1 = 143,
    IPPROTO_RAW___1 = 255,
    IPPROTO_MPTCP___1 = 262,
    IPPROTO_MAX___1 = 263
} ;
#line 103
enum __anonenum__28___1 {
    IPPROTO_HOPOPTS___1 = 0,
    IPPROTO_ROUTING___1 = 43,
    IPPROTO_FRAGMENT___1 = 44,
    IPPROTO_ICMPV6___1 = 58,
    IPPROTO_NONE___1 = 59,
    IPPROTO_DSTOPTS___1 = 60,
    IPPROTO_MH___1 = 135
} ;
#line 126
enum __anonenum__29___1 {
    IPPORT_ECHO___1 = 7,
    IPPORT_DISCARD___1 = 9,
    IPPORT_SYSTAT___1 = 11,
    IPPORT_DAYTIME___1 = 13,
    IPPORT_NETSTAT___1 = 15,
    IPPORT_FTP___1 = 21,
    IPPORT_TELNET___1 = 23,
    IPPORT_SMTP___1 = 25,
    IPPORT_TIMESERVER___1 = 37,
    IPPORT_NAMESERVER___1 = 42,
    IPPORT_WHOIS___1 = 43,
    IPPORT_MTP___1 = 57,
    IPPORT_TFTP___1 = 69,
    IPPORT_RJE___1 = 77,
    IPPORT_FINGER___1 = 79,
    IPPORT_TTYLINK___1 = 87,
    IPPORT_SUPDUP___1 = 95,
    IPPORT_EXECSERVER___1 = 512,
    IPPORT_LOGINSERVER___1 = 513,
    IPPORT_CMDSERVER___1 = 514,
    IPPORT_EFSSERVER___1 = 520,
    IPPORT_BIFFUDP___1 = 512,
    IPPORT_WHOSERVER___1 = 513,
    IPPORT_ROUTESERVER___1 = 520,
    IPPORT_RESERVED___1 = 1024,
    IPPORT_USERRESERVED___1 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___1 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 47
enum __anonenum__33___1 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 69
enum __anonenum__34___1 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 81
enum __anonenum__35___1 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 104
enum __anonenum__36___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 124
enum __anonenum__37___1 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 134
enum __anonenum__38___1 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 144
enum __anonenum__39___1 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 168
enum __anonenum__40___1 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 175
enum __anonenum__41___1 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___1 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__55___1 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__56___1 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__57___1 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__58___1 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 176
enum __anonenum__59___1 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__60___1 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___1 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___1 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___1 {
    EFD_SEMAPHORE___1 = 1,
    EFD_CLOEXEC___1 = 524288,
    EFD_NONBLOCK___1 = 2048
} ;
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_86 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_86 max_align_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_87 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_87 imaxdiv_t;
#line 19 "/usr/include/ogg/config_types.h"
typedef int16_t ogg_int16_t;
#line 20 "/usr/include/ogg/config_types.h"
typedef uint16_t ogg_uint16_t;
#line 21 "/usr/include/ogg/config_types.h"
typedef int32_t ogg_int32_t;
#line 22 "/usr/include/ogg/config_types.h"
typedef uint32_t ogg_uint32_t;
#line 23 "/usr/include/ogg/config_types.h"
typedef int64_t ogg_int64_t;
#line 24 "/usr/include/ogg/config_types.h"
typedef uint64_t ogg_uint64_t;
#line 26 "/usr/include/ogg/ogg.h"
struct __anonstruct_88 {
   void *iov_base ;
   size_t iov_len ;
};
#line 29 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_88 ogg_iovec_t;
#line 31 "/usr/include/ogg/ogg.h"
struct __anonstruct_89 {
   long endbyte ;
   int endbit ;
   unsigned char *buffer ;
   unsigned char *ptr ;
   long storage ;
};
#line 38 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_89 oggpack_buffer;
#line 42 "/usr/include/ogg/ogg.h"
struct __anonstruct_90 {
   unsigned char *header ;
   long header_len ;
   unsigned char *body ;
   long body_len ;
};
#line 47 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_90 ogg_page;
#line 52 "/usr/include/ogg/ogg.h"
struct __anonstruct_91 {
   unsigned char *body_data ;
   long body_storage ;
   long body_fill ;
   long body_returned ;
   int *lacing_vals ;
   ogg_int64_t *granule_vals ;
   long lacing_storage ;
   long lacing_fill ;
   long lacing_packet ;
   long lacing_returned ;
   unsigned char header[282] ;
   int header_fill ;
   int e_o_s ;
   int b_o_s ;
   long serialno ;
   long pageno ;
   ogg_int64_t packetno ;
   ogg_int64_t granulepos ;
};
#line 84 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_91 ogg_stream_state;
#line 89 "/usr/include/ogg/ogg.h"
struct __anonstruct_92 {
   unsigned char *packet ;
   long bytes ;
   long b_o_s ;
   long e_o_s ;
   ogg_int64_t granulepos ;
   ogg_int64_t packetno ;
};
#line 102 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_92 ogg_packet;
#line 104 "/usr/include/ogg/ogg.h"
struct __anonstruct_93 {
   unsigned char *data ;
   int storage ;
   int fill ;
   int returned ;
   int unsynced ;
   int headerbytes ;
   int bodybytes ;
};
#line 113 "/usr/include/ogg/ogg.h"
typedef struct __anonstruct_93 ogg_sync_state;
#line 27 "/usr/include/vorbis/codec.h"
struct vorbis_info {
   int version ;
   int channels ;
   long rate ;
   long bitrate_upper ;
   long bitrate_nominal ;
   long bitrate_lower ;
   long bitrate_window ;
   void *codec_setup ;
};
#line 53 "/usr/include/vorbis/codec.h"
typedef struct vorbis_info vorbis_info;
#line 58 "/usr/include/vorbis/codec.h"
struct vorbis_dsp_state {
   int analysisp ;
   vorbis_info *vi ;
   float **pcm ;
   float **pcmret ;
   int pcm_storage ;
   int pcm_current ;
   int pcm_returned ;
   int preextrapolate ;
   int eofflag ;
   long lW ;
   long W ;
   long nW ;
   long centerW ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   ogg_int64_t glue_bits ;
   ogg_int64_t time_bits ;
   ogg_int64_t floor_bits ;
   ogg_int64_t res_bits ;
   void *backend_state ;
};
#line 85 "/usr/include/vorbis/codec.h"
typedef struct vorbis_dsp_state vorbis_dsp_state;
#line 109
struct alloc_chain ;
#line 87 "/usr/include/vorbis/codec.h"
struct vorbis_block {
   float **pcm ;
   oggpack_buffer opb ;
   long lW ;
   long W ;
   long nW ;
   int pcmend ;
   int mode ;
   int eofflag ;
   ogg_int64_t granulepos ;
   ogg_int64_t sequence ;
   vorbis_dsp_state *vd ;
   void *localstore ;
   long localtop ;
   long localalloc ;
   long totaluse ;
   struct alloc_chain *reap ;
   long glue_bits ;
   long time_bits ;
   long floor_bits ;
   long res_bits ;
   void *internal ;
};
#line 119 "/usr/include/vorbis/codec.h"
typedef struct vorbis_block vorbis_block;
#line 126 "/usr/include/vorbis/codec.h"
struct alloc_chain {
   void *ptr ;
   struct alloc_chain *next ;
};
#line 139 "/usr/include/vorbis/codec.h"
struct vorbis_comment {
   char **user_comments ;
   int *comment_lengths ;
   int comments ;
   char *vendor ;
};
#line 147 "/usr/include/vorbis/codec.h"
typedef struct vorbis_comment vorbis_comment;
#line 38 "/usr/include/vorbis/vorbisfile.h"
struct __anonstruct_94 {
   size_t (*read_func)(void * , size_t  , size_t  , void * ) ;
   int (*seek_func)(void * , ogg_int64_t  , int  ) ;
   int (*close_func)(void * ) ;
   long (*tell_func)(void * ) ;
};
#line 43 "/usr/include/vorbis/vorbisfile.h"
typedef struct __anonstruct_94 ov_callbacks;
#line 110 "/usr/include/vorbis/vorbisfile.h"
struct OggVorbis_File {
   void *datasource ;
   int seekable ;
   ogg_int64_t offset ;
   ogg_int64_t end ;
   ogg_sync_state oy ;
   int links ;
   ogg_int64_t *offsets ;
   ogg_int64_t *dataoffsets ;
   long *serialnos ;
   ogg_int64_t *pcmlengths ;
   vorbis_info *vi ;
   vorbis_comment *vc ;
   ogg_int64_t pcm_offset ;
   int ready_state ;
   long current_serialno ;
   int current_link ;
   double bittrack ;
   double samptrack ;
   ogg_stream_state os ;
   vorbis_dsp_state vd ;
   vorbis_block vb ;
   ov_callbacks callbacks ;
};
#line 145 "/usr/include/vorbis/vorbisfile.h"
typedef struct OggVorbis_File OggVorbis_File;
#line 55 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
struct vorbis {
   OggVorbis_File *vf ;
   int opened ;
   vorbis_info *(*ov_info)(OggVorbis_File * , int  ) ;
   int (*ov_clear)(OggVorbis_File * ) ;
   long (*ov_read)(OggVorbis_File * , char * , int  , int  , int  , int  , int * ) ;
   long (*ov_read_tremor)(OggVorbis_File * , char * , int  , int * ) ;
   int (*ov_open_callbacks)(void * , OggVorbis_File * , char const   * , long  , ov_callbacks  ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___2 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__20___2 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum__21___2 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___2 {
    MSG_OOB___2 = 1,
    MSG_PEEK___2 = 2,
    MSG_DONTROUTE___2 = 4,
    MSG_CTRUNC___2 = 8,
    MSG_PROXY___2 = 16,
    MSG_TRUNC___2 = 32,
    MSG_DONTWAIT___2 = 64,
    MSG_EOR___2 = 128,
    MSG_WAITALL___2 = 256,
    MSG_FIN___2 = 512,
    MSG_SYN___2 = 1024,
    MSG_CONFIRM___2 = 2048,
    MSG_RST___2 = 4096,
    MSG_ERRQUEUE___2 = 8192,
    MSG_NOSIGNAL___2 = 16384,
    MSG_MORE___2 = 32768,
    MSG_WAITFORONE___2 = 65536,
    MSG_BATCH___2 = 262144,
    MSG_ZEROCOPY___2 = 67108864,
    MSG_FASTOPEN___2 = 536870912,
    MSG_CMSG_CLOEXEC___2 = 1073741824
} ;
#line 334
enum __anonenum__23___2 {
    SCM_RIGHTS___2 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___2 {
    SHUT_RD___2 = 0,
    SHUT_WR___2 = 1,
    SHUT_RDWR___2 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___2 {
    IPPROTO_IP___2 = 0,
    IPPROTO_ICMP___2 = 1,
    IPPROTO_IGMP___2 = 2,
    IPPROTO_IPIP___2 = 4,
    IPPROTO_TCP___2 = 6,
    IPPROTO_EGP___2 = 8,
    IPPROTO_PUP___2 = 12,
    IPPROTO_UDP___2 = 17,
    IPPROTO_IDP___2 = 22,
    IPPROTO_TP___2 = 29,
    IPPROTO_DCCP___2 = 33,
    IPPROTO_IPV6___2 = 41,
    IPPROTO_RSVP___2 = 46,
    IPPROTO_GRE___2 = 47,
    IPPROTO_ESP___2 = 50,
    IPPROTO_AH___2 = 51,
    IPPROTO_MTP___2 = 92,
    IPPROTO_BEETPH___2 = 94,
    IPPROTO_ENCAP___2 = 98,
    IPPROTO_PIM___2 = 103,
    IPPROTO_COMP___2 = 108,
    IPPROTO_SCTP___2 = 132,
    IPPROTO_UDPLITE___2 = 136,
    IPPROTO_MPLS___2 = 137,
    IPPROTO_ETHERNET___2 = 143,
    IPPROTO_RAW___2 = 255,
    IPPROTO_MPTCP___2 = 262,
    IPPROTO_MAX___2 = 263
} ;
#line 103
enum __anonenum__28___2 {
    IPPROTO_HOPOPTS___2 = 0,
    IPPROTO_ROUTING___2 = 43,
    IPPROTO_FRAGMENT___2 = 44,
    IPPROTO_ICMPV6___2 = 58,
    IPPROTO_NONE___2 = 59,
    IPPROTO_DSTOPTS___2 = 60,
    IPPROTO_MH___2 = 135
} ;
#line 126
enum __anonenum__29___2 {
    IPPORT_ECHO___2 = 7,
    IPPORT_DISCARD___2 = 9,
    IPPORT_SYSTAT___2 = 11,
    IPPORT_DAYTIME___2 = 13,
    IPPORT_NETSTAT___2 = 15,
    IPPORT_FTP___2 = 21,
    IPPORT_TELNET___2 = 23,
    IPPORT_SMTP___2 = 25,
    IPPORT_TIMESERVER___2 = 37,
    IPPORT_NAMESERVER___2 = 42,
    IPPORT_WHOIS___2 = 43,
    IPPORT_MTP___2 = 57,
    IPPORT_TFTP___2 = 69,
    IPPORT_RJE___2 = 77,
    IPPORT_FINGER___2 = 79,
    IPPORT_TTYLINK___2 = 87,
    IPPORT_SUPDUP___2 = 95,
    IPPORT_EXECSERVER___2 = 512,
    IPPORT_LOGINSERVER___2 = 513,
    IPPORT_CMDSERVER___2 = 514,
    IPPORT_EFSSERVER___2 = 520,
    IPPORT_BIFFUDP___2 = 512,
    IPPORT_WHOSERVER___2 = 513,
    IPPORT_ROUTESERVER___2 = 520,
    IPPORT_RESERVED___2 = 1024,
    IPPORT_USERRESERVED___2 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___2 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 47
enum __anonenum__33___2 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 69
enum __anonenum__34___2 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 81
enum __anonenum__35___2 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 104
enum __anonenum__36___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 124
enum __anonenum__37___2 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 134
enum __anonenum__38___2 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 144
enum __anonenum__39___2 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 168
enum __anonenum__40___2 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 175
enum __anonenum__41___2 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___2 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__55___2 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__56___2 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__57___2 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
#line 142
enum __anonenum__58___2 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 176
enum __anonenum__59___2 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 193
enum __anonenum__60___2 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___2 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___2 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___2 {
    EFD_SEMAPHORE___2 = 1,
    EFD_CLOEXEC___2 = 524288,
    EFD_NONBLOCK___2 = 2048
} ;
#line 71 "/usr/include/mad.h"
typedef int mad_fixed_t;
#line 73 "/usr/include/mad.h"
typedef int mad_fixed64hi_t;
#line 74 "/usr/include/mad.h"
typedef unsigned int mad_fixed64lo_t;
#line 91 "/usr/include/mad.h"
typedef mad_fixed_t mad_sample_t;
#line 572 "/usr/include/mad.h"
struct mad_bitptr {
   unsigned char const   *byte ;
   unsigned short cache ;
   unsigned short left ;
};
#line 601 "/usr/include/mad.h"
struct __anonstruct_95 {
   long seconds ;
   unsigned long fraction ;
};
#line 604 "/usr/include/mad.h"
typedef struct __anonstruct_95 mad_timer_t;
#line 610
enum mad_units {
    MAD_UNITS_HOURS = -2,
    MAD_UNITS_MINUTES = -1,
    MAD_UNITS_SECONDS = 0,
    MAD_UNITS_DECISECONDS = 10,
    MAD_UNITS_CENTISECONDS = 100,
    MAD_UNITS_MILLISECONDS = 1000,
    MAD_UNITS_8000_HZ = 8000,
    MAD_UNITS_11025_HZ = 11025,
    MAD_UNITS_12000_HZ = 12000,
    MAD_UNITS_16000_HZ = 16000,
    MAD_UNITS_22050_HZ = 22050,
    MAD_UNITS_24000_HZ = 24000,
    MAD_UNITS_32000_HZ = 32000,
    MAD_UNITS_44100_HZ = 44100,
    MAD_UNITS_48000_HZ = 48000,
    MAD_UNITS_24_FPS = 24,
    MAD_UNITS_25_FPS = 25,
    MAD_UNITS_30_FPS = 30,
    MAD_UNITS_48_FPS = 48,
    MAD_UNITS_50_FPS = 50,
    MAD_UNITS_60_FPS = 60,
    MAD_UNITS_75_FPS = 75,
    MAD_UNITS_23_976_FPS = -24,
    MAD_UNITS_24_975_FPS = -25,
    MAD_UNITS_29_97_FPS = -30,
    MAD_UNITS_47_952_FPS = -48,
    MAD_UNITS_49_95_FPS = -50,
    MAD_UNITS_59_94_FPS = -60
} ;
#line 687
enum mad_error {
    MAD_ERROR_NONE = 0,
    MAD_ERROR_BUFLEN = 1,
    MAD_ERROR_BUFPTR = 2,
    MAD_ERROR_NOMEM = 49,
    MAD_ERROR_LOSTSYNC = 257,
    MAD_ERROR_BADLAYER = 258,
    MAD_ERROR_BADBITRATE = 259,
    MAD_ERROR_BADSAMPLERATE = 260,
    MAD_ERROR_BADEMPHASIS = 261,
    MAD_ERROR_BADCRC = 513,
    MAD_ERROR_BADBITALLOC = 529,
    MAD_ERROR_BADSCALEFACTOR = 545,
    MAD_ERROR_BADMODE = 546,
    MAD_ERROR_BADFRAMELEN = 561,
    MAD_ERROR_BADBIGVALUES = 562,
    MAD_ERROR_BADBLOCKTYPE = 563,
    MAD_ERROR_BADSCFSI = 564,
    MAD_ERROR_BADDATAPTR = 565,
    MAD_ERROR_BADPART3LEN = 566,
    MAD_ERROR_BADHUFFTABLE = 567,
    MAD_ERROR_BADHUFFDATA = 568,
    MAD_ERROR_BADSTEREO = 569
} ;
#line 718 "/usr/include/mad.h"
struct mad_stream {
   unsigned char const   *buffer ;
   unsigned char const   *bufend ;
   unsigned long skiplen ;
   int sync ;
   unsigned long freerate ;
   unsigned char const   *this_frame ;
   unsigned char const   *next_frame ;
   struct mad_bitptr ptr ;
   struct mad_bitptr anc_ptr ;
   unsigned int anc_bitlen ;
   unsigned char (*main_data)[2567] ;
   unsigned int md_len ;
   int options ;
   enum mad_error error ;
};
#line 741
enum __anonenum__96 {
    MAD_OPTION_IGNORECRC = 1,
    MAD_OPTION_HALFSAMPLERATE = 2
} ;
#line 773
enum mad_layer {
    MAD_LAYER_I = 1,
    MAD_LAYER_II = 2,
    MAD_LAYER_III = 3
} ;
#line 779
enum mad_mode {
    MAD_MODE_SINGLE_CHANNEL = 0,
    MAD_MODE_DUAL_CHANNEL = 1,
    MAD_MODE_JOINT_STEREO = 2,
    MAD_MODE_STEREO = 3
} ;
#line 786
enum mad_emphasis {
    MAD_EMPHASIS_NONE = 0,
    MAD_EMPHASIS_50_15_US = 1,
    MAD_EMPHASIS_CCITT_J_17 = 3,
    MAD_EMPHASIS_RESERVED = 2
} ;
#line 793 "/usr/include/mad.h"
struct mad_header {
   enum mad_layer layer ;
   enum mad_mode mode ;
   int mode_extension ;
   enum mad_emphasis emphasis ;
   unsigned long bitrate ;
   unsigned int samplerate ;
   unsigned short crc_check ;
   unsigned short crc_target ;
   int flags ;
   int private_bits ;
   mad_timer_t duration ;
};
#line 811 "/usr/include/mad.h"
struct mad_frame {
   struct mad_header header ;
   int options ;
   mad_fixed_t sbsample[2][36][32] ;
   mad_fixed_t (*overlap)[2][32][18] ;
};
#line 826
enum __anonenum__97 {
    MAD_FLAG_NPRIVATE_III = 7,
    MAD_FLAG_INCOMPLETE = 8,
    MAD_FLAG_PROTECTION = 16,
    MAD_FLAG_COPYRIGHT = 32,
    MAD_FLAG_ORIGINAL = 64,
    MAD_FLAG_PADDING = 128,
    MAD_FLAG_I_STEREO = 256,
    MAD_FLAG_MS_STEREO = 512,
    MAD_FLAG_FREEFORMAT = 1024,
    MAD_FLAG_LSF_EXT = 4096,
    MAD_FLAG_MC_EXT = 8192,
    MAD_FLAG_MPEG_2_5_EXT = 16384
} ;
#line 844
enum __anonenum__98 {
    MAD_PRIVATE_HEADER = 256,
    MAD_PRIVATE_III = 31
} ;
#line 870 "/usr/include/mad.h"
struct mad_pcm {
   unsigned int samplerate ;
   unsigned short channels ;
   unsigned short length ;
   mad_fixed_t samples[2][1152] ;
};
#line 877 "/usr/include/mad.h"
struct mad_synth {
   mad_fixed_t filter[2][2][2][16][8] ;
   unsigned int phase ;
   struct mad_pcm pcm ;
};
#line 887
enum __anonenum__99 {
    MAD_PCM_CHANNEL_SINGLE = 0
} ;
#line 892
enum __anonenum__100 {
    MAD_PCM_CHANNEL_DUAL_1 = 0,
    MAD_PCM_CHANNEL_DUAL_2 = 1
} ;
#line 898
enum __anonenum__101 {
    MAD_PCM_CHANNEL_STEREO_LEFT = 0,
    MAD_PCM_CHANNEL_STEREO_RIGHT = 1
} ;
#line 919
enum mad_decoder_mode {
    MAD_DECODER_MODE_SYNC = 0,
    MAD_DECODER_MODE_ASYNC = 1
} ;
#line 924
enum mad_flow {
    MAD_FLOW_CONTINUE = 0,
    MAD_FLOW_STOP = 16,
    MAD_FLOW_BREAK = 17,
    MAD_FLOW_IGNORE = 32
} ;
#line 936 "/usr/include/mad.h"
struct __anonstruct_102 {
   long pid ;
   int in ;
   int out ;
};
#line 942 "/usr/include/mad.h"
struct __anonstruct_103 {
   struct mad_stream stream ;
   struct mad_frame frame ;
   struct mad_synth synth ;
};
#line 931 "/usr/include/mad.h"
struct mad_decoder {
   enum mad_decoder_mode mode ;
   int options ;
   struct __anonstruct_102 async ;
   struct __anonstruct_103 *sync ;
   void *cb_data ;
   enum mad_flow (*input_func)(void * , struct mad_stream * ) ;
   enum mad_flow (*header_func)(void * , struct mad_header * ) ;
   enum mad_flow (*filter_func)(void * , struct mad_stream * , struct mad_frame * ) ;
   enum mad_flow (*output_func)(void * , struct mad_header * , struct mad_pcm * ) ;
   enum mad_flow (*error_func)(void * , struct mad_stream * , struct mad_frame * ) ;
   enum mad_flow (*message_func)(void * , void * , unsigned int * ) ;
};
#line 30 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
struct mad {
   u8_t *readbuf ;
   unsigned int readbuf_len ;
   struct mad_stream stream ;
   struct mad_frame frame ;
   struct mad_synth synth ;
   enum mad_error last_error ;
   int checktags ;
   u32_t consume ;
   u32_t skip ;
   u64_t samples ;
   u32_t padding ;
   void (*mad_stream_init)(struct mad_stream * ) ;
   void (*mad_frame_init)(struct mad_frame * ) ;
   void (*mad_synth_init)(struct mad_synth * ) ;
   void (*mad_frame_finish)(struct mad_frame * ) ;
   void (*mad_stream_finish)(struct mad_stream * ) ;
   void (*mad_stream_buffer)(struct mad_stream * , unsigned char const   * , unsigned long  ) ;
   int (*mad_frame_decode)(struct mad_frame * , struct mad_stream * ) ;
   void (*mad_synth_frame)(struct mad_synth * , struct mad_frame * ) ;
   char const   *(*mad_stream_errorstr)(struct mad_stream * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___3 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__20___3 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum__21___3 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___3 {
    MSG_OOB___3 = 1,
    MSG_PEEK___3 = 2,
    MSG_DONTROUTE___3 = 4,
    MSG_CTRUNC___3 = 8,
    MSG_PROXY___3 = 16,
    MSG_TRUNC___3 = 32,
    MSG_DONTWAIT___3 = 64,
    MSG_EOR___3 = 128,
    MSG_WAITALL___3 = 256,
    MSG_FIN___3 = 512,
    MSG_SYN___3 = 1024,
    MSG_CONFIRM___3 = 2048,
    MSG_RST___3 = 4096,
    MSG_ERRQUEUE___3 = 8192,
    MSG_NOSIGNAL___3 = 16384,
    MSG_MORE___3 = 32768,
    MSG_WAITFORONE___3 = 65536,
    MSG_BATCH___3 = 262144,
    MSG_ZEROCOPY___3 = 67108864,
    MSG_FASTOPEN___3 = 536870912,
    MSG_CMSG_CLOEXEC___3 = 1073741824
} ;
#line 334
enum __anonenum__23___3 {
    SCM_RIGHTS___3 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___3 {
    SHUT_RD___3 = 0,
    SHUT_WR___3 = 1,
    SHUT_RDWR___3 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___3 {
    IPPROTO_IP___3 = 0,
    IPPROTO_ICMP___3 = 1,
    IPPROTO_IGMP___3 = 2,
    IPPROTO_IPIP___3 = 4,
    IPPROTO_TCP___3 = 6,
    IPPROTO_EGP___3 = 8,
    IPPROTO_PUP___3 = 12,
    IPPROTO_UDP___3 = 17,
    IPPROTO_IDP___3 = 22,
    IPPROTO_TP___3 = 29,
    IPPROTO_DCCP___3 = 33,
    IPPROTO_IPV6___3 = 41,
    IPPROTO_RSVP___3 = 46,
    IPPROTO_GRE___3 = 47,
    IPPROTO_ESP___3 = 50,
    IPPROTO_AH___3 = 51,
    IPPROTO_MTP___3 = 92,
    IPPROTO_BEETPH___3 = 94,
    IPPROTO_ENCAP___3 = 98,
    IPPROTO_PIM___3 = 103,
    IPPROTO_COMP___3 = 108,
    IPPROTO_SCTP___3 = 132,
    IPPROTO_UDPLITE___3 = 136,
    IPPROTO_MPLS___3 = 137,
    IPPROTO_ETHERNET___3 = 143,
    IPPROTO_RAW___3 = 255,
    IPPROTO_MPTCP___3 = 262,
    IPPROTO_MAX___3 = 263
} ;
#line 103
enum __anonenum__28___3 {
    IPPROTO_HOPOPTS___3 = 0,
    IPPROTO_ROUTING___3 = 43,
    IPPROTO_FRAGMENT___3 = 44,
    IPPROTO_ICMPV6___3 = 58,
    IPPROTO_NONE___3 = 59,
    IPPROTO_DSTOPTS___3 = 60,
    IPPROTO_MH___3 = 135
} ;
#line 126
enum __anonenum__29___3 {
    IPPORT_ECHO___3 = 7,
    IPPORT_DISCARD___3 = 9,
    IPPORT_SYSTAT___3 = 11,
    IPPORT_DAYTIME___3 = 13,
    IPPORT_NETSTAT___3 = 15,
    IPPORT_FTP___3 = 21,
    IPPORT_TELNET___3 = 23,
    IPPORT_SMTP___3 = 25,
    IPPORT_TIMESERVER___3 = 37,
    IPPORT_NAMESERVER___3 = 42,
    IPPORT_WHOIS___3 = 43,
    IPPORT_MTP___3 = 57,
    IPPORT_TFTP___3 = 69,
    IPPORT_RJE___3 = 77,
    IPPORT_FINGER___3 = 79,
    IPPORT_TTYLINK___3 = 87,
    IPPORT_SUPDUP___3 = 95,
    IPPORT_EXECSERVER___3 = 512,
    IPPORT_LOGINSERVER___3 = 513,
    IPPORT_CMDSERVER___3 = 514,
    IPPORT_EFSSERVER___3 = 520,
    IPPORT_BIFFUDP___3 = 512,
    IPPORT_WHOSERVER___3 = 513,
    IPPORT_ROUTESERVER___3 = 520,
    IPPORT_RESERVED___3 = 1024,
    IPPORT_USERRESERVED___3 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___3 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 47
enum __anonenum__33___3 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 69
enum __anonenum__34___3 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 81
enum __anonenum__35___3 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 104
enum __anonenum__36___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 124
enum __anonenum__37___3 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 134
enum __anonenum__38___3 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 144
enum __anonenum__39___3 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 168
enum __anonenum__40___3 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 175
enum __anonenum__41___3 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___3 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
#line 71
enum __anonenum__55___3 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
#line 94
enum __anonenum__56___3 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
#line 119
enum __anonenum__57___3 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7,
    SEGV_MTEAERR___3 = 8,
    SEGV_MTESERR___3 = 9
} ;
#line 142
enum __anonenum__58___3 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
#line 176
enum __anonenum__59___3 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
#line 193
enum __anonenum__60___3 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___3 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___3 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___3 {
    EFD_SEMAPHORE___3 = 1,
    EFD_CLOEXEC___3 = 524288,
    EFD_NONBLOCK___3 = 2048
} ;
#line 77 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
enum __anonenum__104 {
    UNKNOWN = 0,
    WAVE = 1,
    AIFF = 2
} ;
#line 77 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
typedef enum __anonenum__104 header_format;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___4 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum__20___4 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4 = 250
} ;
#line 539
enum __anonenum__21___4 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___4 {
    MSG_OOB___4 = 1,
    MSG_PEEK___4 = 2,
    MSG_DONTROUTE___4 = 4,
    MSG_CTRUNC___4 = 8,
    MSG_PROXY___4 = 16,
    MSG_TRUNC___4 = 32,
    MSG_DONTWAIT___4 = 64,
    MSG_EOR___4 = 128,
    MSG_WAITALL___4 = 256,
    MSG_FIN___4 = 512,
    MSG_SYN___4 = 1024,
    MSG_CONFIRM___4 = 2048,
    MSG_RST___4 = 4096,
    MSG_ERRQUEUE___4 = 8192,
    MSG_NOSIGNAL___4 = 16384,
    MSG_MORE___4 = 32768,
    MSG_WAITFORONE___4 = 65536,
    MSG_BATCH___4 = 262144,
    MSG_ZEROCOPY___4 = 67108864,
    MSG_FASTOPEN___4 = 536870912,
    MSG_CMSG_CLOEXEC___4 = 1073741824
} ;
#line 334
enum __anonenum__23___4 {
    SCM_RIGHTS___4 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___4 {
    SHUT_RD___4 = 0,
    SHUT_WR___4 = 1,
    SHUT_RDWR___4 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___4 {
    IPPROTO_IP___4 = 0,
    IPPROTO_ICMP___4 = 1,
    IPPROTO_IGMP___4 = 2,
    IPPROTO_IPIP___4 = 4,
    IPPROTO_TCP___4 = 6,
    IPPROTO_EGP___4 = 8,
    IPPROTO_PUP___4 = 12,
    IPPROTO_UDP___4 = 17,
    IPPROTO_IDP___4 = 22,
    IPPROTO_TP___4 = 29,
    IPPROTO_DCCP___4 = 33,
    IPPROTO_IPV6___4 = 41,
    IPPROTO_RSVP___4 = 46,
    IPPROTO_GRE___4 = 47,
    IPPROTO_ESP___4 = 50,
    IPPROTO_AH___4 = 51,
    IPPROTO_MTP___4 = 92,
    IPPROTO_BEETPH___4 = 94,
    IPPROTO_ENCAP___4 = 98,
    IPPROTO_PIM___4 = 103,
    IPPROTO_COMP___4 = 108,
    IPPROTO_SCTP___4 = 132,
    IPPROTO_UDPLITE___4 = 136,
    IPPROTO_MPLS___4 = 137,
    IPPROTO_ETHERNET___4 = 143,
    IPPROTO_RAW___4 = 255,
    IPPROTO_MPTCP___4 = 262,
    IPPROTO_MAX___4 = 263
} ;
#line 103
enum __anonenum__28___4 {
    IPPROTO_HOPOPTS___4 = 0,
    IPPROTO_ROUTING___4 = 43,
    IPPROTO_FRAGMENT___4 = 44,
    IPPROTO_ICMPV6___4 = 58,
    IPPROTO_NONE___4 = 59,
    IPPROTO_DSTOPTS___4 = 60,
    IPPROTO_MH___4 = 135
} ;
#line 126
enum __anonenum__29___4 {
    IPPORT_ECHO___4 = 7,
    IPPORT_DISCARD___4 = 9,
    IPPORT_SYSTAT___4 = 11,
    IPPORT_DAYTIME___4 = 13,
    IPPORT_NETSTAT___4 = 15,
    IPPORT_FTP___4 = 21,
    IPPORT_TELNET___4 = 23,
    IPPORT_SMTP___4 = 25,
    IPPORT_TIMESERVER___4 = 37,
    IPPORT_NAMESERVER___4 = 42,
    IPPORT_WHOIS___4 = 43,
    IPPORT_MTP___4 = 57,
    IPPORT_TFTP___4 = 69,
    IPPORT_RJE___4 = 77,
    IPPORT_FINGER___4 = 79,
    IPPORT_TTYLINK___4 = 87,
    IPPORT_SUPDUP___4 = 95,
    IPPORT_EXECSERVER___4 = 512,
    IPPORT_LOGINSERVER___4 = 513,
    IPPORT_CMDSERVER___4 = 514,
    IPPORT_EFSSERVER___4 = 520,
    IPPORT_BIFFUDP___4 = 512,
    IPPORT_WHOSERVER___4 = 513,
    IPPORT_ROUTESERVER___4 = 520,
    IPPORT_RESERVED___4 = 1024,
    IPPORT_USERRESERVED___4 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___4 {
    PTHREAD_CREATE_JOINABLE___4 = 0,
    PTHREAD_CREATE_DETACHED___4 = 1
} ;
#line 47
enum __anonenum__33___4 {
    PTHREAD_MUTEX_TIMED_NP___4 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___4 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___4 = 3,
    PTHREAD_MUTEX_NORMAL___4 = 0,
    PTHREAD_MUTEX_RECURSIVE___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK___4 = 2,
    PTHREAD_MUTEX_DEFAULT___4 = 0
} ;
#line 69
enum __anonenum__34___4 {
    PTHREAD_MUTEX_STALLED___4 = 0,
    PTHREAD_MUTEX_STALLED_NP___4 = 0,
    PTHREAD_MUTEX_ROBUST___4 = 1,
    PTHREAD_MUTEX_ROBUST_NP___4 = 1
} ;
#line 81
enum __anonenum__35___4 {
    PTHREAD_PRIO_NONE___4 = 0,
    PTHREAD_PRIO_INHERIT___4 = 1,
    PTHREAD_PRIO_PROTECT___4 = 2
} ;
#line 104
enum __anonenum__36___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___4 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___4 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___4 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___4 = 0
} ;
#line 124
enum __anonenum__37___4 {
    PTHREAD_INHERIT_SCHED___4 = 0,
    PTHREAD_EXPLICIT_SCHED___4 = 1
} ;
#line 134
enum __anonenum__38___4 {
    PTHREAD_SCOPE_SYSTEM___4 = 0,
    PTHREAD_SCOPE_PROCESS___4 = 1
} ;
#line 144
enum __anonenum__39___4 {
    PTHREAD_PROCESS_PRIVATE___4 = 0,
    PTHREAD_PROCESS_SHARED___4 = 1
} ;
#line 168
enum __anonenum__40___4 {
    PTHREAD_CANCEL_ENABLE___4 = 0,
    PTHREAD_CANCEL_DISABLE___4 = 1
} ;
#line 175
enum __anonenum__41___4 {
    PTHREAD_CANCEL_DEFERRED___4 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___4 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___4 {
    SI_ASYNCNL___4 = -60,
    SI_DETHREAD___4 = -7,
    SI_TKILL___4 = -6,
    SI_SIGIO___4 = -5,
    SI_ASYNCIO___4 = -4,
    SI_MESGQ___4 = -3,
    SI_TIMER___4 = -2,
    SI_QUEUE___4 = -1,
    SI_USER___4 = 0,
    SI_KERNEL___4 = 128
} ;
#line 71
enum __anonenum__55___4 {
    ILL_ILLOPC___4 = 1,
    ILL_ILLOPN___4 = 2,
    ILL_ILLADR___4 = 3,
    ILL_ILLTRP___4 = 4,
    ILL_PRVOPC___4 = 5,
    ILL_PRVREG___4 = 6,
    ILL_COPROC___4 = 7,
    ILL_BADSTK___4 = 8,
    ILL_BADIADDR___4 = 9
} ;
#line 94
enum __anonenum__56___4 {
    FPE_INTDIV___4 = 1,
    FPE_INTOVF___4 = 2,
    FPE_FLTDIV___4 = 3,
    FPE_FLTOVF___4 = 4,
    FPE_FLTUND___4 = 5,
    FPE_FLTRES___4 = 6,
    FPE_FLTINV___4 = 7,
    FPE_FLTSUB___4 = 8,
    FPE_FLTUNK___4 = 14,
    FPE_CONDTRAP___4 = 15
} ;
#line 119
enum __anonenum__57___4 {
    SEGV_MAPERR___4 = 1,
    SEGV_ACCERR___4 = 2,
    SEGV_BNDERR___4 = 3,
    SEGV_PKUERR___4 = 4,
    SEGV_ACCADI___4 = 5,
    SEGV_ADIDERR___4 = 6,
    SEGV_ADIPERR___4 = 7,
    SEGV_MTEAERR___4 = 8,
    SEGV_MTESERR___4 = 9
} ;
#line 142
enum __anonenum__58___4 {
    BUS_ADRALN___4 = 1,
    BUS_ADRERR___4 = 2,
    BUS_OBJERR___4 = 3,
    BUS_MCEERR_AR___4 = 4,
    BUS_MCEERR_AO___4 = 5
} ;
#line 176
enum __anonenum__59___4 {
    CLD_EXITED___4 = 1,
    CLD_KILLED___4 = 2,
    CLD_DUMPED___4 = 3,
    CLD_TRAPPED___4 = 4,
    CLD_STOPPED___4 = 5,
    CLD_CONTINUED___4 = 6
} ;
#line 193
enum __anonenum__60___4 {
    POLL_IN___4 = 1,
    POLL_OUT___4 = 2,
    POLL_MSG___4 = 3,
    POLL_ERR___4 = 4,
    POLL_PRI___4 = 5,
    POLL_HUP___4 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___4 {
    SIGEV_SIGNAL___4 = 0,
    SIGEV_NONE___4 = 1,
    SIGEV_THREAD___4 = 2,
    SIGEV_THREAD_ID___4 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___4 {
    SS_ONSTACK___4 = 1,
    SS_DISABLE___4 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___4 {
    EFD_SEMAPHORE___4 = 1,
    EFD_CLOEXEC___4 = 524288,
    EFD_NONBLOCK___4 = 2048
} ;
#line 57 "/usr/include/FLAC/ordinals.h"
typedef int8_t FLAC__int8;
#line 58 "/usr/include/FLAC/ordinals.h"
typedef uint8_t FLAC__uint8;
#line 60 "/usr/include/FLAC/ordinals.h"
typedef int16_t FLAC__int16;
#line 61 "/usr/include/FLAC/ordinals.h"
typedef int32_t FLAC__int32;
#line 62 "/usr/include/FLAC/ordinals.h"
typedef int64_t FLAC__int64;
#line 63 "/usr/include/FLAC/ordinals.h"
typedef uint16_t FLAC__uint16;
#line 64 "/usr/include/FLAC/ordinals.h"
typedef uint32_t FLAC__uint32;
#line 65 "/usr/include/FLAC/ordinals.h"
typedef uint64_t FLAC__uint64;
#line 69 "/usr/include/FLAC/ordinals.h"
typedef int FLAC__bool;
#line 71 "/usr/include/FLAC/ordinals.h"
typedef FLAC__uint8 FLAC__byte;
#line 194 "/usr/include/FLAC/format.h"
enum __anonenum__105 {
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,
    FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1
} ;
#line 202 "/usr/include/FLAC/format.h"
typedef enum __anonenum__105 FLAC__EntropyCodingMethodType;
#line 214 "/usr/include/FLAC/format.h"
struct __anonstruct_106 {
   uint32_t *parameters ;
   uint32_t *raw_bits ;
   uint32_t capacity_by_order ;
};
#line 229 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_106 FLAC__EntropyCodingMethod_PartitionedRiceContents;
#line 233 "/usr/include/FLAC/format.h"
struct __anonstruct_107 {
   uint32_t order ;
   FLAC__EntropyCodingMethod_PartitionedRiceContents *contents ;
};
#line 241 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_107 FLAC__EntropyCodingMethod_PartitionedRice;
#line 257 "/usr/include/FLAC/format.h"
union __anonunion_109 {
   FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice ;
};
#line 255 "/usr/include/FLAC/format.h"
struct __anonstruct_108 {
   FLAC__EntropyCodingMethodType type ;
   union __anonunion_109 data ;
};
#line 260 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_108 FLAC__EntropyCodingMethod;
#line 267
enum __anonenum__110 {
    FLAC__SUBFRAME_TYPE_CONSTANT = 0,
    FLAC__SUBFRAME_TYPE_VERBATIM = 1,
    FLAC__SUBFRAME_TYPE_FIXED = 2,
    FLAC__SUBFRAME_TYPE_LPC = 3
} ;
#line 272 "/usr/include/FLAC/format.h"
typedef enum __anonenum__110 FLAC__SubframeType;
#line 284 "/usr/include/FLAC/format.h"
struct __anonstruct_111 {
   FLAC__int32 value ;
};
#line 286 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_111 FLAC__Subframe_Constant;
#line 291 "/usr/include/FLAC/format.h"
struct __anonstruct_112 {
   FLAC__int32 *data ;
};
#line 293 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_112 FLAC__Subframe_Verbatim;
#line 298 "/usr/include/FLAC/format.h"
struct __anonstruct_113 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   FLAC__int32 warmup[4] ;
   FLAC__int32 *residual ;
};
#line 310 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_113 FLAC__Subframe_Fixed;
#line 315 "/usr/include/FLAC/format.h"
struct __anonstruct_114 {
   FLAC__EntropyCodingMethod entropy_coding_method ;
   uint32_t order ;
   uint32_t qlp_coeff_precision ;
   int quantization_level ;
   FLAC__int32 qlp_coeff[32] ;
   FLAC__int32 warmup[32] ;
   FLAC__int32 *residual ;
};
#line 336 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_114 FLAC__Subframe_LPC;
#line 346 "/usr/include/FLAC/format.h"
union __anonunion_116 {
   FLAC__Subframe_Constant constant ;
   FLAC__Subframe_Fixed fixed ;
   FLAC__Subframe_LPC lpc ;
   FLAC__Subframe_Verbatim verbatim ;
};
#line 344 "/usr/include/FLAC/format.h"
struct __anonstruct_115 {
   FLAC__SubframeType type ;
   union __anonunion_116 data ;
   uint32_t wasted_bits ;
};
#line 353 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_115 FLAC__Subframe;
#line 381
enum __anonenum__117 {
    FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0,
    FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1,
    FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2,
    FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3
} ;
#line 386 "/usr/include/FLAC/format.h"
typedef enum __anonenum__117 FLAC__ChannelAssignment;
#line 396
enum __anonenum__118 {
    FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER = 0,
    FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER = 1
} ;
#line 399 "/usr/include/FLAC/format.h"
typedef enum __anonenum__118 FLAC__FrameNumberType;
#line 432 "/usr/include/FLAC/format.h"
union __anonunion_120 {
   FLAC__uint32 frame_number ;
   FLAC__uint64 sample_number ;
};
#line 411 "/usr/include/FLAC/format.h"
struct __anonstruct_119 {
   uint32_t blocksize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   FLAC__ChannelAssignment channel_assignment ;
   uint32_t bits_per_sample ;
   FLAC__FrameNumberType number_type ;
   union __anonunion_120 number ;
   FLAC__uint8 crc ;
};
#line 444 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_119 FLAC__FrameHeader;
#line 460 "/usr/include/FLAC/format.h"
struct __anonstruct_121 {
   FLAC__uint16 crc ;
};
#line 466 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_121 FLAC__FrameFooter;
#line 473 "/usr/include/FLAC/format.h"
struct __anonstruct_122 {
   FLAC__FrameHeader header ;
   FLAC__Subframe subframes[8] ;
   FLAC__FrameFooter footer ;
};
#line 477 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_122 FLAC__Frame;
#line 489
enum __anonenum__123 {
    FLAC__METADATA_TYPE_STREAMINFO = 0,
    FLAC__METADATA_TYPE_PADDING = 1,
    FLAC__METADATA_TYPE_APPLICATION = 2,
    FLAC__METADATA_TYPE_SEEKTABLE = 3,
    FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
    FLAC__METADATA_TYPE_CUESHEET = 5,
    FLAC__METADATA_TYPE_PICTURE = 6,
    FLAC__METADATA_TYPE_UNDEFINED = 7,
    FLAC__MAX_METADATA_TYPE = 126
} ;
#line 517 "/usr/include/FLAC/format.h"
typedef enum __anonenum__123 FLAC__MetadataType;
#line 529 "/usr/include/FLAC/format.h"
struct __anonstruct_124 {
   uint32_t min_blocksize ;
   uint32_t max_blocksize ;
   uint32_t min_framesize ;
   uint32_t max_framesize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   uint32_t bits_per_sample ;
   FLAC__uint64 total_samples ;
   FLAC__byte md5sum[16] ;
};
#line 537 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_124 FLAC__StreamMetadata_StreamInfo;
#line 554 "/usr/include/FLAC/format.h"
struct __anonstruct_125 {
   int dummy ;
};
#line 560 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_125 FLAC__StreamMetadata_Padding;
#line 565 "/usr/include/FLAC/format.h"
struct __anonstruct_126 {
   FLAC__byte id[4] ;
   FLAC__byte *data ;
};
#line 568 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_126 FLAC__StreamMetadata_Application;
#line 574 "/usr/include/FLAC/format.h"
struct __anonstruct_127 {
   FLAC__uint64 sample_number ;
   FLAC__uint64 stream_offset ;
   uint32_t frame_samples ;
};
#line 584 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_127 FLAC__StreamMetadata_SeekPoint;
#line 612 "/usr/include/FLAC/format.h"
struct __anonstruct_128 {
   uint32_t num_points ;
   FLAC__StreamMetadata_SeekPoint *points ;
};
#line 615 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_128 FLAC__StreamMetadata_SeekTable;
#line 624 "/usr/include/FLAC/format.h"
struct __anonstruct_129 {
   FLAC__uint32 length ;
   FLAC__byte *entry ;
};
#line 627 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_129 FLAC__StreamMetadata_VorbisComment_Entry;
#line 634 "/usr/include/FLAC/format.h"
struct __anonstruct_130 {
   FLAC__StreamMetadata_VorbisComment_Entry vendor_string ;
   FLAC__uint32 num_comments ;
   FLAC__StreamMetadata_VorbisComment_Entry *comments ;
};
#line 638 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_130 FLAC__StreamMetadata_VorbisComment;
#line 647 "/usr/include/FLAC/format.h"
struct __anonstruct_131 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
};
#line 655 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_131 FLAC__StreamMetadata_CueSheet_Index;
#line 666 "/usr/include/FLAC/format.h"
struct __anonstruct_132 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
   char isrc[13] ;
   uint32_t type ;
   uint32_t pre_emphasis ;
   FLAC__byte num_indices ;
   FLAC__StreamMetadata_CueSheet_Index *indices ;
};
#line 688 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_132 FLAC__StreamMetadata_CueSheet_Track;
#line 703 "/usr/include/FLAC/format.h"
struct __anonstruct_133 {
   char media_catalog_number[129] ;
   FLAC__uint64 lead_in ;
   FLAC__bool is_cd ;
   uint32_t num_tracks ;
   FLAC__StreamMetadata_CueSheet_Track *tracks ;
};
#line 722 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_133 FLAC__StreamMetadata_CueSheet;
#line 732
enum __anonenum__134 {
    FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
    FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
    FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
    FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
    FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
    FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
    FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
    FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED = 21
} ;
#line 755 "/usr/include/FLAC/format.h"
typedef enum __anonenum__134 FLAC__StreamMetadata_Picture_Type;
#line 769 "/usr/include/FLAC/format.h"
struct __anonstruct_135 {
   FLAC__StreamMetadata_Picture_Type type ;
   char *mime_type ;
   FLAC__byte *description ;
   FLAC__uint32 width ;
   FLAC__uint32 height ;
   FLAC__uint32 depth ;
   FLAC__uint32 colors ;
   FLAC__uint32 data_length ;
   FLAC__byte *data ;
};
#line 811 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_135 FLAC__StreamMetadata_Picture;
#line 827 "/usr/include/FLAC/format.h"
struct __anonstruct_136 {
   FLAC__byte *data ;
};
#line 829 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_136 FLAC__StreamMetadata_Unknown;
#line 846 "/usr/include/FLAC/format.h"
union __anonunion_138 {
   FLAC__StreamMetadata_StreamInfo stream_info ;
   FLAC__StreamMetadata_Padding padding ;
   FLAC__StreamMetadata_Application application ;
   FLAC__StreamMetadata_SeekTable seek_table ;
   FLAC__StreamMetadata_VorbisComment vorbis_comment ;
   FLAC__StreamMetadata_CueSheet cue_sheet ;
   FLAC__StreamMetadata_Picture picture ;
   FLAC__StreamMetadata_Unknown unknown ;
};
#line 834 "/usr/include/FLAC/format.h"
struct __anonstruct_137 {
   FLAC__MetadataType type ;
   FLAC__bool is_last ;
   uint32_t length ;
   union __anonunion_138 data ;
};
#line 858 "/usr/include/FLAC/format.h"
typedef struct __anonstruct_137 FLAC__StreamMetadata;
#line 202 "/usr/include/FLAC/stream_decoder.h"
enum __anonenum__139 {
    FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,
    FLAC__STREAM_DECODER_READ_METADATA = 1,
    FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC = 2,
    FLAC__STREAM_DECODER_READ_FRAME = 3,
    FLAC__STREAM_DECODER_END_OF_STREAM = 4,
    FLAC__STREAM_DECODER_OGG_ERROR = 5,
    FLAC__STREAM_DECODER_SEEK_ERROR = 6,
    FLAC__STREAM_DECODER_ABORTED = 7,
    FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR = 8,
    FLAC__STREAM_DECODER_UNINITIALIZED = 9
} ;
#line 244 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__139 FLAC__StreamDecoderState;
#line 256
enum __anonenum__140 {
    FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 1,
    FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS = 2,
    FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR = 3,
    FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE = 4,
    FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED = 5
} ;
#line 282 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__140 FLAC__StreamDecoderInitStatus;
#line 294
enum __anonenum__141 {
    FLAC__STREAM_DECODER_READ_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM = 1,
    FLAC__STREAM_DECODER_READ_STATUS_ABORT = 2
} ;
#line 313 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__141 FLAC__StreamDecoderReadStatus;
#line 325
enum __anonenum__142 {
    FLAC__STREAM_DECODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_DECODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
#line 336 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__142 FLAC__StreamDecoderSeekStatus;
#line 348
enum __anonenum__143 {
    FLAC__STREAM_DECODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_DECODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED = 2
} ;
#line 359 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__143 FLAC__StreamDecoderTellStatus;
#line 371
enum __anonenum__144 {
    FLAC__STREAM_DECODER_LENGTH_STATUS_OK = 0,
    FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR = 1,
    FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED = 2
} ;
#line 382 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__144 FLAC__StreamDecoderLengthStatus;
#line 394
enum __anonenum__145 {
    FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE = 0,
    FLAC__STREAM_DECODER_WRITE_STATUS_ABORT = 1
} ;
#line 402 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__145 FLAC__StreamDecoderWriteStatus;
#line 427
enum __anonenum__146 {
    FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC = 0,
    FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER = 1,
    FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH = 2,
    FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM = 3
} ;
#line 441 "/usr/include/FLAC/stream_decoder.h"
typedef enum __anonenum__146 FLAC__StreamDecoderErrorStatus;
#line 457
struct FLAC__StreamDecoderProtected ;
#line 458
struct FLAC__StreamDecoderPrivate ;
#line 463 "/usr/include/FLAC/stream_decoder.h"
struct __anonstruct_147 {
   struct FLAC__StreamDecoderProtected *protected_ ;
   struct FLAC__StreamDecoderPrivate *private_ ;
};
#line 466 "/usr/include/FLAC/stream_decoder.h"
typedef struct __anonstruct_147 FLAC__StreamDecoder;
#line 517 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderReadStatus (*FLAC__StreamDecoderReadCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__byte [] ,
                                                                         size_t * ,
                                                                         void * );
#line 552 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderSeekStatus (*FLAC__StreamDecoderSeekCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__uint64  ,
                                                                         void * );
#line 590 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderTellStatus (*FLAC__StreamDecoderTellCallback)(FLAC__StreamDecoder * ,
                                                                         FLAC__uint64 * ,
                                                                         void * );
#line 628 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderLengthStatus (*FLAC__StreamDecoderLengthCallback)(FLAC__StreamDecoder * ,
                                                                             FLAC__uint64 * ,
                                                                             void * );
#line 655 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__bool (*FLAC__StreamDecoderEofCallback)(FLAC__StreamDecoder * , void * );
#line 683 "/usr/include/FLAC/stream_decoder.h"
typedef FLAC__StreamDecoderWriteStatus (*FLAC__StreamDecoderWriteCallback)(FLAC__StreamDecoder * ,
                                                                           FLAC__Frame * ,
                                                                           FLAC__int32 * const  [] ,
                                                                           void * );
#line 710 "/usr/include/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderMetadataCallback)(FLAC__StreamDecoder * , FLAC__StreamMetadata * ,
                                                    void * );
#line 727 "/usr/include/FLAC/stream_decoder.h"
typedef void (*FLAC__StreamDecoderErrorCallback)(FLAC__StreamDecoder * , FLAC__StreamDecoderErrorStatus  ,
                                                 void * );
#line 37 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
struct flac {
   FLAC__StreamDecoder *decoder ;
   u8_t container ;
   char const   **FLAC__StreamDecoderErrorStatusString ;
   char const   **FLAC__StreamDecoderStateString ;
   FLAC__StreamDecoder *(*FLAC__stream_decoder_new)(void) ;
   FLAC__bool (*FLAC__stream_decoder_reset)(FLAC__StreamDecoder * ) ;
   void (*FLAC__stream_decoder_delete)(FLAC__StreamDecoder * ) ;
   FLAC__StreamDecoderInitStatus (*FLAC__stream_decoder_init_stream)(FLAC__StreamDecoder * ,
                                                                     FLAC__StreamDecoderReadCallback  ,
                                                                     FLAC__StreamDecoderSeekCallback  ,
                                                                     FLAC__StreamDecoderTellCallback  ,
                                                                     FLAC__StreamDecoderLengthCallback  ,
                                                                     FLAC__StreamDecoderEofCallback  ,
                                                                     FLAC__StreamDecoderWriteCallback  ,
                                                                     FLAC__StreamDecoderMetadataCallback  ,
                                                                     FLAC__StreamDecoderErrorCallback  ,
                                                                     void * ) ;
   FLAC__StreamDecoderInitStatus (*FLAC__stream_decoder_init_ogg_stream)(FLAC__StreamDecoder * ,
                                                                         FLAC__StreamDecoderReadCallback  ,
                                                                         FLAC__StreamDecoderSeekCallback  ,
                                                                         FLAC__StreamDecoderTellCallback  ,
                                                                         FLAC__StreamDecoderLengthCallback  ,
                                                                         FLAC__StreamDecoderEofCallback  ,
                                                                         FLAC__StreamDecoderWriteCallback  ,
                                                                         FLAC__StreamDecoderMetadataCallback  ,
                                                                         FLAC__StreamDecoderErrorCallback  ,
                                                                         void * ) ;
   FLAC__bool (*FLAC__stream_decoder_process_single)(FLAC__StreamDecoder * ) ;
   FLAC__StreamDecoderState (*FLAC__stream_decoder_get_state)(FLAC__StreamDecoder * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___5 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum__20___5 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5 = 250
} ;
#line 539
enum __anonenum__21___5 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___5 {
    MSG_OOB___5 = 1,
    MSG_PEEK___5 = 2,
    MSG_DONTROUTE___5 = 4,
    MSG_CTRUNC___5 = 8,
    MSG_PROXY___5 = 16,
    MSG_TRUNC___5 = 32,
    MSG_DONTWAIT___5 = 64,
    MSG_EOR___5 = 128,
    MSG_WAITALL___5 = 256,
    MSG_FIN___5 = 512,
    MSG_SYN___5 = 1024,
    MSG_CONFIRM___5 = 2048,
    MSG_RST___5 = 4096,
    MSG_ERRQUEUE___5 = 8192,
    MSG_NOSIGNAL___5 = 16384,
    MSG_MORE___5 = 32768,
    MSG_WAITFORONE___5 = 65536,
    MSG_BATCH___5 = 262144,
    MSG_ZEROCOPY___5 = 67108864,
    MSG_FASTOPEN___5 = 536870912,
    MSG_CMSG_CLOEXEC___5 = 1073741824
} ;
#line 334
enum __anonenum__23___5 {
    SCM_RIGHTS___5 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___5 {
    SHUT_RD___5 = 0,
    SHUT_WR___5 = 1,
    SHUT_RDWR___5 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___5 {
    IPPROTO_IP___5 = 0,
    IPPROTO_ICMP___5 = 1,
    IPPROTO_IGMP___5 = 2,
    IPPROTO_IPIP___5 = 4,
    IPPROTO_TCP___5 = 6,
    IPPROTO_EGP___5 = 8,
    IPPROTO_PUP___5 = 12,
    IPPROTO_UDP___5 = 17,
    IPPROTO_IDP___5 = 22,
    IPPROTO_TP___5 = 29,
    IPPROTO_DCCP___5 = 33,
    IPPROTO_IPV6___5 = 41,
    IPPROTO_RSVP___5 = 46,
    IPPROTO_GRE___5 = 47,
    IPPROTO_ESP___5 = 50,
    IPPROTO_AH___5 = 51,
    IPPROTO_MTP___5 = 92,
    IPPROTO_BEETPH___5 = 94,
    IPPROTO_ENCAP___5 = 98,
    IPPROTO_PIM___5 = 103,
    IPPROTO_COMP___5 = 108,
    IPPROTO_SCTP___5 = 132,
    IPPROTO_UDPLITE___5 = 136,
    IPPROTO_MPLS___5 = 137,
    IPPROTO_ETHERNET___5 = 143,
    IPPROTO_RAW___5 = 255,
    IPPROTO_MPTCP___5 = 262,
    IPPROTO_MAX___5 = 263
} ;
#line 103
enum __anonenum__28___5 {
    IPPROTO_HOPOPTS___5 = 0,
    IPPROTO_ROUTING___5 = 43,
    IPPROTO_FRAGMENT___5 = 44,
    IPPROTO_ICMPV6___5 = 58,
    IPPROTO_NONE___5 = 59,
    IPPROTO_DSTOPTS___5 = 60,
    IPPROTO_MH___5 = 135
} ;
#line 126
enum __anonenum__29___5 {
    IPPORT_ECHO___5 = 7,
    IPPORT_DISCARD___5 = 9,
    IPPORT_SYSTAT___5 = 11,
    IPPORT_DAYTIME___5 = 13,
    IPPORT_NETSTAT___5 = 15,
    IPPORT_FTP___5 = 21,
    IPPORT_TELNET___5 = 23,
    IPPORT_SMTP___5 = 25,
    IPPORT_TIMESERVER___5 = 37,
    IPPORT_NAMESERVER___5 = 42,
    IPPORT_WHOIS___5 = 43,
    IPPORT_MTP___5 = 57,
    IPPORT_TFTP___5 = 69,
    IPPORT_RJE___5 = 77,
    IPPORT_FINGER___5 = 79,
    IPPORT_TTYLINK___5 = 87,
    IPPORT_SUPDUP___5 = 95,
    IPPORT_EXECSERVER___5 = 512,
    IPPORT_LOGINSERVER___5 = 513,
    IPPORT_CMDSERVER___5 = 514,
    IPPORT_EFSSERVER___5 = 520,
    IPPORT_BIFFUDP___5 = 512,
    IPPORT_WHOSERVER___5 = 513,
    IPPORT_ROUTESERVER___5 = 520,
    IPPORT_RESERVED___5 = 1024,
    IPPORT_USERRESERVED___5 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___5 {
    PTHREAD_CREATE_JOINABLE___5 = 0,
    PTHREAD_CREATE_DETACHED___5 = 1
} ;
#line 47
enum __anonenum__33___5 {
    PTHREAD_MUTEX_TIMED_NP___5 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___5 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___5 = 3,
    PTHREAD_MUTEX_NORMAL___5 = 0,
    PTHREAD_MUTEX_RECURSIVE___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK___5 = 2,
    PTHREAD_MUTEX_DEFAULT___5 = 0
} ;
#line 69
enum __anonenum__34___5 {
    PTHREAD_MUTEX_STALLED___5 = 0,
    PTHREAD_MUTEX_STALLED_NP___5 = 0,
    PTHREAD_MUTEX_ROBUST___5 = 1,
    PTHREAD_MUTEX_ROBUST_NP___5 = 1
} ;
#line 81
enum __anonenum__35___5 {
    PTHREAD_PRIO_NONE___5 = 0,
    PTHREAD_PRIO_INHERIT___5 = 1,
    PTHREAD_PRIO_PROTECT___5 = 2
} ;
#line 104
enum __anonenum__36___5 {
    PTHREAD_RWLOCK_PREFER_READER_NP___5 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___5 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___5 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___5 = 0
} ;
#line 124
enum __anonenum__37___5 {
    PTHREAD_INHERIT_SCHED___5 = 0,
    PTHREAD_EXPLICIT_SCHED___5 = 1
} ;
#line 134
enum __anonenum__38___5 {
    PTHREAD_SCOPE_SYSTEM___5 = 0,
    PTHREAD_SCOPE_PROCESS___5 = 1
} ;
#line 144
enum __anonenum__39___5 {
    PTHREAD_PROCESS_PRIVATE___5 = 0,
    PTHREAD_PROCESS_SHARED___5 = 1
} ;
#line 168
enum __anonenum__40___5 {
    PTHREAD_CANCEL_ENABLE___5 = 0,
    PTHREAD_CANCEL_DISABLE___5 = 1
} ;
#line 175
enum __anonenum__41___5 {
    PTHREAD_CANCEL_DEFERRED___5 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___5 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___5 {
    SI_ASYNCNL___5 = -60,
    SI_DETHREAD___5 = -7,
    SI_TKILL___5 = -6,
    SI_SIGIO___5 = -5,
    SI_ASYNCIO___5 = -4,
    SI_MESGQ___5 = -3,
    SI_TIMER___5 = -2,
    SI_QUEUE___5 = -1,
    SI_USER___5 = 0,
    SI_KERNEL___5 = 128
} ;
#line 71
enum __anonenum__55___5 {
    ILL_ILLOPC___5 = 1,
    ILL_ILLOPN___5 = 2,
    ILL_ILLADR___5 = 3,
    ILL_ILLTRP___5 = 4,
    ILL_PRVOPC___5 = 5,
    ILL_PRVREG___5 = 6,
    ILL_COPROC___5 = 7,
    ILL_BADSTK___5 = 8,
    ILL_BADIADDR___5 = 9
} ;
#line 94
enum __anonenum__56___5 {
    FPE_INTDIV___5 = 1,
    FPE_INTOVF___5 = 2,
    FPE_FLTDIV___5 = 3,
    FPE_FLTOVF___5 = 4,
    FPE_FLTUND___5 = 5,
    FPE_FLTRES___5 = 6,
    FPE_FLTINV___5 = 7,
    FPE_FLTSUB___5 = 8,
    FPE_FLTUNK___5 = 14,
    FPE_CONDTRAP___5 = 15
} ;
#line 119
enum __anonenum__57___5 {
    SEGV_MAPERR___5 = 1,
    SEGV_ACCERR___5 = 2,
    SEGV_BNDERR___5 = 3,
    SEGV_PKUERR___5 = 4,
    SEGV_ACCADI___5 = 5,
    SEGV_ADIDERR___5 = 6,
    SEGV_ADIPERR___5 = 7,
    SEGV_MTEAERR___5 = 8,
    SEGV_MTESERR___5 = 9
} ;
#line 142
enum __anonenum__58___5 {
    BUS_ADRALN___5 = 1,
    BUS_ADRERR___5 = 2,
    BUS_OBJERR___5 = 3,
    BUS_MCEERR_AR___5 = 4,
    BUS_MCEERR_AO___5 = 5
} ;
#line 176
enum __anonenum__59___5 {
    CLD_EXITED___5 = 1,
    CLD_KILLED___5 = 2,
    CLD_DUMPED___5 = 3,
    CLD_TRAPPED___5 = 4,
    CLD_STOPPED___5 = 5,
    CLD_CONTINUED___5 = 6
} ;
#line 193
enum __anonenum__60___5 {
    POLL_IN___5 = 1,
    POLL_OUT___5 = 2,
    POLL_MSG___5 = 3,
    POLL_ERR___5 = 4,
    POLL_PRI___5 = 5,
    POLL_HUP___5 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___5 {
    SIGEV_SIGNAL___5 = 0,
    SIGEV_NONE___5 = 1,
    SIGEV_THREAD___5 = 2,
    SIGEV_THREAD_ID___5 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___5 {
    SS_ONSTACK___5 = 1,
    SS_DISABLE___5 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___5 {
    EFD_SEMAPHORE___5 = 1,
    EFD_CLOEXEC___5 = 524288,
    EFD_NONBLOCK___5 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___6 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum__20___6 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6 = 250
} ;
#line 539
enum __anonenum__21___6 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___6 {
    MSG_OOB___6 = 1,
    MSG_PEEK___6 = 2,
    MSG_DONTROUTE___6 = 4,
    MSG_CTRUNC___6 = 8,
    MSG_PROXY___6 = 16,
    MSG_TRUNC___6 = 32,
    MSG_DONTWAIT___6 = 64,
    MSG_EOR___6 = 128,
    MSG_WAITALL___6 = 256,
    MSG_FIN___6 = 512,
    MSG_SYN___6 = 1024,
    MSG_CONFIRM___6 = 2048,
    MSG_RST___6 = 4096,
    MSG_ERRQUEUE___6 = 8192,
    MSG_NOSIGNAL___6 = 16384,
    MSG_MORE___6 = 32768,
    MSG_WAITFORONE___6 = 65536,
    MSG_BATCH___6 = 262144,
    MSG_ZEROCOPY___6 = 67108864,
    MSG_FASTOPEN___6 = 536870912,
    MSG_CMSG_CLOEXEC___6 = 1073741824
} ;
#line 334
enum __anonenum__23___6 {
    SCM_RIGHTS___6 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___6 {
    SHUT_RD___6 = 0,
    SHUT_WR___6 = 1,
    SHUT_RDWR___6 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___6 {
    IPPROTO_IP___6 = 0,
    IPPROTO_ICMP___6 = 1,
    IPPROTO_IGMP___6 = 2,
    IPPROTO_IPIP___6 = 4,
    IPPROTO_TCP___6 = 6,
    IPPROTO_EGP___6 = 8,
    IPPROTO_PUP___6 = 12,
    IPPROTO_UDP___6 = 17,
    IPPROTO_IDP___6 = 22,
    IPPROTO_TP___6 = 29,
    IPPROTO_DCCP___6 = 33,
    IPPROTO_IPV6___6 = 41,
    IPPROTO_RSVP___6 = 46,
    IPPROTO_GRE___6 = 47,
    IPPROTO_ESP___6 = 50,
    IPPROTO_AH___6 = 51,
    IPPROTO_MTP___6 = 92,
    IPPROTO_BEETPH___6 = 94,
    IPPROTO_ENCAP___6 = 98,
    IPPROTO_PIM___6 = 103,
    IPPROTO_COMP___6 = 108,
    IPPROTO_SCTP___6 = 132,
    IPPROTO_UDPLITE___6 = 136,
    IPPROTO_MPLS___6 = 137,
    IPPROTO_ETHERNET___6 = 143,
    IPPROTO_RAW___6 = 255,
    IPPROTO_MPTCP___6 = 262,
    IPPROTO_MAX___6 = 263
} ;
#line 103
enum __anonenum__28___6 {
    IPPROTO_HOPOPTS___6 = 0,
    IPPROTO_ROUTING___6 = 43,
    IPPROTO_FRAGMENT___6 = 44,
    IPPROTO_ICMPV6___6 = 58,
    IPPROTO_NONE___6 = 59,
    IPPROTO_DSTOPTS___6 = 60,
    IPPROTO_MH___6 = 135
} ;
#line 126
enum __anonenum__29___6 {
    IPPORT_ECHO___6 = 7,
    IPPORT_DISCARD___6 = 9,
    IPPORT_SYSTAT___6 = 11,
    IPPORT_DAYTIME___6 = 13,
    IPPORT_NETSTAT___6 = 15,
    IPPORT_FTP___6 = 21,
    IPPORT_TELNET___6 = 23,
    IPPORT_SMTP___6 = 25,
    IPPORT_TIMESERVER___6 = 37,
    IPPORT_NAMESERVER___6 = 42,
    IPPORT_WHOIS___6 = 43,
    IPPORT_MTP___6 = 57,
    IPPORT_TFTP___6 = 69,
    IPPORT_RJE___6 = 77,
    IPPORT_FINGER___6 = 79,
    IPPORT_TTYLINK___6 = 87,
    IPPORT_SUPDUP___6 = 95,
    IPPORT_EXECSERVER___6 = 512,
    IPPORT_LOGINSERVER___6 = 513,
    IPPORT_CMDSERVER___6 = 514,
    IPPORT_EFSSERVER___6 = 520,
    IPPORT_BIFFUDP___6 = 512,
    IPPORT_WHOSERVER___6 = 513,
    IPPORT_ROUTESERVER___6 = 520,
    IPPORT_RESERVED___6 = 1024,
    IPPORT_USERRESERVED___6 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___6 {
    PTHREAD_CREATE_JOINABLE___6 = 0,
    PTHREAD_CREATE_DETACHED___6 = 1
} ;
#line 47
enum __anonenum__33___6 {
    PTHREAD_MUTEX_TIMED_NP___6 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___6 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___6 = 3,
    PTHREAD_MUTEX_NORMAL___6 = 0,
    PTHREAD_MUTEX_RECURSIVE___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK___6 = 2,
    PTHREAD_MUTEX_DEFAULT___6 = 0
} ;
#line 69
enum __anonenum__34___6 {
    PTHREAD_MUTEX_STALLED___6 = 0,
    PTHREAD_MUTEX_STALLED_NP___6 = 0,
    PTHREAD_MUTEX_ROBUST___6 = 1,
    PTHREAD_MUTEX_ROBUST_NP___6 = 1
} ;
#line 81
enum __anonenum__35___6 {
    PTHREAD_PRIO_NONE___6 = 0,
    PTHREAD_PRIO_INHERIT___6 = 1,
    PTHREAD_PRIO_PROTECT___6 = 2
} ;
#line 104
enum __anonenum__36___6 {
    PTHREAD_RWLOCK_PREFER_READER_NP___6 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___6 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___6 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___6 = 0
} ;
#line 124
enum __anonenum__37___6 {
    PTHREAD_INHERIT_SCHED___6 = 0,
    PTHREAD_EXPLICIT_SCHED___6 = 1
} ;
#line 134
enum __anonenum__38___6 {
    PTHREAD_SCOPE_SYSTEM___6 = 0,
    PTHREAD_SCOPE_PROCESS___6 = 1
} ;
#line 144
enum __anonenum__39___6 {
    PTHREAD_PROCESS_PRIVATE___6 = 0,
    PTHREAD_PROCESS_SHARED___6 = 1
} ;
#line 168
enum __anonenum__40___6 {
    PTHREAD_CANCEL_ENABLE___6 = 0,
    PTHREAD_CANCEL_DISABLE___6 = 1
} ;
#line 175
enum __anonenum__41___6 {
    PTHREAD_CANCEL_DEFERRED___6 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___6 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___6 {
    SI_ASYNCNL___6 = -60,
    SI_DETHREAD___6 = -7,
    SI_TKILL___6 = -6,
    SI_SIGIO___6 = -5,
    SI_ASYNCIO___6 = -4,
    SI_MESGQ___6 = -3,
    SI_TIMER___6 = -2,
    SI_QUEUE___6 = -1,
    SI_USER___6 = 0,
    SI_KERNEL___6 = 128
} ;
#line 71
enum __anonenum__55___6 {
    ILL_ILLOPC___6 = 1,
    ILL_ILLOPN___6 = 2,
    ILL_ILLADR___6 = 3,
    ILL_ILLTRP___6 = 4,
    ILL_PRVOPC___6 = 5,
    ILL_PRVREG___6 = 6,
    ILL_COPROC___6 = 7,
    ILL_BADSTK___6 = 8,
    ILL_BADIADDR___6 = 9
} ;
#line 94
enum __anonenum__56___6 {
    FPE_INTDIV___6 = 1,
    FPE_INTOVF___6 = 2,
    FPE_FLTDIV___6 = 3,
    FPE_FLTOVF___6 = 4,
    FPE_FLTUND___6 = 5,
    FPE_FLTRES___6 = 6,
    FPE_FLTINV___6 = 7,
    FPE_FLTSUB___6 = 8,
    FPE_FLTUNK___6 = 14,
    FPE_CONDTRAP___6 = 15
} ;
#line 119
enum __anonenum__57___6 {
    SEGV_MAPERR___6 = 1,
    SEGV_ACCERR___6 = 2,
    SEGV_BNDERR___6 = 3,
    SEGV_PKUERR___6 = 4,
    SEGV_ACCADI___6 = 5,
    SEGV_ADIDERR___6 = 6,
    SEGV_ADIPERR___6 = 7,
    SEGV_MTEAERR___6 = 8,
    SEGV_MTESERR___6 = 9
} ;
#line 142
enum __anonenum__58___6 {
    BUS_ADRALN___6 = 1,
    BUS_ADRERR___6 = 2,
    BUS_OBJERR___6 = 3,
    BUS_MCEERR_AR___6 = 4,
    BUS_MCEERR_AO___6 = 5
} ;
#line 176
enum __anonenum__59___6 {
    CLD_EXITED___6 = 1,
    CLD_KILLED___6 = 2,
    CLD_DUMPED___6 = 3,
    CLD_TRAPPED___6 = 4,
    CLD_STOPPED___6 = 5,
    CLD_CONTINUED___6 = 6
} ;
#line 193
enum __anonenum__60___6 {
    POLL_IN___6 = 1,
    POLL_OUT___6 = 2,
    POLL_MSG___6 = 3,
    POLL_ERR___6 = 4,
    POLL_PRI___6 = 5,
    POLL_HUP___6 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___6 {
    SIGEV_SIGNAL___6 = 0,
    SIGEV_NONE___6 = 1,
    SIGEV_THREAD___6 = 2,
    SIGEV_THREAD_ID___6 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___6 {
    SS_ONSTACK___6 = 1,
    SS_DISABLE___6 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___6 {
    EFD_SEMAPHORE___6 = 1,
    EFD_CLOEXEC___6 = 524288,
    EFD_NONBLOCK___6 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___7 {
    _PC_LINK_MAX___7 = 0,
    _PC_MAX_CANON___7 = 1,
    _PC_MAX_INPUT___7 = 2,
    _PC_NAME_MAX___7 = 3,
    _PC_PATH_MAX___7 = 4,
    _PC_PIPE_BUF___7 = 5,
    _PC_CHOWN_RESTRICTED___7 = 6,
    _PC_NO_TRUNC___7 = 7,
    _PC_VDISABLE___7 = 8,
    _PC_SYNC_IO___7 = 9,
    _PC_ASYNC_IO___7 = 10,
    _PC_PRIO_IO___7 = 11,
    _PC_SOCK_MAXBUF___7 = 12,
    _PC_FILESIZEBITS___7 = 13,
    _PC_REC_INCR_XFER_SIZE___7 = 14,
    _PC_REC_MAX_XFER_SIZE___7 = 15,
    _PC_REC_MIN_XFER_SIZE___7 = 16,
    _PC_REC_XFER_ALIGN___7 = 17,
    _PC_ALLOC_SIZE_MIN___7 = 18,
    _PC_SYMLINK_MAX___7 = 19,
    _PC_2_SYMLINKS___7 = 20
} ;
#line 71
enum __anonenum__20___7 {
    _SC_ARG_MAX___7 = 0,
    _SC_CHILD_MAX___7 = 1,
    _SC_CLK_TCK___7 = 2,
    _SC_NGROUPS_MAX___7 = 3,
    _SC_OPEN_MAX___7 = 4,
    _SC_STREAM_MAX___7 = 5,
    _SC_TZNAME_MAX___7 = 6,
    _SC_JOB_CONTROL___7 = 7,
    _SC_SAVED_IDS___7 = 8,
    _SC_REALTIME_SIGNALS___7 = 9,
    _SC_PRIORITY_SCHEDULING___7 = 10,
    _SC_TIMERS___7 = 11,
    _SC_ASYNCHRONOUS_IO___7 = 12,
    _SC_PRIORITIZED_IO___7 = 13,
    _SC_SYNCHRONIZED_IO___7 = 14,
    _SC_FSYNC___7 = 15,
    _SC_MAPPED_FILES___7 = 16,
    _SC_MEMLOCK___7 = 17,
    _SC_MEMLOCK_RANGE___7 = 18,
    _SC_MEMORY_PROTECTION___7 = 19,
    _SC_MESSAGE_PASSING___7 = 20,
    _SC_SEMAPHORES___7 = 21,
    _SC_SHARED_MEMORY_OBJECTS___7 = 22,
    _SC_AIO_LISTIO_MAX___7 = 23,
    _SC_AIO_MAX___7 = 24,
    _SC_AIO_PRIO_DELTA_MAX___7 = 25,
    _SC_DELAYTIMER_MAX___7 = 26,
    _SC_MQ_OPEN_MAX___7 = 27,
    _SC_MQ_PRIO_MAX___7 = 28,
    _SC_VERSION___7 = 29,
    _SC_PAGESIZE___7 = 30,
    _SC_RTSIG_MAX___7 = 31,
    _SC_SEM_NSEMS_MAX___7 = 32,
    _SC_SEM_VALUE_MAX___7 = 33,
    _SC_SIGQUEUE_MAX___7 = 34,
    _SC_TIMER_MAX___7 = 35,
    _SC_BC_BASE_MAX___7 = 36,
    _SC_BC_DIM_MAX___7 = 37,
    _SC_BC_SCALE_MAX___7 = 38,
    _SC_BC_STRING_MAX___7 = 39,
    _SC_COLL_WEIGHTS_MAX___7 = 40,
    _SC_EQUIV_CLASS_MAX___7 = 41,
    _SC_EXPR_NEST_MAX___7 = 42,
    _SC_LINE_MAX___7 = 43,
    _SC_RE_DUP_MAX___7 = 44,
    _SC_CHARCLASS_NAME_MAX___7 = 45,
    _SC_2_VERSION___7 = 46,
    _SC_2_C_BIND___7 = 47,
    _SC_2_C_DEV___7 = 48,
    _SC_2_FORT_DEV___7 = 49,
    _SC_2_FORT_RUN___7 = 50,
    _SC_2_SW_DEV___7 = 51,
    _SC_2_LOCALEDEF___7 = 52,
    _SC_PII___7 = 53,
    _SC_PII_XTI___7 = 54,
    _SC_PII_SOCKET___7 = 55,
    _SC_PII_INTERNET___7 = 56,
    _SC_PII_OSI___7 = 57,
    _SC_POLL___7 = 58,
    _SC_SELECT___7 = 59,
    _SC_UIO_MAXIOV___7 = 60,
    _SC_IOV_MAX___7 = 60,
    _SC_PII_INTERNET_STREAM___7 = 61,
    _SC_PII_INTERNET_DGRAM___7 = 62,
    _SC_PII_OSI_COTS___7 = 63,
    _SC_PII_OSI_CLTS___7 = 64,
    _SC_PII_OSI_M___7 = 65,
    _SC_T_IOV_MAX___7 = 66,
    _SC_THREADS___7 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___7 = 68,
    _SC_GETGR_R_SIZE_MAX___7 = 69,
    _SC_GETPW_R_SIZE_MAX___7 = 70,
    _SC_LOGIN_NAME_MAX___7 = 71,
    _SC_TTY_NAME_MAX___7 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___7 = 73,
    _SC_THREAD_KEYS_MAX___7 = 74,
    _SC_THREAD_STACK_MIN___7 = 75,
    _SC_THREAD_THREADS_MAX___7 = 76,
    _SC_THREAD_ATTR_STACKADDR___7 = 77,
    _SC_THREAD_ATTR_STACKSIZE___7 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___7 = 79,
    _SC_THREAD_PRIO_INHERIT___7 = 80,
    _SC_THREAD_PRIO_PROTECT___7 = 81,
    _SC_THREAD_PROCESS_SHARED___7 = 82,
    _SC_NPROCESSORS_CONF___7 = 83,
    _SC_NPROCESSORS_ONLN___7 = 84,
    _SC_PHYS_PAGES___7 = 85,
    _SC_AVPHYS_PAGES___7 = 86,
    _SC_ATEXIT_MAX___7 = 87,
    _SC_PASS_MAX___7 = 88,
    _SC_XOPEN_VERSION___7 = 89,
    _SC_XOPEN_XCU_VERSION___7 = 90,
    _SC_XOPEN_UNIX___7 = 91,
    _SC_XOPEN_CRYPT___7 = 92,
    _SC_XOPEN_ENH_I18N___7 = 93,
    _SC_XOPEN_SHM___7 = 94,
    _SC_2_CHAR_TERM___7 = 95,
    _SC_2_C_VERSION___7 = 96,
    _SC_2_UPE___7 = 97,
    _SC_XOPEN_XPG2___7 = 98,
    _SC_XOPEN_XPG3___7 = 99,
    _SC_XOPEN_XPG4___7 = 100,
    _SC_CHAR_BIT___7 = 101,
    _SC_CHAR_MAX___7 = 102,
    _SC_CHAR_MIN___7 = 103,
    _SC_INT_MAX___7 = 104,
    _SC_INT_MIN___7 = 105,
    _SC_LONG_BIT___7 = 106,
    _SC_WORD_BIT___7 = 107,
    _SC_MB_LEN_MAX___7 = 108,
    _SC_NZERO___7 = 109,
    _SC_SSIZE_MAX___7 = 110,
    _SC_SCHAR_MAX___7 = 111,
    _SC_SCHAR_MIN___7 = 112,
    _SC_SHRT_MAX___7 = 113,
    _SC_SHRT_MIN___7 = 114,
    _SC_UCHAR_MAX___7 = 115,
    _SC_UINT_MAX___7 = 116,
    _SC_ULONG_MAX___7 = 117,
    _SC_USHRT_MAX___7 = 118,
    _SC_NL_ARGMAX___7 = 119,
    _SC_NL_LANGMAX___7 = 120,
    _SC_NL_MSGMAX___7 = 121,
    _SC_NL_NMAX___7 = 122,
    _SC_NL_SETMAX___7 = 123,
    _SC_NL_TEXTMAX___7 = 124,
    _SC_XBS5_ILP32_OFF32___7 = 125,
    _SC_XBS5_ILP32_OFFBIG___7 = 126,
    _SC_XBS5_LP64_OFF64___7 = 127,
    _SC_XBS5_LPBIG_OFFBIG___7 = 128,
    _SC_XOPEN_LEGACY___7 = 129,
    _SC_XOPEN_REALTIME___7 = 130,
    _SC_XOPEN_REALTIME_THREADS___7 = 131,
    _SC_ADVISORY_INFO___7 = 132,
    _SC_BARRIERS___7 = 133,
    _SC_BASE___7 = 134,
    _SC_C_LANG_SUPPORT___7 = 135,
    _SC_C_LANG_SUPPORT_R___7 = 136,
    _SC_CLOCK_SELECTION___7 = 137,
    _SC_CPUTIME___7 = 138,
    _SC_THREAD_CPUTIME___7 = 139,
    _SC_DEVICE_IO___7 = 140,
    _SC_DEVICE_SPECIFIC___7 = 141,
    _SC_DEVICE_SPECIFIC_R___7 = 142,
    _SC_FD_MGMT___7 = 143,
    _SC_FIFO___7 = 144,
    _SC_PIPE___7 = 145,
    _SC_FILE_ATTRIBUTES___7 = 146,
    _SC_FILE_LOCKING___7 = 147,
    _SC_FILE_SYSTEM___7 = 148,
    _SC_MONOTONIC_CLOCK___7 = 149,
    _SC_MULTI_PROCESS___7 = 150,
    _SC_SINGLE_PROCESS___7 = 151,
    _SC_NETWORKING___7 = 152,
    _SC_READER_WRITER_LOCKS___7 = 153,
    _SC_SPIN_LOCKS___7 = 154,
    _SC_REGEXP___7 = 155,
    _SC_REGEX_VERSION___7 = 156,
    _SC_SHELL___7 = 157,
    _SC_SIGNALS___7 = 158,
    _SC_SPAWN___7 = 159,
    _SC_SPORADIC_SERVER___7 = 160,
    _SC_THREAD_SPORADIC_SERVER___7 = 161,
    _SC_SYSTEM_DATABASE___7 = 162,
    _SC_SYSTEM_DATABASE_R___7 = 163,
    _SC_TIMEOUTS___7 = 164,
    _SC_TYPED_MEMORY_OBJECTS___7 = 165,
    _SC_USER_GROUPS___7 = 166,
    _SC_USER_GROUPS_R___7 = 167,
    _SC_2_PBS___7 = 168,
    _SC_2_PBS_ACCOUNTING___7 = 169,
    _SC_2_PBS_LOCATE___7 = 170,
    _SC_2_PBS_MESSAGE___7 = 171,
    _SC_2_PBS_TRACK___7 = 172,
    _SC_SYMLOOP_MAX___7 = 173,
    _SC_STREAMS___7 = 174,
    _SC_2_PBS_CHECKPOINT___7 = 175,
    _SC_V6_ILP32_OFF32___7 = 176,
    _SC_V6_ILP32_OFFBIG___7 = 177,
    _SC_V6_LP64_OFF64___7 = 178,
    _SC_V6_LPBIG_OFFBIG___7 = 179,
    _SC_HOST_NAME_MAX___7 = 180,
    _SC_TRACE___7 = 181,
    _SC_TRACE_EVENT_FILTER___7 = 182,
    _SC_TRACE_INHERIT___7 = 183,
    _SC_TRACE_LOG___7 = 184,
    _SC_LEVEL1_ICACHE_SIZE___7 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___7 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___7 = 187,
    _SC_LEVEL1_DCACHE_SIZE___7 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___7 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___7 = 190,
    _SC_LEVEL2_CACHE_SIZE___7 = 191,
    _SC_LEVEL2_CACHE_ASSOC___7 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___7 = 193,
    _SC_LEVEL3_CACHE_SIZE___7 = 194,
    _SC_LEVEL3_CACHE_ASSOC___7 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___7 = 196,
    _SC_LEVEL4_CACHE_SIZE___7 = 197,
    _SC_LEVEL4_CACHE_ASSOC___7 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___7 = 199,
    _SC_IPV6___7 = 235,
    _SC_RAW_SOCKETS___7 = 236,
    _SC_V7_ILP32_OFF32___7 = 237,
    _SC_V7_ILP32_OFFBIG___7 = 238,
    _SC_V7_LP64_OFF64___7 = 239,
    _SC_V7_LPBIG_OFFBIG___7 = 240,
    _SC_SS_REPL_MAX___7 = 241,
    _SC_TRACE_EVENT_NAME_MAX___7 = 242,
    _SC_TRACE_NAME_MAX___7 = 243,
    _SC_TRACE_SYS_MAX___7 = 244,
    _SC_TRACE_USER_EVENT_MAX___7 = 245,
    _SC_XOPEN_STREAMS___7 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___7 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___7 = 248,
    _SC_MINSIGSTKSZ___7 = 249,
    _SC_SIGSTKSZ___7 = 250
} ;
#line 539
enum __anonenum__21___7 {
    _CS_PATH___7 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___7 = 1,
    _CS_GNU_LIBC_VERSION___7 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___7 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___7 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___7 = 5,
    _CS_LFS_CFLAGS___7 = 1000,
    _CS_LFS_LDFLAGS___7 = 1001,
    _CS_LFS_LIBS___7 = 1002,
    _CS_LFS_LINTFLAGS___7 = 1003,
    _CS_LFS64_CFLAGS___7 = 1004,
    _CS_LFS64_LDFLAGS___7 = 1005,
    _CS_LFS64_LIBS___7 = 1006,
    _CS_LFS64_LINTFLAGS___7 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___7 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___7 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___7 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___7 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___7 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___7 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___7 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___7 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___7 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___7 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___7 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___7 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___7 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___7 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___7 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___7 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___7 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___7 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___7 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___7 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___7 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___7 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___7 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___7 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___7 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___7 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___7 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___7 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___7 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___7 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___7 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___7 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___7 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___7 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___7 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___7 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___7 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___7 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___7 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___7 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___7 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___7 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___7 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___7 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___7 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___7 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___7 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___7 = 1147,
    _CS_V6_ENV___7 = 1148,
    _CS_V7_ENV___7 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___7 {
    MSG_OOB___7 = 1,
    MSG_PEEK___7 = 2,
    MSG_DONTROUTE___7 = 4,
    MSG_CTRUNC___7 = 8,
    MSG_PROXY___7 = 16,
    MSG_TRUNC___7 = 32,
    MSG_DONTWAIT___7 = 64,
    MSG_EOR___7 = 128,
    MSG_WAITALL___7 = 256,
    MSG_FIN___7 = 512,
    MSG_SYN___7 = 1024,
    MSG_CONFIRM___7 = 2048,
    MSG_RST___7 = 4096,
    MSG_ERRQUEUE___7 = 8192,
    MSG_NOSIGNAL___7 = 16384,
    MSG_MORE___7 = 32768,
    MSG_WAITFORONE___7 = 65536,
    MSG_BATCH___7 = 262144,
    MSG_ZEROCOPY___7 = 67108864,
    MSG_FASTOPEN___7 = 536870912,
    MSG_CMSG_CLOEXEC___7 = 1073741824
} ;
#line 334
enum __anonenum__23___7 {
    SCM_RIGHTS___7 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___7 {
    SHUT_RD___7 = 0,
    SHUT_WR___7 = 1,
    SHUT_RDWR___7 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___7 {
    IPPROTO_IP___7 = 0,
    IPPROTO_ICMP___7 = 1,
    IPPROTO_IGMP___7 = 2,
    IPPROTO_IPIP___7 = 4,
    IPPROTO_TCP___7 = 6,
    IPPROTO_EGP___7 = 8,
    IPPROTO_PUP___7 = 12,
    IPPROTO_UDP___7 = 17,
    IPPROTO_IDP___7 = 22,
    IPPROTO_TP___7 = 29,
    IPPROTO_DCCP___7 = 33,
    IPPROTO_IPV6___7 = 41,
    IPPROTO_RSVP___7 = 46,
    IPPROTO_GRE___7 = 47,
    IPPROTO_ESP___7 = 50,
    IPPROTO_AH___7 = 51,
    IPPROTO_MTP___7 = 92,
    IPPROTO_BEETPH___7 = 94,
    IPPROTO_ENCAP___7 = 98,
    IPPROTO_PIM___7 = 103,
    IPPROTO_COMP___7 = 108,
    IPPROTO_SCTP___7 = 132,
    IPPROTO_UDPLITE___7 = 136,
    IPPROTO_MPLS___7 = 137,
    IPPROTO_ETHERNET___7 = 143,
    IPPROTO_RAW___7 = 255,
    IPPROTO_MPTCP___7 = 262,
    IPPROTO_MAX___7 = 263
} ;
#line 103
enum __anonenum__28___7 {
    IPPROTO_HOPOPTS___7 = 0,
    IPPROTO_ROUTING___7 = 43,
    IPPROTO_FRAGMENT___7 = 44,
    IPPROTO_ICMPV6___7 = 58,
    IPPROTO_NONE___7 = 59,
    IPPROTO_DSTOPTS___7 = 60,
    IPPROTO_MH___7 = 135
} ;
#line 126
enum __anonenum__29___7 {
    IPPORT_ECHO___7 = 7,
    IPPORT_DISCARD___7 = 9,
    IPPORT_SYSTAT___7 = 11,
    IPPORT_DAYTIME___7 = 13,
    IPPORT_NETSTAT___7 = 15,
    IPPORT_FTP___7 = 21,
    IPPORT_TELNET___7 = 23,
    IPPORT_SMTP___7 = 25,
    IPPORT_TIMESERVER___7 = 37,
    IPPORT_NAMESERVER___7 = 42,
    IPPORT_WHOIS___7 = 43,
    IPPORT_MTP___7 = 57,
    IPPORT_TFTP___7 = 69,
    IPPORT_RJE___7 = 77,
    IPPORT_FINGER___7 = 79,
    IPPORT_TTYLINK___7 = 87,
    IPPORT_SUPDUP___7 = 95,
    IPPORT_EXECSERVER___7 = 512,
    IPPORT_LOGINSERVER___7 = 513,
    IPPORT_CMDSERVER___7 = 514,
    IPPORT_EFSSERVER___7 = 520,
    IPPORT_BIFFUDP___7 = 512,
    IPPORT_WHOSERVER___7 = 513,
    IPPORT_ROUTESERVER___7 = 520,
    IPPORT_RESERVED___7 = 1024,
    IPPORT_USERRESERVED___7 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___7 {
    PTHREAD_CREATE_JOINABLE___7 = 0,
    PTHREAD_CREATE_DETACHED___7 = 1
} ;
#line 47
enum __anonenum__33___7 {
    PTHREAD_MUTEX_TIMED_NP___7 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___7 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___7 = 3,
    PTHREAD_MUTEX_NORMAL___7 = 0,
    PTHREAD_MUTEX_RECURSIVE___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK___7 = 2,
    PTHREAD_MUTEX_DEFAULT___7 = 0
} ;
#line 69
enum __anonenum__34___7 {
    PTHREAD_MUTEX_STALLED___7 = 0,
    PTHREAD_MUTEX_STALLED_NP___7 = 0,
    PTHREAD_MUTEX_ROBUST___7 = 1,
    PTHREAD_MUTEX_ROBUST_NP___7 = 1
} ;
#line 81
enum __anonenum__35___7 {
    PTHREAD_PRIO_NONE___7 = 0,
    PTHREAD_PRIO_INHERIT___7 = 1,
    PTHREAD_PRIO_PROTECT___7 = 2
} ;
#line 104
enum __anonenum__36___7 {
    PTHREAD_RWLOCK_PREFER_READER_NP___7 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___7 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___7 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___7 = 0
} ;
#line 124
enum __anonenum__37___7 {
    PTHREAD_INHERIT_SCHED___7 = 0,
    PTHREAD_EXPLICIT_SCHED___7 = 1
} ;
#line 134
enum __anonenum__38___7 {
    PTHREAD_SCOPE_SYSTEM___7 = 0,
    PTHREAD_SCOPE_PROCESS___7 = 1
} ;
#line 144
enum __anonenum__39___7 {
    PTHREAD_PROCESS_PRIVATE___7 = 0,
    PTHREAD_PROCESS_SHARED___7 = 1
} ;
#line 168
enum __anonenum__40___7 {
    PTHREAD_CANCEL_ENABLE___7 = 0,
    PTHREAD_CANCEL_DISABLE___7 = 1
} ;
#line 175
enum __anonenum__41___7 {
    PTHREAD_CANCEL_DEFERRED___7 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___7 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___7 {
    SI_ASYNCNL___7 = -60,
    SI_DETHREAD___7 = -7,
    SI_TKILL___7 = -6,
    SI_SIGIO___7 = -5,
    SI_ASYNCIO___7 = -4,
    SI_MESGQ___7 = -3,
    SI_TIMER___7 = -2,
    SI_QUEUE___7 = -1,
    SI_USER___7 = 0,
    SI_KERNEL___7 = 128
} ;
#line 71
enum __anonenum__55___7 {
    ILL_ILLOPC___7 = 1,
    ILL_ILLOPN___7 = 2,
    ILL_ILLADR___7 = 3,
    ILL_ILLTRP___7 = 4,
    ILL_PRVOPC___7 = 5,
    ILL_PRVREG___7 = 6,
    ILL_COPROC___7 = 7,
    ILL_BADSTK___7 = 8,
    ILL_BADIADDR___7 = 9
} ;
#line 94
enum __anonenum__56___7 {
    FPE_INTDIV___7 = 1,
    FPE_INTOVF___7 = 2,
    FPE_FLTDIV___7 = 3,
    FPE_FLTOVF___7 = 4,
    FPE_FLTUND___7 = 5,
    FPE_FLTRES___7 = 6,
    FPE_FLTINV___7 = 7,
    FPE_FLTSUB___7 = 8,
    FPE_FLTUNK___7 = 14,
    FPE_CONDTRAP___7 = 15
} ;
#line 119
enum __anonenum__57___7 {
    SEGV_MAPERR___7 = 1,
    SEGV_ACCERR___7 = 2,
    SEGV_BNDERR___7 = 3,
    SEGV_PKUERR___7 = 4,
    SEGV_ACCADI___7 = 5,
    SEGV_ADIDERR___7 = 6,
    SEGV_ADIPERR___7 = 7,
    SEGV_MTEAERR___7 = 8,
    SEGV_MTESERR___7 = 9
} ;
#line 142
enum __anonenum__58___7 {
    BUS_ADRALN___7 = 1,
    BUS_ADRERR___7 = 2,
    BUS_OBJERR___7 = 3,
    BUS_MCEERR_AR___7 = 4,
    BUS_MCEERR_AO___7 = 5
} ;
#line 176
enum __anonenum__59___7 {
    CLD_EXITED___7 = 1,
    CLD_KILLED___7 = 2,
    CLD_DUMPED___7 = 3,
    CLD_TRAPPED___7 = 4,
    CLD_STOPPED___7 = 5,
    CLD_CONTINUED___7 = 6
} ;
#line 193
enum __anonenum__60___7 {
    POLL_IN___7 = 1,
    POLL_OUT___7 = 2,
    POLL_MSG___7 = 3,
    POLL_ERR___7 = 4,
    POLL_PRI___7 = 5,
    POLL_HUP___7 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___7 {
    SIGEV_SIGNAL___7 = 0,
    SIGEV_NONE___7 = 1,
    SIGEV_THREAD___7 = 2,
    SIGEV_THREAD_ID___7 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___7 {
    SS_ONSTACK___7 = 1,
    SS_DISABLE___7 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___7 {
    EFD_SEMAPHORE___7 = 1,
    EFD_CLOEXEC___7 = 524288,
    EFD_NONBLOCK___7 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___8 {
    _PC_LINK_MAX___8 = 0,
    _PC_MAX_CANON___8 = 1,
    _PC_MAX_INPUT___8 = 2,
    _PC_NAME_MAX___8 = 3,
    _PC_PATH_MAX___8 = 4,
    _PC_PIPE_BUF___8 = 5,
    _PC_CHOWN_RESTRICTED___8 = 6,
    _PC_NO_TRUNC___8 = 7,
    _PC_VDISABLE___8 = 8,
    _PC_SYNC_IO___8 = 9,
    _PC_ASYNC_IO___8 = 10,
    _PC_PRIO_IO___8 = 11,
    _PC_SOCK_MAXBUF___8 = 12,
    _PC_FILESIZEBITS___8 = 13,
    _PC_REC_INCR_XFER_SIZE___8 = 14,
    _PC_REC_MAX_XFER_SIZE___8 = 15,
    _PC_REC_MIN_XFER_SIZE___8 = 16,
    _PC_REC_XFER_ALIGN___8 = 17,
    _PC_ALLOC_SIZE_MIN___8 = 18,
    _PC_SYMLINK_MAX___8 = 19,
    _PC_2_SYMLINKS___8 = 20
} ;
#line 71
enum __anonenum__20___8 {
    _SC_ARG_MAX___8 = 0,
    _SC_CHILD_MAX___8 = 1,
    _SC_CLK_TCK___8 = 2,
    _SC_NGROUPS_MAX___8 = 3,
    _SC_OPEN_MAX___8 = 4,
    _SC_STREAM_MAX___8 = 5,
    _SC_TZNAME_MAX___8 = 6,
    _SC_JOB_CONTROL___8 = 7,
    _SC_SAVED_IDS___8 = 8,
    _SC_REALTIME_SIGNALS___8 = 9,
    _SC_PRIORITY_SCHEDULING___8 = 10,
    _SC_TIMERS___8 = 11,
    _SC_ASYNCHRONOUS_IO___8 = 12,
    _SC_PRIORITIZED_IO___8 = 13,
    _SC_SYNCHRONIZED_IO___8 = 14,
    _SC_FSYNC___8 = 15,
    _SC_MAPPED_FILES___8 = 16,
    _SC_MEMLOCK___8 = 17,
    _SC_MEMLOCK_RANGE___8 = 18,
    _SC_MEMORY_PROTECTION___8 = 19,
    _SC_MESSAGE_PASSING___8 = 20,
    _SC_SEMAPHORES___8 = 21,
    _SC_SHARED_MEMORY_OBJECTS___8 = 22,
    _SC_AIO_LISTIO_MAX___8 = 23,
    _SC_AIO_MAX___8 = 24,
    _SC_AIO_PRIO_DELTA_MAX___8 = 25,
    _SC_DELAYTIMER_MAX___8 = 26,
    _SC_MQ_OPEN_MAX___8 = 27,
    _SC_MQ_PRIO_MAX___8 = 28,
    _SC_VERSION___8 = 29,
    _SC_PAGESIZE___8 = 30,
    _SC_RTSIG_MAX___8 = 31,
    _SC_SEM_NSEMS_MAX___8 = 32,
    _SC_SEM_VALUE_MAX___8 = 33,
    _SC_SIGQUEUE_MAX___8 = 34,
    _SC_TIMER_MAX___8 = 35,
    _SC_BC_BASE_MAX___8 = 36,
    _SC_BC_DIM_MAX___8 = 37,
    _SC_BC_SCALE_MAX___8 = 38,
    _SC_BC_STRING_MAX___8 = 39,
    _SC_COLL_WEIGHTS_MAX___8 = 40,
    _SC_EQUIV_CLASS_MAX___8 = 41,
    _SC_EXPR_NEST_MAX___8 = 42,
    _SC_LINE_MAX___8 = 43,
    _SC_RE_DUP_MAX___8 = 44,
    _SC_CHARCLASS_NAME_MAX___8 = 45,
    _SC_2_VERSION___8 = 46,
    _SC_2_C_BIND___8 = 47,
    _SC_2_C_DEV___8 = 48,
    _SC_2_FORT_DEV___8 = 49,
    _SC_2_FORT_RUN___8 = 50,
    _SC_2_SW_DEV___8 = 51,
    _SC_2_LOCALEDEF___8 = 52,
    _SC_PII___8 = 53,
    _SC_PII_XTI___8 = 54,
    _SC_PII_SOCKET___8 = 55,
    _SC_PII_INTERNET___8 = 56,
    _SC_PII_OSI___8 = 57,
    _SC_POLL___8 = 58,
    _SC_SELECT___8 = 59,
    _SC_UIO_MAXIOV___8 = 60,
    _SC_IOV_MAX___8 = 60,
    _SC_PII_INTERNET_STREAM___8 = 61,
    _SC_PII_INTERNET_DGRAM___8 = 62,
    _SC_PII_OSI_COTS___8 = 63,
    _SC_PII_OSI_CLTS___8 = 64,
    _SC_PII_OSI_M___8 = 65,
    _SC_T_IOV_MAX___8 = 66,
    _SC_THREADS___8 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___8 = 68,
    _SC_GETGR_R_SIZE_MAX___8 = 69,
    _SC_GETPW_R_SIZE_MAX___8 = 70,
    _SC_LOGIN_NAME_MAX___8 = 71,
    _SC_TTY_NAME_MAX___8 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___8 = 73,
    _SC_THREAD_KEYS_MAX___8 = 74,
    _SC_THREAD_STACK_MIN___8 = 75,
    _SC_THREAD_THREADS_MAX___8 = 76,
    _SC_THREAD_ATTR_STACKADDR___8 = 77,
    _SC_THREAD_ATTR_STACKSIZE___8 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___8 = 79,
    _SC_THREAD_PRIO_INHERIT___8 = 80,
    _SC_THREAD_PRIO_PROTECT___8 = 81,
    _SC_THREAD_PROCESS_SHARED___8 = 82,
    _SC_NPROCESSORS_CONF___8 = 83,
    _SC_NPROCESSORS_ONLN___8 = 84,
    _SC_PHYS_PAGES___8 = 85,
    _SC_AVPHYS_PAGES___8 = 86,
    _SC_ATEXIT_MAX___8 = 87,
    _SC_PASS_MAX___8 = 88,
    _SC_XOPEN_VERSION___8 = 89,
    _SC_XOPEN_XCU_VERSION___8 = 90,
    _SC_XOPEN_UNIX___8 = 91,
    _SC_XOPEN_CRYPT___8 = 92,
    _SC_XOPEN_ENH_I18N___8 = 93,
    _SC_XOPEN_SHM___8 = 94,
    _SC_2_CHAR_TERM___8 = 95,
    _SC_2_C_VERSION___8 = 96,
    _SC_2_UPE___8 = 97,
    _SC_XOPEN_XPG2___8 = 98,
    _SC_XOPEN_XPG3___8 = 99,
    _SC_XOPEN_XPG4___8 = 100,
    _SC_CHAR_BIT___8 = 101,
    _SC_CHAR_MAX___8 = 102,
    _SC_CHAR_MIN___8 = 103,
    _SC_INT_MAX___8 = 104,
    _SC_INT_MIN___8 = 105,
    _SC_LONG_BIT___8 = 106,
    _SC_WORD_BIT___8 = 107,
    _SC_MB_LEN_MAX___8 = 108,
    _SC_NZERO___8 = 109,
    _SC_SSIZE_MAX___8 = 110,
    _SC_SCHAR_MAX___8 = 111,
    _SC_SCHAR_MIN___8 = 112,
    _SC_SHRT_MAX___8 = 113,
    _SC_SHRT_MIN___8 = 114,
    _SC_UCHAR_MAX___8 = 115,
    _SC_UINT_MAX___8 = 116,
    _SC_ULONG_MAX___8 = 117,
    _SC_USHRT_MAX___8 = 118,
    _SC_NL_ARGMAX___8 = 119,
    _SC_NL_LANGMAX___8 = 120,
    _SC_NL_MSGMAX___8 = 121,
    _SC_NL_NMAX___8 = 122,
    _SC_NL_SETMAX___8 = 123,
    _SC_NL_TEXTMAX___8 = 124,
    _SC_XBS5_ILP32_OFF32___8 = 125,
    _SC_XBS5_ILP32_OFFBIG___8 = 126,
    _SC_XBS5_LP64_OFF64___8 = 127,
    _SC_XBS5_LPBIG_OFFBIG___8 = 128,
    _SC_XOPEN_LEGACY___8 = 129,
    _SC_XOPEN_REALTIME___8 = 130,
    _SC_XOPEN_REALTIME_THREADS___8 = 131,
    _SC_ADVISORY_INFO___8 = 132,
    _SC_BARRIERS___8 = 133,
    _SC_BASE___8 = 134,
    _SC_C_LANG_SUPPORT___8 = 135,
    _SC_C_LANG_SUPPORT_R___8 = 136,
    _SC_CLOCK_SELECTION___8 = 137,
    _SC_CPUTIME___8 = 138,
    _SC_THREAD_CPUTIME___8 = 139,
    _SC_DEVICE_IO___8 = 140,
    _SC_DEVICE_SPECIFIC___8 = 141,
    _SC_DEVICE_SPECIFIC_R___8 = 142,
    _SC_FD_MGMT___8 = 143,
    _SC_FIFO___8 = 144,
    _SC_PIPE___8 = 145,
    _SC_FILE_ATTRIBUTES___8 = 146,
    _SC_FILE_LOCKING___8 = 147,
    _SC_FILE_SYSTEM___8 = 148,
    _SC_MONOTONIC_CLOCK___8 = 149,
    _SC_MULTI_PROCESS___8 = 150,
    _SC_SINGLE_PROCESS___8 = 151,
    _SC_NETWORKING___8 = 152,
    _SC_READER_WRITER_LOCKS___8 = 153,
    _SC_SPIN_LOCKS___8 = 154,
    _SC_REGEXP___8 = 155,
    _SC_REGEX_VERSION___8 = 156,
    _SC_SHELL___8 = 157,
    _SC_SIGNALS___8 = 158,
    _SC_SPAWN___8 = 159,
    _SC_SPORADIC_SERVER___8 = 160,
    _SC_THREAD_SPORADIC_SERVER___8 = 161,
    _SC_SYSTEM_DATABASE___8 = 162,
    _SC_SYSTEM_DATABASE_R___8 = 163,
    _SC_TIMEOUTS___8 = 164,
    _SC_TYPED_MEMORY_OBJECTS___8 = 165,
    _SC_USER_GROUPS___8 = 166,
    _SC_USER_GROUPS_R___8 = 167,
    _SC_2_PBS___8 = 168,
    _SC_2_PBS_ACCOUNTING___8 = 169,
    _SC_2_PBS_LOCATE___8 = 170,
    _SC_2_PBS_MESSAGE___8 = 171,
    _SC_2_PBS_TRACK___8 = 172,
    _SC_SYMLOOP_MAX___8 = 173,
    _SC_STREAMS___8 = 174,
    _SC_2_PBS_CHECKPOINT___8 = 175,
    _SC_V6_ILP32_OFF32___8 = 176,
    _SC_V6_ILP32_OFFBIG___8 = 177,
    _SC_V6_LP64_OFF64___8 = 178,
    _SC_V6_LPBIG_OFFBIG___8 = 179,
    _SC_HOST_NAME_MAX___8 = 180,
    _SC_TRACE___8 = 181,
    _SC_TRACE_EVENT_FILTER___8 = 182,
    _SC_TRACE_INHERIT___8 = 183,
    _SC_TRACE_LOG___8 = 184,
    _SC_LEVEL1_ICACHE_SIZE___8 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___8 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___8 = 187,
    _SC_LEVEL1_DCACHE_SIZE___8 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___8 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___8 = 190,
    _SC_LEVEL2_CACHE_SIZE___8 = 191,
    _SC_LEVEL2_CACHE_ASSOC___8 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___8 = 193,
    _SC_LEVEL3_CACHE_SIZE___8 = 194,
    _SC_LEVEL3_CACHE_ASSOC___8 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___8 = 196,
    _SC_LEVEL4_CACHE_SIZE___8 = 197,
    _SC_LEVEL4_CACHE_ASSOC___8 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___8 = 199,
    _SC_IPV6___8 = 235,
    _SC_RAW_SOCKETS___8 = 236,
    _SC_V7_ILP32_OFF32___8 = 237,
    _SC_V7_ILP32_OFFBIG___8 = 238,
    _SC_V7_LP64_OFF64___8 = 239,
    _SC_V7_LPBIG_OFFBIG___8 = 240,
    _SC_SS_REPL_MAX___8 = 241,
    _SC_TRACE_EVENT_NAME_MAX___8 = 242,
    _SC_TRACE_NAME_MAX___8 = 243,
    _SC_TRACE_SYS_MAX___8 = 244,
    _SC_TRACE_USER_EVENT_MAX___8 = 245,
    _SC_XOPEN_STREAMS___8 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___8 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___8 = 248,
    _SC_MINSIGSTKSZ___8 = 249,
    _SC_SIGSTKSZ___8 = 250
} ;
#line 539
enum __anonenum__21___8 {
    _CS_PATH___8 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___8 = 1,
    _CS_GNU_LIBC_VERSION___8 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___8 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___8 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___8 = 5,
    _CS_LFS_CFLAGS___8 = 1000,
    _CS_LFS_LDFLAGS___8 = 1001,
    _CS_LFS_LIBS___8 = 1002,
    _CS_LFS_LINTFLAGS___8 = 1003,
    _CS_LFS64_CFLAGS___8 = 1004,
    _CS_LFS64_LDFLAGS___8 = 1005,
    _CS_LFS64_LIBS___8 = 1006,
    _CS_LFS64_LINTFLAGS___8 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___8 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___8 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___8 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___8 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___8 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___8 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___8 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___8 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___8 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___8 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___8 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___8 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___8 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___8 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___8 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___8 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___8 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___8 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___8 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___8 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___8 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___8 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___8 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___8 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___8 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___8 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___8 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___8 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___8 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___8 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___8 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___8 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___8 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___8 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___8 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___8 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___8 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___8 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___8 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___8 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___8 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___8 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___8 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___8 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___8 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___8 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___8 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___8 = 1147,
    _CS_V6_ENV___8 = 1148,
    _CS_V7_ENV___8 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___8 {
    MSG_OOB___8 = 1,
    MSG_PEEK___8 = 2,
    MSG_DONTROUTE___8 = 4,
    MSG_CTRUNC___8 = 8,
    MSG_PROXY___8 = 16,
    MSG_TRUNC___8 = 32,
    MSG_DONTWAIT___8 = 64,
    MSG_EOR___8 = 128,
    MSG_WAITALL___8 = 256,
    MSG_FIN___8 = 512,
    MSG_SYN___8 = 1024,
    MSG_CONFIRM___8 = 2048,
    MSG_RST___8 = 4096,
    MSG_ERRQUEUE___8 = 8192,
    MSG_NOSIGNAL___8 = 16384,
    MSG_MORE___8 = 32768,
    MSG_WAITFORONE___8 = 65536,
    MSG_BATCH___8 = 262144,
    MSG_ZEROCOPY___8 = 67108864,
    MSG_FASTOPEN___8 = 536870912,
    MSG_CMSG_CLOEXEC___8 = 1073741824
} ;
#line 334
enum __anonenum__23___8 {
    SCM_RIGHTS___8 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___8 {
    SHUT_RD___8 = 0,
    SHUT_WR___8 = 1,
    SHUT_RDWR___8 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___8 {
    IPPROTO_IP___8 = 0,
    IPPROTO_ICMP___8 = 1,
    IPPROTO_IGMP___8 = 2,
    IPPROTO_IPIP___8 = 4,
    IPPROTO_TCP___8 = 6,
    IPPROTO_EGP___8 = 8,
    IPPROTO_PUP___8 = 12,
    IPPROTO_UDP___8 = 17,
    IPPROTO_IDP___8 = 22,
    IPPROTO_TP___8 = 29,
    IPPROTO_DCCP___8 = 33,
    IPPROTO_IPV6___8 = 41,
    IPPROTO_RSVP___8 = 46,
    IPPROTO_GRE___8 = 47,
    IPPROTO_ESP___8 = 50,
    IPPROTO_AH___8 = 51,
    IPPROTO_MTP___8 = 92,
    IPPROTO_BEETPH___8 = 94,
    IPPROTO_ENCAP___8 = 98,
    IPPROTO_PIM___8 = 103,
    IPPROTO_COMP___8 = 108,
    IPPROTO_SCTP___8 = 132,
    IPPROTO_UDPLITE___8 = 136,
    IPPROTO_MPLS___8 = 137,
    IPPROTO_ETHERNET___8 = 143,
    IPPROTO_RAW___8 = 255,
    IPPROTO_MPTCP___8 = 262,
    IPPROTO_MAX___8 = 263
} ;
#line 103
enum __anonenum__28___8 {
    IPPROTO_HOPOPTS___8 = 0,
    IPPROTO_ROUTING___8 = 43,
    IPPROTO_FRAGMENT___8 = 44,
    IPPROTO_ICMPV6___8 = 58,
    IPPROTO_NONE___8 = 59,
    IPPROTO_DSTOPTS___8 = 60,
    IPPROTO_MH___8 = 135
} ;
#line 126
enum __anonenum__29___8 {
    IPPORT_ECHO___8 = 7,
    IPPORT_DISCARD___8 = 9,
    IPPORT_SYSTAT___8 = 11,
    IPPORT_DAYTIME___8 = 13,
    IPPORT_NETSTAT___8 = 15,
    IPPORT_FTP___8 = 21,
    IPPORT_TELNET___8 = 23,
    IPPORT_SMTP___8 = 25,
    IPPORT_TIMESERVER___8 = 37,
    IPPORT_NAMESERVER___8 = 42,
    IPPORT_WHOIS___8 = 43,
    IPPORT_MTP___8 = 57,
    IPPORT_TFTP___8 = 69,
    IPPORT_RJE___8 = 77,
    IPPORT_FINGER___8 = 79,
    IPPORT_TTYLINK___8 = 87,
    IPPORT_SUPDUP___8 = 95,
    IPPORT_EXECSERVER___8 = 512,
    IPPORT_LOGINSERVER___8 = 513,
    IPPORT_CMDSERVER___8 = 514,
    IPPORT_EFSSERVER___8 = 520,
    IPPORT_BIFFUDP___8 = 512,
    IPPORT_WHOSERVER___8 = 513,
    IPPORT_ROUTESERVER___8 = 520,
    IPPORT_RESERVED___8 = 1024,
    IPPORT_USERRESERVED___8 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___8 {
    PTHREAD_CREATE_JOINABLE___8 = 0,
    PTHREAD_CREATE_DETACHED___8 = 1
} ;
#line 47
enum __anonenum__33___8 {
    PTHREAD_MUTEX_TIMED_NP___8 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___8 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___8 = 3,
    PTHREAD_MUTEX_NORMAL___8 = 0,
    PTHREAD_MUTEX_RECURSIVE___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK___8 = 2,
    PTHREAD_MUTEX_DEFAULT___8 = 0
} ;
#line 69
enum __anonenum__34___8 {
    PTHREAD_MUTEX_STALLED___8 = 0,
    PTHREAD_MUTEX_STALLED_NP___8 = 0,
    PTHREAD_MUTEX_ROBUST___8 = 1,
    PTHREAD_MUTEX_ROBUST_NP___8 = 1
} ;
#line 81
enum __anonenum__35___8 {
    PTHREAD_PRIO_NONE___8 = 0,
    PTHREAD_PRIO_INHERIT___8 = 1,
    PTHREAD_PRIO_PROTECT___8 = 2
} ;
#line 104
enum __anonenum__36___8 {
    PTHREAD_RWLOCK_PREFER_READER_NP___8 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___8 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___8 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___8 = 0
} ;
#line 124
enum __anonenum__37___8 {
    PTHREAD_INHERIT_SCHED___8 = 0,
    PTHREAD_EXPLICIT_SCHED___8 = 1
} ;
#line 134
enum __anonenum__38___8 {
    PTHREAD_SCOPE_SYSTEM___8 = 0,
    PTHREAD_SCOPE_PROCESS___8 = 1
} ;
#line 144
enum __anonenum__39___8 {
    PTHREAD_PROCESS_PRIVATE___8 = 0,
    PTHREAD_PROCESS_SHARED___8 = 1
} ;
#line 168
enum __anonenum__40___8 {
    PTHREAD_CANCEL_ENABLE___8 = 0,
    PTHREAD_CANCEL_DISABLE___8 = 1
} ;
#line 175
enum __anonenum__41___8 {
    PTHREAD_CANCEL_DEFERRED___8 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___8 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___8 {
    SI_ASYNCNL___8 = -60,
    SI_DETHREAD___8 = -7,
    SI_TKILL___8 = -6,
    SI_SIGIO___8 = -5,
    SI_ASYNCIO___8 = -4,
    SI_MESGQ___8 = -3,
    SI_TIMER___8 = -2,
    SI_QUEUE___8 = -1,
    SI_USER___8 = 0,
    SI_KERNEL___8 = 128
} ;
#line 71
enum __anonenum__55___8 {
    ILL_ILLOPC___8 = 1,
    ILL_ILLOPN___8 = 2,
    ILL_ILLADR___8 = 3,
    ILL_ILLTRP___8 = 4,
    ILL_PRVOPC___8 = 5,
    ILL_PRVREG___8 = 6,
    ILL_COPROC___8 = 7,
    ILL_BADSTK___8 = 8,
    ILL_BADIADDR___8 = 9
} ;
#line 94
enum __anonenum__56___8 {
    FPE_INTDIV___8 = 1,
    FPE_INTOVF___8 = 2,
    FPE_FLTDIV___8 = 3,
    FPE_FLTOVF___8 = 4,
    FPE_FLTUND___8 = 5,
    FPE_FLTRES___8 = 6,
    FPE_FLTINV___8 = 7,
    FPE_FLTSUB___8 = 8,
    FPE_FLTUNK___8 = 14,
    FPE_CONDTRAP___8 = 15
} ;
#line 119
enum __anonenum__57___8 {
    SEGV_MAPERR___8 = 1,
    SEGV_ACCERR___8 = 2,
    SEGV_BNDERR___8 = 3,
    SEGV_PKUERR___8 = 4,
    SEGV_ACCADI___8 = 5,
    SEGV_ADIDERR___8 = 6,
    SEGV_ADIPERR___8 = 7,
    SEGV_MTEAERR___8 = 8,
    SEGV_MTESERR___8 = 9
} ;
#line 142
enum __anonenum__58___8 {
    BUS_ADRALN___8 = 1,
    BUS_ADRERR___8 = 2,
    BUS_OBJERR___8 = 3,
    BUS_MCEERR_AR___8 = 4,
    BUS_MCEERR_AO___8 = 5
} ;
#line 176
enum __anonenum__59___8 {
    CLD_EXITED___8 = 1,
    CLD_KILLED___8 = 2,
    CLD_DUMPED___8 = 3,
    CLD_TRAPPED___8 = 4,
    CLD_STOPPED___8 = 5,
    CLD_CONTINUED___8 = 6
} ;
#line 193
enum __anonenum__60___8 {
    POLL_IN___8 = 1,
    POLL_OUT___8 = 2,
    POLL_MSG___8 = 3,
    POLL_ERR___8 = 4,
    POLL_PRI___8 = 5,
    POLL_HUP___8 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___8 {
    SIGEV_SIGNAL___8 = 0,
    SIGEV_NONE___8 = 1,
    SIGEV_THREAD___8 = 2,
    SIGEV_THREAD_ID___8 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___8 {
    SS_ONSTACK___8 = 1,
    SS_DISABLE___8 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___8 {
    EFD_SEMAPHORE___8 = 1,
    EFD_CLOEXEC___8 = 524288,
    EFD_NONBLOCK___8 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___9 {
    _PC_LINK_MAX___9 = 0,
    _PC_MAX_CANON___9 = 1,
    _PC_MAX_INPUT___9 = 2,
    _PC_NAME_MAX___9 = 3,
    _PC_PATH_MAX___9 = 4,
    _PC_PIPE_BUF___9 = 5,
    _PC_CHOWN_RESTRICTED___9 = 6,
    _PC_NO_TRUNC___9 = 7,
    _PC_VDISABLE___9 = 8,
    _PC_SYNC_IO___9 = 9,
    _PC_ASYNC_IO___9 = 10,
    _PC_PRIO_IO___9 = 11,
    _PC_SOCK_MAXBUF___9 = 12,
    _PC_FILESIZEBITS___9 = 13,
    _PC_REC_INCR_XFER_SIZE___9 = 14,
    _PC_REC_MAX_XFER_SIZE___9 = 15,
    _PC_REC_MIN_XFER_SIZE___9 = 16,
    _PC_REC_XFER_ALIGN___9 = 17,
    _PC_ALLOC_SIZE_MIN___9 = 18,
    _PC_SYMLINK_MAX___9 = 19,
    _PC_2_SYMLINKS___9 = 20
} ;
#line 71
enum __anonenum__20___9 {
    _SC_ARG_MAX___9 = 0,
    _SC_CHILD_MAX___9 = 1,
    _SC_CLK_TCK___9 = 2,
    _SC_NGROUPS_MAX___9 = 3,
    _SC_OPEN_MAX___9 = 4,
    _SC_STREAM_MAX___9 = 5,
    _SC_TZNAME_MAX___9 = 6,
    _SC_JOB_CONTROL___9 = 7,
    _SC_SAVED_IDS___9 = 8,
    _SC_REALTIME_SIGNALS___9 = 9,
    _SC_PRIORITY_SCHEDULING___9 = 10,
    _SC_TIMERS___9 = 11,
    _SC_ASYNCHRONOUS_IO___9 = 12,
    _SC_PRIORITIZED_IO___9 = 13,
    _SC_SYNCHRONIZED_IO___9 = 14,
    _SC_FSYNC___9 = 15,
    _SC_MAPPED_FILES___9 = 16,
    _SC_MEMLOCK___9 = 17,
    _SC_MEMLOCK_RANGE___9 = 18,
    _SC_MEMORY_PROTECTION___9 = 19,
    _SC_MESSAGE_PASSING___9 = 20,
    _SC_SEMAPHORES___9 = 21,
    _SC_SHARED_MEMORY_OBJECTS___9 = 22,
    _SC_AIO_LISTIO_MAX___9 = 23,
    _SC_AIO_MAX___9 = 24,
    _SC_AIO_PRIO_DELTA_MAX___9 = 25,
    _SC_DELAYTIMER_MAX___9 = 26,
    _SC_MQ_OPEN_MAX___9 = 27,
    _SC_MQ_PRIO_MAX___9 = 28,
    _SC_VERSION___9 = 29,
    _SC_PAGESIZE___9 = 30,
    _SC_RTSIG_MAX___9 = 31,
    _SC_SEM_NSEMS_MAX___9 = 32,
    _SC_SEM_VALUE_MAX___9 = 33,
    _SC_SIGQUEUE_MAX___9 = 34,
    _SC_TIMER_MAX___9 = 35,
    _SC_BC_BASE_MAX___9 = 36,
    _SC_BC_DIM_MAX___9 = 37,
    _SC_BC_SCALE_MAX___9 = 38,
    _SC_BC_STRING_MAX___9 = 39,
    _SC_COLL_WEIGHTS_MAX___9 = 40,
    _SC_EQUIV_CLASS_MAX___9 = 41,
    _SC_EXPR_NEST_MAX___9 = 42,
    _SC_LINE_MAX___9 = 43,
    _SC_RE_DUP_MAX___9 = 44,
    _SC_CHARCLASS_NAME_MAX___9 = 45,
    _SC_2_VERSION___9 = 46,
    _SC_2_C_BIND___9 = 47,
    _SC_2_C_DEV___9 = 48,
    _SC_2_FORT_DEV___9 = 49,
    _SC_2_FORT_RUN___9 = 50,
    _SC_2_SW_DEV___9 = 51,
    _SC_2_LOCALEDEF___9 = 52,
    _SC_PII___9 = 53,
    _SC_PII_XTI___9 = 54,
    _SC_PII_SOCKET___9 = 55,
    _SC_PII_INTERNET___9 = 56,
    _SC_PII_OSI___9 = 57,
    _SC_POLL___9 = 58,
    _SC_SELECT___9 = 59,
    _SC_UIO_MAXIOV___9 = 60,
    _SC_IOV_MAX___9 = 60,
    _SC_PII_INTERNET_STREAM___9 = 61,
    _SC_PII_INTERNET_DGRAM___9 = 62,
    _SC_PII_OSI_COTS___9 = 63,
    _SC_PII_OSI_CLTS___9 = 64,
    _SC_PII_OSI_M___9 = 65,
    _SC_T_IOV_MAX___9 = 66,
    _SC_THREADS___9 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___9 = 68,
    _SC_GETGR_R_SIZE_MAX___9 = 69,
    _SC_GETPW_R_SIZE_MAX___9 = 70,
    _SC_LOGIN_NAME_MAX___9 = 71,
    _SC_TTY_NAME_MAX___9 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___9 = 73,
    _SC_THREAD_KEYS_MAX___9 = 74,
    _SC_THREAD_STACK_MIN___9 = 75,
    _SC_THREAD_THREADS_MAX___9 = 76,
    _SC_THREAD_ATTR_STACKADDR___9 = 77,
    _SC_THREAD_ATTR_STACKSIZE___9 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___9 = 79,
    _SC_THREAD_PRIO_INHERIT___9 = 80,
    _SC_THREAD_PRIO_PROTECT___9 = 81,
    _SC_THREAD_PROCESS_SHARED___9 = 82,
    _SC_NPROCESSORS_CONF___9 = 83,
    _SC_NPROCESSORS_ONLN___9 = 84,
    _SC_PHYS_PAGES___9 = 85,
    _SC_AVPHYS_PAGES___9 = 86,
    _SC_ATEXIT_MAX___9 = 87,
    _SC_PASS_MAX___9 = 88,
    _SC_XOPEN_VERSION___9 = 89,
    _SC_XOPEN_XCU_VERSION___9 = 90,
    _SC_XOPEN_UNIX___9 = 91,
    _SC_XOPEN_CRYPT___9 = 92,
    _SC_XOPEN_ENH_I18N___9 = 93,
    _SC_XOPEN_SHM___9 = 94,
    _SC_2_CHAR_TERM___9 = 95,
    _SC_2_C_VERSION___9 = 96,
    _SC_2_UPE___9 = 97,
    _SC_XOPEN_XPG2___9 = 98,
    _SC_XOPEN_XPG3___9 = 99,
    _SC_XOPEN_XPG4___9 = 100,
    _SC_CHAR_BIT___9 = 101,
    _SC_CHAR_MAX___9 = 102,
    _SC_CHAR_MIN___9 = 103,
    _SC_INT_MAX___9 = 104,
    _SC_INT_MIN___9 = 105,
    _SC_LONG_BIT___9 = 106,
    _SC_WORD_BIT___9 = 107,
    _SC_MB_LEN_MAX___9 = 108,
    _SC_NZERO___9 = 109,
    _SC_SSIZE_MAX___9 = 110,
    _SC_SCHAR_MAX___9 = 111,
    _SC_SCHAR_MIN___9 = 112,
    _SC_SHRT_MAX___9 = 113,
    _SC_SHRT_MIN___9 = 114,
    _SC_UCHAR_MAX___9 = 115,
    _SC_UINT_MAX___9 = 116,
    _SC_ULONG_MAX___9 = 117,
    _SC_USHRT_MAX___9 = 118,
    _SC_NL_ARGMAX___9 = 119,
    _SC_NL_LANGMAX___9 = 120,
    _SC_NL_MSGMAX___9 = 121,
    _SC_NL_NMAX___9 = 122,
    _SC_NL_SETMAX___9 = 123,
    _SC_NL_TEXTMAX___9 = 124,
    _SC_XBS5_ILP32_OFF32___9 = 125,
    _SC_XBS5_ILP32_OFFBIG___9 = 126,
    _SC_XBS5_LP64_OFF64___9 = 127,
    _SC_XBS5_LPBIG_OFFBIG___9 = 128,
    _SC_XOPEN_LEGACY___9 = 129,
    _SC_XOPEN_REALTIME___9 = 130,
    _SC_XOPEN_REALTIME_THREADS___9 = 131,
    _SC_ADVISORY_INFO___9 = 132,
    _SC_BARRIERS___9 = 133,
    _SC_BASE___9 = 134,
    _SC_C_LANG_SUPPORT___9 = 135,
    _SC_C_LANG_SUPPORT_R___9 = 136,
    _SC_CLOCK_SELECTION___9 = 137,
    _SC_CPUTIME___9 = 138,
    _SC_THREAD_CPUTIME___9 = 139,
    _SC_DEVICE_IO___9 = 140,
    _SC_DEVICE_SPECIFIC___9 = 141,
    _SC_DEVICE_SPECIFIC_R___9 = 142,
    _SC_FD_MGMT___9 = 143,
    _SC_FIFO___9 = 144,
    _SC_PIPE___9 = 145,
    _SC_FILE_ATTRIBUTES___9 = 146,
    _SC_FILE_LOCKING___9 = 147,
    _SC_FILE_SYSTEM___9 = 148,
    _SC_MONOTONIC_CLOCK___9 = 149,
    _SC_MULTI_PROCESS___9 = 150,
    _SC_SINGLE_PROCESS___9 = 151,
    _SC_NETWORKING___9 = 152,
    _SC_READER_WRITER_LOCKS___9 = 153,
    _SC_SPIN_LOCKS___9 = 154,
    _SC_REGEXP___9 = 155,
    _SC_REGEX_VERSION___9 = 156,
    _SC_SHELL___9 = 157,
    _SC_SIGNALS___9 = 158,
    _SC_SPAWN___9 = 159,
    _SC_SPORADIC_SERVER___9 = 160,
    _SC_THREAD_SPORADIC_SERVER___9 = 161,
    _SC_SYSTEM_DATABASE___9 = 162,
    _SC_SYSTEM_DATABASE_R___9 = 163,
    _SC_TIMEOUTS___9 = 164,
    _SC_TYPED_MEMORY_OBJECTS___9 = 165,
    _SC_USER_GROUPS___9 = 166,
    _SC_USER_GROUPS_R___9 = 167,
    _SC_2_PBS___9 = 168,
    _SC_2_PBS_ACCOUNTING___9 = 169,
    _SC_2_PBS_LOCATE___9 = 170,
    _SC_2_PBS_MESSAGE___9 = 171,
    _SC_2_PBS_TRACK___9 = 172,
    _SC_SYMLOOP_MAX___9 = 173,
    _SC_STREAMS___9 = 174,
    _SC_2_PBS_CHECKPOINT___9 = 175,
    _SC_V6_ILP32_OFF32___9 = 176,
    _SC_V6_ILP32_OFFBIG___9 = 177,
    _SC_V6_LP64_OFF64___9 = 178,
    _SC_V6_LPBIG_OFFBIG___9 = 179,
    _SC_HOST_NAME_MAX___9 = 180,
    _SC_TRACE___9 = 181,
    _SC_TRACE_EVENT_FILTER___9 = 182,
    _SC_TRACE_INHERIT___9 = 183,
    _SC_TRACE_LOG___9 = 184,
    _SC_LEVEL1_ICACHE_SIZE___9 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___9 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___9 = 187,
    _SC_LEVEL1_DCACHE_SIZE___9 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___9 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___9 = 190,
    _SC_LEVEL2_CACHE_SIZE___9 = 191,
    _SC_LEVEL2_CACHE_ASSOC___9 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___9 = 193,
    _SC_LEVEL3_CACHE_SIZE___9 = 194,
    _SC_LEVEL3_CACHE_ASSOC___9 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___9 = 196,
    _SC_LEVEL4_CACHE_SIZE___9 = 197,
    _SC_LEVEL4_CACHE_ASSOC___9 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___9 = 199,
    _SC_IPV6___9 = 235,
    _SC_RAW_SOCKETS___9 = 236,
    _SC_V7_ILP32_OFF32___9 = 237,
    _SC_V7_ILP32_OFFBIG___9 = 238,
    _SC_V7_LP64_OFF64___9 = 239,
    _SC_V7_LPBIG_OFFBIG___9 = 240,
    _SC_SS_REPL_MAX___9 = 241,
    _SC_TRACE_EVENT_NAME_MAX___9 = 242,
    _SC_TRACE_NAME_MAX___9 = 243,
    _SC_TRACE_SYS_MAX___9 = 244,
    _SC_TRACE_USER_EVENT_MAX___9 = 245,
    _SC_XOPEN_STREAMS___9 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___9 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___9 = 248,
    _SC_MINSIGSTKSZ___9 = 249,
    _SC_SIGSTKSZ___9 = 250
} ;
#line 539
enum __anonenum__21___9 {
    _CS_PATH___9 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___9 = 1,
    _CS_GNU_LIBC_VERSION___9 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___9 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___9 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___9 = 5,
    _CS_LFS_CFLAGS___9 = 1000,
    _CS_LFS_LDFLAGS___9 = 1001,
    _CS_LFS_LIBS___9 = 1002,
    _CS_LFS_LINTFLAGS___9 = 1003,
    _CS_LFS64_CFLAGS___9 = 1004,
    _CS_LFS64_LDFLAGS___9 = 1005,
    _CS_LFS64_LIBS___9 = 1006,
    _CS_LFS64_LINTFLAGS___9 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___9 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___9 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___9 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___9 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___9 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___9 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___9 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___9 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___9 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___9 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___9 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___9 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___9 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___9 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___9 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___9 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___9 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___9 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___9 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___9 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___9 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___9 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___9 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___9 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___9 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___9 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___9 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___9 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___9 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___9 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___9 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___9 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___9 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___9 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___9 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___9 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___9 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___9 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___9 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___9 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___9 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___9 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___9 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___9 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___9 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___9 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___9 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___9 = 1147,
    _CS_V6_ENV___9 = 1148,
    _CS_V7_ENV___9 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___9 {
    MSG_OOB___9 = 1,
    MSG_PEEK___9 = 2,
    MSG_DONTROUTE___9 = 4,
    MSG_CTRUNC___9 = 8,
    MSG_PROXY___9 = 16,
    MSG_TRUNC___9 = 32,
    MSG_DONTWAIT___9 = 64,
    MSG_EOR___9 = 128,
    MSG_WAITALL___9 = 256,
    MSG_FIN___9 = 512,
    MSG_SYN___9 = 1024,
    MSG_CONFIRM___9 = 2048,
    MSG_RST___9 = 4096,
    MSG_ERRQUEUE___9 = 8192,
    MSG_NOSIGNAL___9 = 16384,
    MSG_MORE___9 = 32768,
    MSG_WAITFORONE___9 = 65536,
    MSG_BATCH___9 = 262144,
    MSG_ZEROCOPY___9 = 67108864,
    MSG_FASTOPEN___9 = 536870912,
    MSG_CMSG_CLOEXEC___9 = 1073741824
} ;
#line 334
enum __anonenum__23___9 {
    SCM_RIGHTS___9 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___9 {
    SHUT_RD___9 = 0,
    SHUT_WR___9 = 1,
    SHUT_RDWR___9 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___9 {
    IPPROTO_IP___9 = 0,
    IPPROTO_ICMP___9 = 1,
    IPPROTO_IGMP___9 = 2,
    IPPROTO_IPIP___9 = 4,
    IPPROTO_TCP___9 = 6,
    IPPROTO_EGP___9 = 8,
    IPPROTO_PUP___9 = 12,
    IPPROTO_UDP___9 = 17,
    IPPROTO_IDP___9 = 22,
    IPPROTO_TP___9 = 29,
    IPPROTO_DCCP___9 = 33,
    IPPROTO_IPV6___9 = 41,
    IPPROTO_RSVP___9 = 46,
    IPPROTO_GRE___9 = 47,
    IPPROTO_ESP___9 = 50,
    IPPROTO_AH___9 = 51,
    IPPROTO_MTP___9 = 92,
    IPPROTO_BEETPH___9 = 94,
    IPPROTO_ENCAP___9 = 98,
    IPPROTO_PIM___9 = 103,
    IPPROTO_COMP___9 = 108,
    IPPROTO_SCTP___9 = 132,
    IPPROTO_UDPLITE___9 = 136,
    IPPROTO_MPLS___9 = 137,
    IPPROTO_ETHERNET___9 = 143,
    IPPROTO_RAW___9 = 255,
    IPPROTO_MPTCP___9 = 262,
    IPPROTO_MAX___9 = 263
} ;
#line 103
enum __anonenum__28___9 {
    IPPROTO_HOPOPTS___9 = 0,
    IPPROTO_ROUTING___9 = 43,
    IPPROTO_FRAGMENT___9 = 44,
    IPPROTO_ICMPV6___9 = 58,
    IPPROTO_NONE___9 = 59,
    IPPROTO_DSTOPTS___9 = 60,
    IPPROTO_MH___9 = 135
} ;
#line 126
enum __anonenum__29___9 {
    IPPORT_ECHO___9 = 7,
    IPPORT_DISCARD___9 = 9,
    IPPORT_SYSTAT___9 = 11,
    IPPORT_DAYTIME___9 = 13,
    IPPORT_NETSTAT___9 = 15,
    IPPORT_FTP___9 = 21,
    IPPORT_TELNET___9 = 23,
    IPPORT_SMTP___9 = 25,
    IPPORT_TIMESERVER___9 = 37,
    IPPORT_NAMESERVER___9 = 42,
    IPPORT_WHOIS___9 = 43,
    IPPORT_MTP___9 = 57,
    IPPORT_TFTP___9 = 69,
    IPPORT_RJE___9 = 77,
    IPPORT_FINGER___9 = 79,
    IPPORT_TTYLINK___9 = 87,
    IPPORT_SUPDUP___9 = 95,
    IPPORT_EXECSERVER___9 = 512,
    IPPORT_LOGINSERVER___9 = 513,
    IPPORT_CMDSERVER___9 = 514,
    IPPORT_EFSSERVER___9 = 520,
    IPPORT_BIFFUDP___9 = 512,
    IPPORT_WHOSERVER___9 = 513,
    IPPORT_ROUTESERVER___9 = 520,
    IPPORT_RESERVED___9 = 1024,
    IPPORT_USERRESERVED___9 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___9 {
    PTHREAD_CREATE_JOINABLE___9 = 0,
    PTHREAD_CREATE_DETACHED___9 = 1
} ;
#line 47
enum __anonenum__33___9 {
    PTHREAD_MUTEX_TIMED_NP___9 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___9 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___9 = 3,
    PTHREAD_MUTEX_NORMAL___9 = 0,
    PTHREAD_MUTEX_RECURSIVE___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK___9 = 2,
    PTHREAD_MUTEX_DEFAULT___9 = 0
} ;
#line 69
enum __anonenum__34___9 {
    PTHREAD_MUTEX_STALLED___9 = 0,
    PTHREAD_MUTEX_STALLED_NP___9 = 0,
    PTHREAD_MUTEX_ROBUST___9 = 1,
    PTHREAD_MUTEX_ROBUST_NP___9 = 1
} ;
#line 81
enum __anonenum__35___9 {
    PTHREAD_PRIO_NONE___9 = 0,
    PTHREAD_PRIO_INHERIT___9 = 1,
    PTHREAD_PRIO_PROTECT___9 = 2
} ;
#line 104
enum __anonenum__36___9 {
    PTHREAD_RWLOCK_PREFER_READER_NP___9 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___9 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___9 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___9 = 0
} ;
#line 124
enum __anonenum__37___9 {
    PTHREAD_INHERIT_SCHED___9 = 0,
    PTHREAD_EXPLICIT_SCHED___9 = 1
} ;
#line 134
enum __anonenum__38___9 {
    PTHREAD_SCOPE_SYSTEM___9 = 0,
    PTHREAD_SCOPE_PROCESS___9 = 1
} ;
#line 144
enum __anonenum__39___9 {
    PTHREAD_PROCESS_PRIVATE___9 = 0,
    PTHREAD_PROCESS_SHARED___9 = 1
} ;
#line 168
enum __anonenum__40___9 {
    PTHREAD_CANCEL_ENABLE___9 = 0,
    PTHREAD_CANCEL_DISABLE___9 = 1
} ;
#line 175
enum __anonenum__41___9 {
    PTHREAD_CANCEL_DEFERRED___9 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___9 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___9 {
    SI_ASYNCNL___9 = -60,
    SI_DETHREAD___9 = -7,
    SI_TKILL___9 = -6,
    SI_SIGIO___9 = -5,
    SI_ASYNCIO___9 = -4,
    SI_MESGQ___9 = -3,
    SI_TIMER___9 = -2,
    SI_QUEUE___9 = -1,
    SI_USER___9 = 0,
    SI_KERNEL___9 = 128
} ;
#line 71
enum __anonenum__55___9 {
    ILL_ILLOPC___9 = 1,
    ILL_ILLOPN___9 = 2,
    ILL_ILLADR___9 = 3,
    ILL_ILLTRP___9 = 4,
    ILL_PRVOPC___9 = 5,
    ILL_PRVREG___9 = 6,
    ILL_COPROC___9 = 7,
    ILL_BADSTK___9 = 8,
    ILL_BADIADDR___9 = 9
} ;
#line 94
enum __anonenum__56___9 {
    FPE_INTDIV___9 = 1,
    FPE_INTOVF___9 = 2,
    FPE_FLTDIV___9 = 3,
    FPE_FLTOVF___9 = 4,
    FPE_FLTUND___9 = 5,
    FPE_FLTRES___9 = 6,
    FPE_FLTINV___9 = 7,
    FPE_FLTSUB___9 = 8,
    FPE_FLTUNK___9 = 14,
    FPE_CONDTRAP___9 = 15
} ;
#line 119
enum __anonenum__57___9 {
    SEGV_MAPERR___9 = 1,
    SEGV_ACCERR___9 = 2,
    SEGV_BNDERR___9 = 3,
    SEGV_PKUERR___9 = 4,
    SEGV_ACCADI___9 = 5,
    SEGV_ADIDERR___9 = 6,
    SEGV_ADIPERR___9 = 7,
    SEGV_MTEAERR___9 = 8,
    SEGV_MTESERR___9 = 9
} ;
#line 142
enum __anonenum__58___9 {
    BUS_ADRALN___9 = 1,
    BUS_ADRERR___9 = 2,
    BUS_OBJERR___9 = 3,
    BUS_MCEERR_AR___9 = 4,
    BUS_MCEERR_AO___9 = 5
} ;
#line 176
enum __anonenum__59___9 {
    CLD_EXITED___9 = 1,
    CLD_KILLED___9 = 2,
    CLD_DUMPED___9 = 3,
    CLD_TRAPPED___9 = 4,
    CLD_STOPPED___9 = 5,
    CLD_CONTINUED___9 = 6
} ;
#line 193
enum __anonenum__60___9 {
    POLL_IN___9 = 1,
    POLL_OUT___9 = 2,
    POLL_MSG___9 = 3,
    POLL_ERR___9 = 4,
    POLL_PRI___9 = 5,
    POLL_HUP___9 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___9 {
    SIGEV_SIGNAL___9 = 0,
    SIGEV_NONE___9 = 1,
    SIGEV_THREAD___9 = 2,
    SIGEV_THREAD_ID___9 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___9 {
    SS_ONSTACK___9 = 1,
    SS_DISABLE___9 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___9 {
    EFD_SEMAPHORE___9 = 1,
    EFD_CLOEXEC___9 = 524288,
    EFD_NONBLOCK___9 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___10 {
    _PC_LINK_MAX___10 = 0,
    _PC_MAX_CANON___10 = 1,
    _PC_MAX_INPUT___10 = 2,
    _PC_NAME_MAX___10 = 3,
    _PC_PATH_MAX___10 = 4,
    _PC_PIPE_BUF___10 = 5,
    _PC_CHOWN_RESTRICTED___10 = 6,
    _PC_NO_TRUNC___10 = 7,
    _PC_VDISABLE___10 = 8,
    _PC_SYNC_IO___10 = 9,
    _PC_ASYNC_IO___10 = 10,
    _PC_PRIO_IO___10 = 11,
    _PC_SOCK_MAXBUF___10 = 12,
    _PC_FILESIZEBITS___10 = 13,
    _PC_REC_INCR_XFER_SIZE___10 = 14,
    _PC_REC_MAX_XFER_SIZE___10 = 15,
    _PC_REC_MIN_XFER_SIZE___10 = 16,
    _PC_REC_XFER_ALIGN___10 = 17,
    _PC_ALLOC_SIZE_MIN___10 = 18,
    _PC_SYMLINK_MAX___10 = 19,
    _PC_2_SYMLINKS___10 = 20
} ;
#line 71
enum __anonenum__20___10 {
    _SC_ARG_MAX___10 = 0,
    _SC_CHILD_MAX___10 = 1,
    _SC_CLK_TCK___10 = 2,
    _SC_NGROUPS_MAX___10 = 3,
    _SC_OPEN_MAX___10 = 4,
    _SC_STREAM_MAX___10 = 5,
    _SC_TZNAME_MAX___10 = 6,
    _SC_JOB_CONTROL___10 = 7,
    _SC_SAVED_IDS___10 = 8,
    _SC_REALTIME_SIGNALS___10 = 9,
    _SC_PRIORITY_SCHEDULING___10 = 10,
    _SC_TIMERS___10 = 11,
    _SC_ASYNCHRONOUS_IO___10 = 12,
    _SC_PRIORITIZED_IO___10 = 13,
    _SC_SYNCHRONIZED_IO___10 = 14,
    _SC_FSYNC___10 = 15,
    _SC_MAPPED_FILES___10 = 16,
    _SC_MEMLOCK___10 = 17,
    _SC_MEMLOCK_RANGE___10 = 18,
    _SC_MEMORY_PROTECTION___10 = 19,
    _SC_MESSAGE_PASSING___10 = 20,
    _SC_SEMAPHORES___10 = 21,
    _SC_SHARED_MEMORY_OBJECTS___10 = 22,
    _SC_AIO_LISTIO_MAX___10 = 23,
    _SC_AIO_MAX___10 = 24,
    _SC_AIO_PRIO_DELTA_MAX___10 = 25,
    _SC_DELAYTIMER_MAX___10 = 26,
    _SC_MQ_OPEN_MAX___10 = 27,
    _SC_MQ_PRIO_MAX___10 = 28,
    _SC_VERSION___10 = 29,
    _SC_PAGESIZE___10 = 30,
    _SC_RTSIG_MAX___10 = 31,
    _SC_SEM_NSEMS_MAX___10 = 32,
    _SC_SEM_VALUE_MAX___10 = 33,
    _SC_SIGQUEUE_MAX___10 = 34,
    _SC_TIMER_MAX___10 = 35,
    _SC_BC_BASE_MAX___10 = 36,
    _SC_BC_DIM_MAX___10 = 37,
    _SC_BC_SCALE_MAX___10 = 38,
    _SC_BC_STRING_MAX___10 = 39,
    _SC_COLL_WEIGHTS_MAX___10 = 40,
    _SC_EQUIV_CLASS_MAX___10 = 41,
    _SC_EXPR_NEST_MAX___10 = 42,
    _SC_LINE_MAX___10 = 43,
    _SC_RE_DUP_MAX___10 = 44,
    _SC_CHARCLASS_NAME_MAX___10 = 45,
    _SC_2_VERSION___10 = 46,
    _SC_2_C_BIND___10 = 47,
    _SC_2_C_DEV___10 = 48,
    _SC_2_FORT_DEV___10 = 49,
    _SC_2_FORT_RUN___10 = 50,
    _SC_2_SW_DEV___10 = 51,
    _SC_2_LOCALEDEF___10 = 52,
    _SC_PII___10 = 53,
    _SC_PII_XTI___10 = 54,
    _SC_PII_SOCKET___10 = 55,
    _SC_PII_INTERNET___10 = 56,
    _SC_PII_OSI___10 = 57,
    _SC_POLL___10 = 58,
    _SC_SELECT___10 = 59,
    _SC_UIO_MAXIOV___10 = 60,
    _SC_IOV_MAX___10 = 60,
    _SC_PII_INTERNET_STREAM___10 = 61,
    _SC_PII_INTERNET_DGRAM___10 = 62,
    _SC_PII_OSI_COTS___10 = 63,
    _SC_PII_OSI_CLTS___10 = 64,
    _SC_PII_OSI_M___10 = 65,
    _SC_T_IOV_MAX___10 = 66,
    _SC_THREADS___10 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___10 = 68,
    _SC_GETGR_R_SIZE_MAX___10 = 69,
    _SC_GETPW_R_SIZE_MAX___10 = 70,
    _SC_LOGIN_NAME_MAX___10 = 71,
    _SC_TTY_NAME_MAX___10 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___10 = 73,
    _SC_THREAD_KEYS_MAX___10 = 74,
    _SC_THREAD_STACK_MIN___10 = 75,
    _SC_THREAD_THREADS_MAX___10 = 76,
    _SC_THREAD_ATTR_STACKADDR___10 = 77,
    _SC_THREAD_ATTR_STACKSIZE___10 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___10 = 79,
    _SC_THREAD_PRIO_INHERIT___10 = 80,
    _SC_THREAD_PRIO_PROTECT___10 = 81,
    _SC_THREAD_PROCESS_SHARED___10 = 82,
    _SC_NPROCESSORS_CONF___10 = 83,
    _SC_NPROCESSORS_ONLN___10 = 84,
    _SC_PHYS_PAGES___10 = 85,
    _SC_AVPHYS_PAGES___10 = 86,
    _SC_ATEXIT_MAX___10 = 87,
    _SC_PASS_MAX___10 = 88,
    _SC_XOPEN_VERSION___10 = 89,
    _SC_XOPEN_XCU_VERSION___10 = 90,
    _SC_XOPEN_UNIX___10 = 91,
    _SC_XOPEN_CRYPT___10 = 92,
    _SC_XOPEN_ENH_I18N___10 = 93,
    _SC_XOPEN_SHM___10 = 94,
    _SC_2_CHAR_TERM___10 = 95,
    _SC_2_C_VERSION___10 = 96,
    _SC_2_UPE___10 = 97,
    _SC_XOPEN_XPG2___10 = 98,
    _SC_XOPEN_XPG3___10 = 99,
    _SC_XOPEN_XPG4___10 = 100,
    _SC_CHAR_BIT___10 = 101,
    _SC_CHAR_MAX___10 = 102,
    _SC_CHAR_MIN___10 = 103,
    _SC_INT_MAX___10 = 104,
    _SC_INT_MIN___10 = 105,
    _SC_LONG_BIT___10 = 106,
    _SC_WORD_BIT___10 = 107,
    _SC_MB_LEN_MAX___10 = 108,
    _SC_NZERO___10 = 109,
    _SC_SSIZE_MAX___10 = 110,
    _SC_SCHAR_MAX___10 = 111,
    _SC_SCHAR_MIN___10 = 112,
    _SC_SHRT_MAX___10 = 113,
    _SC_SHRT_MIN___10 = 114,
    _SC_UCHAR_MAX___10 = 115,
    _SC_UINT_MAX___10 = 116,
    _SC_ULONG_MAX___10 = 117,
    _SC_USHRT_MAX___10 = 118,
    _SC_NL_ARGMAX___10 = 119,
    _SC_NL_LANGMAX___10 = 120,
    _SC_NL_MSGMAX___10 = 121,
    _SC_NL_NMAX___10 = 122,
    _SC_NL_SETMAX___10 = 123,
    _SC_NL_TEXTMAX___10 = 124,
    _SC_XBS5_ILP32_OFF32___10 = 125,
    _SC_XBS5_ILP32_OFFBIG___10 = 126,
    _SC_XBS5_LP64_OFF64___10 = 127,
    _SC_XBS5_LPBIG_OFFBIG___10 = 128,
    _SC_XOPEN_LEGACY___10 = 129,
    _SC_XOPEN_REALTIME___10 = 130,
    _SC_XOPEN_REALTIME_THREADS___10 = 131,
    _SC_ADVISORY_INFO___10 = 132,
    _SC_BARRIERS___10 = 133,
    _SC_BASE___10 = 134,
    _SC_C_LANG_SUPPORT___10 = 135,
    _SC_C_LANG_SUPPORT_R___10 = 136,
    _SC_CLOCK_SELECTION___10 = 137,
    _SC_CPUTIME___10 = 138,
    _SC_THREAD_CPUTIME___10 = 139,
    _SC_DEVICE_IO___10 = 140,
    _SC_DEVICE_SPECIFIC___10 = 141,
    _SC_DEVICE_SPECIFIC_R___10 = 142,
    _SC_FD_MGMT___10 = 143,
    _SC_FIFO___10 = 144,
    _SC_PIPE___10 = 145,
    _SC_FILE_ATTRIBUTES___10 = 146,
    _SC_FILE_LOCKING___10 = 147,
    _SC_FILE_SYSTEM___10 = 148,
    _SC_MONOTONIC_CLOCK___10 = 149,
    _SC_MULTI_PROCESS___10 = 150,
    _SC_SINGLE_PROCESS___10 = 151,
    _SC_NETWORKING___10 = 152,
    _SC_READER_WRITER_LOCKS___10 = 153,
    _SC_SPIN_LOCKS___10 = 154,
    _SC_REGEXP___10 = 155,
    _SC_REGEX_VERSION___10 = 156,
    _SC_SHELL___10 = 157,
    _SC_SIGNALS___10 = 158,
    _SC_SPAWN___10 = 159,
    _SC_SPORADIC_SERVER___10 = 160,
    _SC_THREAD_SPORADIC_SERVER___10 = 161,
    _SC_SYSTEM_DATABASE___10 = 162,
    _SC_SYSTEM_DATABASE_R___10 = 163,
    _SC_TIMEOUTS___10 = 164,
    _SC_TYPED_MEMORY_OBJECTS___10 = 165,
    _SC_USER_GROUPS___10 = 166,
    _SC_USER_GROUPS_R___10 = 167,
    _SC_2_PBS___10 = 168,
    _SC_2_PBS_ACCOUNTING___10 = 169,
    _SC_2_PBS_LOCATE___10 = 170,
    _SC_2_PBS_MESSAGE___10 = 171,
    _SC_2_PBS_TRACK___10 = 172,
    _SC_SYMLOOP_MAX___10 = 173,
    _SC_STREAMS___10 = 174,
    _SC_2_PBS_CHECKPOINT___10 = 175,
    _SC_V6_ILP32_OFF32___10 = 176,
    _SC_V6_ILP32_OFFBIG___10 = 177,
    _SC_V6_LP64_OFF64___10 = 178,
    _SC_V6_LPBIG_OFFBIG___10 = 179,
    _SC_HOST_NAME_MAX___10 = 180,
    _SC_TRACE___10 = 181,
    _SC_TRACE_EVENT_FILTER___10 = 182,
    _SC_TRACE_INHERIT___10 = 183,
    _SC_TRACE_LOG___10 = 184,
    _SC_LEVEL1_ICACHE_SIZE___10 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___10 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___10 = 187,
    _SC_LEVEL1_DCACHE_SIZE___10 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___10 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___10 = 190,
    _SC_LEVEL2_CACHE_SIZE___10 = 191,
    _SC_LEVEL2_CACHE_ASSOC___10 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___10 = 193,
    _SC_LEVEL3_CACHE_SIZE___10 = 194,
    _SC_LEVEL3_CACHE_ASSOC___10 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___10 = 196,
    _SC_LEVEL4_CACHE_SIZE___10 = 197,
    _SC_LEVEL4_CACHE_ASSOC___10 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___10 = 199,
    _SC_IPV6___10 = 235,
    _SC_RAW_SOCKETS___10 = 236,
    _SC_V7_ILP32_OFF32___10 = 237,
    _SC_V7_ILP32_OFFBIG___10 = 238,
    _SC_V7_LP64_OFF64___10 = 239,
    _SC_V7_LPBIG_OFFBIG___10 = 240,
    _SC_SS_REPL_MAX___10 = 241,
    _SC_TRACE_EVENT_NAME_MAX___10 = 242,
    _SC_TRACE_NAME_MAX___10 = 243,
    _SC_TRACE_SYS_MAX___10 = 244,
    _SC_TRACE_USER_EVENT_MAX___10 = 245,
    _SC_XOPEN_STREAMS___10 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___10 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___10 = 248,
    _SC_MINSIGSTKSZ___10 = 249,
    _SC_SIGSTKSZ___10 = 250
} ;
#line 539
enum __anonenum__21___10 {
    _CS_PATH___10 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___10 = 1,
    _CS_GNU_LIBC_VERSION___10 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___10 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___10 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___10 = 5,
    _CS_LFS_CFLAGS___10 = 1000,
    _CS_LFS_LDFLAGS___10 = 1001,
    _CS_LFS_LIBS___10 = 1002,
    _CS_LFS_LINTFLAGS___10 = 1003,
    _CS_LFS64_CFLAGS___10 = 1004,
    _CS_LFS64_LDFLAGS___10 = 1005,
    _CS_LFS64_LIBS___10 = 1006,
    _CS_LFS64_LINTFLAGS___10 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___10 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___10 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___10 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___10 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___10 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___10 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___10 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___10 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___10 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___10 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___10 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___10 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___10 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___10 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___10 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___10 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___10 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___10 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___10 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___10 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___10 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___10 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___10 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___10 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___10 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___10 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___10 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___10 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___10 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___10 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___10 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___10 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___10 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___10 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___10 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___10 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___10 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___10 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___10 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___10 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___10 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___10 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___10 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___10 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___10 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___10 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___10 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___10 = 1147,
    _CS_V6_ENV___10 = 1148,
    _CS_V7_ENV___10 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___10 {
    MSG_OOB___10 = 1,
    MSG_PEEK___10 = 2,
    MSG_DONTROUTE___10 = 4,
    MSG_CTRUNC___10 = 8,
    MSG_PROXY___10 = 16,
    MSG_TRUNC___10 = 32,
    MSG_DONTWAIT___10 = 64,
    MSG_EOR___10 = 128,
    MSG_WAITALL___10 = 256,
    MSG_FIN___10 = 512,
    MSG_SYN___10 = 1024,
    MSG_CONFIRM___10 = 2048,
    MSG_RST___10 = 4096,
    MSG_ERRQUEUE___10 = 8192,
    MSG_NOSIGNAL___10 = 16384,
    MSG_MORE___10 = 32768,
    MSG_WAITFORONE___10 = 65536,
    MSG_BATCH___10 = 262144,
    MSG_ZEROCOPY___10 = 67108864,
    MSG_FASTOPEN___10 = 536870912,
    MSG_CMSG_CLOEXEC___10 = 1073741824
} ;
#line 334
enum __anonenum__23___10 {
    SCM_RIGHTS___10 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___10 {
    SHUT_RD___10 = 0,
    SHUT_WR___10 = 1,
    SHUT_RDWR___10 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___10 {
    IPPROTO_IP___10 = 0,
    IPPROTO_ICMP___10 = 1,
    IPPROTO_IGMP___10 = 2,
    IPPROTO_IPIP___10 = 4,
    IPPROTO_TCP___10 = 6,
    IPPROTO_EGP___10 = 8,
    IPPROTO_PUP___10 = 12,
    IPPROTO_UDP___10 = 17,
    IPPROTO_IDP___10 = 22,
    IPPROTO_TP___10 = 29,
    IPPROTO_DCCP___10 = 33,
    IPPROTO_IPV6___10 = 41,
    IPPROTO_RSVP___10 = 46,
    IPPROTO_GRE___10 = 47,
    IPPROTO_ESP___10 = 50,
    IPPROTO_AH___10 = 51,
    IPPROTO_MTP___10 = 92,
    IPPROTO_BEETPH___10 = 94,
    IPPROTO_ENCAP___10 = 98,
    IPPROTO_PIM___10 = 103,
    IPPROTO_COMP___10 = 108,
    IPPROTO_SCTP___10 = 132,
    IPPROTO_UDPLITE___10 = 136,
    IPPROTO_MPLS___10 = 137,
    IPPROTO_ETHERNET___10 = 143,
    IPPROTO_RAW___10 = 255,
    IPPROTO_MPTCP___10 = 262,
    IPPROTO_MAX___10 = 263
} ;
#line 103
enum __anonenum__28___10 {
    IPPROTO_HOPOPTS___10 = 0,
    IPPROTO_ROUTING___10 = 43,
    IPPROTO_FRAGMENT___10 = 44,
    IPPROTO_ICMPV6___10 = 58,
    IPPROTO_NONE___10 = 59,
    IPPROTO_DSTOPTS___10 = 60,
    IPPROTO_MH___10 = 135
} ;
#line 126
enum __anonenum__29___10 {
    IPPORT_ECHO___10 = 7,
    IPPORT_DISCARD___10 = 9,
    IPPORT_SYSTAT___10 = 11,
    IPPORT_DAYTIME___10 = 13,
    IPPORT_NETSTAT___10 = 15,
    IPPORT_FTP___10 = 21,
    IPPORT_TELNET___10 = 23,
    IPPORT_SMTP___10 = 25,
    IPPORT_TIMESERVER___10 = 37,
    IPPORT_NAMESERVER___10 = 42,
    IPPORT_WHOIS___10 = 43,
    IPPORT_MTP___10 = 57,
    IPPORT_TFTP___10 = 69,
    IPPORT_RJE___10 = 77,
    IPPORT_FINGER___10 = 79,
    IPPORT_TTYLINK___10 = 87,
    IPPORT_SUPDUP___10 = 95,
    IPPORT_EXECSERVER___10 = 512,
    IPPORT_LOGINSERVER___10 = 513,
    IPPORT_CMDSERVER___10 = 514,
    IPPORT_EFSSERVER___10 = 520,
    IPPORT_BIFFUDP___10 = 512,
    IPPORT_WHOSERVER___10 = 513,
    IPPORT_ROUTESERVER___10 = 520,
    IPPORT_RESERVED___10 = 1024,
    IPPORT_USERRESERVED___10 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___10 {
    PTHREAD_CREATE_JOINABLE___10 = 0,
    PTHREAD_CREATE_DETACHED___10 = 1
} ;
#line 47
enum __anonenum__33___10 {
    PTHREAD_MUTEX_TIMED_NP___10 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___10 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___10 = 3,
    PTHREAD_MUTEX_NORMAL___10 = 0,
    PTHREAD_MUTEX_RECURSIVE___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK___10 = 2,
    PTHREAD_MUTEX_DEFAULT___10 = 0
} ;
#line 69
enum __anonenum__34___10 {
    PTHREAD_MUTEX_STALLED___10 = 0,
    PTHREAD_MUTEX_STALLED_NP___10 = 0,
    PTHREAD_MUTEX_ROBUST___10 = 1,
    PTHREAD_MUTEX_ROBUST_NP___10 = 1
} ;
#line 81
enum __anonenum__35___10 {
    PTHREAD_PRIO_NONE___10 = 0,
    PTHREAD_PRIO_INHERIT___10 = 1,
    PTHREAD_PRIO_PROTECT___10 = 2
} ;
#line 104
enum __anonenum__36___10 {
    PTHREAD_RWLOCK_PREFER_READER_NP___10 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___10 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___10 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___10 = 0
} ;
#line 124
enum __anonenum__37___10 {
    PTHREAD_INHERIT_SCHED___10 = 0,
    PTHREAD_EXPLICIT_SCHED___10 = 1
} ;
#line 134
enum __anonenum__38___10 {
    PTHREAD_SCOPE_SYSTEM___10 = 0,
    PTHREAD_SCOPE_PROCESS___10 = 1
} ;
#line 144
enum __anonenum__39___10 {
    PTHREAD_PROCESS_PRIVATE___10 = 0,
    PTHREAD_PROCESS_SHARED___10 = 1
} ;
#line 168
enum __anonenum__40___10 {
    PTHREAD_CANCEL_ENABLE___10 = 0,
    PTHREAD_CANCEL_DISABLE___10 = 1
} ;
#line 175
enum __anonenum__41___10 {
    PTHREAD_CANCEL_DEFERRED___10 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___10 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___10 {
    SI_ASYNCNL___10 = -60,
    SI_DETHREAD___10 = -7,
    SI_TKILL___10 = -6,
    SI_SIGIO___10 = -5,
    SI_ASYNCIO___10 = -4,
    SI_MESGQ___10 = -3,
    SI_TIMER___10 = -2,
    SI_QUEUE___10 = -1,
    SI_USER___10 = 0,
    SI_KERNEL___10 = 128
} ;
#line 71
enum __anonenum__55___10 {
    ILL_ILLOPC___10 = 1,
    ILL_ILLOPN___10 = 2,
    ILL_ILLADR___10 = 3,
    ILL_ILLTRP___10 = 4,
    ILL_PRVOPC___10 = 5,
    ILL_PRVREG___10 = 6,
    ILL_COPROC___10 = 7,
    ILL_BADSTK___10 = 8,
    ILL_BADIADDR___10 = 9
} ;
#line 94
enum __anonenum__56___10 {
    FPE_INTDIV___10 = 1,
    FPE_INTOVF___10 = 2,
    FPE_FLTDIV___10 = 3,
    FPE_FLTOVF___10 = 4,
    FPE_FLTUND___10 = 5,
    FPE_FLTRES___10 = 6,
    FPE_FLTINV___10 = 7,
    FPE_FLTSUB___10 = 8,
    FPE_FLTUNK___10 = 14,
    FPE_CONDTRAP___10 = 15
} ;
#line 119
enum __anonenum__57___10 {
    SEGV_MAPERR___10 = 1,
    SEGV_ACCERR___10 = 2,
    SEGV_BNDERR___10 = 3,
    SEGV_PKUERR___10 = 4,
    SEGV_ACCADI___10 = 5,
    SEGV_ADIDERR___10 = 6,
    SEGV_ADIPERR___10 = 7,
    SEGV_MTEAERR___10 = 8,
    SEGV_MTESERR___10 = 9
} ;
#line 142
enum __anonenum__58___10 {
    BUS_ADRALN___10 = 1,
    BUS_ADRERR___10 = 2,
    BUS_OBJERR___10 = 3,
    BUS_MCEERR_AR___10 = 4,
    BUS_MCEERR_AO___10 = 5
} ;
#line 176
enum __anonenum__59___10 {
    CLD_EXITED___10 = 1,
    CLD_KILLED___10 = 2,
    CLD_DUMPED___10 = 3,
    CLD_TRAPPED___10 = 4,
    CLD_STOPPED___10 = 5,
    CLD_CONTINUED___10 = 6
} ;
#line 193
enum __anonenum__60___10 {
    POLL_IN___10 = 1,
    POLL_OUT___10 = 2,
    POLL_MSG___10 = 3,
    POLL_ERR___10 = 4,
    POLL_PRI___10 = 5,
    POLL_HUP___10 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___10 {
    SIGEV_SIGNAL___10 = 0,
    SIGEV_NONE___10 = 1,
    SIGEV_THREAD___10 = 2,
    SIGEV_THREAD_ID___10 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___10 {
    SS_ONSTACK___10 = 1,
    SS_DISABLE___10 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___10 {
    EFD_SEMAPHORE___10 = 1,
    EFD_CLOEXEC___10 = 524288,
    EFD_NONBLOCK___10 = 2048
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 66 "/usr/include/alsa/global.h"
struct snd_dlsym_link {
   struct snd_dlsym_link *next ;
   char const   *dlsym_name ;
   void const   *dlsym_ptr ;
};
#line 115
struct _snd_async_handler ;
#line 115 "/usr/include/alsa/global.h"
typedef struct _snd_async_handler snd_async_handler_t;
#line 122 "/usr/include/alsa/global.h"
typedef void (*snd_async_callback_t)(snd_async_handler_t * );
#line 131
struct snd_shm_area ;
#line 152 "/usr/include/alsa/global.h"
typedef struct timeval snd_timestamp_t;
#line 154 "/usr/include/alsa/global.h"
typedef struct timespec snd_htimestamp_t;
#line 54 "/usr/include/alsa/input.h"
struct _snd_input ;
#line 54 "/usr/include/alsa/input.h"
typedef struct _snd_input snd_input_t;
#line 57
enum _snd_input_type {
    SND_INPUT_STDIO = 0,
    SND_INPUT_BUFFER = 1
} ;
#line 62 "/usr/include/alsa/input.h"
typedef enum _snd_input_type snd_input_type_t;
#line 54 "/usr/include/alsa/output.h"
struct _snd_output ;
#line 54 "/usr/include/alsa/output.h"
typedef struct _snd_output snd_output_t;
#line 57
enum _snd_output_type {
    SND_OUTPUT_STDIO = 0,
    SND_OUTPUT_BUFFER = 1
} ;
#line 62 "/usr/include/alsa/output.h"
typedef enum _snd_output_type snd_output_type_t;
#line 59 "/usr/include/alsa/error.h"
typedef void (*snd_lib_error_handler_t)(char const   * , int  , char const   * , int  ,
                                        char const   *  , ...);
#line 78 "/usr/include/alsa/error.h"
typedef void (*snd_local_error_handler_t)(char const   * , int  , char const   * ,
                                          int  , char const   * , va_list  );
#line 48 "/usr/include/alsa/conf.h"
enum _snd_config_type {
    SND_CONFIG_TYPE_INTEGER = 0,
    SND_CONFIG_TYPE_INTEGER64 = 1,
    SND_CONFIG_TYPE_REAL = 2,
    SND_CONFIG_TYPE_STRING = 3,
    SND_CONFIG_TYPE_POINTER = 4,
    SND_CONFIG_TYPE_COMPOUND = 1024
} ;
#line 61 "/usr/include/alsa/conf.h"
typedef enum _snd_config_type snd_config_type_t;
#line 69
struct _snd_config ;
#line 69 "/usr/include/alsa/conf.h"
typedef struct _snd_config snd_config_t;
#line 77
struct _snd_config_iterator ;
#line 77 "/usr/include/alsa/conf.h"
typedef struct _snd_config_iterator *snd_config_iterator_t;
#line 83
struct _snd_config_update ;
#line 83 "/usr/include/alsa/conf.h"
typedef struct _snd_config_update snd_config_update_t;
#line 112 "/usr/include/alsa/conf.h"
typedef int (*snd_config_expand_fcn_t)(snd_config_t ** , char const   * , void * );
#line 211
struct snd_devname ;
#line 211 "/usr/include/alsa/conf.h"
typedef struct snd_devname snd_devname_t;
#line 216 "/usr/include/alsa/conf.h"
struct snd_devname {
   char *name ;
   char *comment ;
   snd_devname_t *next ;
};
#line 48 "/usr/include/alsa/pcm.h"
struct _snd_pcm_info ;
#line 48 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_info snd_pcm_info_t;
#line 64
struct _snd_pcm_hw_params ;
#line 64 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_hw_params snd_pcm_hw_params_t;
#line 67
struct _snd_pcm_sw_params ;
#line 67 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_sw_params snd_pcm_sw_params_t;
#line 69
struct _snd_pcm_status ;
#line 69 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_status snd_pcm_status_t;
#line 71
struct _snd_pcm_access_mask ;
#line 71 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_access_mask snd_pcm_access_mask_t;
#line 73
struct _snd_pcm_format_mask ;
#line 73 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_format_mask snd_pcm_format_mask_t;
#line 75
struct _snd_pcm_subformat_mask ;
#line 75 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_subformat_mask snd_pcm_subformat_mask_t;
#line 78
enum _snd_pcm_class {
    SND_PCM_CLASS_GENERIC = 0,
    SND_PCM_CLASS_MULTI = 1,
    SND_PCM_CLASS_MODEM = 2,
    SND_PCM_CLASS_DIGITIZER = 3,
    SND_PCM_CLASS_LAST = 3
} ;
#line 89 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_class snd_pcm_class_t;
#line 92
enum _snd_pcm_subclass {
    SND_PCM_SUBCLASS_GENERIC_MIX = 0,
    SND_PCM_SUBCLASS_MULTI_MIX = 1,
    SND_PCM_SUBCLASS_LAST = 1
} ;
#line 98 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_subclass snd_pcm_subclass_t;
#line 101
enum _snd_pcm_stream {
    SND_PCM_STREAM_PLAYBACK = 0,
    SND_PCM_STREAM_CAPTURE = 1,
    SND_PCM_STREAM_LAST = 1
} ;
#line 107 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_stream snd_pcm_stream_t;
#line 110
enum _snd_pcm_access {
    SND_PCM_ACCESS_MMAP_INTERLEAVED = 0,
    SND_PCM_ACCESS_MMAP_NONINTERLEAVED = 1,
    SND_PCM_ACCESS_MMAP_COMPLEX = 2,
    SND_PCM_ACCESS_RW_INTERLEAVED = 3,
    SND_PCM_ACCESS_RW_NONINTERLEAVED = 4,
    SND_PCM_ACCESS_LAST = 4
} ;
#line 122 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_access snd_pcm_access_t;
#line 125
enum _snd_pcm_format {
    SND_PCM_FORMAT_UNKNOWN = -1,
    SND_PCM_FORMAT_S8 = 0,
    SND_PCM_FORMAT_U8 = 1,
    SND_PCM_FORMAT_S16_LE = 2,
    SND_PCM_FORMAT_S16_BE = 3,
    SND_PCM_FORMAT_U16_LE = 4,
    SND_PCM_FORMAT_U16_BE = 5,
    SND_PCM_FORMAT_S24_LE = 6,
    SND_PCM_FORMAT_S24_BE = 7,
    SND_PCM_FORMAT_U24_LE = 8,
    SND_PCM_FORMAT_U24_BE = 9,
    SND_PCM_FORMAT_S32_LE = 10,
    SND_PCM_FORMAT_S32_BE = 11,
    SND_PCM_FORMAT_U32_LE = 12,
    SND_PCM_FORMAT_U32_BE = 13,
    SND_PCM_FORMAT_FLOAT_LE = 14,
    SND_PCM_FORMAT_FLOAT_BE = 15,
    SND_PCM_FORMAT_FLOAT64_LE = 16,
    SND_PCM_FORMAT_FLOAT64_BE = 17,
    SND_PCM_FORMAT_IEC958_SUBFRAME_LE = 18,
    SND_PCM_FORMAT_IEC958_SUBFRAME_BE = 19,
    SND_PCM_FORMAT_MU_LAW = 20,
    SND_PCM_FORMAT_A_LAW = 21,
    SND_PCM_FORMAT_IMA_ADPCM = 22,
    SND_PCM_FORMAT_MPEG = 23,
    SND_PCM_FORMAT_GSM = 24,
    SND_PCM_FORMAT_S20_LE = 25,
    SND_PCM_FORMAT_S20_BE = 26,
    SND_PCM_FORMAT_U20_LE = 27,
    SND_PCM_FORMAT_U20_BE = 28,
    SND_PCM_FORMAT_SPECIAL = 31,
    SND_PCM_FORMAT_S24_3LE = 32,
    SND_PCM_FORMAT_S24_3BE = 33,
    SND_PCM_FORMAT_U24_3LE = 34,
    SND_PCM_FORMAT_U24_3BE = 35,
    SND_PCM_FORMAT_S20_3LE = 36,
    SND_PCM_FORMAT_S20_3BE = 37,
    SND_PCM_FORMAT_U20_3LE = 38,
    SND_PCM_FORMAT_U20_3BE = 39,
    SND_PCM_FORMAT_S18_3LE = 40,
    SND_PCM_FORMAT_S18_3BE = 41,
    SND_PCM_FORMAT_U18_3LE = 42,
    SND_PCM_FORMAT_U18_3BE = 43,
    SND_PCM_FORMAT_G723_24 = 44,
    SND_PCM_FORMAT_G723_24_1B = 45,
    SND_PCM_FORMAT_G723_40 = 46,
    SND_PCM_FORMAT_G723_40_1B = 47,
    SND_PCM_FORMAT_DSD_U8 = 48,
    SND_PCM_FORMAT_DSD_U16_LE = 49,
    SND_PCM_FORMAT_DSD_U32_LE = 50,
    SND_PCM_FORMAT_DSD_U16_BE = 51,
    SND_PCM_FORMAT_DSD_U32_BE = 52,
    SND_PCM_FORMAT_LAST = 52,
    SND_PCM_FORMAT_S16 = 2,
    SND_PCM_FORMAT_U16 = 4,
    SND_PCM_FORMAT_S24 = 6,
    SND_PCM_FORMAT_U24 = 8,
    SND_PCM_FORMAT_S32 = 10,
    SND_PCM_FORMAT_U32 = 12,
    SND_PCM_FORMAT_FLOAT = 14,
    SND_PCM_FORMAT_FLOAT64 = 16,
    SND_PCM_FORMAT_IEC958_SUBFRAME = 18,
    SND_PCM_FORMAT_S20 = 25,
    SND_PCM_FORMAT_U20 = 27
} ;
#line 281 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_format snd_pcm_format_t;
#line 284
enum _snd_pcm_subformat {
    SND_PCM_SUBFORMAT_STD = 0,
    SND_PCM_SUBFORMAT_LAST = 0
} ;
#line 288 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_subformat snd_pcm_subformat_t;
#line 291
enum _snd_pcm_state {
    SND_PCM_STATE_OPEN = 0,
    SND_PCM_STATE_SETUP = 1,
    SND_PCM_STATE_PREPARED = 2,
    SND_PCM_STATE_RUNNING = 3,
    SND_PCM_STATE_XRUN = 4,
    SND_PCM_STATE_DRAINING = 5,
    SND_PCM_STATE_PAUSED = 6,
    SND_PCM_STATE_SUSPENDED = 7,
    SND_PCM_STATE_DISCONNECTED = 8,
    SND_PCM_STATE_LAST = 8,
    SND_PCM_STATE_PRIVATE1 = 1024
} ;
#line 313 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_state snd_pcm_state_t;
#line 316
enum _snd_pcm_start {
    SND_PCM_START_DATA = 0,
    SND_PCM_START_EXPLICIT = 1,
    SND_PCM_START_LAST = 1
} ;
#line 322 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_start snd_pcm_start_t;
#line 325
enum _snd_pcm_xrun {
    SND_PCM_XRUN_NONE = 0,
    SND_PCM_XRUN_STOP = 1,
    SND_PCM_XRUN_LAST = 1
} ;
#line 331 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_xrun snd_pcm_xrun_t;
#line 334
enum _snd_pcm_tstamp {
    SND_PCM_TSTAMP_NONE = 0,
    SND_PCM_TSTAMP_ENABLE = 1,
    SND_PCM_TSTAMP_MMAP = 1,
    SND_PCM_TSTAMP_LAST = 1
} ;
#line 344 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_tstamp snd_pcm_tstamp_t;
#line 346
enum _snd_pcm_tstamp_type {
    SND_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
    SND_PCM_TSTAMP_TYPE_MONOTONIC = 1,
    SND_PCM_TSTAMP_TYPE_MONOTONIC_RAW = 2,
    SND_PCM_TSTAMP_TYPE_LAST = 2
} ;
#line 351 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_tstamp_type snd_pcm_tstamp_type_t;
#line 353
enum _snd_pcm_audio_tstamp_type {
    SND_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,
    SND_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,
    SND_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,
    SND_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,
    SND_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,
    SND_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,
    SND_PCM_AUDIO_TSTAMP_TYPE_LAST = 5
} ;
#line 365 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_audio_tstamp_type snd_pcm_audio_tstamp_type_t;
#line 367 "/usr/include/alsa/pcm.h"
struct _snd_pcm_audio_tstamp_config {
   unsigned int type_requested ;
   unsigned int report_delay ;
};
#line 371 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_audio_tstamp_config snd_pcm_audio_tstamp_config_t;
#line 373 "/usr/include/alsa/pcm.h"
struct _snd_pcm_audio_tstamp_report {
   unsigned int valid ;
   unsigned int actual_type ;
   unsigned int accuracy_report ;
   unsigned int accuracy ;
};
#line 385 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_audio_tstamp_report snd_pcm_audio_tstamp_report_t;
#line 388 "/usr/include/alsa/pcm.h"
typedef unsigned long snd_pcm_uframes_t;
#line 390 "/usr/include/alsa/pcm.h"
typedef long snd_pcm_sframes_t;
#line 408
struct _snd_pcm ;
#line 408 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm snd_pcm_t;
#line 411
enum _snd_pcm_type {
    SND_PCM_TYPE_HW = 0,
    SND_PCM_TYPE_HOOKS = 1,
    SND_PCM_TYPE_MULTI = 2,
    SND_PCM_TYPE_FILE = 3,
    SND_PCM_TYPE_NULL = 4,
    SND_PCM_TYPE_SHM = 5,
    SND_PCM_TYPE_INET = 6,
    SND_PCM_TYPE_COPY = 7,
    SND_PCM_TYPE_LINEAR = 8,
    SND_PCM_TYPE_ALAW = 9,
    SND_PCM_TYPE_MULAW = 10,
    SND_PCM_TYPE_ADPCM = 11,
    SND_PCM_TYPE_RATE = 12,
    SND_PCM_TYPE_ROUTE = 13,
    SND_PCM_TYPE_PLUG = 14,
    SND_PCM_TYPE_SHARE = 15,
    SND_PCM_TYPE_METER = 16,
    SND_PCM_TYPE_MIX = 17,
    SND_PCM_TYPE_DROUTE = 18,
    SND_PCM_TYPE_LBSERVER = 19,
    SND_PCM_TYPE_LINEAR_FLOAT = 20,
    SND_PCM_TYPE_LADSPA = 21,
    SND_PCM_TYPE_DMIX = 22,
    SND_PCM_TYPE_JACK = 23,
    SND_PCM_TYPE_DSNOOP = 24,
    SND_PCM_TYPE_DSHARE = 25,
    SND_PCM_TYPE_IEC958 = 26,
    SND_PCM_TYPE_SOFTVOL = 27,
    SND_PCM_TYPE_IOPLUG = 28,
    SND_PCM_TYPE_EXTPLUG = 29,
    SND_PCM_TYPE_MMAP_EMUL = 30,
    SND_PCM_TYPE_LAST = 30
} ;
#line 479 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_type snd_pcm_type_t;
#line 482 "/usr/include/alsa/pcm.h"
struct _snd_pcm_channel_area {
   void *addr ;
   unsigned int first ;
   unsigned int step ;
};
#line 489 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_channel_area snd_pcm_channel_area_t;
#line 492 "/usr/include/alsa/pcm.h"
union _snd_pcm_sync_id {
   unsigned char id[16] ;
   unsigned short id16[8] ;
   unsigned int id32[4] ;
};
#line 499 "/usr/include/alsa/pcm.h"
typedef union _snd_pcm_sync_id snd_pcm_sync_id_t;
#line 502
struct _snd_pcm_scope ;
#line 502 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_scope snd_pcm_scope_t;
#line 563
enum snd_pcm_chmap_type {
    SND_CHMAP_TYPE_NONE = 0,
    SND_CHMAP_TYPE_FIXED = 1,
    SND_CHMAP_TYPE_VAR = 2,
    SND_CHMAP_TYPE_PAIRED = 3,
    SND_CHMAP_TYPE_LAST = 3
} ;
#line 572
enum snd_pcm_chmap_position {
    SND_CHMAP_UNKNOWN = 0,
    SND_CHMAP_NA = 1,
    SND_CHMAP_MONO = 2,
    SND_CHMAP_FL = 3,
    SND_CHMAP_FR = 4,
    SND_CHMAP_RL = 5,
    SND_CHMAP_RR = 6,
    SND_CHMAP_FC = 7,
    SND_CHMAP_LFE = 8,
    SND_CHMAP_SL = 9,
    SND_CHMAP_SR = 10,
    SND_CHMAP_RC = 11,
    SND_CHMAP_FLC = 12,
    SND_CHMAP_FRC = 13,
    SND_CHMAP_RLC = 14,
    SND_CHMAP_RRC = 15,
    SND_CHMAP_FLW = 16,
    SND_CHMAP_FRW = 17,
    SND_CHMAP_FLH = 18,
    SND_CHMAP_FCH = 19,
    SND_CHMAP_FRH = 20,
    SND_CHMAP_TC = 21,
    SND_CHMAP_TFL = 22,
    SND_CHMAP_TFR = 23,
    SND_CHMAP_TFC = 24,
    SND_CHMAP_TRL = 25,
    SND_CHMAP_TRR = 26,
    SND_CHMAP_TRC = 27,
    SND_CHMAP_TFLC = 28,
    SND_CHMAP_TFRC = 29,
    SND_CHMAP_TSL = 30,
    SND_CHMAP_TSR = 31,
    SND_CHMAP_LLFE = 32,
    SND_CHMAP_RLFE = 33,
    SND_CHMAP_BC = 34,
    SND_CHMAP_BLC = 35,
    SND_CHMAP_BRC = 36,
    SND_CHMAP_LAST = 36
} ;
#line 622 "/usr/include/alsa/pcm.h"
struct snd_pcm_chmap {
   unsigned int channels ;
   unsigned int pos[0] ;
};
#line 625 "/usr/include/alsa/pcm.h"
typedef struct snd_pcm_chmap snd_pcm_chmap_t;
#line 628 "/usr/include/alsa/pcm.h"
struct snd_pcm_chmap_query {
   enum snd_pcm_chmap_type type ;
   snd_pcm_chmap_t map ;
};
#line 631 "/usr/include/alsa/pcm.h"
typedef struct snd_pcm_chmap_query snd_pcm_chmap_query_t;
#line 1209
enum _snd_pcm_hook_type {
    SND_PCM_HOOK_TYPE_HW_PARAMS = 0,
    SND_PCM_HOOK_TYPE_HW_FREE = 1,
    SND_PCM_HOOK_TYPE_CLOSE = 2,
    SND_PCM_HOOK_TYPE_LAST = 2
} ;
#line 1214 "/usr/include/alsa/pcm.h"
typedef enum _snd_pcm_hook_type snd_pcm_hook_type_t;
#line 1217
struct _snd_pcm_hook ;
#line 1217 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_hook snd_pcm_hook_t;
#line 1219 "/usr/include/alsa/pcm.h"
typedef int (*snd_pcm_hook_func_t)(snd_pcm_hook_t * );
#line 1238 "/usr/include/alsa/pcm.h"
struct _snd_pcm_scope_ops {
   int (*enable)(snd_pcm_scope_t * ) ;
   void (*disable)(snd_pcm_scope_t * ) ;
   void (*start)(snd_pcm_scope_t * ) ;
   void (*stop)(snd_pcm_scope_t * ) ;
   void (*update)(snd_pcm_scope_t * ) ;
   void (*reset)(snd_pcm_scope_t * ) ;
   void (*close)(snd_pcm_scope_t * ) ;
};
#line 1267 "/usr/include/alsa/pcm.h"
typedef struct _snd_pcm_scope_ops snd_pcm_scope_ops_t;
#line 1298
enum _snd_spcm_latency {
    SND_SPCM_LATENCY_STANDARD = 0,
    SND_SPCM_LATENCY_MEDIUM = 1,
    SND_SPCM_LATENCY_REALTIME = 2
} ;
#line 1308 "/usr/include/alsa/pcm.h"
typedef enum _snd_spcm_latency snd_spcm_latency_t;
#line 1311
enum _snd_spcm_xrun_type {
    SND_SPCM_XRUN_IGNORE = 0,
    SND_SPCM_XRUN_STOP = 1
} ;
#line 1316 "/usr/include/alsa/pcm.h"
typedef enum _snd_spcm_xrun_type snd_spcm_xrun_type_t;
#line 1319
enum _snd_spcm_duplex_type {
    SND_SPCM_DUPLEX_LIBERAL = 0,
    SND_SPCM_DUPLEX_PEDANTIC = 1
} ;
#line 1324 "/usr/include/alsa/pcm.h"
typedef enum _snd_spcm_duplex_type snd_spcm_duplex_type_t;
#line 45 "/usr/include/alsa/rawmidi.h"
struct _snd_rawmidi_info ;
#line 45 "/usr/include/alsa/rawmidi.h"
typedef struct _snd_rawmidi_info snd_rawmidi_info_t;
#line 47
struct _snd_rawmidi_params ;
#line 47 "/usr/include/alsa/rawmidi.h"
typedef struct _snd_rawmidi_params snd_rawmidi_params_t;
#line 49
struct _snd_rawmidi_status ;
#line 49 "/usr/include/alsa/rawmidi.h"
typedef struct _snd_rawmidi_status snd_rawmidi_status_t;
#line 52
enum _snd_rawmidi_stream {
    SND_RAWMIDI_STREAM_OUTPUT = 0,
    SND_RAWMIDI_STREAM_INPUT = 1,
    SND_RAWMIDI_STREAM_LAST = 1
} ;
#line 58 "/usr/include/alsa/rawmidi.h"
typedef enum _snd_rawmidi_stream snd_rawmidi_stream_t;
#line 68
struct _snd_rawmidi ;
#line 68 "/usr/include/alsa/rawmidi.h"
typedef struct _snd_rawmidi snd_rawmidi_t;
#line 71
enum _snd_rawmidi_type {
    SND_RAWMIDI_TYPE_HW = 0,
    SND_RAWMIDI_TYPE_SHM = 1,
    SND_RAWMIDI_TYPE_INET = 2,
    SND_RAWMIDI_TYPE_VIRTUAL = 3
} ;
#line 80 "/usr/include/alsa/rawmidi.h"
typedef enum _snd_rawmidi_type snd_rawmidi_type_t;
#line 83
enum _snd_rawmidi_clock {
    SND_RAWMIDI_CLOCK_NONE = 0,
    SND_RAWMIDI_CLOCK_REALTIME = 1,
    SND_RAWMIDI_CLOCK_MONOTONIC = 2,
    SND_RAWMIDI_CLOCK_MONOTONIC_RAW = 3
} ;
#line 88 "/usr/include/alsa/rawmidi.h"
typedef enum _snd_rawmidi_clock snd_rawmidi_clock_t;
#line 91
enum _snd_rawmidi_read_mode {
    SND_RAWMIDI_READ_STANDARD = 0,
    SND_RAWMIDI_READ_TSTAMP = 1
} ;
#line 94 "/usr/include/alsa/rawmidi.h"
typedef enum _snd_rawmidi_read_mode snd_rawmidi_read_mode_t;
#line 47 "/usr/include/alsa/timer.h"
struct _snd_timer_id ;
#line 47 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_id snd_timer_id_t;
#line 49
struct _snd_timer_ginfo ;
#line 49 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_ginfo snd_timer_ginfo_t;
#line 51
struct _snd_timer_gparams ;
#line 51 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_gparams snd_timer_gparams_t;
#line 53
struct _snd_timer_gstatus ;
#line 53 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_gstatus snd_timer_gstatus_t;
#line 55
struct _snd_timer_info ;
#line 55 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_info snd_timer_info_t;
#line 57
struct _snd_timer_params ;
#line 57 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_params snd_timer_params_t;
#line 59
struct _snd_timer_status ;
#line 59 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_status snd_timer_status_t;
#line 61
enum _snd_timer_class {
    SND_TIMER_CLASS_NONE = -1,
    SND_TIMER_CLASS_SLAVE = 0,
    SND_TIMER_CLASS_GLOBAL = 1,
    SND_TIMER_CLASS_CARD = 2,
    SND_TIMER_CLASS_PCM = 3,
    SND_TIMER_CLASS_LAST = 3
} ;
#line 68 "/usr/include/alsa/timer.h"
typedef enum _snd_timer_class snd_timer_class_t;
#line 71
enum _snd_timer_slave_class {
    SND_TIMER_SCLASS_NONE = 0,
    SND_TIMER_SCLASS_APPLICATION = 1,
    SND_TIMER_SCLASS_SEQUENCER = 2,
    SND_TIMER_SCLASS_OSS_SEQUENCER = 3,
    SND_TIMER_SCLASS_LAST = 3
} ;
#line 77 "/usr/include/alsa/timer.h"
typedef enum _snd_timer_slave_class snd_timer_slave_class_t;
#line 80
enum _snd_timer_event {
    SND_TIMER_EVENT_RESOLUTION = 0,
    SND_TIMER_EVENT_TICK = 1,
    SND_TIMER_EVENT_START = 2,
    SND_TIMER_EVENT_STOP = 3,
    SND_TIMER_EVENT_CONTINUE = 4,
    SND_TIMER_EVENT_PAUSE = 5,
    SND_TIMER_EVENT_EARLY = 6,
    SND_TIMER_EVENT_SUSPEND = 7,
    SND_TIMER_EVENT_RESUME = 8,
    SND_TIMER_EVENT_MSTART = 12,
    SND_TIMER_EVENT_MSTOP = 13,
    SND_TIMER_EVENT_MCONTINUE = 14,
    SND_TIMER_EVENT_MPAUSE = 15,
    SND_TIMER_EVENT_MSUSPEND = 17,
    SND_TIMER_EVENT_MRESUME = 18
} ;
#line 97 "/usr/include/alsa/timer.h"
typedef enum _snd_timer_event snd_timer_event_t;
#line 100 "/usr/include/alsa/timer.h"
struct _snd_timer_read {
   unsigned int resolution ;
   unsigned int ticks ;
};
#line 103 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_read snd_timer_read_t;
#line 106 "/usr/include/alsa/timer.h"
struct _snd_timer_tread {
   snd_timer_event_t event ;
   snd_htimestamp_t tstamp ;
   unsigned int val ;
};
#line 110 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_tread snd_timer_tread_t;
#line 127
enum _snd_timer_type {
    SND_TIMER_TYPE_HW = 0,
    SND_TIMER_TYPE_SHM = 1,
    SND_TIMER_TYPE_INET = 2
} ;
#line 134 "/usr/include/alsa/timer.h"
typedef enum _snd_timer_type snd_timer_type_t;
#line 137
struct _snd_timer_query ;
#line 137 "/usr/include/alsa/timer.h"
typedef struct _snd_timer_query snd_timer_query_t;
#line 139
struct _snd_timer ;
#line 139 "/usr/include/alsa/timer.h"
typedef struct _snd_timer snd_timer_t;
#line 45 "/usr/include/alsa/hwdep.h"
struct _snd_hwdep_info ;
#line 45 "/usr/include/alsa/hwdep.h"
typedef struct _snd_hwdep_info snd_hwdep_info_t;
#line 48
struct _snd_hwdep_dsp_status ;
#line 48 "/usr/include/alsa/hwdep.h"
typedef struct _snd_hwdep_dsp_status snd_hwdep_dsp_status_t;
#line 51
struct _snd_hwdep_dsp_image ;
#line 51 "/usr/include/alsa/hwdep.h"
typedef struct _snd_hwdep_dsp_image snd_hwdep_dsp_image_t;
#line 54
enum _snd_hwdep_iface {
    SND_HWDEP_IFACE_OPL2 = 0,
    SND_HWDEP_IFACE_OPL3 = 1,
    SND_HWDEP_IFACE_OPL4 = 2,
    SND_HWDEP_IFACE_SB16CSP = 3,
    SND_HWDEP_IFACE_EMU10K1 = 4,
    SND_HWDEP_IFACE_YSS225 = 5,
    SND_HWDEP_IFACE_ICS2115 = 6,
    SND_HWDEP_IFACE_SSCAPE = 7,
    SND_HWDEP_IFACE_VX = 8,
    SND_HWDEP_IFACE_MIXART = 9,
    SND_HWDEP_IFACE_USX2Y = 10,
    SND_HWDEP_IFACE_EMUX_WAVETABLE = 11,
    SND_HWDEP_IFACE_BLUETOOTH = 12,
    SND_HWDEP_IFACE_USX2Y_PCM = 13,
    SND_HWDEP_IFACE_PCXHR = 14,
    SND_HWDEP_IFACE_SB_RC = 15,
    SND_HWDEP_IFACE_HDA = 16,
    SND_HWDEP_IFACE_USB_STREAM = 17,
    SND_HWDEP_IFACE_FW_DICE = 18,
    SND_HWDEP_IFACE_FW_FIREWORKS = 19,
    SND_HWDEP_IFACE_FW_BEBOB = 20,
    SND_HWDEP_IFACE_FW_OXFW = 21,
    SND_HWDEP_IFACE_FW_DIGI00X = 22,
    SND_HWDEP_IFACE_FW_TASCAM = 23,
    SND_HWDEP_IFACE_LINE6 = 24,
    SND_HWDEP_IFACE_FW_MOTU = 25,
    SND_HWDEP_IFACE_FW_FIREFACE = 26,
    SND_HWDEP_IFACE_LAST = 26
} ;
#line 84 "/usr/include/alsa/hwdep.h"
typedef enum _snd_hwdep_iface snd_hwdep_iface_t;
#line 96
enum _snd_hwdep_type {
    SND_HWDEP_TYPE_HW = 0,
    SND_HWDEP_TYPE_SHM = 1,
    SND_HWDEP_TYPE_INET = 2
} ;
#line 103 "/usr/include/alsa/hwdep.h"
typedef enum _snd_hwdep_type snd_hwdep_type_t;
#line 106
struct _snd_hwdep ;
#line 106 "/usr/include/alsa/hwdep.h"
typedef struct _snd_hwdep snd_hwdep_t;
#line 46 "/usr/include/alsa/control.h"
struct snd_aes_iec958 {
   unsigned char status[24] ;
   unsigned char subcode[147] ;
   unsigned char pad ;
   unsigned char dig_subframe[4] ;
};
#line 51 "/usr/include/alsa/control.h"
typedef struct snd_aes_iec958 snd_aes_iec958_t;
#line 79
struct _snd_ctl_card_info ;
#line 79 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_card_info snd_ctl_card_info_t;
#line 82
struct _snd_ctl_elem_id ;
#line 82 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_elem_id snd_ctl_elem_id_t;
#line 153
struct _snd_ctl_elem_list ;
#line 153 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_elem_list snd_ctl_elem_list_t;
#line 156
struct _snd_ctl_elem_info ;
#line 156 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_elem_info snd_ctl_elem_info_t;
#line 210
struct _snd_ctl_elem_value ;
#line 210 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_elem_value snd_ctl_elem_value_t;
#line 213
struct _snd_ctl_event ;
#line 213 "/usr/include/alsa/control.h"
typedef struct _snd_ctl_event snd_ctl_event_t;
#line 216
enum _snd_ctl_elem_type {
    SND_CTL_ELEM_TYPE_NONE = 0,
    SND_CTL_ELEM_TYPE_BOOLEAN = 1,
    SND_CTL_ELEM_TYPE_INTEGER = 2,
    SND_CTL_ELEM_TYPE_ENUMERATED = 3,
    SND_CTL_ELEM_TYPE_BYTES = 4,
    SND_CTL_ELEM_TYPE_IEC958 = 5,
    SND_CTL_ELEM_TYPE_INTEGER64 = 6,
    SND_CTL_ELEM_TYPE_LAST = 6
} ;
#line 232 "/usr/include/alsa/control.h"
typedef enum _snd_ctl_elem_type snd_ctl_elem_type_t;
#line 235
enum _snd_ctl_elem_iface {
    SND_CTL_ELEM_IFACE_CARD = 0,
    SND_CTL_ELEM_IFACE_HWDEP = 1,
    SND_CTL_ELEM_IFACE_MIXER = 2,
    SND_CTL_ELEM_IFACE_PCM = 3,
    SND_CTL_ELEM_IFACE_RAWMIDI = 4,
    SND_CTL_ELEM_IFACE_TIMER = 5,
    SND_CTL_ELEM_IFACE_SEQUENCER = 6,
    SND_CTL_ELEM_IFACE_LAST = 6
} ;
#line 251 "/usr/include/alsa/control.h"
typedef enum _snd_ctl_elem_iface snd_ctl_elem_iface_t;
#line 254
enum _snd_ctl_event_type {
    SND_CTL_EVENT_ELEM = 0,
    SND_CTL_EVENT_LAST = 0
} ;
#line 258 "/usr/include/alsa/control.h"
typedef enum _snd_ctl_event_type snd_ctl_event_type_t;
#line 337
enum _snd_ctl_type {
    SND_CTL_TYPE_HW = 0,
    SND_CTL_TYPE_SHM = 1,
    SND_CTL_TYPE_INET = 2,
    SND_CTL_TYPE_EXT = 3,
    SND_CTL_TYPE_REMAP = 4
} ;
#line 348 "/usr/include/alsa/control.h"
typedef enum _snd_ctl_type snd_ctl_type_t;
#line 360
struct _snd_ctl ;
#line 360 "/usr/include/alsa/control.h"
typedef struct _snd_ctl snd_ctl_t;
#line 366
struct _snd_sctl ;
#line 366 "/usr/include/alsa/control.h"
typedef struct _snd_sctl snd_sctl_t;
#line 696
struct _snd_hctl_elem ;
#line 696 "/usr/include/alsa/control.h"
typedef struct _snd_hctl_elem snd_hctl_elem_t;
#line 699
struct _snd_hctl ;
#line 699 "/usr/include/alsa/control.h"
typedef struct _snd_hctl snd_hctl_t;
#line 707 "/usr/include/alsa/control.h"
typedef int (*snd_hctl_compare_t)(snd_hctl_elem_t * , snd_hctl_elem_t * );
#line 718 "/usr/include/alsa/control.h"
typedef int (*snd_hctl_callback_t)(snd_hctl_t * , unsigned int  , snd_hctl_elem_t * );
#line 727 "/usr/include/alsa/control.h"
typedef int (*snd_hctl_elem_callback_t)(snd_hctl_elem_t * , unsigned int  );
#line 42 "/usr/include/alsa/mixer.h"
struct _snd_mixer ;
#line 42 "/usr/include/alsa/mixer.h"
typedef struct _snd_mixer snd_mixer_t;
#line 44
struct _snd_mixer_class ;
#line 44 "/usr/include/alsa/mixer.h"
typedef struct _snd_mixer_class snd_mixer_class_t;
#line 46
struct _snd_mixer_elem ;
#line 46 "/usr/include/alsa/mixer.h"
typedef struct _snd_mixer_elem snd_mixer_elem_t;
#line 55 "/usr/include/alsa/mixer.h"
typedef int (*snd_mixer_callback_t)(snd_mixer_t * , unsigned int  , snd_mixer_elem_t * );
#line 65 "/usr/include/alsa/mixer.h"
typedef int (*snd_mixer_elem_callback_t)(snd_mixer_elem_t * , unsigned int  );
#line 74 "/usr/include/alsa/mixer.h"
typedef int (*snd_mixer_compare_t)(snd_mixer_elem_t * , snd_mixer_elem_t * );
#line 85 "/usr/include/alsa/mixer.h"
typedef int (*snd_mixer_event_t)(snd_mixer_class_t * , unsigned int  , snd_hctl_elem_t * ,
                                 snd_mixer_elem_t * );
#line 90
enum _snd_mixer_elem_type {
    SND_MIXER_ELEM_SIMPLE = 0,
    SND_MIXER_ELEM_LAST = 0
} ;
#line 94 "/usr/include/alsa/mixer.h"
typedef enum _snd_mixer_elem_type snd_mixer_elem_type_t;
#line 170
enum _snd_mixer_selem_channel_id {
    SND_MIXER_SCHN_UNKNOWN = -1,
    SND_MIXER_SCHN_FRONT_LEFT = 0,
    SND_MIXER_SCHN_FRONT_RIGHT = 1,
    SND_MIXER_SCHN_REAR_LEFT = 2,
    SND_MIXER_SCHN_REAR_RIGHT = 3,
    SND_MIXER_SCHN_FRONT_CENTER = 4,
    SND_MIXER_SCHN_WOOFER = 5,
    SND_MIXER_SCHN_SIDE_LEFT = 6,
    SND_MIXER_SCHN_SIDE_RIGHT = 7,
    SND_MIXER_SCHN_REAR_CENTER = 8,
    SND_MIXER_SCHN_LAST = 31,
    SND_MIXER_SCHN_MONO = 0
} ;
#line 194 "/usr/include/alsa/mixer.h"
typedef enum _snd_mixer_selem_channel_id snd_mixer_selem_channel_id_t;
#line 197
enum snd_mixer_selem_regopt_abstract {
    SND_MIXER_SABSTRACT_NONE = 0,
    SND_MIXER_SABSTRACT_BASIC = 1
} ;
#line 205 "/usr/include/alsa/mixer.h"
struct snd_mixer_selem_regopt {
   int ver ;
   enum snd_mixer_selem_regopt_abstract abstract ;
   char const   *device ;
   snd_pcm_t *playback_pcm ;
   snd_pcm_t *capture_pcm ;
};
#line 219
struct _snd_mixer_selem_id ;
#line 219 "/usr/include/alsa/mixer.h"
typedef struct _snd_mixer_selem_id snd_mixer_selem_id_t;
#line 41 "/usr/include/alsa/seq_event.h"
typedef unsigned char snd_seq_event_type_t;
#line 44
enum snd_seq_event_type {
    SND_SEQ_EVENT_SYSTEM = 0,
    SND_SEQ_EVENT_RESULT = 1,
    SND_SEQ_EVENT_NOTE = 5,
    SND_SEQ_EVENT_NOTEON = 6,
    SND_SEQ_EVENT_NOTEOFF = 7,
    SND_SEQ_EVENT_KEYPRESS = 8,
    SND_SEQ_EVENT_CONTROLLER = 10,
    SND_SEQ_EVENT_PGMCHANGE = 11,
    SND_SEQ_EVENT_CHANPRESS = 12,
    SND_SEQ_EVENT_PITCHBEND = 13,
    SND_SEQ_EVENT_CONTROL14 = 14,
    SND_SEQ_EVENT_NONREGPARAM = 15,
    SND_SEQ_EVENT_REGPARAM = 16,
    SND_SEQ_EVENT_SONGPOS = 20,
    SND_SEQ_EVENT_SONGSEL = 21,
    SND_SEQ_EVENT_QFRAME = 22,
    SND_SEQ_EVENT_TIMESIGN = 23,
    SND_SEQ_EVENT_KEYSIGN = 24,
    SND_SEQ_EVENT_START = 30,
    SND_SEQ_EVENT_CONTINUE = 31,
    SND_SEQ_EVENT_STOP = 32,
    SND_SEQ_EVENT_SETPOS_TICK = 33,
    SND_SEQ_EVENT_SETPOS_TIME = 34,
    SND_SEQ_EVENT_TEMPO = 35,
    SND_SEQ_EVENT_CLOCK = 36,
    SND_SEQ_EVENT_TICK = 37,
    SND_SEQ_EVENT_QUEUE_SKEW = 38,
    SND_SEQ_EVENT_SYNC_POS = 39,
    SND_SEQ_EVENT_TUNE_REQUEST = 40,
    SND_SEQ_EVENT_RESET = 41,
    SND_SEQ_EVENT_SENSING = 42,
    SND_SEQ_EVENT_ECHO = 50,
    SND_SEQ_EVENT_OSS = 51,
    SND_SEQ_EVENT_CLIENT_START = 60,
    SND_SEQ_EVENT_CLIENT_EXIT = 61,
    SND_SEQ_EVENT_CLIENT_CHANGE = 62,
    SND_SEQ_EVENT_PORT_START = 63,
    SND_SEQ_EVENT_PORT_EXIT = 64,
    SND_SEQ_EVENT_PORT_CHANGE = 65,
    SND_SEQ_EVENT_PORT_SUBSCRIBED = 66,
    SND_SEQ_EVENT_PORT_UNSUBSCRIBED = 67,
    SND_SEQ_EVENT_USR0 = 90,
    SND_SEQ_EVENT_USR1 = 91,
    SND_SEQ_EVENT_USR2 = 92,
    SND_SEQ_EVENT_USR3 = 93,
    SND_SEQ_EVENT_USR4 = 94,
    SND_SEQ_EVENT_USR5 = 95,
    SND_SEQ_EVENT_USR6 = 96,
    SND_SEQ_EVENT_USR7 = 97,
    SND_SEQ_EVENT_USR8 = 98,
    SND_SEQ_EVENT_USR9 = 99,
    SND_SEQ_EVENT_SYSEX = 130,
    SND_SEQ_EVENT_BOUNCE = 131,
    SND_SEQ_EVENT_USR_VAR0 = 135,
    SND_SEQ_EVENT_USR_VAR1 = 136,
    SND_SEQ_EVENT_USR_VAR2 = 137,
    SND_SEQ_EVENT_USR_VAR3 = 138,
    SND_SEQ_EVENT_USR_VAR4 = 139,
    SND_SEQ_EVENT_NONE = 255
} ;
#line 178 "/usr/include/alsa/seq_event.h"
struct snd_seq_addr {
   unsigned char client ;
   unsigned char port ;
};
#line 181 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_addr snd_seq_addr_t;
#line 184 "/usr/include/alsa/seq_event.h"
struct snd_seq_connect {
   snd_seq_addr_t sender ;
   snd_seq_addr_t dest ;
};
#line 187 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_connect snd_seq_connect_t;
#line 191 "/usr/include/alsa/seq_event.h"
struct snd_seq_real_time {
   unsigned int tv_sec ;
   unsigned int tv_nsec ;
};
#line 194 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_real_time snd_seq_real_time_t;
#line 197 "/usr/include/alsa/seq_event.h"
typedef unsigned int snd_seq_tick_time_t;
#line 200 "/usr/include/alsa/seq_event.h"
union snd_seq_timestamp {
   snd_seq_tick_time_t tick ;
   struct snd_seq_real_time time ;
};
#line 203 "/usr/include/alsa/seq_event.h"
typedef union snd_seq_timestamp snd_seq_timestamp_t;
#line 230 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_note {
   unsigned char channel ;
   unsigned char note ;
   unsigned char velocity ;
   unsigned char off_velocity ;
   unsigned int duration ;
};
#line 236 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_note snd_seq_ev_note_t;
#line 239 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_ctrl {
   unsigned char channel ;
   unsigned char unused[3] ;
   unsigned int param ;
   int value ;
};
#line 244 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_ctrl snd_seq_ev_ctrl_t;
#line 247 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_raw8 {
   unsigned char d[12] ;
};
#line 249 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_raw8 snd_seq_ev_raw8_t;
#line 252 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_raw32 {
   unsigned int d[3] ;
};
#line 254 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_raw32 snd_seq_ev_raw32_t;
#line 257 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_ext {
   unsigned int len ;
   void *ptr ;
};
#line 262 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_ext snd_seq_ev_ext_t;
#line 269 "/usr/include/alsa/seq_event.h"
struct snd_seq_result {
   int event ;
   int result ;
};
#line 272 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_result snd_seq_result_t;
#line 275 "/usr/include/alsa/seq_event.h"
struct snd_seq_queue_skew {
   unsigned int value ;
   unsigned int base ;
};
#line 278 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_queue_skew snd_seq_queue_skew_t;
#line 284 "/usr/include/alsa/seq_event.h"
union __anonunion_148 {
   int value ;
   snd_seq_timestamp_t time ;
   unsigned int position ;
   snd_seq_queue_skew_t skew ;
   unsigned int d32[2] ;
   unsigned char d8[8] ;
};
#line 281 "/usr/include/alsa/seq_event.h"
struct snd_seq_ev_queue_control {
   unsigned char queue ;
   unsigned char unused[3] ;
   union __anonunion_148 param ;
};
#line 292 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_ev_queue_control snd_seq_ev_queue_control_t;
#line 307 "/usr/include/alsa/seq_event.h"
union __anonunion_149 {
   snd_seq_ev_note_t note ;
   snd_seq_ev_ctrl_t control ;
   snd_seq_ev_raw8_t raw8 ;
   snd_seq_ev_raw32_t raw32 ;
   snd_seq_ev_ext_t ext ;
   snd_seq_ev_queue_control_t queue ;
   snd_seq_timestamp_t time ;
   snd_seq_addr_t addr ;
   snd_seq_connect_t connect ;
   snd_seq_result_t result ;
};
#line 296 "/usr/include/alsa/seq_event.h"
struct snd_seq_event {
   snd_seq_event_type_t type ;
   unsigned char flags ;
   unsigned char tag ;
   unsigned char queue ;
   snd_seq_timestamp_t time ;
   snd_seq_addr_t source ;
   snd_seq_addr_t dest ;
   union __anonunion_149 data ;
};
#line 319 "/usr/include/alsa/seq_event.h"
typedef struct snd_seq_event snd_seq_event_t;
#line 47 "/usr/include/alsa/seq.h"
struct _snd_seq ;
#line 47 "/usr/include/alsa/seq.h"
typedef struct _snd_seq snd_seq_t;
#line 62
enum _snd_seq_type {
    SND_SEQ_TYPE_HW = 0,
    SND_SEQ_TYPE_SHM = 1,
    SND_SEQ_TYPE_INET = 2
} ;
#line 66 "/usr/include/alsa/seq.h"
typedef enum _snd_seq_type snd_seq_type_t;
#line 95
struct _snd_seq_system_info ;
#line 95 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_system_info snd_seq_system_info_t;
#line 125
struct _snd_seq_client_info ;
#line 125 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_client_info snd_seq_client_info_t;
#line 128
enum snd_seq_client_type {
    SND_SEQ_USER_CLIENT = 1,
    SND_SEQ_KERNEL_CLIENT = 2
} ;
#line 131 "/usr/include/alsa/seq.h"
typedef enum snd_seq_client_type snd_seq_client_type_t;
#line 172
struct _snd_seq_client_pool ;
#line 172 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_client_pool snd_seq_client_pool_t;
#line 207
struct _snd_seq_port_info ;
#line 207 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_port_info snd_seq_port_info_t;
#line 319
struct _snd_seq_port_subscribe ;
#line 319 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_port_subscribe snd_seq_port_subscribe_t;
#line 351
struct _snd_seq_query_subscribe ;
#line 351 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_query_subscribe snd_seq_query_subscribe_t;
#line 354
enum __anonenum__150 {
    SND_SEQ_QUERY_SUBS_READ = 0,
    SND_SEQ_QUERY_SUBS_WRITE = 1
} ;
#line 357 "/usr/include/alsa/seq.h"
typedef enum __anonenum__150 snd_seq_query_subs_type_t;
#line 398
struct _snd_seq_queue_info ;
#line 398 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_queue_info snd_seq_queue_info_t;
#line 400
struct _snd_seq_queue_status ;
#line 400 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_queue_status snd_seq_queue_status_t;
#line 402
struct _snd_seq_queue_tempo ;
#line 402 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_queue_tempo snd_seq_queue_tempo_t;
#line 404
struct _snd_seq_queue_timer ;
#line 404 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_queue_timer snd_seq_queue_timer_t;
#line 484
enum __anonenum__151 {
    SND_SEQ_TIMER_ALSA = 0,
    SND_SEQ_TIMER_MIDI_CLOCK = 1,
    SND_SEQ_TIMER_MIDI_TICK = 2
} ;
#line 488 "/usr/include/alsa/seq.h"
typedef enum __anonenum__151 snd_seq_queue_timer_type_t;
#line 535
struct _snd_seq_remove_events ;
#line 535 "/usr/include/alsa/seq.h"
typedef struct _snd_seq_remove_events snd_seq_remove_events_t;
#line 600
enum __anonenum__152 {
    SND_SEQ_EVFLG_RESULT = 0,
    SND_SEQ_EVFLG_NOTE = 1,
    SND_SEQ_EVFLG_CONTROL = 2,
    SND_SEQ_EVFLG_QUEUE = 3,
    SND_SEQ_EVFLG_SYSTEM = 4,
    SND_SEQ_EVFLG_MESSAGE = 5,
    SND_SEQ_EVFLG_CONNECTION = 6,
    SND_SEQ_EVFLG_SAMPLE = 7,
    SND_SEQ_EVFLG_USERS = 8,
    SND_SEQ_EVFLG_INSTR = 9,
    SND_SEQ_EVFLG_QUOTE = 10,
    SND_SEQ_EVFLG_NONE = 11,
    SND_SEQ_EVFLG_RAW = 12,
    SND_SEQ_EVFLG_FIXED = 13,
    SND_SEQ_EVFLG_VARIABLE = 14,
    SND_SEQ_EVFLG_VARUSR = 15
} ;
#line 619
enum __anonenum__153 {
    SND_SEQ_EVFLG_NOTE_ONEARG = 0,
    SND_SEQ_EVFLG_NOTE_TWOARG = 1
} ;
#line 624
enum __anonenum__154 {
    SND_SEQ_EVFLG_QUEUE_NOARG = 0,
    SND_SEQ_EVFLG_QUEUE_TICK = 1,
    SND_SEQ_EVFLG_QUEUE_TIME = 2,
    SND_SEQ_EVFLG_QUEUE_VALUE = 3
} ;
#line 43 "/usr/include/alsa/seq_midi_event.h"
struct snd_midi_event ;
#line 43 "/usr/include/alsa/seq_midi_event.h"
typedef struct snd_midi_event snd_midi_event_t;
#line 82 "/usr/include/malloc.h"
struct mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
#line 99 "/usr/include/malloc.h"
struct mallinfo2 {
   size_t arena ;
   size_t ordblks ;
   size_t smblks ;
   size_t hblks ;
   size_t hblkhd ;
   size_t usmblks ;
   size_t fsmblks ;
   size_t uordblks ;
   size_t fordblks ;
   size_t keepcost ;
};
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 934
enum __anonenum__156 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 48 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
struct __anonstruct_157 {
   char device[129] ;
   char *ctl ;
   char *mixer_ctl ;
   snd_pcm_format_t format ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t period_size ;
   unsigned int rate ;
   int mmap ;
   int reopen ;
   u8_t *write_buf ;
   char const   *volume_mixer_name ;
   int mixer_linear ;
   snd_mixer_elem_t *mixer_elem ;
   snd_mixer_t *mixer_handle ;
   long mixer_min ;
   long mixer_max ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___11 {
    _PC_LINK_MAX___11 = 0,
    _PC_MAX_CANON___11 = 1,
    _PC_MAX_INPUT___11 = 2,
    _PC_NAME_MAX___11 = 3,
    _PC_PATH_MAX___11 = 4,
    _PC_PIPE_BUF___11 = 5,
    _PC_CHOWN_RESTRICTED___11 = 6,
    _PC_NO_TRUNC___11 = 7,
    _PC_VDISABLE___11 = 8,
    _PC_SYNC_IO___11 = 9,
    _PC_ASYNC_IO___11 = 10,
    _PC_PRIO_IO___11 = 11,
    _PC_SOCK_MAXBUF___11 = 12,
    _PC_FILESIZEBITS___11 = 13,
    _PC_REC_INCR_XFER_SIZE___11 = 14,
    _PC_REC_MAX_XFER_SIZE___11 = 15,
    _PC_REC_MIN_XFER_SIZE___11 = 16,
    _PC_REC_XFER_ALIGN___11 = 17,
    _PC_ALLOC_SIZE_MIN___11 = 18,
    _PC_SYMLINK_MAX___11 = 19,
    _PC_2_SYMLINKS___11 = 20
} ;
#line 71
enum __anonenum__20___11 {
    _SC_ARG_MAX___11 = 0,
    _SC_CHILD_MAX___11 = 1,
    _SC_CLK_TCK___11 = 2,
    _SC_NGROUPS_MAX___11 = 3,
    _SC_OPEN_MAX___11 = 4,
    _SC_STREAM_MAX___11 = 5,
    _SC_TZNAME_MAX___11 = 6,
    _SC_JOB_CONTROL___11 = 7,
    _SC_SAVED_IDS___11 = 8,
    _SC_REALTIME_SIGNALS___11 = 9,
    _SC_PRIORITY_SCHEDULING___11 = 10,
    _SC_TIMERS___11 = 11,
    _SC_ASYNCHRONOUS_IO___11 = 12,
    _SC_PRIORITIZED_IO___11 = 13,
    _SC_SYNCHRONIZED_IO___11 = 14,
    _SC_FSYNC___11 = 15,
    _SC_MAPPED_FILES___11 = 16,
    _SC_MEMLOCK___11 = 17,
    _SC_MEMLOCK_RANGE___11 = 18,
    _SC_MEMORY_PROTECTION___11 = 19,
    _SC_MESSAGE_PASSING___11 = 20,
    _SC_SEMAPHORES___11 = 21,
    _SC_SHARED_MEMORY_OBJECTS___11 = 22,
    _SC_AIO_LISTIO_MAX___11 = 23,
    _SC_AIO_MAX___11 = 24,
    _SC_AIO_PRIO_DELTA_MAX___11 = 25,
    _SC_DELAYTIMER_MAX___11 = 26,
    _SC_MQ_OPEN_MAX___11 = 27,
    _SC_MQ_PRIO_MAX___11 = 28,
    _SC_VERSION___11 = 29,
    _SC_PAGESIZE___11 = 30,
    _SC_RTSIG_MAX___11 = 31,
    _SC_SEM_NSEMS_MAX___11 = 32,
    _SC_SEM_VALUE_MAX___11 = 33,
    _SC_SIGQUEUE_MAX___11 = 34,
    _SC_TIMER_MAX___11 = 35,
    _SC_BC_BASE_MAX___11 = 36,
    _SC_BC_DIM_MAX___11 = 37,
    _SC_BC_SCALE_MAX___11 = 38,
    _SC_BC_STRING_MAX___11 = 39,
    _SC_COLL_WEIGHTS_MAX___11 = 40,
    _SC_EQUIV_CLASS_MAX___11 = 41,
    _SC_EXPR_NEST_MAX___11 = 42,
    _SC_LINE_MAX___11 = 43,
    _SC_RE_DUP_MAX___11 = 44,
    _SC_CHARCLASS_NAME_MAX___11 = 45,
    _SC_2_VERSION___11 = 46,
    _SC_2_C_BIND___11 = 47,
    _SC_2_C_DEV___11 = 48,
    _SC_2_FORT_DEV___11 = 49,
    _SC_2_FORT_RUN___11 = 50,
    _SC_2_SW_DEV___11 = 51,
    _SC_2_LOCALEDEF___11 = 52,
    _SC_PII___11 = 53,
    _SC_PII_XTI___11 = 54,
    _SC_PII_SOCKET___11 = 55,
    _SC_PII_INTERNET___11 = 56,
    _SC_PII_OSI___11 = 57,
    _SC_POLL___11 = 58,
    _SC_SELECT___11 = 59,
    _SC_UIO_MAXIOV___11 = 60,
    _SC_IOV_MAX___11 = 60,
    _SC_PII_INTERNET_STREAM___11 = 61,
    _SC_PII_INTERNET_DGRAM___11 = 62,
    _SC_PII_OSI_COTS___11 = 63,
    _SC_PII_OSI_CLTS___11 = 64,
    _SC_PII_OSI_M___11 = 65,
    _SC_T_IOV_MAX___11 = 66,
    _SC_THREADS___11 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___11 = 68,
    _SC_GETGR_R_SIZE_MAX___11 = 69,
    _SC_GETPW_R_SIZE_MAX___11 = 70,
    _SC_LOGIN_NAME_MAX___11 = 71,
    _SC_TTY_NAME_MAX___11 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___11 = 73,
    _SC_THREAD_KEYS_MAX___11 = 74,
    _SC_THREAD_STACK_MIN___11 = 75,
    _SC_THREAD_THREADS_MAX___11 = 76,
    _SC_THREAD_ATTR_STACKADDR___11 = 77,
    _SC_THREAD_ATTR_STACKSIZE___11 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___11 = 79,
    _SC_THREAD_PRIO_INHERIT___11 = 80,
    _SC_THREAD_PRIO_PROTECT___11 = 81,
    _SC_THREAD_PROCESS_SHARED___11 = 82,
    _SC_NPROCESSORS_CONF___11 = 83,
    _SC_NPROCESSORS_ONLN___11 = 84,
    _SC_PHYS_PAGES___11 = 85,
    _SC_AVPHYS_PAGES___11 = 86,
    _SC_ATEXIT_MAX___11 = 87,
    _SC_PASS_MAX___11 = 88,
    _SC_XOPEN_VERSION___11 = 89,
    _SC_XOPEN_XCU_VERSION___11 = 90,
    _SC_XOPEN_UNIX___11 = 91,
    _SC_XOPEN_CRYPT___11 = 92,
    _SC_XOPEN_ENH_I18N___11 = 93,
    _SC_XOPEN_SHM___11 = 94,
    _SC_2_CHAR_TERM___11 = 95,
    _SC_2_C_VERSION___11 = 96,
    _SC_2_UPE___11 = 97,
    _SC_XOPEN_XPG2___11 = 98,
    _SC_XOPEN_XPG3___11 = 99,
    _SC_XOPEN_XPG4___11 = 100,
    _SC_CHAR_BIT___11 = 101,
    _SC_CHAR_MAX___11 = 102,
    _SC_CHAR_MIN___11 = 103,
    _SC_INT_MAX___11 = 104,
    _SC_INT_MIN___11 = 105,
    _SC_LONG_BIT___11 = 106,
    _SC_WORD_BIT___11 = 107,
    _SC_MB_LEN_MAX___11 = 108,
    _SC_NZERO___11 = 109,
    _SC_SSIZE_MAX___11 = 110,
    _SC_SCHAR_MAX___11 = 111,
    _SC_SCHAR_MIN___11 = 112,
    _SC_SHRT_MAX___11 = 113,
    _SC_SHRT_MIN___11 = 114,
    _SC_UCHAR_MAX___11 = 115,
    _SC_UINT_MAX___11 = 116,
    _SC_ULONG_MAX___11 = 117,
    _SC_USHRT_MAX___11 = 118,
    _SC_NL_ARGMAX___11 = 119,
    _SC_NL_LANGMAX___11 = 120,
    _SC_NL_MSGMAX___11 = 121,
    _SC_NL_NMAX___11 = 122,
    _SC_NL_SETMAX___11 = 123,
    _SC_NL_TEXTMAX___11 = 124,
    _SC_XBS5_ILP32_OFF32___11 = 125,
    _SC_XBS5_ILP32_OFFBIG___11 = 126,
    _SC_XBS5_LP64_OFF64___11 = 127,
    _SC_XBS5_LPBIG_OFFBIG___11 = 128,
    _SC_XOPEN_LEGACY___11 = 129,
    _SC_XOPEN_REALTIME___11 = 130,
    _SC_XOPEN_REALTIME_THREADS___11 = 131,
    _SC_ADVISORY_INFO___11 = 132,
    _SC_BARRIERS___11 = 133,
    _SC_BASE___11 = 134,
    _SC_C_LANG_SUPPORT___11 = 135,
    _SC_C_LANG_SUPPORT_R___11 = 136,
    _SC_CLOCK_SELECTION___11 = 137,
    _SC_CPUTIME___11 = 138,
    _SC_THREAD_CPUTIME___11 = 139,
    _SC_DEVICE_IO___11 = 140,
    _SC_DEVICE_SPECIFIC___11 = 141,
    _SC_DEVICE_SPECIFIC_R___11 = 142,
    _SC_FD_MGMT___11 = 143,
    _SC_FIFO___11 = 144,
    _SC_PIPE___11 = 145,
    _SC_FILE_ATTRIBUTES___11 = 146,
    _SC_FILE_LOCKING___11 = 147,
    _SC_FILE_SYSTEM___11 = 148,
    _SC_MONOTONIC_CLOCK___11 = 149,
    _SC_MULTI_PROCESS___11 = 150,
    _SC_SINGLE_PROCESS___11 = 151,
    _SC_NETWORKING___11 = 152,
    _SC_READER_WRITER_LOCKS___11 = 153,
    _SC_SPIN_LOCKS___11 = 154,
    _SC_REGEXP___11 = 155,
    _SC_REGEX_VERSION___11 = 156,
    _SC_SHELL___11 = 157,
    _SC_SIGNALS___11 = 158,
    _SC_SPAWN___11 = 159,
    _SC_SPORADIC_SERVER___11 = 160,
    _SC_THREAD_SPORADIC_SERVER___11 = 161,
    _SC_SYSTEM_DATABASE___11 = 162,
    _SC_SYSTEM_DATABASE_R___11 = 163,
    _SC_TIMEOUTS___11 = 164,
    _SC_TYPED_MEMORY_OBJECTS___11 = 165,
    _SC_USER_GROUPS___11 = 166,
    _SC_USER_GROUPS_R___11 = 167,
    _SC_2_PBS___11 = 168,
    _SC_2_PBS_ACCOUNTING___11 = 169,
    _SC_2_PBS_LOCATE___11 = 170,
    _SC_2_PBS_MESSAGE___11 = 171,
    _SC_2_PBS_TRACK___11 = 172,
    _SC_SYMLOOP_MAX___11 = 173,
    _SC_STREAMS___11 = 174,
    _SC_2_PBS_CHECKPOINT___11 = 175,
    _SC_V6_ILP32_OFF32___11 = 176,
    _SC_V6_ILP32_OFFBIG___11 = 177,
    _SC_V6_LP64_OFF64___11 = 178,
    _SC_V6_LPBIG_OFFBIG___11 = 179,
    _SC_HOST_NAME_MAX___11 = 180,
    _SC_TRACE___11 = 181,
    _SC_TRACE_EVENT_FILTER___11 = 182,
    _SC_TRACE_INHERIT___11 = 183,
    _SC_TRACE_LOG___11 = 184,
    _SC_LEVEL1_ICACHE_SIZE___11 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___11 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___11 = 187,
    _SC_LEVEL1_DCACHE_SIZE___11 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___11 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___11 = 190,
    _SC_LEVEL2_CACHE_SIZE___11 = 191,
    _SC_LEVEL2_CACHE_ASSOC___11 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___11 = 193,
    _SC_LEVEL3_CACHE_SIZE___11 = 194,
    _SC_LEVEL3_CACHE_ASSOC___11 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___11 = 196,
    _SC_LEVEL4_CACHE_SIZE___11 = 197,
    _SC_LEVEL4_CACHE_ASSOC___11 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___11 = 199,
    _SC_IPV6___11 = 235,
    _SC_RAW_SOCKETS___11 = 236,
    _SC_V7_ILP32_OFF32___11 = 237,
    _SC_V7_ILP32_OFFBIG___11 = 238,
    _SC_V7_LP64_OFF64___11 = 239,
    _SC_V7_LPBIG_OFFBIG___11 = 240,
    _SC_SS_REPL_MAX___11 = 241,
    _SC_TRACE_EVENT_NAME_MAX___11 = 242,
    _SC_TRACE_NAME_MAX___11 = 243,
    _SC_TRACE_SYS_MAX___11 = 244,
    _SC_TRACE_USER_EVENT_MAX___11 = 245,
    _SC_XOPEN_STREAMS___11 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___11 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___11 = 248,
    _SC_MINSIGSTKSZ___11 = 249,
    _SC_SIGSTKSZ___11 = 250
} ;
#line 539
enum __anonenum__21___11 {
    _CS_PATH___11 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___11 = 1,
    _CS_GNU_LIBC_VERSION___11 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___11 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___11 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___11 = 5,
    _CS_LFS_CFLAGS___11 = 1000,
    _CS_LFS_LDFLAGS___11 = 1001,
    _CS_LFS_LIBS___11 = 1002,
    _CS_LFS_LINTFLAGS___11 = 1003,
    _CS_LFS64_CFLAGS___11 = 1004,
    _CS_LFS64_LDFLAGS___11 = 1005,
    _CS_LFS64_LIBS___11 = 1006,
    _CS_LFS64_LINTFLAGS___11 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___11 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___11 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___11 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___11 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___11 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___11 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___11 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___11 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___11 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___11 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___11 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___11 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___11 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___11 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___11 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___11 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___11 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___11 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___11 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___11 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___11 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___11 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___11 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___11 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___11 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___11 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___11 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___11 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___11 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___11 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___11 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___11 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___11 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___11 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___11 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___11 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___11 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___11 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___11 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___11 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___11 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___11 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___11 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___11 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___11 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___11 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___11 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___11 = 1147,
    _CS_V6_ENV___11 = 1148,
    _CS_V7_ENV___11 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___11 {
    MSG_OOB___11 = 1,
    MSG_PEEK___11 = 2,
    MSG_DONTROUTE___11 = 4,
    MSG_CTRUNC___11 = 8,
    MSG_PROXY___11 = 16,
    MSG_TRUNC___11 = 32,
    MSG_DONTWAIT___11 = 64,
    MSG_EOR___11 = 128,
    MSG_WAITALL___11 = 256,
    MSG_FIN___11 = 512,
    MSG_SYN___11 = 1024,
    MSG_CONFIRM___11 = 2048,
    MSG_RST___11 = 4096,
    MSG_ERRQUEUE___11 = 8192,
    MSG_NOSIGNAL___11 = 16384,
    MSG_MORE___11 = 32768,
    MSG_WAITFORONE___11 = 65536,
    MSG_BATCH___11 = 262144,
    MSG_ZEROCOPY___11 = 67108864,
    MSG_FASTOPEN___11 = 536870912,
    MSG_CMSG_CLOEXEC___11 = 1073741824
} ;
#line 334
enum __anonenum__23___11 {
    SCM_RIGHTS___11 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___11 {
    SHUT_RD___11 = 0,
    SHUT_WR___11 = 1,
    SHUT_RDWR___11 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___11 {
    IPPROTO_IP___11 = 0,
    IPPROTO_ICMP___11 = 1,
    IPPROTO_IGMP___11 = 2,
    IPPROTO_IPIP___11 = 4,
    IPPROTO_TCP___11 = 6,
    IPPROTO_EGP___11 = 8,
    IPPROTO_PUP___11 = 12,
    IPPROTO_UDP___11 = 17,
    IPPROTO_IDP___11 = 22,
    IPPROTO_TP___11 = 29,
    IPPROTO_DCCP___11 = 33,
    IPPROTO_IPV6___11 = 41,
    IPPROTO_RSVP___11 = 46,
    IPPROTO_GRE___11 = 47,
    IPPROTO_ESP___11 = 50,
    IPPROTO_AH___11 = 51,
    IPPROTO_MTP___11 = 92,
    IPPROTO_BEETPH___11 = 94,
    IPPROTO_ENCAP___11 = 98,
    IPPROTO_PIM___11 = 103,
    IPPROTO_COMP___11 = 108,
    IPPROTO_SCTP___11 = 132,
    IPPROTO_UDPLITE___11 = 136,
    IPPROTO_MPLS___11 = 137,
    IPPROTO_ETHERNET___11 = 143,
    IPPROTO_RAW___11 = 255,
    IPPROTO_MPTCP___11 = 262,
    IPPROTO_MAX___11 = 263
} ;
#line 103
enum __anonenum__28___11 {
    IPPROTO_HOPOPTS___11 = 0,
    IPPROTO_ROUTING___11 = 43,
    IPPROTO_FRAGMENT___11 = 44,
    IPPROTO_ICMPV6___11 = 58,
    IPPROTO_NONE___11 = 59,
    IPPROTO_DSTOPTS___11 = 60,
    IPPROTO_MH___11 = 135
} ;
#line 126
enum __anonenum__29___11 {
    IPPORT_ECHO___11 = 7,
    IPPORT_DISCARD___11 = 9,
    IPPORT_SYSTAT___11 = 11,
    IPPORT_DAYTIME___11 = 13,
    IPPORT_NETSTAT___11 = 15,
    IPPORT_FTP___11 = 21,
    IPPORT_TELNET___11 = 23,
    IPPORT_SMTP___11 = 25,
    IPPORT_TIMESERVER___11 = 37,
    IPPORT_NAMESERVER___11 = 42,
    IPPORT_WHOIS___11 = 43,
    IPPORT_MTP___11 = 57,
    IPPORT_TFTP___11 = 69,
    IPPORT_RJE___11 = 77,
    IPPORT_FINGER___11 = 79,
    IPPORT_TTYLINK___11 = 87,
    IPPORT_SUPDUP___11 = 95,
    IPPORT_EXECSERVER___11 = 512,
    IPPORT_LOGINSERVER___11 = 513,
    IPPORT_CMDSERVER___11 = 514,
    IPPORT_EFSSERVER___11 = 520,
    IPPORT_BIFFUDP___11 = 512,
    IPPORT_WHOSERVER___11 = 513,
    IPPORT_ROUTESERVER___11 = 520,
    IPPORT_RESERVED___11 = 1024,
    IPPORT_USERRESERVED___11 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___11 {
    PTHREAD_CREATE_JOINABLE___11 = 0,
    PTHREAD_CREATE_DETACHED___11 = 1
} ;
#line 47
enum __anonenum__33___11 {
    PTHREAD_MUTEX_TIMED_NP___11 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___11 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___11 = 3,
    PTHREAD_MUTEX_NORMAL___11 = 0,
    PTHREAD_MUTEX_RECURSIVE___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK___11 = 2,
    PTHREAD_MUTEX_DEFAULT___11 = 0
} ;
#line 69
enum __anonenum__34___11 {
    PTHREAD_MUTEX_STALLED___11 = 0,
    PTHREAD_MUTEX_STALLED_NP___11 = 0,
    PTHREAD_MUTEX_ROBUST___11 = 1,
    PTHREAD_MUTEX_ROBUST_NP___11 = 1
} ;
#line 81
enum __anonenum__35___11 {
    PTHREAD_PRIO_NONE___11 = 0,
    PTHREAD_PRIO_INHERIT___11 = 1,
    PTHREAD_PRIO_PROTECT___11 = 2
} ;
#line 104
enum __anonenum__36___11 {
    PTHREAD_RWLOCK_PREFER_READER_NP___11 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___11 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___11 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___11 = 0
} ;
#line 124
enum __anonenum__37___11 {
    PTHREAD_INHERIT_SCHED___11 = 0,
    PTHREAD_EXPLICIT_SCHED___11 = 1
} ;
#line 134
enum __anonenum__38___11 {
    PTHREAD_SCOPE_SYSTEM___11 = 0,
    PTHREAD_SCOPE_PROCESS___11 = 1
} ;
#line 144
enum __anonenum__39___11 {
    PTHREAD_PROCESS_PRIVATE___11 = 0,
    PTHREAD_PROCESS_SHARED___11 = 1
} ;
#line 168
enum __anonenum__40___11 {
    PTHREAD_CANCEL_ENABLE___11 = 0,
    PTHREAD_CANCEL_DISABLE___11 = 1
} ;
#line 175
enum __anonenum__41___11 {
    PTHREAD_CANCEL_DEFERRED___11 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___11 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___11 {
    SI_ASYNCNL___11 = -60,
    SI_DETHREAD___11 = -7,
    SI_TKILL___11 = -6,
    SI_SIGIO___11 = -5,
    SI_ASYNCIO___11 = -4,
    SI_MESGQ___11 = -3,
    SI_TIMER___11 = -2,
    SI_QUEUE___11 = -1,
    SI_USER___11 = 0,
    SI_KERNEL___11 = 128
} ;
#line 71
enum __anonenum__55___11 {
    ILL_ILLOPC___11 = 1,
    ILL_ILLOPN___11 = 2,
    ILL_ILLADR___11 = 3,
    ILL_ILLTRP___11 = 4,
    ILL_PRVOPC___11 = 5,
    ILL_PRVREG___11 = 6,
    ILL_COPROC___11 = 7,
    ILL_BADSTK___11 = 8,
    ILL_BADIADDR___11 = 9
} ;
#line 94
enum __anonenum__56___11 {
    FPE_INTDIV___11 = 1,
    FPE_INTOVF___11 = 2,
    FPE_FLTDIV___11 = 3,
    FPE_FLTOVF___11 = 4,
    FPE_FLTUND___11 = 5,
    FPE_FLTRES___11 = 6,
    FPE_FLTINV___11 = 7,
    FPE_FLTSUB___11 = 8,
    FPE_FLTUNK___11 = 14,
    FPE_CONDTRAP___11 = 15
} ;
#line 119
enum __anonenum__57___11 {
    SEGV_MAPERR___11 = 1,
    SEGV_ACCERR___11 = 2,
    SEGV_BNDERR___11 = 3,
    SEGV_PKUERR___11 = 4,
    SEGV_ACCADI___11 = 5,
    SEGV_ADIDERR___11 = 6,
    SEGV_ADIPERR___11 = 7,
    SEGV_MTEAERR___11 = 8,
    SEGV_MTESERR___11 = 9
} ;
#line 142
enum __anonenum__58___11 {
    BUS_ADRALN___11 = 1,
    BUS_ADRERR___11 = 2,
    BUS_OBJERR___11 = 3,
    BUS_MCEERR_AR___11 = 4,
    BUS_MCEERR_AO___11 = 5
} ;
#line 176
enum __anonenum__59___11 {
    CLD_EXITED___11 = 1,
    CLD_KILLED___11 = 2,
    CLD_DUMPED___11 = 3,
    CLD_TRAPPED___11 = 4,
    CLD_STOPPED___11 = 5,
    CLD_CONTINUED___11 = 6
} ;
#line 193
enum __anonenum__60___11 {
    POLL_IN___11 = 1,
    POLL_OUT___11 = 2,
    POLL_MSG___11 = 3,
    POLL_ERR___11 = 4,
    POLL_PRI___11 = 5,
    POLL_HUP___11 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___11 {
    SIGEV_SIGNAL___11 = 0,
    SIGEV_NONE___11 = 1,
    SIGEV_THREAD___11 = 2,
    SIGEV_THREAD_ID___11 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___11 {
    SS_ONSTACK___11 = 1,
    SS_DISABLE___11 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___11 {
    EFD_SEMAPHORE___11 = 1,
    EFD_CLOEXEC___11 = 524288,
    EFD_NONBLOCK___11 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___12 {
    _PC_LINK_MAX___12 = 0,
    _PC_MAX_CANON___12 = 1,
    _PC_MAX_INPUT___12 = 2,
    _PC_NAME_MAX___12 = 3,
    _PC_PATH_MAX___12 = 4,
    _PC_PIPE_BUF___12 = 5,
    _PC_CHOWN_RESTRICTED___12 = 6,
    _PC_NO_TRUNC___12 = 7,
    _PC_VDISABLE___12 = 8,
    _PC_SYNC_IO___12 = 9,
    _PC_ASYNC_IO___12 = 10,
    _PC_PRIO_IO___12 = 11,
    _PC_SOCK_MAXBUF___12 = 12,
    _PC_FILESIZEBITS___12 = 13,
    _PC_REC_INCR_XFER_SIZE___12 = 14,
    _PC_REC_MAX_XFER_SIZE___12 = 15,
    _PC_REC_MIN_XFER_SIZE___12 = 16,
    _PC_REC_XFER_ALIGN___12 = 17,
    _PC_ALLOC_SIZE_MIN___12 = 18,
    _PC_SYMLINK_MAX___12 = 19,
    _PC_2_SYMLINKS___12 = 20
} ;
#line 71
enum __anonenum__20___12 {
    _SC_ARG_MAX___12 = 0,
    _SC_CHILD_MAX___12 = 1,
    _SC_CLK_TCK___12 = 2,
    _SC_NGROUPS_MAX___12 = 3,
    _SC_OPEN_MAX___12 = 4,
    _SC_STREAM_MAX___12 = 5,
    _SC_TZNAME_MAX___12 = 6,
    _SC_JOB_CONTROL___12 = 7,
    _SC_SAVED_IDS___12 = 8,
    _SC_REALTIME_SIGNALS___12 = 9,
    _SC_PRIORITY_SCHEDULING___12 = 10,
    _SC_TIMERS___12 = 11,
    _SC_ASYNCHRONOUS_IO___12 = 12,
    _SC_PRIORITIZED_IO___12 = 13,
    _SC_SYNCHRONIZED_IO___12 = 14,
    _SC_FSYNC___12 = 15,
    _SC_MAPPED_FILES___12 = 16,
    _SC_MEMLOCK___12 = 17,
    _SC_MEMLOCK_RANGE___12 = 18,
    _SC_MEMORY_PROTECTION___12 = 19,
    _SC_MESSAGE_PASSING___12 = 20,
    _SC_SEMAPHORES___12 = 21,
    _SC_SHARED_MEMORY_OBJECTS___12 = 22,
    _SC_AIO_LISTIO_MAX___12 = 23,
    _SC_AIO_MAX___12 = 24,
    _SC_AIO_PRIO_DELTA_MAX___12 = 25,
    _SC_DELAYTIMER_MAX___12 = 26,
    _SC_MQ_OPEN_MAX___12 = 27,
    _SC_MQ_PRIO_MAX___12 = 28,
    _SC_VERSION___12 = 29,
    _SC_PAGESIZE___12 = 30,
    _SC_RTSIG_MAX___12 = 31,
    _SC_SEM_NSEMS_MAX___12 = 32,
    _SC_SEM_VALUE_MAX___12 = 33,
    _SC_SIGQUEUE_MAX___12 = 34,
    _SC_TIMER_MAX___12 = 35,
    _SC_BC_BASE_MAX___12 = 36,
    _SC_BC_DIM_MAX___12 = 37,
    _SC_BC_SCALE_MAX___12 = 38,
    _SC_BC_STRING_MAX___12 = 39,
    _SC_COLL_WEIGHTS_MAX___12 = 40,
    _SC_EQUIV_CLASS_MAX___12 = 41,
    _SC_EXPR_NEST_MAX___12 = 42,
    _SC_LINE_MAX___12 = 43,
    _SC_RE_DUP_MAX___12 = 44,
    _SC_CHARCLASS_NAME_MAX___12 = 45,
    _SC_2_VERSION___12 = 46,
    _SC_2_C_BIND___12 = 47,
    _SC_2_C_DEV___12 = 48,
    _SC_2_FORT_DEV___12 = 49,
    _SC_2_FORT_RUN___12 = 50,
    _SC_2_SW_DEV___12 = 51,
    _SC_2_LOCALEDEF___12 = 52,
    _SC_PII___12 = 53,
    _SC_PII_XTI___12 = 54,
    _SC_PII_SOCKET___12 = 55,
    _SC_PII_INTERNET___12 = 56,
    _SC_PII_OSI___12 = 57,
    _SC_POLL___12 = 58,
    _SC_SELECT___12 = 59,
    _SC_UIO_MAXIOV___12 = 60,
    _SC_IOV_MAX___12 = 60,
    _SC_PII_INTERNET_STREAM___12 = 61,
    _SC_PII_INTERNET_DGRAM___12 = 62,
    _SC_PII_OSI_COTS___12 = 63,
    _SC_PII_OSI_CLTS___12 = 64,
    _SC_PII_OSI_M___12 = 65,
    _SC_T_IOV_MAX___12 = 66,
    _SC_THREADS___12 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___12 = 68,
    _SC_GETGR_R_SIZE_MAX___12 = 69,
    _SC_GETPW_R_SIZE_MAX___12 = 70,
    _SC_LOGIN_NAME_MAX___12 = 71,
    _SC_TTY_NAME_MAX___12 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___12 = 73,
    _SC_THREAD_KEYS_MAX___12 = 74,
    _SC_THREAD_STACK_MIN___12 = 75,
    _SC_THREAD_THREADS_MAX___12 = 76,
    _SC_THREAD_ATTR_STACKADDR___12 = 77,
    _SC_THREAD_ATTR_STACKSIZE___12 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___12 = 79,
    _SC_THREAD_PRIO_INHERIT___12 = 80,
    _SC_THREAD_PRIO_PROTECT___12 = 81,
    _SC_THREAD_PROCESS_SHARED___12 = 82,
    _SC_NPROCESSORS_CONF___12 = 83,
    _SC_NPROCESSORS_ONLN___12 = 84,
    _SC_PHYS_PAGES___12 = 85,
    _SC_AVPHYS_PAGES___12 = 86,
    _SC_ATEXIT_MAX___12 = 87,
    _SC_PASS_MAX___12 = 88,
    _SC_XOPEN_VERSION___12 = 89,
    _SC_XOPEN_XCU_VERSION___12 = 90,
    _SC_XOPEN_UNIX___12 = 91,
    _SC_XOPEN_CRYPT___12 = 92,
    _SC_XOPEN_ENH_I18N___12 = 93,
    _SC_XOPEN_SHM___12 = 94,
    _SC_2_CHAR_TERM___12 = 95,
    _SC_2_C_VERSION___12 = 96,
    _SC_2_UPE___12 = 97,
    _SC_XOPEN_XPG2___12 = 98,
    _SC_XOPEN_XPG3___12 = 99,
    _SC_XOPEN_XPG4___12 = 100,
    _SC_CHAR_BIT___12 = 101,
    _SC_CHAR_MAX___12 = 102,
    _SC_CHAR_MIN___12 = 103,
    _SC_INT_MAX___12 = 104,
    _SC_INT_MIN___12 = 105,
    _SC_LONG_BIT___12 = 106,
    _SC_WORD_BIT___12 = 107,
    _SC_MB_LEN_MAX___12 = 108,
    _SC_NZERO___12 = 109,
    _SC_SSIZE_MAX___12 = 110,
    _SC_SCHAR_MAX___12 = 111,
    _SC_SCHAR_MIN___12 = 112,
    _SC_SHRT_MAX___12 = 113,
    _SC_SHRT_MIN___12 = 114,
    _SC_UCHAR_MAX___12 = 115,
    _SC_UINT_MAX___12 = 116,
    _SC_ULONG_MAX___12 = 117,
    _SC_USHRT_MAX___12 = 118,
    _SC_NL_ARGMAX___12 = 119,
    _SC_NL_LANGMAX___12 = 120,
    _SC_NL_MSGMAX___12 = 121,
    _SC_NL_NMAX___12 = 122,
    _SC_NL_SETMAX___12 = 123,
    _SC_NL_TEXTMAX___12 = 124,
    _SC_XBS5_ILP32_OFF32___12 = 125,
    _SC_XBS5_ILP32_OFFBIG___12 = 126,
    _SC_XBS5_LP64_OFF64___12 = 127,
    _SC_XBS5_LPBIG_OFFBIG___12 = 128,
    _SC_XOPEN_LEGACY___12 = 129,
    _SC_XOPEN_REALTIME___12 = 130,
    _SC_XOPEN_REALTIME_THREADS___12 = 131,
    _SC_ADVISORY_INFO___12 = 132,
    _SC_BARRIERS___12 = 133,
    _SC_BASE___12 = 134,
    _SC_C_LANG_SUPPORT___12 = 135,
    _SC_C_LANG_SUPPORT_R___12 = 136,
    _SC_CLOCK_SELECTION___12 = 137,
    _SC_CPUTIME___12 = 138,
    _SC_THREAD_CPUTIME___12 = 139,
    _SC_DEVICE_IO___12 = 140,
    _SC_DEVICE_SPECIFIC___12 = 141,
    _SC_DEVICE_SPECIFIC_R___12 = 142,
    _SC_FD_MGMT___12 = 143,
    _SC_FIFO___12 = 144,
    _SC_PIPE___12 = 145,
    _SC_FILE_ATTRIBUTES___12 = 146,
    _SC_FILE_LOCKING___12 = 147,
    _SC_FILE_SYSTEM___12 = 148,
    _SC_MONOTONIC_CLOCK___12 = 149,
    _SC_MULTI_PROCESS___12 = 150,
    _SC_SINGLE_PROCESS___12 = 151,
    _SC_NETWORKING___12 = 152,
    _SC_READER_WRITER_LOCKS___12 = 153,
    _SC_SPIN_LOCKS___12 = 154,
    _SC_REGEXP___12 = 155,
    _SC_REGEX_VERSION___12 = 156,
    _SC_SHELL___12 = 157,
    _SC_SIGNALS___12 = 158,
    _SC_SPAWN___12 = 159,
    _SC_SPORADIC_SERVER___12 = 160,
    _SC_THREAD_SPORADIC_SERVER___12 = 161,
    _SC_SYSTEM_DATABASE___12 = 162,
    _SC_SYSTEM_DATABASE_R___12 = 163,
    _SC_TIMEOUTS___12 = 164,
    _SC_TYPED_MEMORY_OBJECTS___12 = 165,
    _SC_USER_GROUPS___12 = 166,
    _SC_USER_GROUPS_R___12 = 167,
    _SC_2_PBS___12 = 168,
    _SC_2_PBS_ACCOUNTING___12 = 169,
    _SC_2_PBS_LOCATE___12 = 170,
    _SC_2_PBS_MESSAGE___12 = 171,
    _SC_2_PBS_TRACK___12 = 172,
    _SC_SYMLOOP_MAX___12 = 173,
    _SC_STREAMS___12 = 174,
    _SC_2_PBS_CHECKPOINT___12 = 175,
    _SC_V6_ILP32_OFF32___12 = 176,
    _SC_V6_ILP32_OFFBIG___12 = 177,
    _SC_V6_LP64_OFF64___12 = 178,
    _SC_V6_LPBIG_OFFBIG___12 = 179,
    _SC_HOST_NAME_MAX___12 = 180,
    _SC_TRACE___12 = 181,
    _SC_TRACE_EVENT_FILTER___12 = 182,
    _SC_TRACE_INHERIT___12 = 183,
    _SC_TRACE_LOG___12 = 184,
    _SC_LEVEL1_ICACHE_SIZE___12 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___12 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___12 = 187,
    _SC_LEVEL1_DCACHE_SIZE___12 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___12 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___12 = 190,
    _SC_LEVEL2_CACHE_SIZE___12 = 191,
    _SC_LEVEL2_CACHE_ASSOC___12 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___12 = 193,
    _SC_LEVEL3_CACHE_SIZE___12 = 194,
    _SC_LEVEL3_CACHE_ASSOC___12 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___12 = 196,
    _SC_LEVEL4_CACHE_SIZE___12 = 197,
    _SC_LEVEL4_CACHE_ASSOC___12 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___12 = 199,
    _SC_IPV6___12 = 235,
    _SC_RAW_SOCKETS___12 = 236,
    _SC_V7_ILP32_OFF32___12 = 237,
    _SC_V7_ILP32_OFFBIG___12 = 238,
    _SC_V7_LP64_OFF64___12 = 239,
    _SC_V7_LPBIG_OFFBIG___12 = 240,
    _SC_SS_REPL_MAX___12 = 241,
    _SC_TRACE_EVENT_NAME_MAX___12 = 242,
    _SC_TRACE_NAME_MAX___12 = 243,
    _SC_TRACE_SYS_MAX___12 = 244,
    _SC_TRACE_USER_EVENT_MAX___12 = 245,
    _SC_XOPEN_STREAMS___12 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___12 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___12 = 248,
    _SC_MINSIGSTKSZ___12 = 249,
    _SC_SIGSTKSZ___12 = 250
} ;
#line 539
enum __anonenum__21___12 {
    _CS_PATH___12 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___12 = 1,
    _CS_GNU_LIBC_VERSION___12 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___12 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___12 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___12 = 5,
    _CS_LFS_CFLAGS___12 = 1000,
    _CS_LFS_LDFLAGS___12 = 1001,
    _CS_LFS_LIBS___12 = 1002,
    _CS_LFS_LINTFLAGS___12 = 1003,
    _CS_LFS64_CFLAGS___12 = 1004,
    _CS_LFS64_LDFLAGS___12 = 1005,
    _CS_LFS64_LIBS___12 = 1006,
    _CS_LFS64_LINTFLAGS___12 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___12 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___12 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___12 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___12 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___12 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___12 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___12 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___12 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___12 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___12 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___12 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___12 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___12 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___12 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___12 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___12 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___12 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___12 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___12 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___12 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___12 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___12 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___12 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___12 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___12 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___12 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___12 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___12 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___12 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___12 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___12 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___12 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___12 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___12 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___12 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___12 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___12 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___12 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___12 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___12 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___12 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___12 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___12 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___12 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___12 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___12 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___12 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___12 = 1147,
    _CS_V6_ENV___12 = 1148,
    _CS_V7_ENV___12 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___12 {
    MSG_OOB___12 = 1,
    MSG_PEEK___12 = 2,
    MSG_DONTROUTE___12 = 4,
    MSG_CTRUNC___12 = 8,
    MSG_PROXY___12 = 16,
    MSG_TRUNC___12 = 32,
    MSG_DONTWAIT___12 = 64,
    MSG_EOR___12 = 128,
    MSG_WAITALL___12 = 256,
    MSG_FIN___12 = 512,
    MSG_SYN___12 = 1024,
    MSG_CONFIRM___12 = 2048,
    MSG_RST___12 = 4096,
    MSG_ERRQUEUE___12 = 8192,
    MSG_NOSIGNAL___12 = 16384,
    MSG_MORE___12 = 32768,
    MSG_WAITFORONE___12 = 65536,
    MSG_BATCH___12 = 262144,
    MSG_ZEROCOPY___12 = 67108864,
    MSG_FASTOPEN___12 = 536870912,
    MSG_CMSG_CLOEXEC___12 = 1073741824
} ;
#line 334
enum __anonenum__23___12 {
    SCM_RIGHTS___12 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___12 {
    SHUT_RD___12 = 0,
    SHUT_WR___12 = 1,
    SHUT_RDWR___12 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___12 {
    IPPROTO_IP___12 = 0,
    IPPROTO_ICMP___12 = 1,
    IPPROTO_IGMP___12 = 2,
    IPPROTO_IPIP___12 = 4,
    IPPROTO_TCP___12 = 6,
    IPPROTO_EGP___12 = 8,
    IPPROTO_PUP___12 = 12,
    IPPROTO_UDP___12 = 17,
    IPPROTO_IDP___12 = 22,
    IPPROTO_TP___12 = 29,
    IPPROTO_DCCP___12 = 33,
    IPPROTO_IPV6___12 = 41,
    IPPROTO_RSVP___12 = 46,
    IPPROTO_GRE___12 = 47,
    IPPROTO_ESP___12 = 50,
    IPPROTO_AH___12 = 51,
    IPPROTO_MTP___12 = 92,
    IPPROTO_BEETPH___12 = 94,
    IPPROTO_ENCAP___12 = 98,
    IPPROTO_PIM___12 = 103,
    IPPROTO_COMP___12 = 108,
    IPPROTO_SCTP___12 = 132,
    IPPROTO_UDPLITE___12 = 136,
    IPPROTO_MPLS___12 = 137,
    IPPROTO_ETHERNET___12 = 143,
    IPPROTO_RAW___12 = 255,
    IPPROTO_MPTCP___12 = 262,
    IPPROTO_MAX___12 = 263
} ;
#line 103
enum __anonenum__28___12 {
    IPPROTO_HOPOPTS___12 = 0,
    IPPROTO_ROUTING___12 = 43,
    IPPROTO_FRAGMENT___12 = 44,
    IPPROTO_ICMPV6___12 = 58,
    IPPROTO_NONE___12 = 59,
    IPPROTO_DSTOPTS___12 = 60,
    IPPROTO_MH___12 = 135
} ;
#line 126
enum __anonenum__29___12 {
    IPPORT_ECHO___12 = 7,
    IPPORT_DISCARD___12 = 9,
    IPPORT_SYSTAT___12 = 11,
    IPPORT_DAYTIME___12 = 13,
    IPPORT_NETSTAT___12 = 15,
    IPPORT_FTP___12 = 21,
    IPPORT_TELNET___12 = 23,
    IPPORT_SMTP___12 = 25,
    IPPORT_TIMESERVER___12 = 37,
    IPPORT_NAMESERVER___12 = 42,
    IPPORT_WHOIS___12 = 43,
    IPPORT_MTP___12 = 57,
    IPPORT_TFTP___12 = 69,
    IPPORT_RJE___12 = 77,
    IPPORT_FINGER___12 = 79,
    IPPORT_TTYLINK___12 = 87,
    IPPORT_SUPDUP___12 = 95,
    IPPORT_EXECSERVER___12 = 512,
    IPPORT_LOGINSERVER___12 = 513,
    IPPORT_CMDSERVER___12 = 514,
    IPPORT_EFSSERVER___12 = 520,
    IPPORT_BIFFUDP___12 = 512,
    IPPORT_WHOSERVER___12 = 513,
    IPPORT_ROUTESERVER___12 = 520,
    IPPORT_RESERVED___12 = 1024,
    IPPORT_USERRESERVED___12 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___12 {
    PTHREAD_CREATE_JOINABLE___12 = 0,
    PTHREAD_CREATE_DETACHED___12 = 1
} ;
#line 47
enum __anonenum__33___12 {
    PTHREAD_MUTEX_TIMED_NP___12 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___12 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___12 = 3,
    PTHREAD_MUTEX_NORMAL___12 = 0,
    PTHREAD_MUTEX_RECURSIVE___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK___12 = 2,
    PTHREAD_MUTEX_DEFAULT___12 = 0
} ;
#line 69
enum __anonenum__34___12 {
    PTHREAD_MUTEX_STALLED___12 = 0,
    PTHREAD_MUTEX_STALLED_NP___12 = 0,
    PTHREAD_MUTEX_ROBUST___12 = 1,
    PTHREAD_MUTEX_ROBUST_NP___12 = 1
} ;
#line 81
enum __anonenum__35___12 {
    PTHREAD_PRIO_NONE___12 = 0,
    PTHREAD_PRIO_INHERIT___12 = 1,
    PTHREAD_PRIO_PROTECT___12 = 2
} ;
#line 104
enum __anonenum__36___12 {
    PTHREAD_RWLOCK_PREFER_READER_NP___12 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___12 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___12 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___12 = 0
} ;
#line 124
enum __anonenum__37___12 {
    PTHREAD_INHERIT_SCHED___12 = 0,
    PTHREAD_EXPLICIT_SCHED___12 = 1
} ;
#line 134
enum __anonenum__38___12 {
    PTHREAD_SCOPE_SYSTEM___12 = 0,
    PTHREAD_SCOPE_PROCESS___12 = 1
} ;
#line 144
enum __anonenum__39___12 {
    PTHREAD_PROCESS_PRIVATE___12 = 0,
    PTHREAD_PROCESS_SHARED___12 = 1
} ;
#line 168
enum __anonenum__40___12 {
    PTHREAD_CANCEL_ENABLE___12 = 0,
    PTHREAD_CANCEL_DISABLE___12 = 1
} ;
#line 175
enum __anonenum__41___12 {
    PTHREAD_CANCEL_DEFERRED___12 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___12 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___12 {
    SI_ASYNCNL___12 = -60,
    SI_DETHREAD___12 = -7,
    SI_TKILL___12 = -6,
    SI_SIGIO___12 = -5,
    SI_ASYNCIO___12 = -4,
    SI_MESGQ___12 = -3,
    SI_TIMER___12 = -2,
    SI_QUEUE___12 = -1,
    SI_USER___12 = 0,
    SI_KERNEL___12 = 128
} ;
#line 71
enum __anonenum__55___12 {
    ILL_ILLOPC___12 = 1,
    ILL_ILLOPN___12 = 2,
    ILL_ILLADR___12 = 3,
    ILL_ILLTRP___12 = 4,
    ILL_PRVOPC___12 = 5,
    ILL_PRVREG___12 = 6,
    ILL_COPROC___12 = 7,
    ILL_BADSTK___12 = 8,
    ILL_BADIADDR___12 = 9
} ;
#line 94
enum __anonenum__56___12 {
    FPE_INTDIV___12 = 1,
    FPE_INTOVF___12 = 2,
    FPE_FLTDIV___12 = 3,
    FPE_FLTOVF___12 = 4,
    FPE_FLTUND___12 = 5,
    FPE_FLTRES___12 = 6,
    FPE_FLTINV___12 = 7,
    FPE_FLTSUB___12 = 8,
    FPE_FLTUNK___12 = 14,
    FPE_CONDTRAP___12 = 15
} ;
#line 119
enum __anonenum__57___12 {
    SEGV_MAPERR___12 = 1,
    SEGV_ACCERR___12 = 2,
    SEGV_BNDERR___12 = 3,
    SEGV_PKUERR___12 = 4,
    SEGV_ACCADI___12 = 5,
    SEGV_ADIDERR___12 = 6,
    SEGV_ADIPERR___12 = 7,
    SEGV_MTEAERR___12 = 8,
    SEGV_MTESERR___12 = 9
} ;
#line 142
enum __anonenum__58___12 {
    BUS_ADRALN___12 = 1,
    BUS_ADRERR___12 = 2,
    BUS_OBJERR___12 = 3,
    BUS_MCEERR_AR___12 = 4,
    BUS_MCEERR_AO___12 = 5
} ;
#line 176
enum __anonenum__59___12 {
    CLD_EXITED___12 = 1,
    CLD_KILLED___12 = 2,
    CLD_DUMPED___12 = 3,
    CLD_TRAPPED___12 = 4,
    CLD_STOPPED___12 = 5,
    CLD_CONTINUED___12 = 6
} ;
#line 193
enum __anonenum__60___12 {
    POLL_IN___12 = 1,
    POLL_OUT___12 = 2,
    POLL_MSG___12 = 3,
    POLL_ERR___12 = 4,
    POLL_PRI___12 = 5,
    POLL_HUP___12 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___12 {
    SIGEV_SIGNAL___12 = 0,
    SIGEV_NONE___12 = 1,
    SIGEV_THREAD___12 = 2,
    SIGEV_THREAD_ID___12 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___12 {
    SS_ONSTACK___12 = 1,
    SS_DISABLE___12 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___12 {
    EFD_SEMAPHORE___12 = 1,
    EFD_CLOEXEC___12 = 524288,
    EFD_NONBLOCK___12 = 2048
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 33 "/usr/include/net/if.h"
struct if_nameindex {
   unsigned int if_index ;
   char *if_name ;
};
#line 42
enum __anonenum__158 {
    IFF_UP = 1,
    IFF_BROADCAST = 2,
    IFF_DEBUG = 4,
    IFF_LOOPBACK = 8,
    IFF_POINTOPOINT = 16,
    IFF_NOTRAILERS = 32,
    IFF_RUNNING = 64,
    IFF_NOARP = 128,
    IFF_PROMISC = 256,
    IFF_ALLMULTI = 512,
    IFF_MASTER = 1024,
    IFF_SLAVE = 2048,
    IFF_MULTICAST = 4096,
    IFF_PORTSEL = 8192,
    IFF_AUTOMEDIA = 16384,
    IFF_DYNAMIC = 32768
} ;
#line 91 "/usr/include/net/if.h"
union __anonunion_159 {
   struct sockaddr ifu_broadaddr ;
   struct sockaddr ifu_dstaddr ;
};
#line 96
struct iface ;
#line 88 "/usr/include/net/if.h"
struct ifaddr {
   struct sockaddr ifa_addr ;
   union __anonunion_159 ifa_ifu ;
   struct iface *ifa_ifp ;
   struct ifaddr *ifa_next ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 130 "/usr/include/net/if.h"
union __anonunion_160 {
   char ifrn_name[16] ;
};
#line 135 "/usr/include/net/if.h"
union __anonunion_161 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_160 ifr_ifrn ;
   union __anonunion_161 ifr_ifru ;
};
#line 179 "/usr/include/net/if.h"
union __anonunion_162 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_162 ifc_ifcu ;
};
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 98 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 255 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 324 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void * , char * , size_t  );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void * , char const   * , size_t  );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void * , __off64_t * , int  );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void * );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 70 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 89 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 850
struct obstack ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 819 "/usr/include/stdlib.h"
typedef __compar_fn_t comparison_fn_t;
#line 823 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h"
typedef int error_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__179 {
    _PC_LINK_MAX___13 = 0,
    _PC_MAX_CANON___13 = 1,
    _PC_MAX_INPUT___13 = 2,
    _PC_NAME_MAX___13 = 3,
    _PC_PATH_MAX___13 = 4,
    _PC_PIPE_BUF___13 = 5,
    _PC_CHOWN_RESTRICTED___13 = 6,
    _PC_NO_TRUNC___13 = 7,
    _PC_VDISABLE___13 = 8,
    _PC_SYNC_IO___13 = 9,
    _PC_ASYNC_IO___13 = 10,
    _PC_PRIO_IO___13 = 11,
    _PC_SOCK_MAXBUF___13 = 12,
    _PC_FILESIZEBITS___13 = 13,
    _PC_REC_INCR_XFER_SIZE___13 = 14,
    _PC_REC_MAX_XFER_SIZE___13 = 15,
    _PC_REC_MIN_XFER_SIZE___13 = 16,
    _PC_REC_XFER_ALIGN___13 = 17,
    _PC_ALLOC_SIZE_MIN___13 = 18,
    _PC_SYMLINK_MAX___13 = 19,
    _PC_2_SYMLINKS___13 = 20
} ;
#line 71
enum __anonenum__180 {
    _SC_ARG_MAX___13 = 0,
    _SC_CHILD_MAX___13 = 1,
    _SC_CLK_TCK___13 = 2,
    _SC_NGROUPS_MAX___13 = 3,
    _SC_OPEN_MAX___13 = 4,
    _SC_STREAM_MAX___13 = 5,
    _SC_TZNAME_MAX___13 = 6,
    _SC_JOB_CONTROL___13 = 7,
    _SC_SAVED_IDS___13 = 8,
    _SC_REALTIME_SIGNALS___13 = 9,
    _SC_PRIORITY_SCHEDULING___13 = 10,
    _SC_TIMERS___13 = 11,
    _SC_ASYNCHRONOUS_IO___13 = 12,
    _SC_PRIORITIZED_IO___13 = 13,
    _SC_SYNCHRONIZED_IO___13 = 14,
    _SC_FSYNC___13 = 15,
    _SC_MAPPED_FILES___13 = 16,
    _SC_MEMLOCK___13 = 17,
    _SC_MEMLOCK_RANGE___13 = 18,
    _SC_MEMORY_PROTECTION___13 = 19,
    _SC_MESSAGE_PASSING___13 = 20,
    _SC_SEMAPHORES___13 = 21,
    _SC_SHARED_MEMORY_OBJECTS___13 = 22,
    _SC_AIO_LISTIO_MAX___13 = 23,
    _SC_AIO_MAX___13 = 24,
    _SC_AIO_PRIO_DELTA_MAX___13 = 25,
    _SC_DELAYTIMER_MAX___13 = 26,
    _SC_MQ_OPEN_MAX___13 = 27,
    _SC_MQ_PRIO_MAX___13 = 28,
    _SC_VERSION___13 = 29,
    _SC_PAGESIZE___13 = 30,
    _SC_RTSIG_MAX___13 = 31,
    _SC_SEM_NSEMS_MAX___13 = 32,
    _SC_SEM_VALUE_MAX___13 = 33,
    _SC_SIGQUEUE_MAX___13 = 34,
    _SC_TIMER_MAX___13 = 35,
    _SC_BC_BASE_MAX___13 = 36,
    _SC_BC_DIM_MAX___13 = 37,
    _SC_BC_SCALE_MAX___13 = 38,
    _SC_BC_STRING_MAX___13 = 39,
    _SC_COLL_WEIGHTS_MAX___13 = 40,
    _SC_EQUIV_CLASS_MAX___13 = 41,
    _SC_EXPR_NEST_MAX___13 = 42,
    _SC_LINE_MAX___13 = 43,
    _SC_RE_DUP_MAX___13 = 44,
    _SC_CHARCLASS_NAME_MAX___13 = 45,
    _SC_2_VERSION___13 = 46,
    _SC_2_C_BIND___13 = 47,
    _SC_2_C_DEV___13 = 48,
    _SC_2_FORT_DEV___13 = 49,
    _SC_2_FORT_RUN___13 = 50,
    _SC_2_SW_DEV___13 = 51,
    _SC_2_LOCALEDEF___13 = 52,
    _SC_PII___13 = 53,
    _SC_PII_XTI___13 = 54,
    _SC_PII_SOCKET___13 = 55,
    _SC_PII_INTERNET___13 = 56,
    _SC_PII_OSI___13 = 57,
    _SC_POLL___13 = 58,
    _SC_SELECT___13 = 59,
    _SC_UIO_MAXIOV___13 = 60,
    _SC_IOV_MAX___13 = 60,
    _SC_PII_INTERNET_STREAM___13 = 61,
    _SC_PII_INTERNET_DGRAM___13 = 62,
    _SC_PII_OSI_COTS___13 = 63,
    _SC_PII_OSI_CLTS___13 = 64,
    _SC_PII_OSI_M___13 = 65,
    _SC_T_IOV_MAX___13 = 66,
    _SC_THREADS___13 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___13 = 68,
    _SC_GETGR_R_SIZE_MAX___13 = 69,
    _SC_GETPW_R_SIZE_MAX___13 = 70,
    _SC_LOGIN_NAME_MAX___13 = 71,
    _SC_TTY_NAME_MAX___13 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___13 = 73,
    _SC_THREAD_KEYS_MAX___13 = 74,
    _SC_THREAD_STACK_MIN___13 = 75,
    _SC_THREAD_THREADS_MAX___13 = 76,
    _SC_THREAD_ATTR_STACKADDR___13 = 77,
    _SC_THREAD_ATTR_STACKSIZE___13 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___13 = 79,
    _SC_THREAD_PRIO_INHERIT___13 = 80,
    _SC_THREAD_PRIO_PROTECT___13 = 81,
    _SC_THREAD_PROCESS_SHARED___13 = 82,
    _SC_NPROCESSORS_CONF___13 = 83,
    _SC_NPROCESSORS_ONLN___13 = 84,
    _SC_PHYS_PAGES___13 = 85,
    _SC_AVPHYS_PAGES___13 = 86,
    _SC_ATEXIT_MAX___13 = 87,
    _SC_PASS_MAX___13 = 88,
    _SC_XOPEN_VERSION___13 = 89,
    _SC_XOPEN_XCU_VERSION___13 = 90,
    _SC_XOPEN_UNIX___13 = 91,
    _SC_XOPEN_CRYPT___13 = 92,
    _SC_XOPEN_ENH_I18N___13 = 93,
    _SC_XOPEN_SHM___13 = 94,
    _SC_2_CHAR_TERM___13 = 95,
    _SC_2_C_VERSION___13 = 96,
    _SC_2_UPE___13 = 97,
    _SC_XOPEN_XPG2___13 = 98,
    _SC_XOPEN_XPG3___13 = 99,
    _SC_XOPEN_XPG4___13 = 100,
    _SC_CHAR_BIT___13 = 101,
    _SC_CHAR_MAX___13 = 102,
    _SC_CHAR_MIN___13 = 103,
    _SC_INT_MAX___13 = 104,
    _SC_INT_MIN___13 = 105,
    _SC_LONG_BIT___13 = 106,
    _SC_WORD_BIT___13 = 107,
    _SC_MB_LEN_MAX___13 = 108,
    _SC_NZERO___13 = 109,
    _SC_SSIZE_MAX___13 = 110,
    _SC_SCHAR_MAX___13 = 111,
    _SC_SCHAR_MIN___13 = 112,
    _SC_SHRT_MAX___13 = 113,
    _SC_SHRT_MIN___13 = 114,
    _SC_UCHAR_MAX___13 = 115,
    _SC_UINT_MAX___13 = 116,
    _SC_ULONG_MAX___13 = 117,
    _SC_USHRT_MAX___13 = 118,
    _SC_NL_ARGMAX___13 = 119,
    _SC_NL_LANGMAX___13 = 120,
    _SC_NL_MSGMAX___13 = 121,
    _SC_NL_NMAX___13 = 122,
    _SC_NL_SETMAX___13 = 123,
    _SC_NL_TEXTMAX___13 = 124,
    _SC_XBS5_ILP32_OFF32___13 = 125,
    _SC_XBS5_ILP32_OFFBIG___13 = 126,
    _SC_XBS5_LP64_OFF64___13 = 127,
    _SC_XBS5_LPBIG_OFFBIG___13 = 128,
    _SC_XOPEN_LEGACY___13 = 129,
    _SC_XOPEN_REALTIME___13 = 130,
    _SC_XOPEN_REALTIME_THREADS___13 = 131,
    _SC_ADVISORY_INFO___13 = 132,
    _SC_BARRIERS___13 = 133,
    _SC_BASE___13 = 134,
    _SC_C_LANG_SUPPORT___13 = 135,
    _SC_C_LANG_SUPPORT_R___13 = 136,
    _SC_CLOCK_SELECTION___13 = 137,
    _SC_CPUTIME___13 = 138,
    _SC_THREAD_CPUTIME___13 = 139,
    _SC_DEVICE_IO___13 = 140,
    _SC_DEVICE_SPECIFIC___13 = 141,
    _SC_DEVICE_SPECIFIC_R___13 = 142,
    _SC_FD_MGMT___13 = 143,
    _SC_FIFO___13 = 144,
    _SC_PIPE___13 = 145,
    _SC_FILE_ATTRIBUTES___13 = 146,
    _SC_FILE_LOCKING___13 = 147,
    _SC_FILE_SYSTEM___13 = 148,
    _SC_MONOTONIC_CLOCK___13 = 149,
    _SC_MULTI_PROCESS___13 = 150,
    _SC_SINGLE_PROCESS___13 = 151,
    _SC_NETWORKING___13 = 152,
    _SC_READER_WRITER_LOCKS___13 = 153,
    _SC_SPIN_LOCKS___13 = 154,
    _SC_REGEXP___13 = 155,
    _SC_REGEX_VERSION___13 = 156,
    _SC_SHELL___13 = 157,
    _SC_SIGNALS___13 = 158,
    _SC_SPAWN___13 = 159,
    _SC_SPORADIC_SERVER___13 = 160,
    _SC_THREAD_SPORADIC_SERVER___13 = 161,
    _SC_SYSTEM_DATABASE___13 = 162,
    _SC_SYSTEM_DATABASE_R___13 = 163,
    _SC_TIMEOUTS___13 = 164,
    _SC_TYPED_MEMORY_OBJECTS___13 = 165,
    _SC_USER_GROUPS___13 = 166,
    _SC_USER_GROUPS_R___13 = 167,
    _SC_2_PBS___13 = 168,
    _SC_2_PBS_ACCOUNTING___13 = 169,
    _SC_2_PBS_LOCATE___13 = 170,
    _SC_2_PBS_MESSAGE___13 = 171,
    _SC_2_PBS_TRACK___13 = 172,
    _SC_SYMLOOP_MAX___13 = 173,
    _SC_STREAMS___13 = 174,
    _SC_2_PBS_CHECKPOINT___13 = 175,
    _SC_V6_ILP32_OFF32___13 = 176,
    _SC_V6_ILP32_OFFBIG___13 = 177,
    _SC_V6_LP64_OFF64___13 = 178,
    _SC_V6_LPBIG_OFFBIG___13 = 179,
    _SC_HOST_NAME_MAX___13 = 180,
    _SC_TRACE___13 = 181,
    _SC_TRACE_EVENT_FILTER___13 = 182,
    _SC_TRACE_INHERIT___13 = 183,
    _SC_TRACE_LOG___13 = 184,
    _SC_LEVEL1_ICACHE_SIZE___13 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___13 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___13 = 187,
    _SC_LEVEL1_DCACHE_SIZE___13 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___13 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___13 = 190,
    _SC_LEVEL2_CACHE_SIZE___13 = 191,
    _SC_LEVEL2_CACHE_ASSOC___13 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___13 = 193,
    _SC_LEVEL3_CACHE_SIZE___13 = 194,
    _SC_LEVEL3_CACHE_ASSOC___13 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___13 = 196,
    _SC_LEVEL4_CACHE_SIZE___13 = 197,
    _SC_LEVEL4_CACHE_ASSOC___13 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___13 = 199,
    _SC_IPV6___13 = 235,
    _SC_RAW_SOCKETS___13 = 236,
    _SC_V7_ILP32_OFF32___13 = 237,
    _SC_V7_ILP32_OFFBIG___13 = 238,
    _SC_V7_LP64_OFF64___13 = 239,
    _SC_V7_LPBIG_OFFBIG___13 = 240,
    _SC_SS_REPL_MAX___13 = 241,
    _SC_TRACE_EVENT_NAME_MAX___13 = 242,
    _SC_TRACE_NAME_MAX___13 = 243,
    _SC_TRACE_SYS_MAX___13 = 244,
    _SC_TRACE_USER_EVENT_MAX___13 = 245,
    _SC_XOPEN_STREAMS___13 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___13 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___13 = 248,
    _SC_MINSIGSTKSZ___13 = 249,
    _SC_SIGSTKSZ___13 = 250
} ;
#line 539
enum __anonenum__181 {
    _CS_PATH___13 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___13 = 1,
    _CS_GNU_LIBC_VERSION___13 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___13 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___13 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___13 = 5,
    _CS_LFS_CFLAGS___13 = 1000,
    _CS_LFS_LDFLAGS___13 = 1001,
    _CS_LFS_LIBS___13 = 1002,
    _CS_LFS_LINTFLAGS___13 = 1003,
    _CS_LFS64_CFLAGS___13 = 1004,
    _CS_LFS64_LDFLAGS___13 = 1005,
    _CS_LFS64_LIBS___13 = 1006,
    _CS_LFS64_LINTFLAGS___13 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___13 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___13 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___13 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___13 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___13 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___13 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___13 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___13 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___13 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___13 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___13 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___13 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___13 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___13 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___13 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___13 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___13 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___13 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___13 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___13 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___13 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___13 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___13 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___13 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___13 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___13 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___13 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___13 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___13 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___13 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___13 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___13 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___13 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___13 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___13 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___13 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___13 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___13 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___13 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___13 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___13 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___13 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___13 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___13 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___13 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___13 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___13 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___13 = 1147,
    _CS_V6_ENV___13 = 1148,
    _CS_V7_ENV___13 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__182 {
    MSG_OOB___13 = 1,
    MSG_PEEK___13 = 2,
    MSG_DONTROUTE___13 = 4,
    MSG_TRYHARD = 4,
    MSG_CTRUNC___13 = 8,
    MSG_PROXY___13 = 16,
    MSG_TRUNC___13 = 32,
    MSG_DONTWAIT___13 = 64,
    MSG_EOR___13 = 128,
    MSG_WAITALL___13 = 256,
    MSG_FIN___13 = 512,
    MSG_SYN___13 = 1024,
    MSG_CONFIRM___13 = 2048,
    MSG_RST___13 = 4096,
    MSG_ERRQUEUE___13 = 8192,
    MSG_NOSIGNAL___13 = 16384,
    MSG_MORE___13 = 32768,
    MSG_WAITFORONE___13 = 65536,
    MSG_BATCH___13 = 262144,
    MSG_ZEROCOPY___13 = 67108864,
    MSG_FASTOPEN___13 = 536870912,
    MSG_CMSG_CLOEXEC___13 = 1073741824
} ;
#line 334
enum __anonenum__183 {
    SCM_RIGHTS___13 = 1,
    SCM_CREDENTIALS = 2
} ;
#line 346 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__186 {
    SHUT_RD___13 = 0,
    SHUT_WR___13 = 1,
    SHUT_RDWR___13 = 2
} ;
#line 79
struct sockaddr_at ;
#line 79
struct sockaddr_ax25 ;
#line 79
struct sockaddr_dl ;
#line 79
struct sockaddr_eon ;
#line 79
struct sockaddr_inarp ;
#line 79
struct sockaddr_ipx ;
#line 79
struct sockaddr_iso ;
#line 79
struct sockaddr_ns ;
#line 79
struct sockaddr_un ;
#line 79
struct sockaddr_x25 ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_187 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 80 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_187 __SOCKADDR_ARG;
#line 83 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_188 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 84 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_188 __CONST_SOCKADDR_ARG;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct mmsghdr {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__189 {
    IPPROTO_IP___13 = 0,
    IPPROTO_ICMP___13 = 1,
    IPPROTO_IGMP___13 = 2,
    IPPROTO_IPIP___13 = 4,
    IPPROTO_TCP___13 = 6,
    IPPROTO_EGP___13 = 8,
    IPPROTO_PUP___13 = 12,
    IPPROTO_UDP___13 = 17,
    IPPROTO_IDP___13 = 22,
    IPPROTO_TP___13 = 29,
    IPPROTO_DCCP___13 = 33,
    IPPROTO_IPV6___13 = 41,
    IPPROTO_RSVP___13 = 46,
    IPPROTO_GRE___13 = 47,
    IPPROTO_ESP___13 = 50,
    IPPROTO_AH___13 = 51,
    IPPROTO_MTP___13 = 92,
    IPPROTO_BEETPH___13 = 94,
    IPPROTO_ENCAP___13 = 98,
    IPPROTO_PIM___13 = 103,
    IPPROTO_COMP___13 = 108,
    IPPROTO_SCTP___13 = 132,
    IPPROTO_UDPLITE___13 = 136,
    IPPROTO_MPLS___13 = 137,
    IPPROTO_ETHERNET___13 = 143,
    IPPROTO_RAW___13 = 255,
    IPPROTO_MPTCP___13 = 262,
    IPPROTO_MAX___13 = 263
} ;
#line 103
enum __anonenum__190 {
    IPPROTO_HOPOPTS___13 = 0,
    IPPROTO_ROUTING___13 = 43,
    IPPROTO_FRAGMENT___13 = 44,
    IPPROTO_ICMPV6___13 = 58,
    IPPROTO_NONE___13 = 59,
    IPPROTO_DSTOPTS___13 = 60,
    IPPROTO_MH___13 = 135
} ;
#line 126
enum __anonenum__191 {
    IPPORT_ECHO___13 = 7,
    IPPORT_DISCARD___13 = 9,
    IPPORT_SYSTAT___13 = 11,
    IPPORT_DAYTIME___13 = 13,
    IPPORT_NETSTAT___13 = 15,
    IPPORT_FTP___13 = 21,
    IPPORT_TELNET___13 = 23,
    IPPORT_SMTP___13 = 25,
    IPPORT_TIMESERVER___13 = 37,
    IPPORT_NAMESERVER___13 = 42,
    IPPORT_WHOIS___13 = 43,
    IPPORT_MTP___13 = 57,
    IPPORT_TFTP___13 = 69,
    IPPORT_RJE___13 = 77,
    IPPORT_FINGER___13 = 79,
    IPPORT_TTYLINK___13 = 87,
    IPPORT_SUPDUP___13 = 95,
    IPPORT_EXECSERVER___13 = 512,
    IPPORT_LOGINSERVER___13 = 513,
    IPPORT_CMDSERVER___13 = 514,
    IPPORT_EFSSERVER___13 = 520,
    IPPORT_BIFFUDP___13 = 512,
    IPPORT_WHOSERVER___13 = 513,
    IPPORT_ROUTESERVER___13 = 520,
    IPPORT_RESERVED___13 = 1024,
    IPPORT_USERRESERVED___13 = 5000
} ;
#line 544 "/usr/include/netinet/in.h"
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
#line 551 "/usr/include/netinet/in.h"
struct ip6_mtuinfo {
   struct sockaddr_in6 ip6m_addr ;
   uint32_t ip6m_mtu ;
};
#line 46 "/usr/include/dlfcn.h"
typedef long Lmid_t;
#line 90 "/usr/include/dlfcn.h"
struct __anonstruct_193 {
   char const   *dli_fname ;
   void *dli_fbase ;
   char const   *dli_sname ;
   void *dli_saddr ;
};
#line 96 "/usr/include/dlfcn.h"
typedef struct __anonstruct_193 Dl_info;
#line 110
enum __anonenum__194 {
    RTLD_DL_SYMENT = 1,
    RTLD_DL_LINKMAP = 2
} ;
#line 130
enum __anonenum__195 {
    RTLD_DI_LMID = 1,
    RTLD_DI_LINKMAP = 2,
    RTLD_DI_CONFIGADDR = 3,
    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,
    RTLD_DI_ORIGIN = 6,
    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,
    RTLD_DI_TLS_MODID = 9,
    RTLD_DI_TLS_DATA = 10,
    RTLD_DI_MAX = 10
} ;
#line 173 "/usr/include/dlfcn.h"
struct __anonstruct_196 {
   char *dls_name ;
   unsigned int dls_flags ;
};
#line 177 "/usr/include/dlfcn.h"
typedef struct __anonstruct_196 Dl_serpath;
#line 190 "/usr/include/dlfcn.h"
union __anonunion_198 {
   Dl_serpath dls_serpath[0] ;
   Dl_serpath __dls_serpath_pad[1] ;
};
#line 181 "/usr/include/dlfcn.h"
struct __anonstruct_197 {
   size_t dls_size ;
   unsigned int dls_cnt ;
   union __anonunion_198  ;
   Dl_serpath dls_serpath[0] ;
   Dl_serpath __dls_serpath_pad[1] ;
};
#line 198 "/usr/include/dlfcn.h"
typedef struct __anonstruct_197 Dl_serinfo;
#line 205
struct link_map ;
#line 200 "/usr/include/dlfcn.h"
struct dl_find_object {
   unsigned long long dlfo_flags ;
   void *dlfo_map_start ;
   void *dlfo_map_end ;
   struct link_map *dlfo_link_map ;
   void *dlfo_eh_frame ;
   unsigned long long __dflo_reserved[7] ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__200 {
    PTHREAD_CREATE_JOINABLE___13 = 0,
    PTHREAD_CREATE_DETACHED___13 = 1
} ;
#line 47
enum __anonenum__201 {
    PTHREAD_MUTEX_TIMED_NP___13 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___13 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___13 = 3,
    PTHREAD_MUTEX_NORMAL___13 = 0,
    PTHREAD_MUTEX_RECURSIVE___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK___13 = 2,
    PTHREAD_MUTEX_DEFAULT___13 = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
#line 69
enum __anonenum__202 {
    PTHREAD_MUTEX_STALLED___13 = 0,
    PTHREAD_MUTEX_STALLED_NP___13 = 0,
    PTHREAD_MUTEX_ROBUST___13 = 1,
    PTHREAD_MUTEX_ROBUST_NP___13 = 1
} ;
#line 81
enum __anonenum__203 {
    PTHREAD_PRIO_NONE___13 = 0,
    PTHREAD_PRIO_INHERIT___13 = 1,
    PTHREAD_PRIO_PROTECT___13 = 2
} ;
#line 104
enum __anonenum__204 {
    PTHREAD_RWLOCK_PREFER_READER_NP___13 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___13 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___13 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___13 = 0
} ;
#line 124
enum __anonenum__205 {
    PTHREAD_INHERIT_SCHED___13 = 0,
    PTHREAD_EXPLICIT_SCHED___13 = 1
} ;
#line 134
enum __anonenum__206 {
    PTHREAD_SCOPE_SYSTEM___13 = 0,
    PTHREAD_SCOPE_PROCESS___13 = 1
} ;
#line 144
enum __anonenum__207 {
    PTHREAD_PROCESS_PRIVATE___13 = 0,
    PTHREAD_PROCESS_SHARED___13 = 1
} ;
#line 168
enum __anonenum__208 {
    PTHREAD_CANCEL_ENABLE___13 = 0,
    PTHREAD_CANCEL_DISABLE___13 = 1
} ;
#line 175
enum __anonenum__209 {
    PTHREAD_CANCEL_DEFERRED___13 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___13 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__222 {
    SI_ASYNCNL___13 = -60,
    SI_DETHREAD___13 = -7,
    SI_TKILL___13 = -6,
    SI_SIGIO___13 = -5,
    SI_ASYNCIO___13 = -4,
    SI_MESGQ___13 = -3,
    SI_TIMER___13 = -2,
    SI_QUEUE___13 = -1,
    SI_USER___13 = 0,
    SI_KERNEL___13 = 128
} ;
#line 71
enum __anonenum__223 {
    ILL_ILLOPC___13 = 1,
    ILL_ILLOPN___13 = 2,
    ILL_ILLADR___13 = 3,
    ILL_ILLTRP___13 = 4,
    ILL_PRVOPC___13 = 5,
    ILL_PRVREG___13 = 6,
    ILL_COPROC___13 = 7,
    ILL_BADSTK___13 = 8,
    ILL_BADIADDR___13 = 9
} ;
#line 94
enum __anonenum__224 {
    FPE_INTDIV___13 = 1,
    FPE_INTOVF___13 = 2,
    FPE_FLTDIV___13 = 3,
    FPE_FLTOVF___13 = 4,
    FPE_FLTUND___13 = 5,
    FPE_FLTRES___13 = 6,
    FPE_FLTINV___13 = 7,
    FPE_FLTSUB___13 = 8,
    FPE_FLTUNK___13 = 14,
    FPE_CONDTRAP___13 = 15
} ;
#line 119
enum __anonenum__225 {
    SEGV_MAPERR___13 = 1,
    SEGV_ACCERR___13 = 2,
    SEGV_BNDERR___13 = 3,
    SEGV_PKUERR___13 = 4,
    SEGV_ACCADI___13 = 5,
    SEGV_ADIDERR___13 = 6,
    SEGV_ADIPERR___13 = 7,
    SEGV_MTEAERR___13 = 8,
    SEGV_MTESERR___13 = 9
} ;
#line 142
enum __anonenum__226 {
    BUS_ADRALN___13 = 1,
    BUS_ADRERR___13 = 2,
    BUS_OBJERR___13 = 3,
    BUS_MCEERR_AR___13 = 4,
    BUS_MCEERR_AO___13 = 5
} ;
#line 159
enum __anonenum__227 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
#line 176
enum __anonenum__228 {
    CLD_EXITED___13 = 1,
    CLD_KILLED___13 = 2,
    CLD_DUMPED___13 = 3,
    CLD_TRAPPED___13 = 4,
    CLD_STOPPED___13 = 5,
    CLD_CONTINUED___13 = 6
} ;
#line 193
enum __anonenum__229 {
    POLL_IN___13 = 1,
    POLL_OUT___13 = 2,
    POLL_MSG___13 = 3,
    POLL_ERR___13 = 4,
    POLL_PRI___13 = 5,
    POLL_HUP___13 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__232 {
    SIGEV_SIGNAL___13 = 0,
    SIGEV_NONE___13 = 1,
    SIGEV_THREAD___13 = 2,
    SIGEV_THREAD_ID___13 = 4
} ;
#line 188 "/usr/include/signal.h"
typedef __sighandler_t sighandler_t;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__236 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__238 {
    SS_ONSTACK___13 = 1,
    SS_DISABLE___13 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__239 {
    EFD_SEMAPHORE___13 = 1,
    EFD_CLOEXEC___13 = 524288,
    EFD_NONBLOCK___13 = 2048
} ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID = 1,
    F_OWNER_PGRP = 2,
    F_OWNER_GID = 2
} ;
#line 274 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
#line 358 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__179___0 {
    _PC_LINK_MAX___14 = 0,
    _PC_MAX_CANON___14 = 1,
    _PC_MAX_INPUT___14 = 2,
    _PC_NAME_MAX___14 = 3,
    _PC_PATH_MAX___14 = 4,
    _PC_PIPE_BUF___14 = 5,
    _PC_CHOWN_RESTRICTED___14 = 6,
    _PC_NO_TRUNC___14 = 7,
    _PC_VDISABLE___14 = 8,
    _PC_SYNC_IO___14 = 9,
    _PC_ASYNC_IO___14 = 10,
    _PC_PRIO_IO___14 = 11,
    _PC_SOCK_MAXBUF___14 = 12,
    _PC_FILESIZEBITS___14 = 13,
    _PC_REC_INCR_XFER_SIZE___14 = 14,
    _PC_REC_MAX_XFER_SIZE___14 = 15,
    _PC_REC_MIN_XFER_SIZE___14 = 16,
    _PC_REC_XFER_ALIGN___14 = 17,
    _PC_ALLOC_SIZE_MIN___14 = 18,
    _PC_SYMLINK_MAX___14 = 19,
    _PC_2_SYMLINKS___14 = 20
} ;
#line 71
enum __anonenum__180___0 {
    _SC_ARG_MAX___14 = 0,
    _SC_CHILD_MAX___14 = 1,
    _SC_CLK_TCK___14 = 2,
    _SC_NGROUPS_MAX___14 = 3,
    _SC_OPEN_MAX___14 = 4,
    _SC_STREAM_MAX___14 = 5,
    _SC_TZNAME_MAX___14 = 6,
    _SC_JOB_CONTROL___14 = 7,
    _SC_SAVED_IDS___14 = 8,
    _SC_REALTIME_SIGNALS___14 = 9,
    _SC_PRIORITY_SCHEDULING___14 = 10,
    _SC_TIMERS___14 = 11,
    _SC_ASYNCHRONOUS_IO___14 = 12,
    _SC_PRIORITIZED_IO___14 = 13,
    _SC_SYNCHRONIZED_IO___14 = 14,
    _SC_FSYNC___14 = 15,
    _SC_MAPPED_FILES___14 = 16,
    _SC_MEMLOCK___14 = 17,
    _SC_MEMLOCK_RANGE___14 = 18,
    _SC_MEMORY_PROTECTION___14 = 19,
    _SC_MESSAGE_PASSING___14 = 20,
    _SC_SEMAPHORES___14 = 21,
    _SC_SHARED_MEMORY_OBJECTS___14 = 22,
    _SC_AIO_LISTIO_MAX___14 = 23,
    _SC_AIO_MAX___14 = 24,
    _SC_AIO_PRIO_DELTA_MAX___14 = 25,
    _SC_DELAYTIMER_MAX___14 = 26,
    _SC_MQ_OPEN_MAX___14 = 27,
    _SC_MQ_PRIO_MAX___14 = 28,
    _SC_VERSION___14 = 29,
    _SC_PAGESIZE___14 = 30,
    _SC_RTSIG_MAX___14 = 31,
    _SC_SEM_NSEMS_MAX___14 = 32,
    _SC_SEM_VALUE_MAX___14 = 33,
    _SC_SIGQUEUE_MAX___14 = 34,
    _SC_TIMER_MAX___14 = 35,
    _SC_BC_BASE_MAX___14 = 36,
    _SC_BC_DIM_MAX___14 = 37,
    _SC_BC_SCALE_MAX___14 = 38,
    _SC_BC_STRING_MAX___14 = 39,
    _SC_COLL_WEIGHTS_MAX___14 = 40,
    _SC_EQUIV_CLASS_MAX___14 = 41,
    _SC_EXPR_NEST_MAX___14 = 42,
    _SC_LINE_MAX___14 = 43,
    _SC_RE_DUP_MAX___14 = 44,
    _SC_CHARCLASS_NAME_MAX___14 = 45,
    _SC_2_VERSION___14 = 46,
    _SC_2_C_BIND___14 = 47,
    _SC_2_C_DEV___14 = 48,
    _SC_2_FORT_DEV___14 = 49,
    _SC_2_FORT_RUN___14 = 50,
    _SC_2_SW_DEV___14 = 51,
    _SC_2_LOCALEDEF___14 = 52,
    _SC_PII___14 = 53,
    _SC_PII_XTI___14 = 54,
    _SC_PII_SOCKET___14 = 55,
    _SC_PII_INTERNET___14 = 56,
    _SC_PII_OSI___14 = 57,
    _SC_POLL___14 = 58,
    _SC_SELECT___14 = 59,
    _SC_UIO_MAXIOV___14 = 60,
    _SC_IOV_MAX___14 = 60,
    _SC_PII_INTERNET_STREAM___14 = 61,
    _SC_PII_INTERNET_DGRAM___14 = 62,
    _SC_PII_OSI_COTS___14 = 63,
    _SC_PII_OSI_CLTS___14 = 64,
    _SC_PII_OSI_M___14 = 65,
    _SC_T_IOV_MAX___14 = 66,
    _SC_THREADS___14 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___14 = 68,
    _SC_GETGR_R_SIZE_MAX___14 = 69,
    _SC_GETPW_R_SIZE_MAX___14 = 70,
    _SC_LOGIN_NAME_MAX___14 = 71,
    _SC_TTY_NAME_MAX___14 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___14 = 73,
    _SC_THREAD_KEYS_MAX___14 = 74,
    _SC_THREAD_STACK_MIN___14 = 75,
    _SC_THREAD_THREADS_MAX___14 = 76,
    _SC_THREAD_ATTR_STACKADDR___14 = 77,
    _SC_THREAD_ATTR_STACKSIZE___14 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___14 = 79,
    _SC_THREAD_PRIO_INHERIT___14 = 80,
    _SC_THREAD_PRIO_PROTECT___14 = 81,
    _SC_THREAD_PROCESS_SHARED___14 = 82,
    _SC_NPROCESSORS_CONF___14 = 83,
    _SC_NPROCESSORS_ONLN___14 = 84,
    _SC_PHYS_PAGES___14 = 85,
    _SC_AVPHYS_PAGES___14 = 86,
    _SC_ATEXIT_MAX___14 = 87,
    _SC_PASS_MAX___14 = 88,
    _SC_XOPEN_VERSION___14 = 89,
    _SC_XOPEN_XCU_VERSION___14 = 90,
    _SC_XOPEN_UNIX___14 = 91,
    _SC_XOPEN_CRYPT___14 = 92,
    _SC_XOPEN_ENH_I18N___14 = 93,
    _SC_XOPEN_SHM___14 = 94,
    _SC_2_CHAR_TERM___14 = 95,
    _SC_2_C_VERSION___14 = 96,
    _SC_2_UPE___14 = 97,
    _SC_XOPEN_XPG2___14 = 98,
    _SC_XOPEN_XPG3___14 = 99,
    _SC_XOPEN_XPG4___14 = 100,
    _SC_CHAR_BIT___14 = 101,
    _SC_CHAR_MAX___14 = 102,
    _SC_CHAR_MIN___14 = 103,
    _SC_INT_MAX___14 = 104,
    _SC_INT_MIN___14 = 105,
    _SC_LONG_BIT___14 = 106,
    _SC_WORD_BIT___14 = 107,
    _SC_MB_LEN_MAX___14 = 108,
    _SC_NZERO___14 = 109,
    _SC_SSIZE_MAX___14 = 110,
    _SC_SCHAR_MAX___14 = 111,
    _SC_SCHAR_MIN___14 = 112,
    _SC_SHRT_MAX___14 = 113,
    _SC_SHRT_MIN___14 = 114,
    _SC_UCHAR_MAX___14 = 115,
    _SC_UINT_MAX___14 = 116,
    _SC_ULONG_MAX___14 = 117,
    _SC_USHRT_MAX___14 = 118,
    _SC_NL_ARGMAX___14 = 119,
    _SC_NL_LANGMAX___14 = 120,
    _SC_NL_MSGMAX___14 = 121,
    _SC_NL_NMAX___14 = 122,
    _SC_NL_SETMAX___14 = 123,
    _SC_NL_TEXTMAX___14 = 124,
    _SC_XBS5_ILP32_OFF32___14 = 125,
    _SC_XBS5_ILP32_OFFBIG___14 = 126,
    _SC_XBS5_LP64_OFF64___14 = 127,
    _SC_XBS5_LPBIG_OFFBIG___14 = 128,
    _SC_XOPEN_LEGACY___14 = 129,
    _SC_XOPEN_REALTIME___14 = 130,
    _SC_XOPEN_REALTIME_THREADS___14 = 131,
    _SC_ADVISORY_INFO___14 = 132,
    _SC_BARRIERS___14 = 133,
    _SC_BASE___14 = 134,
    _SC_C_LANG_SUPPORT___14 = 135,
    _SC_C_LANG_SUPPORT_R___14 = 136,
    _SC_CLOCK_SELECTION___14 = 137,
    _SC_CPUTIME___14 = 138,
    _SC_THREAD_CPUTIME___14 = 139,
    _SC_DEVICE_IO___14 = 140,
    _SC_DEVICE_SPECIFIC___14 = 141,
    _SC_DEVICE_SPECIFIC_R___14 = 142,
    _SC_FD_MGMT___14 = 143,
    _SC_FIFO___14 = 144,
    _SC_PIPE___14 = 145,
    _SC_FILE_ATTRIBUTES___14 = 146,
    _SC_FILE_LOCKING___14 = 147,
    _SC_FILE_SYSTEM___14 = 148,
    _SC_MONOTONIC_CLOCK___14 = 149,
    _SC_MULTI_PROCESS___14 = 150,
    _SC_SINGLE_PROCESS___14 = 151,
    _SC_NETWORKING___14 = 152,
    _SC_READER_WRITER_LOCKS___14 = 153,
    _SC_SPIN_LOCKS___14 = 154,
    _SC_REGEXP___14 = 155,
    _SC_REGEX_VERSION___14 = 156,
    _SC_SHELL___14 = 157,
    _SC_SIGNALS___14 = 158,
    _SC_SPAWN___14 = 159,
    _SC_SPORADIC_SERVER___14 = 160,
    _SC_THREAD_SPORADIC_SERVER___14 = 161,
    _SC_SYSTEM_DATABASE___14 = 162,
    _SC_SYSTEM_DATABASE_R___14 = 163,
    _SC_TIMEOUTS___14 = 164,
    _SC_TYPED_MEMORY_OBJECTS___14 = 165,
    _SC_USER_GROUPS___14 = 166,
    _SC_USER_GROUPS_R___14 = 167,
    _SC_2_PBS___14 = 168,
    _SC_2_PBS_ACCOUNTING___14 = 169,
    _SC_2_PBS_LOCATE___14 = 170,
    _SC_2_PBS_MESSAGE___14 = 171,
    _SC_2_PBS_TRACK___14 = 172,
    _SC_SYMLOOP_MAX___14 = 173,
    _SC_STREAMS___14 = 174,
    _SC_2_PBS_CHECKPOINT___14 = 175,
    _SC_V6_ILP32_OFF32___14 = 176,
    _SC_V6_ILP32_OFFBIG___14 = 177,
    _SC_V6_LP64_OFF64___14 = 178,
    _SC_V6_LPBIG_OFFBIG___14 = 179,
    _SC_HOST_NAME_MAX___14 = 180,
    _SC_TRACE___14 = 181,
    _SC_TRACE_EVENT_FILTER___14 = 182,
    _SC_TRACE_INHERIT___14 = 183,
    _SC_TRACE_LOG___14 = 184,
    _SC_LEVEL1_ICACHE_SIZE___14 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___14 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___14 = 187,
    _SC_LEVEL1_DCACHE_SIZE___14 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___14 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___14 = 190,
    _SC_LEVEL2_CACHE_SIZE___14 = 191,
    _SC_LEVEL2_CACHE_ASSOC___14 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___14 = 193,
    _SC_LEVEL3_CACHE_SIZE___14 = 194,
    _SC_LEVEL3_CACHE_ASSOC___14 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___14 = 196,
    _SC_LEVEL4_CACHE_SIZE___14 = 197,
    _SC_LEVEL4_CACHE_ASSOC___14 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___14 = 199,
    _SC_IPV6___14 = 235,
    _SC_RAW_SOCKETS___14 = 236,
    _SC_V7_ILP32_OFF32___14 = 237,
    _SC_V7_ILP32_OFFBIG___14 = 238,
    _SC_V7_LP64_OFF64___14 = 239,
    _SC_V7_LPBIG_OFFBIG___14 = 240,
    _SC_SS_REPL_MAX___14 = 241,
    _SC_TRACE_EVENT_NAME_MAX___14 = 242,
    _SC_TRACE_NAME_MAX___14 = 243,
    _SC_TRACE_SYS_MAX___14 = 244,
    _SC_TRACE_USER_EVENT_MAX___14 = 245,
    _SC_XOPEN_STREAMS___14 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___14 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___14 = 248,
    _SC_MINSIGSTKSZ___14 = 249,
    _SC_SIGSTKSZ___14 = 250
} ;
#line 539
enum __anonenum__181___0 {
    _CS_PATH___14 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___14 = 1,
    _CS_GNU_LIBC_VERSION___14 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___14 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___14 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___14 = 5,
    _CS_LFS_CFLAGS___14 = 1000,
    _CS_LFS_LDFLAGS___14 = 1001,
    _CS_LFS_LIBS___14 = 1002,
    _CS_LFS_LINTFLAGS___14 = 1003,
    _CS_LFS64_CFLAGS___14 = 1004,
    _CS_LFS64_LDFLAGS___14 = 1005,
    _CS_LFS64_LIBS___14 = 1006,
    _CS_LFS64_LINTFLAGS___14 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___14 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___14 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___14 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___14 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___14 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___14 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___14 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___14 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___14 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___14 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___14 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___14 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___14 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___14 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___14 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___14 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___14 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___14 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___14 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___14 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___14 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___14 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___14 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___14 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___14 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___14 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___14 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___14 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___14 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___14 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___14 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___14 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___14 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___14 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___14 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___14 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___14 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___14 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___14 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___14 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___14 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___14 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___14 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___14 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___14 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___14 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___14 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___14 = 1147,
    _CS_V6_ENV___14 = 1148,
    _CS_V7_ENV___14 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__182___0 {
    MSG_OOB___14 = 1,
    MSG_PEEK___14 = 2,
    MSG_DONTROUTE___14 = 4,
    MSG_TRYHARD___0 = 4,
    MSG_CTRUNC___14 = 8,
    MSG_PROXY___14 = 16,
    MSG_TRUNC___14 = 32,
    MSG_DONTWAIT___14 = 64,
    MSG_EOR___14 = 128,
    MSG_WAITALL___14 = 256,
    MSG_FIN___14 = 512,
    MSG_SYN___14 = 1024,
    MSG_CONFIRM___14 = 2048,
    MSG_RST___14 = 4096,
    MSG_ERRQUEUE___14 = 8192,
    MSG_NOSIGNAL___14 = 16384,
    MSG_MORE___14 = 32768,
    MSG_WAITFORONE___14 = 65536,
    MSG_BATCH___14 = 262144,
    MSG_ZEROCOPY___14 = 67108864,
    MSG_FASTOPEN___14 = 536870912,
    MSG_CMSG_CLOEXEC___14 = 1073741824
} ;
#line 334
enum __anonenum__183___0 {
    SCM_RIGHTS___14 = 1,
    SCM_CREDENTIALS___0 = 2
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__186___0 {
    SHUT_RD___14 = 0,
    SHUT_WR___14 = 1,
    SHUT_RDWR___14 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__189___0 {
    IPPROTO_IP___14 = 0,
    IPPROTO_ICMP___14 = 1,
    IPPROTO_IGMP___14 = 2,
    IPPROTO_IPIP___14 = 4,
    IPPROTO_TCP___14 = 6,
    IPPROTO_EGP___14 = 8,
    IPPROTO_PUP___14 = 12,
    IPPROTO_UDP___14 = 17,
    IPPROTO_IDP___14 = 22,
    IPPROTO_TP___14 = 29,
    IPPROTO_DCCP___14 = 33,
    IPPROTO_IPV6___14 = 41,
    IPPROTO_RSVP___14 = 46,
    IPPROTO_GRE___14 = 47,
    IPPROTO_ESP___14 = 50,
    IPPROTO_AH___14 = 51,
    IPPROTO_MTP___14 = 92,
    IPPROTO_BEETPH___14 = 94,
    IPPROTO_ENCAP___14 = 98,
    IPPROTO_PIM___14 = 103,
    IPPROTO_COMP___14 = 108,
    IPPROTO_SCTP___14 = 132,
    IPPROTO_UDPLITE___14 = 136,
    IPPROTO_MPLS___14 = 137,
    IPPROTO_ETHERNET___14 = 143,
    IPPROTO_RAW___14 = 255,
    IPPROTO_MPTCP___14 = 262,
    IPPROTO_MAX___14 = 263
} ;
#line 103
enum __anonenum__190___0 {
    IPPROTO_HOPOPTS___14 = 0,
    IPPROTO_ROUTING___14 = 43,
    IPPROTO_FRAGMENT___14 = 44,
    IPPROTO_ICMPV6___14 = 58,
    IPPROTO_NONE___14 = 59,
    IPPROTO_DSTOPTS___14 = 60,
    IPPROTO_MH___14 = 135
} ;
#line 126
enum __anonenum__191___0 {
    IPPORT_ECHO___14 = 7,
    IPPORT_DISCARD___14 = 9,
    IPPORT_SYSTAT___14 = 11,
    IPPORT_DAYTIME___14 = 13,
    IPPORT_NETSTAT___14 = 15,
    IPPORT_FTP___14 = 21,
    IPPORT_TELNET___14 = 23,
    IPPORT_SMTP___14 = 25,
    IPPORT_TIMESERVER___14 = 37,
    IPPORT_NAMESERVER___14 = 42,
    IPPORT_WHOIS___14 = 43,
    IPPORT_MTP___14 = 57,
    IPPORT_TFTP___14 = 69,
    IPPORT_RJE___14 = 77,
    IPPORT_FINGER___14 = 79,
    IPPORT_TTYLINK___14 = 87,
    IPPORT_SUPDUP___14 = 95,
    IPPORT_EXECSERVER___14 = 512,
    IPPORT_LOGINSERVER___14 = 513,
    IPPORT_CMDSERVER___14 = 514,
    IPPORT_EFSSERVER___14 = 520,
    IPPORT_BIFFUDP___14 = 512,
    IPPORT_WHOSERVER___14 = 513,
    IPPORT_ROUTESERVER___14 = 520,
    IPPORT_RESERVED___14 = 1024,
    IPPORT_USERRESERVED___14 = 5000
} ;
#line 110 "/usr/include/dlfcn.h"
enum __anonenum__194___0 {
    RTLD_DL_SYMENT___0 = 1,
    RTLD_DL_LINKMAP___0 = 2
} ;
#line 130
enum __anonenum__195___0 {
    RTLD_DI_LMID___0 = 1,
    RTLD_DI_LINKMAP___0 = 2,
    RTLD_DI_CONFIGADDR___0 = 3,
    RTLD_DI_SERINFO___0 = 4,
    RTLD_DI_SERINFOSIZE___0 = 5,
    RTLD_DI_ORIGIN___0 = 6,
    RTLD_DI_PROFILENAME___0 = 7,
    RTLD_DI_PROFILEOUT___0 = 8,
    RTLD_DI_TLS_MODID___0 = 9,
    RTLD_DI_TLS_DATA___0 = 10,
    RTLD_DI_MAX___0 = 10
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__200___0 {
    PTHREAD_CREATE_JOINABLE___14 = 0,
    PTHREAD_CREATE_DETACHED___14 = 1
} ;
#line 47
enum __anonenum__201___0 {
    PTHREAD_MUTEX_TIMED_NP___14 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___14 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___14 = 3,
    PTHREAD_MUTEX_NORMAL___14 = 0,
    PTHREAD_MUTEX_RECURSIVE___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK___14 = 2,
    PTHREAD_MUTEX_DEFAULT___14 = 0,
    PTHREAD_MUTEX_FAST_NP___0 = 0
} ;
#line 69
enum __anonenum__202___0 {
    PTHREAD_MUTEX_STALLED___14 = 0,
    PTHREAD_MUTEX_STALLED_NP___14 = 0,
    PTHREAD_MUTEX_ROBUST___14 = 1,
    PTHREAD_MUTEX_ROBUST_NP___14 = 1
} ;
#line 81
enum __anonenum__203___0 {
    PTHREAD_PRIO_NONE___14 = 0,
    PTHREAD_PRIO_INHERIT___14 = 1,
    PTHREAD_PRIO_PROTECT___14 = 2
} ;
#line 104
enum __anonenum__204___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___14 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___14 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___14 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___14 = 0
} ;
#line 124
enum __anonenum__205___0 {
    PTHREAD_INHERIT_SCHED___14 = 0,
    PTHREAD_EXPLICIT_SCHED___14 = 1
} ;
#line 134
enum __anonenum__206___0 {
    PTHREAD_SCOPE_SYSTEM___14 = 0,
    PTHREAD_SCOPE_PROCESS___14 = 1
} ;
#line 144
enum __anonenum__207___0 {
    PTHREAD_PROCESS_PRIVATE___14 = 0,
    PTHREAD_PROCESS_SHARED___14 = 1
} ;
#line 168
enum __anonenum__208___0 {
    PTHREAD_CANCEL_ENABLE___14 = 0,
    PTHREAD_CANCEL_DISABLE___14 = 1
} ;
#line 175
enum __anonenum__209___0 {
    PTHREAD_CANCEL_DEFERRED___14 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___14 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__222___0 {
    SI_ASYNCNL___14 = -60,
    SI_DETHREAD___14 = -7,
    SI_TKILL___14 = -6,
    SI_SIGIO___14 = -5,
    SI_ASYNCIO___14 = -4,
    SI_MESGQ___14 = -3,
    SI_TIMER___14 = -2,
    SI_QUEUE___14 = -1,
    SI_USER___14 = 0,
    SI_KERNEL___14 = 128
} ;
#line 71
enum __anonenum__223___0 {
    ILL_ILLOPC___14 = 1,
    ILL_ILLOPN___14 = 2,
    ILL_ILLADR___14 = 3,
    ILL_ILLTRP___14 = 4,
    ILL_PRVOPC___14 = 5,
    ILL_PRVREG___14 = 6,
    ILL_COPROC___14 = 7,
    ILL_BADSTK___14 = 8,
    ILL_BADIADDR___14 = 9
} ;
#line 94
enum __anonenum__224___0 {
    FPE_INTDIV___14 = 1,
    FPE_INTOVF___14 = 2,
    FPE_FLTDIV___14 = 3,
    FPE_FLTOVF___14 = 4,
    FPE_FLTUND___14 = 5,
    FPE_FLTRES___14 = 6,
    FPE_FLTINV___14 = 7,
    FPE_FLTSUB___14 = 8,
    FPE_FLTUNK___14 = 14,
    FPE_CONDTRAP___14 = 15
} ;
#line 119
enum __anonenum__225___0 {
    SEGV_MAPERR___14 = 1,
    SEGV_ACCERR___14 = 2,
    SEGV_BNDERR___14 = 3,
    SEGV_PKUERR___14 = 4,
    SEGV_ACCADI___14 = 5,
    SEGV_ADIDERR___14 = 6,
    SEGV_ADIPERR___14 = 7,
    SEGV_MTEAERR___14 = 8,
    SEGV_MTESERR___14 = 9
} ;
#line 142
enum __anonenum__226___0 {
    BUS_ADRALN___14 = 1,
    BUS_ADRERR___14 = 2,
    BUS_OBJERR___14 = 3,
    BUS_MCEERR_AR___14 = 4,
    BUS_MCEERR_AO___14 = 5
} ;
#line 159
enum __anonenum__227___0 {
    TRAP_BRKPT___0 = 1,
    TRAP_TRACE___0 = 2,
    TRAP_BRANCH___0 = 3,
    TRAP_HWBKPT___0 = 4,
    TRAP_UNK___0 = 5
} ;
#line 176
enum __anonenum__228___0 {
    CLD_EXITED___14 = 1,
    CLD_KILLED___14 = 2,
    CLD_DUMPED___14 = 3,
    CLD_TRAPPED___14 = 4,
    CLD_STOPPED___14 = 5,
    CLD_CONTINUED___14 = 6
} ;
#line 193
enum __anonenum__229___0 {
    POLL_IN___14 = 1,
    POLL_OUT___14 = 2,
    POLL_MSG___14 = 3,
    POLL_ERR___14 = 4,
    POLL_PRI___14 = 5,
    POLL_HUP___14 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__232___0 {
    SIGEV_SIGNAL___14 = 0,
    SIGEV_NONE___14 = 1,
    SIGEV_THREAD___14 = 2,
    SIGEV_THREAD_ID___14 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__236___0 {
    REG_R8___0 = 0,
    REG_R9___0 = 1,
    REG_R10___0 = 2,
    REG_R11___0 = 3,
    REG_R12___0 = 4,
    REG_R13___0 = 5,
    REG_R14___0 = 6,
    REG_R15___0 = 7,
    REG_RDI___0 = 8,
    REG_RSI___0 = 9,
    REG_RBP___0 = 10,
    REG_RBX___0 = 11,
    REG_RDX___0 = 12,
    REG_RAX___0 = 13,
    REG_RCX___0 = 14,
    REG_RSP___0 = 15,
    REG_RIP___0 = 16,
    REG_EFL___0 = 17,
    REG_CSGSFS___0 = 18,
    REG_ERR___0 = 19,
    REG_TRAPNO___0 = 20,
    REG_OLDMASK___0 = 21,
    REG_CR2___0 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__238___0 {
    SS_ONSTACK___14 = 1,
    SS_DISABLE___14 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__239___0 {
    EFD_SEMAPHORE___14 = 1,
    EFD_CLOEXEC___14 = 524288,
    EFD_NONBLOCK___14 = 2048
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___13 {
    _PC_LINK_MAX___15 = 0,
    _PC_MAX_CANON___15 = 1,
    _PC_MAX_INPUT___15 = 2,
    _PC_NAME_MAX___15 = 3,
    _PC_PATH_MAX___15 = 4,
    _PC_PIPE_BUF___15 = 5,
    _PC_CHOWN_RESTRICTED___15 = 6,
    _PC_NO_TRUNC___15 = 7,
    _PC_VDISABLE___15 = 8,
    _PC_SYNC_IO___15 = 9,
    _PC_ASYNC_IO___15 = 10,
    _PC_PRIO_IO___15 = 11,
    _PC_SOCK_MAXBUF___15 = 12,
    _PC_FILESIZEBITS___15 = 13,
    _PC_REC_INCR_XFER_SIZE___15 = 14,
    _PC_REC_MAX_XFER_SIZE___15 = 15,
    _PC_REC_MIN_XFER_SIZE___15 = 16,
    _PC_REC_XFER_ALIGN___15 = 17,
    _PC_ALLOC_SIZE_MIN___15 = 18,
    _PC_SYMLINK_MAX___15 = 19,
    _PC_2_SYMLINKS___15 = 20
} ;
#line 71
enum __anonenum__20___13 {
    _SC_ARG_MAX___15 = 0,
    _SC_CHILD_MAX___15 = 1,
    _SC_CLK_TCK___15 = 2,
    _SC_NGROUPS_MAX___15 = 3,
    _SC_OPEN_MAX___15 = 4,
    _SC_STREAM_MAX___15 = 5,
    _SC_TZNAME_MAX___15 = 6,
    _SC_JOB_CONTROL___15 = 7,
    _SC_SAVED_IDS___15 = 8,
    _SC_REALTIME_SIGNALS___15 = 9,
    _SC_PRIORITY_SCHEDULING___15 = 10,
    _SC_TIMERS___15 = 11,
    _SC_ASYNCHRONOUS_IO___15 = 12,
    _SC_PRIORITIZED_IO___15 = 13,
    _SC_SYNCHRONIZED_IO___15 = 14,
    _SC_FSYNC___15 = 15,
    _SC_MAPPED_FILES___15 = 16,
    _SC_MEMLOCK___15 = 17,
    _SC_MEMLOCK_RANGE___15 = 18,
    _SC_MEMORY_PROTECTION___15 = 19,
    _SC_MESSAGE_PASSING___15 = 20,
    _SC_SEMAPHORES___15 = 21,
    _SC_SHARED_MEMORY_OBJECTS___15 = 22,
    _SC_AIO_LISTIO_MAX___15 = 23,
    _SC_AIO_MAX___15 = 24,
    _SC_AIO_PRIO_DELTA_MAX___15 = 25,
    _SC_DELAYTIMER_MAX___15 = 26,
    _SC_MQ_OPEN_MAX___15 = 27,
    _SC_MQ_PRIO_MAX___15 = 28,
    _SC_VERSION___15 = 29,
    _SC_PAGESIZE___15 = 30,
    _SC_RTSIG_MAX___15 = 31,
    _SC_SEM_NSEMS_MAX___15 = 32,
    _SC_SEM_VALUE_MAX___15 = 33,
    _SC_SIGQUEUE_MAX___15 = 34,
    _SC_TIMER_MAX___15 = 35,
    _SC_BC_BASE_MAX___15 = 36,
    _SC_BC_DIM_MAX___15 = 37,
    _SC_BC_SCALE_MAX___15 = 38,
    _SC_BC_STRING_MAX___15 = 39,
    _SC_COLL_WEIGHTS_MAX___15 = 40,
    _SC_EQUIV_CLASS_MAX___15 = 41,
    _SC_EXPR_NEST_MAX___15 = 42,
    _SC_LINE_MAX___15 = 43,
    _SC_RE_DUP_MAX___15 = 44,
    _SC_CHARCLASS_NAME_MAX___15 = 45,
    _SC_2_VERSION___15 = 46,
    _SC_2_C_BIND___15 = 47,
    _SC_2_C_DEV___15 = 48,
    _SC_2_FORT_DEV___15 = 49,
    _SC_2_FORT_RUN___15 = 50,
    _SC_2_SW_DEV___15 = 51,
    _SC_2_LOCALEDEF___15 = 52,
    _SC_PII___15 = 53,
    _SC_PII_XTI___15 = 54,
    _SC_PII_SOCKET___15 = 55,
    _SC_PII_INTERNET___15 = 56,
    _SC_PII_OSI___15 = 57,
    _SC_POLL___15 = 58,
    _SC_SELECT___15 = 59,
    _SC_UIO_MAXIOV___15 = 60,
    _SC_IOV_MAX___15 = 60,
    _SC_PII_INTERNET_STREAM___15 = 61,
    _SC_PII_INTERNET_DGRAM___15 = 62,
    _SC_PII_OSI_COTS___15 = 63,
    _SC_PII_OSI_CLTS___15 = 64,
    _SC_PII_OSI_M___15 = 65,
    _SC_T_IOV_MAX___15 = 66,
    _SC_THREADS___15 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___15 = 68,
    _SC_GETGR_R_SIZE_MAX___15 = 69,
    _SC_GETPW_R_SIZE_MAX___15 = 70,
    _SC_LOGIN_NAME_MAX___15 = 71,
    _SC_TTY_NAME_MAX___15 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___15 = 73,
    _SC_THREAD_KEYS_MAX___15 = 74,
    _SC_THREAD_STACK_MIN___15 = 75,
    _SC_THREAD_THREADS_MAX___15 = 76,
    _SC_THREAD_ATTR_STACKADDR___15 = 77,
    _SC_THREAD_ATTR_STACKSIZE___15 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___15 = 79,
    _SC_THREAD_PRIO_INHERIT___15 = 80,
    _SC_THREAD_PRIO_PROTECT___15 = 81,
    _SC_THREAD_PROCESS_SHARED___15 = 82,
    _SC_NPROCESSORS_CONF___15 = 83,
    _SC_NPROCESSORS_ONLN___15 = 84,
    _SC_PHYS_PAGES___15 = 85,
    _SC_AVPHYS_PAGES___15 = 86,
    _SC_ATEXIT_MAX___15 = 87,
    _SC_PASS_MAX___15 = 88,
    _SC_XOPEN_VERSION___15 = 89,
    _SC_XOPEN_XCU_VERSION___15 = 90,
    _SC_XOPEN_UNIX___15 = 91,
    _SC_XOPEN_CRYPT___15 = 92,
    _SC_XOPEN_ENH_I18N___15 = 93,
    _SC_XOPEN_SHM___15 = 94,
    _SC_2_CHAR_TERM___15 = 95,
    _SC_2_C_VERSION___15 = 96,
    _SC_2_UPE___15 = 97,
    _SC_XOPEN_XPG2___15 = 98,
    _SC_XOPEN_XPG3___15 = 99,
    _SC_XOPEN_XPG4___15 = 100,
    _SC_CHAR_BIT___15 = 101,
    _SC_CHAR_MAX___15 = 102,
    _SC_CHAR_MIN___15 = 103,
    _SC_INT_MAX___15 = 104,
    _SC_INT_MIN___15 = 105,
    _SC_LONG_BIT___15 = 106,
    _SC_WORD_BIT___15 = 107,
    _SC_MB_LEN_MAX___15 = 108,
    _SC_NZERO___15 = 109,
    _SC_SSIZE_MAX___15 = 110,
    _SC_SCHAR_MAX___15 = 111,
    _SC_SCHAR_MIN___15 = 112,
    _SC_SHRT_MAX___15 = 113,
    _SC_SHRT_MIN___15 = 114,
    _SC_UCHAR_MAX___15 = 115,
    _SC_UINT_MAX___15 = 116,
    _SC_ULONG_MAX___15 = 117,
    _SC_USHRT_MAX___15 = 118,
    _SC_NL_ARGMAX___15 = 119,
    _SC_NL_LANGMAX___15 = 120,
    _SC_NL_MSGMAX___15 = 121,
    _SC_NL_NMAX___15 = 122,
    _SC_NL_SETMAX___15 = 123,
    _SC_NL_TEXTMAX___15 = 124,
    _SC_XBS5_ILP32_OFF32___15 = 125,
    _SC_XBS5_ILP32_OFFBIG___15 = 126,
    _SC_XBS5_LP64_OFF64___15 = 127,
    _SC_XBS5_LPBIG_OFFBIG___15 = 128,
    _SC_XOPEN_LEGACY___15 = 129,
    _SC_XOPEN_REALTIME___15 = 130,
    _SC_XOPEN_REALTIME_THREADS___15 = 131,
    _SC_ADVISORY_INFO___15 = 132,
    _SC_BARRIERS___15 = 133,
    _SC_BASE___15 = 134,
    _SC_C_LANG_SUPPORT___15 = 135,
    _SC_C_LANG_SUPPORT_R___15 = 136,
    _SC_CLOCK_SELECTION___15 = 137,
    _SC_CPUTIME___15 = 138,
    _SC_THREAD_CPUTIME___15 = 139,
    _SC_DEVICE_IO___15 = 140,
    _SC_DEVICE_SPECIFIC___15 = 141,
    _SC_DEVICE_SPECIFIC_R___15 = 142,
    _SC_FD_MGMT___15 = 143,
    _SC_FIFO___15 = 144,
    _SC_PIPE___15 = 145,
    _SC_FILE_ATTRIBUTES___15 = 146,
    _SC_FILE_LOCKING___15 = 147,
    _SC_FILE_SYSTEM___15 = 148,
    _SC_MONOTONIC_CLOCK___15 = 149,
    _SC_MULTI_PROCESS___15 = 150,
    _SC_SINGLE_PROCESS___15 = 151,
    _SC_NETWORKING___15 = 152,
    _SC_READER_WRITER_LOCKS___15 = 153,
    _SC_SPIN_LOCKS___15 = 154,
    _SC_REGEXP___15 = 155,
    _SC_REGEX_VERSION___15 = 156,
    _SC_SHELL___15 = 157,
    _SC_SIGNALS___15 = 158,
    _SC_SPAWN___15 = 159,
    _SC_SPORADIC_SERVER___15 = 160,
    _SC_THREAD_SPORADIC_SERVER___15 = 161,
    _SC_SYSTEM_DATABASE___15 = 162,
    _SC_SYSTEM_DATABASE_R___15 = 163,
    _SC_TIMEOUTS___15 = 164,
    _SC_TYPED_MEMORY_OBJECTS___15 = 165,
    _SC_USER_GROUPS___15 = 166,
    _SC_USER_GROUPS_R___15 = 167,
    _SC_2_PBS___15 = 168,
    _SC_2_PBS_ACCOUNTING___15 = 169,
    _SC_2_PBS_LOCATE___15 = 170,
    _SC_2_PBS_MESSAGE___15 = 171,
    _SC_2_PBS_TRACK___15 = 172,
    _SC_SYMLOOP_MAX___15 = 173,
    _SC_STREAMS___15 = 174,
    _SC_2_PBS_CHECKPOINT___15 = 175,
    _SC_V6_ILP32_OFF32___15 = 176,
    _SC_V6_ILP32_OFFBIG___15 = 177,
    _SC_V6_LP64_OFF64___15 = 178,
    _SC_V6_LPBIG_OFFBIG___15 = 179,
    _SC_HOST_NAME_MAX___15 = 180,
    _SC_TRACE___15 = 181,
    _SC_TRACE_EVENT_FILTER___15 = 182,
    _SC_TRACE_INHERIT___15 = 183,
    _SC_TRACE_LOG___15 = 184,
    _SC_LEVEL1_ICACHE_SIZE___15 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___15 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___15 = 187,
    _SC_LEVEL1_DCACHE_SIZE___15 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___15 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___15 = 190,
    _SC_LEVEL2_CACHE_SIZE___15 = 191,
    _SC_LEVEL2_CACHE_ASSOC___15 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___15 = 193,
    _SC_LEVEL3_CACHE_SIZE___15 = 194,
    _SC_LEVEL3_CACHE_ASSOC___15 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___15 = 196,
    _SC_LEVEL4_CACHE_SIZE___15 = 197,
    _SC_LEVEL4_CACHE_ASSOC___15 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___15 = 199,
    _SC_IPV6___15 = 235,
    _SC_RAW_SOCKETS___15 = 236,
    _SC_V7_ILP32_OFF32___15 = 237,
    _SC_V7_ILP32_OFFBIG___15 = 238,
    _SC_V7_LP64_OFF64___15 = 239,
    _SC_V7_LPBIG_OFFBIG___15 = 240,
    _SC_SS_REPL_MAX___15 = 241,
    _SC_TRACE_EVENT_NAME_MAX___15 = 242,
    _SC_TRACE_NAME_MAX___15 = 243,
    _SC_TRACE_SYS_MAX___15 = 244,
    _SC_TRACE_USER_EVENT_MAX___15 = 245,
    _SC_XOPEN_STREAMS___15 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___15 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___15 = 248,
    _SC_MINSIGSTKSZ___15 = 249,
    _SC_SIGSTKSZ___15 = 250
} ;
#line 539
enum __anonenum__21___13 {
    _CS_PATH___15 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___15 = 1,
    _CS_GNU_LIBC_VERSION___15 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___15 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___15 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___15 = 5,
    _CS_LFS_CFLAGS___15 = 1000,
    _CS_LFS_LDFLAGS___15 = 1001,
    _CS_LFS_LIBS___15 = 1002,
    _CS_LFS_LINTFLAGS___15 = 1003,
    _CS_LFS64_CFLAGS___15 = 1004,
    _CS_LFS64_LDFLAGS___15 = 1005,
    _CS_LFS64_LIBS___15 = 1006,
    _CS_LFS64_LINTFLAGS___15 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___15 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___15 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___15 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___15 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___15 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___15 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___15 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___15 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___15 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___15 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___15 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___15 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___15 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___15 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___15 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___15 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___15 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___15 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___15 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___15 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___15 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___15 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___15 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___15 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___15 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___15 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___15 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___15 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___15 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___15 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___15 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___15 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___15 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___15 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___15 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___15 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___15 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___15 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___15 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___15 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___15 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___15 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___15 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___15 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___15 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___15 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___15 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___15 = 1147,
    _CS_V6_ENV___15 = 1148,
    _CS_V7_ENV___15 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___13 {
    MSG_OOB___15 = 1,
    MSG_PEEK___15 = 2,
    MSG_DONTROUTE___15 = 4,
    MSG_CTRUNC___15 = 8,
    MSG_PROXY___15 = 16,
    MSG_TRUNC___15 = 32,
    MSG_DONTWAIT___15 = 64,
    MSG_EOR___15 = 128,
    MSG_WAITALL___15 = 256,
    MSG_FIN___15 = 512,
    MSG_SYN___15 = 1024,
    MSG_CONFIRM___15 = 2048,
    MSG_RST___15 = 4096,
    MSG_ERRQUEUE___15 = 8192,
    MSG_NOSIGNAL___15 = 16384,
    MSG_MORE___15 = 32768,
    MSG_WAITFORONE___15 = 65536,
    MSG_BATCH___15 = 262144,
    MSG_ZEROCOPY___15 = 67108864,
    MSG_FASTOPEN___15 = 536870912,
    MSG_CMSG_CLOEXEC___15 = 1073741824
} ;
#line 334
enum __anonenum__23___13 {
    SCM_RIGHTS___15 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___13 {
    SHUT_RD___15 = 0,
    SHUT_WR___15 = 1,
    SHUT_RDWR___15 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___13 {
    IPPROTO_IP___15 = 0,
    IPPROTO_ICMP___15 = 1,
    IPPROTO_IGMP___15 = 2,
    IPPROTO_IPIP___15 = 4,
    IPPROTO_TCP___15 = 6,
    IPPROTO_EGP___15 = 8,
    IPPROTO_PUP___15 = 12,
    IPPROTO_UDP___15 = 17,
    IPPROTO_IDP___15 = 22,
    IPPROTO_TP___15 = 29,
    IPPROTO_DCCP___15 = 33,
    IPPROTO_IPV6___15 = 41,
    IPPROTO_RSVP___15 = 46,
    IPPROTO_GRE___15 = 47,
    IPPROTO_ESP___15 = 50,
    IPPROTO_AH___15 = 51,
    IPPROTO_MTP___15 = 92,
    IPPROTO_BEETPH___15 = 94,
    IPPROTO_ENCAP___15 = 98,
    IPPROTO_PIM___15 = 103,
    IPPROTO_COMP___15 = 108,
    IPPROTO_SCTP___15 = 132,
    IPPROTO_UDPLITE___15 = 136,
    IPPROTO_MPLS___15 = 137,
    IPPROTO_ETHERNET___15 = 143,
    IPPROTO_RAW___15 = 255,
    IPPROTO_MPTCP___15 = 262,
    IPPROTO_MAX___15 = 263
} ;
#line 103
enum __anonenum__28___13 {
    IPPROTO_HOPOPTS___15 = 0,
    IPPROTO_ROUTING___15 = 43,
    IPPROTO_FRAGMENT___15 = 44,
    IPPROTO_ICMPV6___15 = 58,
    IPPROTO_NONE___15 = 59,
    IPPROTO_DSTOPTS___15 = 60,
    IPPROTO_MH___15 = 135
} ;
#line 126
enum __anonenum__29___13 {
    IPPORT_ECHO___15 = 7,
    IPPORT_DISCARD___15 = 9,
    IPPORT_SYSTAT___15 = 11,
    IPPORT_DAYTIME___15 = 13,
    IPPORT_NETSTAT___15 = 15,
    IPPORT_FTP___15 = 21,
    IPPORT_TELNET___15 = 23,
    IPPORT_SMTP___15 = 25,
    IPPORT_TIMESERVER___15 = 37,
    IPPORT_NAMESERVER___15 = 42,
    IPPORT_WHOIS___15 = 43,
    IPPORT_MTP___15 = 57,
    IPPORT_TFTP___15 = 69,
    IPPORT_RJE___15 = 77,
    IPPORT_FINGER___15 = 79,
    IPPORT_TTYLINK___15 = 87,
    IPPORT_SUPDUP___15 = 95,
    IPPORT_EXECSERVER___15 = 512,
    IPPORT_LOGINSERVER___15 = 513,
    IPPORT_CMDSERVER___15 = 514,
    IPPORT_EFSSERVER___15 = 520,
    IPPORT_BIFFUDP___15 = 512,
    IPPORT_WHOSERVER___15 = 513,
    IPPORT_ROUTESERVER___15 = 520,
    IPPORT_RESERVED___15 = 1024,
    IPPORT_USERRESERVED___15 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___13 {
    PTHREAD_CREATE_JOINABLE___15 = 0,
    PTHREAD_CREATE_DETACHED___15 = 1
} ;
#line 47
enum __anonenum__33___13 {
    PTHREAD_MUTEX_TIMED_NP___15 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___15 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___15 = 3,
    PTHREAD_MUTEX_NORMAL___15 = 0,
    PTHREAD_MUTEX_RECURSIVE___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK___15 = 2,
    PTHREAD_MUTEX_DEFAULT___15 = 0
} ;
#line 69
enum __anonenum__34___13 {
    PTHREAD_MUTEX_STALLED___15 = 0,
    PTHREAD_MUTEX_STALLED_NP___15 = 0,
    PTHREAD_MUTEX_ROBUST___15 = 1,
    PTHREAD_MUTEX_ROBUST_NP___15 = 1
} ;
#line 81
enum __anonenum__35___13 {
    PTHREAD_PRIO_NONE___15 = 0,
    PTHREAD_PRIO_INHERIT___15 = 1,
    PTHREAD_PRIO_PROTECT___15 = 2
} ;
#line 104
enum __anonenum__36___13 {
    PTHREAD_RWLOCK_PREFER_READER_NP___15 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___15 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___15 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___15 = 0
} ;
#line 124
enum __anonenum__37___13 {
    PTHREAD_INHERIT_SCHED___15 = 0,
    PTHREAD_EXPLICIT_SCHED___15 = 1
} ;
#line 134
enum __anonenum__38___13 {
    PTHREAD_SCOPE_SYSTEM___15 = 0,
    PTHREAD_SCOPE_PROCESS___15 = 1
} ;
#line 144
enum __anonenum__39___13 {
    PTHREAD_PROCESS_PRIVATE___15 = 0,
    PTHREAD_PROCESS_SHARED___15 = 1
} ;
#line 168
enum __anonenum__40___13 {
    PTHREAD_CANCEL_ENABLE___15 = 0,
    PTHREAD_CANCEL_DISABLE___15 = 1
} ;
#line 175
enum __anonenum__41___13 {
    PTHREAD_CANCEL_DEFERRED___15 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___15 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___13 {
    SI_ASYNCNL___15 = -60,
    SI_DETHREAD___15 = -7,
    SI_TKILL___15 = -6,
    SI_SIGIO___15 = -5,
    SI_ASYNCIO___15 = -4,
    SI_MESGQ___15 = -3,
    SI_TIMER___15 = -2,
    SI_QUEUE___15 = -1,
    SI_USER___15 = 0,
    SI_KERNEL___15 = 128
} ;
#line 71
enum __anonenum__55___13 {
    ILL_ILLOPC___15 = 1,
    ILL_ILLOPN___15 = 2,
    ILL_ILLADR___15 = 3,
    ILL_ILLTRP___15 = 4,
    ILL_PRVOPC___15 = 5,
    ILL_PRVREG___15 = 6,
    ILL_COPROC___15 = 7,
    ILL_BADSTK___15 = 8,
    ILL_BADIADDR___15 = 9
} ;
#line 94
enum __anonenum__56___13 {
    FPE_INTDIV___15 = 1,
    FPE_INTOVF___15 = 2,
    FPE_FLTDIV___15 = 3,
    FPE_FLTOVF___15 = 4,
    FPE_FLTUND___15 = 5,
    FPE_FLTRES___15 = 6,
    FPE_FLTINV___15 = 7,
    FPE_FLTSUB___15 = 8,
    FPE_FLTUNK___15 = 14,
    FPE_CONDTRAP___15 = 15
} ;
#line 119
enum __anonenum__57___13 {
    SEGV_MAPERR___15 = 1,
    SEGV_ACCERR___15 = 2,
    SEGV_BNDERR___15 = 3,
    SEGV_PKUERR___15 = 4,
    SEGV_ACCADI___15 = 5,
    SEGV_ADIDERR___15 = 6,
    SEGV_ADIPERR___15 = 7,
    SEGV_MTEAERR___15 = 8,
    SEGV_MTESERR___15 = 9
} ;
#line 142
enum __anonenum__58___13 {
    BUS_ADRALN___15 = 1,
    BUS_ADRERR___15 = 2,
    BUS_OBJERR___15 = 3,
    BUS_MCEERR_AR___15 = 4,
    BUS_MCEERR_AO___15 = 5
} ;
#line 176
enum __anonenum__59___13 {
    CLD_EXITED___15 = 1,
    CLD_KILLED___15 = 2,
    CLD_DUMPED___15 = 3,
    CLD_TRAPPED___15 = 4,
    CLD_STOPPED___15 = 5,
    CLD_CONTINUED___15 = 6
} ;
#line 193
enum __anonenum__60___13 {
    POLL_IN___15 = 1,
    POLL_OUT___15 = 2,
    POLL_MSG___15 = 3,
    POLL_ERR___15 = 4,
    POLL_PRI___15 = 5,
    POLL_HUP___15 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___13 {
    SIGEV_SIGNAL___15 = 0,
    SIGEV_NONE___15 = 1,
    SIGEV_THREAD___15 = 2,
    SIGEV_THREAD_ID___15 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___13 {
    SS_ONSTACK___15 = 1,
    SS_DISABLE___15 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___13 {
    EFD_SEMAPHORE___15 = 1,
    EFD_CLOEXEC___15 = 524288,
    EFD_NONBLOCK___15 = 2048
} ;
#line 31 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct HELO_packet {
   char opcode[4] ;
   u32_t length ;
   u8_t deviceid ;
   u8_t revision ;
   u8_t mac[6] ;
   u8_t uuid[16] ;
   u16_t wlan_channellist ;
   u32_t bytes_received_H ;
   u32_t bytes_received_L ;
   char lang[2] ;
};
#line 45 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct STAT_packet {
   char opcode[4] ;
   u32_t length ;
   u32_t event ;
   u8_t num_crlf ;
   u8_t mas_initialized ;
   u8_t mas_mode ;
   u32_t stream_buffer_size ;
   u32_t stream_buffer_fullness ;
   u32_t bytes_received_H ;
   u32_t bytes_received_L ;
   u16_t signal_strength ;
   u32_t jiffies ;
   u32_t output_buffer_size ;
   u32_t output_buffer_fullness ;
   u32_t elapsed_seconds ;
   u16_t voltage ;
   u32_t elapsed_milliseconds ;
   u32_t server_timestamp ;
   u16_t error_code ;
};
#line 68 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct DSCO_packet {
   char opcode[4] ;
   u32_t length ;
   u8_t reason ;
};
#line 75 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct RESP_header {
   char opcode[4] ;
   u32_t length ;
};
#line 82 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct META_header {
   char opcode[4] ;
   u32_t length ;
};
#line 89 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct SETD_header {
   char opcode[4] ;
   u32_t length ;
   u8_t id ;
};
#line 108 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct strm_packet {
   char opcode[4] ;
   char command ;
   u8_t autostart ;
   u8_t format ;
   u8_t pcm_sample_size ;
   u8_t pcm_sample_rate ;
   u8_t pcm_channels ;
   u8_t pcm_endianness ;
   u8_t threshold ;
   u8_t spdif_enable ;
   u8_t transition_period ;
   u8_t transition_type ;
   u8_t flags ;
   u8_t output_threshold ;
   u8_t slaves ;
   u32_t replay_gain ;
   u16_t server_port ;
   u32_t server_ip ;
};
#line 131 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct aude_packet {
   char opcode[4] ;
   u8_t enable_spdif ;
   u8_t enable_dac ;
};
#line 138 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct audg_packet {
   char opcode[4] ;
   u32_t old_gainL ;
   u32_t old_gainR ;
   u8_t adjust ;
   u8_t preamp ;
   u32_t gainL ;
   u32_t gainR ;
};
#line 150 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct cont_packet {
   char opcode[4] ;
   u32_t metaint ;
   u8_t loop ;
};
#line 158 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct serv_packet {
   char opcode[4] ;
   u32_t server_ip ;
};
#line 165 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct setd_packet {
   char opcode[4] ;
   u8_t id ;
   char data[] ;
};
#line 172 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.h"
struct codc_packet {
   char opcode[4] ;
   u8_t format ;
   u8_t pcm_sample_size ;
   u8_t pcm_sample_rate ;
   u8_t pcm_channels ;
   u8_t pcm_endianness ;
};
#line 72 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
struct __anonstruct_251 {
   u32_t updated ;
   u32_t stream_start ;
   u32_t stream_full ;
   u32_t stream_size ;
   u64_t stream_bytes ;
   u32_t output_full ;
   u32_t output_size ;
   u32_t frames_played ;
   u32_t device_frames ;
   u32_t current_sample_rate ;
   u32_t last ;
   stream_state stream_state ;
};
#line 507 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
struct handler {
   char opcode[5] ;
   void (*handler)(u8_t * , int  ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__19___14 {
    _PC_LINK_MAX___16 = 0,
    _PC_MAX_CANON___16 = 1,
    _PC_MAX_INPUT___16 = 2,
    _PC_NAME_MAX___16 = 3,
    _PC_PATH_MAX___16 = 4,
    _PC_PIPE_BUF___16 = 5,
    _PC_CHOWN_RESTRICTED___16 = 6,
    _PC_NO_TRUNC___16 = 7,
    _PC_VDISABLE___16 = 8,
    _PC_SYNC_IO___16 = 9,
    _PC_ASYNC_IO___16 = 10,
    _PC_PRIO_IO___16 = 11,
    _PC_SOCK_MAXBUF___16 = 12,
    _PC_FILESIZEBITS___16 = 13,
    _PC_REC_INCR_XFER_SIZE___16 = 14,
    _PC_REC_MAX_XFER_SIZE___16 = 15,
    _PC_REC_MIN_XFER_SIZE___16 = 16,
    _PC_REC_XFER_ALIGN___16 = 17,
    _PC_ALLOC_SIZE_MIN___16 = 18,
    _PC_SYMLINK_MAX___16 = 19,
    _PC_2_SYMLINKS___16 = 20
} ;
#line 71
enum __anonenum__20___14 {
    _SC_ARG_MAX___16 = 0,
    _SC_CHILD_MAX___16 = 1,
    _SC_CLK_TCK___16 = 2,
    _SC_NGROUPS_MAX___16 = 3,
    _SC_OPEN_MAX___16 = 4,
    _SC_STREAM_MAX___16 = 5,
    _SC_TZNAME_MAX___16 = 6,
    _SC_JOB_CONTROL___16 = 7,
    _SC_SAVED_IDS___16 = 8,
    _SC_REALTIME_SIGNALS___16 = 9,
    _SC_PRIORITY_SCHEDULING___16 = 10,
    _SC_TIMERS___16 = 11,
    _SC_ASYNCHRONOUS_IO___16 = 12,
    _SC_PRIORITIZED_IO___16 = 13,
    _SC_SYNCHRONIZED_IO___16 = 14,
    _SC_FSYNC___16 = 15,
    _SC_MAPPED_FILES___16 = 16,
    _SC_MEMLOCK___16 = 17,
    _SC_MEMLOCK_RANGE___16 = 18,
    _SC_MEMORY_PROTECTION___16 = 19,
    _SC_MESSAGE_PASSING___16 = 20,
    _SC_SEMAPHORES___16 = 21,
    _SC_SHARED_MEMORY_OBJECTS___16 = 22,
    _SC_AIO_LISTIO_MAX___16 = 23,
    _SC_AIO_MAX___16 = 24,
    _SC_AIO_PRIO_DELTA_MAX___16 = 25,
    _SC_DELAYTIMER_MAX___16 = 26,
    _SC_MQ_OPEN_MAX___16 = 27,
    _SC_MQ_PRIO_MAX___16 = 28,
    _SC_VERSION___16 = 29,
    _SC_PAGESIZE___16 = 30,
    _SC_RTSIG_MAX___16 = 31,
    _SC_SEM_NSEMS_MAX___16 = 32,
    _SC_SEM_VALUE_MAX___16 = 33,
    _SC_SIGQUEUE_MAX___16 = 34,
    _SC_TIMER_MAX___16 = 35,
    _SC_BC_BASE_MAX___16 = 36,
    _SC_BC_DIM_MAX___16 = 37,
    _SC_BC_SCALE_MAX___16 = 38,
    _SC_BC_STRING_MAX___16 = 39,
    _SC_COLL_WEIGHTS_MAX___16 = 40,
    _SC_EQUIV_CLASS_MAX___16 = 41,
    _SC_EXPR_NEST_MAX___16 = 42,
    _SC_LINE_MAX___16 = 43,
    _SC_RE_DUP_MAX___16 = 44,
    _SC_CHARCLASS_NAME_MAX___16 = 45,
    _SC_2_VERSION___16 = 46,
    _SC_2_C_BIND___16 = 47,
    _SC_2_C_DEV___16 = 48,
    _SC_2_FORT_DEV___16 = 49,
    _SC_2_FORT_RUN___16 = 50,
    _SC_2_SW_DEV___16 = 51,
    _SC_2_LOCALEDEF___16 = 52,
    _SC_PII___16 = 53,
    _SC_PII_XTI___16 = 54,
    _SC_PII_SOCKET___16 = 55,
    _SC_PII_INTERNET___16 = 56,
    _SC_PII_OSI___16 = 57,
    _SC_POLL___16 = 58,
    _SC_SELECT___16 = 59,
    _SC_UIO_MAXIOV___16 = 60,
    _SC_IOV_MAX___16 = 60,
    _SC_PII_INTERNET_STREAM___16 = 61,
    _SC_PII_INTERNET_DGRAM___16 = 62,
    _SC_PII_OSI_COTS___16 = 63,
    _SC_PII_OSI_CLTS___16 = 64,
    _SC_PII_OSI_M___16 = 65,
    _SC_T_IOV_MAX___16 = 66,
    _SC_THREADS___16 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___16 = 68,
    _SC_GETGR_R_SIZE_MAX___16 = 69,
    _SC_GETPW_R_SIZE_MAX___16 = 70,
    _SC_LOGIN_NAME_MAX___16 = 71,
    _SC_TTY_NAME_MAX___16 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___16 = 73,
    _SC_THREAD_KEYS_MAX___16 = 74,
    _SC_THREAD_STACK_MIN___16 = 75,
    _SC_THREAD_THREADS_MAX___16 = 76,
    _SC_THREAD_ATTR_STACKADDR___16 = 77,
    _SC_THREAD_ATTR_STACKSIZE___16 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___16 = 79,
    _SC_THREAD_PRIO_INHERIT___16 = 80,
    _SC_THREAD_PRIO_PROTECT___16 = 81,
    _SC_THREAD_PROCESS_SHARED___16 = 82,
    _SC_NPROCESSORS_CONF___16 = 83,
    _SC_NPROCESSORS_ONLN___16 = 84,
    _SC_PHYS_PAGES___16 = 85,
    _SC_AVPHYS_PAGES___16 = 86,
    _SC_ATEXIT_MAX___16 = 87,
    _SC_PASS_MAX___16 = 88,
    _SC_XOPEN_VERSION___16 = 89,
    _SC_XOPEN_XCU_VERSION___16 = 90,
    _SC_XOPEN_UNIX___16 = 91,
    _SC_XOPEN_CRYPT___16 = 92,
    _SC_XOPEN_ENH_I18N___16 = 93,
    _SC_XOPEN_SHM___16 = 94,
    _SC_2_CHAR_TERM___16 = 95,
    _SC_2_C_VERSION___16 = 96,
    _SC_2_UPE___16 = 97,
    _SC_XOPEN_XPG2___16 = 98,
    _SC_XOPEN_XPG3___16 = 99,
    _SC_XOPEN_XPG4___16 = 100,
    _SC_CHAR_BIT___16 = 101,
    _SC_CHAR_MAX___16 = 102,
    _SC_CHAR_MIN___16 = 103,
    _SC_INT_MAX___16 = 104,
    _SC_INT_MIN___16 = 105,
    _SC_LONG_BIT___16 = 106,
    _SC_WORD_BIT___16 = 107,
    _SC_MB_LEN_MAX___16 = 108,
    _SC_NZERO___16 = 109,
    _SC_SSIZE_MAX___16 = 110,
    _SC_SCHAR_MAX___16 = 111,
    _SC_SCHAR_MIN___16 = 112,
    _SC_SHRT_MAX___16 = 113,
    _SC_SHRT_MIN___16 = 114,
    _SC_UCHAR_MAX___16 = 115,
    _SC_UINT_MAX___16 = 116,
    _SC_ULONG_MAX___16 = 117,
    _SC_USHRT_MAX___16 = 118,
    _SC_NL_ARGMAX___16 = 119,
    _SC_NL_LANGMAX___16 = 120,
    _SC_NL_MSGMAX___16 = 121,
    _SC_NL_NMAX___16 = 122,
    _SC_NL_SETMAX___16 = 123,
    _SC_NL_TEXTMAX___16 = 124,
    _SC_XBS5_ILP32_OFF32___16 = 125,
    _SC_XBS5_ILP32_OFFBIG___16 = 126,
    _SC_XBS5_LP64_OFF64___16 = 127,
    _SC_XBS5_LPBIG_OFFBIG___16 = 128,
    _SC_XOPEN_LEGACY___16 = 129,
    _SC_XOPEN_REALTIME___16 = 130,
    _SC_XOPEN_REALTIME_THREADS___16 = 131,
    _SC_ADVISORY_INFO___16 = 132,
    _SC_BARRIERS___16 = 133,
    _SC_BASE___16 = 134,
    _SC_C_LANG_SUPPORT___16 = 135,
    _SC_C_LANG_SUPPORT_R___16 = 136,
    _SC_CLOCK_SELECTION___16 = 137,
    _SC_CPUTIME___16 = 138,
    _SC_THREAD_CPUTIME___16 = 139,
    _SC_DEVICE_IO___16 = 140,
    _SC_DEVICE_SPECIFIC___16 = 141,
    _SC_DEVICE_SPECIFIC_R___16 = 142,
    _SC_FD_MGMT___16 = 143,
    _SC_FIFO___16 = 144,
    _SC_PIPE___16 = 145,
    _SC_FILE_ATTRIBUTES___16 = 146,
    _SC_FILE_LOCKING___16 = 147,
    _SC_FILE_SYSTEM___16 = 148,
    _SC_MONOTONIC_CLOCK___16 = 149,
    _SC_MULTI_PROCESS___16 = 150,
    _SC_SINGLE_PROCESS___16 = 151,
    _SC_NETWORKING___16 = 152,
    _SC_READER_WRITER_LOCKS___16 = 153,
    _SC_SPIN_LOCKS___16 = 154,
    _SC_REGEXP___16 = 155,
    _SC_REGEX_VERSION___16 = 156,
    _SC_SHELL___16 = 157,
    _SC_SIGNALS___16 = 158,
    _SC_SPAWN___16 = 159,
    _SC_SPORADIC_SERVER___16 = 160,
    _SC_THREAD_SPORADIC_SERVER___16 = 161,
    _SC_SYSTEM_DATABASE___16 = 162,
    _SC_SYSTEM_DATABASE_R___16 = 163,
    _SC_TIMEOUTS___16 = 164,
    _SC_TYPED_MEMORY_OBJECTS___16 = 165,
    _SC_USER_GROUPS___16 = 166,
    _SC_USER_GROUPS_R___16 = 167,
    _SC_2_PBS___16 = 168,
    _SC_2_PBS_ACCOUNTING___16 = 169,
    _SC_2_PBS_LOCATE___16 = 170,
    _SC_2_PBS_MESSAGE___16 = 171,
    _SC_2_PBS_TRACK___16 = 172,
    _SC_SYMLOOP_MAX___16 = 173,
    _SC_STREAMS___16 = 174,
    _SC_2_PBS_CHECKPOINT___16 = 175,
    _SC_V6_ILP32_OFF32___16 = 176,
    _SC_V6_ILP32_OFFBIG___16 = 177,
    _SC_V6_LP64_OFF64___16 = 178,
    _SC_V6_LPBIG_OFFBIG___16 = 179,
    _SC_HOST_NAME_MAX___16 = 180,
    _SC_TRACE___16 = 181,
    _SC_TRACE_EVENT_FILTER___16 = 182,
    _SC_TRACE_INHERIT___16 = 183,
    _SC_TRACE_LOG___16 = 184,
    _SC_LEVEL1_ICACHE_SIZE___16 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___16 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___16 = 187,
    _SC_LEVEL1_DCACHE_SIZE___16 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___16 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___16 = 190,
    _SC_LEVEL2_CACHE_SIZE___16 = 191,
    _SC_LEVEL2_CACHE_ASSOC___16 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___16 = 193,
    _SC_LEVEL3_CACHE_SIZE___16 = 194,
    _SC_LEVEL3_CACHE_ASSOC___16 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___16 = 196,
    _SC_LEVEL4_CACHE_SIZE___16 = 197,
    _SC_LEVEL4_CACHE_ASSOC___16 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___16 = 199,
    _SC_IPV6___16 = 235,
    _SC_RAW_SOCKETS___16 = 236,
    _SC_V7_ILP32_OFF32___16 = 237,
    _SC_V7_ILP32_OFFBIG___16 = 238,
    _SC_V7_LP64_OFF64___16 = 239,
    _SC_V7_LPBIG_OFFBIG___16 = 240,
    _SC_SS_REPL_MAX___16 = 241,
    _SC_TRACE_EVENT_NAME_MAX___16 = 242,
    _SC_TRACE_NAME_MAX___16 = 243,
    _SC_TRACE_SYS_MAX___16 = 244,
    _SC_TRACE_USER_EVENT_MAX___16 = 245,
    _SC_XOPEN_STREAMS___16 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___16 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___16 = 248,
    _SC_MINSIGSTKSZ___16 = 249,
    _SC_SIGSTKSZ___16 = 250
} ;
#line 539
enum __anonenum__21___14 {
    _CS_PATH___16 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___16 = 1,
    _CS_GNU_LIBC_VERSION___16 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___16 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___16 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___16 = 5,
    _CS_LFS_CFLAGS___16 = 1000,
    _CS_LFS_LDFLAGS___16 = 1001,
    _CS_LFS_LIBS___16 = 1002,
    _CS_LFS_LINTFLAGS___16 = 1003,
    _CS_LFS64_CFLAGS___16 = 1004,
    _CS_LFS64_LDFLAGS___16 = 1005,
    _CS_LFS64_LIBS___16 = 1006,
    _CS_LFS64_LINTFLAGS___16 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___16 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___16 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___16 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___16 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___16 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___16 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___16 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___16 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___16 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___16 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___16 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___16 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___16 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___16 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___16 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___16 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___16 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___16 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___16 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___16 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___16 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___16 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___16 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___16 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___16 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___16 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___16 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___16 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___16 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___16 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___16 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___16 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___16 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___16 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___16 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___16 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___16 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___16 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___16 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___16 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___16 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___16 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___16 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___16 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___16 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___16 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___16 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___16 = 1147,
    _CS_V6_ENV___16 = 1148,
    _CS_V7_ENV___16 = 1149
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__22___14 {
    MSG_OOB___16 = 1,
    MSG_PEEK___16 = 2,
    MSG_DONTROUTE___16 = 4,
    MSG_CTRUNC___16 = 8,
    MSG_PROXY___16 = 16,
    MSG_TRUNC___16 = 32,
    MSG_DONTWAIT___16 = 64,
    MSG_EOR___16 = 128,
    MSG_WAITALL___16 = 256,
    MSG_FIN___16 = 512,
    MSG_SYN___16 = 1024,
    MSG_CONFIRM___16 = 2048,
    MSG_RST___16 = 4096,
    MSG_ERRQUEUE___16 = 8192,
    MSG_NOSIGNAL___16 = 16384,
    MSG_MORE___16 = 32768,
    MSG_WAITFORONE___16 = 65536,
    MSG_BATCH___16 = 262144,
    MSG_ZEROCOPY___16 = 67108864,
    MSG_FASTOPEN___16 = 536870912,
    MSG_CMSG_CLOEXEC___16 = 1073741824
} ;
#line 334
enum __anonenum__23___14 {
    SCM_RIGHTS___16 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__26___14 {
    SHUT_RD___16 = 0,
    SHUT_WR___16 = 1,
    SHUT_RDWR___16 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__27___14 {
    IPPROTO_IP___16 = 0,
    IPPROTO_ICMP___16 = 1,
    IPPROTO_IGMP___16 = 2,
    IPPROTO_IPIP___16 = 4,
    IPPROTO_TCP___16 = 6,
    IPPROTO_EGP___16 = 8,
    IPPROTO_PUP___16 = 12,
    IPPROTO_UDP___16 = 17,
    IPPROTO_IDP___16 = 22,
    IPPROTO_TP___16 = 29,
    IPPROTO_DCCP___16 = 33,
    IPPROTO_IPV6___16 = 41,
    IPPROTO_RSVP___16 = 46,
    IPPROTO_GRE___16 = 47,
    IPPROTO_ESP___16 = 50,
    IPPROTO_AH___16 = 51,
    IPPROTO_MTP___16 = 92,
    IPPROTO_BEETPH___16 = 94,
    IPPROTO_ENCAP___16 = 98,
    IPPROTO_PIM___16 = 103,
    IPPROTO_COMP___16 = 108,
    IPPROTO_SCTP___16 = 132,
    IPPROTO_UDPLITE___16 = 136,
    IPPROTO_MPLS___16 = 137,
    IPPROTO_ETHERNET___16 = 143,
    IPPROTO_RAW___16 = 255,
    IPPROTO_MPTCP___16 = 262,
    IPPROTO_MAX___16 = 263
} ;
#line 103
enum __anonenum__28___14 {
    IPPROTO_HOPOPTS___16 = 0,
    IPPROTO_ROUTING___16 = 43,
    IPPROTO_FRAGMENT___16 = 44,
    IPPROTO_ICMPV6___16 = 58,
    IPPROTO_NONE___16 = 59,
    IPPROTO_DSTOPTS___16 = 60,
    IPPROTO_MH___16 = 135
} ;
#line 126
enum __anonenum__29___14 {
    IPPORT_ECHO___16 = 7,
    IPPORT_DISCARD___16 = 9,
    IPPORT_SYSTAT___16 = 11,
    IPPORT_DAYTIME___16 = 13,
    IPPORT_NETSTAT___16 = 15,
    IPPORT_FTP___16 = 21,
    IPPORT_TELNET___16 = 23,
    IPPORT_SMTP___16 = 25,
    IPPORT_TIMESERVER___16 = 37,
    IPPORT_NAMESERVER___16 = 42,
    IPPORT_WHOIS___16 = 43,
    IPPORT_MTP___16 = 57,
    IPPORT_TFTP___16 = 69,
    IPPORT_RJE___16 = 77,
    IPPORT_FINGER___16 = 79,
    IPPORT_TTYLINK___16 = 87,
    IPPORT_SUPDUP___16 = 95,
    IPPORT_EXECSERVER___16 = 512,
    IPPORT_LOGINSERVER___16 = 513,
    IPPORT_CMDSERVER___16 = 514,
    IPPORT_EFSSERVER___16 = 520,
    IPPORT_BIFFUDP___16 = 512,
    IPPORT_WHOSERVER___16 = 513,
    IPPORT_ROUTESERVER___16 = 520,
    IPPORT_RESERVED___16 = 1024,
    IPPORT_USERRESERVED___16 = 5000
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__32___14 {
    PTHREAD_CREATE_JOINABLE___16 = 0,
    PTHREAD_CREATE_DETACHED___16 = 1
} ;
#line 47
enum __anonenum__33___14 {
    PTHREAD_MUTEX_TIMED_NP___16 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___16 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___16 = 3,
    PTHREAD_MUTEX_NORMAL___16 = 0,
    PTHREAD_MUTEX_RECURSIVE___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK___16 = 2,
    PTHREAD_MUTEX_DEFAULT___16 = 0
} ;
#line 69
enum __anonenum__34___14 {
    PTHREAD_MUTEX_STALLED___16 = 0,
    PTHREAD_MUTEX_STALLED_NP___16 = 0,
    PTHREAD_MUTEX_ROBUST___16 = 1,
    PTHREAD_MUTEX_ROBUST_NP___16 = 1
} ;
#line 81
enum __anonenum__35___14 {
    PTHREAD_PRIO_NONE___16 = 0,
    PTHREAD_PRIO_INHERIT___16 = 1,
    PTHREAD_PRIO_PROTECT___16 = 2
} ;
#line 104
enum __anonenum__36___14 {
    PTHREAD_RWLOCK_PREFER_READER_NP___16 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___16 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___16 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___16 = 0
} ;
#line 124
enum __anonenum__37___14 {
    PTHREAD_INHERIT_SCHED___16 = 0,
    PTHREAD_EXPLICIT_SCHED___16 = 1
} ;
#line 134
enum __anonenum__38___14 {
    PTHREAD_SCOPE_SYSTEM___16 = 0,
    PTHREAD_SCOPE_PROCESS___16 = 1
} ;
#line 144
enum __anonenum__39___14 {
    PTHREAD_PROCESS_PRIVATE___16 = 0,
    PTHREAD_PROCESS_SHARED___16 = 1
} ;
#line 168
enum __anonenum__40___14 {
    PTHREAD_CANCEL_ENABLE___16 = 0,
    PTHREAD_CANCEL_DISABLE___16 = 1
} ;
#line 175
enum __anonenum__41___14 {
    PTHREAD_CANCEL_DEFERRED___16 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___16 = 1
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__54___14 {
    SI_ASYNCNL___16 = -60,
    SI_DETHREAD___16 = -7,
    SI_TKILL___16 = -6,
    SI_SIGIO___16 = -5,
    SI_ASYNCIO___16 = -4,
    SI_MESGQ___16 = -3,
    SI_TIMER___16 = -2,
    SI_QUEUE___16 = -1,
    SI_USER___16 = 0,
    SI_KERNEL___16 = 128
} ;
#line 71
enum __anonenum__55___14 {
    ILL_ILLOPC___16 = 1,
    ILL_ILLOPN___16 = 2,
    ILL_ILLADR___16 = 3,
    ILL_ILLTRP___16 = 4,
    ILL_PRVOPC___16 = 5,
    ILL_PRVREG___16 = 6,
    ILL_COPROC___16 = 7,
    ILL_BADSTK___16 = 8,
    ILL_BADIADDR___16 = 9
} ;
#line 94
enum __anonenum__56___14 {
    FPE_INTDIV___16 = 1,
    FPE_INTOVF___16 = 2,
    FPE_FLTDIV___16 = 3,
    FPE_FLTOVF___16 = 4,
    FPE_FLTUND___16 = 5,
    FPE_FLTRES___16 = 6,
    FPE_FLTINV___16 = 7,
    FPE_FLTSUB___16 = 8,
    FPE_FLTUNK___16 = 14,
    FPE_CONDTRAP___16 = 15
} ;
#line 119
enum __anonenum__57___14 {
    SEGV_MAPERR___16 = 1,
    SEGV_ACCERR___16 = 2,
    SEGV_BNDERR___16 = 3,
    SEGV_PKUERR___16 = 4,
    SEGV_ACCADI___16 = 5,
    SEGV_ADIDERR___16 = 6,
    SEGV_ADIPERR___16 = 7,
    SEGV_MTEAERR___16 = 8,
    SEGV_MTESERR___16 = 9
} ;
#line 142
enum __anonenum__58___14 {
    BUS_ADRALN___16 = 1,
    BUS_ADRERR___16 = 2,
    BUS_OBJERR___16 = 3,
    BUS_MCEERR_AR___16 = 4,
    BUS_MCEERR_AO___16 = 5
} ;
#line 176
enum __anonenum__59___14 {
    CLD_EXITED___16 = 1,
    CLD_KILLED___16 = 2,
    CLD_DUMPED___16 = 3,
    CLD_TRAPPED___16 = 4,
    CLD_STOPPED___16 = 5,
    CLD_CONTINUED___16 = 6
} ;
#line 193
enum __anonenum__60___14 {
    POLL_IN___16 = 1,
    POLL_OUT___16 = 2,
    POLL_MSG___16 = 3,
    POLL_ERR___16 = 4,
    POLL_PRI___16 = 5,
    POLL_HUP___16 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__63___14 {
    SIGEV_SIGNAL___16 = 0,
    SIGEV_NONE___16 = 1,
    SIGEV_THREAD___16 = 2,
    SIGEV_THREAD_ID___16 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__68___14 {
    SS_ONSTACK___16 = 1,
    SS_DISABLE___16 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/eventfd.h"
enum __anonenum__69___14 {
    EFD_SEMAPHORE___16 = 1,
    EFD_CLOEXEC___16 = 524288,
    EFD_NONBLOCK___16 = 2048
} ;
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 402 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 791
extern int system(char const   *__command ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 432
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 309
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 339
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern  __attribute__((__nothrow__)) void closefrom(int __lowfd ) ;
#line 371
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 389
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 437
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 452
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 498
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 503
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 517
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 521
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 531
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 545
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 552
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 555
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 564
extern char **__environ ;
#line 572
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 578
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 589
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 594
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 599
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 605
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 619
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 624
extern void _exit(int __status ) ;
#line 633
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 637
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 640
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 644
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 650
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 653
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 656
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 659
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 661
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 668
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 689
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 697
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 706
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 722
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 732
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 749
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 778
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 799
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 803
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 809
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 814
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 819
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 832
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 838
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 847
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 851
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 858
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 862
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 867
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 871
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 874
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 895
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 911 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 919
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 924
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 930
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 933
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 939
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 942
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 950
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 958
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 962
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 963
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 964
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 970
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 977
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 981
extern char *getpass(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 1011
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 1026
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1049
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1070
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1076
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1091
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1114
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1159
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1198
int getentropy(void *__buffer , size_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 29
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 36
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 38
  __cil_tmp7 = __builtin_object_size(__buf, 0);
  }
  {
#line 38
  __cil_tmp5 = __builtin_object_size(__buf, 0);
#line 38
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 38
  __cil_tmp4 = __builtin_constant_p(__nbytes);
  }
#line 38
  if (__cil_tmp6 && (unsigned long )__nbytes <= __cil_tmp7 / sizeof(char )) {
    {
#line 38
    __cil_tmp8 = __read_alias(__fd, __buf, __nbytes);
#line 38
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 38
    __cil_tmp12 = __builtin_object_size(__buf, 0);
    }
    {
#line 38
    __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 38
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 38
    __cil_tmp9 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (__cil_tmp11 && ! ((unsigned long )__nbytes <= __cil_tmp12 / sizeof(char ))) {
      {
#line 38
      __cil_tmp13 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp14 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp13);
#line 38
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 38
      __cil_tmp15 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp16 = __read_chk(__fd, __buf, __nbytes, __cil_tmp15);
#line 38
      tmp = __cil_tmp16;
      }
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  return (tmp___0);
}
}
#line 44
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 47
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 50
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 54
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 74
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 74
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 74
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 74
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 74
    __cil_tmp9 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 74
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 74
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 74
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 74
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 74
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 74
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 74
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp15 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 74
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 74
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp17 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 74
      tmp = __cil_tmp17;
      }
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 100
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 104
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 108
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 119
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 119
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 119
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 119
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 119
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 119
    __cil_tmp8 = __readlink_alias(__path, __buf, __len);
#line 119
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 119
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 119
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 119
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 119
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 119
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp14 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp13);
#line 119
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 119
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp16 = __readlink_chk(__path, __buf, __len, __cil_tmp15);
#line 119
      tmp = __cil_tmp16;
      }
    }
#line 119
    tmp___0 = tmp;
  }
#line 119
  return (tmp___0);
}
}
#line 126
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 130
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 135
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 147
  __cil_tmp8 = __builtin_object_size(__buf, 1);
  }
  {
#line 147
  __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 147
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 147
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 147
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 147
    __cil_tmp9 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 147
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 147
    __cil_tmp13 = __builtin_object_size(__buf, 1);
    }
    {
#line 147
    __cil_tmp11 = __builtin_object_size(__buf, 1);
#line 147
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 147
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 147
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 147
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp15 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp14);
#line 147
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 147
      __cil_tmp16 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp17 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp16);
#line 147
      tmp = __cil_tmp17;
      }
    }
#line 147
    tmp___0 = tmp;
  }
#line 147
  return (tmp___0);
}
}
#line 153
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 155
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 157
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 164
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 164 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 166
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 166
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 166
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 166
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 166
  if (__cil_tmp5 && (unsigned long )__size <= __cil_tmp6 / sizeof(char )) {
    {
#line 166
    __cil_tmp7 = __getcwd_alias(__buf, __size);
#line 166
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 166
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 166
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 166
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 166
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 166
    if (__cil_tmp10 && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(char ))) {
      {
#line 166
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp13 = __getcwd_chk_warn(__buf, __size, __cil_tmp12);
#line 166
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 166
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp15 = __getcwd_chk(__buf, __size, __cil_tmp14);
#line 166
      tmp = __cil_tmp15;
      }
    }
#line 166
    tmp___0 = tmp;
  }
#line 166
  return (tmp___0);
}
}
#line 172
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 174
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 181
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 182
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 182
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 182
    return (__cil_tmp4);
  }
  {
#line 183
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 183
  return (__cil_tmp5);
}
}
#line 187
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 190
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 193
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 202
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 202
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 202
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 202
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 202
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 202
    __cil_tmp8 = __confstr_alias(__name, __buf, __len);
#line 202
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 202
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 202
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 202
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 202
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 202
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 202
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp14 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp13);
#line 202
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 202
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp16 = __confstr_chk(__name, __buf, __len, __cil_tmp15);
#line 202
      tmp = __cil_tmp16;
      }
    }
#line 202
    tmp___0 = tmp;
  }
#line 202
  return (tmp___0);
}
}
#line 208
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 210
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 212
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 219
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 219 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  __cil_tmp6 = __builtin_object_size(__list, 1);
  }
  {
#line 221
  __cil_tmp4 = __builtin_object_size(__list, 1);
#line 221
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(__gid_t ));
  }
  {
#line 221
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 221
  if (((__cil_tmp3 && __size > 0) && __cil_tmp5) && (unsigned long )__size <= __cil_tmp6 / sizeof(__gid_t )) {
    {
#line 221
    __cil_tmp7 = __getgroups_alias(__size, __list);
#line 221
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 221
    __cil_tmp11 = __builtin_object_size(__list, 1);
    }
    {
#line 221
    __cil_tmp9 = __builtin_object_size(__list, 1);
#line 221
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(__gid_t ));
    }
    {
#line 221
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 221
    if (((__cil_tmp8 && __size > 0) && __cil_tmp10) && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(__gid_t ))) {
      {
#line 221
      __cil_tmp12 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp13 = __getgroups_chk_warn(__size, __list, __cil_tmp12);
#line 221
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 221
      __cil_tmp14 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp15 = __getgroups_chk(__size, __list, __cil_tmp14);
#line 221
      tmp = __cil_tmp15;
      }
    }
#line 221
    tmp___0 = tmp;
  }
#line 221
  return (tmp___0);
}
}
#line 227
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 230
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 233
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 242
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 242
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 242
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 242
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 242
    __cil_tmp8 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 242
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 242
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 242
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 242
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 242
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 242
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 242
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp14 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 242
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 242
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp16 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 242
      tmp = __cil_tmp16;
      }
    }
#line 242
    tmp___0 = tmp;
  }
#line 242
  return (tmp___0);
}
}
#line 249
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 251
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 253
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 260
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 260 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 262
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 262
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 262
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 262
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 262
    __cil_tmp7 = __getlogin_r_alias(__buf, __buflen);
#line 262
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 262
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 262
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 262
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 262
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 262
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 262
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp13 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp12);
#line 262
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 262
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp15 = __getlogin_r_chk(__buf, __buflen, __cil_tmp14);
#line 262
      tmp = __cil_tmp15;
      }
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return (tmp___0);
}
}
#line 270
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 272
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 275
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 282
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 284
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 284
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 284
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 284
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 284
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 284
    __cil_tmp7 = __gethostname_alias(__buf, __buflen);
#line 284
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 284
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 284
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 284
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 284
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 284
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 284
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp13 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 284
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 284
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp15 = __gethostname_chk(__buf, __buflen, __cil_tmp14);
#line 284
      tmp = __cil_tmp15;
      }
    }
#line 284
    tmp___0 = tmp;
  }
#line 284
  return (tmp___0);
}
}
#line 292
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 294
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 298
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 306
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 308
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 308
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 308
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 308
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 308
    __cil_tmp7 = __getdomainname_alias(__buf, __buflen);
#line 308
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 308
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 308
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 308
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 308
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 308
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 308
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp13 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 308
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 308
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp15 = __getdomainname_chk(__buf, __buflen, __cil_tmp14);
#line 308
      tmp = __cil_tmp15;
      }
    }
#line 308
    tmp___0 = tmp;
  }
#line 308
  return (tmp___0);
}
}
#line 307 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 316
  if ((size_t )__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 318
    return ((struct cmsghdr *)0);
  }
#line 320
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))));
#line 322
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  } else
#line 322
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  }
#line 328
  return (__cmsg);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 108
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int __fds[2] ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr *__addr ,
                                              socklen_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr *__addr ,
                                                     socklen_t *__len ) ;
#line 126
extern int connect(int __fd , struct sockaddr *__addr , socklen_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr *__addr ,
                                                     socklen_t *__len ) ;
#line 138
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 145
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 152
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr *__addr , socklen_t __addr_len ) ;
#line 163
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 174
extern ssize_t sendmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 216
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 255
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void *__optval , socklen_t *__optlen ) ;
#line 277
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 296
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 306
extern int accept(int __fd , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 324
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 329
extern  __attribute__((__nothrow__)) int sockatmark(int __fd ) ;
#line 337
extern  __attribute__((__nothrow__)) int isfdtype(int __fd , int __fdtype ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) ;
#line 34
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  ssize_t __cil_tmp13 ;

  {
  {
#line 36
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 36
  sz = __cil_tmp6;
#line 37
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 37
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 37
  if (__cil_tmp8) {
#line 37
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 38
      __cil_tmp9 = __recv_alias(__fd, __buf, __n, __flags);
      }
#line 38
      return (__cil_tmp9);
    }
  }
  {
#line 39
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 39
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 39
  if (__cil_tmp11) {
#line 39
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 40
      __cil_tmp12 = __recv_chk_warn(__fd, __buf, __n, sz, __flags);
      }
#line 40
      return (__cil_tmp12);
    }
  }
  {
#line 41
  __cil_tmp13 = __recv_chk(__fd, __buf, __n, sz, __flags);
  }
#line 41
  return (__cil_tmp13);
}
}
#line 44
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 48
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 52
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 61
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__buf, 0);
#line 64
  sz = __cil_tmp8;
#line 65
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 65
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 65
  if (__cil_tmp10) {
#line 65
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 66
      __cil_tmp11 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
      }
#line 66
      return (__cil_tmp11);
    }
  }
  {
#line 67
  __cil_tmp13 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 67
  __cil_tmp12 = __builtin_constant_p(__n);
  }
#line 67
  if (__cil_tmp13) {
#line 67
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 68
      __cil_tmp14 = __recvfrom_chk_warn(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
      }
#line 68
      return (__cil_tmp14);
    }
  }
  {
#line 70
  __cil_tmp15 = __recvfrom_chk(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
  }
#line 70
  return (__cil_tmp15);
}
}
#line 235 "/usr/include/netinet/in.h"
extern struct in6_addr in6addr_any ;
#line 236
extern struct in6_addr in6addr_loopback ;
#line 382
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong ) ;
#line 383
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort ) ;
#line 385
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong ) ;
#line 387
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort ) ;
#line 510
extern  __attribute__((__nothrow__)) int bindresvport(int __sockfd , struct sockaddr_in *__sock_in ) ;
#line 513
extern  __attribute__((__nothrow__)) int bindresvport6(int __sockfd , struct sockaddr_in6 *__sock_in ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 37
extern  __attribute__((__nothrow__)) in_addr_t inet_lnaof(struct in_addr __in ) ;
#line 41
extern  __attribute__((__nothrow__)) struct in_addr inet_makeaddr(in_addr_t __net ,
                                                                  in_addr_t __host ) ;
#line 45
extern  __attribute__((__nothrow__)) in_addr_t inet_netof(struct in_addr __in ) ;
#line 49
extern  __attribute__((__nothrow__)) in_addr_t inet_network(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   *__cp ,
                                                   void *__buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   *__cp ,
                                                             char *__buf , socklen_t __len ) ;
#line 73
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 77
extern  __attribute__((__nothrow__)) char *inet_neta(in_addr_t __net , char *__buf ,
                                                     size_t __len ) ;
#line 83
extern  __attribute__((__nothrow__)) char *inet_net_ntop(int __af , void const   *__cp ,
                                                         int __bits , char *__buf ,
                                                         size_t __len ) ;
#line 89
extern  __attribute__((__nothrow__)) int inet_net_pton(int __af , char const   *__cp ,
                                                       void *__buf , size_t __len ) ;
#line 95
extern  __attribute__((__nothrow__)) unsigned int inet_nsap_addr(char const   *__cp ,
                                                                 unsigned char *__buf ,
                                                                 int __len ) ;
#line 100
extern  __attribute__((__nothrow__)) char *inet_nsap_ntoa(int __len , unsigned char const   *__cp ,
                                                          char *__buf ) ;
#line 67 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 86
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 94
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 149
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 155
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 162
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 189
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 193
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/poll.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
extern int __poll_alias(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 28
extern int __poll_chk(struct pollfd *__fds , nfds_t __nfds , int __timeout , unsigned long __fdslen ) ;
#line 31
extern int __poll_chk_warn(struct pollfd *__fds , nfds_t __nfds , int __timeout ,
                           unsigned long __fdslen ) ;
#line 37
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  __cil_tmp7 = __builtin_object_size(__fds, 1);
  }
  {
#line 39
  __cil_tmp5 = __builtin_object_size(__fds, 1);
#line 39
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp5 / sizeof(*__fds));
  }
  {
#line 39
  __cil_tmp4 = __builtin_constant_p(__nfds);
  }
#line 39
  if (__cil_tmp6 && (unsigned long )__nfds <= __cil_tmp7 / sizeof(*__fds)) {
    {
#line 39
    __cil_tmp8 = __poll_alias(__fds, __nfds, __timeout);
#line 39
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 39
    __cil_tmp12 = __builtin_object_size(__fds, 1);
    }
    {
#line 39
    __cil_tmp10 = __builtin_object_size(__fds, 1);
#line 39
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp10 / sizeof(*__fds));
    }
    {
#line 39
    __cil_tmp9 = __builtin_constant_p(__nfds);
    }
#line 39
    if (__cil_tmp11 && ! ((unsigned long )__nfds <= __cil_tmp12 / sizeof(*__fds))) {
      {
#line 39
      __cil_tmp13 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp14 = __poll_chk_warn(__fds, __nfds, __timeout, __cil_tmp13);
#line 39
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 39
      __cil_tmp15 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp16 = __poll_chk(__fds, __nfds, __timeout, __cil_tmp15);
#line 39
      tmp = __cil_tmp16;
      }
    }
#line 39
    tmp___0 = tmp;
  }
#line 39
  return (tmp___0);
}
}
#line 58 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 62
extern  __attribute__((__nothrow__)) int dlclose(void *__handle ) ;
#line 66
extern  __attribute__((__nothrow__)) void *dlsym(void *__handle , char const   *__name ) ;
#line 84
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 333
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 34 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
extern  __attribute__((__nothrow__)) int eventfd(unsigned int __count , int __flags ) ;
#line 37
extern int eventfd_read(int __fd , eventfd_t *__value ) ;
#line 40
extern int eventfd_write(int __fd , eventfd_t __value ) ;
#line 442 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/squeezelite.h"
char const   *logtime(void) ;
#line 443
void logprint(char const   *fmt  , ...) ;
#line 457
char *next_param(char *src , char c ) ;
#line 458
u32_t gettime_ms(void) ;
#line 459
void get_mac(u8_t *mac ) ;
#line 460
void set_nonblock(sockfd s ) ;
#line 461
int connect_timeout(sockfd sock___0 , struct sockaddr *addr___0 , socklen_t addrlen ,
                    int timeout ) ;
#line 462
void server_addr(char *server , in_addr_t *ip_ptr , unsigned int *port_ptr ) ;
#line 463
void set_readwake_handles(struct pollfd handles[] , sockfd s , int e ) ;
#line 464
event_type wait_readwake(struct pollfd handles[] , int timeout ) ;
#line 465
void packN(u32_t *dest , u32_t val ) ;
#line 466
void packn(u16_t *dest , u16_t val ) ;
#line 467
u32_t unpackN(u32_t *src ) ;
#line 468
u16_t unpackn(u16_t *src ) ;
#line 487
void touch_memory(u8_t *buf___2 , size_t size ) ;
#line 502
unsigned int _buf_used(struct buffer *buf___2 ) ;
#line 503
unsigned int _buf_space(struct buffer *buf___2 ) ;
#line 504
unsigned int _buf_cont_read(struct buffer *buf___2 ) ;
#line 505
unsigned int _buf_cont_write(struct buffer *buf___2 ) ;
#line 506
void _buf_inc_readp(struct buffer *buf___2 , unsigned int by ) ;
#line 507
void _buf_inc_writep(struct buffer *buf___2 , unsigned int by ) ;
#line 508
void buf_flush(struct buffer *buf___2 ) ;
#line 509
void _buf_unwrap(struct buffer *buf___2 , size_t cont ) ;
#line 510
void buf_adjust(struct buffer *buf___2 , size_t mod ) ;
#line 511
void _buf_resize(struct buffer *buf___2 , size_t size ) ;
#line 512
void buf_init(struct buffer *buf___2 , size_t size ) ;
#line 513
void buf_destroy(struct buffer *buf___2 ) ;
#line 516
void slimproto(log_level level , char *server , u8_t mac[6] , char const   *name ,
               char const   *namefile , char const   *modelname , int maxSampleRate ) ;
#line 517
void slimproto_stop(void) ;
#line 518
void wake_controller(void) ;
#line 540
void stream_init(log_level level , unsigned int stream_buf_size ) ;
#line 541
void stream_close(void) ;
#line 542
void stream_file(char const   *header , size_t header_len , unsigned int threshold ) ;
#line 543
void stream_sock(u32_t ip , u16_t port , int use_ssl , char const   *header , size_t header_len ,
                 unsigned int threshold , int cont_wait ) ;
#line 544
int stream_disconnect(void) ;
#line 579
void decode_init(log_level level , char const   *include_codecs , char const   *exclude_codecs ) ;
#line 580
void decode_close(void) ;
#line 581
void decode_flush(void) ;
#line 582
unsigned int decode_newstream(unsigned int sample_rate___0 , unsigned int supported_rates[] ) ;
#line 583
void codec_open(u8_t format , u8_t sample_size___0 , u8_t sample_rate___0 , u8_t channels___0 ,
                u8_t endianness ) ;
#line 680
void output_init_common(log_level level , char const   *device , unsigned int output_buf_size ,
                        unsigned int rates[] , unsigned int idle ) ;
#line 681
void output_close_common(void) ;
#line 682
void output_flush(void) ;
#line 684
frames_t _output_frames(frames_t avail ) ;
#line 685
void _checkfade(int start ) ;
#line 689
void list_devices(void) ;
#line 690
void list_mixers(char const   *output_device ) ;
#line 691
void set_volume(unsigned int left , unsigned int right ) ;
#line 692
int test_open(char const   *device , unsigned int rates[] , int userdef_rates ) ;
#line 693
void output_init_alsa(log_level level , char const   *device , unsigned int output_buf_size ,
                      char *params , unsigned int rates[] , unsigned int rate_delay ,
                      unsigned int rt_priority , unsigned int idle , char *mixer_device ,
                      char *volume_mixer , int mixer_unmute , int mixer_linear ) ;
#line 694
void output_close_alsa(void) ;
#line 718
void output_init_stdout(log_level level , unsigned int output_buf_size , char *params ,
                        unsigned int rates[] , unsigned int rate_delay ) ;
#line 719
void output_close_stdout(void) ;
#line 722
void _scale_and_pack_frames(void *outputptr , s32_t *inputptr , frames_t cnt , s32_t gainL ,
                            s32_t gainR , u8_t flags , output_format format ) ;
#line 723
void _apply_cross(struct buffer *outputbuf___0 , frames_t out_frames , s32_t cross_gain_in ,
                  s32_t cross_gain_out , s32_t **cross_ptr ) ;
#line 724
void _apply_gain(struct buffer *outputbuf___0 , frames_t count , s32_t gainL , s32_t gainR ,
                 u8_t flags ) ;
#line 725
s32_t gain(s32_t gain___0 , s32_t sample ) ;
#line 726
s32_t to_gain(float f___0 ) ;
#line 750
struct codec *register_flac(void) ;
#line 751
struct codec *register_pcm(void) ;
#line 752
struct codec *register_mad(void) ;
#line 753
struct codec *register_mpg(void) ;
#line 754
struct codec *register_vorbis(void) ;
#line 758
struct codec *register_faad(void) ;
#line 759
struct codec *register_dsd(void) ;
#line 760
struct codec *register_ff(char const   *codec ) ;
#line 199 "/usr/include/neaacdec.h"
char *NeAACDecGetErrorMessage(unsigned char errcode ) ;
#line 201
unsigned long NeAACDecGetCapabilities(void) ;
#line 203
NeAACDecHandle NeAACDecOpen(void) ;
#line 205
NeAACDecConfigurationPtr NeAACDecGetCurrentConfiguration(NeAACDecHandle hDecoder ) ;
#line 207
unsigned char NeAACDecSetConfiguration(NeAACDecHandle hDecoder , NeAACDecConfigurationPtr config ) ;
#line 211
long NeAACDecInit(NeAACDecHandle hDecoder , unsigned char *buffer , unsigned long buffer_size ,
                  unsigned long *samplerate , unsigned char *channels ) ;
#line 218
char NeAACDecInit2(NeAACDecHandle hDecoder , unsigned char *pBuffer , unsigned long SizeOfDecoderSpecificInfo ,
                   unsigned long *samplerate , unsigned char *channels ) ;
#line 225
char NeAACDecInitDRM(NeAACDecHandle *hDecoder , unsigned long samplerate , unsigned char channels ) ;
#line 228
void NeAACDecPostSeekReset(NeAACDecHandle hDecoder , long frame ) ;
#line 230
void NeAACDecClose(NeAACDecHandle hDecoder ) ;
#line 232
void *NeAACDecDecode(NeAACDecHandle hDecoder , NeAACDecFrameInfo *hInfo , unsigned char *buffer ,
                     unsigned long buffer_size ) ;
#line 237
void *NeAACDecDecode2(NeAACDecHandle hDecoder , NeAACDecFrameInfo *hInfo , unsigned char *buffer ,
                      unsigned long buffer_size , void **sample_buffer , unsigned long sample_buffer_size ) ;
#line 244
char NeAACDecAudioSpecificConfig(unsigned char *pBuffer , unsigned long buffer_size ,
                                 mp4AudioSpecificConfig *mp4ASC ) ;
#line 249
int NeAACDecGetVersion(char **faad_id_string , char **faad_copyright_string ) ;
#line 65 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static struct faad *a ;
#line 67
log_level loglevel ;
#line 69
struct buffer *streambuf ;
#line 70
struct buffer *outputbuf ;
#line 71
struct streamstate stream ;
#line 72
struct outputstate output ;
#line 73
struct decodestate decode ;
#line 74
extern struct processstate process ;
#line 101 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
u32_t mp4_desc_length(u8_t **buf___2 ) 
{ 
  u8_t b ;
  u8_t num_bytes ;
  u32_t length ;
  u8_t __cil_tmp5 ;

  {
#line 103
  num_bytes = (u8_t )0;
#line 104
  length = (u32_t )0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    b = *(*buf___2);
#line 108
    (*buf___2) ++;
#line 109
    num_bytes ++;
#line 110
    length = (length << 7) | (unsigned int )((int )b & 127);
#line 106
    if (! ((int )b & 128 && (int )num_bytes < 4)) {
#line 106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (length);
}
}
#line 117 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static int read_mp4_header(unsigned long *samplerate_p , unsigned char *channels_p ) 
{ 
  size_t bytes ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int tmp ;
  char type[5] ;
  u32_t len ;
  static unsigned int trak ;
  static unsigned int play ;
  u32_t consume ;
  u32_t __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned int config_len ;
  u8_t *ptr ;
  u8_t *__cil_tmp21 ;
  u8_t *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  u32_t __cil_tmp24 ;
  char __cil_tmp25 ;
  char const   *__cil_tmp26 ;
  int __cil_tmp27 ;
  u32_t i ;
  u8_t *ptr___0 ;
  u32_t entries ;
  u32_t __cil_tmp31 ;
  u32_t count ;
  u32_t __cil_tmp33 ;
  u32_t size ;
  u32_t __cil_tmp35 ;
  char const   *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  char const   *__cil_tmp39 ;
  int __cil_tmp40 ;
  u32_t i___0 ;
  u8_t *ptr___1 ;
  u32_t entries___0 ;
  u32_t __cil_tmp44 ;
  void *__cil_tmp45 ;
  char const   *__cil_tmp46 ;
  u32_t __cil_tmp47 ;
  u32_t stsc_entries ;
  u32_t __cil_tmp49 ;
  u32_t sample ;
  u32_t last ;
  u32_t last_samples ;
  u8_t *ptr___2 ;
  u32_t __cil_tmp54 ;
  u32_t first ;
  u32_t __cil_tmp56 ;
  u32_t samples ;
  u32_t __cil_tmp58 ;
  int __cil_tmp59 ;
  char const   *__cil_tmp60 ;
  u32_t skip ;
  char const   *__cil_tmp62 ;
  char const   *__cil_tmp63 ;
  int __cil_tmp64 ;
  u8_t *ptr___3 ;
  u32_t remain ;
  u32_t size___0 ;
  int __cil_tmp68 ;
  u32_t __cil_tmp69 ;
  int __cil_tmp70 ;
  u32_t __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  u32_t b ;
  u32_t c ;
  u64_t d ;
  int __cil_tmp77 ;
  char const   *__cil_tmp78 ;
  char const   *__cil_tmp79 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  char const   *__cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  char const   *__cil_tmp96 ;
  char const   *__cil_tmp97 ;

  {
  {
#line 118
  __cil_tmp5 = _buf_cont_read(streambuf);
  }
  {
#line 118
  __cil_tmp4 = _buf_used(streambuf);
  }
#line 118
  if (__cil_tmp4 < __cil_tmp5) {
    {
#line 118
    __cil_tmp6 = _buf_used(streambuf);
#line 118
    tmp = __cil_tmp6;
    }
  } else {
    {
#line 118
    __cil_tmp7 = _buf_cont_read(streambuf);
#line 118
    tmp = __cil_tmp7;
    }
  }
#line 118
  bytes = (size_t )tmp;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (bytes >= 8UL)) {
#line 122
      goto while_break;
    }
    {
#line 127
    len = unpackN((u32_t *)streambuf->readp);
#line 128
    memcpy((char *)type, streambuf->readp + 4, (unsigned long )4);
#line 129
    type[4] = (char )'\000';
#line 131
    __cil_tmp15 = strcmp((char const   *)((char *)type), "moov");
    }
#line 131
    if (! __cil_tmp15) {
#line 132
      trak = (unsigned int )0;
#line 133
      play = (unsigned int )0;
    }
    {
#line 135
    __cil_tmp16 = strcmp((char const   *)((char *)type), "trak");
    }
#line 135
    if (! __cil_tmp16) {
#line 136
      trak ++;
    }
    {
#line 140
    __cil_tmp18 = strcmp((char const   *)((char *)type), "esds");
    }
#line 140
    if (! __cil_tmp18) {
#line 140
      if (bytes > (unsigned long )len) {
#line 142
        ptr = streambuf->readp + 12;
#line 143
        __cil_tmp21 = ptr;
#line 143
        ptr ++;
#line 143
        if ((int )*__cil_tmp21 == 3) {
          {
#line 144
          mp4_desc_length(& ptr);
#line 145
          ptr += 4;
          }
        } else {
#line 147
          ptr += 3;
        }
        {
#line 149
        mp4_desc_length(& ptr);
#line 150
        ptr += 13;
#line 151
        __cil_tmp22 = ptr;
#line 151
        ptr ++;
        }
#line 151
        if ((int )*__cil_tmp22 != 5) {
#line 152
          if ((unsigned int )loglevel >= 1U) {
            {
#line 152
            __cil_tmp23 = logtime();
#line 152
            logprint("%s %s:%d error parsing esds\n", __cil_tmp23, "read_mp4_header",
                     152);
            }
          }
#line 153
          return (- 1);
        }
        {
#line 155
        config_len = mp4_desc_length(& ptr);
#line 156
        __cil_tmp25 = (*(a->NeAACDecInit2))(a->hAac, ptr, (unsigned long )config_len,
                                            samplerate_p, channels_p);
        }
#line 156
        if ((int )__cil_tmp25 == 0) {
#line 157
          if ((unsigned int )loglevel >= 3U) {
            {
#line 157
            __cil_tmp26 = logtime();
#line 157
            logprint("%s %s:%d playable aac track: %u\n\230", __cil_tmp26, "read_mp4_header",
                     157, trak);
            }
          }
#line 158
          play = trak;
        }
      }
    }
    {
#line 163
    __cil_tmp27 = strcmp((char const   *)((char *)type), "stts");
    }
#line 163
    if (! __cil_tmp27) {
#line 163
      if (bytes > (unsigned long )len) {
        {
#line 165
        ptr___0 = streambuf->readp + 12;
#line 166
        __cil_tmp31 = unpackN((u32_t *)ptr___0);
#line 166
        entries = __cil_tmp31;
#line 167
        ptr___0 += 4;
#line 168
        i = (u32_t )0;
        }
        {
#line 168
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 168
          if (! (i < entries)) {
#line 168
            goto while_break___0;
          }
          {
#line 169
          __cil_tmp33 = unpackN((u32_t *)ptr___0);
#line 169
          count = __cil_tmp33;
#line 170
          __cil_tmp35 = unpackN((u32_t *)(ptr___0 + 4));
#line 170
          size = __cil_tmp35;
#line 171
          a->sttssamples += (unsigned long )(count * size);
#line 172
          ptr___0 += 8;
          }
#line 168
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 174
        if ((unsigned int )loglevel >= 3U) {
          {
#line 174
          __cil_tmp36 = logtime();
#line 174
          logprint("%s %s:%d total number of samples contained in stts: %lu\n", __cil_tmp36,
                   "read_mp4_header", 174, a->sttssamples);
          }
        }
      }
    }
    {
#line 178
    __cil_tmp37 = strcmp((char const   *)((char *)type), "stsc");
    }
#line 178
    if (! a->chunkinfo) {
#line 178
      if (! __cil_tmp37) {
#line 178
        if (bytes > (unsigned long )len) {
          {
#line 179
          a->stsc = malloc((unsigned long )(len - 12U));
          }
#line 180
          if (a->stsc == (void *)0) {
#line 181
            if ((unsigned int )loglevel >= 1U) {
              {
#line 181
              __cil_tmp39 = logtime();
#line 181
              logprint("%s %s:%d malloc fail\n", __cil_tmp39, "read_mp4_header", 181);
              }
            }
#line 182
            return (- 1);
          }
          {
#line 184
          memcpy(a->stsc, streambuf->readp + 12, (unsigned long )(len - 12U));
          }
        }
      }
    }
    {
#line 188
    __cil_tmp40 = strcmp((char const   *)((char *)type), "stco");
    }
#line 188
    if (! __cil_tmp40) {
#line 188
      if (bytes > (unsigned long )len) {
#line 188
        if (play == trak) {
          {
#line 191
          ptr___1 = streambuf->readp + 12;
#line 192
          __cil_tmp44 = unpackN((u32_t *)ptr___1);
#line 192
          entries___0 = __cil_tmp44;
#line 193
          ptr___1 += 4;
#line 194
          a->chunkinfo = (struct chunk_table *)malloc(sizeof(struct chunk_table ) * (unsigned long )(entries___0 + 1U));
          }
#line 195
          if (a->chunkinfo == (void *)0) {
#line 196
            if ((unsigned int )loglevel >= 1U) {
              {
#line 196
              __cil_tmp46 = logtime();
#line 196
              logprint("%s %s:%d malloc fail\n", __cil_tmp46, "read_mp4_header", 196);
              }
            }
#line 197
            return (- 1);
          }
#line 199
          i___0 = (u32_t )0;
          {
#line 199
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 199
            if (! (i___0 < entries___0)) {
#line 199
              goto while_break___1;
            }
            {
#line 200
            (a->chunkinfo + i___0)->offset = unpackN((u32_t *)ptr___1);
#line 201
            (a->chunkinfo + i___0)->sample = (u32_t )0;
#line 202
            ptr___1 += 4;
            }
#line 199
            i___0 ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 204
          (a->chunkinfo + i___0)->sample = (u32_t )0;
#line 205
          (a->chunkinfo + i___0)->offset = (u32_t )0;
#line 207
          if (a->stsc) {
            {
#line 208
            __cil_tmp49 = unpackN((u32_t *)a->stsc);
#line 208
            stsc_entries = __cil_tmp49;
#line 209
            sample = (u32_t )0;
#line 210
            last = (u32_t )0;
            }
#line 210
            last_samples = (u32_t )0;
#line 211
            ptr___2 = (u8_t *)a->stsc + 4;
            {
#line 212
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 212
              __cil_tmp54 = stsc_entries;
#line 212
              stsc_entries --;
#line 212
              if (! __cil_tmp54) {
#line 212
                goto while_break___2;
              }
              {
#line 213
              __cil_tmp56 = unpackN((u32_t *)ptr___2);
#line 213
              first = __cil_tmp56;
#line 214
              __cil_tmp58 = unpackN((u32_t *)(ptr___2 + 4));
#line 214
              samples = __cil_tmp58;
              }
#line 215
              if (last) {
#line 216
                i___0 = last - 1U;
                {
#line 216
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 216
                  if (! (i___0 < first - 1U)) {
#line 216
                    goto while_break___3;
                  }
#line 217
                  (a->chunkinfo + i___0)->sample = sample;
#line 218
                  sample += last_samples;
#line 216
                  i___0 ++;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
#line 221
              if (stsc_entries == 0U) {
#line 222
                i___0 = first - 1U;
                {
#line 222
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 222
                  if (! (i___0 < entries___0)) {
#line 222
                    goto while_break___4;
                  }
#line 223
                  (a->chunkinfo + i___0)->sample = sample;
#line 224
                  sample += samples;
#line 222
                  i___0 ++;
                }
                while_break___4: /* CIL Label */ ;
                }
              }
#line 227
              last = first;
#line 228
              last_samples = samples;
#line 229
              ptr___2 += 12;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 231
            free(a->stsc);
#line 232
            a->stsc = (void *)0;
            }
          }
        }
      }
    }
    {
#line 237
    __cil_tmp59 = strcmp((char const   *)((char *)type), "mdat");
    }
#line 237
    if (! __cil_tmp59) {
      {
#line 238
      _buf_inc_readp(streambuf, (unsigned int )8);
#line 239
      a->pos += (unsigned int )8;
#line 240
      bytes -= (unsigned long )8;
      }
#line 241
      if (play) {
#line 242
        if ((unsigned int )loglevel >= 3U) {
          {
#line 242
          __cil_tmp60 = logtime();
#line 242
          logprint("%s %s:%d type: mdat len: %u pos: %u\n", __cil_tmp60, "read_mp4_header",
                   242, len, a->pos);
          }
        }
#line 243
        if (a->chunkinfo) {
#line 243
          if ((a->chunkinfo + 0)->offset > a->pos) {
#line 244
            skip = (a->chunkinfo + 0)->offset - a->pos;
#line 245
            if ((unsigned int )loglevel >= 3U) {
              {
#line 245
              __cil_tmp62 = logtime();
#line 245
              logprint("%s %s:%d skipping: %u\n", __cil_tmp62, "read_mp4_header",
                       245, skip);
              }
            }
#line 246
            if ((unsigned long )skip <= bytes) {
              {
#line 247
              _buf_inc_readp(streambuf, skip);
#line 248
              a->pos += skip;
              }
            } else {
#line 250
              a->consume = skip;
            }
          }
        }
#line 253
        a->nextchunk = (u32_t )1;
#line 253
        a->sample = a->nextchunk;
#line 254
        return (1);
      } else {
#line 256
        if ((unsigned int )loglevel >= 3U) {
          {
#line 256
          __cil_tmp63 = logtime();
#line 256
          logprint("%s %s:%d type: mdat len: %u, no playable track found\n", __cil_tmp63,
                   "read_mp4_header", 256, len);
          }
        }
#line 257
        return (- 1);
      }
    }
    {
#line 262
    __cil_tmp64 = strcmp((char const   *)((char *)type), "----");
    }
#line 262
    if (! __cil_tmp64) {
#line 262
      if (bytes > (unsigned long )len) {
        {
#line 263
        ptr___3 = streambuf->readp + 8;
#line 264
        remain = len - 8U;
#line 265
        size___0 = unpackN((u32_t *)ptr___3);
        }
        {
#line 265
        __cil_tmp68 = memcmp(ptr___3 + 4, "mean", (unsigned long )4);
        }
#line 265
        if (! __cil_tmp68) {
#line 265
          if (size___0 < remain) {
#line 266
            ptr___3 += size___0;
#line 266
            remain -= size___0;
          }
        }
        {
#line 268
        __cil_tmp72 = memcmp(ptr___3 + 12, "iTunSMPB\251", (unsigned long )8);
        }
        {
#line 268
        size___0 = unpackN((u32_t *)ptr___3);
        }
        {
#line 268
        __cil_tmp70 = memcmp(ptr___3 + 4, "name", (unsigned long )4);
        }
#line 268
        if (! __cil_tmp70) {
#line 268
          if (size___0 < remain) {
#line 268
            if (! __cil_tmp72) {
#line 269
              ptr___3 += size___0;
#line 269
              remain -= size___0;
            }
          }
        }
        {
#line 271
        __cil_tmp73 = memcmp(ptr___3 + 4, "data", (unsigned long )4);
        }
#line 271
        if (! __cil_tmp73) {
#line 271
          if (remain > 64U) {
            {
#line 274
            __cil_tmp77 = sscanf((char const   *)(ptr___3 + 16), "%x %x %x %lx\230\001",
                                 & b, & b, & c, & d);
            }
#line 274
            if (__cil_tmp77 == 4) {
#line 275
              if ((unsigned int )loglevel >= 3U) {
                {
#line 275
                __cil_tmp78 = logtime();
#line 275
                logprint("%s %s:%d iTunSMPB start: %u end: %u samples: %lu\n", __cil_tmp78,
                         "read_mp4_header", 275, b, c, d);
                }
              }
#line 276
              if (a->sttssamples) {
#line 276
                if (a->sttssamples < (unsigned long )(b + c) + d) {
#line 277
                  if ((unsigned int )loglevel >= 3U) {
                    {
#line 277
                    __cil_tmp79 = logtime();
#line 277
                    logprint("%s %s:%d reducing samples as stts count is less\n\230",
                             __cil_tmp79, "read_mp4_header", 277);
                    }
                  }
#line 278
                  d = a->sttssamples - (unsigned long )(b + c);
                }
              }
#line 280
              a->skip = b;
#line 281
              a->samples = d;
            }
          }
        }
      }
    }
    {
#line 287
    consume = len;
#line 290
    __cil_tmp86 = strcmp((char const   *)((char *)type), "ilst");
    }
    {
#line 290
    __cil_tmp85 = strcmp((char const   *)((char *)type), "udta");
    }
    {
#line 290
    __cil_tmp84 = strcmp((char const   *)((char *)type), "stbl");
    }
    {
#line 290
    __cil_tmp83 = strcmp((char const   *)((char *)type), "minf");
    }
    {
#line 290
    __cil_tmp82 = strcmp((char const   *)((char *)type), "mdia");
    }
    {
#line 290
    __cil_tmp81 = strcmp((char const   *)((char *)type), "trak");
    }
    {
#line 290
    __cil_tmp80 = strcmp((char const   *)((char *)type), "moov");
    }
#line 290
    if (! __cil_tmp80) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp81) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp82) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp83) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp84) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp85) {
#line 292
      consume = (u32_t )8;
    } else
#line 290
    if (! __cil_tmp86) {
#line 292
      consume = (u32_t )8;
    }
    {
#line 295
    __cil_tmp87 = strcmp((char const   *)((char *)type), "stsd");
    }
#line 295
    if (! __cil_tmp87) {
#line 295
      consume = (u32_t )16;
    }
    {
#line 296
    __cil_tmp88 = strcmp((char const   *)((char *)type), "mp4a");
    }
#line 296
    if (! __cil_tmp88) {
#line 296
      consume = (u32_t )36;
    }
    {
#line 297
    __cil_tmp89 = strcmp((char const   *)((char *)type), "meta");
    }
#line 297
    if (! __cil_tmp89) {
#line 297
      consume = (u32_t )12;
    }
#line 300
    if (bytes >= (unsigned long )consume) {
#line 301
      if ((unsigned int )loglevel >= 3U) {
        {
#line 301
        __cil_tmp90 = logtime();
#line 301
        logprint("%s %s:%d type: %s len: %u consume: %u\n", __cil_tmp90, "read_mp4_header",
                 301, (char *)type, len, consume);
        }
      }
      {
#line 302
      _buf_inc_readp(streambuf, consume);
#line 303
      a->pos += consume;
#line 304
      bytes -= (unsigned long )consume;
      }
    } else {
      {
#line 305
      __cil_tmp95 = strcmp((char const   *)((char *)type), "----");
      }
      {
#line 305
      __cil_tmp94 = strcmp((char const   *)((char *)type), "stco");
      }
      {
#line 305
      __cil_tmp93 = strcmp((char const   *)((char *)type), "stsc");
      }
      {
#line 305
      __cil_tmp92 = strcmp((char const   *)((char *)type), "stts");
      }
      {
#line 305
      __cil_tmp91 = strcmp((char const   *)((char *)type), "esds");
      }
#line 305
      if (! ((((! __cil_tmp91 || ! __cil_tmp92) || ! __cil_tmp93) || ! __cil_tmp94) || ! __cil_tmp95)) {
#line 307
        if ((unsigned int )loglevel >= 3U) {
          {
#line 307
          __cil_tmp96 = logtime();
#line 307
          logprint("%s %s:%d type: %s len: %u consume: %u - partial consume: %u\n",
                   __cil_tmp96, "read_mp4_header", 307, (char *)type, len, consume,
                   bytes);
          }
        }
        {
#line 308
        _buf_inc_readp(streambuf, (unsigned int )bytes);
#line 309
        a->pos += bytes;
#line 310
        a->consume = (u32_t )((unsigned long )consume - bytes);
        }
#line 311
        goto while_break;
      } else
#line 312
      if ((unsigned long )len > streambuf->size) {
        {
#line 314
        __cil_tmp97 = logtime();
#line 314
        logprint("%s %s:%d atom %s too large for buffer %u %u\n", __cil_tmp97, "read_mp4_header",
                 314, (char *)type, len, streambuf->size);
        }
#line 315
        return (- 1);
      } else {
        {
#line 318
        _buf_unwrap(streambuf, (size_t )len);
        }
#line 319
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return (0);
}
}
#line 326 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static decode_state faad_decode(void) 
{ 
  size_t bytes_total ;
  size_t bytes_wrap ;
  static NeAACDecFrameInfo info ;
  s32_t *iptr ;
  int endstream ;
  frames_t frames ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  size_t tmp ;
  u32_t consume ;
  unsigned long tmp___0 ;
  char const   *__cil_tmp13 ;
  int found ;
  static unsigned char channels___0 ;
  static unsigned long samplerate ;
  size_t __cil_tmp17 ;
  size_t __cil_tmp18 ;
  long n ;
  long __cil_tmp20 ;
  int __cil_tmp21 ;
  char const   *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  size_t tmp___1 ;
  char const   *__cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  char const   *__cil_tmp29 ;
  static u8_t buf___2[2048] ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char const   *__cil_tmp33 ;
  char *__cil_tmp34 ;
  u32_t __cil_tmp35 ;
  u32_t skip ;
  char const   *__cil_tmp37 ;
  u32_t __cil_tmp38 ;
  char const   *__cil_tmp39 ;
  char const   *__cil_tmp40 ;
  u32_t skip___0 ;
  char const   *__cil_tmp42 ;
  frames_t tmp___2 ;
  char const   *__cil_tmp44 ;
  char const   *__cil_tmp45 ;
  char const   *__cil_tmp46 ;
  frames_t f___0 ;
  frames_t count ;
  s32_t *optr ;
  unsigned int __cil_tmp50 ;
  frames_t tmp___3 ;
  frames_t __cil_tmp52 ;
  s32_t *__cil_tmp53 ;
  s32_t *__cil_tmp54 ;
  s32_t *__cil_tmp55 ;
  s32_t *__cil_tmp56 ;
  frames_t __cil_tmp57 ;
  s32_t *__cil_tmp58 ;
  s32_t *__cil_tmp59 ;
  s32_t *__cil_tmp60 ;
  char const   *__cil_tmp61 ;

  {
  {
#line 334
  pthread_mutex_lock(& streambuf->mutex);
#line 335
  __cil_tmp7 = _buf_used(streambuf);
#line 335
  bytes_total = (size_t )__cil_tmp7;
#line 336
  __cil_tmp8 = _buf_cont_read(streambuf);
  }
#line 336
  if (bytes_total < (unsigned long )__cil_tmp8) {
#line 336
    tmp = bytes_total;
  } else {
    {
#line 336
    __cil_tmp9 = _buf_cont_read(streambuf);
#line 336
    tmp = (unsigned long )__cil_tmp9;
    }
  }
#line 336
  bytes_wrap = tmp;
#line 338
  if ((unsigned int )stream.state <= 1U) {
#line 338
    if (! bytes_total) {
      {
#line 339
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 340
      return ((decode_state )3);
    }
  }
#line 343
  if (a->consume) {
#line 344
    if ((unsigned long )a->consume < bytes_wrap) {
#line 344
      tmp___0 = (unsigned long )a->consume;
    } else {
#line 344
      tmp___0 = bytes_wrap;
    }
#line 344
    consume = (u32_t )tmp___0;
#line 345
    if ((unsigned int )loglevel >= 3U) {
      {
#line 345
      __cil_tmp13 = logtime();
#line 345
      logprint("%s %s:%d consume: %u of %u\n", __cil_tmp13, "faad_decode", 345, consume,
               a->consume);
      }
    }
    {
#line 346
    _buf_inc_readp(streambuf, consume);
#line 347
    a->pos += consume;
#line 348
    a->consume -= consume;
#line 349
    pthread_mutex_unlock(& streambuf->mutex);
    }
#line 350
    return ((decode_state )2);
  }
#line 353
  if (decode.new_stream) {
#line 354
    found = 0;
#line 358
    if ((int )a->type == 50) {
      {
#line 361
      while (1) {
        while_continue: /* CIL Label */ ;
#line 361
        if (! (bytes_wrap >= 2UL && ((int )*(streambuf->readp) != 255 || ((int )*(streambuf->readp + 1) & 246) != 240))) {
#line 361
          goto while_break;
        }
        {
#line 362
        _buf_inc_readp(streambuf, (unsigned int )1);
#line 363
        __cil_tmp17 = bytes_total;
#line 363
        bytes_total --;
#line 364
        __cil_tmp18 = bytes_wrap;
#line 364
        bytes_wrap --;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 367
      if (bytes_wrap >= 2UL) {
        {
#line 368
        __cil_tmp20 = (*(a->NeAACDecInit))(a->hAac, streambuf->readp, bytes_wrap,
                                           & samplerate, & channels___0);
#line 368
        n = __cil_tmp20;
        }
#line 369
        if (n < 0L) {
#line 370
          found = - 1;
        } else {
          {
#line 372
          _buf_inc_readp(streambuf, (unsigned int )n);
#line 373
          found = 1;
          }
        }
      }
    } else {
      {
#line 380
      found = read_mp4_header(& samplerate, & channels___0);
      }
    }
#line 383
    if (found == 1) {
#line 385
      if ((unsigned int )loglevel >= 2U) {
        {
#line 385
        __cil_tmp22 = logtime();
#line 385
        logprint("%s %s:%d samplerate: %u channels: %u\nU", __cil_tmp22, "faad_decodee\301U",
                 385, samplerate, (int )channels___0);
        }
      }
      {
#line 386
      __cil_tmp23 = _buf_used(streambuf);
#line 386
      bytes_total = (size_t )__cil_tmp23;
#line 387
      __cil_tmp24 = _buf_cont_read(streambuf);
      }
#line 387
      if (bytes_total < (unsigned long )__cil_tmp24) {
#line 387
        tmp___1 = bytes_total;
      } else {
        {
#line 387
        __cil_tmp25 = _buf_cont_read(streambuf);
#line 387
        tmp___1 = (unsigned long )__cil_tmp25;
        }
      }
      {
#line 387
      bytes_wrap = tmp___1;
#line 389
      pthread_mutex_lock(& outputbuf->mutex);
      }
#line 390
      if ((unsigned int )loglevel >= 2U) {
        {
#line 390
        __cil_tmp27 = logtime();
#line 390
        logprint("%s %s:%d setting track_start\n", __cil_tmp27, "faad_decode", 390);
        }
      }
      {
#line 391
      output.next_sample_rate = decode_newstream((unsigned int )samplerate, (unsigned int *)output.supported_rates);
#line 393
      output.track_start = outputbuf->writep;
      }
#line 394
      if (output.fade_mode) {
        {
#line 394
        _checkfade(1);
        }
      }
      {
#line 395
      decode.new_stream = 0;
#line 396
      pthread_mutex_unlock(& outputbuf->mutex);
      }
    } else
#line 398
    if (found == -1) {
#line 400
      if ((unsigned int )loglevel >= 1U) {
        {
#line 400
        __cil_tmp29 = logtime();
#line 400
        logprint("%s %s:%d error reading stream header\n", __cil_tmp29, "faad_decodee\301U",
                 400);
        }
      }
      {
#line 401
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 402
      return ((decode_state )4);
    } else {
      {
#line 407
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 408
      return ((decode_state )2);
    }
  }
#line 412
  if (bytes_wrap < 2048UL) {
#line 412
    if (bytes_total > 2048UL) {
      {
#line 416
      memcpy((u8_t *)buf___2, streambuf->readp, bytes_wrap);
#line 417
      memcpy((u8_t *)buf___2 + bytes_wrap, streambuf->buf, 2048UL - bytes_wrap);
#line 419
      iptr = (s32_t *)(*(a->NeAACDecDecode))(a->hAac, & info, (u8_t *)buf___2, (unsigned long )2048);
      }
    } else {
      {
      {
#line 423
      iptr = (s32_t *)(*(a->NeAACDecDecode))(a->hAac, & info, streambuf->readp, bytes_wrap);
      }
      }
    }
  } else {
    {
    {
#line 423
    iptr = (s32_t *)(*(a->NeAACDecDecode))(a->hAac, & info, streambuf->readp, bytes_wrap);
    }
    }
  }
#line 426
  if (info.error) {
#line 427
    if ((unsigned int )loglevel >= 1U) {
      {
#line 427
      __cil_tmp33 = logtime();
      }
      {
#line 427
      __cil_tmp34 = (*(a->NeAACDecGetErrorMessage))(info.error);
#line 427
      logprint("%s %s:%d error: %u %s\n", __cil_tmp33, "faad_decode", 427, (int )info.error,
               __cil_tmp34);
      }
    }
  }
#line 430
  endstream = 0;
#line 433
  __cil_tmp35 = a->sample;
#line 433
  (a->sample) ++;
#line 433
  if (a->chunkinfo) {
#line 433
    if ((a->chunkinfo + a->nextchunk)->offset) {
#line 433
      if (__cil_tmp35 == (a->chunkinfo + a->nextchunk)->sample) {
#line 435
        if ((a->chunkinfo + a->nextchunk)->offset > a->pos) {
#line 436
          skip = (a->chunkinfo + a->nextchunk)->offset - a->pos;
#line 437
          if ((unsigned long )skip != info.bytesconsumed) {
#line 438
            if ((unsigned int )loglevel >= 3U) {
              {
#line 438
              __cil_tmp37 = logtime();
#line 438
              logprint("%s %s:%d skipping to next chunk pos: %u consumed: %u != skip: %u\nA\230e\301U",
                       __cil_tmp37, "faad_decode", 438, a->pos, info.bytesconsumed,
                       skip);
              }
            }
          }
#line 440
          if (bytes_total >= (unsigned long )skip) {
            {
#line 441
            _buf_inc_readp(streambuf, skip);
#line 442
            a->pos += skip;
            }
          } else {
#line 444
            a->consume = skip;
          }
#line 446
          (a->nextchunk) ++;
        } else {
          {
#line 448
          __cil_tmp39 = logtime();
#line 448
          logprint("%s %s:%d error: need to skip backwards!\n\230", __cil_tmp39, "faad_decodee\301U",
                   448);
#line 449
          endstream = 1;
          }
        }
      } else {
#line 433
        goto _L;
      }
    } else {
#line 433
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  _L___1: /* CIL Label */ 
#line 453
  if (info.bytesconsumed != 0UL) {
    {
#line 455
    _buf_inc_readp(streambuf, (unsigned int )info.bytesconsumed);
#line 456
    a->pos += info.bytesconsumed;
    }
  } else {
#line 460
    endstream = 1;
  }
  {
#line 463
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 465
  if (endstream) {
#line 466
    if ((unsigned int )loglevel >= 1U) {
      {
#line 466
      __cil_tmp40 = logtime();
#line 466
      logprint("%s %s:%d unable to decode further\n\227e\301U", __cil_tmp40, "faad_decode",
               466);
      }
    }
#line 467
    return ((decode_state )4);
  }
#line 470
  if (! info.samples) {
#line 471
    a->empty = 1;
#line 472
    return ((decode_state )2);
  }
#line 475
  frames = (frames_t )(info.samples / (unsigned long )info.channels);
#line 477
  if (a->skip) {
#line 479
    if (a->empty) {
#line 480
      a->empty = 0;
#line 481
      a->skip -= frames;
#line 482
      if ((unsigned int )loglevel >= 3U) {
        {
#line 482
        __cil_tmp42 = logtime();
#line 482
        logprint("%s %s:%d gapless: first frame empty, skipped %u frames at start\n\230",
                 __cil_tmp42, "faad_decodee\301U", 482, frames);
        }
      }
    }
#line 484
    if (frames < a->skip) {
#line 484
      tmp___2 = frames;
    } else {
#line 484
      tmp___2 = a->skip;
    }
#line 484
    skip___0 = tmp___2;
#line 485
    if ((unsigned int )loglevel >= 3U) {
      {
#line 485
      __cil_tmp44 = logtime();
#line 485
      logprint("%s %s:%d gapless: skipping %u frames at start\n", __cil_tmp44, "faad_decode",
               485, skip___0);
      }
    }
#line 486
    frames -= skip___0;
#line 487
    a->skip -= skip___0;
#line 488
    iptr += skip___0 * (unsigned int )info.channels;
  }
#line 491
  if (a->samples) {
#line 492
    if (a->samples < (unsigned long )frames) {
#line 493
      if ((unsigned int )loglevel >= 3U) {
        {
#line 493
        __cil_tmp45 = logtime();
#line 493
        logprint("%s %s:%d gapless: trimming %u frames from end\n", __cil_tmp45, "faad_decodee\301U",
                 493, (unsigned long )frames - a->samples);
        }
      }
#line 494
      frames = (frames_t )a->samples;
    }
#line 496
    a->samples -= (unsigned long )frames;
  }
#line 499
  if ((unsigned int )loglevel >= 4U) {
    {
#line 499
    __cil_tmp46 = logtime();
#line 499
    logprint("%s %s:%d write %u frames\n\230\227e\301U", __cil_tmp46, "faad_decodee\301U",
             499, frames);
    }
  }
  {
#line 501
  pthread_mutex_lock(& outputbuf->mutex);
  }
  {
#line 503
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 503
    if (! (frames > 0U)) {
#line 503
      goto while_break___0;
    }
    {
#line 508
    __cil_tmp50 = _buf_cont_write(outputbuf);
#line 508
    f___0 = __cil_tmp50 / 8U;
#line 508
    optr = (s32_t *)outputbuf->writep;
    }
#line 517
    if (f___0 < frames) {
#line 517
      tmp___3 = f___0;
    } else {
#line 517
      tmp___3 = frames;
    }
#line 517
    f___0 = tmp___3;
#line 518
    count = f___0;
#line 520
    if ((int )info.channels == 2) {
      {
#line 525
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 525
        __cil_tmp52 = count;
#line 525
        count --;
#line 525
        if (! __cil_tmp52) {
#line 525
          goto while_break___1;
        }
#line 526
        __cil_tmp54 = iptr;
#line 526
        iptr ++;
#line 526
        __cil_tmp53 = optr;
#line 526
        optr ++;
#line 526
        *__cil_tmp53 = *__cil_tmp54 << 8;
#line 527
        __cil_tmp56 = iptr;
#line 527
        iptr ++;
#line 527
        __cil_tmp55 = optr;
#line 527
        optr ++;
#line 527
        *__cil_tmp55 = *__cil_tmp56 << 8;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 530
    if ((int )info.channels == 1) {
      {
#line 531
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 531
        __cil_tmp57 = count;
#line 531
        count --;
#line 531
        if (! __cil_tmp57) {
#line 531
          goto while_break___2;
        }
#line 532
        __cil_tmp58 = optr;
#line 532
        optr ++;
#line 532
        *__cil_tmp58 = *iptr << 8;
#line 533
        __cil_tmp60 = iptr;
#line 533
        iptr ++;
#line 533
        __cil_tmp59 = optr;
#line 533
        optr ++;
#line 533
        *__cil_tmp59 = *__cil_tmp60 << 8;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 536
    if ((unsigned int )loglevel >= 1U) {
      {
#line 536
      __cil_tmp61 = logtime();
#line 536
      logprint("%s %s:%d unsupported number of channels\n\230", __cil_tmp61, "faad_decodee\301U",
               536);
      }
    }
    {
#line 539
    frames -= f___0;
#line 541
    _buf_inc_writep(outputbuf, f___0 * 8U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 550
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 552
  return ((decode_state )2);
}
}
#line 555 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static void faad_open(u8_t size , u8_t rate , u8_t chan , u8_t endianness ) 
{ 
  NeAACDecConfigurationPtr conf ;
  char const   *__cil_tmp6 ;
  char const   *tmp ;
  NeAACDecHandle __cil_tmp8 ;
  NeAACDecConfigurationPtr __cil_tmp9 ;
  unsigned char __cil_tmp10 ;
  char const   *__cil_tmp11 ;

  {
#line 558
  if ((unsigned int )loglevel >= 2U) {
    {
#line 558
    __cil_tmp6 = logtime();
    }
#line 558
    if ((int )size == 50) {
#line 558
      tmp = "adts";
    } else {
#line 558
      tmp = "mp4";
    }
    {
#line 558
    logprint("%s %s:%d opening %s stream\ne\301U", __cil_tmp6, "faad_open", 558, tmp);
    }
  }
#line 560
  a->type = size;
#line 561
  a->nextchunk = (u32_t )0;
#line 561
  a->sample = a->nextchunk;
#line 561
  a->consume = a->sample;
#line 561
  a->pos = a->consume;
#line 563
  if (a->chunkinfo) {
    {
#line 564
    free(a->chunkinfo);
    }
  }
#line 566
  if (a->stsc) {
    {
#line 567
    free(a->stsc);
    }
  }
#line 569
  a->chunkinfo = (struct chunk_table *)((void *)0);
#line 570
  a->stsc = (void *)0;
#line 571
  a->skip = (u32_t )0;
#line 572
  a->samples = (u64_t )0;
#line 573
  a->sttssamples = (u64_t )0;
#line 574
  a->empty = 0;
#line 576
  if (a->hAac) {
    {
#line 577
    (*(a->NeAACDecClose))(a->hAac);
    }
  }
  {
#line 579
  a->hAac = (*(a->NeAACDecOpen))();
#line 581
  conf = (*(a->NeAACDecGetCurrentConfiguration))(a->hAac);
#line 586
  conf->outputFormat = (unsigned char )2;
#line 588
  conf->defSampleRate = (unsigned long )44100;
#line 589
  conf->downMatrix = (unsigned char )1;
#line 591
  __cil_tmp10 = (*(a->NeAACDecSetConfiguration))(a->hAac, conf);
  }
#line 591
  if (! __cil_tmp10) {
#line 592
    if ((unsigned int )loglevel >= 1U) {
      {
#line 592
      __cil_tmp11 = logtime();
#line 592
      logprint("%s %s:%d error setting config\n", __cil_tmp11, "faad_open\245\230e\301U",
               592);
      }
    }
  }

  return;
}
}
#line 596 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static void faad_close(void) 
{ 


  {
  {
#line 597
  (*(a->NeAACDecClose))(a->hAac);
#line 598
  a->hAac = (void *)0;
  }
#line 599
  if (a->chunkinfo) {
    {
#line 600
    free(a->chunkinfo);
#line 601
    a->chunkinfo = (struct chunk_table *)((void *)0);
    }
  }
#line 603
  if (a->stsc) {
    {
#line 604
    free(a->stsc);
#line 605
    a->stsc = (void *)0;
    }
  }
  return;
}
}
#line 609 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
static int load_faad(void) 
{ 
  void *handle ;
  void *__cil_tmp2 ;
  char *err ;
  char const   *__cil_tmp4 ;
  char *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char const   *__cil_tmp16 ;

  {
  {
#line 611
  __cil_tmp2 = dlopen("libfaad.so.2\301U", 2);
#line 611
  handle = __cil_tmp2;
  }
#line 614
  if (! handle) {
#line 615
    if ((unsigned int )loglevel >= 2U) {
      {
#line 615
      __cil_tmp4 = logtime();
      }
      {
#line 615
      __cil_tmp5 = dlerror();
#line 615
      logprint("%s %s:%d dlerror: %s\n", __cil_tmp4, "load_faad", 615, __cil_tmp5);
      }
    }
#line 616
    return (0);
  }
  {
#line 619
  a->NeAACDecGetCurrentConfiguration = (NeAACDecConfigurationPtr (*)(NeAACDecHandle  ))dlsym(handle,
                                                                                             "NeAACDecGetCurrentConfiguration");
#line 620
  a->NeAACDecSetConfiguration = (unsigned char (*)(NeAACDecHandle  , NeAACDecConfigurationPtr  ))dlsym(handle,
                                                                                                       "NeAACDecSetConfiguration\220");
#line 621
  a->NeAACDecOpen = (NeAACDecHandle (*)(void))dlsym(handle, "NeAACDecOpen\301U");
#line 622
  a->NeAACDecClose = (void (*)(NeAACDecHandle  ))dlsym(handle, "NeAACDecClose");
#line 623
  a->NeAACDecInit = (long (*)(NeAACDecHandle  , unsigned char * , unsigned long  ,
                              unsigned long * , unsigned char * ))dlsym(handle, "NeAACDecInit");
#line 624
  a->NeAACDecInit2 = (char (*)(NeAACDecHandle  , unsigned char * , unsigned long  ,
                               unsigned long * , unsigned char * ))dlsym(handle, "NeAACDecInit2U");
#line 625
  a->NeAACDecDecode = (void *(*)(NeAACDecHandle  , NeAACDecFrameInfo * , unsigned char * ,
                                 unsigned long  ))dlsym(handle, "NeAACDecDecode");
#line 626
  a->NeAACDecGetErrorMessage = (char *(*)(unsigned char  ))dlsym(handle, "NeAACDecGetErrorMessage");
#line 628
  err = dlerror();
  }
#line 628
  if (err != (void *)0) {
#line 629
    if ((unsigned int )loglevel >= 2U) {
      {
#line 629
      __cil_tmp15 = logtime();
#line 629
      logprint("%s %s:%d dlerror: %s\nU", __cil_tmp15, "load_faad\310\230e\301U",
               629, err);
      }
    }
#line 630
    return (0);
  }
#line 633
  if ((unsigned int )loglevel >= 2U) {
    {
#line 633
    __cil_tmp16 = logtime();
#line 633
    logprint("%s %s:%d loaded libfaad.so.2\n", __cil_tmp16, "load_faad", 633);
    }
  }
#line 636
  return (1);
}
}
#line 639 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/faad.c"
struct codec *register_faad(void) 
{ 
  static struct codec ret ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
#line 640
  ret.id = (char )'a';
#line 640
  ret.types = "aace\301U";
#line 640
  ret.min_read_bytes = (unsigned int )2048;
#line 640
  ret.min_space = (unsigned int )20480;
#line 640
  ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& faad_open);
#line 640
  ret.close = (void (*)(void))(& faad_close);
  {
#line 640
  ret.decode = (enum __anonenum__74 (*)(void))(& faad_decode);
#line 650
  a = (struct faad *)malloc(sizeof(struct faad ));
  }
#line 651
  if (! a) {
#line 652
    return ((struct codec *)((void *)0));
  }
  {
#line 655
  a->hAac = (void *)0;
#line 656
  a->chunkinfo = (struct chunk_table *)((void *)0);
#line 657
  a->stsc = (void *)0;
#line 659
  __cil_tmp3 = load_faad();
  }
#line 659
  if (! __cil_tmp3) {
#line 660
    return ((struct codec *)((void *)0));
  }
#line 663
  if ((unsigned int )loglevel >= 2U) {
    {
#line 663
    __cil_tmp4 = logtime();
#line 663
    logprint("%s %s:%d using faad to decode aac\n", __cil_tmp4, "register_faad", 663);
    }
  }
#line 664
  return (& ret);
}
}
#line 190 "/usr/include/mpg123.h"
int mpg123_init(void) ;
#line 197
void mpg123_exit(void) ;
#line 207
mpg123_handle *mpg123_new(char const   *decoder , int *error ) ;
#line 212
void mpg123_delete(mpg123_handle *mh ) ;
#line 219
void mpg123_free(void *ptr ) ;
#line 348
int mpg123_param2(mpg123_handle *mh , int type , long value , double fvalue ) ;
#line 378
int mpg123_getparam2(mpg123_handle *mh , int type , long *value , double *fvalue ) ;
#line 424
int mpg123_feature2(int key ) ;
#line 518
char const   *mpg123_plain_strerror(int errcode ) ;
#line 527
char const   *mpg123_strerror(mpg123_handle *mh ) ;
#line 533
int mpg123_errcode(mpg123_handle *mh ) ;
#line 549
char const   **mpg123_decoders(void) ;
#line 558
char const   **mpg123_supported_decoders(void) ;
#line 565
int mpg123_decoder(mpg123_handle *mh , char const   *decoder_name ) ;
#line 576
char const   *mpg123_current_decoder(mpg123_handle *mh ) ;
#line 617
void mpg123_rates(long const   **list , size_t *number ) ;
#line 623
void mpg123_encodings(int const   **list , size_t *number ) ;
#line 628
int mpg123_encsize(int encoding ) ;
#line 635
int mpg123_format_none(mpg123_handle *mh ) ;
#line 642
int mpg123_format_all(mpg123_handle *mh ) ;
#line 650
int mpg123_format(mpg123_handle *mh , long rate , int channels , int encodings ) ;
#line 663
int mpg123_format2(mpg123_handle *mh , long rate , int channels , int encodings ) ;
#line 673
int mpg123_format_support(mpg123_handle *mh , long rate , int encoding ) ;
#line 687
int mpg123_getformat(mpg123_handle *mh , long *rate , int *channels , int *encoding ) ;
#line 701
int mpg123_getformat2(mpg123_handle *mh , long *rate , int *channels , int *encoding ,
                      int clear_flag ) ;
#line 757
int mpg123_open_fixed(mpg123_handle *mh , char const   *path , int channels , int encoding ) ;
#line 775
int mpg123_open(mpg123_handle *mh , char const   *path ) ;
#line 783
int mpg123_open_fd(mpg123_handle *mh , int fd ) ;
#line 792
int mpg123_open_handle(mpg123_handle *mh , void *iohandle ) ;
#line 801
int mpg123_open_feed(mpg123_handle *mh ) ;
#line 807
int mpg123_close(mpg123_handle *mh ) ;
#line 820
int mpg123_read(mpg123_handle *mh , void *outmemory , size_t outmemsize , size_t *done ) ;
#line 830
int mpg123_feed(mpg123_handle *mh , unsigned char const   *in , size_t size ) ;
#line 852
int mpg123_decode(mpg123_handle *mh , unsigned char const   *inmemory , size_t inmemsize ,
                  void *outmemory , size_t outmemsize , size_t *done ) ;
#line 864
int mpg123_decode_frame(mpg123_handle *mh , off_t *num , unsigned char **audio , size_t *bytes ) ;
#line 876
int mpg123_framebyframe_decode(mpg123_handle *mh , off_t *num , unsigned char **audio ,
                               size_t *bytes ) ;
#line 885
int mpg123_framebyframe_next(mpg123_handle *mh ) ;
#line 902
int mpg123_framedata(mpg123_handle *mh , unsigned long *header , unsigned char **bodydata ,
                     size_t *bodybytes ) ;
#line 912
off_t mpg123_framepos(mpg123_handle *mh ) ;
#line 964
off_t mpg123_tell(mpg123_handle *mh ) ;
#line 970
off_t mpg123_tellframe(mpg123_handle *mh ) ;
#line 976
off_t mpg123_tell_stream(mpg123_handle *mh ) ;
#line 985
off_t mpg123_seek(mpg123_handle *mh , off_t sampleoff , int whence ) ;
#line 998
off_t mpg123_feedseek(mpg123_handle *mh , off_t sampleoff , int whence , off_t *input_offset ) ;
#line 1007
off_t mpg123_seek_frame(mpg123_handle *mh , off_t frameoff , int whence ) ;
#line 1013
off_t mpg123_timeframe(mpg123_handle *mh , double sec ) ;
#line 1024
int mpg123_index(mpg123_handle *mh , off_t **offsets , off_t *step , size_t *fill ) ;
#line 1036
int mpg123_set_index(mpg123_handle *mh , off_t *offsets , off_t step , size_t fill ) ;
#line 1046
int mpg123_position(mpg123_handle *mh , off_t frame_offset , off_t buffered_bytes ,
                    off_t *current_frame , off_t *frames_left , double *current_seconds ,
                    double *seconds_left ) ;
#line 1093
int mpg123_eq2(mpg123_handle *mh , int channel , int band , double val ) ;
#line 1121
double mpg123_geteq2(mpg123_handle *mh , int channel , int band ) ;
#line 1127
int mpg123_reset_eq(mpg123_handle *mh ) ;
#line 1135
int mpg123_volume(mpg123_handle *mh , double vol ) ;
#line 1142
int mpg123_volume_change(mpg123_handle *mh , double change ) ;
#line 1154
int mpg123_getvolume(mpg123_handle *mh , double *base , double *really , double *rva_db ) ;
#line 1281
int mpg123_info2(mpg123_handle *mh , struct mpg123_frameinfo2 *mi ) ;
#line 1289
int mpg123_set_moreinfo(mpg123_handle *mh , struct mpg123_moreinfo *mi ) ;
#line 1296
size_t mpg123_safe_buffer(void) ;
#line 1305
int mpg123_scan(mpg123_handle *mh ) ;
#line 1312
off_t mpg123_framelength(mpg123_handle *mh ) ;
#line 1326
off_t mpg123_length(mpg123_handle *mh ) ;
#line 1334
int mpg123_set_filesize(mpg123_handle *mh , off_t size ) ;
#line 1340
double mpg123_tpf(mpg123_handle *mh ) ;
#line 1346
int mpg123_spf(mpg123_handle *mh ) ;
#line 1352
long mpg123_clip(mpg123_handle *mh ) ;
#line 1394
int mpg123_getstate2(mpg123_handle *mh , int key , long *val , double *fval ) ;
#line 1420
mpg123_string *mpg123_new_string(char const   *val ) ;
#line 1425
void mpg123_delete_string(mpg123_string *sb ) ;
#line 1432
void mpg123_init_string(mpg123_string *sb ) ;
#line 1439
void mpg123_free_string(mpg123_string *sb ) ;
#line 1446
int mpg123_resize_string(mpg123_string *sb , size_t news ) ;
#line 1457
int mpg123_grow_string(mpg123_string *sb , size_t news ) ;
#line 1465
int mpg123_copy_string(mpg123_string *from , mpg123_string *to ) ;
#line 1479
int mpg123_move_string(mpg123_string *from , mpg123_string *to ) ;
#line 1486
int mpg123_add_string(mpg123_string *sb , char const   *stuff ) ;
#line 1495
int mpg123_add_substring(mpg123_string *sb , char const   *stuff , size_t from , size_t count ) ;
#line 1503
int mpg123_set_string(mpg123_string *sb , char const   *stuff ) ;
#line 1512
int mpg123_set_substring(mpg123_string *sb , char const   *stuff , size_t from , size_t count ) ;
#line 1523
size_t mpg123_strlen(mpg123_string *sb , int utf8 ) ;
#line 1529
int mpg123_chomp_string(mpg123_string *sb ) ;
#line 1538
int mpg123_same_string(mpg123_string *a , mpg123_string *b ) ;
#line 1590
int mpg123_enc_from_id3_2(unsigned char id3_enc_byte ) ;
#line 1622
int mpg123_store_utf8_2(mpg123_string *sb , int enc , unsigned char const   *source ,
                        size_t source_size ) ;
#line 1729
int mpg123_meta_check(mpg123_handle *mh ) ;
#line 1734
void mpg123_meta_free(mpg123_handle *mh ) ;
#line 1740
int mpg123_id3(mpg123_handle *mh , mpg123_id3v1 **v1 , mpg123_id3v2 **v2 ) ;
#line 1756
int mpg123_id3_raw(mpg123_handle *mh , unsigned char **v1 , size_t *v1_size , unsigned char **v2 ,
                   size_t *v2_size ) ;
#line 1765
int mpg123_icy(mpg123_handle *mh , char **icy_meta ) ;
#line 1771
char *mpg123_icy2utf8(char const   *icy_text ) ;
#line 1804
mpg123_handle *mpg123_parnew(mpg123_pars *mp , char const   *decoder , int *error ) ;
#line 1811
mpg123_pars *mpg123_new_pars(int *error ) ;
#line 1816
void mpg123_delete_pars(mpg123_pars *mp ) ;
#line 1823
int mpg123_fmt_none(mpg123_pars *mp ) ;
#line 1830
int mpg123_fmt_all(mpg123_pars *mp ) ;
#line 1841
int mpg123_fmt(mpg123_pars *mp , long rate , int channels , int encodings ) ;
#line 1854
int mpg123_fmt2(mpg123_pars *mp , long rate , int channels , int encodings ) ;
#line 1864
int mpg123_fmt_support(mpg123_pars *mp , long rate , int encoding ) ;
#line 1893
int mpg123_par2(mpg123_pars *mp , int type , long value , double fvalue ) ;
#line 1923
int mpg123_getpar2(mpg123_pars *mp , int type , long *value , double *fvalue ) ;
#line 1948
int mpg123_replace_buffer(mpg123_handle *mh , void *data , size_t size ) ;
#line 1956
size_t mpg123_outblock(mpg123_handle *mh ) ;
#line 1971
int mpg123_replace_reader(mpg123_handle *mh , mpg123_ssize_t (*r_read)(int  , void * ,
                                                                       size_t  ) ,
                          off_t (*r_lseek)(int  , off_t  , int  ) ) ;
#line 1990
int mpg123_replace_reader_handle(mpg123_handle *mh , mpg123_ssize_t (*r_read)(void * ,
                                                                              void * ,
                                                                              size_t  ) ,
                                 off_t (*r_lseek)(void * , off_t  , int  ) , void (*cleanup)(void * ) ) ;
#line 48 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
static struct mpg *m ;
#line 85 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
static decode_state mpg_decode(void) 
{ 
  size_t bytes ;
  size_t space ;
  size_t size ;
  int ret ;
  u8_t *write_buf ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int tmp ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int __cil_tmp18 ;
  long rate ;
  int channels___0 ;
  int enc ;
  char const   *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  char const   *__cil_tmp24 ;
  s16_t *iptr ;
  s32_t *optr ;
  size_t count ;
  size_t __cil_tmp28 ;
  char const   *__cil_tmp29 ;
  char const   *__cil_tmp30 ;
  char const   *__cil_tmp31 ;

  {
  {
#line 90
  pthread_mutex_lock(& streambuf->mutex);
#line 91
  pthread_mutex_lock(& outputbuf->mutex);
#line 92
  __cil_tmp7 = _buf_cont_read(streambuf);
  }
  {
#line 92
  __cil_tmp6 = _buf_used(streambuf);
  }
#line 92
  if (__cil_tmp6 < __cil_tmp7) {
    {
#line 92
    __cil_tmp8 = _buf_used(streambuf);
#line 92
    tmp = __cil_tmp8;
    }
  } else {
    {
#line 92
    __cil_tmp9 = _buf_cont_read(streambuf);
#line 92
    tmp = __cil_tmp9;
    }
  }
  {
#line 92
  bytes = (size_t )tmp;
#line 94
  __cil_tmp12 = _buf_cont_write(outputbuf);
  }
  {
#line 94
  __cil_tmp11 = _buf_space(outputbuf);
  }
#line 94
  if (__cil_tmp11 < __cil_tmp12) {
    {
#line 94
    __cil_tmp13 = _buf_space(outputbuf);
#line 94
    tmp___0 = __cil_tmp13;
    }
  } else {
    {
#line 94
    __cil_tmp14 = _buf_cont_write(outputbuf);
#line 94
    tmp___0 = __cil_tmp14;
    }
  }
#line 94
  space = (size_t )tmp___0;
#line 94
  write_buf = outputbuf->writep;
#line 103
  if (bytes < 512UL) {
#line 103
    tmp___1 = bytes;
  } else {
#line 103
    tmp___1 = (unsigned long )512;
  }
#line 103
  bytes = tmp___1;
#line 104
  if (space < 32768UL) {
#line 104
    tmp___2 = space;
  } else {
#line 104
    tmp___2 = (unsigned long )32768;
  }
#line 104
  space = tmp___2;
#line 106
  if (m->use16bit) {
#line 107
    space = (space / 8UL) * 4UL;
  }
#line 111
  if (decode.new_stream) {
#line 112
    space = (size_t )0;
  }
  {
#line 115
  ret = (*(m->mpg123_decode))(m->h, (unsigned char const   *)streambuf->readp, bytes,
                              write_buf, space, & size);
  }
#line 117
  if (ret == -11) {
#line 119
    if (decode.new_stream) {
      {
#line 123
      (*(m->mpg123_getformat))(m->h, & rate, & channels___0, & enc);
      }
#line 125
      if ((unsigned int )loglevel >= 2U) {
        {
#line 125
        __cil_tmp22 = logtime();
#line 125
        logprint("%s %s:%d setting track_start\nU", __cil_tmp22, "mpg_decode\256e\301U",
                 125);
        }
      }
      {
#line 127
      output.next_sample_rate = decode_newstream((unsigned int )rate, (unsigned int *)output.supported_rates);
#line 129
      output.track_start = outputbuf->writep;
      }
#line 130
      if (output.fade_mode) {
        {
#line 130
        _checkfade(1);
        }
      }
#line 131
      decode.new_stream = 0;
    } else
#line 135
    if ((unsigned int )loglevel >= 1U) {
      {
#line 135
      __cil_tmp24 = logtime();
#line 135
      logprint("%s %s:%d format change mid stream - not supported\n", __cil_tmp24,
               "mpg_decode", 135);
      }
    }
  }
#line 140
  if (m->use16bit) {
#line 143
    count = size / 2UL;
#line 144
    size = count * 4UL;
#line 145
    iptr = (s16_t *)write_buf + count;
#line 146
    optr = (s32_t *)write_buf + count;
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      __cil_tmp28 = count;
#line 147
      count --;
#line 147
      if (! __cil_tmp28) {
#line 147
        goto while_break;
      }
#line 148
      iptr --;
#line 148
      optr --;
#line 148
      *optr = (int )*iptr << 16;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 152
  _buf_inc_readp(streambuf, (unsigned int )bytes);
#line 154
  _buf_inc_writep(outputbuf, (unsigned int )size);
#line 161
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 163
  if ((unsigned int )loglevel >= 4U) {
    {
#line 163
    __cil_tmp29 = logtime();
#line 163
    logprint("%s %s:%d write %u frames\n", __cil_tmp29, "mpg_decode", 163, size / 8UL);
    }
  }
#line 165
  if (ret == -12) {
    _L: /* CIL Label */ 
    {
#line 166
    pthread_mutex_unlock(& streambuf->mutex);
    }
#line 167
    if ((unsigned int )loglevel >= 2U) {
      {
#line 167
      __cil_tmp30 = logtime();
#line 167
      logprint("%s %s:%d stream complete\n", __cil_tmp30, "mpg_decode", 167);
      }
    }
#line 168
    return ((decode_state )3);
  } else
#line 165
  if (bytes == 0UL) {
#line 165
    if (size == 0UL) {
#line 165
      if ((unsigned int )stream.state <= 1U) {
#line 165
        goto _L;
      }
    }
  }
  {
#line 171
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 173
  if (ret == -1) {
#line 174
    if ((unsigned int )loglevel >= 1U) {
      {
#line 174
      __cil_tmp31 = logtime();
#line 174
      logprint("%s %s:%d Error\n", __cil_tmp31, "mpg_decode", 174);
      }
    }
#line 175
    return ((decode_state )3);
  }
#line 179
  return ((decode_state )2);
}
}
#line 182 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
static void mpg_open(u8_t size , u8_t rate , u8_t chan , u8_t endianness ) 
{ 
  int err ;
  long const   *list ;
  size_t count ;
  size_t i ;
  mpg123_handle *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;
  int tmp ;
  size_t __cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char const   *__cil_tmp16 ;

  {
#line 187
  if (m->h) {
    {
#line 188
    (*(m->mpg123_delete))(m->h);
    }
  }
  {
#line 191
  m->h = (*(m->mpg123_new))((char const   *)((void *)0), & err);
  }
#line 193
  if (m->h == (void *)0) {
#line 194
    if ((unsigned int )loglevel >= 1U) {
      {
#line 194
      __cil_tmp10 = logtime();
      }
      {
#line 194
      __cil_tmp11 = (*(m->mpg123_plain_strerror))(err);
#line 194
      logprint("%s %s:%d new error: %s\n", __cil_tmp10, "mpg_open\312\001D", 194,
               __cil_tmp11);
      }
    }
  }
  {
#line 198
  (*(m->mpg123_rates))(& list, & count);
#line 199
  (*(m->mpg123_format_none))(m->h);
#line 200
  i = (size_t )0;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < count)) {
#line 200
      goto while_break;
    }
#line 201
    if (m->use16bit) {
#line 201
      tmp = 208;
    } else {
#line 201
      tmp = 4480;
    }
    {
#line 201
    (*(m->mpg123_format))(m->h, *(list + i), 2, tmp);
    }
#line 200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 204
  err = (*(m->mpg123_open_feed))(m->h);
  }
#line 206
  if (err) {
#line 207
    if ((unsigned int )loglevel >= 1U) {
      {
#line 207
      __cil_tmp15 = logtime();
      }
      {
#line 207
      __cil_tmp16 = (*(m->mpg123_plain_strerror))(err);
#line 207
      logprint("%s %s:%d open feed error: %s\n", __cil_tmp15, "mpg_open\312\001D",
               207, __cil_tmp16);
      }
    }
  }
  return;
}
}
#line 211 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
static void mpg_close(void) 
{ 


  {
  {
#line 212
  (*(m->mpg123_delete))(m->h);
#line 213
  m->h = (mpg123_handle *)((void *)0);
  }
  return;
}
}
#line 216 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
static int load_mpg(void) 
{ 
  void *handle ;
  void *__cil_tmp2 ;
  char *err ;
  char const   *__cil_tmp4 ;
  char *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char const   *__cil_tmp18 ;
  char const   *__cil_tmp19 ;

  {
  {
#line 218
  __cil_tmp2 = dlopen("libmpg123.so.0", 2);
#line 218
  handle = __cil_tmp2;
  }
#line 221
  if (! handle) {
#line 222
    if ((unsigned int )loglevel >= 2U) {
      {
#line 222
      __cil_tmp4 = logtime();
      }
      {
#line 222
      __cil_tmp5 = dlerror();
#line 222
      logprint("%s %s:%d dlerror: %s\n", __cil_tmp4, "load_mpg\312\001D", 222, __cil_tmp5);
      }
    }
#line 223
    return (0);
  }
  {
#line 226
  m->mpg123_init = (int (*)(void))dlsym(handle, "mpg123_inite\301U");
#line 227
  m->mpg123_feature2 = (int (*)(enum mpg123_feature_set  ))dlsym(handle, "mpg123_feature");
#line 228
  m->mpg123_rates = (void (*)(long const   ** , size_t * ))dlsym(handle, "mpg123_rates\301U");
#line 229
  m->mpg123_format_none = (int (*)(mpg123_handle * ))dlsym(handle, "mpg123_format_none\271e\301U");
#line 230
  m->mpg123_format = (int (*)(mpg123_handle * , long  , int  , int  ))dlsym(handle,
                                                                            "mpg123_format");
#line 231
  m->mpg123_new = (mpg123_handle *(*)(char const   * , int * ))dlsym(handle, "mpg123_new");
#line 232
  m->mpg123_delete = (void (*)(mpg123_handle * ))dlsym(handle, "mpg123_delete");
#line 233
  m->mpg123_open_feed = (int (*)(mpg123_handle * ))dlsym(handle, "mpg123_open_feed\220");
#line 234
  m->mpg123_decode = (int (*)(mpg123_handle * , unsigned char const   * , size_t  ,
                              unsigned char * , size_t  , size_t * ))dlsym(handle,
                                                                           "mpg123_decode");
#line 235
  m->mpg123_getformat = (int (*)(mpg123_handle * , long * , int * , int * ))dlsym(handle,
                                                                                  "mpg123_getformat\220");
#line 236
  m->mpg123_plain_strerror = (char const   *(*)(int  ))dlsym(handle, "mpg123_plain_strerrorU");
#line 238
  err = dlerror();
  }
#line 238
  if (err != (void *)0) {
#line 239
    if ((unsigned int )loglevel >= 2U) {
      {
#line 239
      __cil_tmp18 = logtime();
#line 239
      logprint("%s %s:%d dlerror: %s\nU", __cil_tmp18, "load_mpg\312\001\304e9\301\003",
               239, err);
      }
    }
#line 240
    return (0);
  }
#line 243
  if ((unsigned int )loglevel >= 2U) {
    {
#line 243
    __cil_tmp19 = logtime();
#line 243
    logprint("%s %s:%d loaded libmpg123.so.0\ne\301U", __cil_tmp19, "load_mpg\312\001\304e\301\302\003",
             243);
    }
  }
#line 246
  return (1);
}
}
#line 249 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mpg.c"
struct codec *register_mpg(void) 
{ 
  static struct codec ret ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
#line 250
  ret.id = (char )'m';
#line 250
  ret.types = "mp3";
#line 250
  ret.min_read_bytes = (unsigned int )512;
#line 250
  ret.min_space = (unsigned int )32768;
#line 250
  ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& mpg_open);
#line 250
  ret.close = (void (*)(void))(& mpg_close);
  {
#line 250
  ret.decode = (enum __anonenum__74 (*)(void))(& mpg_decode);
#line 260
  m = (struct mpg *)malloc(sizeof(struct mpg ));
  }
#line 261
  if (! m) {
#line 262
    return ((struct codec *)((void *)0));
  }
  {
#line 265
  m->h = (mpg123_handle *)((void *)0);
#line 267
  __cil_tmp3 = load_mpg();
  }
#line 267
  if (! __cil_tmp3) {
#line 268
    return ((struct codec *)((void *)0));
  }
  {
#line 271
  (*(m->mpg123_init))();
#line 273
  m->use16bit = (*(m->mpg123_feature2))((enum mpg123_feature_set )3);
  }
#line 275
  if ((unsigned int )loglevel >= 2U) {
    {
#line 275
    __cil_tmp5 = logtime();
#line 275
    logprint("%s %s:%d using mpg to decode mp3\n\255\206e\301U", __cil_tmp5, "register_mpg",
             275);
    }
  }
#line 276
  return (& ret);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *__nptr , char **__endptr ,
                                                        int __base ) ;
#line 301
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *__nptr , char **__endptr ,
                                                         int __base ) ;
#line 305
extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                        int __base ) ;
#line 310
extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                         int __base ) ;
#line 117 "/usr/include/ogg/ogg.h"
extern void oggpack_writeinit(oggpack_buffer *b ) ;
#line 118
extern int oggpack_writecheck(oggpack_buffer *b ) ;
#line 119
extern void oggpack_writetrunc(oggpack_buffer *b , long bits ) ;
#line 120
extern void oggpack_writealign(oggpack_buffer *b ) ;
#line 121
extern void oggpack_writecopy(oggpack_buffer *b , void *source , long bits ) ;
#line 122
extern void oggpack_reset(oggpack_buffer *b ) ;
#line 123
extern void oggpack_writeclear(oggpack_buffer *b ) ;
#line 124
extern void oggpack_readinit(oggpack_buffer *b , unsigned char *buf , int bytes ) ;
#line 125
extern void oggpack_write(oggpack_buffer *b , unsigned long value , int bits ) ;
#line 126
extern long oggpack_look(oggpack_buffer *b , int bits ) ;
#line 127
extern long oggpack_look1(oggpack_buffer *b ) ;
#line 128
extern void oggpack_adv(oggpack_buffer *b , int bits ) ;
#line 129
extern void oggpack_adv1(oggpack_buffer *b ) ;
#line 130
extern long oggpack_read(oggpack_buffer *b , int bits ) ;
#line 131
extern long oggpack_read1(oggpack_buffer *b ) ;
#line 132
extern long oggpack_bytes(oggpack_buffer *b ) ;
#line 133
extern long oggpack_bits(oggpack_buffer *b ) ;
#line 134
extern unsigned char *oggpack_get_buffer(oggpack_buffer *b ) ;
#line 136
extern void oggpackB_writeinit(oggpack_buffer *b ) ;
#line 137
extern int oggpackB_writecheck(oggpack_buffer *b ) ;
#line 138
extern void oggpackB_writetrunc(oggpack_buffer *b , long bits ) ;
#line 139
extern void oggpackB_writealign(oggpack_buffer *b ) ;
#line 140
extern void oggpackB_writecopy(oggpack_buffer *b , void *source , long bits ) ;
#line 141
extern void oggpackB_reset(oggpack_buffer *b ) ;
#line 142
extern void oggpackB_writeclear(oggpack_buffer *b ) ;
#line 143
extern void oggpackB_readinit(oggpack_buffer *b , unsigned char *buf , int bytes ) ;
#line 144
extern void oggpackB_write(oggpack_buffer *b , unsigned long value , int bits ) ;
#line 145
extern long oggpackB_look(oggpack_buffer *b , int bits ) ;
#line 146
extern long oggpackB_look1(oggpack_buffer *b ) ;
#line 147
extern void oggpackB_adv(oggpack_buffer *b , int bits ) ;
#line 148
extern void oggpackB_adv1(oggpack_buffer *b ) ;
#line 149
extern long oggpackB_read(oggpack_buffer *b , int bits ) ;
#line 150
extern long oggpackB_read1(oggpack_buffer *b ) ;
#line 151
extern long oggpackB_bytes(oggpack_buffer *b ) ;
#line 152
extern long oggpackB_bits(oggpack_buffer *b ) ;
#line 153
extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b ) ;
#line 157
extern int ogg_stream_packetin(ogg_stream_state *os , ogg_packet *op ) ;
#line 158
extern int ogg_stream_iovecin(ogg_stream_state *os , ogg_iovec_t *iov , int count ,
                              long e_o_s , ogg_int64_t granulepos ) ;
#line 160
extern int ogg_stream_pageout(ogg_stream_state *os , ogg_page *og ) ;
#line 161
extern int ogg_stream_pageout_fill(ogg_stream_state *os , ogg_page *og , int nfill ) ;
#line 162
extern int ogg_stream_flush(ogg_stream_state *os , ogg_page *og ) ;
#line 163
extern int ogg_stream_flush_fill(ogg_stream_state *os , ogg_page *og , int nfill ) ;
#line 167
extern int ogg_sync_init(ogg_sync_state *oy ) ;
#line 168
extern int ogg_sync_clear(ogg_sync_state *oy ) ;
#line 169
extern int ogg_sync_reset(ogg_sync_state *oy ) ;
#line 170
extern int ogg_sync_destroy(ogg_sync_state *oy ) ;
#line 171
extern int ogg_sync_check(ogg_sync_state *oy ) ;
#line 173
extern char *ogg_sync_buffer(ogg_sync_state *oy , long size ) ;
#line 174
extern int ogg_sync_wrote(ogg_sync_state *oy , long bytes ) ;
#line 175
extern long ogg_sync_pageseek(ogg_sync_state *oy , ogg_page *og ) ;
#line 176
extern int ogg_sync_pageout(ogg_sync_state *oy , ogg_page *og ) ;
#line 177
extern int ogg_stream_pagein(ogg_stream_state *os , ogg_page *og ) ;
#line 178
extern int ogg_stream_packetout(ogg_stream_state *os , ogg_packet *op ) ;
#line 179
extern int ogg_stream_packetpeek(ogg_stream_state *os , ogg_packet *op ) ;
#line 183
extern int ogg_stream_init(ogg_stream_state *os , int serialno ) ;
#line 184
extern int ogg_stream_clear(ogg_stream_state *os ) ;
#line 185
extern int ogg_stream_reset(ogg_stream_state *os ) ;
#line 186
extern int ogg_stream_reset_serialno(ogg_stream_state *os , int serialno ) ;
#line 187
extern int ogg_stream_destroy(ogg_stream_state *os ) ;
#line 188
extern int ogg_stream_check(ogg_stream_state *os ) ;
#line 189
extern int ogg_stream_eos(ogg_stream_state *os ) ;
#line 191
extern void ogg_page_checksum_set(ogg_page *og ) ;
#line 193
extern int ogg_page_version(ogg_page *og ) ;
#line 194
extern int ogg_page_continued(ogg_page *og ) ;
#line 195
extern int ogg_page_bos(ogg_page *og ) ;
#line 196
extern int ogg_page_eos(ogg_page *og ) ;
#line 197
extern ogg_int64_t ogg_page_granulepos(ogg_page *og ) ;
#line 198
extern int ogg_page_serialno(ogg_page *og ) ;
#line 199
extern long ogg_page_pageno(ogg_page *og ) ;
#line 200
extern int ogg_page_packets(ogg_page *og ) ;
#line 202
extern void ogg_packet_clear(ogg_packet *op ) ;
#line 164 "/usr/include/vorbis/codec.h"
extern void vorbis_info_init(vorbis_info *vi ) ;
#line 165
extern void vorbis_info_clear(vorbis_info *vi ) ;
#line 166
extern int vorbis_info_blocksize(vorbis_info *vi , int zo ) ;
#line 167
extern void vorbis_comment_init(vorbis_comment *vc ) ;
#line 168
extern void vorbis_comment_add(vorbis_comment *vc , char const   *comment ) ;
#line 169
extern void vorbis_comment_add_tag(vorbis_comment *vc , char const   *tag , char const   *contents ) ;
#line 171
extern char *vorbis_comment_query(vorbis_comment *vc , char const   *tag , int count ) ;
#line 172
extern int vorbis_comment_query_count(vorbis_comment *vc , char const   *tag ) ;
#line 173
extern void vorbis_comment_clear(vorbis_comment *vc ) ;
#line 175
extern int vorbis_block_init(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 176
extern int vorbis_block_clear(vorbis_block *vb ) ;
#line 177
extern void vorbis_dsp_clear(vorbis_dsp_state *v ) ;
#line 178
extern double vorbis_granule_time(vorbis_dsp_state *v , ogg_int64_t granulepos ) ;
#line 181
extern char const   *vorbis_version_string(void) ;
#line 185
extern int vorbis_analysis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 186
extern int vorbis_commentheader_out(vorbis_comment *vc , ogg_packet *op ) ;
#line 187
extern int vorbis_analysis_headerout(vorbis_dsp_state *v , vorbis_comment *vc , ogg_packet *op ,
                                     ogg_packet *op_comm , ogg_packet *op_code ) ;
#line 192
extern float **vorbis_analysis_buffer(vorbis_dsp_state *v , int vals ) ;
#line 193
extern int vorbis_analysis_wrote(vorbis_dsp_state *v , int vals ) ;
#line 194
extern int vorbis_analysis_blockout(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 195
extern int vorbis_analysis(vorbis_block *vb , ogg_packet *op ) ;
#line 197
extern int vorbis_bitrate_addblock(vorbis_block *vb ) ;
#line 198
extern int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd , ogg_packet *op ) ;
#line 202
extern int vorbis_synthesis_idheader(ogg_packet *op ) ;
#line 203
extern int vorbis_synthesis_headerin(vorbis_info *vi , vorbis_comment *vc , ogg_packet *op ) ;
#line 206
extern int vorbis_synthesis_init(vorbis_dsp_state *v , vorbis_info *vi ) ;
#line 207
extern int vorbis_synthesis_restart(vorbis_dsp_state *v ) ;
#line 208
extern int vorbis_synthesis(vorbis_block *vb , ogg_packet *op ) ;
#line 209
extern int vorbis_synthesis_trackonly(vorbis_block *vb , ogg_packet *op ) ;
#line 210
extern int vorbis_synthesis_blockin(vorbis_dsp_state *v , vorbis_block *vb ) ;
#line 211
extern int vorbis_synthesis_pcmout(vorbis_dsp_state *v , float ***pcm ) ;
#line 212
extern int vorbis_synthesis_lapout(vorbis_dsp_state *v , float ***pcm ) ;
#line 213
extern int vorbis_synthesis_read(vorbis_dsp_state *v , int samples ) ;
#line 214
extern long vorbis_packet_blocksize(vorbis_info *vi , ogg_packet *op ) ;
#line 216
extern int vorbis_synthesis_halfrate(vorbis_info *v , int flag ) ;
#line 217
extern int vorbis_synthesis_halfrate_p(vorbis_info *v ) ;
#line 148 "/usr/include/vorbis/vorbisfile.h"
extern int ov_clear(OggVorbis_File *vf ) ;
#line 149
extern int ov_fopen(char const   *path , OggVorbis_File *vf ) ;
#line 150
extern int ov_open(FILE *f , OggVorbis_File *vf , char const   *initial , long ibytes ) ;
#line 151
extern int ov_open_callbacks(void *datasource , OggVorbis_File *vf , char const   *initial ,
                             long ibytes , ov_callbacks callbacks ) ;
#line 154
extern int ov_test(FILE *f , OggVorbis_File *vf , char const   *initial , long ibytes ) ;
#line 155
extern int ov_test_callbacks(void *datasource , OggVorbis_File *vf , char const   *initial ,
                             long ibytes , ov_callbacks callbacks ) ;
#line 157
extern int ov_test_open(OggVorbis_File *vf ) ;
#line 159
extern long ov_bitrate(OggVorbis_File *vf , int i ) ;
#line 160
extern long ov_bitrate_instant(OggVorbis_File *vf ) ;
#line 161
extern long ov_streams(OggVorbis_File *vf ) ;
#line 162
extern long ov_seekable(OggVorbis_File *vf ) ;
#line 163
extern long ov_serialnumber(OggVorbis_File *vf , int i ) ;
#line 165
extern ogg_int64_t ov_raw_total(OggVorbis_File *vf , int i ) ;
#line 166
extern ogg_int64_t ov_pcm_total(OggVorbis_File *vf , int i ) ;
#line 167
extern double ov_time_total(OggVorbis_File *vf , int i ) ;
#line 169
extern int ov_raw_seek(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 170
extern int ov_pcm_seek(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 171
extern int ov_pcm_seek_page(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 172
extern int ov_time_seek(OggVorbis_File *vf , double pos ) ;
#line 173
extern int ov_time_seek_page(OggVorbis_File *vf , double pos ) ;
#line 175
extern int ov_raw_seek_lap(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 176
extern int ov_pcm_seek_lap(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 177
extern int ov_pcm_seek_page_lap(OggVorbis_File *vf , ogg_int64_t pos ) ;
#line 178
extern int ov_time_seek_lap(OggVorbis_File *vf , double pos ) ;
#line 179
extern int ov_time_seek_page_lap(OggVorbis_File *vf , double pos ) ;
#line 181
extern ogg_int64_t ov_raw_tell(OggVorbis_File *vf ) ;
#line 182
extern ogg_int64_t ov_pcm_tell(OggVorbis_File *vf ) ;
#line 183
extern double ov_time_tell(OggVorbis_File *vf ) ;
#line 185
extern vorbis_info *ov_info(OggVorbis_File *vf , int link ) ;
#line 186
extern vorbis_comment *ov_comment(OggVorbis_File *vf , int link ) ;
#line 188
extern long ov_read_float(OggVorbis_File *vf , float ***pcm_channels , int samples ,
                          int *bitstream ) ;
#line 190
extern long ov_read_filter(OggVorbis_File *vf , char *buffer , int length , int bigendianp ,
                           int word , int sgned , int *bitstream , void (*filter)(float ** ,
                                                                                  long  ,
                                                                                  long  ,
                                                                                  void * ) ,
                           void *filter_param ) ;
#line 193
extern long ov_read(OggVorbis_File *vf , char *buffer , int length , int bigendianp ,
                    int word , int sgned , int *bitstream ) ;
#line 195
extern int ov_crosslap(OggVorbis_File *vf1 , OggVorbis_File *vf2 ) ;
#line 197
extern int ov_halfrate(OggVorbis_File *vf , int flag ) ;
#line 198
extern int ov_halfrate_p(OggVorbis_File *vf ) ;
#line 71 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static struct vorbis *v ;
#line 114 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static size_t _read_cb(void *ptr , size_t size , size_t nmemb , void *datasource ) 
{ 
  size_t bytes ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int tmp ;
  size_t tmp___0 ;

  {
  {
#line 117
  pthread_mutex_lock(& streambuf->mutex);
#line 119
  __cil_tmp7 = _buf_cont_read(streambuf);
  }
  {
#line 119
  __cil_tmp6 = _buf_used(streambuf);
  }
#line 119
  if (__cil_tmp6 < __cil_tmp7) {
    {
#line 119
    __cil_tmp8 = _buf_used(streambuf);
#line 119
    tmp = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp9 = _buf_cont_read(streambuf);
#line 119
    tmp = __cil_tmp9;
    }
  }
#line 119
  bytes = (size_t )tmp;
#line 120
  if (bytes < size * nmemb) {
#line 120
    tmp___0 = bytes;
  } else {
#line 120
    tmp___0 = size * nmemb;
  }
  {
#line 120
  bytes = tmp___0;
#line 122
  memcpy(ptr, streambuf->readp, bytes);
#line 123
  _buf_inc_readp(streambuf, (unsigned int )bytes);
#line 125
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 127
  return (bytes / size);
}
}
#line 131 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static int _seek_cb(void *datasource , ogg_int64_t offset , int whence ) 
{ 


  {
#line 131
  return (- 1);
}
}
#line 132 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static int _close_cb(void *datasource ) 
{ 


  {
#line 132
  return (0);
}
}
#line 133 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static long _tell_cb(void *datasource ) 
{ 


  {
#line 133
  return ((long )0);
}
}
#line 135 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static decode_state vorbis_decode(void) 
{ 
  static int channels___0 ;
  frames_t frames ;
  int bytes ;
  int s ;
  int n ;
  u8_t *write_buf ;
  unsigned int __cil_tmp7 ;
  ov_callbacks cbs ;
  int err ;
  struct vorbis_info *info ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;
  vorbis_info *__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int tmp ;
  long __cil_tmp22 ;
  long __cil_tmp23 ;
  frames_t count ;
  s16_t *iptr ;
  s32_t *optr ;
  frames_t __cil_tmp27 ;
  frames_t __cil_tmp28 ;
  char const   *__cil_tmp29 ;
  char const   *__cil_tmp30 ;
  char const   *__cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char const   *__cil_tmp33 ;

  {
  {
#line 141
  pthread_mutex_lock(& streambuf->mutex);
#line 143
  __cil_tmp7 = _buf_used(streambuf);
  }
#line 143
  if ((unsigned int )stream.state <= 1U) {
#line 143
    if (! __cil_tmp7) {
      {
#line 144
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 145
      return ((decode_state )3);
    }
  }
  {
#line 148
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 150
  if (decode.new_stream) {
#line 155
    cbs.read_func = & _read_cb;
#line 157
    if (v->ov_read_tremor) {
#line 158
      cbs.seek_func = & _seek_cb;
#line 158
      cbs.close_func = & _close_cb;
#line 158
      cbs.tell_func = & _tell_cb;
    } else {
#line 160
      cbs.seek_func = (int (*)(void * , ogg_int64_t  , int  ))((void *)0);
#line 160
      cbs.close_func = (int (*)(void * ))((void *)0);
#line 160
      cbs.tell_func = (long (*)(void * ))((void *)0);
    }
    {
#line 163
    err = (*(v->ov_open_callbacks))(streambuf, v->vf, (char const   *)((void *)0),
                                    (long )0, cbs);
    }
#line 163
    if (err < 0) {
#line 164
      if ((unsigned int )loglevel >= 1U) {
        {
#line 164
        __cil_tmp12 = logtime();
#line 164
        logprint("%s %s:%d open_callbacks error: %d\n", __cil_tmp12, "vorbis_decode",
                 164, err);
        }
      }
#line 165
      return ((decode_state )3);
    }
    {
#line 168
    v->opened = 1;
#line 169
    info = (*(v->ov_info))(v->vf, - 1);
    }
#line 171
    if ((unsigned int )loglevel >= 2U) {
      {
#line 171
      __cil_tmp14 = logtime();
#line 171
      logprint("%s %s:%d setting track_start\n", __cil_tmp14, "vorbis_decode", 171);
      }
    }
    {
#line 172
    pthread_mutex_lock(& outputbuf->mutex);
#line 173
    output.next_sample_rate = decode_newstream((unsigned int )info->rate, (unsigned int *)output.supported_rates);
#line 175
    output.track_start = outputbuf->writep;
    }
#line 176
    if (output.fade_mode) {
      {
#line 176
      _checkfade(1);
      }
    }
    {
#line 177
    decode.new_stream = 0;
#line 178
    pthread_mutex_unlock(& outputbuf->mutex);
#line 180
    channels___0 = info->channels;
    }
#line 182
    if (channels___0 > 2) {
#line 183
      if ((unsigned int )loglevel >= 1U) {
        {
#line 183
        __cil_tmp16 = logtime();
#line 183
        logprint("%s %s:%d too many channels: %d\n", __cil_tmp16, "vorbis_decode",
                 183, channels___0);
        }
      }
#line 184
      return ((decode_state )4);
    }
  }
  {
#line 195
  pthread_mutex_lock(& outputbuf->mutex);
#line 196
  __cil_tmp18 = _buf_cont_write(outputbuf);
  }
  {
#line 196
  __cil_tmp17 = _buf_space(outputbuf);
  }
#line 196
  if (__cil_tmp17 < __cil_tmp18) {
    {
#line 196
    __cil_tmp19 = _buf_space(outputbuf);
#line 196
    tmp = __cil_tmp19;
    }
  } else {
    {
#line 196
    __cil_tmp20 = _buf_cont_write(outputbuf);
#line 196
    tmp = __cil_tmp20;
    }
  }
#line 196
  frames = tmp / 8U;
#line 196
  write_buf = outputbuf->writep;
#line 206
  bytes = (int )((frames * 2U) * (unsigned int )channels___0);
#line 212
  if (! v->ov_read_tremor) {
    {
#line 214
    __cil_tmp22 = (*(v->ov_read))(v->vf, (char *)write_buf, bytes, 0, 2, 1, & s);
#line 214
    n = (int )__cil_tmp22;
    }
  } else {
    {
#line 220
    __cil_tmp23 = (*(v->ov_read_tremor))(v->vf, (char *)write_buf, bytes, & s);
#line 220
    n = (int )__cil_tmp23;
    }
  }
#line 229
  if (n > 0) {
#line 234
    frames = (frames_t )((n / 2) / channels___0);
#line 235
    count = frames * (unsigned int )channels___0;
#line 238
    iptr = (s16_t *)write_buf + count;
#line 239
    optr = (s32_t *)outputbuf->writep + frames * 2U;
#line 246
    if (channels___0 == 2) {
      {
#line 255
      while (1) {
        while_continue: /* CIL Label */ ;
#line 255
        __cil_tmp27 = count;
#line 255
        count --;
#line 255
        if (! __cil_tmp27) {
#line 255
          goto while_break;
        }
#line 256
        iptr --;
#line 256
        optr --;
#line 256
        *optr = (int )*iptr << 16;
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 259
    if (channels___0 == 1) {
      {
#line 260
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 260
        __cil_tmp28 = count;
#line 260
        count --;
#line 260
        if (! __cil_tmp28) {
#line 260
          goto while_break___0;
        }
#line 261
        iptr --;
#line 261
        optr --;
#line 261
        *optr = (int )*iptr << 16;
#line 262
        optr --;
#line 262
        *optr = (int )*iptr << 16;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 266
    _buf_inc_writep(outputbuf, frames * 8U);
    }
#line 273
    if ((unsigned int )loglevel >= 4U) {
      {
#line 273
      __cil_tmp29 = logtime();
#line 273
      logprint("%s %s:%d wrote %u frames\n", __cil_tmp29, "vorbis_decode", 273, frames);
      }
    }
  } else
#line 275
  if (n == 0) {
#line 277
    if ((unsigned int )stream.state <= 1U) {
#line 278
      if ((unsigned int )loglevel >= 2U) {
        {
#line 278
        __cil_tmp30 = logtime();
#line 278
        logprint("%s %s:%d partial decode\n\230", __cil_tmp30, "vorbis_decode", 278);
        }
      }
      {
#line 279
      pthread_mutex_unlock(& outputbuf->mutex);
      }
#line 280
      return ((decode_state )3);
    } else
#line 282
    if ((unsigned int )loglevel >= 2U) {
      {
#line 282
      __cil_tmp31 = logtime();
#line 282
      logprint("%s %s:%d no frame decoded\n", __cil_tmp31, "vorbis_decode", 282);
      }
    }
  } else
#line 285
  if (n == -3) {
#line 288
    if ((unsigned int )loglevel >= 3U) {
      {
#line 288
      __cil_tmp32 = logtime();
#line 288
      logprint("%s %s:%d hole in stream\n\230", __cil_tmp32, "vorbis_decode", 288);
      }
    }
  } else {
#line 292
    if ((unsigned int )loglevel >= 2U) {
      {
#line 292
      __cil_tmp33 = logtime();
#line 292
      logprint("%s %s:%d ov_read error: %d\n", __cil_tmp33, "vorbis_decode", 292,
               n);
      }
    }
    {
#line 293
    pthread_mutex_unlock(& outputbuf->mutex);
    }
#line 294
    return ((decode_state )3);
  }
  {
#line 297
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 298
  return ((decode_state )2);
}
}
#line 301 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static void vorbis_open(u8_t size , u8_t rate , u8_t chan , u8_t endianness ) 
{ 
  void *__cil_tmp5 ;

  {
#line 302
  if (! v->vf) {
    {
#line 303
    v->vf = (OggVorbis_File *)malloc(sizeof(OggVorbis_File ) + 128UL);
#line 304
    memset(v->vf, 0, sizeof(OggVorbis_File ) + 128UL);
    }
  } else
#line 309
  if (v->opened) {
    {
#line 310
    (*(v->ov_clear))(v->vf);
#line 311
    v->opened = 0;
    }
  }
  return;
}
}
#line 316 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static void vorbis_close(void) 
{ 


  {
#line 317
  if (v->opened) {
    {
#line 318
    (*(v->ov_clear))(v->vf);
#line 319
    v->opened = 0;
    }
  }
  {
#line 321
  free(v->vf);
#line 326
  v->vf = (OggVorbis_File *)((void *)0);
  }
  return;
}
}
#line 329 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
static int load_vorbis(void) 
{ 
  void *handle ;
  void *__cil_tmp2 ;
  char *err ;
  int tremor ;
  void *__cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *tmp ;
  void *__cil_tmp10 ;
  void *tmp___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  char const   *tmp___1 ;

  {
  {
#line 331
  __cil_tmp2 = dlopen("libvorbisfile.so.3", 2);
#line 331
  handle = __cil_tmp2;
#line 333
  tremor = 0;
  }
#line 335
  if (! handle) {
    {
#line 336
    handle = dlopen("libvorbisidec.so.1", 2);
    }
#line 337
    if (handle) {
#line 338
      tremor = 1;
    } else {
#line 340
      if ((unsigned int )loglevel >= 2U) {
        {
#line 340
        __cil_tmp6 = logtime();
        }
        {
#line 340
        __cil_tmp7 = dlerror();
#line 340
        logprint("%s %s:%d dlerror: %s\n", __cil_tmp6, "load_vorbis", 340, __cil_tmp7);
        }
      }
#line 341
      return (0);
    }
  }
#line 345
  if (tremor) {
#line 345
    tmp = (void *)0;
  } else {
    {
#line 345
    __cil_tmp8 = dlsym(handle, "ov_read");
#line 345
    tmp = __cil_tmp8;
    }
  }
#line 345
  v->ov_read = tmp;
#line 346
  if (tremor) {
    {
#line 346
    __cil_tmp10 = dlsym(handle, "ov_read");
#line 346
    tmp___0 = __cil_tmp10;
    }
  } else {
#line 346
    tmp___0 = (void *)0;
  }
  {
#line 346
  v->ov_read_tremor = tmp___0;
#line 347
  v->ov_info = (vorbis_info *(*)(OggVorbis_File * , int  ))dlsym(handle, "ov_info");
#line 348
  v->ov_clear = (int (*)(OggVorbis_File * ))dlsym(handle, "ov_clear\220");
#line 349
  v->ov_open_callbacks = (int (*)(void * , OggVorbis_File * , char const   * , long  ,
                                  ov_callbacks  ))dlsym(handle, "ov_open_callbacks");
#line 351
  err = dlerror();
  }
#line 351
  if (err != (void *)0) {
#line 352
    if ((unsigned int )loglevel >= 2U) {
      {
#line 352
      __cil_tmp16 = logtime();
#line 352
      logprint("%s %s:%d dlerror: %s\nU", __cil_tmp16, "load_vorbis", 352, err);
      }
    }
#line 353
    return (0);
  }
#line 356
  if ((unsigned int )loglevel >= 2U) {
    {
#line 356
    __cil_tmp17 = logtime();
    }
#line 356
    if (tremor) {
#line 356
      tmp___1 = "libvorbisidec.so.1";
    } else {
#line 356
      tmp___1 = "libvorbisfile.so.3\331e\301U";
    }
    {
#line 356
    logprint("%s %s:%d loaded %s\n", __cil_tmp17, "load_vorbis", 356, tmp___1);
    }
  }
#line 359
  return (1);
}
}
#line 362 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/vorbis.c"
struct codec *register_vorbis(void) 
{ 
  static struct codec ret ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
#line 363
  ret.id = (char )'o';
#line 363
  ret.types = "ogg";
#line 363
  ret.min_read_bytes = (unsigned int )4096;
#line 363
  ret.min_space = (unsigned int )20480;
#line 363
  ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& vorbis_open);
#line 363
  ret.close = (void (*)(void))(& vorbis_close);
  {
#line 363
  ret.decode = (enum __anonenum__74 (*)(void))(& vorbis_decode);
#line 373
  v = (struct vorbis *)malloc(sizeof(struct vorbis ));
  }
#line 374
  if (! v) {
#line 375
    return ((struct codec *)((void *)0));
  }
  {
#line 378
  v->vf = (OggVorbis_File *)((void *)0);
#line 379
  v->opened = 0;
#line 381
  __cil_tmp3 = load_vorbis();
  }
#line 381
  if (! __cil_tmp3) {
#line 382
    return ((struct codec *)((void *)0));
  }
#line 385
  if ((unsigned int )loglevel >= 2U) {
    {
#line 385
    __cil_tmp4 = logtime();
#line 385
    logprint("%s %s:%d using vorbis to decode ogg\n", __cil_tmp4, "register_vorbis",
             385);
    }
  }
#line 386
  return (& ret);
}
}
#line 58 "/usr/include/mad.h"
extern char const   mad_version[] ;
#line 59
extern char const   mad_copyright[] ;
#line 60
extern char const   mad_author[] ;
#line 61
extern char const   mad_build[] ;
#line 562
mad_fixed_t mad_f_abs(mad_fixed_t  ) ;
#line 563
mad_fixed_t mad_f_div(mad_fixed_t  , mad_fixed_t  ) ;
#line 578
void mad_bit_init(struct mad_bitptr * , unsigned char const   * ) ;
#line 582
unsigned int mad_bit_length(struct mad_bitptr * , struct mad_bitptr * ) ;
#line 586
unsigned char const   *mad_bit_nextbyte(struct mad_bitptr * ) ;
#line 588
void mad_bit_skip(struct mad_bitptr * , unsigned int  ) ;
#line 589
unsigned long mad_bit_read(struct mad_bitptr * , unsigned int  ) ;
#line 590
void mad_bit_write(struct mad_bitptr * , unsigned int  , unsigned long  ) ;
#line 592
unsigned short mad_bit_crc(struct mad_bitptr  , unsigned int  , unsigned short  ) ;
#line 606
extern mad_timer_t mad_timer_zero ;
#line 660
int mad_timer_compare(mad_timer_t  , mad_timer_t  ) ;
#line 664
void mad_timer_negate(mad_timer_t * ) ;
#line 665
mad_timer_t mad_timer_abs(mad_timer_t  ) ;
#line 667
void mad_timer_set(mad_timer_t * , unsigned long  , unsigned long  , unsigned long  ) ;
#line 668
void mad_timer_add(mad_timer_t * , mad_timer_t  ) ;
#line 669
void mad_timer_multiply(mad_timer_t * , long  ) ;
#line 671
long mad_timer_count(mad_timer_t  , enum mad_units  ) ;
#line 672
unsigned long mad_timer_fraction(mad_timer_t  , unsigned long  ) ;
#line 673
void mad_timer_string(mad_timer_t  , char * , char const   * , enum mad_units  , enum mad_units  ,
                      unsigned long  ) ;
#line 751
void mad_stream_init(struct mad_stream * ) ;
#line 752
void mad_stream_finish(struct mad_stream * ) ;
#line 757
void mad_stream_buffer(struct mad_stream * , unsigned char const   * , unsigned long  ) ;
#line 759
void mad_stream_skip(struct mad_stream * , unsigned long  ) ;
#line 761
int mad_stream_sync(struct mad_stream * ) ;
#line 763
char const   *mad_stream_errorstr(struct mad_stream * ) ;
#line 849
void mad_header_init(struct mad_header * ) ;
#line 853
int mad_header_decode(struct mad_header * , struct mad_stream * ) ;
#line 855
void mad_frame_init(struct mad_frame * ) ;
#line 856
void mad_frame_finish(struct mad_frame * ) ;
#line 858
int mad_frame_decode(struct mad_frame * , struct mad_stream * ) ;
#line 860
void mad_frame_mute(struct mad_frame * ) ;
#line 903
void mad_synth_init(struct mad_synth * ) ;
#line 907
void mad_synth_mute(struct mad_synth * ) ;
#line 909
void mad_synth_frame(struct mad_synth * , struct mad_frame * ) ;
#line 960
void mad_decoder_init(struct mad_decoder * , void * , enum mad_flow (*)(void * , struct mad_stream * ) ,
                      enum mad_flow (*)(void * , struct mad_header * ) , enum mad_flow (*)(void * ,
                                                                                           struct mad_stream * ,
                                                                                           struct mad_frame * ) ,
                      enum mad_flow (*)(void * , struct mad_header * , struct mad_pcm * ) ,
                      enum mad_flow (*)(void * , struct mad_stream * , struct mad_frame * ) ,
                      enum mad_flow (*)(void * , void * , unsigned int * ) ) ;
#line 973
int mad_decoder_finish(struct mad_decoder * ) ;
#line 978
int mad_decoder_run(struct mad_decoder * , enum mad_decoder_mode  ) ;
#line 979
int mad_decoder_message(struct mad_decoder * , void * , unsigned int * ) ;
#line 57 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static struct mad *m___0 ;
#line 91 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
__inline static s32_t scale(mad_fixed_t sample ) 
{ 


  {
#line 92
  sample += 1L << 4;
#line 94
  if (sample >= 268435456) {
#line 95
    sample = 268435455;
  } else
#line 96
  if (sample < -268435456) {
#line 97
    sample = - ((mad_fixed_t )268435456L);
  }
#line 101
  return ((s32_t )((sample >> 5) << 8));
}
}
#line 106 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static unsigned int _check_id3_tag(size_t bytes ) 
{ 
  u8_t *ptr ;
  u32_t size ;
  int tmp ;
  char const   *__cil_tmp5 ;

  {
#line 107
  ptr = streambuf->readp;
#line 108
  size = (u32_t )0;
#line 110
  if (bytes > 10UL) {
#line 110
    if ((int )*ptr == 73) {
#line 110
      if ((int )*(ptr + 1) == 68) {
#line 110
        if ((int )*(ptr + 2) == 51) {
#line 112
          if ((int )*(ptr + 6) < 128) {
#line 112
            if ((int )*(ptr + 7) < 128) {
#line 112
              if ((int )*(ptr + 8) < 128) {
#line 112
                if ((int )*(ptr + 9) < 128) {
#line 113
                  if ((int )*(ptr + 5) & 16) {
#line 113
                    tmp = 10;
                  } else {
#line 113
                    tmp = 0;
                  }
#line 113
                  size = (u32_t )(((((10 + ((int )*(ptr + 6) << 21)) + ((int )*(ptr + 7) << 14)) + ((int )*(ptr + 8) << 7)) + (int )*(ptr + 9)) + tmp);
#line 114
                  if ((unsigned int )loglevel >= 3U) {
                    {
#line 114
                    __cil_tmp5 = logtime();
#line 114
                    logprint("%s %s:%d id3.2 tag len: %u\n", __cil_tmp5, "_check_id3_tag",
                             114, size);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 118
  return (size);
}
}
#line 122 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static void _check_lame_header(size_t bytes ) 
{ 
  u8_t *ptr ;
  u32_t frame_count ;
  u32_t enc_delay ;
  u32_t enc_padding ;
  u8_t flags ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  u32_t __cil_tmp11 ;
  int __cil_tmp12 ;
  u32_t tmp ;
  char const   *__cil_tmp14 ;

  {
#line 123
  ptr = streambuf->readp;
#line 125
  if ((int )*ptr == 255) {
#line 125
    if (((int )*(ptr + 1) & 240) == 240) {
#line 125
      if (bytes > 180UL) {
#line 127
        frame_count = (u32_t )0;
#line 127
        enc_delay = (u32_t )0;
        {
#line 127
        enc_padding = (u32_t )0;
#line 131
        __cil_tmp8 = memcmp(ptr + 36, "Info\301U", (unsigned long )4);
        }
        {
#line 131
        __cil_tmp7 = memcmp(ptr + 36, "Xing\301U", (unsigned long )4);
        }
#line 131
        if (! __cil_tmp7) {
#line 132
          ptr += 43;
        } else
#line 131
        if (! __cil_tmp8) {
#line 132
          ptr += 43;
        } else {
          {
#line 134
          __cil_tmp10 = memcmp(ptr + 21, "Info", (unsigned long )4);
          }
          {
#line 134
          __cil_tmp9 = memcmp(ptr + 21, "Xing", (unsigned long )4);
          }
#line 134
          if (! __cil_tmp9) {
#line 135
            ptr += 28;
          } else
#line 134
          if (! __cil_tmp10) {
#line 135
            ptr += 28;
          }
        }
#line 138
        flags = *ptr;
#line 140
        if ((int )flags & 1) {
          {
#line 141
          frame_count = unpackN((u32_t *)(ptr + 1));
#line 142
          ptr += 4;
          }
        }
#line 144
        if ((int )flags & 2) {
#line 144
          ptr += 4;
        }
#line 145
        if ((int )flags & 4) {
#line 145
          ptr += 100;
        }
#line 146
        if ((int )flags & 8) {
#line 146
          ptr += 4;
        }
        {
#line 148
        __cil_tmp12 = memcmp(ptr + 1, "LAME\301U", (unsigned long )4);
        }
#line 148
        if (! (! __cil_tmp12)) {
#line 149
          return;
        }
#line 152
        ptr += 22;
#line 154
        enc_delay = (u32_t )((((int )*ptr << 4) | ((int )*(ptr + 1) >> 4)) + 529);
#line 155
        enc_padding = (u32_t )((((int )*(ptr + 1) & 15) << 8) | (int )*(ptr + 2));
#line 156
        if (enc_padding > 529U) {
#line 156
          tmp = enc_padding - 529U;
        } else {
#line 156
          tmp = (unsigned int )0;
        }
#line 156
        enc_padding = tmp;
#line 159
        m___0->skip = enc_delay + 1152U;
#line 160
        m___0->samples = (u64_t )((frame_count * 1152U - enc_delay) - enc_padding);
#line 161
        m___0->padding = enc_padding;
#line 163
        if ((unsigned int )loglevel >= 2U) {
          {
#line 163
          __cil_tmp14 = logtime();
#line 163
          logprint("%s %s:%d gapless: skip: %u samples: %lu delay: %u padding: %u\n",
                   __cil_tmp14, "_check_lame_header", 163, m___0->skip, m___0->samples,
                   enc_delay, enc_padding);
          }
        }
      }
    }
  }
  return;
}
}
#line 167 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static decode_state mad_decode(void) 
{ 
  size_t bytes ;
  int eos ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int tmp ;
  unsigned int __cil_tmp8 ;
  u32_t consume ;
  unsigned long tmp___0 ;
  char const   *__cil_tmp11 ;
  size_t tmp___1 ;
  unsigned int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  size_t frames ;
  s32_t *iptrl ;
  s32_t *iptrr ;
  unsigned int max_frames ;
  int __cil_tmp19 ;
  decode_state ret ;
  char const   *__cil_tmp21 ;
  char const   *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char const   *__cil_tmp24 ;
  char const   *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  char const   *__cil_tmp28 ;
  u32_t skip ;
  unsigned long tmp___2 ;
  char const   *__cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char const   *__cil_tmp33 ;
  char const   *__cil_tmp34 ;
  size_t f___0 ;
  size_t count ;
  s32_t *optr ;
  unsigned int __cil_tmp38 ;
  unsigned int __cil_tmp39 ;
  size_t tmp___3 ;
  size_t __cil_tmp41 ;
  s32_t *__cil_tmp42 ;
  s32_t *__cil_tmp43 ;
  s32_t __cil_tmp44 ;
  s32_t *__cil_tmp45 ;
  s32_t *__cil_tmp46 ;
  s32_t __cil_tmp47 ;
  int tmp___4 ;

  {
  {
#line 169
  eos = 0;
#line 171
  pthread_mutex_lock(& streambuf->mutex);
#line 172
  __cil_tmp4 = _buf_cont_read(streambuf);
  }
  {
#line 172
  __cil_tmp3 = _buf_used(streambuf);
  }
#line 172
  if (__cil_tmp3 < __cil_tmp4) {
    {
#line 172
    __cil_tmp5 = _buf_used(streambuf);
#line 172
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 172
    __cil_tmp6 = _buf_cont_read(streambuf);
#line 172
    tmp = __cil_tmp6;
    }
  }
#line 172
  bytes = (size_t )tmp;
#line 174
  if (m___0->checktags) {
#line 175
    if (m___0->checktags == 1) {
      {
#line 176
      m___0->consume = _check_id3_tag(bytes);
#line 177
      m___0->checktags = 2;
      }
    }
#line 179
    if (m___0->consume) {
#line 180
      if ((unsigned long )m___0->consume < bytes) {
#line 180
        tmp___0 = (unsigned long )m___0->consume;
      } else {
#line 180
        tmp___0 = bytes;
      }
#line 180
      consume = (u32_t )tmp___0;
#line 181
      if ((unsigned int )loglevel >= 3U) {
        {
#line 181
        __cil_tmp11 = logtime();
#line 181
        logprint("%s %s:%d consume: %u of %u\n", __cil_tmp11, "mad_decode", 181, consume,
                 m___0->consume);
        }
      }
      {
#line 182
      _buf_inc_readp(streambuf, consume);
#line 183
      m___0->consume -= consume;
#line 184
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 185
      return ((decode_state )2);
    }
#line 187
    if (m___0->checktags == 2) {
#line 188
      if (! stream.meta_interval) {
        {
#line 189
        _check_lame_header(bytes);
        }
      }
#line 191
      m___0->checktags = 0;
    }
  }
#line 195
  if (m___0->stream.next_frame) {
#line 195
    if (m___0->readbuf_len) {
      {
#line 196
      m___0->readbuf_len -= m___0->stream.next_frame - m___0->readbuf;
#line 197
      memmove(m___0->readbuf, m___0->stream.next_frame, (unsigned long )m___0->readbuf_len);
      }
    }
  }
#line 200
  if (bytes < (unsigned long )(2048U - m___0->readbuf_len)) {
#line 200
    tmp___1 = bytes;
  } else {
#line 200
    tmp___1 = (unsigned long )(2048U - m___0->readbuf_len);
  }
  {
#line 200
  bytes = tmp___1;
#line 201
  memcpy(m___0->readbuf + m___0->readbuf_len, streambuf->readp, bytes);
#line 202
  m___0->readbuf_len += bytes;
#line 203
  _buf_inc_readp(streambuf, (unsigned int )bytes);
#line 205
  __cil_tmp13 = _buf_used(streambuf);
  }
#line 205
  if ((unsigned int )stream.state <= 1U) {
#line 205
    if (__cil_tmp13 == 0U) {
#line 206
      eos = 1;
#line 207
      if ((unsigned int )loglevel >= 3U) {
        {
#line 207
        __cil_tmp14 = logtime();
#line 207
        logprint("%s %s:%d end of stream\n", __cil_tmp14, "mad_decode", 207);
        }
      }
      {
#line 208
      memset(m___0->readbuf + m___0->readbuf_len, 0, (unsigned long )8);
#line 209
      m___0->readbuf_len += (unsigned int )8;
      }
    }
  }
  {
#line 212
  pthread_mutex_unlock(& streambuf->mutex);
#line 214
  (*(m___0->mad_stream_buffer))(& m___0->stream, (unsigned char const   *)m___0->readbuf,
                                (unsigned long )m___0->readbuf_len);
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 222
    __cil_tmp19 = (*(m___0->mad_frame_decode))(& m___0->frame, & m___0->stream);
    }
#line 222
    if (__cil_tmp19 == -1) {
#line 224
      if (! eos) {
#line 224
        if ((unsigned int )m___0->stream.error == 1U) {
#line 225
          ret = (decode_state )2;
        } else {
#line 224
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 226
      if (eos) {
#line 226
        if ((unsigned int )m___0->stream.error == 1U) {
#line 228
          ret = (decode_state )3;
        } else
#line 226
        if ((unsigned int )m___0->stream.error == 257U) {
#line 228
          ret = (decode_state )3;
        } else
#line 226
        if ((unsigned int )m___0->stream.error == 259U) {
#line 228
          ret = (decode_state )3;
        } else {
#line 226
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 229
      if (! ((unsigned int )m___0->stream.error & 65280U)) {
#line 230
        if ((unsigned int )loglevel >= 2U) {
          {
#line 230
          __cil_tmp21 = logtime();
          }
          {
#line 230
          __cil_tmp22 = (*(m___0->mad_stream_errorstr))(& m___0->stream);
#line 230
          logprint("%s %s:%d mad_frame_decode error: %s - stopping decoder\n", __cil_tmp21,
                   "mad_decode", 230, __cil_tmp22);
          }
        }
#line 231
        ret = (decode_state )3;
      } else {
#line 233
        if ((unsigned int )m___0->stream.error != (unsigned int )m___0->last_error) {
#line 235
          if ((unsigned int )loglevel >= 3U) {
            {
#line 235
            __cil_tmp23 = logtime();
            }
            {
#line 235
            __cil_tmp24 = (*(m___0->mad_stream_errorstr))(& m___0->stream);
#line 235
            logprint("%s %s:%d mad_frame_decode error: %s\n", __cil_tmp23, "mad_decode",
                     235, __cil_tmp24);
            }
          }
        }
#line 237
        ret = (decode_state )2;
      }
#line 239
      m___0->last_error = m___0->stream.error;
#line 240
      return (ret);
    }
    {
#line 243
    (*(m___0->mad_synth_frame))(& m___0->synth, & m___0->frame);
    }
#line 245
    if (decode.new_stream) {
      {
#line 246
      pthread_mutex_lock(& outputbuf->mutex);
      }
#line 247
      if ((unsigned int )loglevel >= 2U) {
        {
#line 247
        __cil_tmp25 = logtime();
#line 247
        logprint("%s %s:%d setting track_start\n", __cil_tmp25, "mad_decode", 247);
        }
      }
      {
#line 248
      output.next_sample_rate = decode_newstream(m___0->synth.pcm.samplerate, (unsigned int *)output.supported_rates);
#line 250
      output.track_start = outputbuf->writep;
      }
#line 251
      if (output.fade_mode) {
        {
#line 251
        _checkfade(1);
        }
      }
      {
#line 252
      decode.new_stream = 0;
#line 253
      pthread_mutex_unlock(& outputbuf->mutex);
      }
    }
    {
#line 256
    pthread_mutex_lock(& outputbuf->mutex);
#line 258
    __cil_tmp27 = _buf_space(outputbuf);
#line 258
    max_frames = __cil_tmp27 / 8U;
    }
#line 265
    if ((unsigned int )m___0->synth.pcm.length > max_frames) {
#line 266
      if ((unsigned int )loglevel >= 1U) {
        {
#line 266
        __cil_tmp28 = logtime();
#line 266
        logprint("%s %s:%d too many samples - dropping samples\n", __cil_tmp28, "mad_decode",
                 266);
        }
      }
#line 267
      m___0->synth.pcm.length = (unsigned short )max_frames;
    }
#line 270
    frames = (size_t )m___0->synth.pcm.length;
#line 271
    iptrl = (mad_fixed_t *)m___0->synth.pcm.samples[0];
#line 272
    iptrr = (mad_fixed_t *)m___0->synth.pcm.samples[(int )m___0->synth.pcm.channels - 1];
#line 274
    if (m___0->skip) {
#line 275
      if ((unsigned long )m___0->skip < frames) {
#line 275
        tmp___2 = (unsigned long )m___0->skip;
      } else {
#line 275
        tmp___2 = frames;
      }
#line 275
      skip = (u32_t )tmp___2;
#line 276
      if ((unsigned int )loglevel >= 3U) {
        {
#line 276
        __cil_tmp31 = logtime();
#line 276
        logprint("%s %s:%d gapless: skipping %u frames at start\n", __cil_tmp31, "mad_decode",
                 276, skip);
        }
      }
#line 277
      frames -= (unsigned long )skip;
#line 278
      m___0->skip -= skip;
#line 279
      iptrl += skip;
#line 280
      iptrr += skip;
    }
#line 283
    if (m___0->samples) {
#line 284
      if (m___0->samples < frames) {
#line 285
        if ((unsigned int )loglevel >= 3U) {
          {
#line 285
          __cil_tmp32 = logtime();
#line 285
          logprint("%s %s:%d gapless: trimming %u frames from end\n", __cil_tmp32,
                   "mad_decode", 285, frames - m___0->samples);
          }
        }
#line 286
        frames = (size_t )m___0->samples;
      }
#line 288
      m___0->samples -= frames;
#line 289
      if (m___0->samples > 0UL) {
#line 289
        if (eos) {
#line 289
          if (! ((int )*(m___0->stream.next_frame + 0) == 255 && ((int )*(m___0->stream.next_frame + 1) & 240) == 240)) {
#line 292
            if ((unsigned int )loglevel >= 3U) {
              {
#line 292
              __cil_tmp33 = logtime();
#line 292
              logprint("%s %s:%d gapless: early end - trimming padding from end\n\230",
                       __cil_tmp33, "mad_decode", 292);
              }
            }
#line 293
            if (frames >= (unsigned long )m___0->padding) {
#line 294
              frames -= (unsigned long )m___0->padding;
            } else {
#line 296
              frames = (size_t )0;
            }
#line 298
            m___0->samples = (u64_t )0;
          }
        }
      }
    }
#line 302
    if ((unsigned int )loglevel >= 4U) {
      {
#line 302
      __cil_tmp34 = logtime();
#line 302
      logprint("%s %s:%d write %u frames\n", __cil_tmp34, "mad_decode", 302, frames);
      }
    }
    {
#line 304
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 304
      if (! (frames > 0UL)) {
#line 304
        goto while_break___0;
      }
      {
#line 308
      __cil_tmp38 = _buf_cont_write(outputbuf);
      }
#line 308
      if (frames < (unsigned long )(__cil_tmp38 / 8U)) {
#line 308
        tmp___3 = frames;
      } else {
        {
#line 308
        __cil_tmp39 = _buf_cont_write(outputbuf);
#line 308
        tmp___3 = (unsigned long )(__cil_tmp39 / 8U);
        }
      }
#line 308
      f___0 = tmp___3;
#line 308
      optr = (s32_t *)outputbuf->writep;
#line 317
      count = f___0;
      {
#line 319
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 319
        __cil_tmp41 = count;
#line 319
        count --;
#line 319
        if (! __cil_tmp41) {
#line 319
          goto while_break___1;
        }
        {
#line 320
        __cil_tmp43 = iptrl;
#line 320
        iptrl ++;
#line 320
        __cil_tmp44 = scale(*__cil_tmp43);
        }
        {
#line 320
        __cil_tmp42 = optr;
#line 320
        optr ++;
#line 320
        *__cil_tmp42 = __cil_tmp44;
#line 321
        __cil_tmp46 = iptrr;
#line 321
        iptrr ++;
#line 321
        __cil_tmp47 = scale(*__cil_tmp46);
        }
#line 321
        __cil_tmp45 = optr;
#line 321
        optr ++;
#line 321
        *__cil_tmp45 = __cil_tmp47;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 324
      frames -= f___0;
#line 326
      _buf_inc_writep(outputbuf, (unsigned int )(f___0 * 8UL));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 334
    pthread_mutex_unlock(& outputbuf->mutex);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (eos) {
#line 337
    tmp___4 = 3;
  } else {
#line 337
    tmp___4 = 2;
  }
#line 337
  return ((decode_state )tmp___4);
}
}
#line 340 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static void mad_open(u8_t size , u8_t rate , u8_t chan , u8_t endianness ) 
{ 
  void *__cil_tmp5 ;

  {
#line 341
  if (! m___0->readbuf) {
    {
#line 342
    m___0->readbuf = (u8_t *)malloc((unsigned long )2056);
    }
  }
  {
#line 344
  m___0->checktags = 1;
#line 345
  m___0->consume = (u32_t )0;
#line 346
  m___0->skip = (u32_t )529;
#line 347
  m___0->samples = (u64_t )0;
#line 348
  m___0->readbuf_len = (unsigned int )0;
#line 349
  m___0->last_error = (enum mad_error )0;
#line 352
  (*(m___0->mad_stream_finish))(& m___0->stream);
#line 353
  (*(m___0->mad_frame_finish))(& m___0->frame);
#line 356
  (*(m___0->mad_stream_init))(& m___0->stream);
#line 357
  (*(m___0->mad_frame_init))(& m___0->frame);
#line 358
  (*(m___0->mad_synth_init))(& m___0->synth);
  }
  return;
}
}
#line 361 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static void mad_close(void) 
{ 


  {
  {
#line 363
  (*(m___0->mad_frame_finish))(& m___0->frame);
#line 364
  (*(m___0->mad_stream_finish))(& m___0->stream);
#line 365
  free(m___0->readbuf);
#line 366
  m___0->readbuf = (u8_t *)((void *)0);
  }
  return;
}
}
#line 369 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
static int load_mad(void) 
{ 
  void *handle ;
  void *__cil_tmp2 ;
  char *err ;
  char const   *__cil_tmp4 ;
  char *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;

  {
  {
#line 371
  __cil_tmp2 = dlopen("libmad.so.0", 2);
#line 371
  handle = __cil_tmp2;
  }
#line 374
  if (! handle) {
#line 375
    if ((unsigned int )loglevel >= 2U) {
      {
#line 375
      __cil_tmp4 = logtime();
      }
      {
#line 375
      __cil_tmp5 = dlerror();
#line 375
      logprint("%s %s:%d dlerror: %s\n", __cil_tmp4, "load_mad\312\001D", 375, __cil_tmp5);
      }
    }
#line 376
    return (0);
  }
  {
#line 379
  m___0->mad_stream_init = (void (*)(struct mad_stream * ))dlsym(handle, "mad_stream_init");
#line 380
  m___0->mad_frame_init = (void (*)(struct mad_frame * ))dlsym(handle, "mad_frame_init");
#line 381
  m___0->mad_synth_init = (void (*)(struct mad_synth * ))dlsym(handle, "mad_synth_init");
#line 382
  m___0->mad_frame_finish = (void (*)(struct mad_frame * ))dlsym(handle, "mad_frame_finish\220");
#line 383
  m___0->mad_stream_finish = (void (*)(struct mad_stream * ))dlsym(handle, "mad_stream_finish\245\372e\301U");
#line 384
  m___0->mad_stream_buffer = (void (*)(struct mad_stream * , unsigned char const   * ,
                                       unsigned long  ))dlsym(handle, "mad_stream_buffer\247\372e\301U");
#line 385
  m___0->mad_frame_decode = (int (*)(struct mad_frame * , struct mad_stream * ))dlsym(handle,
                                                                                      "mad_frame_decode\220");
#line 386
  m___0->mad_synth_frame = (void (*)(struct mad_synth * , struct mad_frame * ))dlsym(handle,
                                                                                     "mad_synth_frame");
#line 387
  m___0->mad_stream_errorstr = (char const   *(*)(struct mad_stream * ))dlsym(handle,
                                                                              "mad_stream_errorstre\301U");
#line 389
  err = dlerror();
  }
#line 389
  if (err != (void *)0) {
#line 390
    if ((unsigned int )loglevel >= 2U) {
      {
#line 390
      __cil_tmp16 = logtime();
#line 390
      logprint("%s %s:%d dlerror: %s\n", __cil_tmp16, "load_mad\312\001D", 390, err);
      }
    }
#line 391
    return (0);
  }
#line 394
  if ((unsigned int )loglevel >= 2U) {
    {
#line 394
    __cil_tmp17 = logtime();
#line 394
    logprint("%s %s:%d loaded libmad.so.0\n\230", __cil_tmp17, "load_mad\312\001\304e\356\275\003",
             394);
    }
  }
#line 397
  return (1);
}
}
#line 400 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/mad.c"
struct codec *register_mad(void) 
{ 
  static struct codec ret ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
#line 401
  ret.id = (char )'m';
#line 401
  ret.types = "mp3";
#line 401
  ret.min_read_bytes = (unsigned int )2048;
#line 401
  ret.min_space = (unsigned int )206800;
#line 401
  ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& mad_open);
#line 401
  ret.close = (void (*)(void))(& mad_close);
  {
#line 401
  ret.decode = (enum __anonenum__74 (*)(void))(& mad_decode);
#line 411
  m___0 = (struct mad *)calloc((unsigned long )1, sizeof(struct mad ));
  }
#line 412
  if (! m___0) {
#line 413
    return ((struct codec *)((void *)0));
  }
  {
#line 416
  m___0->readbuf = (u8_t *)((void *)0);
#line 417
  m___0->readbuf_len = (unsigned int )0;
#line 419
  __cil_tmp3 = load_mad();
  }
#line 419
  if (! __cil_tmp3) {
#line 420
    return ((struct codec *)((void *)0));
  }
#line 423
  if ((unsigned int )loglevel >= 2U) {
    {
#line 423
    __cil_tmp4 = logtime();
#line 423
    logprint("%s %s:%d using mad to decode mp3\n", __cil_tmp4, "register_mad", 423);
    }
  }
#line 424
  return (& ret);
}
}
#line 41 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
int pcm_check_header  =    0;
#line 65 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
static u32_t sample_rates[19]  = 
#line 65
  {      (u32_t )11025,      (u32_t )22050,      (u32_t )32000,      (u32_t )44100, 
        (u32_t )48000,      (u32_t )8000,      (u32_t )12000,      (u32_t )16000, 
        (u32_t )24000,      (u32_t )96000,      (u32_t )88200,      (u32_t )176400, 
        (u32_t )192000,      (u32_t )352800,      (u32_t )384000,      (u32_t )705600, 
        (u32_t )768000,      (u32_t )1411200,      (u32_t )1536000};
#line 69
static u32_t sample_rate ;
#line 70
static u32_t sample_size ;
#line 71
static u32_t channels ;
#line 72
static int bigendian ;
#line 73
static int limit ;
#line 74
static u32_t audio_left ;
#line 75
static u32_t bytes_per_frame ;
#line 79 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
static void _check_header(void) 
{ 
  u8_t *ptr ;
  unsigned int bytes ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int tmp ;
  header_format format ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char id[5] ;
  unsigned int len ;
  char const   *__cil_tmp18 ;
  int __cil_tmp19 ;
  char const   *__cil_tmp20 ;
  char const   *__cil_tmp21 ;
  int __cil_tmp22 ;
  unsigned int offset ;
  char const   *__cil_tmp24 ;
  int __cil_tmp25 ;
  char const   *__cil_tmp26 ;
  int __cil_tmp27 ;
  int exponent ;
  char const   *__cil_tmp29 ;
  char const   *__cil_tmp30 ;
  char const   *__cil_tmp31 ;

  {
  {
#line 80
  ptr = streambuf->readp;
#line 81
  __cil_tmp4 = _buf_cont_read(streambuf);
  }
  {
#line 81
  __cil_tmp3 = _buf_used(streambuf);
  }
#line 81
  if (__cil_tmp3 < __cil_tmp4) {
    {
#line 81
    __cil_tmp5 = _buf_used(streambuf);
#line 81
    tmp = __cil_tmp5;
    }
  } else {
    {
#line 81
    __cil_tmp6 = _buf_cont_read(streambuf);
#line 81
    tmp = __cil_tmp6;
    }
  }
#line 81
  bytes = tmp;
#line 82
  format = (header_format )0;
#line 86
  if (bytes > 12U) {
    {
#line 87
    __cil_tmp10 = memcmp(ptr + 8, "WAVE", (unsigned long )4);
    }
    {
#line 87
    __cil_tmp9 = memcmp(ptr, "RIFF", (unsigned long )4);
    }
#line 87
    if (! __cil_tmp9) {
#line 87
      if (! __cil_tmp10) {
#line 88
        if ((unsigned int )loglevel >= 2U) {
          {
#line 88
          __cil_tmp11 = logtime();
#line 88
          logprint("%s %s:%d WAVE\n", __cil_tmp11, "_check_header", 88);
          }
        }
#line 89
        format = (header_format )1;
      } else {
#line 87
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 90
      __cil_tmp14 = memcmp(ptr + 8, "AIFC", (unsigned long )4);
      }
      {
#line 90
      __cil_tmp13 = memcmp(ptr + 8, "AIFF", (unsigned long )4);
      }
      {
#line 90
      __cil_tmp12 = memcmp(ptr, "FORM", (unsigned long )4);
      }
#line 90
      if (! __cil_tmp12) {
#line 90
        if (! __cil_tmp13) {
          _L: /* CIL Label */ 
#line 91
          if ((unsigned int )loglevel >= 2U) {
            {
#line 91
            __cil_tmp15 = logtime();
#line 91
            logprint("%s %s:%d AIFF\n", __cil_tmp15, "_check_header", 91);
            }
          }
#line 92
          format = (header_format )2;
        } else
#line 90
        if (! __cil_tmp14) {
#line 90
          goto _L;
        }
      }
    }
  }
#line 96
  if ((unsigned int )format != 0U) {
#line 97
    ptr += 12;
#line 98
    bytes -= (unsigned int )12;
    {
#line 100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 100
      if (! (bytes >= 8U)) {
#line 100
        goto while_break;
      }
      {
#line 103
      memcpy((char *)id, ptr, (unsigned long )4);
#line 104
      id[4] = (char )'\000';
      }
#line 106
      if ((unsigned int )format == 1U) {
#line 107
        len = (unsigned int )((((int )*(ptr + 4) | ((int )*(ptr + 5) << 8)) | ((int )*(ptr + 6) << 16)) | ((int )*(ptr + 7) << 24));
      } else {
#line 109
        len = (unsigned int )(((((int )*(ptr + 4) << 24) | ((int )*(ptr + 5) << 16)) | ((int )*(ptr + 6) << 8)) | (int )*(ptr + 7));
      }
#line 112
      if ((unsigned int )loglevel >= 2U) {
        {
#line 112
        __cil_tmp18 = logtime();
#line 112
        logprint("%s %s:%d header: %s len: %d\n", __cil_tmp18, "_check_header", 112,
                 (char *)id, len);
        }
      }
      {
#line 114
      __cil_tmp19 = memcmp(ptr, "data", (unsigned long )4);
      }
#line 114
      if ((unsigned int )format == 1U) {
#line 114
        if (! __cil_tmp19) {
          {
#line 115
          ptr += 8;
#line 116
          _buf_inc_readp(streambuf, (unsigned int )(ptr - streambuf->readp));
#line 117
          audio_left = len;
          }
#line 119
          if (audio_left == 4294967295U) {
            _L___4: /* CIL Label */ 
#line 120
            if ((unsigned int )loglevel >= 2U) {
              {
#line 120
              __cil_tmp20 = logtime();
#line 120
              logprint("%s %s:%d wav audio size unknown: %u\n", __cil_tmp20, "_check_header",
                       120, audio_left);
              }
            }
#line 121
            limit = 0;
          } else
#line 119
          if (audio_left == 2147479548U) {
#line 119
            goto _L___4;
          } else {
#line 123
            if ((unsigned int )loglevel >= 2U) {
              {
#line 123
              __cil_tmp21 = logtime();
#line 123
              logprint("%s %s:%d wav audio size: %u\n", __cil_tmp21, "_check_header",
                       123, audio_left);
              }
            }
#line 124
            limit = 1;
          }
#line 126
          return;
        }
      }
      {
#line 129
      __cil_tmp22 = memcmp(ptr, "SSND", (unsigned long )4);
      }
#line 129
      if ((unsigned int )format == 2U) {
#line 129
        if (! __cil_tmp22) {
#line 129
          if (bytes >= 16U) {
            {
#line 130
            offset = (unsigned int )(((((int )*(ptr + 8) << 24) | ((int )*(ptr + 9) << 16)) | ((int )*(ptr + 10) << 8)) | (int )*(ptr + 11));
#line 132
            ptr += 16;
#line 133
            _buf_inc_readp(streambuf, (unsigned int )((ptr + offset) - streambuf->readp));
            }
#line 137
            if ((unsigned int )stream.state == 4U) {
#line 138
              audio_left = (len - 8U) - offset;
#line 139
              if ((unsigned int )loglevel >= 2U) {
                {
#line 139
                __cil_tmp24 = logtime();
#line 139
                logprint("%s %s:%d aif audio size: %u\n", __cil_tmp24, "_check_header",
                         139, audio_left);
                }
              }
#line 140
              limit = 1;
            }
#line 142
            return;
          }
        }
      }
      {
#line 145
      __cil_tmp25 = memcmp(ptr, "fmt ", (unsigned long )4);
      }
#line 145
      if ((unsigned int )format == 1U) {
#line 145
        if (! __cil_tmp25) {
#line 145
          if (bytes >= 24U) {
#line 147
            channels = (u32_t )((int )*(ptr + 10) | ((int )*(ptr + 11) << 8));
#line 148
            sample_rate = (u32_t )((((int )*(ptr + 12) | ((int )*(ptr + 13) << 8)) | ((int )*(ptr + 14) << 16)) | ((int )*(ptr + 15) << 24));
#line 149
            sample_size = (u32_t )(((int )*(ptr + 22) | ((int )*(ptr + 23) << 8)) / 8);
#line 150
            bigendian = 0;
#line 151
            if ((unsigned int )loglevel >= 2U) {
              {
#line 151
              __cil_tmp26 = logtime();
#line 151
              logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n",
                       __cil_tmp26, "_check_header", 151, sample_size, sample_rate,
                       channels, bigendian);
              }
            }
          }
        }
      }
      {
#line 154
      __cil_tmp27 = memcmp(ptr, "COMM", (unsigned long )4);
      }
#line 154
      if ((unsigned int )format == 2U) {
#line 154
        if (! __cil_tmp27) {
#line 154
          if (bytes >= 26U) {
#line 157
            channels = (u32_t )(((int )*(ptr + 8) << 8) | (int )*(ptr + 9));
#line 158
            sample_size = (u32_t )((((int )*(ptr + 14) << 8) | (int )*(ptr + 15)) / 8);
#line 159
            bigendian = 1;
#line 162
            exponent = (((((int )*(ptr + 16) & 127) << 8) | (int )*(ptr + 17)) - 16383) - 31;
#line 163
            sample_rate = (u32_t )(((((int )*(ptr + 18) << 24) | ((int )*(ptr + 19) << 16)) | ((int )*(ptr + 20) << 8)) | (int )*(ptr + 21));
            {
#line 164
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 164
              if (! (exponent < 0)) {
#line 164
                goto while_break___0;
              }
#line 164
              sample_rate >>= 1;
#line 164
              exponent ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 165
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 165
              if (! (exponent > 0)) {
#line 165
                goto while_break___1;
              }
#line 165
              sample_rate <<= 1;
#line 165
              exponent --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 166
            if ((unsigned int )loglevel >= 2U) {
              {
#line 166
              __cil_tmp29 = logtime();
#line 166
              logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n",
                       __cil_tmp29, "_check_header", 166, sample_size, sample_rate,
                       channels, bigendian);
              }
            }
          }
        }
      }
#line 169
      if (bytes >= len + 8U) {
#line 170
        ptr += len + 8U;
#line 171
        bytes -= len + 8U;
      } else {
#line 173
        if ((unsigned int )loglevel >= 1U) {
          {
#line 173
          __cil_tmp30 = logtime();
#line 173
          logprint("%s %s:%d run out of data\n", __cil_tmp30, "_check_header", 173);
          }
        }
#line 174
        return;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 179
  if ((unsigned int )loglevel >= 1U) {
    {
#line 179
    __cil_tmp31 = logtime();
#line 179
    logprint("%s %s:%d unknown format - can\'t parse header\n", __cil_tmp31, "_check_header",
             179);
    }
  }
  return;
}
}
#line 183 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
static decode_state pcm_decode(void) 
{ 
  unsigned int bytes ;
  unsigned int in ;
  unsigned int out ;
  frames_t frames ;
  frames_t count ;
  u32_t *optr ;
  u8_t *iptr ;
  u8_t tmp[24] ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int tmp___5 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int tmp___6 ;
  char const   *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int tmp___7 ;
  frames_t tmp___8 ;
  char const   *__cil_tmp24 ;
  frames_t __cil_tmp25 ;
  u32_t *__cil_tmp26 ;
  u8_t *__cil_tmp27 ;
  frames_t __cil_tmp28 ;
  u32_t *__cil_tmp29 ;
  frames_t __cil_tmp30 ;
  u32_t *__cil_tmp31 ;
  frames_t __cil_tmp32 ;
  u32_t *__cil_tmp33 ;
  frames_t __cil_tmp34 ;
  u32_t *__cil_tmp35 ;
  frames_t __cil_tmp36 ;
  u32_t *__cil_tmp37 ;
  frames_t __cil_tmp38 ;
  u32_t *__cil_tmp39 ;
  frames_t __cil_tmp40 ;
  u8_t *__cil_tmp41 ;
  frames_t __cil_tmp42 ;
  frames_t __cil_tmp43 ;
  frames_t __cil_tmp44 ;
  frames_t __cil_tmp45 ;
  frames_t __cil_tmp46 ;
  u32_t *__cil_tmp47 ;
  frames_t __cil_tmp48 ;
  u32_t *__cil_tmp49 ;
  char const   *__cil_tmp50 ;
  char const   *__cil_tmp51 ;

  {
  {
#line 190
  pthread_mutex_lock(& streambuf->mutex);
  }
#line 192
  if (decode.new_stream) {
#line 192
    if ((unsigned int )stream.state == 4U) {
      {
      {
#line 193
      _check_header();
      }
      }
    } else
#line 192
    if (pcm_check_header) {
      {
      {
#line 193
      _check_header();
      }
      }
    }
  }
  {
#line 196
  pthread_mutex_lock(& outputbuf->mutex);
#line 198
  __cil_tmp10 = _buf_cont_read(streambuf);
  }
  {
#line 198
  __cil_tmp9 = _buf_used(streambuf);
  }
#line 198
  if (__cil_tmp9 < __cil_tmp10) {
    {
#line 198
    __cil_tmp11 = _buf_used(streambuf);
#line 198
    tmp___5 = __cil_tmp11;
    }
  } else {
    {
#line 198
    __cil_tmp12 = _buf_cont_read(streambuf);
#line 198
    tmp___5 = __cil_tmp12;
    }
  }
  {
#line 198
  bytes = tmp___5;
#line 200
  __cil_tmp15 = _buf_cont_write(outputbuf);
  }
  {
#line 200
  __cil_tmp14 = _buf_space(outputbuf);
  }
#line 200
  if (__cil_tmp14 < __cil_tmp15) {
    {
#line 200
    __cil_tmp16 = _buf_space(outputbuf);
#line 200
    tmp___6 = __cil_tmp16;
    }
  } else {
    {
#line 200
    __cil_tmp17 = _buf_cont_write(outputbuf);
#line 200
    tmp___6 = __cil_tmp17;
    }
  }
#line 200
  out = tmp___6 / 8U;
#line 207
  if ((unsigned int )stream.state <= 1U) {
#line 207
    if (bytes < bytes_per_frame) {
      {
      {
#line 208
      pthread_mutex_unlock(& outputbuf->mutex);
      }
      {
#line 209
      pthread_mutex_unlock(& streambuf->mutex);
      }
      }
#line 210
      return ((decode_state )3);
    } else {
#line 207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 207
  if (limit) {
#line 207
    if (audio_left == 0U) {
      {
      {
#line 208
      pthread_mutex_unlock(& outputbuf->mutex);
      }
      {
#line 209
      pthread_mutex_unlock(& streambuf->mutex);
      }
      }
#line 210
      return ((decode_state )3);
    }
  }
#line 213
  if (decode.new_stream) {
#line 214
    if ((unsigned int )loglevel >= 2U) {
      {
#line 214
      __cil_tmp19 = logtime();
#line 214
      logprint("%s %s:%d setting track_start\nU", __cil_tmp19, "pcm_decode", 214);
      }
    }
    {
#line 216
    output.track_start = outputbuf->writep;
#line 217
    decode.new_stream = 0;
#line 236
    output.next_sample_rate = decode_newstream(sample_rate, (unsigned int *)output.supported_rates);
    }
#line 237
    if (output.fade_mode) {
      {
#line 237
      _checkfade(1);
      }
    }
#line 243
    bytes_per_frame = channels * sample_size;
  }
  {
#line 246
  optr = (u32_t *)outputbuf->writep;
#line 252
  iptr = (u8_t *)streambuf->readp;
#line 254
  in = bytes / bytes_per_frame;
#line 258
  __cil_tmp21 = _buf_used(streambuf);
  }
#line 258
  if (in == 0U) {
#line 258
    if (bytes > 0U) {
#line 258
      if (__cil_tmp21 >= bytes_per_frame) {
        {
#line 259
        memcpy((u8_t *)tmp, iptr, (unsigned long )bytes);
#line 260
        memcpy((u8_t *)tmp + bytes, streambuf->buf, (unsigned long )(bytes_per_frame - bytes));
#line 261
        iptr = (u8_t *)tmp;
#line 262
        in = (unsigned int )1;
        }
      }
    }
  }
#line 265
  if (in < out) {
#line 265
    tmp___7 = in;
  } else {
#line 265
    tmp___7 = out;
  }
#line 265
  frames = tmp___7;
#line 266
  if (frames < 4096U) {
#line 266
    tmp___8 = frames;
  } else {
#line 266
    tmp___8 = (unsigned int )4096;
  }
#line 266
  frames = tmp___8;
#line 268
  if (limit) {
#line 268
    if (frames * bytes_per_frame > audio_left) {
#line 269
      if ((unsigned int )loglevel >= 2U) {
        {
#line 269
        __cil_tmp24 = logtime();
#line 269
        logprint("%s %s:%d reached end of audio\n", __cil_tmp24, "pcm_decode", 269);
        }
      }
#line 270
      frames = audio_left / bytes_per_frame;
    }
  }
#line 273
  count = frames * channels;
#line 275
  if (channels == 2U) {
#line 276
    if (sample_size == 1U) {
      {
#line 277
      while (1) {
        while_continue: /* CIL Label */ ;
#line 277
        __cil_tmp25 = count;
#line 277
        count --;
#line 277
        if (! __cil_tmp25) {
#line 277
          goto while_break;
        }
#line 278
        __cil_tmp27 = iptr;
#line 278
        iptr ++;
#line 278
        __cil_tmp26 = optr;
#line 278
        optr ++;
#line 278
        *__cil_tmp26 = (u32_t )((int )*__cil_tmp27 << 24);
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 280
    if (sample_size == 2U) {
#line 281
      if (bigendian) {
        {
#line 286
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 286
          __cil_tmp28 = count;
#line 286
          count --;
#line 286
          if (! __cil_tmp28) {
#line 286
            goto while_break___0;
          }
#line 287
          __cil_tmp29 = optr;
#line 287
          optr ++;
#line 287
          *__cil_tmp29 = (u32_t )(((int )*iptr << 24) | ((int )*(iptr + 1) << 16));
#line 288
          iptr += 2;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 296
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 296
          __cil_tmp30 = count;
#line 296
          count --;
#line 296
          if (! __cil_tmp30) {
#line 296
            goto while_break___1;
          }
#line 297
          __cil_tmp31 = optr;
#line 297
          optr ++;
#line 297
          *__cil_tmp31 = (u32_t )(((int )*iptr << 16) | ((int )*(iptr + 1) << 24));
#line 298
          iptr += 2;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else
#line 302
    if (sample_size == 3U) {
#line 303
      if (bigendian) {
        {
#line 304
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 304
          __cil_tmp32 = count;
#line 304
          count --;
#line 304
          if (! __cil_tmp32) {
#line 304
            goto while_break___2;
          }
#line 308
          __cil_tmp33 = optr;
#line 308
          optr ++;
#line 308
          *__cil_tmp33 = (u32_t )((((int )*iptr << 24) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 8));
#line 310
          iptr += 3;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 313
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 313
          __cil_tmp34 = count;
#line 313
          count --;
#line 313
          if (! __cil_tmp34) {
#line 313
            goto while_break___3;
          }
#line 317
          __cil_tmp35 = optr;
#line 317
          optr ++;
#line 317
          *__cil_tmp35 = (u32_t )((((int )*iptr << 8) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 24));
#line 319
          iptr += 3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    } else
#line 322
    if (sample_size == 4U) {
#line 323
      if (bigendian) {
        {
#line 324
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 324
          __cil_tmp36 = count;
#line 324
          count --;
#line 324
          if (! __cil_tmp36) {
#line 324
            goto while_break___4;
          }
#line 328
          __cil_tmp37 = optr;
#line 328
          optr ++;
#line 328
          *__cil_tmp37 = (u32_t )(((((int )*iptr << 24) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 8)) | (int )*(iptr + 3));
#line 330
          iptr += 4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 333
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 333
          __cil_tmp38 = count;
#line 333
          count --;
#line 333
          if (! __cil_tmp38) {
#line 333
            goto while_break___5;
          }
#line 337
          __cil_tmp39 = optr;
#line 337
          optr ++;
#line 337
          *__cil_tmp39 = (u32_t )((((int )*iptr | ((int )*(iptr + 1) << 8)) | ((int )*(iptr + 2) << 16)) | ((int )*(iptr + 3) << 24));
#line 339
          iptr += 4;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  } else
#line 343
  if (channels == 1U) {
#line 344
    if (sample_size == 1U) {
      {
#line 345
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 345
        __cil_tmp40 = count;
#line 345
        count --;
#line 345
        if (! __cil_tmp40) {
#line 345
          goto while_break___6;
        }
#line 346
        __cil_tmp41 = iptr;
#line 346
        iptr ++;
#line 346
        *optr = (u32_t )((int )*__cil_tmp41 << 24);
#line 347
        *(optr + 1) = *optr;
#line 348
        optr += 2;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 350
    if (sample_size == 2U) {
#line 351
      if (bigendian) {
        {
#line 352
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 352
          __cil_tmp42 = count;
#line 352
          count --;
#line 352
          if (! __cil_tmp42) {
#line 352
            goto while_break___7;
          }
#line 353
          *optr = (u32_t )(((int )*iptr << 24) | ((int )*(iptr + 1) << 16));
#line 354
          *(optr + 1) = *optr;
#line 355
          iptr += 2;
#line 356
          optr += 2;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 359
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 359
          __cil_tmp43 = count;
#line 359
          count --;
#line 359
          if (! __cil_tmp43) {
#line 359
            goto while_break___8;
          }
#line 360
          *optr = (u32_t )(((int )*iptr << 16) | ((int )*(iptr + 1) << 24));
#line 361
          *(optr + 1) = *optr;
#line 362
          iptr += 2;
#line 363
          optr += 2;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    } else
#line 366
    if (sample_size == 3U) {
#line 367
      if (bigendian) {
        {
#line 368
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 368
          __cil_tmp44 = count;
#line 368
          count --;
#line 368
          if (! __cil_tmp44) {
#line 368
            goto while_break___9;
          }
#line 372
          *optr = (u32_t )((((int )*iptr << 24) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 8));
#line 374
          *(optr + 1) = *optr;
#line 375
          iptr += 3;
#line 376
          optr += 2;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
        {
#line 379
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 379
          __cil_tmp45 = count;
#line 379
          count --;
#line 379
          if (! __cil_tmp45) {
#line 379
            goto while_break___10;
          }
#line 383
          *optr = (u32_t )((((int )*iptr << 8) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 24));
#line 385
          *(optr + 1) = *optr;
#line 386
          iptr += 3;
#line 387
          optr += 2;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    } else
#line 390
    if (sample_size == 4U) {
#line 391
      if (bigendian) {
        {
#line 392
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 392
          __cil_tmp46 = count;
#line 392
          count --;
#line 392
          if (! __cil_tmp46) {
#line 392
            goto while_break___11;
          }
#line 396
          __cil_tmp47 = optr;
#line 396
          optr ++;
#line 396
          *__cil_tmp47 = (u32_t )(((((int )*iptr << 24) | ((int )*(iptr + 1) << 16)) | ((int )*(iptr + 2) << 8)) | (int )*(iptr + 3));
#line 398
          *(optr + 1) = *optr;
#line 399
          iptr += 4;
#line 400
          optr += 2;
        }
        while_break___11: /* CIL Label */ ;
        }
      } else {
        {
#line 403
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 403
          __cil_tmp48 = count;
#line 403
          count --;
#line 403
          if (! __cil_tmp48) {
#line 403
            goto while_break___12;
          }
#line 407
          __cil_tmp49 = optr;
#line 407
          optr ++;
#line 407
          *__cil_tmp49 = (u32_t )((((int )*iptr | ((int )*(iptr + 1) << 8)) | ((int )*(iptr + 2) << 16)) | ((int )*(iptr + 3) << 24));
#line 409
          *(optr + 1) = *optr;
#line 410
          iptr += 4;
#line 411
          optr += 2;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
  } else {
    {
#line 416
    __cil_tmp50 = logtime();
#line 416
    logprint("%s %s:%d unsupported channels\n", __cil_tmp50, "pcm_decode", 416);
    }
  }
#line 419
  if ((unsigned int )loglevel >= 4U) {
    {
#line 419
    __cil_tmp51 = logtime();
#line 419
    logprint("%s %s:%d decoded %u frames\nf\301U", __cil_tmp51, "pcm_decode\031f\301U",
             419, frames);
    }
  }
  {
#line 421
  _buf_inc_readp(streambuf, frames * bytes_per_frame);
  }
#line 423
  if (limit) {
#line 424
    audio_left -= frames * bytes_per_frame;
  }
  {
#line 427
  _buf_inc_writep(outputbuf, frames * 8U);
#line 434
  pthread_mutex_unlock(& outputbuf->mutex);
#line 435
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 437
  return ((decode_state )2);
}
}
#line 440 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
static void pcm_open(u8_t size , u8_t rate , u8_t chan , u8_t endianness ) 
{ 
  char const   *__cil_tmp5 ;

  {
#line 441
  sample_size = (u32_t )(((int )size - 48) + 1);
#line 442
  sample_rate = sample_rates[(int )rate - 48];
#line 443
  channels = (u32_t )((int )chan - 48);
#line 444
  bigendian = (int )endianness == 48;
#line 445
  limit = 0;
#line 447
  if ((unsigned int )loglevel >= 2U) {
    {
#line 447
    __cil_tmp5 = logtime();
#line 447
    logprint("%s %s:%d pcm size: %u rate: %u chan: %u bigendian: %u\n", __cil_tmp5,
             "pcm_open\312\001D", 447, sample_size, sample_rate, channels, bigendian);
    }
  }
  {
#line 448
  buf_adjust(streambuf, (size_t )(sample_size * channels));
  }
  return;
}
}
#line 451 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
static void pcm_close(void) 
{ 


  {
  {
#line 452
  buf_adjust(streambuf, (size_t )1);
  }
  return;
}
}
#line 455 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/pcm.c"
struct codec *register_pcm(void) 
{ 
  static struct codec ret ;
  char const   *__cil_tmp2 ;
  static struct codec ret___0 ;
  char const   *__cil_tmp4 ;

  {
#line 456
  if (pcm_check_header) {
#line 458
    ret.id = (char )'p';
#line 458
    ret.types = "wav,aif,pcm";
#line 458
    ret.min_read_bytes = (unsigned int )4096;
#line 458
    ret.min_space = (unsigned int )102400;
#line 458
    ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& pcm_open);
#line 458
    ret.close = (void (*)(void))(& pcm_close);
#line 458
    ret.decode = (enum __anonenum__74 (*)(void))(& pcm_decode);
#line 468
    if ((unsigned int )loglevel >= 2U) {
      {
#line 468
      __cil_tmp2 = logtime();
#line 468
      logprint("%s %s:%d using pcm to decode wav,aif,pcm\n\216\031f\301U", __cil_tmp2,
               "register_pcm", 468);
      }
    }
#line 469
    return (& ret);
  } else {
#line 473
    ret___0.id = (char )'p';
#line 473
    ret___0.types = "aif,pcm";
#line 473
    ret___0.min_read_bytes = (unsigned int )4096;
#line 473
    ret___0.min_space = (unsigned int )102400;
#line 473
    ret___0.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& pcm_open);
#line 473
    ret___0.close = (void (*)(void))(& pcm_close);
#line 473
    ret___0.decode = (enum __anonenum__74 (*)(void))(& pcm_decode);
#line 483
    if ((unsigned int )loglevel >= 2U) {
      {
#line 483
      __cil_tmp4 = logtime();
#line 483
      logprint("%s %s:%d using pcm to decode aif,pcm\nU", __cil_tmp4, "register_pcm",
               483);
      }
    }
#line 484
    return (& ret___0);
  }
#line 487
  return ((struct codec *)((void *)0));
}
}
#line 89 "/usr/include/FLAC/export.h"
extern int FLAC_API_SUPPORTS_OGG_FLAC ;
#line 162 "/usr/include/FLAC/format.h"
extern char const   *FLAC__VERSION_STRING ;
#line 168
extern char const   *FLAC__VENDOR_STRING ;
#line 171
extern FLAC__byte FLAC__STREAM_SYNC_STRING[4] ;
#line 176
extern uint32_t FLAC__STREAM_SYNC ;
#line 179
extern uint32_t FLAC__STREAM_SYNC_LEN ;
#line 209
extern char const   * const  FLAC__EntropyCodingMethodTypeString[] ;
#line 243
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN ;
#line 244
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN ;
#line 245
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN ;
#line 246
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN ;
#line 248
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER ;
#line 250
extern uint32_t FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER ;
#line 262
extern uint32_t FLAC__ENTROPY_CODING_METHOD_TYPE_LEN ;
#line 279
extern char const   * const  FLAC__SubframeTypeString[] ;
#line 338
extern uint32_t FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN ;
#line 339
extern uint32_t FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN ;
#line 362
extern uint32_t FLAC__SUBFRAME_ZERO_PAD_LEN ;
#line 363
extern uint32_t FLAC__SUBFRAME_TYPE_LEN ;
#line 364
extern uint32_t FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN ;
#line 366
extern uint32_t FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK ;
#line 367
extern uint32_t FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK ;
#line 368
extern uint32_t FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK ;
#line 369
extern uint32_t FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK ;
#line 393
extern char const   * const  FLAC__ChannelAssignmentString[] ;
#line 406
extern char const   * const  FLAC__FrameNumberTypeString[] ;
#line 446
extern uint32_t FLAC__FRAME_HEADER_SYNC ;
#line 447
extern uint32_t FLAC__FRAME_HEADER_SYNC_LEN ;
#line 448
extern uint32_t FLAC__FRAME_HEADER_RESERVED_LEN ;
#line 449
extern uint32_t FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN ;
#line 450
extern uint32_t FLAC__FRAME_HEADER_BLOCK_SIZE_LEN ;
#line 451
extern uint32_t FLAC__FRAME_HEADER_SAMPLE_RATE_LEN ;
#line 452
extern uint32_t FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN ;
#line 453
extern uint32_t FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN ;
#line 454
extern uint32_t FLAC__FRAME_HEADER_ZERO_PAD_LEN ;
#line 455
extern uint32_t FLAC__FRAME_HEADER_CRC_LEN ;
#line 468
extern uint32_t FLAC__FRAME_FOOTER_CRC_LEN ;
#line 524
extern char const   * const  FLAC__MetadataTypeString[] ;
#line 539
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN ;
#line 540
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN ;
#line 541
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN ;
#line 542
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN ;
#line 543
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN ;
#line 544
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN ;
#line 545
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN ;
#line 546
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN ;
#line 547
extern uint32_t FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN ;
#line 570
extern uint32_t FLAC__STREAM_METADATA_APPLICATION_ID_LEN ;
#line 586
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN ;
#line 587
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN ;
#line 588
extern uint32_t FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN ;
#line 597
extern FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER ;
#line 629
extern uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN ;
#line 640
extern uint32_t FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN ;
#line 657
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN ;
#line 658
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN ;
#line 659
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN ;
#line 690
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN ;
#line 691
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN ;
#line 692
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN ;
#line 693
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN ;
#line 694
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN ;
#line 695
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN ;
#line 696
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN ;
#line 724
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN ;
#line 725
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN ;
#line 726
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN ;
#line 727
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN ;
#line 728
extern uint32_t FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN ;
#line 763
extern char const   * const  FLAC__StreamMetadata_Picture_TypeString[] ;
#line 813
extern uint32_t FLAC__STREAM_METADATA_PICTURE_TYPE_LEN ;
#line 814
extern uint32_t FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN ;
#line 815
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN ;
#line 816
extern uint32_t FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN ;
#line 817
extern uint32_t FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN ;
#line 818
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN ;
#line 819
extern uint32_t FLAC__STREAM_METADATA_PICTURE_COLORS_LEN ;
#line 820
extern uint32_t FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN ;
#line 860
extern uint32_t FLAC__STREAM_METADATA_IS_LAST_LEN ;
#line 861
extern uint32_t FLAC__STREAM_METADATA_TYPE_LEN ;
#line 862
extern uint32_t FLAC__STREAM_METADATA_LENGTH_LEN ;
#line 883
FLAC__bool FLAC__format_sample_rate_is_valid(uint32_t sample_rate ) ;
#line 895
FLAC__bool FLAC__format_blocksize_is_subset(uint32_t blocksize , uint32_t sample_rate ) ;
#line 906
FLAC__bool FLAC__format_sample_rate_is_subset(uint32_t sample_rate ) ;
#line 920
FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(char const   *name ) ;
#line 936
FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(FLAC__byte *value , uint32_t length ) ;
#line 953
FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(FLAC__byte *entry , uint32_t length ) ;
#line 965
FLAC__bool FLAC__format_seektable_is_legal(FLAC__StreamMetadata_SeekTable *seek_table ) ;
#line 979
uint32_t FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table ) ;
#line 999
FLAC__bool FLAC__format_cuesheet_is_legal(FLAC__StreamMetadata_CueSheet *cue_sheet ,
                                          FLAC__bool check_cd_da_subset , char const   **violation ) ;
#line 1017
FLAC__bool FLAC__format_picture_is_legal(FLAC__StreamMetadata_Picture *picture , char const   **violation ) ;
#line 251 "/usr/include/FLAC/stream_decoder.h"
extern char const   * const  FLAC__StreamDecoderStateString[] ;
#line 289
extern char const   * const  FLAC__StreamDecoderInitStatusString[] ;
#line 320
extern char const   * const  FLAC__StreamDecoderReadStatusString[] ;
#line 343
extern char const   * const  FLAC__StreamDecoderSeekStatusString[] ;
#line 366
extern char const   * const  FLAC__StreamDecoderTellStatusString[] ;
#line 389
extern char const   * const  FLAC__StreamDecoderLengthStatusString[] ;
#line 409
extern char const   * const  FLAC__StreamDecoderWriteStatusString[] ;
#line 448
extern char const   * const  FLAC__StreamDecoderErrorStatusString[] ;
#line 743
FLAC__StreamDecoder *FLAC__stream_decoder_new(void) ;
#line 751
void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder ) ;
#line 776
FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder ,
                                                      long serial_number ) ;
#line 798
FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder , FLAC__bool value ) ;
#line 812
FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder ,
                                                     FLAC__MetadataType type ) ;
#line 827
FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder ,
                                                                 FLAC__byte id[4] ) ;
#line 839
FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder ) ;
#line 853
FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder ,
                                                    FLAC__MetadataType type ) ;
#line 868
FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder ,
                                                                FLAC__byte id[4] ) ;
#line 880
FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder ) ;
#line 890
FLAC__StreamDecoderState FLAC__stream_decoder_get_state(FLAC__StreamDecoder *decoder ) ;
#line 900
char const   *FLAC__stream_decoder_get_resolved_state_string(FLAC__StreamDecoder *decoder ) ;
#line 914
FLAC__bool FLAC__stream_decoder_get_md5_checking(FLAC__StreamDecoder *decoder ) ;
#line 926
FLAC__uint64 FLAC__stream_decoder_get_total_samples(FLAC__StreamDecoder *decoder ) ;
#line 938
uint32_t FLAC__stream_decoder_get_channels(FLAC__StreamDecoder *decoder ) ;
#line 950
FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(FLAC__StreamDecoder *decoder ) ;
#line 962
uint32_t FLAC__stream_decoder_get_bits_per_sample(FLAC__StreamDecoder *decoder ) ;
#line 974
uint32_t FLAC__stream_decoder_get_sample_rate(FLAC__StreamDecoder *decoder ) ;
#line 986
uint32_t FLAC__stream_decoder_get_blocksize(FLAC__StreamDecoder *decoder ) ;
#line 1007
FLAC__bool FLAC__stream_decoder_get_decode_position(FLAC__StreamDecoder *decoder ,
                                                    FLAC__uint64 *position ) ;
#line 1073
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(FLAC__StreamDecoder *decoder ,
                                                               FLAC__StreamDecoderReadCallback read_callback ,
                                                               FLAC__StreamDecoderSeekCallback seek_callback ,
                                                               FLAC__StreamDecoderTellCallback tell_callback ,
                                                               FLAC__StreamDecoderLengthCallback length_callback ,
                                                               FLAC__StreamDecoderEofCallback eof_callback ,
                                                               FLAC__StreamDecoderWriteCallback write_callback ,
                                                               FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                               FLAC__StreamDecoderErrorCallback error_callback ,
                                                               void *client_data ) ;
#line 1154
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(FLAC__StreamDecoder *decoder ,
                                                                   FLAC__StreamDecoderReadCallback read_callback ,
                                                                   FLAC__StreamDecoderSeekCallback seek_callback ,
                                                                   FLAC__StreamDecoderTellCallback tell_callback ,
                                                                   FLAC__StreamDecoderLengthCallback length_callback ,
                                                                   FLAC__StreamDecoderEofCallback eof_callback ,
                                                                   FLAC__StreamDecoderWriteCallback write_callback ,
                                                                   FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                   FLAC__StreamDecoderErrorCallback error_callback ,
                                                                   void *client_data ) ;
#line 1204
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(FLAC__StreamDecoder *decoder ,
                                                             FILE *file , FLAC__StreamDecoderWriteCallback write_callback ,
                                                             FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                             FLAC__StreamDecoderErrorCallback error_callback ,
                                                             void *client_data ) ;
#line 1254
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(FLAC__StreamDecoder *decoder ,
                                                                 FILE *file , FLAC__StreamDecoderWriteCallback write_callback ,
                                                                 FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                 FLAC__StreamDecoderErrorCallback error_callback ,
                                                                 void *client_data ) ;
#line 1296
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(FLAC__StreamDecoder *decoder ,
                                                             char const   *filename ,
                                                             FLAC__StreamDecoderWriteCallback write_callback ,
                                                             FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                             FLAC__StreamDecoderErrorCallback error_callback ,
                                                             void *client_data ) ;
#line 1342
FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(FLAC__StreamDecoder *decoder ,
                                                                 char const   *filename ,
                                                                 FLAC__StreamDecoderWriteCallback write_callback ,
                                                                 FLAC__StreamDecoderMetadataCallback metadata_callback ,
                                                                 FLAC__StreamDecoderErrorCallback error_callback ,
                                                                 void *client_data ) ;
#line 1370
FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder ) ;
#line 1385
FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder ) ;
#line 1417
FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder ) ;
#line 1450
FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder ) ;
#line 1471
FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder ) ;
#line 1492
FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder ) ;
#line 1533
FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder ) ;
#line 1551
FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder , FLAC__uint64 sample ) ;
#line 76 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static struct flac *f ;
#line 111 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static FLAC__StreamDecoderReadStatus read_cb(FLAC__StreamDecoder *decoder , FLAC__byte buffer[] ,
                                             size_t *want , void *client_data ) 
{ 
  size_t bytes ;
  int end ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 115
  pthread_mutex_lock(& streambuf->mutex);
#line 116
  __cil_tmp8 = _buf_cont_read(streambuf);
  }
  {
#line 116
  __cil_tmp7 = _buf_used(streambuf);
  }
#line 116
  if (__cil_tmp7 < __cil_tmp8) {
    {
#line 116
    __cil_tmp9 = _buf_used(streambuf);
#line 116
    tmp = __cil_tmp9;
    }
  } else {
    {
#line 116
    __cil_tmp10 = _buf_cont_read(streambuf);
#line 116
    tmp = __cil_tmp10;
    }
  }
#line 116
  bytes = (size_t )tmp;
#line 117
  if (bytes < *want) {
#line 117
    tmp___0 = bytes;
  } else {
#line 117
    tmp___0 = *want;
  }
  {
#line 117
  bytes = tmp___0;
#line 118
  end = (int )((unsigned int )stream.state <= 1U && bytes == 0UL);
#line 120
  memcpy(buffer, streambuf->readp, bytes);
#line 121
  _buf_inc_readp(streambuf, (unsigned int )bytes);
#line 122
  pthread_mutex_unlock(& streambuf->mutex);
#line 124
  *want = bytes;
  }
#line 127
  if (! bytes) {
#line 127
    if (! end) {
      {
#line 128
      usleep((__useconds_t )1000);
      }
    }
  }
#line 130
  if (end) {
#line 130
    tmp___1 = 1;
  } else {
#line 130
    tmp___1 = 0;
  }
#line 130
  return ((FLAC__StreamDecoderReadStatus )tmp___1);
}
}
#line 133 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static FLAC__StreamDecoderWriteStatus write_cb(FLAC__StreamDecoder *decoder , FLAC__Frame *frame ,
                                               FLAC__int32 * const  buffer[] , void *client_data ) 
{ 
  size_t frames ;
  unsigned int bits_per_sample ;
  unsigned int channels___0 ;
  FLAC__int32 *lptr ;
  FLAC__int32 *rptr ;
  int tmp ;
  char const   *__cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  frames_t f___9 ;
  frames_t count ;
  s32_t *optr ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int tmp___0 ;
  unsigned long tmp___1 ;
  frames_t __cil_tmp22 ;
  s32_t *__cil_tmp23 ;
  FLAC__int32 *__cil_tmp24 ;
  s32_t *__cil_tmp25 ;
  FLAC__int32 *__cil_tmp26 ;
  frames_t __cil_tmp27 ;
  s32_t *__cil_tmp28 ;
  FLAC__int32 *__cil_tmp29 ;
  s32_t *__cil_tmp30 ;
  FLAC__int32 *__cil_tmp31 ;
  frames_t __cil_tmp32 ;
  s32_t *__cil_tmp33 ;
  FLAC__int32 *__cil_tmp34 ;
  s32_t *__cil_tmp35 ;
  FLAC__int32 *__cil_tmp36 ;
  frames_t __cil_tmp37 ;
  s32_t *__cil_tmp38 ;
  FLAC__int32 *__cil_tmp39 ;
  s32_t *__cil_tmp40 ;
  FLAC__int32 *__cil_tmp41 ;
  char const   *__cil_tmp42 ;

  {
#line 136
  frames = (size_t )frame->header.blocksize;
#line 137
  bits_per_sample = frame->header.bits_per_sample;
#line 138
  channels___0 = frame->header.channels;
#line 140
  lptr = (FLAC__int32 *)buffer[0];
#line 141
  if (channels___0 > 1U) {
#line 141
    tmp = 1;
  } else {
#line 141
    tmp = 0;
  }
#line 141
  rptr = (FLAC__int32 *)buffer[tmp];
#line 143
  if (decode.new_stream) {
    {
#line 144
    pthread_mutex_lock(& outputbuf->mutex);
    }
#line 145
    if ((unsigned int )loglevel >= 2U) {
      {
#line 145
      __cil_tmp11 = logtime();
#line 145
      logprint("%s %s:%d setting track_start\n", __cil_tmp11, "write_cb\312\001Dfw\317\003",
               145);
      }
    }
    {
#line 146
    output.track_start = outputbuf->writep;
#line 147
    decode.new_stream = 0;
#line 169
    output.next_sample_rate = decode_newstream(frame->header.sample_rate, (unsigned int *)output.supported_rates);
    }
#line 170
    if (output.fade_mode) {
      {
#line 170
      _checkfade(1);
      }
    }
    {
#line 173
    pthread_mutex_unlock(& outputbuf->mutex);
    }
  }
  {
#line 176
  pthread_mutex_lock(& outputbuf->mutex);
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (frames > 0UL)) {
#line 178
      goto while_break;
    }
    {
#line 183
    optr = (s32_t *)outputbuf->writep;
#line 183
    __cil_tmp17 = _buf_cont_write(outputbuf);
    }
    {
#line 183
    __cil_tmp16 = _buf_space(outputbuf);
    }
#line 183
    if (__cil_tmp16 < __cil_tmp17) {
      {
#line 183
      __cil_tmp18 = _buf_space(outputbuf);
#line 183
      tmp___0 = __cil_tmp18;
      }
    } else {
      {
#line 183
      __cil_tmp19 = _buf_cont_write(outputbuf);
#line 183
      tmp___0 = __cil_tmp19;
      }
    }
#line 183
    f___9 = tmp___0 / 8U;
#line 192
    if ((unsigned long )f___9 < frames) {
#line 192
      tmp___1 = (unsigned long )f___9;
    } else {
#line 192
      tmp___1 = frames;
    }
#line 192
    f___9 = (frames_t )tmp___1;
#line 194
    count = f___9;
#line 196
    if (bits_per_sample == 8U) {
      {
#line 197
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 197
        __cil_tmp22 = count;
#line 197
        count --;
#line 197
        if (! __cil_tmp22) {
#line 197
          goto while_break___0;
        }
#line 198
        __cil_tmp24 = lptr;
#line 198
        lptr ++;
#line 198
        __cil_tmp23 = optr;
#line 198
        optr ++;
#line 198
        *__cil_tmp23 = *__cil_tmp24 << 24;
#line 199
        __cil_tmp26 = rptr;
#line 199
        rptr ++;
#line 199
        __cil_tmp25 = optr;
#line 199
        optr ++;
#line 199
        *__cil_tmp25 = *__cil_tmp26 << 24;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 201
    if (bits_per_sample == 16U) {
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 202
        __cil_tmp27 = count;
#line 202
        count --;
#line 202
        if (! __cil_tmp27) {
#line 202
          goto while_break___1;
        }
#line 203
        __cil_tmp29 = lptr;
#line 203
        lptr ++;
#line 203
        __cil_tmp28 = optr;
#line 203
        optr ++;
#line 203
        *__cil_tmp28 = *__cil_tmp29 << 16;
#line 204
        __cil_tmp31 = rptr;
#line 204
        rptr ++;
#line 204
        __cil_tmp30 = optr;
#line 204
        optr ++;
#line 204
        *__cil_tmp30 = *__cil_tmp31 << 16;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 206
    if (bits_per_sample == 24U) {
      {
#line 207
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 207
        __cil_tmp32 = count;
#line 207
        count --;
#line 207
        if (! __cil_tmp32) {
#line 207
          goto while_break___2;
        }
#line 208
        __cil_tmp34 = lptr;
#line 208
        lptr ++;
#line 208
        __cil_tmp33 = optr;
#line 208
        optr ++;
#line 208
        *__cil_tmp33 = *__cil_tmp34 << 8;
#line 209
        __cil_tmp36 = rptr;
#line 209
        rptr ++;
#line 209
        __cil_tmp35 = optr;
#line 209
        optr ++;
#line 209
        *__cil_tmp35 = *__cil_tmp36 << 8;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 211
    if (bits_per_sample == 32U) {
      {
#line 212
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 212
        __cil_tmp37 = count;
#line 212
        count --;
#line 212
        if (! __cil_tmp37) {
#line 212
          goto while_break___3;
        }
#line 213
        __cil_tmp39 = lptr;
#line 213
        lptr ++;
#line 213
        __cil_tmp38 = optr;
#line 213
        optr ++;
#line 213
        *__cil_tmp38 = *__cil_tmp39;
#line 214
        __cil_tmp41 = rptr;
#line 214
        rptr ++;
#line 214
        __cil_tmp40 = optr;
#line 214
        optr ++;
#line 214
        *__cil_tmp40 = *__cil_tmp41;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 217
      __cil_tmp42 = logtime();
#line 217
      logprint("%s %s:%d unsupported bits per sample: %u\n", __cil_tmp42, "write_cb\312\001D",
               217, bits_per_sample);
      }
    }
    {
#line 220
    frames -= (unsigned long )f___9;
#line 222
    _buf_inc_writep(outputbuf, f___9 * 8U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 233
  return ((FLAC__StreamDecoderWriteStatus )0);
}
}
#line 236 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static void error_cb(FLAC__StreamDecoder *decoder , FLAC__StreamDecoderErrorStatus status___0 ,
                     void *client_data ) 
{ 
  char const   *__cil_tmp4 ;

  {
#line 237
  if ((unsigned int )loglevel >= 2U) {
    {
#line 237
    __cil_tmp4 = logtime();
#line 237
    logprint("%s %s:%d flac error: %s\n\230", __cil_tmp4, "error_cb\312\001D", 237,
             *(f->FLAC__StreamDecoderErrorStatusString + status___0));
    }
  }
  return;
}
}
#line 240 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static void flac_close(void) 
{ 


  {
  {
#line 241
  (*(f->FLAC__stream_decoder_delete))(f->decoder);
#line 242
  f->decoder = (FLAC__StreamDecoder *)((void *)0);
  }
  return;
}
}
#line 245 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static void flac_open(u8_t sample_size___0 , u8_t sample_rate___0 , u8_t channels___0 ,
                      u8_t endianness ) 
{ 
  FLAC__StreamDecoder *__cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
#line 246
  if (f->decoder) {
#line 246
    if ((int )f->container != (int )sample_size___0) {
      {
#line 247
      flac_close();
      }
    }
  }
#line 250
  f->container = sample_size___0;
#line 252
  if (f->decoder) {
    {
#line 253
    (*(f->FLAC__stream_decoder_reset))(f->decoder);
    }
  } else {
    {
#line 255
    f->decoder = (*(f->FLAC__stream_decoder_new))();
    }
  }
#line 258
  if ((int )f->container == 111) {
#line 259
    if ((unsigned int )loglevel >= 2U) {
      {
#line 259
      __cil_tmp6 = logtime();
#line 259
      logprint("%s %s:%d ogg/flac container - using init_ogg_stream\n", __cil_tmp6,
               "flac_open", 259);
      }
    }
    {
#line 260
    (*(f->FLAC__stream_decoder_init_ogg_stream))(f->decoder, & read_cb, (FLAC__StreamDecoderSeekCallback )((void *)0),
                                                 (FLAC__StreamDecoderTellCallback )((void *)0),
                                                 (FLAC__StreamDecoderLengthCallback )((void *)0),
                                                 (FLAC__StreamDecoderEofCallback )((void *)0),
                                                 & write_cb, (FLAC__StreamDecoderMetadataCallback )((void *)0),
                                                 & error_cb, (void *)0);
    }
  } else {
    {
#line 262
    (*(f->FLAC__stream_decoder_init_stream))(f->decoder, & read_cb, (FLAC__StreamDecoderSeekCallback )((void *)0),
                                             (FLAC__StreamDecoderTellCallback )((void *)0),
                                             (FLAC__StreamDecoderLengthCallback )((void *)0),
                                             (FLAC__StreamDecoderEofCallback )((void *)0),
                                             & write_cb, (FLAC__StreamDecoderMetadataCallback )((void *)0),
                                             & error_cb, (void *)0);
    }
  }
  return;
}
}
#line 266 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static decode_state flac_decode(void) 
{ 
  int ok ;
  FLAC__bool __cil_tmp2 ;
  FLAC__StreamDecoderState state ;
  FLAC__StreamDecoderState __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 267
  __cil_tmp2 = (*(f->FLAC__stream_decoder_process_single))(f->decoder);
#line 267
  ok = __cil_tmp2;
#line 268
  __cil_tmp4 = (*(f->FLAC__stream_decoder_get_state))(f->decoder);
#line 268
  state = __cil_tmp4;
  }
#line 270
  if (! ok) {
#line 270
    if ((unsigned int )state != 4U) {
#line 271
      if ((unsigned int )loglevel >= 2U) {
        {
#line 271
        __cil_tmp5 = logtime();
#line 271
        logprint("%s %s:%d flac error: %s\n\230", __cil_tmp5, "flac_decode", 271,
                 *(f->FLAC__StreamDecoderStateString + state));
        }
      }
    }
  }

#line 274
  if ((unsigned int )state == 4U) {
#line 275
    return ((decode_state )3);
  } else
#line 276
  if ((unsigned int )state > 4U) {
#line 277
    return ((decode_state )4);
  } else {
#line 279
    return ((decode_state )2);
  }
}
}
#line 283 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
static int load_flac(void) 
{ 
  void *handle ;
  void *__cil_tmp2 ;
  char *err ;
  char const   *__cil_tmp4 ;
  char *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;

  {
  {
#line 285
  __cil_tmp2 = dlopen("libFLAC.so.8\301U", 2);
#line 285
  handle = __cil_tmp2;
  }
#line 288
  if (! handle) {
#line 289
    if ((unsigned int )loglevel >= 2U) {
      {
#line 289
      __cil_tmp4 = logtime();
      }
      {
#line 289
      __cil_tmp5 = dlerror();
#line 289
      logprint("%s %s:%d dlerror: %s\nU", __cil_tmp4, "load_flac\251\337e\301U", 289,
               __cil_tmp5);
      }
    }
#line 290
    return (0);
  }
  {
#line 293
  f->FLAC__StreamDecoderErrorStatusString = (char const   **)dlsym(handle, "FLAC__StreamDecoderErrorStatusString\301U");
#line 294
  f->FLAC__StreamDecoderStateString = (char const   **)dlsym(handle, "FLAC__StreamDecoderStateString");
#line 295
  f->FLAC__stream_decoder_new = (FLAC__StreamDecoder *(*)(void))dlsym(handle, "FLAC__stream_decoder_new\220");
#line 296
  f->FLAC__stream_decoder_reset = (FLAC__bool (*)(FLAC__StreamDecoder * ))dlsym(handle,
                                                                                "FLAC__stream_decoder_reset9f\301U");
#line 297
  f->FLAC__stream_decoder_delete = (void (*)(FLAC__StreamDecoder * ))dlsym(handle,
                                                                           "FLAC__stream_decoder_delete");
#line 298
  f->FLAC__stream_decoder_init_stream = (FLAC__StreamDecoderInitStatus (*)(FLAC__StreamDecoder * ,
                                                                           FLAC__StreamDecoderReadCallback  ,
                                                                           FLAC__StreamDecoderSeekCallback  ,
                                                                           FLAC__StreamDecoderTellCallback  ,
                                                                           FLAC__StreamDecoderLengthCallback  ,
                                                                           FLAC__StreamDecoderEofCallback  ,
                                                                           FLAC__StreamDecoderWriteCallback  ,
                                                                           FLAC__StreamDecoderMetadataCallback  ,
                                                                           FLAC__StreamDecoderErrorCallback  ,
                                                                           void * ))dlsym(handle,
                                                                                          "FLAC__stream_decoder_init_stream\220");
#line 299
  f->FLAC__stream_decoder_init_ogg_stream = (FLAC__StreamDecoderInitStatus (*)(FLAC__StreamDecoder * ,
                                                                               FLAC__StreamDecoderReadCallback  ,
                                                                               FLAC__StreamDecoderSeekCallback  ,
                                                                               FLAC__StreamDecoderTellCallback  ,
                                                                               FLAC__StreamDecoderLengthCallback  ,
                                                                               FLAC__StreamDecoderEofCallback  ,
                                                                               FLAC__StreamDecoderWriteCallback  ,
                                                                               FLAC__StreamDecoderMetadataCallback  ,
                                                                               FLAC__StreamDecoderErrorCallback  ,
                                                                               void * ))dlsym(handle,
                                                                                              "FLAC__stream_decoder_init_ogg_stream\301U");
#line 300
  f->FLAC__stream_decoder_process_single = (FLAC__bool (*)(FLAC__StreamDecoder * ))dlsym(handle,
                                                                                         "FLAC__stream_decoder_process_single");
#line 301
  f->FLAC__stream_decoder_get_state = (FLAC__StreamDecoderState (*)(FLAC__StreamDecoder * ))dlsym(handle,
                                                                                                  "FLAC__stream_decoder_get_state");
#line 303
  err = dlerror();
  }
#line 303
  if (err != (void *)0) {
#line 304
    if ((unsigned int )loglevel >= 2U) {
      {
#line 304
      __cil_tmp16 = logtime();
#line 304
      logprint("%s %s:%d dlerror: %s\nU", __cil_tmp16, "load_flac", 304, err);
      }
    }
#line 305
    return (0);
  }
#line 308
  if ((unsigned int )loglevel >= 2U) {
    {
#line 308
    __cil_tmp17 = logtime();
#line 308
    logprint("%s %s:%d loaded libFLAC.so.8\nZ:f\301U", __cil_tmp17, "load_flac", 308);
    }
  }
#line 311
  return (1);
}
}
#line 314 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/flac.c"
struct codec *register_flac(void) 
{ 
  static struct codec ret ;
  void *__cil_tmp2 ;
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
#line 315
  ret.id = (char )'f';
#line 315
  ret.types = "ogf,flc";
#line 315
  ret.min_read_bytes = (unsigned int )16384;
#line 315
  ret.min_space = (unsigned int )204800;
#line 315
  ret.open = (void (*)(unsigned char  , unsigned char  , unsigned char  , unsigned char  ))(& flac_open);
#line 315
  ret.close = (void (*)(void))(& flac_close);
  {
#line 315
  ret.decode = (enum __anonenum__74 (*)(void))(& flac_decode);
#line 325
  f = (struct flac *)malloc(sizeof(struct flac ));
  }
#line 326
  if (! f) {
#line 327
    return ((struct codec *)((void *)0));
  }
  {
#line 330
  f->decoder = (FLAC__StreamDecoder *)((void *)0);
#line 332
  __cil_tmp3 = load_flac();
  }
#line 332
  if (! __cil_tmp3) {
#line 333
    return ((struct codec *)((void *)0));
  }
#line 336
  if ((unsigned int )loglevel >= 2U) {
    {
#line 336
    __cil_tmp4 = logtime();
#line 336
    logprint("%s %s:%d using flac to decode ogf,flc\n", __cil_tmp4, "register_flac",
             336);
    }
  }
#line 337
  return (& ret);
}
}
#line 35 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
struct codec *codecs[10] ;
#line 36
struct codec *codec ;
#line 37 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
static int running  =    1;
#line 56 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
static void *decode_thread(void) 
{ 
  size_t bytes ;
  size_t space ;
  size_t min_space ;
  int toend ;
  int ran ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  char const   *__cil_tmp8 ;
  decode_state __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *tmp ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! running) {
#line 58
      goto while_break;
    }
    {
#line 61
    ran = 0;
#line 63
    pthread_mutex_lock(& streambuf->mutex);
#line 64
    __cil_tmp6 = _buf_used(streambuf);
#line 64
    bytes = (size_t )__cil_tmp6;
#line 65
    toend = (int )((unsigned int )stream.state <= 1U);
#line 66
    pthread_mutex_unlock(& streambuf->mutex);
#line 67
    pthread_mutex_lock(& outputbuf->mutex);
#line 68
    __cil_tmp7 = _buf_space(outputbuf);
#line 68
    space = (size_t )__cil_tmp7;
#line 69
    pthread_mutex_unlock(& outputbuf->mutex);
#line 71
    pthread_mutex_lock(& decode.mutex);
    }
#line 73
    if (codec) {
#line 73
      if ((unsigned int )decode.state == 2U) {
#line 75
        if ((unsigned int )loglevel >= 4U) {
          {
#line 75
          __cil_tmp8 = logtime();
#line 75
          logprint("%s %s:%d streambuf bytes: %u outputbuf space: %u\n", __cil_tmp8,
                   "decode_thread", 75, bytes, space);
          }
        }
#line 77
        min_space = (size_t )codec->min_space;
#line 84
        if (space > min_space) {
#line 84
          if (bytes > (unsigned long )codec->min_read_bytes) {
            _L: /* CIL Label */ 
            {
#line 86
            decode.state = (*(codec->decode))();
            }
#line 98
            if ((unsigned int )decode.state != 2U) {
#line 100
              if ((unsigned int )loglevel >= 2U) {
                {
#line 100
                __cil_tmp10 = logtime();
                }
#line 100
                if ((unsigned int )decode.state == 3U) {
#line 100
                  tmp = "complete\323\001 ";
                } else {
#line 100
                  tmp = "error";
                }
                {
#line 100
                logprint("%s %s:%d decode %s\n", __cil_tmp10, "decode_thread", 100,
                         tmp);
                }
              }
              {
#line 102
              pthread_mutex_lock(& outputbuf->mutex);
              }
#line 103
              if (output.fade_mode) {
                {
#line 103
                _checkfade(0);
                }
              }
              {
#line 104
              pthread_mutex_unlock(& outputbuf->mutex);
#line 106
              wake_controller();
              }
            }
#line 109
            ran = 1;
          } else
#line 84
          if (toend) {
#line 84
            goto _L;
          }
        }
      }
    }
    {
#line 113
    pthread_mutex_unlock(& decode.mutex);
    }
#line 115
    if (! ran) {
      {
#line 116
      usleep((__useconds_t )100000);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return ((void *)0);
}
}
#line 123 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
static void sort_codecs(int pry , struct codec *ptr ) 
{ 
  static int priority[10] ;
  int i ;
  int tpry ;
  struct codec *tptr ;
  int __cil_tmp7 ;

  {
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < 10)) {
#line 128
      goto while_break;
    }
#line 129
    if (! codecs[i]) {
#line 130
      codecs[i] = ptr;
#line 131
      priority[i] = pry;
#line 132
      return;
    }
#line 134
    if (pry < priority[i]) {
#line 135
      tptr = codecs[i];
#line 136
      codecs[i] = ptr;
#line 137
      ptr = tptr;
#line 138
      tpry = priority[i];
#line 139
      priority[i] = pry;
#line 140
      pry = tpry;
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 145
static pthread_t thread ;
#line 147 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
void decode_init(log_level level , char const   *include_codecs , char const   *exclude_codecs ) 
{ 
  int i ;
  char *order_codecs ;
  char const   *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *tmp ;
  struct codec *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *tmp___0 ;
  struct codec *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *tmp___1 ;
  struct codec *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *tmp___2 ;
  struct codec *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *tmp___3 ;
  struct codec *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *tmp___4 ;
  struct codec *__cil_tmp34 ;
  char const   *__cil_tmp35 ;
  char const   *tmp___5 ;
  pthread_attr_t attr ;

  {
#line 151
  loglevel = level;
#line 153
  if ((unsigned int )loglevel >= 2U) {
    {
#line 153
    __cil_tmp6 = logtime();
#line 153
    logprint("%s %s:%d init decode\n", __cil_tmp6, "decode_init", 153);
    }
  }
  {
#line 157
  i = 0;
#line 172
  order_codecs = strstr(include_codecs, "aacf\301U");
  }
  {
#line 172
  __cil_tmp7 = strstr(exclude_codecs, "aacf\301U");
  }
#line 172
  if (! __cil_tmp7) {
#line 172
    if (! include_codecs) {
      _L: /* CIL Label */ 
#line 173
      if (include_codecs) {
#line 173
        tmp = order_codecs - include_codecs;
      } else {
#line 173
        tmp = (char *)((long )i);
      }
      {
#line 173
      __cil_tmp10 = register_faad();
#line 173
      sort_codecs((int )tmp, __cil_tmp10);
      }
    } else
#line 172
    if (order_codecs) {
#line 172
      goto _L;
    }
  }
  {
#line 175
  order_codecs = strstr(include_codecs, "ogg");
  }
  {
#line 175
  __cil_tmp11 = strstr(exclude_codecs, "ogg");
  }
#line 175
  if (! __cil_tmp11) {
#line 175
    if (! include_codecs) {
      _L___10: /* CIL Label */ 
#line 176
      if (include_codecs) {
#line 176
        tmp___0 = order_codecs - include_codecs;
      } else {
#line 176
        tmp___0 = (char *)((long )i);
      }
      {
#line 176
      __cil_tmp14 = register_vorbis();
#line 176
      sort_codecs((int )tmp___0, __cil_tmp14);
      }
    } else
#line 175
    if (order_codecs) {
#line 175
      goto _L___10;
    }
  }
  {
#line 181
  order_codecs = strstr(include_codecs, "flac");
  }
  {
#line 181
  __cil_tmp15 = strstr(exclude_codecs, "flac\301U");
  }
#line 181
  if (! __cil_tmp15) {
#line 181
    if (! include_codecs) {
      _L___11: /* CIL Label */ 
#line 182
      if (include_codecs) {
#line 182
        tmp___1 = order_codecs - include_codecs;
      } else {
#line 182
        tmp___1 = (char *)((long )i);
      }
      {
#line 182
      __cil_tmp18 = register_flac();
#line 182
      sort_codecs((int )tmp___1, __cil_tmp18);
      }
    } else
#line 181
    if (order_codecs) {
#line 181
      goto _L___11;
    }
  }
  {
#line 183
  order_codecs = strstr(include_codecs, "pcmf\301U");
  }
  {
#line 183
  __cil_tmp19 = strstr(exclude_codecs, "pcme\301U");
  }
#line 183
  if (! __cil_tmp19) {
#line 183
    if (! include_codecs) {
      _L___12: /* CIL Label */ 
#line 184
      if (include_codecs) {
#line 184
        tmp___2 = order_codecs - include_codecs;
      } else {
#line 184
        tmp___2 = (char *)((long )i);
      }
      {
#line 184
      __cil_tmp22 = register_pcm();
#line 184
      sort_codecs((int )tmp___2, __cil_tmp22);
      }
    } else
#line 183
    if (order_codecs) {
#line 183
      goto _L___12;
    }
  }
  {
#line 187
  order_codecs = strstr(include_codecs, "madf\301U");
  }
  {
#line 187
  order_codecs = strstr(include_codecs, "mp3");
  }
  {
#line 187
  __cil_tmp24 = strstr(exclude_codecs, "mad");
  }
  {
#line 187
  __cil_tmp23 = strstr(exclude_codecs, "mp3");
  }
#line 187
  if (! (__cil_tmp23 || __cil_tmp24)) {
#line 187
    if (! include_codecs) {
      _L___16: /* CIL Label */ 
      _L___17: /* CIL Label */ 
#line 189
      if (include_codecs) {
#line 189
        tmp___3 = order_codecs - include_codecs;
      } else {
#line 189
        tmp___3 = (char *)((long )i);
      }
      {
#line 189
      __cil_tmp28 = register_mad();
#line 189
      sort_codecs((int )tmp___3, __cil_tmp28);
      }
    } else
#line 187
    if (order_codecs) {
#line 187
      goto _L___16;
    } else
#line 187
    if (order_codecs) {
#line 187
      goto _L___16;
    } else {
#line 187
      goto _L___15;
    }
  } else {
    _L___15: /* CIL Label */ 
    {
#line 190
    order_codecs = strstr(include_codecs, "mpgf\301U");
    }
    {
#line 190
    order_codecs = strstr(include_codecs, "mp3f\301U");
    }
    {
#line 190
    __cil_tmp30 = strstr(exclude_codecs, "mpg");
    }
    {
#line 190
    __cil_tmp29 = strstr(exclude_codecs, "mp3f\301U");
    }
#line 190
    if (! (__cil_tmp29 || __cil_tmp30)) {
#line 190
      if (! include_codecs) {
        _L___13: /* CIL Label */ 
        _L___14: /* CIL Label */ 
#line 192
        if (include_codecs) {
#line 192
          tmp___4 = order_codecs - include_codecs;
        } else {
#line 192
          tmp___4 = (char *)((long )i);
        }
        {
#line 192
        __cil_tmp34 = register_mpg();
#line 192
        sort_codecs((int )tmp___4, __cil_tmp34);
        }
      } else
#line 190
      if (order_codecs) {
#line 190
        goto _L___13;
      } else
#line 190
      if (order_codecs) {
#line 190
        goto _L___13;
      }
    }
  }
#line 194
  if ((unsigned int )loglevel >= 3U) {
    {
#line 194
    __cil_tmp35 = logtime();
    }
#line 194
    if (include_codecs) {
#line 194
      tmp___5 = include_codecs;
    } else {
#line 194
      tmp___5 = "\220";
    }
    {
#line 194
    logprint("%s %s:%d include codecs: %s exclude codecs: %s\n", __cil_tmp35, "decode_init",
             194, tmp___5, exclude_codecs);
    }
  }
  {
#line 196
  pthread_mutex_init(& decode.mutex, (pthread_mutexattr_t *)((void *)0));
#line 200
  pthread_attr_init(& attr);
#line 202
  pthread_attr_setstacksize(& attr, (size_t )147456);
#line 204
  pthread_create(& thread, & attr, & decode_thread, (void *)0);
#line 205
  pthread_attr_destroy(& attr);
#line 211
  decode.new_stream = 1;
#line 212
  decode.state = (decode_state )0;
  }
  return;
}
}
#line 220 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
void decode_close(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 221
  if ((unsigned int )loglevel >= 2U) {
    {
#line 221
    __cil_tmp1 = logtime();
#line 221
    logprint("%s %s:%d close decode\n", __cil_tmp1, "decode_close", 221);
    }
  }
  {
#line 222
  pthread_mutex_lock(& decode.mutex);
  }
#line 223
  if (codec) {
    {
#line 224
    (*(codec->close))();
#line 225
    codec = (struct codec *)((void *)0);
    }
  }
  {
#line 227
  running = 0;
#line 228
  pthread_mutex_unlock(& decode.mutex);
#line 230
  pthread_join(thread, (void **)((void *)0));
#line 232
  pthread_mutex_destroy(& decode.mutex);
  }
  return;
}
}
#line 235 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
void decode_flush(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 236
  if ((unsigned int )loglevel >= 2U) {
    {
#line 236
    __cil_tmp1 = logtime();
#line 236
    logprint("%s %s:%d decode flush\n", __cil_tmp1, "decode_flush\301U", 236);
    }
  }
  {
#line 237
  pthread_mutex_lock(& decode.mutex);
#line 238
  decode.state = (decode_state )0;
#line 242
  pthread_mutex_unlock(& decode.mutex);
  }
  return;
}
}
#line 245 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
unsigned int decode_newstream(unsigned int sample_rate___0 , unsigned int supported_rates[] ) 
{ 


  {

#line 258
  return (sample_rate___0);
}
}
#line 261 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/decode.c"
void codec_open(u8_t format , u8_t sample_size___0 , u8_t sample_rate___0 , u8_t channels___0 ,
                u8_t endianness ) 
{ 
  int i ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
#line 264
  if ((unsigned int )loglevel >= 2U) {
    {
#line 264
    __cil_tmp7 = logtime();
#line 264
    logprint("%s %s:%d codec open: \'%c\'\n", __cil_tmp7, "codec_openXf\301U", 264,
             (int )format);
    }
  }
  {
#line 266
  pthread_mutex_lock(& decode.mutex);
#line 268
  decode.new_stream = 1;
#line 269
  decode.state = (decode_state )0;
#line 276
  i = 0;
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < 10)) {
#line 276
      goto while_break;
    }
#line 278
    if (codecs[i]) {
#line 278
      if ((int )(codecs[i])->id == (int )format) {
#line 280
        if (codec) {
#line 280
          if (codec != codecs[i]) {
#line 281
            if ((unsigned int )loglevel >= 2U) {
              {
#line 281
              __cil_tmp8 = logtime();
#line 281
              logprint("%s %s:%d closing codec: \'%c\'\n", __cil_tmp8, "codec_open",
                       281, (int )codec->id);
              }
            }
            {
#line 282
            (*(codec->close))();
            }
          }
        }
        {
#line 285
        codec = codecs[i];
#line 287
        (*(codec->open))(sample_size___0, sample_rate___0, channels___0, endianness);
#line 289
        decode.state = (decode_state )1;
#line 291
        pthread_mutex_unlock(& decode.mutex);
        }
#line 292
        return;
      }
    }
#line 276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  pthread_mutex_unlock(& decode.mutex);
#line 298
  __cil_tmp9 = logtime();
#line 298
  logprint("%s %s:%d codec not found\n\266Xf\301U", __cil_tmp9, "codec_openXf\301U",
           298);
  }
  return;
}
}
#line 33 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_pack.c"
s32_t gain(s32_t gain___0 , s32_t sample ) 
{ 
  s64_t res ;

  {
#line 34
  res = (s64_t )gain___0 * (s64_t )sample;
#line 35
  if ((long long )res > 140737488355327LL) {
#line 35
    res = (s64_t )140737488355327LL;
  }
#line 36
  if ((long long )res < -140737488355327LL) {
#line 36
    res = (s64_t )(- 140737488355327LL);
  }
#line 37
  return ((s32_t )(res >> 16));
}
}
#line 42 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_pack.c"
s32_t to_gain(float f___0 ) 
{ 


  {
#line 43
  return ((s32_t )(f___0 * 65536.f));
}
}
#line 46 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_pack.c"
void _scale_and_pack_frames(void *outputptr , s32_t *inputptr , frames_t cnt , s32_t gainL ,
                            s32_t gainR , u8_t flags , output_format format ) 
{ 
  s32_t *ptr ;
  frames_t count ;
  frames_t __cil_tmp10 ;
  s32_t *ptr___0 ;
  frames_t count___0 ;
  frames_t __cil_tmp13 ;
  s32_t *ptr___1 ;
  frames_t count___1 ;
  frames_t __cil_tmp16 ;
  u32_t *optr ;
  frames_t __cil_tmp18 ;
  u32_t *__cil_tmp19 ;
  frames_t __cil_tmp20 ;
  u32_t *__cil_tmp21 ;
  s32_t __cil_tmp22 ;
  s32_t __cil_tmp23 ;
  u32_t *optr___0 ;
  frames_t __cil_tmp25 ;
  u32_t *__cil_tmp26 ;
  s32_t *__cil_tmp27 ;
  u32_t *__cil_tmp28 ;
  s32_t *__cil_tmp29 ;
  frames_t __cil_tmp30 ;
  u32_t *__cil_tmp31 ;
  s32_t *__cil_tmp32 ;
  s32_t __cil_tmp33 ;
  u32_t *__cil_tmp34 ;
  s32_t *__cil_tmp35 ;
  s32_t __cil_tmp36 ;
  u8_t *optr___1 ;
  u32_t *o_ptr ;
  s32_t l1 ;
  s32_t *__cil_tmp40 ;
  s32_t r1 ;
  s32_t *__cil_tmp42 ;
  s32_t l2 ;
  s32_t *__cil_tmp44 ;
  s32_t r2 ;
  s32_t *__cil_tmp46 ;
  u32_t *__cil_tmp47 ;
  u32_t *__cil_tmp48 ;
  u32_t *__cil_tmp49 ;
  s32_t lsample ;
  s32_t *__cil_tmp51 ;
  s32_t rsample ;
  s32_t *__cil_tmp53 ;
  u8_t *__cil_tmp54 ;
  u8_t *__cil_tmp55 ;
  u8_t *__cil_tmp56 ;
  u8_t *__cil_tmp57 ;
  u8_t *__cil_tmp58 ;
  u8_t *__cil_tmp59 ;
  frames_t __cil_tmp60 ;
  u32_t *o_ptr___0 ;
  s32_t l1___0 ;
  s32_t *__cil_tmp63 ;
  s32_t __cil_tmp64 ;
  s32_t r1___0 ;
  s32_t *__cil_tmp66 ;
  s32_t __cil_tmp67 ;
  s32_t l2___0 ;
  s32_t *__cil_tmp69 ;
  s32_t __cil_tmp70 ;
  s32_t r2___0 ;
  s32_t *__cil_tmp72 ;
  s32_t __cil_tmp73 ;
  u32_t *__cil_tmp74 ;
  u32_t *__cil_tmp75 ;
  u32_t *__cil_tmp76 ;
  s32_t lsample___0 ;
  s32_t *__cil_tmp78 ;
  s32_t __cil_tmp79 ;
  s32_t rsample___0 ;
  s32_t *__cil_tmp81 ;
  s32_t __cil_tmp82 ;
  u8_t *__cil_tmp83 ;
  u8_t *__cil_tmp84 ;
  u8_t *__cil_tmp85 ;
  u8_t *__cil_tmp86 ;
  u8_t *__cil_tmp87 ;
  u8_t *__cil_tmp88 ;
  frames_t __cil_tmp89 ;
  u32_t *optr___2 ;
  frames_t __cil_tmp91 ;
  u32_t *__cil_tmp92 ;
  s32_t *__cil_tmp93 ;
  s32_t __cil_tmp94 ;
  u32_t *__cil_tmp95 ;
  s32_t *__cil_tmp96 ;
  s32_t __cil_tmp97 ;

  {
#line 48
  if ((int )flags & 1) {
#line 48
    if ((int )flags & 2) {
#line 49
      ptr = inputptr;
#line 50
      count = cnt;
      {
#line 51
      while (1) {
        while_continue: /* CIL Label */ ;
#line 51
        __cil_tmp10 = count;
#line 51
        count --;
#line 51
        if (! __cil_tmp10) {
#line 51
          goto while_break;
        }
#line 53
        *(ptr + 1) = (s32_t )(((s64_t )*ptr + (s64_t )*(ptr + 1)) / 2L);
#line 53
        *ptr = *(ptr + 1);
#line 54
        ptr += 2;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 48
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 56
  if ((int )flags & 2) {
#line 57
    ptr___0 = inputptr + 1;
#line 58
    count___0 = cnt;
    {
#line 59
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 59
      __cil_tmp13 = count___0;
#line 59
      count___0 --;
#line 59
      if (! __cil_tmp13) {
#line 59
        goto while_break___0;
      }
#line 60
      *(ptr___0 - 1) = *ptr___0;
#line 61
      ptr___0 += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 63
  if ((int )flags & 1) {
#line 64
    ptr___1 = inputptr;
#line 65
    count___1 = cnt;
    {
#line 66
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 66
      __cil_tmp16 = count___1;
#line 66
      count___1 --;
#line 66
      if (! __cil_tmp16) {
#line 66
        goto while_break___1;
      }
#line 67
      *(ptr___1 + 1) = *ptr___1;
#line 68
      ptr___1 += 2;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 167
  if ((unsigned int )format == (unsigned int )3) {
#line 167
    goto case_3;
  }
#line 203
  if ((unsigned int )format == (unsigned int )1) {
#line 203
    goto case_1;
  }
#line 241
  if ((unsigned int )format == (unsigned int )2) {
#line 241
    goto case_2;
  }
#line 319
  if ((unsigned int )format == (unsigned int )0) {
#line 319
    goto case_0;
  }
#line 358
  goto switch_default;
  case_3: /* CIL Label */ 
#line 169
  optr = (u32_t *)((void *)outputptr);
#line 171
  if (gainL == 65536) {
#line 171
    if (gainR == 65536) {
      {
#line 172
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 172
        __cil_tmp18 = cnt;
#line 172
        cnt --;
#line 172
        if (! __cil_tmp18) {
#line 172
          goto while_break___2;
        }
#line 173
        __cil_tmp19 = optr;
#line 173
        optr ++;
#line 173
        *__cil_tmp19 = (unsigned int )((*inputptr >> 16) & 65535) | ((unsigned int )*(inputptr + 1) & 4294901760U);
#line 174
        inputptr += 2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
#line 171
      goto _L___18;
    }
  } else {
    _L___18: /* CIL Label */ 
    {
#line 177
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 177
      __cil_tmp20 = cnt;
#line 177
      cnt --;
#line 177
      if (! __cil_tmp20) {
#line 177
        goto while_break___3;
      }
      {
#line 178
      __cil_tmp23 = gain(gainR, *(inputptr + 1));
      }
      {
#line 178
      __cil_tmp22 = gain(gainL, *inputptr);
      }
#line 178
      __cil_tmp21 = optr;
#line 178
      optr ++;
#line 178
      *__cil_tmp21 = (unsigned int )((__cil_tmp22 >> 16) & 65535) | ((unsigned int )__cil_tmp23 & 4294901760U);
#line 179
      inputptr += 2;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 202
  goto switch_break;
  case_1: /* CIL Label */ 
#line 205
  optr___0 = (u32_t *)((void *)outputptr);
#line 207
  if (gainL == 65536) {
#line 207
    if (gainR == 65536) {
      {
#line 208
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 208
        __cil_tmp25 = cnt;
#line 208
        cnt --;
#line 208
        if (! __cil_tmp25) {
#line 208
          goto while_break___4;
        }
#line 209
        __cil_tmp27 = inputptr;
#line 209
        inputptr ++;
#line 209
        __cil_tmp26 = optr___0;
#line 209
        optr___0 ++;
#line 209
        *__cil_tmp26 = (u32_t )(*__cil_tmp27 >> 8);
#line 210
        __cil_tmp29 = inputptr;
#line 210
        inputptr ++;
#line 210
        __cil_tmp28 = optr___0;
#line 210
        optr___0 ++;
#line 210
        *__cil_tmp28 = (u32_t )(*__cil_tmp29 >> 8);
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
#line 207
      goto _L___19;
    }
  } else {
    _L___19: /* CIL Label */ 
    {
#line 213
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 213
      __cil_tmp30 = cnt;
#line 213
      cnt --;
#line 213
      if (! __cil_tmp30) {
#line 213
        goto while_break___5;
      }
      {
#line 214
      __cil_tmp32 = inputptr;
#line 214
      inputptr ++;
#line 214
      __cil_tmp33 = gain(gainL, *__cil_tmp32);
      }
      {
#line 214
      __cil_tmp31 = optr___0;
#line 214
      optr___0 ++;
#line 214
      *__cil_tmp31 = (u32_t )(__cil_tmp33 >> 8);
#line 215
      __cil_tmp35 = inputptr;
#line 215
      inputptr ++;
#line 215
      __cil_tmp36 = gain(gainR, *__cil_tmp35);
      }
#line 215
      __cil_tmp34 = optr___0;
#line 215
      optr___0 ++;
#line 215
      *__cil_tmp34 = (u32_t )(__cil_tmp36 >> 8);
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 240
  goto switch_break;
  case_2: /* CIL Label */ 
#line 243
  optr___1 = (u8_t *)((void *)outputptr);
#line 244
  if (gainL == 65536) {
#line 244
    if (gainR == 65536) {
      {
#line 245
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 245
        if (! cnt) {
#line 245
          goto while_break___6;
        }
#line 248
        if (((uintptr_t )optr___1 & 3UL) == 0UL) {
#line 248
          if (cnt >= 2U) {
#line 249
            o_ptr = (u32_t *)((void *)optr___1);
            {
#line 250
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 250
              if (! (cnt >= 2U)) {
#line 250
                goto while_break___7;
              }
#line 251
              __cil_tmp40 = inputptr;
#line 251
              inputptr ++;
#line 251
              l1 = *__cil_tmp40;
#line 251
              __cil_tmp42 = inputptr;
#line 251
              inputptr ++;
#line 251
              r1 = *__cil_tmp42;
#line 252
              __cil_tmp44 = inputptr;
#line 252
              inputptr ++;
#line 252
              l2 = *__cil_tmp44;
#line 252
              __cil_tmp46 = inputptr;
#line 252
              inputptr ++;
#line 252
              r2 = *__cil_tmp46;
#line 254
              __cil_tmp47 = o_ptr;
#line 254
              o_ptr ++;
#line 254
              *__cil_tmp47 = (((unsigned int )l1 & 4294967040U) >> 8) | (unsigned int )((r1 & 65280) << 16);
#line 255
              __cil_tmp48 = o_ptr;
#line 255
              o_ptr ++;
#line 255
              *__cil_tmp48 = (((unsigned int )r1 & 4294901760U) >> 16) | (unsigned int )((l2 & 16776960) << 8);
#line 256
              __cil_tmp49 = o_ptr;
#line 256
              o_ptr ++;
#line 256
              *__cil_tmp49 = (((unsigned int )l2 & 4278190080U) >> 24) | ((unsigned int )r2 & 4294967040U);
#line 265
              optr___1 += 12;
#line 266
              cnt -= (unsigned int )2;
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
#line 248
            goto _L___20;
          }
        } else {
          _L___20: /* CIL Label */ 
#line 269
          __cil_tmp51 = inputptr;
#line 269
          inputptr ++;
#line 269
          lsample = *__cil_tmp51;
#line 270
          __cil_tmp53 = inputptr;
#line 270
          inputptr ++;
#line 270
          rsample = *__cil_tmp53;
#line 271
          __cil_tmp54 = optr___1;
#line 271
          optr___1 ++;
#line 271
          *__cil_tmp54 = (u8_t )((lsample & 65280) >> 8);
#line 272
          __cil_tmp55 = optr___1;
#line 272
          optr___1 ++;
#line 272
          *__cil_tmp55 = (u8_t )((lsample & 16711680) >> 16);
#line 273
          __cil_tmp56 = optr___1;
#line 273
          optr___1 ++;
#line 273
          *__cil_tmp56 = (u8_t )(((unsigned int )lsample & 4278190080U) >> 24);
#line 274
          __cil_tmp57 = optr___1;
#line 274
          optr___1 ++;
#line 274
          *__cil_tmp57 = (u8_t )((rsample & 65280) >> 8);
#line 275
          __cil_tmp58 = optr___1;
#line 275
          optr___1 ++;
#line 275
          *__cil_tmp58 = (u8_t )((rsample & 16711680) >> 16);
#line 276
          __cil_tmp59 = optr___1;
#line 276
          optr___1 ++;
#line 276
          *__cil_tmp59 = (u8_t )(((unsigned int )rsample & 4278190080U) >> 24);
#line 277
          __cil_tmp60 = cnt;
#line 277
          cnt --;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 244
      goto _L___22;
    }
  } else {
    _L___22: /* CIL Label */ 
    {
#line 281
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 281
      if (! cnt) {
#line 281
        goto while_break___8;
      }
#line 284
      if (((uintptr_t )optr___1 & 3UL) == 0UL) {
#line 284
        if (cnt >= 2U) {
#line 285
          o_ptr___0 = (u32_t *)((void *)optr___1);
          {
#line 286
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 286
            if (! (cnt >= 2U)) {
#line 286
              goto while_break___9;
            }
            {
#line 287
            __cil_tmp63 = inputptr;
#line 287
            inputptr ++;
#line 287
            __cil_tmp64 = gain(gainL, *__cil_tmp63);
#line 287
            l1___0 = __cil_tmp64;
#line 287
            __cil_tmp66 = inputptr;
#line 287
            inputptr ++;
#line 287
            __cil_tmp67 = gain(gainR, *__cil_tmp66);
#line 287
            r1___0 = __cil_tmp67;
#line 288
            __cil_tmp69 = inputptr;
#line 288
            inputptr ++;
#line 288
            __cil_tmp70 = gain(gainL, *__cil_tmp69);
#line 288
            l2___0 = __cil_tmp70;
#line 288
            __cil_tmp72 = inputptr;
#line 288
            inputptr ++;
#line 288
            __cil_tmp73 = gain(gainR, *__cil_tmp72);
#line 288
            r2___0 = __cil_tmp73;
#line 290
            __cil_tmp74 = o_ptr___0;
#line 290
            o_ptr___0 ++;
#line 290
            *__cil_tmp74 = (((unsigned int )l1___0 & 4294967040U) >> 8) | (unsigned int )((r1___0 & 65280) << 16);
#line 291
            __cil_tmp75 = o_ptr___0;
#line 291
            o_ptr___0 ++;
#line 291
            *__cil_tmp75 = (((unsigned int )r1___0 & 4294901760U) >> 16) | (unsigned int )((l2___0 & 16776960) << 8);
#line 292
            __cil_tmp76 = o_ptr___0;
#line 292
            o_ptr___0 ++;
#line 292
            *__cil_tmp76 = (((unsigned int )l2___0 & 4278190080U) >> 24) | ((unsigned int )r2___0 & 4294967040U);
#line 301
            optr___1 += 12;
#line 302
            cnt -= (unsigned int )2;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        } else {
#line 284
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
        {
#line 305
        __cil_tmp78 = inputptr;
#line 305
        inputptr ++;
#line 305
        __cil_tmp79 = gain(gainL, *__cil_tmp78);
#line 305
        lsample___0 = __cil_tmp79;
#line 306
        __cil_tmp81 = inputptr;
#line 306
        inputptr ++;
#line 306
        __cil_tmp82 = gain(gainR, *__cil_tmp81);
#line 306
        rsample___0 = __cil_tmp82;
#line 307
        __cil_tmp83 = optr___1;
#line 307
        optr___1 ++;
#line 307
        *__cil_tmp83 = (u8_t )((lsample___0 & 65280) >> 8);
#line 308
        __cil_tmp84 = optr___1;
#line 308
        optr___1 ++;
#line 308
        *__cil_tmp84 = (u8_t )((lsample___0 & 16711680) >> 16);
#line 309
        __cil_tmp85 = optr___1;
#line 309
        optr___1 ++;
#line 309
        *__cil_tmp85 = (u8_t )(((unsigned int )lsample___0 & 4278190080U) >> 24);
#line 310
        __cil_tmp86 = optr___1;
#line 310
        optr___1 ++;
#line 310
        *__cil_tmp86 = (u8_t )((rsample___0 & 65280) >> 8);
#line 311
        __cil_tmp87 = optr___1;
#line 311
        optr___1 ++;
#line 311
        *__cil_tmp87 = (u8_t )((rsample___0 & 16711680) >> 16);
#line 312
        __cil_tmp88 = optr___1;
#line 312
        optr___1 ++;
#line 312
        *__cil_tmp88 = (u8_t )(((unsigned int )rsample___0 & 4278190080U) >> 24);
#line 313
        __cil_tmp89 = cnt;
#line 313
        cnt --;
        }
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 318
  goto switch_break;
  case_0: /* CIL Label */ 
#line 321
  optr___2 = (u32_t *)((void *)outputptr);
#line 323
  if (gainL == 65536) {
#line 323
    if (gainR == 65536) {
      {
#line 324
      memcpy(outputptr, inputptr, (unsigned long )(cnt * 8U));
      }
    } else {
#line 323
      goto _L___23;
    }
  } else {
    _L___23: /* CIL Label */ 
    {
#line 326
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 326
      __cil_tmp91 = cnt;
#line 326
      cnt --;
#line 326
      if (! __cil_tmp91) {
#line 326
        goto while_break___10;
      }
      {
#line 327
      __cil_tmp93 = inputptr;
#line 327
      inputptr ++;
#line 327
      __cil_tmp94 = gain(gainL, *__cil_tmp93);
      }
      {
#line 327
      __cil_tmp92 = optr___2;
#line 327
      optr___2 ++;
#line 327
      *__cil_tmp92 = (u32_t )__cil_tmp94;
#line 328
      __cil_tmp96 = inputptr;
#line 328
      inputptr ++;
#line 328
      __cil_tmp97 = gain(gainR, *__cil_tmp96);
      }
#line 328
      __cil_tmp95 = optr___2;
#line 328
      optr___2 ++;
#line 328
      *__cil_tmp95 = (u32_t )__cil_tmp97;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 357
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 359
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 366 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_pack.c"
void _apply_cross(struct buffer *outputbuf___0 , frames_t out_frames , s32_t cross_gain_in ,
                  s32_t cross_gain_out , s32_t **cross_ptr ) 
{ 
  s32_t *ptr ;
  frames_t count ;
  frames_t __cil_tmp8 ;
  s32_t __cil_tmp9 ;
  s32_t __cil_tmp10 ;
  s32_t *__cil_tmp11 ;
  s32_t *__cil_tmp12 ;

  {
#line 367
  ptr = (s32_t *)((void *)outputbuf___0->readp);
#line 368
  count = out_frames * 2U;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    __cil_tmp8 = count;
#line 369
    count --;
#line 369
    if (! __cil_tmp8) {
#line 369
      goto while_break;
    }
#line 370
    if (*cross_ptr > (s32_t *)outputbuf___0->wrap) {
#line 371
      *cross_ptr -= (outputbuf___0->size / 8UL) * 2UL;
    }
    {
#line 373
    __cil_tmp10 = gain(cross_gain_in, *(*cross_ptr));
    }
    {
#line 373
    __cil_tmp9 = gain(cross_gain_out, *ptr);
#line 373
    *ptr = __cil_tmp9 + __cil_tmp10;
#line 374
    ptr ++;
#line 374
    (*cross_ptr) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 381 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_pack.c"
void _apply_gain(struct buffer *outputbuf___0 , frames_t count , s32_t gainL , s32_t gainR ,
                 u8_t flags ) 
{ 
  s32_t *ptrL ;
  s32_t *ptrR ;
  frames_t __cil_tmp8 ;
  s32_t __cil_tmp9 ;
  s32_t __cil_tmp10 ;
  s32_t *ptr ;
  frames_t __cil_tmp12 ;
  s32_t __cil_tmp13 ;
  s32_t *ptr___0 ;
  frames_t __cil_tmp15 ;
  s32_t __cil_tmp16 ;
  s32_t *ptrL___0 ;
  s32_t *ptrR___0 ;
  frames_t __cil_tmp19 ;
  s32_t __cil_tmp20 ;
  s32_t __cil_tmp21 ;

  {
#line 382
  if (gainL == 65536) {
#line 382
    if (gainR == 65536) {
#line 382
      if (! ((int )flags & 3)) {
#line 383
        return;
      } else {
#line 382
        goto _L___24;
      }
    } else {
#line 382
      goto _L___24;
    }
  } else
  _L___24: /* CIL Label */ 
  _L___25: /* CIL Label */ 
#line 384
  if ((int )flags & 1) {
#line 384
    if ((int )flags & 2) {
#line 385
      ptrL = (s32_t *)((void *)outputbuf___0->readp);
#line 386
      ptrR = (s32_t *)((void *)outputbuf___0->readp) + 1;
      {
#line 387
      while (1) {
        while_continue: /* CIL Label */ ;
#line 387
        __cil_tmp8 = count;
#line 387
        count --;
#line 387
        if (! __cil_tmp8) {
#line 387
          goto while_break;
        }
        {
#line 388
        __cil_tmp10 = gain(gainR, *ptrR);
        }
        {
#line 388
        __cil_tmp9 = gain(gainL, *ptrL);
#line 388
        *ptrR = (__cil_tmp9 + __cil_tmp10) / 2;
#line 388
        *ptrL = *ptrR;
#line 389
        ptrL += 2;
#line 389
        ptrR += 2;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 384
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 392
  if ((int )flags & 2) {
#line 393
    ptr = (s32_t *)((void *)outputbuf___0->readp) + 1;
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 394
      __cil_tmp12 = count;
#line 394
      count --;
#line 394
      if (! __cil_tmp12) {
#line 394
        goto while_break___0;
      }
      {
#line 395
      *(ptr - 1) = gain(gainR, *ptr);
#line 396
      ptr += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 398
  if ((int )flags & 1) {
#line 399
    ptr___0 = (s32_t *)((void *)outputbuf___0->readp);
    {
#line 400
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 400
      __cil_tmp15 = count;
#line 400
      count --;
#line 400
      if (! __cil_tmp15) {
#line 400
        goto while_break___1;
      }
      {
#line 401
      *(ptr___0 + 1) = gain(gainL, *ptr___0);
#line 402
      ptr___0 += 2;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 405
    ptrL___0 = (s32_t *)((void *)outputbuf___0->readp);
#line 406
    ptrR___0 = (s32_t *)((void *)outputbuf___0->readp) + 1;
    {
#line 407
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 407
      __cil_tmp19 = count;
#line 407
      count --;
#line 407
      if (! __cil_tmp19) {
#line 407
        goto while_break___2;
      }
      {
#line 408
      *ptrL___0 = gain(gainL, *ptrL___0);
#line 409
      *ptrR___0 = gain(gainR, *ptrR___0);
#line 410
      ptrL___0 += 2;
#line 410
      ptrR___0 += 2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 28 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
static log_level loglevel___0 ;
#line 30 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
static int running___0  =    1;
#line 38
u8_t *silencebuf ;
#line 44
static u8_t *buf ;
#line 45
static unsigned int buffill ;
#line 46
static int bytes_per_frame___0 ;
#line 48 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
static int _stdout_write_frames(frames_t out_frames , int silence , s32_t gainL ,
                                s32_t gainR , u8_t flags , s32_t cross_gain_in , s32_t cross_gain_out ,
                                s32_t **cross_ptr ) 
{ 
  u8_t *obuf ;

  {
#line 53
  if (! silence) {
#line 55
    if (*cross_ptr) {
#line 55
      if ((unsigned int )output.fade == 2U) {
#line 55
        if ((unsigned int )output.fade_dir == 3U) {
          {
#line 56
          _apply_cross(outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);
          }
        }
      }
    }
#line 59
    obuf = outputbuf->readp;
  } else {
#line 63
    obuf = silencebuf;
  }
  {
#line 78
  _scale_and_pack_frames(buf + buffill * (unsigned int )bytes_per_frame___0, (s32_t *)((void *)obuf),
                         out_frames, gainL, gainR, flags, output.format);
#line 80
  buffill += out_frames;
  }
#line 82
  return ((int )out_frames);
}
}
#line 85 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
static void *output_thread(void) 
{ 
  u32_t __cil_tmp1 ;

  {
  {
#line 87
  pthread_mutex_lock(& outputbuf->mutex);
  }
  {
#line 90
  if ((unsigned int )output.format == (unsigned int )0) {
#line 90
    goto case_0;
  }
#line 92
  if ((unsigned int )output.format == (unsigned int )2) {
#line 92
    goto case_2;
  }
#line 94
  if ((unsigned int )output.format == (unsigned int )3) {
#line 94
    goto case_3;
  }
#line 96
  goto switch_default;
  case_0: /* CIL Label */ 
#line 91
  bytes_per_frame___0 = 8;
#line 91
  goto switch_break;
  case_2: /* CIL Label */ 
#line 93
  bytes_per_frame___0 = 6;
#line 93
  goto switch_break;
  case_3: /* CIL Label */ 
#line 95
  bytes_per_frame___0 = 4;
#line 95
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 97
  bytes_per_frame___0 = 8;
#line 97
  goto switch_break;
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 101
  pthread_mutex_unlock(& outputbuf->mutex);
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! running___0) {
#line 103
      goto while_break;
    }
    {
#line 105
    pthread_mutex_lock(& outputbuf->mutex);
#line 107
    output.device_frames = (unsigned int )0;
#line 108
    output.updated = gettime_ms();
#line 109
    output.frames_played_dmp = output.frames_played;
#line 111
    _output_frames((frames_t )2048);
#line 113
    pthread_mutex_unlock(& outputbuf->mutex);
    }
#line 115
    if (buffill) {
      {
#line 116
      fwrite(buf, (unsigned long )bytes_per_frame___0, (unsigned long )buffill, stdout);
#line 117
      buffill = (unsigned int )0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return ((void *)0);
}
}
#line 125
static pthread_t thread___0 ;
#line 127 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
void output_init_stdout(log_level level , unsigned int output_buf_size , char *params ,
                        unsigned int rates[] , unsigned int rate_delay ) 
{ 
  char const   *__cil_tmp6 ;
  void *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  pthread_attr_t attr ;

  {
#line 128
  loglevel___0 = level;
#line 130
  if ((unsigned int )loglevel___0 >= 2U) {
    {
#line 130
    __cil_tmp6 = logtime();
#line 130
    logprint("%s %s:%d init output stdout\n", __cil_tmp6, "output_init_stdout\262f\301U",
             130);
    }
  }
  {
#line 132
  buf = (u8_t *)malloc((unsigned long )16384);
  }
#line 133
  if (! buf) {
    {
#line 134
    __cil_tmp8 = logtime();
#line 134
    logprint("%s %s:%d unable to malloc buf\n", __cil_tmp8, "output_init_stdout",
             134);
    }
#line 135
    return;
  }
  {
#line 137
  buffill = (unsigned int )0;
#line 139
  memset(& output, 0, sizeof(output));
#line 141
  output.format = (output_format )0;
#line 142
  output.start_frames = (unsigned int )4096;
#line 143
  output.write_cb = & _stdout_write_frames;
#line 144
  output.rate_delay = rate_delay;
  }
#line 146
  if (params) {
    {
#line 147
    __cil_tmp9 = strcmp((char const   *)params, "32");
    }
#line 147
    if (! __cil_tmp9) {
#line 147
      output.format = (output_format )0;
    }
    {
#line 148
    __cil_tmp10 = strcmp((char const   *)params, "24");
    }
#line 148
    if (! __cil_tmp10) {
#line 148
      output.format = (output_format )2;
    }
    {
#line 149
    __cil_tmp11 = strcmp((char const   *)params, "16");
    }
#line 149
    if (! __cil_tmp11) {
#line 149
      output.format = (output_format )3;
    }
  }
#line 153
  if (! rates[0]) {
#line 154
    rates[0] = (unsigned int )44100;
  }
  {
#line 157
  output_init_common(level, "-", output_buf_size, rates, (unsigned int )0);
#line 161
  pthread_attr_init(& attr);
#line 163
  pthread_attr_setstacksize(& attr, (size_t )81920);
#line 165
  pthread_create(& thread___0, & attr, & output_thread, (void *)0);
#line 166
  pthread_attr_destroy(& attr);
  }
  return;
}
}
#line 173 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_stdout.c"
void output_close_stdout(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 174
  if ((unsigned int )loglevel___0 >= 2U) {
    {
#line 174
    __cil_tmp1 = logtime();
#line 174
    logprint("%s %s:%d close output\n", __cil_tmp1, "output_close_stdoutf\301U", 174);
    }
  }
  {
#line 176
  pthread_mutex_lock(& outputbuf->mutex);
#line 177
  running___0 = 0;
#line 178
  pthread_mutex_unlock(& outputbuf->mutex);
#line 180
  free(buf);
#line 182
  output_close_common();
  }
  return;
}
}
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , off_t __offset ,
                                                       off_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , off_t __offset , off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 47 "/usr/include/alsa/global.h"
char const   *snd_asoundlib_version(void) ;
#line 72
extern struct snd_dlsym_link *snd_dlsym_start ;
#line 100
int snd_dlpath(char *path , size_t path_len , char const   *name ) ;
#line 101
void *snd_dlopen(char const   *file , int mode , char *errbuf , size_t errbuflen ) ;
#line 102
void *snd_dlsym(void *handle , char const   *name , char const   *version ) ;
#line 103
int snd_dlclose(void *handle ) ;
#line 124
int snd_async_add_handler(snd_async_handler_t **handler , int fd , snd_async_callback_t callback ,
                          void *private_data ) ;
#line 126
int snd_async_del_handler(snd_async_handler_t *handler ) ;
#line 127
int snd_async_handler_get_fd(snd_async_handler_t *handler ) ;
#line 128
int snd_async_handler_get_signo(snd_async_handler_t *handler ) ;
#line 129
void *snd_async_handler_get_callback_private(snd_async_handler_t *handler ) ;
#line 131
struct snd_shm_area *snd_shm_area_create(int shmid , void *ptr ) ;
#line 132
struct snd_shm_area *snd_shm_area_share(struct snd_shm_area *area ) ;
#line 133
int snd_shm_area_destroy(struct snd_shm_area *area ) ;
#line 135
int snd_user_file(char const   *file , char **result ) ;
#line 64 "/usr/include/alsa/input.h"
int snd_input_stdio_open(snd_input_t **inputp , char const   *file , char const   *mode ) ;
#line 65
int snd_input_stdio_attach(snd_input_t **inputp , FILE *fp , int _close ) ;
#line 66
int snd_input_buffer_open(snd_input_t **inputp , char const   *buffer , ssize_t size ) ;
#line 67
int snd_input_close(snd_input_t *input ) ;
#line 68
int snd_input_scanf(snd_input_t *input , char const   *format  , ...) ;
#line 73
char *snd_input_gets(snd_input_t *input , char *str , size_t size ) ;
#line 74
int snd_input_getc(snd_input_t *input ) ;
#line 75
int snd_input_ungetc(snd_input_t *input , int c ) ;
#line 64 "/usr/include/alsa/output.h"
int snd_output_stdio_open(snd_output_t **outputp , char const   *file , char const   *mode ) ;
#line 65
int snd_output_stdio_attach(snd_output_t **outputp , FILE *fp , int _close ) ;
#line 66
int snd_output_buffer_open(snd_output_t **outputp ) ;
#line 67
size_t snd_output_buffer_string(snd_output_t *output , char **buf ) ;
#line 68
size_t snd_output_buffer_steal(snd_output_t *output , char **buf ) ;
#line 69
int snd_output_close(snd_output_t *output ) ;
#line 70
int snd_output_printf(snd_output_t *output , char const   *format  , ...) ;
#line 75
int snd_output_vprintf(snd_output_t *output , char const   *format , va_list args ) ;
#line 76
int snd_output_puts(snd_output_t *output , char const   *str ) ;
#line 77
int snd_output_putc(snd_output_t *output , int c ) ;
#line 78
int snd_output_flush(snd_output_t *output ) ;
#line 45 "/usr/include/alsa/error.h"
char const   *snd_strerror(int errnum ) ;
#line 60
extern snd_lib_error_handler_t snd_lib_error ;
#line 61
extern int snd_lib_error_set_handler(snd_lib_error_handler_t handler ) ;
#line 82
snd_local_error_handler_t snd_lib_error_set_local(snd_local_error_handler_t func ) ;
#line 85 "/usr/include/alsa/conf.h"
extern snd_config_t *snd_config ;
#line 87
char const   *snd_config_topdir(void) ;
#line 89
int snd_config_top(snd_config_t **config ) ;
#line 91
int snd_config_load(snd_config_t *config , snd_input_t *in ) ;
#line 92
int snd_config_load_string(snd_config_t **config , char const   *s , size_t size ) ;
#line 93
int snd_config_load_override(snd_config_t *config , snd_input_t *in ) ;
#line 94
int snd_config_save(snd_config_t *config , snd_output_t *out ) ;
#line 95
int snd_config_update(void) ;
#line 96
int snd_config_update_r(snd_config_t **top , snd_config_update_t **update , char const   *path ) ;
#line 97
int snd_config_update_free(snd_config_update_t *update ) ;
#line 98
int snd_config_update_free_global(void) ;
#line 100
int snd_config_update_ref(snd_config_t **top ) ;
#line 101
void snd_config_ref(snd_config_t *top ) ;
#line 102
void snd_config_unref(snd_config_t *top ) ;
#line 104
int snd_config_search(snd_config_t *config , char const   *key , snd_config_t **result ) ;
#line 106
int snd_config_searchv(snd_config_t *config , snd_config_t **result  , ...) ;
#line 108
int snd_config_search_definition(snd_config_t *config , char const   *base , char const   *key ,
                                 snd_config_t **result ) ;
#line 114
int snd_config_expand_custom(snd_config_t *config , snd_config_t *root , snd_config_expand_fcn_t fcn ,
                             void *private_data , snd_config_t **result ) ;
#line 117
int snd_config_expand(snd_config_t *config , snd_config_t *root , char const   *args ,
                      snd_config_t *private_data , snd_config_t **result ) ;
#line 120
int snd_config_evaluate(snd_config_t *config , snd_config_t *root , snd_config_t *private_data ,
                        snd_config_t **result ) ;
#line 122
int snd_config_evaluate_string(snd_config_t **dst , char const   *s , snd_config_expand_fcn_t fcn ,
                               void *private_data ) ;
#line 125
int snd_config_add(snd_config_t *config , snd_config_t *child ) ;
#line 126
int snd_config_add_before(snd_config_t *before , snd_config_t *child ) ;
#line 127
int snd_config_add_after(snd_config_t *after , snd_config_t *child ) ;
#line 128
int snd_config_remove(snd_config_t *config ) ;
#line 129
int snd_config_delete(snd_config_t *config ) ;
#line 130
int snd_config_delete_compound_members(snd_config_t *config ) ;
#line 131
int snd_config_copy(snd_config_t **dst , snd_config_t *src ) ;
#line 132
int snd_config_merge(snd_config_t *dst , snd_config_t *src , int override ) ;
#line 134
int snd_config_make(snd_config_t **config , char const   *key , snd_config_type_t type ) ;
#line 136
int snd_config_make_integer(snd_config_t **config , char const   *key ) ;
#line 137
int snd_config_make_integer64(snd_config_t **config , char const   *key ) ;
#line 138
int snd_config_make_real(snd_config_t **config , char const   *key ) ;
#line 139
int snd_config_make_string(snd_config_t **config , char const   *key ) ;
#line 140
int snd_config_make_pointer(snd_config_t **config , char const   *key ) ;
#line 141
int snd_config_make_compound(snd_config_t **config , char const   *key , int join ) ;
#line 142
int snd_config_make_path(snd_config_t **config , snd_config_t *root , char const   *key ,
                         int join , int override ) ;
#line 145
int snd_config_imake_integer(snd_config_t **config , char const   *key , long const   value ) ;
#line 146
int snd_config_imake_integer64(snd_config_t **config , char const   *key , long long const   value ) ;
#line 147
int snd_config_imake_real(snd_config_t **config , char const   *key , double const   value ) ;
#line 148
int snd_config_imake_string(snd_config_t **config , char const   *key , char const   *ascii ) ;
#line 149
int snd_config_imake_safe_string(snd_config_t **config , char const   *key , char const   *ascii ) ;
#line 150
int snd_config_imake_pointer(snd_config_t **config , char const   *key , void const   *ptr ) ;
#line 152
snd_config_type_t snd_config_get_type(snd_config_t *config ) ;
#line 153
int snd_config_is_array(snd_config_t *config ) ;
#line 154
int snd_config_is_empty(snd_config_t *config ) ;
#line 156
int snd_config_set_id(snd_config_t *config , char const   *id ) ;
#line 157
int snd_config_set_integer(snd_config_t *config , long value ) ;
#line 158
int snd_config_set_integer64(snd_config_t *config , long long value ) ;
#line 159
int snd_config_set_real(snd_config_t *config , double value ) ;
#line 160
int snd_config_set_string(snd_config_t *config , char const   *value ) ;
#line 161
int snd_config_set_ascii(snd_config_t *config , char const   *ascii ) ;
#line 162
int snd_config_set_pointer(snd_config_t *config , void const   *ptr ) ;
#line 163
int snd_config_get_id(snd_config_t *config , char const   **value ) ;
#line 164
int snd_config_get_integer(snd_config_t *config , long *value ) ;
#line 165
int snd_config_get_integer64(snd_config_t *config , long long *value ) ;
#line 166
int snd_config_get_real(snd_config_t *config , double *value ) ;
#line 167
int snd_config_get_ireal(snd_config_t *config , double *value ) ;
#line 168
int snd_config_get_string(snd_config_t *config , char const   **value ) ;
#line 169
int snd_config_get_ascii(snd_config_t *config , char **value ) ;
#line 170
int snd_config_get_pointer(snd_config_t *config , void const   **value ) ;
#line 171
int snd_config_test_id(snd_config_t *config , char const   *id ) ;
#line 173
snd_config_iterator_t snd_config_iterator_first(snd_config_t *node ) ;
#line 174
snd_config_iterator_t snd_config_iterator_next(snd_config_iterator_t iterator ) ;
#line 175
snd_config_iterator_t snd_config_iterator_end(snd_config_t *node ) ;
#line 176
snd_config_t *snd_config_iterator_entry(snd_config_iterator_t iterator ) ;
#line 200
int snd_config_get_bool_ascii(char const   *ascii ) ;
#line 201
int snd_config_get_bool(snd_config_t *conf ) ;
#line 202
int snd_config_get_card(snd_config_t *conf ) ;
#line 203
int snd_config_get_ctl_iface_ascii(char const   *ascii ) ;
#line 204
int snd_config_get_ctl_iface(snd_config_t *conf ) ;
#line 222
int snd_names_list(char const   *iface , snd_devname_t **list ) ;
#line 223
void snd_names_list_free(snd_devname_t *list ) ;
#line 504 "/usr/include/alsa/pcm.h"
int snd_pcm_open(snd_pcm_t **pcm , char const   *name , snd_pcm_stream_t stream ,
                 int mode ) ;
#line 506
int snd_pcm_open_lconf(snd_pcm_t **pcm , char const   *name , snd_pcm_stream_t stream ,
                       int mode , snd_config_t *lconf ) ;
#line 509
int snd_pcm_open_fallback(snd_pcm_t **pcm , snd_config_t *root , char const   *name ,
                          char const   *orig_name , snd_pcm_stream_t stream , int mode ) ;
#line 513
int snd_pcm_close(snd_pcm_t *pcm ) ;
#line 514
char const   *snd_pcm_name(snd_pcm_t *pcm ) ;
#line 515
snd_pcm_type_t snd_pcm_type(snd_pcm_t *pcm ) ;
#line 516
snd_pcm_stream_t snd_pcm_stream(snd_pcm_t *pcm ) ;
#line 517
int snd_pcm_poll_descriptors_count(snd_pcm_t *pcm ) ;
#line 518
int snd_pcm_poll_descriptors(snd_pcm_t *pcm , struct pollfd *pfds , unsigned int space ) ;
#line 519
int snd_pcm_poll_descriptors_revents(snd_pcm_t *pcm , struct pollfd *pfds , unsigned int nfds ,
                                     unsigned short *revents ) ;
#line 520
int snd_pcm_nonblock(snd_pcm_t *pcm , int nonblock ) ;
#line 521 "/usr/include/alsa/pcm.h"
__inline static int snd_pcm_abort(snd_pcm_t *pcm ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 521
  __cil_tmp2 = snd_pcm_nonblock(pcm, 2);
  }
#line 521
  return (__cil_tmp2);
}
}
#line 522
int snd_async_add_pcm_handler(snd_async_handler_t **handler , snd_pcm_t *pcm , snd_async_callback_t callback ,
                              void *private_data ) ;
#line 524
snd_pcm_t *snd_async_handler_get_pcm(snd_async_handler_t *handler ) ;
#line 525
int snd_pcm_info(snd_pcm_t *pcm , snd_pcm_info_t *info ) ;
#line 526
int snd_pcm_hw_params_current(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
#line 527
int snd_pcm_hw_params(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
#line 528
int snd_pcm_hw_free(snd_pcm_t *pcm ) ;
#line 529
int snd_pcm_sw_params_current(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ) ;
#line 530
int snd_pcm_sw_params(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ) ;
#line 531
int snd_pcm_prepare(snd_pcm_t *pcm ) ;
#line 532
int snd_pcm_reset(snd_pcm_t *pcm ) ;
#line 533
int snd_pcm_status(snd_pcm_t *pcm , snd_pcm_status_t *status ) ;
#line 534
int snd_pcm_start(snd_pcm_t *pcm ) ;
#line 535
int snd_pcm_drop(snd_pcm_t *pcm ) ;
#line 536
int snd_pcm_drain(snd_pcm_t *pcm ) ;
#line 537
int snd_pcm_pause(snd_pcm_t *pcm , int enable ) ;
#line 538
snd_pcm_state_t snd_pcm_state(snd_pcm_t *pcm ) ;
#line 539
int snd_pcm_hwsync(snd_pcm_t *pcm ) ;
#line 540
int snd_pcm_delay(snd_pcm_t *pcm , snd_pcm_sframes_t *delayp ) ;
#line 541
int snd_pcm_resume(snd_pcm_t *pcm ) ;
#line 542
int snd_pcm_htimestamp(snd_pcm_t *pcm , snd_pcm_uframes_t *avail , snd_htimestamp_t *tstamp ) ;
#line 543
snd_pcm_sframes_t snd_pcm_avail(snd_pcm_t *pcm ) ;
#line 544
snd_pcm_sframes_t snd_pcm_avail_update(snd_pcm_t *pcm ) ;
#line 545
int snd_pcm_avail_delay(snd_pcm_t *pcm , snd_pcm_sframes_t *availp , snd_pcm_sframes_t *delayp ) ;
#line 546
snd_pcm_sframes_t snd_pcm_rewindable(snd_pcm_t *pcm ) ;
#line 547
snd_pcm_sframes_t snd_pcm_rewind(snd_pcm_t *pcm , snd_pcm_uframes_t frames ) ;
#line 548
snd_pcm_sframes_t snd_pcm_forwardable(snd_pcm_t *pcm ) ;
#line 549
snd_pcm_sframes_t snd_pcm_forward(snd_pcm_t *pcm , snd_pcm_uframes_t frames ) ;
#line 550
snd_pcm_sframes_t snd_pcm_writei(snd_pcm_t *pcm , void const   *buffer , snd_pcm_uframes_t size ) ;
#line 551
snd_pcm_sframes_t snd_pcm_readi(snd_pcm_t *pcm , void *buffer , snd_pcm_uframes_t size ) ;
#line 552
snd_pcm_sframes_t snd_pcm_writen(snd_pcm_t *pcm , void **bufs , snd_pcm_uframes_t size ) ;
#line 553
snd_pcm_sframes_t snd_pcm_readn(snd_pcm_t *pcm , void **bufs , snd_pcm_uframes_t size ) ;
#line 554
int snd_pcm_wait(snd_pcm_t *pcm , int timeout ) ;
#line 556
int snd_pcm_link(snd_pcm_t *pcm1 , snd_pcm_t *pcm2 ) ;
#line 557
int snd_pcm_unlink(snd_pcm_t *pcm ) ;
#line 634
snd_pcm_chmap_query_t **snd_pcm_query_chmaps(snd_pcm_t *pcm ) ;
#line 635
snd_pcm_chmap_query_t **snd_pcm_query_chmaps_from_hw(int card , int dev , int subdev ,
                                                     snd_pcm_stream_t stream ) ;
#line 638
void snd_pcm_free_chmaps(snd_pcm_chmap_query_t **maps ) ;
#line 639
snd_pcm_chmap_t *snd_pcm_get_chmap(snd_pcm_t *pcm ) ;
#line 640
int snd_pcm_set_chmap(snd_pcm_t *pcm , snd_pcm_chmap_t *map ) ;
#line 642
char const   *snd_pcm_chmap_type_name(enum snd_pcm_chmap_type val ) ;
#line 643
char const   *snd_pcm_chmap_name(enum snd_pcm_chmap_position val ) ;
#line 644
char const   *snd_pcm_chmap_long_name(enum snd_pcm_chmap_position val ) ;
#line 645
int snd_pcm_chmap_print(snd_pcm_chmap_t *map , size_t maxlen , char *buf ) ;
#line 646
unsigned int snd_pcm_chmap_from_string(char const   *str ) ;
#line 647
snd_pcm_chmap_t *snd_pcm_chmap_parse_string(char const   *str ) ;
#line 656
int snd_pcm_recover(snd_pcm_t *pcm , int err , int silent ) ;
#line 657
int snd_pcm_set_params(snd_pcm_t *pcm , snd_pcm_format_t format , snd_pcm_access_t access ,
                       unsigned int channels , unsigned int rate , int soft_resample ,
                       unsigned int latency ) ;
#line 664
int snd_pcm_get_params(snd_pcm_t *pcm , snd_pcm_uframes_t *buffer_size , snd_pcm_uframes_t *period_size ) ;
#line 677
size_t snd_pcm_info_sizeof(void) ;
#line 683
int snd_pcm_info_malloc(snd_pcm_info_t **ptr ) ;
#line 684
void snd_pcm_info_free(snd_pcm_info_t *obj ) ;
#line 685
void snd_pcm_info_copy(snd_pcm_info_t *dst , snd_pcm_info_t *src ) ;
#line 686
unsigned int snd_pcm_info_get_device(snd_pcm_info_t *obj ) ;
#line 687
unsigned int snd_pcm_info_get_subdevice(snd_pcm_info_t *obj ) ;
#line 688
snd_pcm_stream_t snd_pcm_info_get_stream(snd_pcm_info_t *obj ) ;
#line 689
int snd_pcm_info_get_card(snd_pcm_info_t *obj ) ;
#line 690
char const   *snd_pcm_info_get_id(snd_pcm_info_t *obj ) ;
#line 691
char const   *snd_pcm_info_get_name(snd_pcm_info_t *obj ) ;
#line 692
char const   *snd_pcm_info_get_subdevice_name(snd_pcm_info_t *obj ) ;
#line 693
snd_pcm_class_t snd_pcm_info_get_class(snd_pcm_info_t *obj ) ;
#line 694
snd_pcm_subclass_t snd_pcm_info_get_subclass(snd_pcm_info_t *obj ) ;
#line 695
unsigned int snd_pcm_info_get_subdevices_count(snd_pcm_info_t *obj ) ;
#line 696
unsigned int snd_pcm_info_get_subdevices_avail(snd_pcm_info_t *obj ) ;
#line 697
snd_pcm_sync_id_t snd_pcm_info_get_sync(snd_pcm_info_t *obj ) ;
#line 698
void snd_pcm_info_set_device(snd_pcm_info_t *obj , unsigned int val ) ;
#line 699
void snd_pcm_info_set_subdevice(snd_pcm_info_t *obj , unsigned int val ) ;
#line 700
void snd_pcm_info_set_stream(snd_pcm_info_t *obj , snd_pcm_stream_t val ) ;
#line 711
int snd_pcm_hw_params_any(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
#line 713
int snd_pcm_hw_params_can_mmap_sample_resolution(snd_pcm_hw_params_t *params ) ;
#line 714
int snd_pcm_hw_params_is_double(snd_pcm_hw_params_t *params ) ;
#line 715
int snd_pcm_hw_params_is_batch(snd_pcm_hw_params_t *params ) ;
#line 716
int snd_pcm_hw_params_is_block_transfer(snd_pcm_hw_params_t *params ) ;
#line 717
int snd_pcm_hw_params_is_monotonic(snd_pcm_hw_params_t *params ) ;
#line 718
int snd_pcm_hw_params_can_overrange(snd_pcm_hw_params_t *params ) ;
#line 719
int snd_pcm_hw_params_can_pause(snd_pcm_hw_params_t *params ) ;
#line 720
int snd_pcm_hw_params_can_resume(snd_pcm_hw_params_t *params ) ;
#line 721
int snd_pcm_hw_params_is_half_duplex(snd_pcm_hw_params_t *params ) ;
#line 722
int snd_pcm_hw_params_is_joint_duplex(snd_pcm_hw_params_t *params ) ;
#line 723
int snd_pcm_hw_params_can_sync_start(snd_pcm_hw_params_t *params ) ;
#line 724
int snd_pcm_hw_params_can_disable_period_wakeup(snd_pcm_hw_params_t *params ) ;
#line 725
int snd_pcm_hw_params_supports_audio_wallclock_ts(snd_pcm_hw_params_t *params ) ;
#line 726
int snd_pcm_hw_params_supports_audio_ts_type(snd_pcm_hw_params_t *params , int type ) ;
#line 727
int snd_pcm_hw_params_get_rate_numden(snd_pcm_hw_params_t *params , unsigned int *rate_num ,
                                      unsigned int *rate_den ) ;
#line 730
int snd_pcm_hw_params_get_sbits(snd_pcm_hw_params_t *params ) ;
#line 731
int snd_pcm_hw_params_get_fifo_size(snd_pcm_hw_params_t *params ) ;
#line 759
size_t snd_pcm_hw_params_sizeof(void) ;
#line 765
int snd_pcm_hw_params_malloc(snd_pcm_hw_params_t **ptr ) ;
#line 766
void snd_pcm_hw_params_free(snd_pcm_hw_params_t *obj ) ;
#line 767
void snd_pcm_hw_params_copy(snd_pcm_hw_params_t *dst , snd_pcm_hw_params_t *src ) ;
#line 771
int snd_pcm_hw_params_get_access(snd_pcm_hw_params_t *params , snd_pcm_access_t *_access ) ;
#line 772
int snd_pcm_hw_params_test_access(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , snd_pcm_access_t _access ) ;
#line 773
int snd_pcm_hw_params_set_access(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , snd_pcm_access_t _access ) ;
#line 774
int snd_pcm_hw_params_set_access_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       snd_pcm_access_t *_access ) ;
#line 775
int snd_pcm_hw_params_set_access_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_access_t *_access ) ;
#line 776
int snd_pcm_hw_params_set_access_mask(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_access_mask_t *mask ) ;
#line 777
int snd_pcm_hw_params_get_access_mask(snd_pcm_hw_params_t *params , snd_pcm_access_mask_t *mask ) ;
#line 779
int snd_pcm_hw_params_get_format(snd_pcm_hw_params_t *params , snd_pcm_format_t *val ) ;
#line 780
int snd_pcm_hw_params_test_format(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , snd_pcm_format_t val ) ;
#line 781
int snd_pcm_hw_params_set_format(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , snd_pcm_format_t val ) ;
#line 782
int snd_pcm_hw_params_set_format_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       snd_pcm_format_t *format ) ;
#line 783
int snd_pcm_hw_params_set_format_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_format_t *format ) ;
#line 784
int snd_pcm_hw_params_set_format_mask(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_format_mask_t *mask ) ;
#line 785
void snd_pcm_hw_params_get_format_mask(snd_pcm_hw_params_t *params , snd_pcm_format_mask_t *mask ) ;
#line 787
int snd_pcm_hw_params_get_subformat(snd_pcm_hw_params_t *params , snd_pcm_subformat_t *subformat ) ;
#line 788
int snd_pcm_hw_params_test_subformat(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                     snd_pcm_subformat_t subformat ) ;
#line 789
int snd_pcm_hw_params_set_subformat(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                    snd_pcm_subformat_t subformat ) ;
#line 790
int snd_pcm_hw_params_set_subformat_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          snd_pcm_subformat_t *subformat ) ;
#line 791
int snd_pcm_hw_params_set_subformat_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         snd_pcm_subformat_t *subformat ) ;
#line 792
int snd_pcm_hw_params_set_subformat_mask(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         snd_pcm_subformat_mask_t *mask ) ;
#line 793
void snd_pcm_hw_params_get_subformat_mask(snd_pcm_hw_params_t *params , snd_pcm_subformat_mask_t *mask ) ;
#line 795
int snd_pcm_hw_params_get_channels(snd_pcm_hw_params_t *params , unsigned int *val ) ;
#line 796
int snd_pcm_hw_params_get_channels_min(snd_pcm_hw_params_t *params , unsigned int *val ) ;
#line 797
int snd_pcm_hw_params_get_channels_max(snd_pcm_hw_params_t *params , unsigned int *val ) ;
#line 798
int snd_pcm_hw_params_test_channels(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                    unsigned int val ) ;
#line 799
int snd_pcm_hw_params_set_channels(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                   unsigned int val ) ;
#line 800
int snd_pcm_hw_params_set_channels_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int *val ) ;
#line 801
int snd_pcm_hw_params_set_channels_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int *val ) ;
#line 802
int snd_pcm_hw_params_set_channels_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *min , unsigned int *max ) ;
#line 803
int snd_pcm_hw_params_set_channels_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val ) ;
#line 804
int snd_pcm_hw_params_set_channels_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         unsigned int *val ) ;
#line 805
int snd_pcm_hw_params_set_channels_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val ) ;
#line 807
int snd_pcm_hw_params_get_rate(snd_pcm_hw_params_t *params , unsigned int *val , int *dir ) ;
#line 808
int snd_pcm_hw_params_get_rate_min(snd_pcm_hw_params_t *params , unsigned int *val ,
                                   int *dir ) ;
#line 809
int snd_pcm_hw_params_get_rate_max(snd_pcm_hw_params_t *params , unsigned int *val ,
                                   int *dir ) ;
#line 810
int snd_pcm_hw_params_test_rate(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , unsigned int val ,
                                int dir ) ;
#line 811
int snd_pcm_hw_params_set_rate(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , unsigned int val ,
                               int dir ) ;
#line 812
int snd_pcm_hw_params_set_rate_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                   unsigned int *val , int *dir ) ;
#line 813
int snd_pcm_hw_params_set_rate_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                   unsigned int *val , int *dir ) ;
#line 814
int snd_pcm_hw_params_set_rate_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      unsigned int *min , int *mindir , unsigned int *max ,
                                      int *maxdir ) ;
#line 815
int snd_pcm_hw_params_set_rate_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                    unsigned int *val , int *dir ) ;
#line 816
int snd_pcm_hw_params_set_rate_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                     unsigned int *val , int *dir ) ;
#line 817
int snd_pcm_hw_params_set_rate_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                    unsigned int *val , int *dir ) ;
#line 818
int snd_pcm_hw_params_set_rate_resample(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int val ) ;
#line 819
int snd_pcm_hw_params_get_rate_resample(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val ) ;
#line 820
int snd_pcm_hw_params_set_export_buffer(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int val ) ;
#line 821
int snd_pcm_hw_params_get_export_buffer(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val ) ;
#line 822
int snd_pcm_hw_params_set_period_wakeup(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int val ) ;
#line 823
int snd_pcm_hw_params_get_period_wakeup(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val ) ;
#line 825
int snd_pcm_hw_params_get_period_time(snd_pcm_hw_params_t *params , unsigned int *val ,
                                      int *dir ) ;
#line 826
int snd_pcm_hw_params_get_period_time_min(snd_pcm_hw_params_t *params , unsigned int *val ,
                                          int *dir ) ;
#line 827
int snd_pcm_hw_params_get_period_time_max(snd_pcm_hw_params_t *params , unsigned int *val ,
                                          int *dir ) ;
#line 828
int snd_pcm_hw_params_test_period_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int val , int dir ) ;
#line 829
int snd_pcm_hw_params_set_period_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      unsigned int val , int dir ) ;
#line 830
int snd_pcm_hw_params_set_period_time_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *val , int *dir ) ;
#line 831
int snd_pcm_hw_params_set_period_time_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *val , int *dir ) ;
#line 832
int snd_pcm_hw_params_set_period_time_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                             unsigned int *min , int *mindir , unsigned int *max ,
                                             int *maxdir ) ;
#line 833
int snd_pcm_hw_params_set_period_time_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
#line 834
int snd_pcm_hw_params_set_period_time_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                            unsigned int *val , int *dir ) ;
#line 835
int snd_pcm_hw_params_set_period_time_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
#line 837
int snd_pcm_hw_params_get_period_size(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *frames ,
                                      int *dir ) ;
#line 838
int snd_pcm_hw_params_get_period_size_min(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *frames ,
                                          int *dir ) ;
#line 839
int snd_pcm_hw_params_get_period_size_max(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *frames ,
                                          int *dir ) ;
#line 840
int snd_pcm_hw_params_test_period_size(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       snd_pcm_uframes_t val , int dir ) ;
#line 841
int snd_pcm_hw_params_set_period_size(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_uframes_t val , int dir ) ;
#line 842
int snd_pcm_hw_params_set_period_size_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          snd_pcm_uframes_t *val , int *dir ) ;
#line 843
int snd_pcm_hw_params_set_period_size_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          snd_pcm_uframes_t *val , int *dir ) ;
#line 844
int snd_pcm_hw_params_set_period_size_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                             snd_pcm_uframes_t *min , int *mindir ,
                                             snd_pcm_uframes_t *max , int *maxdir ) ;
#line 845
int snd_pcm_hw_params_set_period_size_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           snd_pcm_uframes_t *val , int *dir ) ;
#line 846
int snd_pcm_hw_params_set_period_size_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                            snd_pcm_uframes_t *val , int *dir ) ;
#line 847
int snd_pcm_hw_params_set_period_size_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           snd_pcm_uframes_t *val , int *dir ) ;
#line 848
int snd_pcm_hw_params_set_period_size_integer(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
#line 850
int snd_pcm_hw_params_get_periods(snd_pcm_hw_params_t *params , unsigned int *val ,
                                  int *dir ) ;
#line 851
int snd_pcm_hw_params_get_periods_min(snd_pcm_hw_params_t *params , unsigned int *val ,
                                      int *dir ) ;
#line 852
int snd_pcm_hw_params_get_periods_max(snd_pcm_hw_params_t *params , unsigned int *val ,
                                      int *dir ) ;
#line 853
int snd_pcm_hw_params_test_periods(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                   unsigned int val , int dir ) ;
#line 854
int snd_pcm_hw_params_set_periods(snd_pcm_t *pcm , snd_pcm_hw_params_t *params , unsigned int val ,
                                  int dir ) ;
#line 855
int snd_pcm_hw_params_set_periods_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      unsigned int *val , int *dir ) ;
#line 856
int snd_pcm_hw_params_set_periods_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      unsigned int *val , int *dir ) ;
#line 857
int snd_pcm_hw_params_set_periods_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         unsigned int *min , int *mindir , unsigned int *max ,
                                         int *maxdir ) ;
#line 858
int snd_pcm_hw_params_set_periods_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int *val , int *dir ) ;
#line 859
int snd_pcm_hw_params_set_periods_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val , int *dir ) ;
#line 860
int snd_pcm_hw_params_set_periods_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int *val , int *dir ) ;
#line 861
int snd_pcm_hw_params_set_periods_integer(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ) ;
#line 863
int snd_pcm_hw_params_get_buffer_time(snd_pcm_hw_params_t *params , unsigned int *val ,
                                      int *dir ) ;
#line 864
int snd_pcm_hw_params_get_buffer_time_min(snd_pcm_hw_params_t *params , unsigned int *val ,
                                          int *dir ) ;
#line 865
int snd_pcm_hw_params_get_buffer_time_max(snd_pcm_hw_params_t *params , unsigned int *val ,
                                          int *dir ) ;
#line 866
int snd_pcm_hw_params_test_buffer_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       unsigned int val , int dir ) ;
#line 867
int snd_pcm_hw_params_set_buffer_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      unsigned int val , int dir ) ;
#line 868
int snd_pcm_hw_params_set_buffer_time_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *val , int *dir ) ;
#line 869
int snd_pcm_hw_params_set_buffer_time_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *val , int *dir ) ;
#line 870
int snd_pcm_hw_params_set_buffer_time_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                             unsigned int *min , int *mindir , unsigned int *max ,
                                             int *maxdir ) ;
#line 871
int snd_pcm_hw_params_set_buffer_time_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
#line 872
int snd_pcm_hw_params_set_buffer_time_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                            unsigned int *val , int *dir ) ;
#line 873
int snd_pcm_hw_params_set_buffer_time_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *val , int *dir ) ;
#line 875
int snd_pcm_hw_params_get_buffer_size(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 876
int snd_pcm_hw_params_get_buffer_size_min(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 877
int snd_pcm_hw_params_get_buffer_size_max(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 878
int snd_pcm_hw_params_test_buffer_size(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                       snd_pcm_uframes_t val ) ;
#line 879
int snd_pcm_hw_params_set_buffer_size(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                      snd_pcm_uframes_t val ) ;
#line 880
int snd_pcm_hw_params_set_buffer_size_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          snd_pcm_uframes_t *val ) ;
#line 881
int snd_pcm_hw_params_set_buffer_size_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          snd_pcm_uframes_t *val ) ;
#line 882
int snd_pcm_hw_params_set_buffer_size_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                             snd_pcm_uframes_t *min , snd_pcm_uframes_t *max ) ;
#line 883
int snd_pcm_hw_params_set_buffer_size_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           snd_pcm_uframes_t *val ) ;
#line 884
int snd_pcm_hw_params_set_buffer_size_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                            snd_pcm_uframes_t *val ) ;
#line 885
int snd_pcm_hw_params_set_buffer_size_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           snd_pcm_uframes_t *val ) ;
#line 889
int snd_pcm_hw_params_get_min_align(snd_pcm_hw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 900
size_t snd_pcm_sw_params_sizeof(void) ;
#line 906
int snd_pcm_sw_params_malloc(snd_pcm_sw_params_t **ptr ) ;
#line 907
void snd_pcm_sw_params_free(snd_pcm_sw_params_t *obj ) ;
#line 908
void snd_pcm_sw_params_copy(snd_pcm_sw_params_t *dst , snd_pcm_sw_params_t *src ) ;
#line 909
int snd_pcm_sw_params_get_boundary(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 913
int snd_pcm_sw_params_set_tstamp_mode(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                      snd_pcm_tstamp_t val ) ;
#line 914
int snd_pcm_sw_params_get_tstamp_mode(snd_pcm_sw_params_t *params , snd_pcm_tstamp_t *val ) ;
#line 915
int snd_pcm_sw_params_set_tstamp_type(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                      snd_pcm_tstamp_type_t val ) ;
#line 916
int snd_pcm_sw_params_get_tstamp_type(snd_pcm_sw_params_t *params , snd_pcm_tstamp_type_t *val ) ;
#line 917
int snd_pcm_sw_params_set_avail_min(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                    snd_pcm_uframes_t val ) ;
#line 918
int snd_pcm_sw_params_get_avail_min(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 919
int snd_pcm_sw_params_set_period_event(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                       int val ) ;
#line 920
int snd_pcm_sw_params_get_period_event(snd_pcm_sw_params_t *params , int *val ) ;
#line 921
int snd_pcm_sw_params_set_start_threshold(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                          snd_pcm_uframes_t val ) ;
#line 922
int snd_pcm_sw_params_get_start_threshold(snd_pcm_sw_params_t *paramsm , snd_pcm_uframes_t *val ) ;
#line 923
int snd_pcm_sw_params_set_stop_threshold(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                         snd_pcm_uframes_t val ) ;
#line 924
int snd_pcm_sw_params_get_stop_threshold(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 925
int snd_pcm_sw_params_set_silence_threshold(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                            snd_pcm_uframes_t val ) ;
#line 926
int snd_pcm_sw_params_get_silence_threshold(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 927
int snd_pcm_sw_params_set_silence_size(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                       snd_pcm_uframes_t val ) ;
#line 928
int snd_pcm_sw_params_get_silence_size(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 948
size_t snd_pcm_access_mask_sizeof(void) ;
#line 954
int snd_pcm_access_mask_malloc(snd_pcm_access_mask_t **ptr ) ;
#line 955
void snd_pcm_access_mask_free(snd_pcm_access_mask_t *obj ) ;
#line 956
void snd_pcm_access_mask_copy(snd_pcm_access_mask_t *dst , snd_pcm_access_mask_t *src ) ;
#line 957
void snd_pcm_access_mask_none(snd_pcm_access_mask_t *mask ) ;
#line 958
void snd_pcm_access_mask_any(snd_pcm_access_mask_t *mask ) ;
#line 959
int snd_pcm_access_mask_test(snd_pcm_access_mask_t *mask , snd_pcm_access_t val ) ;
#line 960
int snd_pcm_access_mask_empty(snd_pcm_access_mask_t *mask ) ;
#line 961
void snd_pcm_access_mask_set(snd_pcm_access_mask_t *mask , snd_pcm_access_t val ) ;
#line 962
void snd_pcm_access_mask_reset(snd_pcm_access_mask_t *mask , snd_pcm_access_t val ) ;
#line 973
size_t snd_pcm_format_mask_sizeof(void) ;
#line 979
int snd_pcm_format_mask_malloc(snd_pcm_format_mask_t **ptr ) ;
#line 980
void snd_pcm_format_mask_free(snd_pcm_format_mask_t *obj ) ;
#line 981
void snd_pcm_format_mask_copy(snd_pcm_format_mask_t *dst , snd_pcm_format_mask_t *src ) ;
#line 982
void snd_pcm_format_mask_none(snd_pcm_format_mask_t *mask ) ;
#line 983
void snd_pcm_format_mask_any(snd_pcm_format_mask_t *mask ) ;
#line 984
int snd_pcm_format_mask_test(snd_pcm_format_mask_t *mask , snd_pcm_format_t val ) ;
#line 985
int snd_pcm_format_mask_empty(snd_pcm_format_mask_t *mask ) ;
#line 986
void snd_pcm_format_mask_set(snd_pcm_format_mask_t *mask , snd_pcm_format_t val ) ;
#line 987
void snd_pcm_format_mask_reset(snd_pcm_format_mask_t *mask , snd_pcm_format_t val ) ;
#line 998
size_t snd_pcm_subformat_mask_sizeof(void) ;
#line 1004
int snd_pcm_subformat_mask_malloc(snd_pcm_subformat_mask_t **ptr ) ;
#line 1005
void snd_pcm_subformat_mask_free(snd_pcm_subformat_mask_t *obj ) ;
#line 1006
void snd_pcm_subformat_mask_copy(snd_pcm_subformat_mask_t *dst , snd_pcm_subformat_mask_t *src ) ;
#line 1007
void snd_pcm_subformat_mask_none(snd_pcm_subformat_mask_t *mask ) ;
#line 1008
void snd_pcm_subformat_mask_any(snd_pcm_subformat_mask_t *mask ) ;
#line 1009
int snd_pcm_subformat_mask_test(snd_pcm_subformat_mask_t *mask , snd_pcm_subformat_t val ) ;
#line 1010
int snd_pcm_subformat_mask_empty(snd_pcm_subformat_mask_t *mask ) ;
#line 1011
void snd_pcm_subformat_mask_set(snd_pcm_subformat_mask_t *mask , snd_pcm_subformat_t val ) ;
#line 1012
void snd_pcm_subformat_mask_reset(snd_pcm_subformat_mask_t *mask , snd_pcm_subformat_t val ) ;
#line 1023
size_t snd_pcm_status_sizeof(void) ;
#line 1029
int snd_pcm_status_malloc(snd_pcm_status_t **ptr ) ;
#line 1030
void snd_pcm_status_free(snd_pcm_status_t *obj ) ;
#line 1031
void snd_pcm_status_copy(snd_pcm_status_t *dst , snd_pcm_status_t *src ) ;
#line 1032
snd_pcm_state_t snd_pcm_status_get_state(snd_pcm_status_t *obj ) ;
#line 1033
void snd_pcm_status_get_trigger_tstamp(snd_pcm_status_t *obj , snd_timestamp_t *ptr ) ;
#line 1034
void snd_pcm_status_get_trigger_htstamp(snd_pcm_status_t *obj , snd_htimestamp_t *ptr ) ;
#line 1035
void snd_pcm_status_get_tstamp(snd_pcm_status_t *obj , snd_timestamp_t *ptr ) ;
#line 1036
void snd_pcm_status_get_htstamp(snd_pcm_status_t *obj , snd_htimestamp_t *ptr ) ;
#line 1037
void snd_pcm_status_get_audio_htstamp(snd_pcm_status_t *obj , snd_htimestamp_t *ptr ) ;
#line 1038
void snd_pcm_status_get_driver_htstamp(snd_pcm_status_t *obj , snd_htimestamp_t *ptr ) ;
#line 1039
void snd_pcm_status_get_audio_htstamp_report(snd_pcm_status_t *obj , snd_pcm_audio_tstamp_report_t *audio_tstamp_report ) ;
#line 1041
void snd_pcm_status_set_audio_htstamp_config(snd_pcm_status_t *obj , snd_pcm_audio_tstamp_config_t *audio_tstamp_config ) ;
#line 1044 "/usr/include/alsa/pcm.h"
__inline static void snd_pcm_pack_audio_tstamp_config(unsigned int *data , snd_pcm_audio_tstamp_config_t *config ) 
{ 


  {
#line 1047
  *data = config->report_delay;
#line 1048
  *data <<= 4;
#line 1049
  *data |= config->type_requested;
  return;
}
}
#line 1052 "/usr/include/alsa/pcm.h"
__inline static void snd_pcm_unpack_audio_tstamp_report(unsigned int data , unsigned int accuracy ,
                                                        snd_pcm_audio_tstamp_report_t *report ) 
{ 


  {
#line 1055
  data >>= 16;
#line 1056
  report->valid = data & 1U;
#line 1057
  report->actual_type = (data >> 1) & 15U;
#line 1058
  report->accuracy_report = (data >> 5) & 1U;
#line 1059
  report->accuracy = accuracy;
  return;
}
}
#line 1062
snd_pcm_sframes_t snd_pcm_status_get_delay(snd_pcm_status_t *obj ) ;
#line 1063
snd_pcm_uframes_t snd_pcm_status_get_avail(snd_pcm_status_t *obj ) ;
#line 1064
snd_pcm_uframes_t snd_pcm_status_get_avail_max(snd_pcm_status_t *obj ) ;
#line 1065
snd_pcm_uframes_t snd_pcm_status_get_overrange(snd_pcm_status_t *obj ) ;
#line 1076
char const   *snd_pcm_type_name(snd_pcm_type_t type ) ;
#line 1077
char const   *snd_pcm_stream_name(snd_pcm_stream_t stream ) ;
#line 1078
char const   *snd_pcm_access_name(snd_pcm_access_t _access ) ;
#line 1079
char const   *snd_pcm_format_name(snd_pcm_format_t format ) ;
#line 1080
char const   *snd_pcm_format_description(snd_pcm_format_t format ) ;
#line 1081
char const   *snd_pcm_subformat_name(snd_pcm_subformat_t subformat ) ;
#line 1082
char const   *snd_pcm_subformat_description(snd_pcm_subformat_t subformat ) ;
#line 1083
snd_pcm_format_t snd_pcm_format_value(char const   *name ) ;
#line 1084
char const   *snd_pcm_tstamp_mode_name(snd_pcm_tstamp_t mode ) ;
#line 1085
char const   *snd_pcm_state_name(snd_pcm_state_t state ) ;
#line 1096
int snd_pcm_dump(snd_pcm_t *pcm , snd_output_t *out ) ;
#line 1097
int snd_pcm_dump_hw_setup(snd_pcm_t *pcm , snd_output_t *out ) ;
#line 1098
int snd_pcm_dump_sw_setup(snd_pcm_t *pcm , snd_output_t *out ) ;
#line 1099
int snd_pcm_dump_setup(snd_pcm_t *pcm , snd_output_t *out ) ;
#line 1100
int snd_pcm_hw_params_dump(snd_pcm_hw_params_t *params , snd_output_t *out ) ;
#line 1101
int snd_pcm_sw_params_dump(snd_pcm_sw_params_t *params , snd_output_t *out ) ;
#line 1102
int snd_pcm_status_dump(snd_pcm_status_t *status , snd_output_t *out ) ;
#line 1113
int snd_pcm_mmap_begin(snd_pcm_t *pcm , snd_pcm_channel_area_t **areas , snd_pcm_uframes_t *offset ,
                       snd_pcm_uframes_t *frames ) ;
#line 1117
snd_pcm_sframes_t snd_pcm_mmap_commit(snd_pcm_t *pcm , snd_pcm_uframes_t offset ,
                                      snd_pcm_uframes_t frames ) ;
#line 1120
snd_pcm_sframes_t snd_pcm_mmap_writei(snd_pcm_t *pcm , void const   *buffer , snd_pcm_uframes_t size ) ;
#line 1121
snd_pcm_sframes_t snd_pcm_mmap_readi(snd_pcm_t *pcm , void *buffer , snd_pcm_uframes_t size ) ;
#line 1122
snd_pcm_sframes_t snd_pcm_mmap_writen(snd_pcm_t *pcm , void **bufs , snd_pcm_uframes_t size ) ;
#line 1123
snd_pcm_sframes_t snd_pcm_mmap_readn(snd_pcm_t *pcm , void **bufs , snd_pcm_uframes_t size ) ;
#line 1134
int snd_pcm_format_signed(snd_pcm_format_t format ) ;
#line 1135
int snd_pcm_format_unsigned(snd_pcm_format_t format ) ;
#line 1136
int snd_pcm_format_linear(snd_pcm_format_t format ) ;
#line 1137
int snd_pcm_format_float(snd_pcm_format_t format ) ;
#line 1138
int snd_pcm_format_little_endian(snd_pcm_format_t format ) ;
#line 1139
int snd_pcm_format_big_endian(snd_pcm_format_t format ) ;
#line 1140
int snd_pcm_format_cpu_endian(snd_pcm_format_t format ) ;
#line 1141
int snd_pcm_format_width(snd_pcm_format_t format ) ;
#line 1142
int snd_pcm_format_physical_width(snd_pcm_format_t format ) ;
#line 1143
snd_pcm_format_t snd_pcm_build_linear_format(int width , int pwidth , int unsignd ,
                                             int big_endian ) ;
#line 1144
ssize_t snd_pcm_format_size(snd_pcm_format_t format , size_t samples ) ;
#line 1145
uint8_t snd_pcm_format_silence(snd_pcm_format_t format ) ;
#line 1146
uint16_t snd_pcm_format_silence_16(snd_pcm_format_t format ) ;
#line 1147
uint32_t snd_pcm_format_silence_32(snd_pcm_format_t format ) ;
#line 1148
uint64_t snd_pcm_format_silence_64(snd_pcm_format_t format ) ;
#line 1149
int snd_pcm_format_set_silence(snd_pcm_format_t format , void *buf , unsigned int samples ) ;
#line 1151
snd_pcm_sframes_t snd_pcm_bytes_to_frames(snd_pcm_t *pcm , ssize_t bytes ) ;
#line 1152
ssize_t snd_pcm_frames_to_bytes(snd_pcm_t *pcm , snd_pcm_sframes_t frames ) ;
#line 1153
long snd_pcm_bytes_to_samples(snd_pcm_t *pcm , ssize_t bytes ) ;
#line 1154
ssize_t snd_pcm_samples_to_bytes(snd_pcm_t *pcm , long samples ) ;
#line 1156
int snd_pcm_area_silence(snd_pcm_channel_area_t *dst_channel , snd_pcm_uframes_t dst_offset ,
                         unsigned int samples , snd_pcm_format_t format ) ;
#line 1158
int snd_pcm_areas_silence(snd_pcm_channel_area_t *dst_channels , snd_pcm_uframes_t dst_offset ,
                          unsigned int channels , snd_pcm_uframes_t frames , snd_pcm_format_t format ) ;
#line 1160
int snd_pcm_area_copy(snd_pcm_channel_area_t *dst_channel , snd_pcm_uframes_t dst_offset ,
                      snd_pcm_channel_area_t *src_channel , snd_pcm_uframes_t src_offset ,
                      unsigned int samples , snd_pcm_format_t format ) ;
#line 1163
int snd_pcm_areas_copy(snd_pcm_channel_area_t *dst_channels , snd_pcm_uframes_t dst_offset ,
                       snd_pcm_channel_area_t *src_channels , snd_pcm_uframes_t src_offset ,
                       unsigned int channels , snd_pcm_uframes_t frames , snd_pcm_format_t format ) ;
#line 1166
int snd_pcm_areas_copy_wrap(snd_pcm_channel_area_t *dst_channels , snd_pcm_uframes_t dst_offset ,
                            snd_pcm_uframes_t dst_size , snd_pcm_channel_area_t *src_channels ,
                            snd_pcm_uframes_t src_offset , snd_pcm_uframes_t src_size ,
                            unsigned int const   channels , snd_pcm_uframes_t frames ,
                            snd_pcm_format_t format ) ;
#line 1183 "/usr/include/alsa/pcm.h"
__inline static void *snd_pcm_channel_area_addr(snd_pcm_channel_area_t *area , snd_pcm_uframes_t offset ) 
{ 


  {
#line 1185
  return ((char *)area->addr + ((unsigned long )area->first + (unsigned long )area->step * offset) / 8UL);
}
}
#line 1194 "/usr/include/alsa/pcm.h"
__inline static unsigned int snd_pcm_channel_area_step(snd_pcm_channel_area_t *area ) 
{ 


  {
#line 1196
  return (area->step / 8U);
}
}
#line 1220
snd_pcm_t *snd_pcm_hook_get_pcm(snd_pcm_hook_t *hook ) ;
#line 1221
void *snd_pcm_hook_get_private(snd_pcm_hook_t *hook ) ;
#line 1222
void snd_pcm_hook_set_private(snd_pcm_hook_t *hook , void *private_data ) ;
#line 1223
int snd_pcm_hook_add(snd_pcm_hook_t **hookp , snd_pcm_t *pcm , snd_pcm_hook_type_t type ,
                     snd_pcm_hook_func_t func , void *private_data ) ;
#line 1226
int snd_pcm_hook_remove(snd_pcm_hook_t *hook ) ;
#line 1269
snd_pcm_uframes_t snd_pcm_meter_get_bufsize(snd_pcm_t *pcm ) ;
#line 1270
unsigned int snd_pcm_meter_get_channels(snd_pcm_t *pcm ) ;
#line 1271
unsigned int snd_pcm_meter_get_rate(snd_pcm_t *pcm ) ;
#line 1272
snd_pcm_uframes_t snd_pcm_meter_get_now(snd_pcm_t *pcm ) ;
#line 1273
snd_pcm_uframes_t snd_pcm_meter_get_boundary(snd_pcm_t *pcm ) ;
#line 1274
int snd_pcm_meter_add_scope(snd_pcm_t *pcm , snd_pcm_scope_t *scope ) ;
#line 1275
snd_pcm_scope_t *snd_pcm_meter_search_scope(snd_pcm_t *pcm , char const   *name ) ;
#line 1276
int snd_pcm_scope_malloc(snd_pcm_scope_t **ptr ) ;
#line 1277
void snd_pcm_scope_set_ops(snd_pcm_scope_t *scope , snd_pcm_scope_ops_t *val ) ;
#line 1279
void snd_pcm_scope_set_name(snd_pcm_scope_t *scope , char const   *val ) ;
#line 1280
char const   *snd_pcm_scope_get_name(snd_pcm_scope_t *scope ) ;
#line 1281
void *snd_pcm_scope_get_callback_private(snd_pcm_scope_t *scope ) ;
#line 1282
void snd_pcm_scope_set_callback_private(snd_pcm_scope_t *scope , void *val ) ;
#line 1283
int snd_pcm_scope_s16_open(snd_pcm_t *pcm , char const   *name , snd_pcm_scope_t **scopep ) ;
#line 1285
int16_t *snd_pcm_scope_s16_get_channel_buffer(snd_pcm_scope_t *scope , unsigned int channel ) ;
#line 1326
int snd_spcm_init(snd_pcm_t *pcm , unsigned int rate , unsigned int channels , snd_pcm_format_t format ,
                  snd_pcm_subformat_t subformat , snd_spcm_latency_t latency , snd_pcm_access_t _access ,
                  snd_spcm_xrun_type_t xrun_type ) ;
#line 1335
int snd_spcm_init_duplex(snd_pcm_t *playback_pcm , snd_pcm_t *capture_pcm , unsigned int rate ,
                         unsigned int channels , snd_pcm_format_t format , snd_pcm_subformat_t subformat ,
                         snd_spcm_latency_t latency , snd_pcm_access_t _access , snd_spcm_xrun_type_t xrun_type ,
                         snd_spcm_duplex_type_t duplex_type ) ;
#line 1346
int snd_spcm_init_get_params(snd_pcm_t *pcm , unsigned int *rate , snd_pcm_uframes_t *buffer_size ,
                             snd_pcm_uframes_t *period_size ) ;
#line 1361
char const   *snd_pcm_start_mode_name(snd_pcm_start_t mode ) ;
#line 1362
char const   *snd_pcm_xrun_mode_name(snd_pcm_xrun_t mode ) ;
#line 1363
int snd_pcm_sw_params_set_start_mode(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                     snd_pcm_start_t val ) ;
#line 1364
snd_pcm_start_t snd_pcm_sw_params_get_start_mode(snd_pcm_sw_params_t *params ) ;
#line 1365
int snd_pcm_sw_params_set_xrun_mode(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                    snd_pcm_xrun_t val ) ;
#line 1366
snd_pcm_xrun_t snd_pcm_sw_params_get_xrun_mode(snd_pcm_sw_params_t *params ) ;
#line 1368
int snd_pcm_sw_params_set_xfer_align(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                     snd_pcm_uframes_t val ) ;
#line 1369
int snd_pcm_sw_params_get_xfer_align(snd_pcm_sw_params_t *params , snd_pcm_uframes_t *val ) ;
#line 1370
int snd_pcm_sw_params_set_sleep_min(snd_pcm_t *pcm , snd_pcm_sw_params_t *params ,
                                    unsigned int val ) ;
#line 1371
int snd_pcm_sw_params_get_sleep_min(snd_pcm_sw_params_t *params , unsigned int *val ) ;
#line 1374
int snd_pcm_hw_params_get_tick_time(snd_pcm_hw_params_t *params , unsigned int *val ,
                                    int *dir ) ;
#line 1375
int snd_pcm_hw_params_get_tick_time_min(snd_pcm_hw_params_t *params , unsigned int *val ,
                                        int *dir ) ;
#line 1376
int snd_pcm_hw_params_get_tick_time_max(snd_pcm_hw_params_t *params , unsigned int *val ,
                                        int *dir ) ;
#line 1377
int snd_pcm_hw_params_test_tick_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                     unsigned int val , int dir ) ;
#line 1378
int snd_pcm_hw_params_set_tick_time(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                    unsigned int val , int dir ) ;
#line 1379
int snd_pcm_hw_params_set_tick_time_min(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val , int *dir ) ;
#line 1380
int snd_pcm_hw_params_set_tick_time_max(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                        unsigned int *val , int *dir ) ;
#line 1381
int snd_pcm_hw_params_set_tick_time_minmax(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                           unsigned int *min , int *mindir , unsigned int *max ,
                                           int *maxdir ) ;
#line 1382
int snd_pcm_hw_params_set_tick_time_near(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         unsigned int *val , int *dir ) ;
#line 1383
int snd_pcm_hw_params_set_tick_time_first(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                          unsigned int *val , int *dir ) ;
#line 1384
int snd_pcm_hw_params_set_tick_time_last(snd_pcm_t *pcm , snd_pcm_hw_params_t *params ,
                                         unsigned int *val , int *dir ) ;
#line 96 "/usr/include/alsa/rawmidi.h"
int snd_rawmidi_open(snd_rawmidi_t **in_rmidi , snd_rawmidi_t **out_rmidi , char const   *name ,
                     int mode ) ;
#line 98
int snd_rawmidi_open_lconf(snd_rawmidi_t **in_rmidi , snd_rawmidi_t **out_rmidi ,
                           char const   *name , int mode , snd_config_t *lconf ) ;
#line 100
int snd_rawmidi_close(snd_rawmidi_t *rmidi ) ;
#line 101
int snd_rawmidi_poll_descriptors_count(snd_rawmidi_t *rmidi ) ;
#line 102
int snd_rawmidi_poll_descriptors(snd_rawmidi_t *rmidi , struct pollfd *pfds , unsigned int space ) ;
#line 103
int snd_rawmidi_poll_descriptors_revents(snd_rawmidi_t *rawmidi , struct pollfd *pfds ,
                                         unsigned int nfds , unsigned short *revent ) ;
#line 104
int snd_rawmidi_nonblock(snd_rawmidi_t *rmidi , int nonblock ) ;
#line 105
size_t snd_rawmidi_info_sizeof(void) ;
#line 111
int snd_rawmidi_info_malloc(snd_rawmidi_info_t **ptr ) ;
#line 112
void snd_rawmidi_info_free(snd_rawmidi_info_t *obj ) ;
#line 113
void snd_rawmidi_info_copy(snd_rawmidi_info_t *dst , snd_rawmidi_info_t *src ) ;
#line 114
unsigned int snd_rawmidi_info_get_device(snd_rawmidi_info_t *obj ) ;
#line 115
unsigned int snd_rawmidi_info_get_subdevice(snd_rawmidi_info_t *obj ) ;
#line 116
snd_rawmidi_stream_t snd_rawmidi_info_get_stream(snd_rawmidi_info_t *obj ) ;
#line 117
int snd_rawmidi_info_get_card(snd_rawmidi_info_t *obj ) ;
#line 118
unsigned int snd_rawmidi_info_get_flags(snd_rawmidi_info_t *obj ) ;
#line 119
char const   *snd_rawmidi_info_get_id(snd_rawmidi_info_t *obj ) ;
#line 120
char const   *snd_rawmidi_info_get_name(snd_rawmidi_info_t *obj ) ;
#line 121
char const   *snd_rawmidi_info_get_subdevice_name(snd_rawmidi_info_t *obj ) ;
#line 122
unsigned int snd_rawmidi_info_get_subdevices_count(snd_rawmidi_info_t *obj ) ;
#line 123
unsigned int snd_rawmidi_info_get_subdevices_avail(snd_rawmidi_info_t *obj ) ;
#line 124
void snd_rawmidi_info_set_device(snd_rawmidi_info_t *obj , unsigned int val ) ;
#line 125
void snd_rawmidi_info_set_subdevice(snd_rawmidi_info_t *obj , unsigned int val ) ;
#line 126
void snd_rawmidi_info_set_stream(snd_rawmidi_info_t *obj , snd_rawmidi_stream_t val ) ;
#line 127
int snd_rawmidi_info(snd_rawmidi_t *rmidi , snd_rawmidi_info_t *info ) ;
#line 128
size_t snd_rawmidi_params_sizeof(void) ;
#line 134
int snd_rawmidi_params_malloc(snd_rawmidi_params_t **ptr ) ;
#line 135
void snd_rawmidi_params_free(snd_rawmidi_params_t *obj ) ;
#line 136
void snd_rawmidi_params_copy(snd_rawmidi_params_t *dst , snd_rawmidi_params_t *src ) ;
#line 137
int snd_rawmidi_params_set_buffer_size(snd_rawmidi_t *rmidi , snd_rawmidi_params_t *params ,
                                       size_t val ) ;
#line 138
size_t snd_rawmidi_params_get_buffer_size(snd_rawmidi_params_t *params ) ;
#line 139
int snd_rawmidi_params_set_avail_min(snd_rawmidi_t *rmidi , snd_rawmidi_params_t *params ,
                                     size_t val ) ;
#line 140
size_t snd_rawmidi_params_get_avail_min(snd_rawmidi_params_t *params ) ;
#line 141
int snd_rawmidi_params_set_no_active_sensing(snd_rawmidi_t *rmidi , snd_rawmidi_params_t *params ,
                                             int val ) ;
#line 142
int snd_rawmidi_params_get_no_active_sensing(snd_rawmidi_params_t *params ) ;
#line 143
int snd_rawmidi_params_set_read_mode(snd_rawmidi_t *rawmidi , snd_rawmidi_params_t *params ,
                                     snd_rawmidi_read_mode_t val ) ;
#line 144
snd_rawmidi_read_mode_t snd_rawmidi_params_get_read_mode(snd_rawmidi_params_t *params ) ;
#line 145
int snd_rawmidi_params_set_clock_type(snd_rawmidi_t *rawmidi , snd_rawmidi_params_t *params ,
                                      snd_rawmidi_clock_t val ) ;
#line 146
snd_rawmidi_clock_t snd_rawmidi_params_get_clock_type(snd_rawmidi_params_t *params ) ;
#line 148
int snd_rawmidi_params(snd_rawmidi_t *rmidi , snd_rawmidi_params_t *params ) ;
#line 149
int snd_rawmidi_params_current(snd_rawmidi_t *rmidi , snd_rawmidi_params_t *params ) ;
#line 150
size_t snd_rawmidi_status_sizeof(void) ;
#line 156
int snd_rawmidi_status_malloc(snd_rawmidi_status_t **ptr ) ;
#line 157
void snd_rawmidi_status_free(snd_rawmidi_status_t *obj ) ;
#line 158
void snd_rawmidi_status_copy(snd_rawmidi_status_t *dst , snd_rawmidi_status_t *src ) ;
#line 159
void snd_rawmidi_status_get_tstamp(snd_rawmidi_status_t *obj , snd_htimestamp_t *ptr ) ;
#line 160
size_t snd_rawmidi_status_get_avail(snd_rawmidi_status_t *obj ) ;
#line 161
size_t snd_rawmidi_status_get_xruns(snd_rawmidi_status_t *obj ) ;
#line 162
int snd_rawmidi_status(snd_rawmidi_t *rmidi , snd_rawmidi_status_t *status ) ;
#line 163
int snd_rawmidi_drain(snd_rawmidi_t *rmidi ) ;
#line 164
int snd_rawmidi_drop(snd_rawmidi_t *rmidi ) ;
#line 165
ssize_t snd_rawmidi_write(snd_rawmidi_t *rmidi , void const   *buffer , size_t size ) ;
#line 166
ssize_t snd_rawmidi_read(snd_rawmidi_t *rmidi , void *buffer , size_t size ) ;
#line 167
ssize_t snd_rawmidi_tread(snd_rawmidi_t *rmidi , struct timespec *tstamp , void *buffer ,
                          size_t size ) ;
#line 168
char const   *snd_rawmidi_name(snd_rawmidi_t *rmidi ) ;
#line 169
snd_rawmidi_type_t snd_rawmidi_type(snd_rawmidi_t *rmidi ) ;
#line 170
snd_rawmidi_stream_t snd_rawmidi_stream(snd_rawmidi_t *rawmidi ) ;
#line 142 "/usr/include/alsa/timer.h"
int snd_timer_query_open(snd_timer_query_t **handle , char const   *name , int mode ) ;
#line 143
int snd_timer_query_open_lconf(snd_timer_query_t **handle , char const   *name , int mode ,
                               snd_config_t *lconf ) ;
#line 144
int snd_timer_query_close(snd_timer_query_t *handle ) ;
#line 145
int snd_timer_query_next_device(snd_timer_query_t *handle , snd_timer_id_t *tid ) ;
#line 146
int snd_timer_query_info(snd_timer_query_t *handle , snd_timer_ginfo_t *info ) ;
#line 147
int snd_timer_query_params(snd_timer_query_t *handle , snd_timer_gparams_t *params ) ;
#line 148
int snd_timer_query_status(snd_timer_query_t *handle , snd_timer_gstatus_t *status ) ;
#line 150
int snd_timer_open(snd_timer_t **handle , char const   *name , int mode ) ;
#line 151
int snd_timer_open_lconf(snd_timer_t **handle , char const   *name , int mode , snd_config_t *lconf ) ;
#line 152
int snd_timer_close(snd_timer_t *handle ) ;
#line 153
int snd_async_add_timer_handler(snd_async_handler_t **handler , snd_timer_t *timer ,
                                snd_async_callback_t callback , void *private_data ) ;
#line 155
snd_timer_t *snd_async_handler_get_timer(snd_async_handler_t *handler ) ;
#line 156
int snd_timer_poll_descriptors_count(snd_timer_t *handle ) ;
#line 157
int snd_timer_poll_descriptors(snd_timer_t *handle , struct pollfd *pfds , unsigned int space ) ;
#line 158
int snd_timer_poll_descriptors_revents(snd_timer_t *timer , struct pollfd *pfds ,
                                       unsigned int nfds , unsigned short *revents ) ;
#line 159
int snd_timer_info(snd_timer_t *handle , snd_timer_info_t *timer ) ;
#line 160
int snd_timer_params(snd_timer_t *handle , snd_timer_params_t *params ) ;
#line 161
int snd_timer_status(snd_timer_t *handle , snd_timer_status_t *status ) ;
#line 162
int snd_timer_start(snd_timer_t *handle ) ;
#line 163
int snd_timer_stop(snd_timer_t *handle ) ;
#line 164
int snd_timer_continue(snd_timer_t *handle ) ;
#line 165
ssize_t snd_timer_read(snd_timer_t *handle , void *buffer , size_t size ) ;
#line 167
size_t snd_timer_id_sizeof(void) ;
#line 170
int snd_timer_id_malloc(snd_timer_id_t **ptr ) ;
#line 171
void snd_timer_id_free(snd_timer_id_t *obj ) ;
#line 172
void snd_timer_id_copy(snd_timer_id_t *dst , snd_timer_id_t *src ) ;
#line 174
void snd_timer_id_set_class(snd_timer_id_t *id , int dev_class ) ;
#line 175
int snd_timer_id_get_class(snd_timer_id_t *id ) ;
#line 176
void snd_timer_id_set_sclass(snd_timer_id_t *id , int dev_sclass ) ;
#line 177
int snd_timer_id_get_sclass(snd_timer_id_t *id ) ;
#line 178
void snd_timer_id_set_card(snd_timer_id_t *id , int card ) ;
#line 179
int snd_timer_id_get_card(snd_timer_id_t *id ) ;
#line 180
void snd_timer_id_set_device(snd_timer_id_t *id , int device ) ;
#line 181
int snd_timer_id_get_device(snd_timer_id_t *id ) ;
#line 182
void snd_timer_id_set_subdevice(snd_timer_id_t *id , int subdevice ) ;
#line 183
int snd_timer_id_get_subdevice(snd_timer_id_t *id ) ;
#line 185
size_t snd_timer_ginfo_sizeof(void) ;
#line 188
int snd_timer_ginfo_malloc(snd_timer_ginfo_t **ptr ) ;
#line 189
void snd_timer_ginfo_free(snd_timer_ginfo_t *obj ) ;
#line 190
void snd_timer_ginfo_copy(snd_timer_ginfo_t *dst , snd_timer_ginfo_t *src ) ;
#line 192
int snd_timer_ginfo_set_tid(snd_timer_ginfo_t *obj , snd_timer_id_t *tid ) ;
#line 193
snd_timer_id_t *snd_timer_ginfo_get_tid(snd_timer_ginfo_t *obj ) ;
#line 194
unsigned int snd_timer_ginfo_get_flags(snd_timer_ginfo_t *obj ) ;
#line 195
int snd_timer_ginfo_get_card(snd_timer_ginfo_t *obj ) ;
#line 196
char *snd_timer_ginfo_get_id(snd_timer_ginfo_t *obj ) ;
#line 197
char *snd_timer_ginfo_get_name(snd_timer_ginfo_t *obj ) ;
#line 198
unsigned long snd_timer_ginfo_get_resolution(snd_timer_ginfo_t *obj ) ;
#line 199
unsigned long snd_timer_ginfo_get_resolution_min(snd_timer_ginfo_t *obj ) ;
#line 200
unsigned long snd_timer_ginfo_get_resolution_max(snd_timer_ginfo_t *obj ) ;
#line 201
unsigned int snd_timer_ginfo_get_clients(snd_timer_ginfo_t *obj ) ;
#line 203
size_t snd_timer_info_sizeof(void) ;
#line 206
int snd_timer_info_malloc(snd_timer_info_t **ptr ) ;
#line 207
void snd_timer_info_free(snd_timer_info_t *obj ) ;
#line 208
void snd_timer_info_copy(snd_timer_info_t *dst , snd_timer_info_t *src ) ;
#line 210
int snd_timer_info_is_slave(snd_timer_info_t *info ) ;
#line 211
int snd_timer_info_get_card(snd_timer_info_t *info ) ;
#line 212
char const   *snd_timer_info_get_id(snd_timer_info_t *info ) ;
#line 213
char const   *snd_timer_info_get_name(snd_timer_info_t *info ) ;
#line 214
long snd_timer_info_get_resolution(snd_timer_info_t *info ) ;
#line 216
size_t snd_timer_params_sizeof(void) ;
#line 219
int snd_timer_params_malloc(snd_timer_params_t **ptr ) ;
#line 220
void snd_timer_params_free(snd_timer_params_t *obj ) ;
#line 221
void snd_timer_params_copy(snd_timer_params_t *dst , snd_timer_params_t *src ) ;
#line 223
int snd_timer_params_set_auto_start(snd_timer_params_t *params , int auto_start ) ;
#line 224
int snd_timer_params_get_auto_start(snd_timer_params_t *params ) ;
#line 225
int snd_timer_params_set_exclusive(snd_timer_params_t *params , int exclusive ) ;
#line 226
int snd_timer_params_get_exclusive(snd_timer_params_t *params ) ;
#line 227
int snd_timer_params_set_early_event(snd_timer_params_t *params , int early_event ) ;
#line 228
int snd_timer_params_get_early_event(snd_timer_params_t *params ) ;
#line 229
void snd_timer_params_set_ticks(snd_timer_params_t *params , long ticks ) ;
#line 230
long snd_timer_params_get_ticks(snd_timer_params_t *params ) ;
#line 231
void snd_timer_params_set_queue_size(snd_timer_params_t *params , long queue_size ) ;
#line 232
long snd_timer_params_get_queue_size(snd_timer_params_t *params ) ;
#line 233
void snd_timer_params_set_filter(snd_timer_params_t *params , unsigned int filter ) ;
#line 234
unsigned int snd_timer_params_get_filter(snd_timer_params_t *params ) ;
#line 236
size_t snd_timer_status_sizeof(void) ;
#line 239
int snd_timer_status_malloc(snd_timer_status_t **ptr ) ;
#line 240
void snd_timer_status_free(snd_timer_status_t *obj ) ;
#line 241
void snd_timer_status_copy(snd_timer_status_t *dst , snd_timer_status_t *src ) ;
#line 243
snd_htimestamp_t snd_timer_status_get_timestamp(snd_timer_status_t *status ) ;
#line 244
long snd_timer_status_get_resolution(snd_timer_status_t *status ) ;
#line 245
long snd_timer_status_get_lost(snd_timer_status_t *status ) ;
#line 246
long snd_timer_status_get_overrun(snd_timer_status_t *status ) ;
#line 247
long snd_timer_status_get_queue(snd_timer_status_t *status ) ;
#line 250
long snd_timer_info_get_ticks(snd_timer_info_t *info ) ;
#line 108 "/usr/include/alsa/hwdep.h"
int snd_hwdep_open(snd_hwdep_t **hwdep , char const   *name , int mode ) ;
#line 109
int snd_hwdep_close(snd_hwdep_t *hwdep ) ;
#line 110
int snd_hwdep_poll_descriptors(snd_hwdep_t *hwdep , struct pollfd *pfds , unsigned int space ) ;
#line 111
int snd_hwdep_poll_descriptors_count(snd_hwdep_t *hwdep ) ;
#line 112
int snd_hwdep_poll_descriptors_revents(snd_hwdep_t *hwdep , struct pollfd *pfds ,
                                       unsigned int nfds , unsigned short *revents ) ;
#line 113
int snd_hwdep_nonblock(snd_hwdep_t *hwdep , int nonblock ) ;
#line 114
int snd_hwdep_info(snd_hwdep_t *hwdep , snd_hwdep_info_t *info ) ;
#line 115
int snd_hwdep_dsp_status(snd_hwdep_t *hwdep , snd_hwdep_dsp_status_t *status ) ;
#line 116
int snd_hwdep_dsp_load(snd_hwdep_t *hwdep , snd_hwdep_dsp_image_t *block ) ;
#line 117
int snd_hwdep_ioctl(snd_hwdep_t *hwdep , unsigned int request , void *arg ) ;
#line 118
ssize_t snd_hwdep_write(snd_hwdep_t *hwdep , void const   *buffer , size_t size ) ;
#line 119
ssize_t snd_hwdep_read(snd_hwdep_t *hwdep , void *buffer , size_t size ) ;
#line 121
size_t snd_hwdep_info_sizeof(void) ;
#line 124
int snd_hwdep_info_malloc(snd_hwdep_info_t **ptr ) ;
#line 125
void snd_hwdep_info_free(snd_hwdep_info_t *obj ) ;
#line 126
void snd_hwdep_info_copy(snd_hwdep_info_t *dst , snd_hwdep_info_t *src ) ;
#line 128
unsigned int snd_hwdep_info_get_device(snd_hwdep_info_t *obj ) ;
#line 129
int snd_hwdep_info_get_card(snd_hwdep_info_t *obj ) ;
#line 130
char const   *snd_hwdep_info_get_id(snd_hwdep_info_t *obj ) ;
#line 131
char const   *snd_hwdep_info_get_name(snd_hwdep_info_t *obj ) ;
#line 132
snd_hwdep_iface_t snd_hwdep_info_get_iface(snd_hwdep_info_t *obj ) ;
#line 133
void snd_hwdep_info_set_device(snd_hwdep_info_t *obj , unsigned int val ) ;
#line 135
size_t snd_hwdep_dsp_status_sizeof(void) ;
#line 138
int snd_hwdep_dsp_status_malloc(snd_hwdep_dsp_status_t **ptr ) ;
#line 139
void snd_hwdep_dsp_status_free(snd_hwdep_dsp_status_t *obj ) ;
#line 140
void snd_hwdep_dsp_status_copy(snd_hwdep_dsp_status_t *dst , snd_hwdep_dsp_status_t *src ) ;
#line 142
unsigned int snd_hwdep_dsp_status_get_version(snd_hwdep_dsp_status_t *obj ) ;
#line 143
char const   *snd_hwdep_dsp_status_get_id(snd_hwdep_dsp_status_t *obj ) ;
#line 144
unsigned int snd_hwdep_dsp_status_get_num_dsps(snd_hwdep_dsp_status_t *obj ) ;
#line 145
unsigned int snd_hwdep_dsp_status_get_dsp_loaded(snd_hwdep_dsp_status_t *obj ) ;
#line 146
unsigned int snd_hwdep_dsp_status_get_chip_ready(snd_hwdep_dsp_status_t *obj ) ;
#line 148
size_t snd_hwdep_dsp_image_sizeof(void) ;
#line 151
int snd_hwdep_dsp_image_malloc(snd_hwdep_dsp_image_t **ptr ) ;
#line 152
void snd_hwdep_dsp_image_free(snd_hwdep_dsp_image_t *obj ) ;
#line 153
void snd_hwdep_dsp_image_copy(snd_hwdep_dsp_image_t *dst , snd_hwdep_dsp_image_t *src ) ;
#line 155
unsigned int snd_hwdep_dsp_image_get_index(snd_hwdep_dsp_image_t *obj ) ;
#line 156
char const   *snd_hwdep_dsp_image_get_name(snd_hwdep_dsp_image_t *obj ) ;
#line 157
void const   *snd_hwdep_dsp_image_get_image(snd_hwdep_dsp_image_t *obj ) ;
#line 158
size_t snd_hwdep_dsp_image_get_length(snd_hwdep_dsp_image_t *obj ) ;
#line 160
void snd_hwdep_dsp_image_set_index(snd_hwdep_dsp_image_t *obj , unsigned int _index ) ;
#line 161
void snd_hwdep_dsp_image_set_name(snd_hwdep_dsp_image_t *obj , char const   *name ) ;
#line 162
void snd_hwdep_dsp_image_set_image(snd_hwdep_dsp_image_t *obj , void *buffer ) ;
#line 163
void snd_hwdep_dsp_image_set_length(snd_hwdep_dsp_image_t *obj , size_t length ) ;
#line 368 "/usr/include/alsa/control.h"
int snd_card_load(int card ) ;
#line 369
int snd_card_next(int *card ) ;
#line 370
int snd_card_get_index(char const   *name ) ;
#line 371
int snd_card_get_name(int card , char **name ) ;
#line 372
int snd_card_get_longname(int card , char **name ) ;
#line 374
int snd_device_name_hint(int card , char const   *iface , void ***hints ) ;
#line 375
int snd_device_name_free_hint(void **hints ) ;
#line 376
char *snd_device_name_get_hint(void const   *hint , char const   *id ) ;
#line 378
int snd_ctl_open(snd_ctl_t **ctl , char const   *name , int mode ) ;
#line 379
int snd_ctl_open_lconf(snd_ctl_t **ctl , char const   *name , int mode , snd_config_t *lconf ) ;
#line 380
int snd_ctl_open_fallback(snd_ctl_t **ctl , snd_config_t *root , char const   *name ,
                          char const   *orig_name , int mode ) ;
#line 381
int snd_ctl_close(snd_ctl_t *ctl ) ;
#line 382
int snd_ctl_nonblock(snd_ctl_t *ctl , int nonblock ) ;
#line 383 "/usr/include/alsa/control.h"
__inline static int snd_ctl_abort(snd_ctl_t *ctl ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 383
  __cil_tmp2 = snd_ctl_nonblock(ctl, 2);
  }
#line 383
  return (__cil_tmp2);
}
}
#line 384
int snd_async_add_ctl_handler(snd_async_handler_t **handler , snd_ctl_t *ctl , snd_async_callback_t callback ,
                              void *private_data ) ;
#line 386
snd_ctl_t *snd_async_handler_get_ctl(snd_async_handler_t *handler ) ;
#line 387
int snd_ctl_poll_descriptors_count(snd_ctl_t *ctl ) ;
#line 388
int snd_ctl_poll_descriptors(snd_ctl_t *ctl , struct pollfd *pfds , unsigned int space ) ;
#line 389
int snd_ctl_poll_descriptors_revents(snd_ctl_t *ctl , struct pollfd *pfds , unsigned int nfds ,
                                     unsigned short *revents ) ;
#line 390
int snd_ctl_subscribe_events(snd_ctl_t *ctl , int subscribe ) ;
#line 391
int snd_ctl_card_info(snd_ctl_t *ctl , snd_ctl_card_info_t *info ) ;
#line 392
int snd_ctl_elem_list(snd_ctl_t *ctl , snd_ctl_elem_list_t *list ) ;
#line 393
int snd_ctl_elem_info(snd_ctl_t *ctl , snd_ctl_elem_info_t *info ) ;
#line 394
int snd_ctl_elem_read(snd_ctl_t *ctl , snd_ctl_elem_value_t *data ) ;
#line 395
int snd_ctl_elem_write(snd_ctl_t *ctl , snd_ctl_elem_value_t *data ) ;
#line 396
int snd_ctl_elem_lock(snd_ctl_t *ctl , snd_ctl_elem_id_t *id ) ;
#line 397
int snd_ctl_elem_unlock(snd_ctl_t *ctl , snd_ctl_elem_id_t *id ) ;
#line 398
int snd_ctl_elem_tlv_read(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int *tlv ,
                          unsigned int tlv_size ) ;
#line 400
int snd_ctl_elem_tlv_write(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int const   *tlv ) ;
#line 402
int snd_ctl_elem_tlv_command(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int const   *tlv ) ;
#line 405
int snd_ctl_hwdep_next_device(snd_ctl_t *ctl , int *device ) ;
#line 406
int snd_ctl_hwdep_info(snd_ctl_t *ctl , snd_hwdep_info_t *info ) ;
#line 409
int snd_ctl_pcm_next_device(snd_ctl_t *ctl , int *device ) ;
#line 410
int snd_ctl_pcm_info(snd_ctl_t *ctl , snd_pcm_info_t *info ) ;
#line 411
int snd_ctl_pcm_prefer_subdevice(snd_ctl_t *ctl , int subdev ) ;
#line 414
int snd_ctl_rawmidi_next_device(snd_ctl_t *ctl , int *device ) ;
#line 415
int snd_ctl_rawmidi_info(snd_ctl_t *ctl , snd_rawmidi_info_t *info ) ;
#line 416
int snd_ctl_rawmidi_prefer_subdevice(snd_ctl_t *ctl , int subdev ) ;
#line 418
int snd_ctl_set_power_state(snd_ctl_t *ctl , unsigned int state ) ;
#line 419
int snd_ctl_get_power_state(snd_ctl_t *ctl , unsigned int *state ) ;
#line 421
int snd_ctl_read(snd_ctl_t *ctl , snd_ctl_event_t *event ) ;
#line 422
int snd_ctl_wait(snd_ctl_t *ctl , int timeout ) ;
#line 423
char const   *snd_ctl_name(snd_ctl_t *ctl ) ;
#line 424
snd_ctl_type_t snd_ctl_type(snd_ctl_t *ctl ) ;
#line 426
char const   *snd_ctl_elem_type_name(snd_ctl_elem_type_t type ) ;
#line 427
char const   *snd_ctl_elem_iface_name(snd_ctl_elem_iface_t iface ) ;
#line 428
char const   *snd_ctl_event_type_name(snd_ctl_event_type_t type ) ;
#line 430
unsigned int snd_ctl_event_elem_get_mask(snd_ctl_event_t *obj ) ;
#line 431
unsigned int snd_ctl_event_elem_get_numid(snd_ctl_event_t *obj ) ;
#line 432
void snd_ctl_event_elem_get_id(snd_ctl_event_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 433
snd_ctl_elem_iface_t snd_ctl_event_elem_get_interface(snd_ctl_event_t *obj ) ;
#line 434
unsigned int snd_ctl_event_elem_get_device(snd_ctl_event_t *obj ) ;
#line 435
unsigned int snd_ctl_event_elem_get_subdevice(snd_ctl_event_t *obj ) ;
#line 436
char const   *snd_ctl_event_elem_get_name(snd_ctl_event_t *obj ) ;
#line 437
unsigned int snd_ctl_event_elem_get_index(snd_ctl_event_t *obj ) ;
#line 439
int snd_ctl_elem_list_alloc_space(snd_ctl_elem_list_t *obj , unsigned int entries ) ;
#line 440
void snd_ctl_elem_list_free_space(snd_ctl_elem_list_t *obj ) ;
#line 442
char *snd_ctl_ascii_elem_id_get(snd_ctl_elem_id_t *id ) ;
#line 443
int snd_ctl_ascii_elem_id_parse(snd_ctl_elem_id_t *dst , char const   *str ) ;
#line 444
int snd_ctl_ascii_value_parse(snd_ctl_t *handle , snd_ctl_elem_value_t *dst , snd_ctl_elem_info_t *info ,
                              char const   *value ) ;
#line 449
size_t snd_ctl_elem_id_sizeof(void) ;
#line 455
int snd_ctl_elem_id_malloc(snd_ctl_elem_id_t **ptr ) ;
#line 456
void snd_ctl_elem_id_free(snd_ctl_elem_id_t *obj ) ;
#line 457
void snd_ctl_elem_id_clear(snd_ctl_elem_id_t *obj ) ;
#line 458
void snd_ctl_elem_id_copy(snd_ctl_elem_id_t *dst , snd_ctl_elem_id_t *src ) ;
#line 459
int snd_ctl_elem_id_compare_numid(snd_ctl_elem_id_t *id1 , snd_ctl_elem_id_t *id2 ) ;
#line 460
int snd_ctl_elem_id_compare_set(snd_ctl_elem_id_t *id1 , snd_ctl_elem_id_t *id2 ) ;
#line 461
unsigned int snd_ctl_elem_id_get_numid(snd_ctl_elem_id_t *obj ) ;
#line 462
snd_ctl_elem_iface_t snd_ctl_elem_id_get_interface(snd_ctl_elem_id_t *obj ) ;
#line 463
unsigned int snd_ctl_elem_id_get_device(snd_ctl_elem_id_t *obj ) ;
#line 464
unsigned int snd_ctl_elem_id_get_subdevice(snd_ctl_elem_id_t *obj ) ;
#line 465
char const   *snd_ctl_elem_id_get_name(snd_ctl_elem_id_t *obj ) ;
#line 466
unsigned int snd_ctl_elem_id_get_index(snd_ctl_elem_id_t *obj ) ;
#line 467
void snd_ctl_elem_id_set_numid(snd_ctl_elem_id_t *obj , unsigned int val ) ;
#line 468
void snd_ctl_elem_id_set_interface(snd_ctl_elem_id_t *obj , snd_ctl_elem_iface_t val ) ;
#line 469
void snd_ctl_elem_id_set_device(snd_ctl_elem_id_t *obj , unsigned int val ) ;
#line 470
void snd_ctl_elem_id_set_subdevice(snd_ctl_elem_id_t *obj , unsigned int val ) ;
#line 471
void snd_ctl_elem_id_set_name(snd_ctl_elem_id_t *obj , char const   *val ) ;
#line 472
void snd_ctl_elem_id_set_index(snd_ctl_elem_id_t *obj , unsigned int val ) ;
#line 474
size_t snd_ctl_card_info_sizeof(void) ;
#line 489
int snd_ctl_card_info_malloc(snd_ctl_card_info_t **ptr ) ;
#line 490
void snd_ctl_card_info_free(snd_ctl_card_info_t *obj ) ;
#line 491
void snd_ctl_card_info_clear(snd_ctl_card_info_t *obj ) ;
#line 492
void snd_ctl_card_info_copy(snd_ctl_card_info_t *dst , snd_ctl_card_info_t *src ) ;
#line 493
int snd_ctl_card_info_get_card(snd_ctl_card_info_t *obj ) ;
#line 494
char const   *snd_ctl_card_info_get_id(snd_ctl_card_info_t *obj ) ;
#line 495
char const   *snd_ctl_card_info_get_driver(snd_ctl_card_info_t *obj ) ;
#line 496
char const   *snd_ctl_card_info_get_name(snd_ctl_card_info_t *obj ) ;
#line 497
char const   *snd_ctl_card_info_get_longname(snd_ctl_card_info_t *obj ) ;
#line 498
char const   *snd_ctl_card_info_get_mixername(snd_ctl_card_info_t *obj ) ;
#line 499
char const   *snd_ctl_card_info_get_components(snd_ctl_card_info_t *obj ) ;
#line 501
size_t snd_ctl_event_sizeof(void) ;
#line 507
int snd_ctl_event_malloc(snd_ctl_event_t **ptr ) ;
#line 508
void snd_ctl_event_free(snd_ctl_event_t *obj ) ;
#line 509
void snd_ctl_event_clear(snd_ctl_event_t *obj ) ;
#line 510
void snd_ctl_event_copy(snd_ctl_event_t *dst , snd_ctl_event_t *src ) ;
#line 511
snd_ctl_event_type_t snd_ctl_event_get_type(snd_ctl_event_t *obj ) ;
#line 513
size_t snd_ctl_elem_list_sizeof(void) ;
#line 526
int snd_ctl_elem_list_malloc(snd_ctl_elem_list_t **ptr ) ;
#line 527
void snd_ctl_elem_list_free(snd_ctl_elem_list_t *obj ) ;
#line 528
void snd_ctl_elem_list_clear(snd_ctl_elem_list_t *obj ) ;
#line 529
void snd_ctl_elem_list_copy(snd_ctl_elem_list_t *dst , snd_ctl_elem_list_t *src ) ;
#line 530
void snd_ctl_elem_list_set_offset(snd_ctl_elem_list_t *obj , unsigned int val ) ;
#line 531
unsigned int snd_ctl_elem_list_get_used(snd_ctl_elem_list_t *obj ) ;
#line 532
unsigned int snd_ctl_elem_list_get_count(snd_ctl_elem_list_t *obj ) ;
#line 533
void snd_ctl_elem_list_get_id(snd_ctl_elem_list_t *obj , unsigned int idx , snd_ctl_elem_id_t *ptr ) ;
#line 534
unsigned int snd_ctl_elem_list_get_numid(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 535
snd_ctl_elem_iface_t snd_ctl_elem_list_get_interface(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 536
unsigned int snd_ctl_elem_list_get_device(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 537
unsigned int snd_ctl_elem_list_get_subdevice(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 538
char const   *snd_ctl_elem_list_get_name(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 539
unsigned int snd_ctl_elem_list_get_index(snd_ctl_elem_list_t *obj , unsigned int idx ) ;
#line 541
size_t snd_ctl_elem_info_sizeof(void) ;
#line 547
int snd_ctl_elem_info_malloc(snd_ctl_elem_info_t **ptr ) ;
#line 548
void snd_ctl_elem_info_free(snd_ctl_elem_info_t *obj ) ;
#line 549
void snd_ctl_elem_info_clear(snd_ctl_elem_info_t *obj ) ;
#line 550
void snd_ctl_elem_info_copy(snd_ctl_elem_info_t *dst , snd_ctl_elem_info_t *src ) ;
#line 551
snd_ctl_elem_type_t snd_ctl_elem_info_get_type(snd_ctl_elem_info_t *obj ) ;
#line 552
int snd_ctl_elem_info_is_readable(snd_ctl_elem_info_t *obj ) ;
#line 553
int snd_ctl_elem_info_is_writable(snd_ctl_elem_info_t *obj ) ;
#line 554
int snd_ctl_elem_info_is_volatile(snd_ctl_elem_info_t *obj ) ;
#line 555
int snd_ctl_elem_info_is_inactive(snd_ctl_elem_info_t *obj ) ;
#line 556
int snd_ctl_elem_info_is_locked(snd_ctl_elem_info_t *obj ) ;
#line 557
int snd_ctl_elem_info_is_tlv_readable(snd_ctl_elem_info_t *obj ) ;
#line 558
int snd_ctl_elem_info_is_tlv_writable(snd_ctl_elem_info_t *obj ) ;
#line 559
int snd_ctl_elem_info_is_tlv_commandable(snd_ctl_elem_info_t *obj ) ;
#line 560
int snd_ctl_elem_info_is_owner(snd_ctl_elem_info_t *obj ) ;
#line 561
int snd_ctl_elem_info_is_user(snd_ctl_elem_info_t *obj ) ;
#line 562
pid_t snd_ctl_elem_info_get_owner(snd_ctl_elem_info_t *obj ) ;
#line 563
unsigned int snd_ctl_elem_info_get_count(snd_ctl_elem_info_t *obj ) ;
#line 564
long snd_ctl_elem_info_get_min(snd_ctl_elem_info_t *obj ) ;
#line 565
long snd_ctl_elem_info_get_max(snd_ctl_elem_info_t *obj ) ;
#line 566
long snd_ctl_elem_info_get_step(snd_ctl_elem_info_t *obj ) ;
#line 567
long long snd_ctl_elem_info_get_min64(snd_ctl_elem_info_t *obj ) ;
#line 568
long long snd_ctl_elem_info_get_max64(snd_ctl_elem_info_t *obj ) ;
#line 569
long long snd_ctl_elem_info_get_step64(snd_ctl_elem_info_t *obj ) ;
#line 570
unsigned int snd_ctl_elem_info_get_items(snd_ctl_elem_info_t *obj ) ;
#line 571
void snd_ctl_elem_info_set_item(snd_ctl_elem_info_t *obj , unsigned int val ) ;
#line 572
char const   *snd_ctl_elem_info_get_item_name(snd_ctl_elem_info_t *obj ) ;
#line 573
int snd_ctl_elem_info_get_dimensions(snd_ctl_elem_info_t *obj ) ;
#line 574
int snd_ctl_elem_info_get_dimension(snd_ctl_elem_info_t *obj , unsigned int idx ) ;
#line 575
int snd_ctl_elem_info_set_dimension(snd_ctl_elem_info_t *info , int const   dimension[4] ) ;
#line 577
void snd_ctl_elem_info_get_id(snd_ctl_elem_info_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 578
unsigned int snd_ctl_elem_info_get_numid(snd_ctl_elem_info_t *obj ) ;
#line 579
snd_ctl_elem_iface_t snd_ctl_elem_info_get_interface(snd_ctl_elem_info_t *obj ) ;
#line 580
unsigned int snd_ctl_elem_info_get_device(snd_ctl_elem_info_t *obj ) ;
#line 581
unsigned int snd_ctl_elem_info_get_subdevice(snd_ctl_elem_info_t *obj ) ;
#line 582
char const   *snd_ctl_elem_info_get_name(snd_ctl_elem_info_t *obj ) ;
#line 583
unsigned int snd_ctl_elem_info_get_index(snd_ctl_elem_info_t *obj ) ;
#line 584
void snd_ctl_elem_info_set_id(snd_ctl_elem_info_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 585
void snd_ctl_elem_info_set_numid(snd_ctl_elem_info_t *obj , unsigned int val ) ;
#line 586
void snd_ctl_elem_info_set_interface(snd_ctl_elem_info_t *obj , snd_ctl_elem_iface_t val ) ;
#line 587
void snd_ctl_elem_info_set_device(snd_ctl_elem_info_t *obj , unsigned int val ) ;
#line 588
void snd_ctl_elem_info_set_subdevice(snd_ctl_elem_info_t *obj , unsigned int val ) ;
#line 589
void snd_ctl_elem_info_set_name(snd_ctl_elem_info_t *obj , char const   *val ) ;
#line 590
void snd_ctl_elem_info_set_index(snd_ctl_elem_info_t *obj , unsigned int val ) ;
#line 591
void snd_ctl_elem_info_set_read_write(snd_ctl_elem_info_t *obj , int rval , int wval ) ;
#line 592
void snd_ctl_elem_info_set_tlv_read_write(snd_ctl_elem_info_t *obj , int rval , int wval ) ;
#line 593
void snd_ctl_elem_info_set_inactive(snd_ctl_elem_info_t *obj , int val ) ;
#line 595
int snd_ctl_add_integer_elem_set(snd_ctl_t *ctl , snd_ctl_elem_info_t *info , unsigned int element_count ,
                                 unsigned int member_count , long min , long max ,
                                 long step ) ;
#line 599
int snd_ctl_add_integer64_elem_set(snd_ctl_t *ctl , snd_ctl_elem_info_t *info , unsigned int element_count ,
                                   unsigned int member_count , long long min , long long max ,
                                   long long step ) ;
#line 604
int snd_ctl_add_boolean_elem_set(snd_ctl_t *ctl , snd_ctl_elem_info_t *info , unsigned int element_count ,
                                 unsigned int member_count ) ;
#line 607
int snd_ctl_add_enumerated_elem_set(snd_ctl_t *ctl , snd_ctl_elem_info_t *info , unsigned int element_count ,
                                    unsigned int member_count , unsigned int items ,
                                    char const   * const  labels[] ) ;
#line 612
int snd_ctl_add_bytes_elem_set(snd_ctl_t *ctl , snd_ctl_elem_info_t *info , unsigned int element_count ,
                               unsigned int member_count ) ;
#line 616
int snd_ctl_elem_add_integer(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int count ,
                             long imin , long imax , long istep ) ;
#line 617
int snd_ctl_elem_add_integer64(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int count ,
                               long long imin , long long imax , long long istep ) ;
#line 618
int snd_ctl_elem_add_boolean(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int count ) ;
#line 619
int snd_ctl_elem_add_enumerated(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , unsigned int count ,
                                unsigned int items , char const   * const  names[] ) ;
#line 620
int snd_ctl_elem_add_iec958(snd_ctl_t *ctl , snd_ctl_elem_id_t *id ) ;
#line 621
int snd_ctl_elem_remove(snd_ctl_t *ctl , snd_ctl_elem_id_t *id ) ;
#line 623
size_t snd_ctl_elem_value_sizeof(void) ;
#line 638
int snd_ctl_elem_value_malloc(snd_ctl_elem_value_t **ptr ) ;
#line 639
void snd_ctl_elem_value_free(snd_ctl_elem_value_t *obj ) ;
#line 640
void snd_ctl_elem_value_clear(snd_ctl_elem_value_t *obj ) ;
#line 641
void snd_ctl_elem_value_copy(snd_ctl_elem_value_t *dst , snd_ctl_elem_value_t *src ) ;
#line 642
int snd_ctl_elem_value_compare(snd_ctl_elem_value_t *left , snd_ctl_elem_value_t *right ) ;
#line 643
void snd_ctl_elem_value_get_id(snd_ctl_elem_value_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 644
unsigned int snd_ctl_elem_value_get_numid(snd_ctl_elem_value_t *obj ) ;
#line 645
snd_ctl_elem_iface_t snd_ctl_elem_value_get_interface(snd_ctl_elem_value_t *obj ) ;
#line 646
unsigned int snd_ctl_elem_value_get_device(snd_ctl_elem_value_t *obj ) ;
#line 647
unsigned int snd_ctl_elem_value_get_subdevice(snd_ctl_elem_value_t *obj ) ;
#line 648
char const   *snd_ctl_elem_value_get_name(snd_ctl_elem_value_t *obj ) ;
#line 649
unsigned int snd_ctl_elem_value_get_index(snd_ctl_elem_value_t *obj ) ;
#line 650
void snd_ctl_elem_value_set_id(snd_ctl_elem_value_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 651
void snd_ctl_elem_value_set_numid(snd_ctl_elem_value_t *obj , unsigned int val ) ;
#line 652
void snd_ctl_elem_value_set_interface(snd_ctl_elem_value_t *obj , snd_ctl_elem_iface_t val ) ;
#line 653
void snd_ctl_elem_value_set_device(snd_ctl_elem_value_t *obj , unsigned int val ) ;
#line 654
void snd_ctl_elem_value_set_subdevice(snd_ctl_elem_value_t *obj , unsigned int val ) ;
#line 655
void snd_ctl_elem_value_set_name(snd_ctl_elem_value_t *obj , char const   *val ) ;
#line 656
void snd_ctl_elem_value_set_index(snd_ctl_elem_value_t *obj , unsigned int val ) ;
#line 657
int snd_ctl_elem_value_get_boolean(snd_ctl_elem_value_t *obj , unsigned int idx ) ;
#line 658
long snd_ctl_elem_value_get_integer(snd_ctl_elem_value_t *obj , unsigned int idx ) ;
#line 659
long long snd_ctl_elem_value_get_integer64(snd_ctl_elem_value_t *obj , unsigned int idx ) ;
#line 660
unsigned int snd_ctl_elem_value_get_enumerated(snd_ctl_elem_value_t *obj , unsigned int idx ) ;
#line 661
unsigned char snd_ctl_elem_value_get_byte(snd_ctl_elem_value_t *obj , unsigned int idx ) ;
#line 662
void snd_ctl_elem_value_set_boolean(snd_ctl_elem_value_t *obj , unsigned int idx ,
                                    long val ) ;
#line 663
void snd_ctl_elem_value_set_integer(snd_ctl_elem_value_t *obj , unsigned int idx ,
                                    long val ) ;
#line 664
void snd_ctl_elem_value_set_integer64(snd_ctl_elem_value_t *obj , unsigned int idx ,
                                      long long val ) ;
#line 665
void snd_ctl_elem_value_set_enumerated(snd_ctl_elem_value_t *obj , unsigned int idx ,
                                       unsigned int val ) ;
#line 666
void snd_ctl_elem_value_set_byte(snd_ctl_elem_value_t *obj , unsigned int idx , unsigned char val ) ;
#line 667
void snd_ctl_elem_set_bytes(snd_ctl_elem_value_t *obj , void *data , size_t size ) ;
#line 668
void const   *snd_ctl_elem_value_get_bytes(snd_ctl_elem_value_t *obj ) ;
#line 669
void snd_ctl_elem_value_get_iec958(snd_ctl_elem_value_t *obj , snd_aes_iec958_t *ptr ) ;
#line 670
void snd_ctl_elem_value_set_iec958(snd_ctl_elem_value_t *obj , snd_aes_iec958_t *ptr ) ;
#line 672
int snd_tlv_parse_dB_info(unsigned int *tlv , unsigned int tlv_size , unsigned int **db_tlvp ) ;
#line 674
int snd_tlv_get_dB_range(unsigned int *tlv , long rangemin , long rangemax , long *min ,
                         long *max ) ;
#line 676
int snd_tlv_convert_to_dB(unsigned int *tlv , long rangemin , long rangemax , long volume ,
                          long *db_gain ) ;
#line 678
int snd_tlv_convert_from_dB(unsigned int *tlv , long rangemin , long rangemax , long db_gain ,
                            long *value , int xdir ) ;
#line 680
int snd_ctl_get_dB_range(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , long *min , long *max ) ;
#line 682
int snd_ctl_convert_to_dB(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , long volume , long *db_gain ) ;
#line 684
int snd_ctl_convert_from_dB(snd_ctl_t *ctl , snd_ctl_elem_id_t *id , long db_gain ,
                            long *value , int xdir ) ;
#line 709
int snd_hctl_compare_fast(snd_hctl_elem_t *c1 , snd_hctl_elem_t *c2 ) ;
#line 730
int snd_hctl_open(snd_hctl_t **hctl , char const   *name , int mode ) ;
#line 731
int snd_hctl_open_ctl(snd_hctl_t **hctlp , snd_ctl_t *ctl ) ;
#line 732
int snd_hctl_close(snd_hctl_t *hctl ) ;
#line 733
int snd_hctl_nonblock(snd_hctl_t *hctl , int nonblock ) ;
#line 734 "/usr/include/alsa/control.h"
__inline static int snd_hctl_abort(snd_hctl_t *hctl ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 734
  __cil_tmp2 = snd_hctl_nonblock(hctl, 2);
  }
#line 734
  return (__cil_tmp2);
}
}
#line 735
int snd_hctl_poll_descriptors_count(snd_hctl_t *hctl ) ;
#line 736
int snd_hctl_poll_descriptors(snd_hctl_t *hctl , struct pollfd *pfds , unsigned int space ) ;
#line 737
int snd_hctl_poll_descriptors_revents(snd_hctl_t *ctl , struct pollfd *pfds , unsigned int nfds ,
                                      unsigned short *revents ) ;
#line 738
unsigned int snd_hctl_get_count(snd_hctl_t *hctl ) ;
#line 739
int snd_hctl_set_compare(snd_hctl_t *hctl , snd_hctl_compare_t hsort ) ;
#line 740
snd_hctl_elem_t *snd_hctl_first_elem(snd_hctl_t *hctl ) ;
#line 741
snd_hctl_elem_t *snd_hctl_last_elem(snd_hctl_t *hctl ) ;
#line 742
snd_hctl_elem_t *snd_hctl_find_elem(snd_hctl_t *hctl , snd_ctl_elem_id_t *id ) ;
#line 743
void snd_hctl_set_callback(snd_hctl_t *hctl , snd_hctl_callback_t callback ) ;
#line 744
void snd_hctl_set_callback_private(snd_hctl_t *hctl , void *data ) ;
#line 745
void *snd_hctl_get_callback_private(snd_hctl_t *hctl ) ;
#line 746
int snd_hctl_load(snd_hctl_t *hctl ) ;
#line 747
int snd_hctl_free(snd_hctl_t *hctl ) ;
#line 748
int snd_hctl_handle_events(snd_hctl_t *hctl ) ;
#line 749
char const   *snd_hctl_name(snd_hctl_t *hctl ) ;
#line 750
int snd_hctl_wait(snd_hctl_t *hctl , int timeout ) ;
#line 751
snd_ctl_t *snd_hctl_ctl(snd_hctl_t *hctl ) ;
#line 753
snd_hctl_elem_t *snd_hctl_elem_next(snd_hctl_elem_t *elem ) ;
#line 754
snd_hctl_elem_t *snd_hctl_elem_prev(snd_hctl_elem_t *elem ) ;
#line 755
int snd_hctl_elem_info(snd_hctl_elem_t *elem , snd_ctl_elem_info_t *info ) ;
#line 756
int snd_hctl_elem_read(snd_hctl_elem_t *elem , snd_ctl_elem_value_t *value ) ;
#line 757
int snd_hctl_elem_write(snd_hctl_elem_t *elem , snd_ctl_elem_value_t *value ) ;
#line 758
int snd_hctl_elem_tlv_read(snd_hctl_elem_t *elem , unsigned int *tlv , unsigned int tlv_size ) ;
#line 759
int snd_hctl_elem_tlv_write(snd_hctl_elem_t *elem , unsigned int const   *tlv ) ;
#line 760
int snd_hctl_elem_tlv_command(snd_hctl_elem_t *elem , unsigned int const   *tlv ) ;
#line 762
snd_hctl_t *snd_hctl_elem_get_hctl(snd_hctl_elem_t *elem ) ;
#line 764
void snd_hctl_elem_get_id(snd_hctl_elem_t *obj , snd_ctl_elem_id_t *ptr ) ;
#line 765
unsigned int snd_hctl_elem_get_numid(snd_hctl_elem_t *obj ) ;
#line 766
snd_ctl_elem_iface_t snd_hctl_elem_get_interface(snd_hctl_elem_t *obj ) ;
#line 767
unsigned int snd_hctl_elem_get_device(snd_hctl_elem_t *obj ) ;
#line 768
unsigned int snd_hctl_elem_get_subdevice(snd_hctl_elem_t *obj ) ;
#line 769
char const   *snd_hctl_elem_get_name(snd_hctl_elem_t *obj ) ;
#line 770
unsigned int snd_hctl_elem_get_index(snd_hctl_elem_t *obj ) ;
#line 771
void snd_hctl_elem_set_callback(snd_hctl_elem_t *obj , snd_hctl_elem_callback_t val ) ;
#line 772
void *snd_hctl_elem_get_callback_private(snd_hctl_elem_t *obj ) ;
#line 773
void snd_hctl_elem_set_callback_private(snd_hctl_elem_t *obj , void *val ) ;
#line 786
int snd_sctl_build(snd_sctl_t **ctl , snd_ctl_t *handle , snd_config_t *config , snd_config_t *private_data ,
                   int mode ) ;
#line 788
int snd_sctl_free(snd_sctl_t *handle ) ;
#line 789
int snd_sctl_install(snd_sctl_t *handle ) ;
#line 790
int snd_sctl_remove(snd_sctl_t *handle ) ;
#line 96 "/usr/include/alsa/mixer.h"
int snd_mixer_open(snd_mixer_t **mixer , int mode ) ;
#line 97
int snd_mixer_close(snd_mixer_t *mixer ) ;
#line 98
snd_mixer_elem_t *snd_mixer_first_elem(snd_mixer_t *mixer ) ;
#line 99
snd_mixer_elem_t *snd_mixer_last_elem(snd_mixer_t *mixer ) ;
#line 100
int snd_mixer_handle_events(snd_mixer_t *mixer ) ;
#line 101
int snd_mixer_attach(snd_mixer_t *mixer , char const   *name ) ;
#line 102
int snd_mixer_attach_hctl(snd_mixer_t *mixer , snd_hctl_t *hctl ) ;
#line 103
int snd_mixer_detach(snd_mixer_t *mixer , char const   *name ) ;
#line 104
int snd_mixer_detach_hctl(snd_mixer_t *mixer , snd_hctl_t *hctl ) ;
#line 105
int snd_mixer_get_hctl(snd_mixer_t *mixer , char const   *name , snd_hctl_t **hctl ) ;
#line 106
int snd_mixer_poll_descriptors_count(snd_mixer_t *mixer ) ;
#line 107
int snd_mixer_poll_descriptors(snd_mixer_t *mixer , struct pollfd *pfds , unsigned int space ) ;
#line 108
int snd_mixer_poll_descriptors_revents(snd_mixer_t *mixer , struct pollfd *pfds ,
                                       unsigned int nfds , unsigned short *revents ) ;
#line 109
int snd_mixer_load(snd_mixer_t *mixer ) ;
#line 110
void snd_mixer_free(snd_mixer_t *mixer ) ;
#line 111
int snd_mixer_wait(snd_mixer_t *mixer , int timeout ) ;
#line 112
int snd_mixer_set_compare(snd_mixer_t *mixer , snd_mixer_compare_t msort ) ;
#line 113
void snd_mixer_set_callback(snd_mixer_t *obj , snd_mixer_callback_t val ) ;
#line 114
void *snd_mixer_get_callback_private(snd_mixer_t *obj ) ;
#line 115
void snd_mixer_set_callback_private(snd_mixer_t *obj , void *val ) ;
#line 116
unsigned int snd_mixer_get_count(snd_mixer_t *obj ) ;
#line 117
int snd_mixer_class_unregister(snd_mixer_class_t *clss ) ;
#line 119
snd_mixer_elem_t *snd_mixer_elem_next(snd_mixer_elem_t *elem ) ;
#line 120
snd_mixer_elem_t *snd_mixer_elem_prev(snd_mixer_elem_t *elem ) ;
#line 121
void snd_mixer_elem_set_callback(snd_mixer_elem_t *obj , snd_mixer_elem_callback_t val ) ;
#line 122
void *snd_mixer_elem_get_callback_private(snd_mixer_elem_t *obj ) ;
#line 123
void snd_mixer_elem_set_callback_private(snd_mixer_elem_t *obj , void *val ) ;
#line 124
snd_mixer_elem_type_t snd_mixer_elem_get_type(snd_mixer_elem_t *obj ) ;
#line 126
int snd_mixer_class_register(snd_mixer_class_t *class_ , snd_mixer_t *mixer ) ;
#line 127
int snd_mixer_elem_new(snd_mixer_elem_t **elem , snd_mixer_elem_type_t type , int compare_weight ,
                       void *private_data , void (*private_free)(snd_mixer_elem_t * ) ) ;
#line 132
int snd_mixer_elem_add(snd_mixer_elem_t *elem , snd_mixer_class_t *class_ ) ;
#line 133
int snd_mixer_elem_remove(snd_mixer_elem_t *elem ) ;
#line 134
void snd_mixer_elem_free(snd_mixer_elem_t *elem ) ;
#line 135
int snd_mixer_elem_info(snd_mixer_elem_t *elem ) ;
#line 136
int snd_mixer_elem_value(snd_mixer_elem_t *elem ) ;
#line 137
int snd_mixer_elem_attach(snd_mixer_elem_t *melem , snd_hctl_elem_t *helem ) ;
#line 138
int snd_mixer_elem_detach(snd_mixer_elem_t *melem , snd_hctl_elem_t *helem ) ;
#line 139
int snd_mixer_elem_empty(snd_mixer_elem_t *melem ) ;
#line 140
void *snd_mixer_elem_get_private(snd_mixer_elem_t *melem ) ;
#line 142
size_t snd_mixer_class_sizeof(void) ;
#line 148
int snd_mixer_class_malloc(snd_mixer_class_t **ptr ) ;
#line 149
void snd_mixer_class_free(snd_mixer_class_t *obj ) ;
#line 150
void snd_mixer_class_copy(snd_mixer_class_t *dst , snd_mixer_class_t *src ) ;
#line 151
snd_mixer_t *snd_mixer_class_get_mixer(snd_mixer_class_t *class_ ) ;
#line 152
snd_mixer_event_t snd_mixer_class_get_event(snd_mixer_class_t *class_ ) ;
#line 153
void *snd_mixer_class_get_private(snd_mixer_class_t *class_ ) ;
#line 154
snd_mixer_compare_t snd_mixer_class_get_compare(snd_mixer_class_t *class_ ) ;
#line 155
int snd_mixer_class_set_event(snd_mixer_class_t *class_ , snd_mixer_event_t event ) ;
#line 156
int snd_mixer_class_set_private(snd_mixer_class_t *class_ , void *private_data ) ;
#line 157
int snd_mixer_class_set_private_free(snd_mixer_class_t *class_ , void (*private_free)(snd_mixer_class_t * ) ) ;
#line 158
int snd_mixer_class_set_compare(snd_mixer_class_t *class_ , snd_mixer_compare_t compare ) ;
#line 221
char const   *snd_mixer_selem_channel_name(snd_mixer_selem_channel_id_t channel ) ;
#line 223
int snd_mixer_selem_register(snd_mixer_t *mixer , struct snd_mixer_selem_regopt *options ,
                             snd_mixer_class_t **classp ) ;
#line 226
void snd_mixer_selem_get_id(snd_mixer_elem_t *element , snd_mixer_selem_id_t *id ) ;
#line 228
char const   *snd_mixer_selem_get_name(snd_mixer_elem_t *elem ) ;
#line 229
unsigned int snd_mixer_selem_get_index(snd_mixer_elem_t *elem ) ;
#line 230
snd_mixer_elem_t *snd_mixer_find_selem(snd_mixer_t *mixer , snd_mixer_selem_id_t *id ) ;
#line 233
int snd_mixer_selem_is_active(snd_mixer_elem_t *elem ) ;
#line 234
int snd_mixer_selem_is_playback_mono(snd_mixer_elem_t *elem ) ;
#line 235
int snd_mixer_selem_has_playback_channel(snd_mixer_elem_t *obj , snd_mixer_selem_channel_id_t channel ) ;
#line 236
int snd_mixer_selem_is_capture_mono(snd_mixer_elem_t *elem ) ;
#line 237
int snd_mixer_selem_has_capture_channel(snd_mixer_elem_t *obj , snd_mixer_selem_channel_id_t channel ) ;
#line 238
int snd_mixer_selem_get_capture_group(snd_mixer_elem_t *elem ) ;
#line 239
int snd_mixer_selem_has_common_volume(snd_mixer_elem_t *elem ) ;
#line 240
int snd_mixer_selem_has_playback_volume(snd_mixer_elem_t *elem ) ;
#line 241
int snd_mixer_selem_has_playback_volume_joined(snd_mixer_elem_t *elem ) ;
#line 242
int snd_mixer_selem_has_capture_volume(snd_mixer_elem_t *elem ) ;
#line 243
int snd_mixer_selem_has_capture_volume_joined(snd_mixer_elem_t *elem ) ;
#line 244
int snd_mixer_selem_has_common_switch(snd_mixer_elem_t *elem ) ;
#line 245
int snd_mixer_selem_has_playback_switch(snd_mixer_elem_t *elem ) ;
#line 246
int snd_mixer_selem_has_playback_switch_joined(snd_mixer_elem_t *elem ) ;
#line 247
int snd_mixer_selem_has_capture_switch(snd_mixer_elem_t *elem ) ;
#line 248
int snd_mixer_selem_has_capture_switch_joined(snd_mixer_elem_t *elem ) ;
#line 249
int snd_mixer_selem_has_capture_switch_exclusive(snd_mixer_elem_t *elem ) ;
#line 251
int snd_mixer_selem_ask_playback_vol_dB(snd_mixer_elem_t *elem , long value , long *dBvalue ) ;
#line 252
int snd_mixer_selem_ask_capture_vol_dB(snd_mixer_elem_t *elem , long value , long *dBvalue ) ;
#line 253
int snd_mixer_selem_ask_playback_dB_vol(snd_mixer_elem_t *elem , long dBvalue , int dir ,
                                        long *value ) ;
#line 254
int snd_mixer_selem_ask_capture_dB_vol(snd_mixer_elem_t *elem , long dBvalue , int dir ,
                                       long *value ) ;
#line 255
int snd_mixer_selem_get_playback_volume(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                        long *value ) ;
#line 256
int snd_mixer_selem_get_capture_volume(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                       long *value ) ;
#line 257
int snd_mixer_selem_get_playback_dB(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                    long *value ) ;
#line 258
int snd_mixer_selem_get_capture_dB(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                   long *value ) ;
#line 259
int snd_mixer_selem_get_playback_switch(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                        int *value ) ;
#line 260
int snd_mixer_selem_get_capture_switch(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                       int *value ) ;
#line 261
int snd_mixer_selem_set_playback_volume(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                        long value ) ;
#line 262
int snd_mixer_selem_set_capture_volume(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                       long value ) ;
#line 263
int snd_mixer_selem_set_playback_dB(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                    long value , int dir ) ;
#line 264
int snd_mixer_selem_set_capture_dB(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                   long value , int dir ) ;
#line 265
int snd_mixer_selem_set_playback_volume_all(snd_mixer_elem_t *elem , long value ) ;
#line 266
int snd_mixer_selem_set_capture_volume_all(snd_mixer_elem_t *elem , long value ) ;
#line 267
int snd_mixer_selem_set_playback_dB_all(snd_mixer_elem_t *elem , long value , int dir ) ;
#line 268
int snd_mixer_selem_set_capture_dB_all(snd_mixer_elem_t *elem , long value , int dir ) ;
#line 269
int snd_mixer_selem_set_playback_switch(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                        int value ) ;
#line 270
int snd_mixer_selem_set_capture_switch(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                       int value ) ;
#line 271
int snd_mixer_selem_set_playback_switch_all(snd_mixer_elem_t *elem , int value ) ;
#line 272
int snd_mixer_selem_set_capture_switch_all(snd_mixer_elem_t *elem , int value ) ;
#line 273
int snd_mixer_selem_get_playback_volume_range(snd_mixer_elem_t *elem , long *min ,
                                              long *max ) ;
#line 275
int snd_mixer_selem_get_playback_dB_range(snd_mixer_elem_t *elem , long *min , long *max ) ;
#line 277
int snd_mixer_selem_set_playback_volume_range(snd_mixer_elem_t *elem , long min ,
                                              long max ) ;
#line 279
int snd_mixer_selem_get_capture_volume_range(snd_mixer_elem_t *elem , long *min ,
                                             long *max ) ;
#line 281
int snd_mixer_selem_get_capture_dB_range(snd_mixer_elem_t *elem , long *min , long *max ) ;
#line 283
int snd_mixer_selem_set_capture_volume_range(snd_mixer_elem_t *elem , long min , long max ) ;
#line 286
int snd_mixer_selem_is_enumerated(snd_mixer_elem_t *elem ) ;
#line 287
int snd_mixer_selem_is_enum_playback(snd_mixer_elem_t *elem ) ;
#line 288
int snd_mixer_selem_is_enum_capture(snd_mixer_elem_t *elem ) ;
#line 289
int snd_mixer_selem_get_enum_items(snd_mixer_elem_t *elem ) ;
#line 290
int snd_mixer_selem_get_enum_item_name(snd_mixer_elem_t *elem , unsigned int idx ,
                                       size_t maxlen , char *str ) ;
#line 291
int snd_mixer_selem_get_enum_item(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                  unsigned int *idxp ) ;
#line 292
int snd_mixer_selem_set_enum_item(snd_mixer_elem_t *elem , snd_mixer_selem_channel_id_t channel ,
                                  unsigned int idx ) ;
#line 294
size_t snd_mixer_selem_id_sizeof(void) ;
#line 300
int snd_mixer_selem_id_malloc(snd_mixer_selem_id_t **ptr ) ;
#line 301
void snd_mixer_selem_id_free(snd_mixer_selem_id_t *obj ) ;
#line 302
void snd_mixer_selem_id_copy(snd_mixer_selem_id_t *dst , snd_mixer_selem_id_t *src ) ;
#line 303
char const   *snd_mixer_selem_id_get_name(snd_mixer_selem_id_t *obj ) ;
#line 304
unsigned int snd_mixer_selem_id_get_index(snd_mixer_selem_id_t *obj ) ;
#line 305
void snd_mixer_selem_id_set_name(snd_mixer_selem_id_t *obj , char const   *val ) ;
#line 306
void snd_mixer_selem_id_set_index(snd_mixer_selem_id_t *obj , unsigned int val ) ;
#line 307
int snd_mixer_selem_id_parse(snd_mixer_selem_id_t *dst , char const   *str ) ;
#line 78 "/usr/include/alsa/seq.h"
int snd_seq_open(snd_seq_t **handle , char const   *name , int streams , int mode ) ;
#line 79
int snd_seq_open_lconf(snd_seq_t **handle , char const   *name , int streams , int mode ,
                       snd_config_t *lconf ) ;
#line 80
char const   *snd_seq_name(snd_seq_t *seq ) ;
#line 81
snd_seq_type_t snd_seq_type(snd_seq_t *seq ) ;
#line 82
int snd_seq_close(snd_seq_t *handle ) ;
#line 83
int snd_seq_poll_descriptors_count(snd_seq_t *handle , short events ) ;
#line 84
int snd_seq_poll_descriptors(snd_seq_t *handle , struct pollfd *pfds , unsigned int space ,
                             short events ) ;
#line 85
int snd_seq_poll_descriptors_revents(snd_seq_t *seq , struct pollfd *pfds , unsigned int nfds ,
                                     unsigned short *revents ) ;
#line 86
int snd_seq_nonblock(snd_seq_t *handle , int nonblock ) ;
#line 87
int snd_seq_client_id(snd_seq_t *handle ) ;
#line 89
size_t snd_seq_get_output_buffer_size(snd_seq_t *handle ) ;
#line 90
size_t snd_seq_get_input_buffer_size(snd_seq_t *handle ) ;
#line 91
int snd_seq_set_output_buffer_size(snd_seq_t *handle , size_t size ) ;
#line 92
int snd_seq_set_input_buffer_size(snd_seq_t *handle , size_t size ) ;
#line 97
size_t snd_seq_system_info_sizeof(void) ;
#line 101
int snd_seq_system_info_malloc(snd_seq_system_info_t **ptr ) ;
#line 102
void snd_seq_system_info_free(snd_seq_system_info_t *ptr ) ;
#line 103
void snd_seq_system_info_copy(snd_seq_system_info_t *dst , snd_seq_system_info_t *src ) ;
#line 105
int snd_seq_system_info_get_queues(snd_seq_system_info_t *info ) ;
#line 106
int snd_seq_system_info_get_clients(snd_seq_system_info_t *info ) ;
#line 107
int snd_seq_system_info_get_ports(snd_seq_system_info_t *info ) ;
#line 108
int snd_seq_system_info_get_channels(snd_seq_system_info_t *info ) ;
#line 109
int snd_seq_system_info_get_cur_clients(snd_seq_system_info_t *info ) ;
#line 110
int snd_seq_system_info_get_cur_queues(snd_seq_system_info_t *info ) ;
#line 112
int snd_seq_system_info(snd_seq_t *handle , snd_seq_system_info_t *info ) ;
#line 133
size_t snd_seq_client_info_sizeof(void) ;
#line 137
int snd_seq_client_info_malloc(snd_seq_client_info_t **ptr ) ;
#line 138
void snd_seq_client_info_free(snd_seq_client_info_t *ptr ) ;
#line 139
void snd_seq_client_info_copy(snd_seq_client_info_t *dst , snd_seq_client_info_t *src ) ;
#line 141
int snd_seq_client_info_get_client(snd_seq_client_info_t *info ) ;
#line 142
snd_seq_client_type_t snd_seq_client_info_get_type(snd_seq_client_info_t *info ) ;
#line 143
char const   *snd_seq_client_info_get_name(snd_seq_client_info_t *info ) ;
#line 144
int snd_seq_client_info_get_broadcast_filter(snd_seq_client_info_t *info ) ;
#line 145
int snd_seq_client_info_get_error_bounce(snd_seq_client_info_t *info ) ;
#line 146
int snd_seq_client_info_get_card(snd_seq_client_info_t *info ) ;
#line 147
int snd_seq_client_info_get_pid(snd_seq_client_info_t *info ) ;
#line 148
unsigned char const   *snd_seq_client_info_get_event_filter(snd_seq_client_info_t *info ) ;
#line 149
int snd_seq_client_info_get_num_ports(snd_seq_client_info_t *info ) ;
#line 150
int snd_seq_client_info_get_event_lost(snd_seq_client_info_t *info ) ;
#line 152
void snd_seq_client_info_set_client(snd_seq_client_info_t *info , int client ) ;
#line 153
void snd_seq_client_info_set_name(snd_seq_client_info_t *info , char const   *name ) ;
#line 154
void snd_seq_client_info_set_broadcast_filter(snd_seq_client_info_t *info , int val ) ;
#line 155
void snd_seq_client_info_set_error_bounce(snd_seq_client_info_t *info , int val ) ;
#line 156
void snd_seq_client_info_set_event_filter(snd_seq_client_info_t *info , unsigned char *filter ) ;
#line 158
void snd_seq_client_info_event_filter_clear(snd_seq_client_info_t *info ) ;
#line 159
void snd_seq_client_info_event_filter_add(snd_seq_client_info_t *info , int event_type ) ;
#line 160
void snd_seq_client_info_event_filter_del(snd_seq_client_info_t *info , int event_type ) ;
#line 161
int snd_seq_client_info_event_filter_check(snd_seq_client_info_t *info , int event_type ) ;
#line 163
int snd_seq_get_client_info(snd_seq_t *handle , snd_seq_client_info_t *info ) ;
#line 164
int snd_seq_get_any_client_info(snd_seq_t *handle , int client , snd_seq_client_info_t *info ) ;
#line 165
int snd_seq_set_client_info(snd_seq_t *handle , snd_seq_client_info_t *info ) ;
#line 166
int snd_seq_query_next_client(snd_seq_t *handle , snd_seq_client_info_t *info ) ;
#line 174
size_t snd_seq_client_pool_sizeof(void) ;
#line 178
int snd_seq_client_pool_malloc(snd_seq_client_pool_t **ptr ) ;
#line 179
void snd_seq_client_pool_free(snd_seq_client_pool_t *ptr ) ;
#line 180
void snd_seq_client_pool_copy(snd_seq_client_pool_t *dst , snd_seq_client_pool_t *src ) ;
#line 182
int snd_seq_client_pool_get_client(snd_seq_client_pool_t *info ) ;
#line 183
size_t snd_seq_client_pool_get_output_pool(snd_seq_client_pool_t *info ) ;
#line 184
size_t snd_seq_client_pool_get_input_pool(snd_seq_client_pool_t *info ) ;
#line 185
size_t snd_seq_client_pool_get_output_room(snd_seq_client_pool_t *info ) ;
#line 186
size_t snd_seq_client_pool_get_output_free(snd_seq_client_pool_t *info ) ;
#line 187
size_t snd_seq_client_pool_get_input_free(snd_seq_client_pool_t *info ) ;
#line 188
void snd_seq_client_pool_set_output_pool(snd_seq_client_pool_t *info , size_t size ) ;
#line 189
void snd_seq_client_pool_set_input_pool(snd_seq_client_pool_t *info , size_t size ) ;
#line 190
void snd_seq_client_pool_set_output_room(snd_seq_client_pool_t *info , size_t size ) ;
#line 192
int snd_seq_get_client_pool(snd_seq_t *handle , snd_seq_client_pool_t *info ) ;
#line 193
int snd_seq_set_client_pool(snd_seq_t *handle , snd_seq_client_pool_t *info ) ;
#line 263
size_t snd_seq_port_info_sizeof(void) ;
#line 267
int snd_seq_port_info_malloc(snd_seq_port_info_t **ptr ) ;
#line 268
void snd_seq_port_info_free(snd_seq_port_info_t *ptr ) ;
#line 269
void snd_seq_port_info_copy(snd_seq_port_info_t *dst , snd_seq_port_info_t *src ) ;
#line 271
int snd_seq_port_info_get_client(snd_seq_port_info_t *info ) ;
#line 272
int snd_seq_port_info_get_port(snd_seq_port_info_t *info ) ;
#line 273
snd_seq_addr_t *snd_seq_port_info_get_addr(snd_seq_port_info_t *info ) ;
#line 274
char const   *snd_seq_port_info_get_name(snd_seq_port_info_t *info ) ;
#line 275
unsigned int snd_seq_port_info_get_capability(snd_seq_port_info_t *info ) ;
#line 276
unsigned int snd_seq_port_info_get_type(snd_seq_port_info_t *info ) ;
#line 277
int snd_seq_port_info_get_midi_channels(snd_seq_port_info_t *info ) ;
#line 278
int snd_seq_port_info_get_midi_voices(snd_seq_port_info_t *info ) ;
#line 279
int snd_seq_port_info_get_synth_voices(snd_seq_port_info_t *info ) ;
#line 280
int snd_seq_port_info_get_read_use(snd_seq_port_info_t *info ) ;
#line 281
int snd_seq_port_info_get_write_use(snd_seq_port_info_t *info ) ;
#line 282
int snd_seq_port_info_get_port_specified(snd_seq_port_info_t *info ) ;
#line 283
int snd_seq_port_info_get_timestamping(snd_seq_port_info_t *info ) ;
#line 284
int snd_seq_port_info_get_timestamp_real(snd_seq_port_info_t *info ) ;
#line 285
int snd_seq_port_info_get_timestamp_queue(snd_seq_port_info_t *info ) ;
#line 287
void snd_seq_port_info_set_client(snd_seq_port_info_t *info , int client ) ;
#line 288
void snd_seq_port_info_set_port(snd_seq_port_info_t *info , int port ) ;
#line 289
void snd_seq_port_info_set_addr(snd_seq_port_info_t *info , snd_seq_addr_t *addr ) ;
#line 290
void snd_seq_port_info_set_name(snd_seq_port_info_t *info , char const   *name ) ;
#line 291
void snd_seq_port_info_set_capability(snd_seq_port_info_t *info , unsigned int capability ) ;
#line 292
void snd_seq_port_info_set_type(snd_seq_port_info_t *info , unsigned int type ) ;
#line 293
void snd_seq_port_info_set_midi_channels(snd_seq_port_info_t *info , int channels ) ;
#line 294
void snd_seq_port_info_set_midi_voices(snd_seq_port_info_t *info , int voices ) ;
#line 295
void snd_seq_port_info_set_synth_voices(snd_seq_port_info_t *info , int voices ) ;
#line 296
void snd_seq_port_info_set_port_specified(snd_seq_port_info_t *info , int val ) ;
#line 297
void snd_seq_port_info_set_timestamping(snd_seq_port_info_t *info , int enable ) ;
#line 298
void snd_seq_port_info_set_timestamp_real(snd_seq_port_info_t *info , int realtime ) ;
#line 299
void snd_seq_port_info_set_timestamp_queue(snd_seq_port_info_t *info , int queue ) ;
#line 301
int snd_seq_create_port(snd_seq_t *handle , snd_seq_port_info_t *info ) ;
#line 302
int snd_seq_delete_port(snd_seq_t *handle , int port ) ;
#line 303
int snd_seq_get_port_info(snd_seq_t *handle , int port , snd_seq_port_info_t *info ) ;
#line 304
int snd_seq_get_any_port_info(snd_seq_t *handle , int client , int port , snd_seq_port_info_t *info ) ;
#line 305
int snd_seq_set_port_info(snd_seq_t *handle , int port , snd_seq_port_info_t *info ) ;
#line 306
int snd_seq_query_next_port(snd_seq_t *handle , snd_seq_port_info_t *info ) ;
#line 321
size_t snd_seq_port_subscribe_sizeof(void) ;
#line 325
int snd_seq_port_subscribe_malloc(snd_seq_port_subscribe_t **ptr ) ;
#line 326
void snd_seq_port_subscribe_free(snd_seq_port_subscribe_t *ptr ) ;
#line 327
void snd_seq_port_subscribe_copy(snd_seq_port_subscribe_t *dst , snd_seq_port_subscribe_t *src ) ;
#line 329
snd_seq_addr_t *snd_seq_port_subscribe_get_sender(snd_seq_port_subscribe_t *info ) ;
#line 330
snd_seq_addr_t *snd_seq_port_subscribe_get_dest(snd_seq_port_subscribe_t *info ) ;
#line 331
int snd_seq_port_subscribe_get_queue(snd_seq_port_subscribe_t *info ) ;
#line 332
int snd_seq_port_subscribe_get_exclusive(snd_seq_port_subscribe_t *info ) ;
#line 333
int snd_seq_port_subscribe_get_time_update(snd_seq_port_subscribe_t *info ) ;
#line 334
int snd_seq_port_subscribe_get_time_real(snd_seq_port_subscribe_t *info ) ;
#line 336
void snd_seq_port_subscribe_set_sender(snd_seq_port_subscribe_t *info , snd_seq_addr_t *addr ) ;
#line 337
void snd_seq_port_subscribe_set_dest(snd_seq_port_subscribe_t *info , snd_seq_addr_t *addr ) ;
#line 338
void snd_seq_port_subscribe_set_queue(snd_seq_port_subscribe_t *info , int q ) ;
#line 339
void snd_seq_port_subscribe_set_exclusive(snd_seq_port_subscribe_t *info , int val ) ;
#line 340
void snd_seq_port_subscribe_set_time_update(snd_seq_port_subscribe_t *info , int val ) ;
#line 341
void snd_seq_port_subscribe_set_time_real(snd_seq_port_subscribe_t *info , int val ) ;
#line 343
int snd_seq_get_port_subscription(snd_seq_t *handle , snd_seq_port_subscribe_t *sub ) ;
#line 344
int snd_seq_subscribe_port(snd_seq_t *handle , snd_seq_port_subscribe_t *sub ) ;
#line 345
int snd_seq_unsubscribe_port(snd_seq_t *handle , snd_seq_port_subscribe_t *sub ) ;
#line 359
size_t snd_seq_query_subscribe_sizeof(void) ;
#line 363
int snd_seq_query_subscribe_malloc(snd_seq_query_subscribe_t **ptr ) ;
#line 364
void snd_seq_query_subscribe_free(snd_seq_query_subscribe_t *ptr ) ;
#line 365
void snd_seq_query_subscribe_copy(snd_seq_query_subscribe_t *dst , snd_seq_query_subscribe_t *src ) ;
#line 367
int snd_seq_query_subscribe_get_client(snd_seq_query_subscribe_t *info ) ;
#line 368
int snd_seq_query_subscribe_get_port(snd_seq_query_subscribe_t *info ) ;
#line 369
snd_seq_addr_t *snd_seq_query_subscribe_get_root(snd_seq_query_subscribe_t *info ) ;
#line 370
snd_seq_query_subs_type_t snd_seq_query_subscribe_get_type(snd_seq_query_subscribe_t *info ) ;
#line 371
int snd_seq_query_subscribe_get_index(snd_seq_query_subscribe_t *info ) ;
#line 372
int snd_seq_query_subscribe_get_num_subs(snd_seq_query_subscribe_t *info ) ;
#line 373
snd_seq_addr_t *snd_seq_query_subscribe_get_addr(snd_seq_query_subscribe_t *info ) ;
#line 374
int snd_seq_query_subscribe_get_queue(snd_seq_query_subscribe_t *info ) ;
#line 375
int snd_seq_query_subscribe_get_exclusive(snd_seq_query_subscribe_t *info ) ;
#line 376
int snd_seq_query_subscribe_get_time_update(snd_seq_query_subscribe_t *info ) ;
#line 377
int snd_seq_query_subscribe_get_time_real(snd_seq_query_subscribe_t *info ) ;
#line 379
void snd_seq_query_subscribe_set_client(snd_seq_query_subscribe_t *info , int client ) ;
#line 380
void snd_seq_query_subscribe_set_port(snd_seq_query_subscribe_t *info , int port ) ;
#line 381
void snd_seq_query_subscribe_set_root(snd_seq_query_subscribe_t *info , snd_seq_addr_t *addr ) ;
#line 382
void snd_seq_query_subscribe_set_type(snd_seq_query_subscribe_t *info , snd_seq_query_subs_type_t type ) ;
#line 383
void snd_seq_query_subscribe_set_index(snd_seq_query_subscribe_t *info , int _index ) ;
#line 385
int snd_seq_query_port_subscribers(snd_seq_t *seq , snd_seq_query_subscribe_t *subs ) ;
#line 409
size_t snd_seq_queue_info_sizeof(void) ;
#line 413
int snd_seq_queue_info_malloc(snd_seq_queue_info_t **ptr ) ;
#line 414
void snd_seq_queue_info_free(snd_seq_queue_info_t *ptr ) ;
#line 415
void snd_seq_queue_info_copy(snd_seq_queue_info_t *dst , snd_seq_queue_info_t *src ) ;
#line 417
int snd_seq_queue_info_get_queue(snd_seq_queue_info_t *info ) ;
#line 418
char const   *snd_seq_queue_info_get_name(snd_seq_queue_info_t *info ) ;
#line 419
int snd_seq_queue_info_get_owner(snd_seq_queue_info_t *info ) ;
#line 420
int snd_seq_queue_info_get_locked(snd_seq_queue_info_t *info ) ;
#line 421
unsigned int snd_seq_queue_info_get_flags(snd_seq_queue_info_t *info ) ;
#line 423
void snd_seq_queue_info_set_name(snd_seq_queue_info_t *info , char const   *name ) ;
#line 424
void snd_seq_queue_info_set_owner(snd_seq_queue_info_t *info , int owner ) ;
#line 425
void snd_seq_queue_info_set_locked(snd_seq_queue_info_t *info , int locked ) ;
#line 426
void snd_seq_queue_info_set_flags(snd_seq_queue_info_t *info , unsigned int flags ) ;
#line 428
int snd_seq_create_queue(snd_seq_t *seq , snd_seq_queue_info_t *info ) ;
#line 429
int snd_seq_alloc_named_queue(snd_seq_t *seq , char const   *name ) ;
#line 430
int snd_seq_alloc_queue(snd_seq_t *handle ) ;
#line 431
int snd_seq_free_queue(snd_seq_t *handle , int q ) ;
#line 432
int snd_seq_get_queue_info(snd_seq_t *seq , int q , snd_seq_queue_info_t *info ) ;
#line 433
int snd_seq_set_queue_info(snd_seq_t *seq , int q , snd_seq_queue_info_t *info ) ;
#line 434
int snd_seq_query_named_queue(snd_seq_t *seq , char const   *name ) ;
#line 436
int snd_seq_get_queue_usage(snd_seq_t *handle , int q ) ;
#line 437
int snd_seq_set_queue_usage(snd_seq_t *handle , int q , int used ) ;
#line 441
size_t snd_seq_queue_status_sizeof(void) ;
#line 445
int snd_seq_queue_status_malloc(snd_seq_queue_status_t **ptr ) ;
#line 446
void snd_seq_queue_status_free(snd_seq_queue_status_t *ptr ) ;
#line 447
void snd_seq_queue_status_copy(snd_seq_queue_status_t *dst , snd_seq_queue_status_t *src ) ;
#line 449
int snd_seq_queue_status_get_queue(snd_seq_queue_status_t *info ) ;
#line 450
int snd_seq_queue_status_get_events(snd_seq_queue_status_t *info ) ;
#line 451
snd_seq_tick_time_t snd_seq_queue_status_get_tick_time(snd_seq_queue_status_t *info ) ;
#line 452
snd_seq_real_time_t *snd_seq_queue_status_get_real_time(snd_seq_queue_status_t *info ) ;
#line 453
unsigned int snd_seq_queue_status_get_status(snd_seq_queue_status_t *info ) ;
#line 455
int snd_seq_get_queue_status(snd_seq_t *handle , int q , snd_seq_queue_status_t *status ) ;
#line 459
size_t snd_seq_queue_tempo_sizeof(void) ;
#line 463
int snd_seq_queue_tempo_malloc(snd_seq_queue_tempo_t **ptr ) ;
#line 464
void snd_seq_queue_tempo_free(snd_seq_queue_tempo_t *ptr ) ;
#line 465
void snd_seq_queue_tempo_copy(snd_seq_queue_tempo_t *dst , snd_seq_queue_tempo_t *src ) ;
#line 467
int snd_seq_queue_tempo_get_queue(snd_seq_queue_tempo_t *info ) ;
#line 468
unsigned int snd_seq_queue_tempo_get_tempo(snd_seq_queue_tempo_t *info ) ;
#line 469
int snd_seq_queue_tempo_get_ppq(snd_seq_queue_tempo_t *info ) ;
#line 470
unsigned int snd_seq_queue_tempo_get_skew(snd_seq_queue_tempo_t *info ) ;
#line 471
unsigned int snd_seq_queue_tempo_get_skew_base(snd_seq_queue_tempo_t *info ) ;
#line 472
void snd_seq_queue_tempo_set_tempo(snd_seq_queue_tempo_t *info , unsigned int tempo ) ;
#line 473
void snd_seq_queue_tempo_set_ppq(snd_seq_queue_tempo_t *info , int ppq ) ;
#line 474
void snd_seq_queue_tempo_set_skew(snd_seq_queue_tempo_t *info , unsigned int skew ) ;
#line 475
void snd_seq_queue_tempo_set_skew_base(snd_seq_queue_tempo_t *info , unsigned int base ) ;
#line 477
int snd_seq_get_queue_tempo(snd_seq_t *handle , int q , snd_seq_queue_tempo_t *tempo ) ;
#line 478
int snd_seq_set_queue_tempo(snd_seq_t *handle , int q , snd_seq_queue_tempo_t *tempo ) ;
#line 490
size_t snd_seq_queue_timer_sizeof(void) ;
#line 494
int snd_seq_queue_timer_malloc(snd_seq_queue_timer_t **ptr ) ;
#line 495
void snd_seq_queue_timer_free(snd_seq_queue_timer_t *ptr ) ;
#line 496
void snd_seq_queue_timer_copy(snd_seq_queue_timer_t *dst , snd_seq_queue_timer_t *src ) ;
#line 498
int snd_seq_queue_timer_get_queue(snd_seq_queue_timer_t *info ) ;
#line 499
snd_seq_queue_timer_type_t snd_seq_queue_timer_get_type(snd_seq_queue_timer_t *info ) ;
#line 500
snd_timer_id_t *snd_seq_queue_timer_get_id(snd_seq_queue_timer_t *info ) ;
#line 501
unsigned int snd_seq_queue_timer_get_resolution(snd_seq_queue_timer_t *info ) ;
#line 503
void snd_seq_queue_timer_set_type(snd_seq_queue_timer_t *info , snd_seq_queue_timer_type_t type ) ;
#line 504
void snd_seq_queue_timer_set_id(snd_seq_queue_timer_t *info , snd_timer_id_t *id ) ;
#line 505
void snd_seq_queue_timer_set_resolution(snd_seq_queue_timer_t *info , unsigned int resolution ) ;
#line 507
int snd_seq_get_queue_timer(snd_seq_t *handle , int q , snd_seq_queue_timer_t *timer ) ;
#line 508
int snd_seq_set_queue_timer(snd_seq_t *handle , int q , snd_seq_queue_timer_t *timer ) ;
#line 519
int snd_seq_free_event(snd_seq_event_t *ev ) ;
#line 520
ssize_t snd_seq_event_length(snd_seq_event_t *ev ) ;
#line 521
int snd_seq_event_output(snd_seq_t *handle , snd_seq_event_t *ev ) ;
#line 522
int snd_seq_event_output_buffer(snd_seq_t *handle , snd_seq_event_t *ev ) ;
#line 523
int snd_seq_event_output_direct(snd_seq_t *handle , snd_seq_event_t *ev ) ;
#line 524
int snd_seq_event_input(snd_seq_t *handle , snd_seq_event_t **ev ) ;
#line 525
int snd_seq_event_input_pending(snd_seq_t *seq , int fetch_sequencer ) ;
#line 526
int snd_seq_drain_output(snd_seq_t *handle ) ;
#line 527
int snd_seq_event_output_pending(snd_seq_t *seq ) ;
#line 528
int snd_seq_extract_output(snd_seq_t *handle , snd_seq_event_t **ev ) ;
#line 529
int snd_seq_drop_output(snd_seq_t *handle ) ;
#line 530
int snd_seq_drop_output_buffer(snd_seq_t *handle ) ;
#line 531
int snd_seq_drop_input(snd_seq_t *handle ) ;
#line 532
int snd_seq_drop_input_buffer(snd_seq_t *handle ) ;
#line 549
size_t snd_seq_remove_events_sizeof(void) ;
#line 553
int snd_seq_remove_events_malloc(snd_seq_remove_events_t **ptr ) ;
#line 554
void snd_seq_remove_events_free(snd_seq_remove_events_t *ptr ) ;
#line 555
void snd_seq_remove_events_copy(snd_seq_remove_events_t *dst , snd_seq_remove_events_t *src ) ;
#line 557
unsigned int snd_seq_remove_events_get_condition(snd_seq_remove_events_t *info ) ;
#line 558
int snd_seq_remove_events_get_queue(snd_seq_remove_events_t *info ) ;
#line 559
snd_seq_timestamp_t *snd_seq_remove_events_get_time(snd_seq_remove_events_t *info ) ;
#line 560
snd_seq_addr_t *snd_seq_remove_events_get_dest(snd_seq_remove_events_t *info ) ;
#line 561
int snd_seq_remove_events_get_channel(snd_seq_remove_events_t *info ) ;
#line 562
int snd_seq_remove_events_get_event_type(snd_seq_remove_events_t *info ) ;
#line 563
int snd_seq_remove_events_get_tag(snd_seq_remove_events_t *info ) ;
#line 565
void snd_seq_remove_events_set_condition(snd_seq_remove_events_t *info , unsigned int flags ) ;
#line 566
void snd_seq_remove_events_set_queue(snd_seq_remove_events_t *info , int queue ) ;
#line 567
void snd_seq_remove_events_set_time(snd_seq_remove_events_t *info , snd_seq_timestamp_t *time ) ;
#line 568
void snd_seq_remove_events_set_dest(snd_seq_remove_events_t *info , snd_seq_addr_t *addr ) ;
#line 569
void snd_seq_remove_events_set_channel(snd_seq_remove_events_t *info , int channel ) ;
#line 570
void snd_seq_remove_events_set_event_type(snd_seq_remove_events_t *info , int type ) ;
#line 571
void snd_seq_remove_events_set_tag(snd_seq_remove_events_t *info , int tag ) ;
#line 573
int snd_seq_remove_events(snd_seq_t *handle , snd_seq_remove_events_t *info ) ;
#line 584
void snd_seq_set_bit(int nr , void *array ) ;
#line 585
void snd_seq_unset_bit(int nr , void *array ) ;
#line 586
int snd_seq_change_bit(int nr , void *array ) ;
#line 587
int snd_seq_get_bit(int nr , void *array ) ;
#line 636
extern unsigned int const   snd_seq_event_types[] ;
#line 288 "/usr/include/alsa/seqmid.h"
int snd_seq_control_queue(snd_seq_t *seq , int q , int type , int value , snd_seq_event_t *ev ) ;
#line 328
int snd_seq_create_simple_port(snd_seq_t *seq , char const   *name , unsigned int caps ,
                               unsigned int type ) ;
#line 331
int snd_seq_delete_simple_port(snd_seq_t *seq , int port ) ;
#line 336
int snd_seq_connect_from(snd_seq_t *seq , int my_port , int src_client , int src_port ) ;
#line 337
int snd_seq_connect_to(snd_seq_t *seq , int my_port , int dest_client , int dest_port ) ;
#line 338
int snd_seq_disconnect_from(snd_seq_t *seq , int my_port , int src_client , int src_port ) ;
#line 339
int snd_seq_disconnect_to(snd_seq_t *seq , int my_port , int dest_client , int dest_port ) ;
#line 344
int snd_seq_set_client_name(snd_seq_t *seq , char const   *name ) ;
#line 345
int snd_seq_set_client_event_filter(snd_seq_t *seq , int event_type ) ;
#line 346
int snd_seq_set_client_pool_output(snd_seq_t *seq , size_t size ) ;
#line 347
int snd_seq_set_client_pool_output_room(snd_seq_t *seq , size_t size ) ;
#line 348
int snd_seq_set_client_pool_input(snd_seq_t *seq , size_t size ) ;
#line 350
int snd_seq_sync_output_queue(snd_seq_t *seq ) ;
#line 355
int snd_seq_parse_address(snd_seq_t *seq , snd_seq_addr_t *addr , char const   *str ) ;
#line 360
int snd_seq_reset_pool_output(snd_seq_t *seq ) ;
#line 361
int snd_seq_reset_pool_input(snd_seq_t *seq ) ;
#line 45 "/usr/include/alsa/seq_midi_event.h"
int snd_midi_event_new(size_t bufsize , snd_midi_event_t **rdev ) ;
#line 46
int snd_midi_event_resize_buffer(snd_midi_event_t *dev , size_t bufsize ) ;
#line 47
void snd_midi_event_free(snd_midi_event_t *dev ) ;
#line 48
void snd_midi_event_init(snd_midi_event_t *dev ) ;
#line 49
void snd_midi_event_reset_encode(snd_midi_event_t *dev ) ;
#line 50
void snd_midi_event_reset_decode(snd_midi_event_t *dev ) ;
#line 51
void snd_midi_event_no_status(snd_midi_event_t *dev , int on ) ;
#line 53
long snd_midi_event_encode(snd_midi_event_t *dev , unsigned char const   *buf , long count ,
                           snd_seq_event_t *ev ) ;
#line 54
int snd_midi_event_encode_byte(snd_midi_event_t *dev , int c , snd_seq_event_t *ev ) ;
#line 56
long snd_midi_event_decode(snd_midi_event_t *dev , unsigned char *buf , long count ,
                           snd_seq_event_t *ev ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
#line 81
extern  __attribute__((__nothrow__)) int mprotect(void *__addr , size_t __len , int __prot ) ;
#line 89
extern int msync(void *__addr , size_t __len , int __flags ) ;
#line 94
extern  __attribute__((__nothrow__)) int madvise(void *__addr , size_t __len , int __advice ) ;
#line 98
extern  __attribute__((__nothrow__)) int posix_madvise(void *__addr , size_t __len ,
                                                       int __advice ) ;
#line 103
extern  __attribute__((__nothrow__)) int mlock(void const   *__addr , size_t __len ) ;
#line 106
extern  __attribute__((__nothrow__)) int munlock(void const   *__addr , size_t __len ) ;
#line 111
extern  __attribute__((__nothrow__)) int mlockall(int __flags ) ;
#line 115
extern  __attribute__((__nothrow__)) int munlockall(void) ;
#line 123
extern  __attribute__((__nothrow__)) int mincore(void *__start , size_t __len , unsigned char *__vec ) ;
#line 144
extern int shm_open(char const   *__name , int __oflag , mode_t __mode ) ;
#line 147
extern int shm_unlink(char const   *__name ) ;
#line 67 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *memalign(size_t __alignment , size_t __size ) ;
#line 77
extern  __attribute__((__nothrow__)) void *pvalloc(size_t __size ) ;
#line 114
extern  __attribute__((__nothrow__)) struct mallinfo mallinfo(void) ;
#line 117
extern  __attribute__((__nothrow__)) struct mallinfo2 mallinfo2(void) ;
#line 144
extern  __attribute__((__nothrow__)) int mallopt(int __param , int __val ) ;
#line 148
extern  __attribute__((__nothrow__)) int malloc_trim(size_t __pad ) ;
#line 152
extern  __attribute__((__nothrow__)) size_t malloc_usable_size(void *__ptr ) ;
#line 155
extern  __attribute__((__nothrow__)) void malloc_stats(void) ;
#line 158
extern  __attribute__((__nothrow__)) int malloc_info(int __options , FILE *__fp ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 187
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 187
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 191
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 191
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 198
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 198
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 203
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 220
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 262
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 262
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 279
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 329
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 340
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 340
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 435
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 435
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 38 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static snd_pcm_format_t fmts[5]  = {      (snd_pcm_format_t )10,      (snd_pcm_format_t )6,      (snd_pcm_format_t )32,      (snd_pcm_format_t )2, 
        (snd_pcm_format_t )-1};
#line 69
static struct __anonstruct_157 alsa ;
#line 71 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static snd_pcm_t *pcmp  =    (snd_pcm_t *)((void *)0);
#line 78
static log_level loglevel___1 ;
#line 80 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static int running___1  =    1;
#line 88 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static char *ctl4device(char const   *device ) 
{ 
  char *ctl ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;
  char *__cil_tmp6 ;
  char *comma ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 89
  ctl = (char *)((void *)0);
#line 91
  __cil_tmp3 = strncmp(device, "hw:", (unsigned long )3);
  }
#line 91
  if (! __cil_tmp3) {
    {
#line 92
    ctl = strdup(device);
    }
  } else {
    {
#line 93
    __cil_tmp5 = strncmp(device, "plughw:", (unsigned long )7);
    }
#line 93
    if (! __cil_tmp5) {
      {
#line 94
      ctl = strdup(device + 4);
      }
    }
  }
#line 96
  if (ctl) {
    {
#line 98
    comma = strrchr((char const   *)ctl, ',');
    }
#line 98
    if (comma) {
#line 99
      *comma = (char )'\000';
    }
  } else {
    {
#line 101
    ctl = strdup(device);
    }
  }
#line 103
  return (ctl);
}
}
#line 106 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
void list_devices(void) 
{ 
  void **hints ;
  void **n ;
  int __cil_tmp3 ;
  char *name ;
  char *__cil_tmp5 ;
  char *desc ;
  char *__cil_tmp7 ;
  char *s1 ;
  char *__cil_tmp9 ;
  char *s2 ;
  char *__cil_tmp11 ;
  void **__cil_tmp12 ;

  {
  {
#line 108
  __cil_tmp3 = snd_device_name_hint(- 1, "pcm", & hints);
  }
#line 108
  if (__cil_tmp3 >= 0) {
    {
#line 109
    n = hints;
#line 110
    printf("Output devices:\n\220");
    }
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! *n) {
#line 111
        goto while_break;
      }
      {
#line 112
      __cil_tmp5 = snd_device_name_get_hint(*n, "NAME");
#line 112
      name = __cil_tmp5;
#line 113
      __cil_tmp7 = snd_device_name_get_hint(*n, "DESC");
#line 113
      desc = __cil_tmp7;
      }
#line 114
      if (name) {
        {
#line 114
        printf("  %-30s", name);
        }
      }
#line 115
      if (desc) {
        {
#line 116
        __cil_tmp9 = strtok(desc, "\n");
#line 116
        s1 = __cil_tmp9;
#line 117
        __cil_tmp11 = strtok((char *)((void *)0), "\n");
#line 117
        s2 = __cil_tmp11;
        }
#line 118
        if (s1) {
          {
#line 118
          printf(" - %s", s1);
          }
        }
#line 119
        if (s2) {
          {
#line 119
          printf(" - %s", s2);
          }
        }
      }
      {
#line 121
      printf("\n");
      }
#line 122
      if (name) {
        {
#line 122
        free(name);
        }
      }
#line 123
      if (desc) {
        {
#line 123
        free(desc);
        }
      }
#line 124
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 126
    snd_device_name_free_hint(hints);
    }
  }
  {
#line 128
  printf("\n");
  }
  return;
}
}
#line 131 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
void list_mixers(char const   *output_device ) 
{ 
  int err ;
  snd_mixer_t *handle ;
  snd_mixer_selem_id_t *sid ;
  snd_mixer_elem_t *elem ;
  char *ctl ;
  char *__cil_tmp7 ;
  size_t __cil_tmp8 ;
  void *__cil_tmp9 ;
  size_t __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  int __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  int __cil_tmp18 ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  int __cil_tmp21 ;
  char const   *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  snd_mixer_elem_t *__cil_tmp24 ;
  int __cil_tmp25 ;
  char const   *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  snd_mixer_elem_t *__cil_tmp29 ;

  {
  {
#line 136
  __cil_tmp7 = ctl4device(output_device);
#line 136
  ctl = __cil_tmp7;
  }
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 137
    __cil_tmp8 = snd_mixer_selem_id_sizeof();
#line 137
    __cil_tmp9 = __builtin_alloca(__cil_tmp8);
#line 137
    *(& sid) = (snd_mixer_selem_id_t *)__cil_tmp9;
#line 137
    __cil_tmp10 = snd_mixer_selem_id_sizeof();
#line 137
    memset(*(& sid), 0, __cil_tmp10);
    }
#line 137
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 139
    __cil_tmp11 = logtime();
#line 139
    logprint("%s %s:%d listing mixers for: %s\n\230", __cil_tmp11, "list_mixers",
             139, output_device);
    }
  }
  {
#line 141
  err = snd_mixer_open(& handle, 0);
  }
#line 141
  if (err < 0) {
    {
#line 142
    __cil_tmp13 = logtime();
    }
    {
#line 142
    __cil_tmp14 = snd_strerror(err);
#line 142
    logprint("%s %s:%d open error: %s\n\230", __cil_tmp13, "list_mixers", 142, __cil_tmp14);
    }
#line 143
    return;
  }
  {
#line 145
  err = snd_mixer_attach(handle, (char const   *)ctl);
  }
#line 145
  if (err < 0) {
    {
#line 146
    __cil_tmp16 = logtime();
    }
    {
#line 146
    __cil_tmp17 = snd_strerror(err);
#line 146
    logprint("%s %s:%d attach error: %s\n", __cil_tmp16, "list_mixers", 146, __cil_tmp17);
#line 147
    snd_mixer_close(handle);
#line 148
    free(ctl);
    }
#line 149
    return;
  }
  {
#line 151
  free(ctl);
#line 152
  err = snd_mixer_selem_register(handle, (struct snd_mixer_selem_regopt *)((void *)0),
                                 (snd_mixer_class_t **)((void *)0));
  }
#line 152
  if (err < 0) {
    {
#line 153
    __cil_tmp19 = logtime();
    }
    {
#line 153
    __cil_tmp20 = snd_strerror(err);
#line 153
    logprint("%s %s:%d register error: %s\n\301U", __cil_tmp19, "list_mixersg\301U",
             153, __cil_tmp20);
#line 154
    snd_mixer_close(handle);
    }
#line 155
    return;
  }
  {
#line 157
  err = snd_mixer_load(handle);
  }
#line 157
  if (err < 0) {
    {
#line 158
    __cil_tmp22 = logtime();
    }
    {
#line 158
    __cil_tmp23 = snd_strerror(err);
#line 158
    logprint("%s %s:%d load error: %s\n\230", __cil_tmp22, "list_mixers", 158, __cil_tmp23);
#line 159
    snd_mixer_close(handle);
    }
#line 160
    return;
  }
  {
#line 163
  printf("Volume controls for %s\n", output_device);
#line 164
  elem = snd_mixer_first_elem(handle);
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! elem) {
#line 164
      goto while_break___0;
    }
    {
#line 165
    __cil_tmp25 = snd_mixer_selem_has_playback_volume(elem);
    }
#line 165
    if (__cil_tmp25) {
      {
#line 166
      snd_mixer_selem_get_id(elem, sid);
#line 167
      __cil_tmp26 = snd_mixer_selem_id_get_name(sid);
#line 167
      printf("   %s(\001", __cil_tmp26);
#line 168
      __cil_tmp27 = snd_mixer_selem_id_get_index(sid);
      }
#line 168
      if (__cil_tmp27) {
        {
#line 169
        __cil_tmp28 = snd_mixer_selem_id_get_index(sid);
#line 169
        printf(",%d", __cil_tmp28);
        }
      }
      {
#line 171
      printf("\nY\001");
      }
    }
    {
#line 164
    elem = snd_mixer_elem_next(elem);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  printf("\n]\001");
#line 176
  snd_mixer_close(handle);
  }
  return;
}
}
#line 181 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static void set_mixer(int setmax , float ldB , float rdB ) 
{ 
  int err ;
  long nleft ;
  long nright ;
  long lraw ;
  long rraw ;
  double __cil_tmp9 ;
  double tmp ;
  double __cil_tmp11 ;
  double tmp___0 ;
  char const   *__cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char const   *__cil_tmp16 ;
  int __cil_tmp17 ;
  char const   *__cil_tmp18 ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  int __cil_tmp21 ;
  char const   *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  int __cil_tmp24 ;
  char const   *__cil_tmp25 ;
  char const   *__cil_tmp26 ;
  int __cil_tmp27 ;
  char const   *__cil_tmp28 ;
  char const   *__cil_tmp29 ;
  int __cil_tmp30 ;
  char const   *__cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char const   *__cil_tmp33 ;

  {
#line 185
  if (alsa.mixer_linear) {
#line 187
    if (setmax) {
#line 188
      rraw = alsa.mixer_max;
#line 188
      lraw = rraw;
    } else {
#line 190
      if (ldB > (float )-72) {
        {
#line 190
        __cil_tmp9 = floor((double )ldB);
#line 190
        tmp = (double )72 + __cil_tmp9;
        }
      } else {
#line 190
        tmp = (double )0;
      }
#line 190
      lraw = (long )((tmp / (double )72) * (double )(alsa.mixer_max - alsa.mixer_min) + (double )alsa.mixer_min);
#line 191
      if (rdB > (float )-72) {
        {
#line 191
        __cil_tmp11 = floor((double )rdB);
#line 191
        tmp___0 = (double )72 + __cil_tmp11;
        }
      } else {
#line 191
        tmp___0 = (double )0;
      }
#line 191
      rraw = (long )((tmp___0 / (double )72) * (double )(alsa.mixer_max - alsa.mixer_min) + (double )alsa.mixer_min);
    }
#line 193
    if ((unsigned int )loglevel___1 >= 3U) {
      {
#line 193
      __cil_tmp13 = logtime();
#line 193
      logprint("%s %s:%d setting vol raw [%ld..%ld]\n\001", __cil_tmp13, "set_mixer",
               193, alsa.mixer_min, alsa.mixer_max);
      }
    }
    {
#line 194
    err = snd_mixer_selem_set_playback_volume(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )0,
                                              lraw);
    }
#line 194
    if (err < 0) {
      {
#line 195
      __cil_tmp15 = logtime();
      }
      {
#line 195
      __cil_tmp16 = snd_strerror(err);
#line 195
      logprint("%s %s:%d error setting left volume: %s\n", __cil_tmp15, "set_mixer!\003",
               195, __cil_tmp16);
      }
    }
    {
#line 197
    err = snd_mixer_selem_set_playback_volume(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )1,
                                              rraw);
    }
#line 197
    if (err < 0) {
      {
#line 198
      __cil_tmp18 = logtime();
      }
      {
#line 198
      __cil_tmp19 = snd_strerror(err);
#line 198
      logprint("%s %s:%d error setting right volume: %s\n\230", __cil_tmp18, "set_mixer",
               198, __cil_tmp19);
      }
    }
  } else {
#line 202
    if ((unsigned int )loglevel___1 >= 3U) {
      {
#line 202
      __cil_tmp20 = logtime();
#line 202
      logprint("%s %s:%d setting vol dB [%ld..%ld]\n", __cil_tmp20, "set_mixer", 202,
               alsa.mixer_min, alsa.mixer_max);
      }
    }
#line 203
    if (setmax) {
#line 205
      if (alsa.mixer_max >= 0L) {
#line 205
        if (alsa.mixer_min <= 0L) {
#line 206
          rdB = (float )0;
#line 206
          ldB = rdB;
        } else {
#line 208
          rdB = (float )alsa.mixer_max;
#line 208
          ldB = rdB;
        }
      } else {
#line 208
        rdB = (float )alsa.mixer_max;
#line 208
        ldB = rdB;
      }
    }
    {
#line 211
    err = snd_mixer_selem_set_playback_dB(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )0,
                                          (long )((float )100 * ldB), 1);
    }
#line 211
    if (err < 0) {
      {
#line 212
      __cil_tmp22 = logtime();
      }
      {
#line 212
      __cil_tmp23 = snd_strerror(err);
#line 212
      logprint("%s %s:%d error setting left volume: %s\n", __cil_tmp22, "set_mixer",
               212, __cil_tmp23);
      }
    }
    {
#line 214
    err = snd_mixer_selem_set_playback_dB(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )1,
                                          (long )((float )100 * rdB), 1);
    }
#line 214
    if (err < 0) {
      {
#line 215
      __cil_tmp25 = logtime();
      }
      {
#line 215
      __cil_tmp26 = snd_strerror(err);
#line 215
      logprint("%s %s:%d error setting right volume: %s\n\230", __cil_tmp25, "set_mixer",
               215, __cil_tmp26);
      }
    }
  }
  {
#line 219
  err = snd_mixer_selem_get_playback_volume(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )0,
                                            & nleft);
  }
#line 219
  if (err < 0) {
    {
#line 220
    __cil_tmp28 = logtime();
    }
    {
#line 220
    __cil_tmp29 = snd_strerror(err);
#line 220
    logprint("%s %s:%d error getting left vol: %s\n", __cil_tmp28, "set_mixer", 220,
             __cil_tmp29);
    }
  }
  {
#line 222
  err = snd_mixer_selem_get_playback_volume(alsa.mixer_elem, (snd_mixer_selem_channel_id_t )1,
                                            & nright);
  }
#line 222
  if (err < 0) {
    {
#line 223
    __cil_tmp31 = logtime();
    }
    {
#line 223
    __cil_tmp32 = snd_strerror(err);
#line 223
    logprint("%s %s:%d error getting right vol: %s\n", __cil_tmp31, "set_mixer", 223,
             __cil_tmp32);
    }
  }
#line 226
  if ((unsigned int )loglevel___1 >= 3U) {
    {
#line 226
    __cil_tmp33 = logtime();
#line 226
    logprint("%s %s:%d %s left: %3.1fdB -> %ld right: %3.1fdB -> %ld\n", __cil_tmp33,
             "set_mixer", 226, alsa.volume_mixer_name, (double )ldB, nleft, (double )rdB,
             nright);
    }
  }
  return;
}
}
#line 229 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
void set_volume(unsigned int left , unsigned int right ) 
{ 
  float ldB ;
  float rdB ;
  char const   *__cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
#line 232
  if (! alsa.volume_mixer_name) {
#line 233
    if ((unsigned int )loglevel___1 >= 3U) {
      {
#line 233
      __cil_tmp5 = logtime();
#line 233
      logprint("%s %s:%d setting internal gain left: %u right: %u\n", __cil_tmp5,
               "set_volume", 233, left, right);
      }
    }
    {
#line 234
    pthread_mutex_lock(& outputbuf->mutex);
#line 235
    output.gainL = left;
#line 236
    output.gainR = right;
#line 237
    pthread_mutex_unlock(& outputbuf->mutex);
    }
#line 238
    return;
  } else {
    {
#line 240
    pthread_mutex_lock(& outputbuf->mutex);
#line 241
    output.gainL = (u32_t )65536;
#line 242
    output.gainR = (u32_t )65536;
#line 243
    pthread_mutex_unlock(& outputbuf->mutex);
    }
  }
  {
#line 247
  __cil_tmp6 = log10((double )((float )left / 65536.f));
#line 247
  ldB = (float )((double )20 * __cil_tmp6);
#line 248
  __cil_tmp7 = log10((double )((float )right / 65536.f));
#line 248
  rdB = (float )((double )20 * __cil_tmp7);
#line 250
  set_mixer(0, ldB, rdB);
  }
  return;
}
}
#line 253 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static void *alsa_error_handler(char const   *file , int line , char const   *function ,
                                int err , char const   *fmt  , ...) 
{ 
  va_list args ;
  char const   *__cil_tmp7 ;

  {
#line 255
  if ((unsigned int )loglevel___1 >= 2U) {
#line 255
    if (err == 0) {
      _L: /* CIL Label */ 
      {
#line 256
      __cil_tmp7 = logtime();
#line 256
      fprintf(stderr, "%s ALSA %s:%d ", __cil_tmp7, function, line);
#line 257
      __builtin_va_start((void *)args, fmt);
#line 258
      vfprintf(stderr, fmt, (void *)args);
#line 259
      fprintf(stderr, "\n");
#line 260
      fflush(stderr);
      }
    } else {
#line 255
      goto _L___26;
    }
  } else
  _L___26: /* CIL Label */ 
#line 255
  if ((unsigned int )loglevel___1 >= 3U) {
#line 255
    goto _L;
  }
#line 262
  return ((void *)0);
}
}
#line 265 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static void alsa_close(void) 
{ 
  int err ;
  int __cil_tmp2 ;
  char const   *__cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 267
  err = snd_pcm_close(pcmp);
  }
#line 267
  if (err < 0) {
#line 268
    if ((unsigned int )loglevel___1 >= 2U) {
      {
#line 268
      __cil_tmp3 = logtime();
      }
      {
#line 268
      __cil_tmp4 = snd_strerror(err);
#line 268
      logprint("%s %s:%d snd_pcm_close error: %s\n", __cil_tmp3, "alsa_close", 268,
               __cil_tmp4);
      }
    }
  }
  return;
}
}
#line 272 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
int test_open(char const   *device , unsigned int rates[] , int userdef_rates ) 
{ 
  int err ;
  snd_pcm_t *pcm ;
  snd_pcm_hw_params_t *hw_params ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  char const   *__cil_tmp15 ;
  unsigned int i ;
  unsigned int ind ;
  unsigned int ref[20] ;
  int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  char const   *__cil_tmp21 ;
  int __cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char const   *__cil_tmp24 ;

  {
  {
#line 276
  __cil_tmp7 = snd_pcm_hw_params_sizeof();
#line 276
  __cil_tmp8 = __builtin_alloca(__cil_tmp7);
#line 276
  hw_params = (snd_pcm_hw_params_t *)__cil_tmp8;
#line 277
  __cil_tmp9 = snd_pcm_hw_params_sizeof();
#line 277
  memset(hw_params, 0, __cil_tmp9);
#line 280
  err = snd_pcm_open(& pcm, device, (snd_pcm_stream_t )0, 0);
  }
#line 280
  if (err < 0) {
    {
#line 281
    __cil_tmp11 = logtime();
    }
    {
#line 281
    __cil_tmp12 = snd_strerror(err);
#line 281
    logprint("%s %s:%d playback open error: %s\n", __cil_tmp11, "test_open", 281,
             __cil_tmp12);
    }
#line 282
    return (0);
  }
  {
#line 286
  err = snd_pcm_hw_params_any(pcm, hw_params);
  }
#line 286
  if (err < 0) {
    {
#line 287
    __cil_tmp14 = logtime();
    }
    {
#line 287
    __cil_tmp15 = snd_strerror(err);
#line 287
    logprint("%s %s:%d hwparam init error: %s\n\230", __cil_tmp14, "test_open", 287,
             __cil_tmp15);
    }
#line 288
    return (0);
  }
#line 292
  if (! userdef_rates) {
#line 294
    ref[0] = (unsigned int )1536000;
#line 294
    ref[1] = (unsigned int )1411200;
#line 294
    ref[2] = (unsigned int )768000;
#line 294
    ref[3] = (unsigned int )705600;
#line 294
    ref[4] = (unsigned int )384000;
#line 294
    ref[5] = (unsigned int )352800;
#line 294
    ref[6] = (unsigned int )192000;
#line 294
    ref[7] = (unsigned int )176400;
#line 294
    ref[8] = (unsigned int )96000;
#line 294
    ref[9] = (unsigned int )88200;
#line 294
    ref[10] = (unsigned int )48000;
#line 294
    ref[11] = (unsigned int )44100;
#line 294
    ref[12] = (unsigned int )32000;
#line 294
    ref[13] = (unsigned int )24000;
#line 294
    ref[14] = (unsigned int )22500;
#line 294
    ref[15] = (unsigned int )16000;
#line 294
    ref[16] = (unsigned int )12000;
#line 294
    ref[17] = (unsigned int )11025;
#line 294
    ref[18] = (unsigned int )8000;
#line 294
    ref[19] = (unsigned int )0;
#line 296
    ind = (unsigned int )0;
#line 296
    i = (unsigned int )0;
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if (! ref[i]) {
#line 296
        goto while_break;
      }
      {
#line 297
      __cil_tmp19 = snd_pcm_hw_params_test_rate(pcm, hw_params, ref[i], 0);
      }
#line 297
      if (__cil_tmp19 == 0) {
#line 298
        __cil_tmp20 = ind;
#line 298
        ind ++;
#line 298
        rates[__cil_tmp20] = ref[i];
      } else
#line 301
      if ((unsigned int )loglevel___1 >= 3U) {
        {
#line 301
        __cil_tmp21 = logtime();
#line 301
        logprint("%s %s:%d sample rate %u not supported\n", __cil_tmp21, "test_open",
                 301, ref[i]);
        }
      }
#line 296
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 306
  err = snd_pcm_close(pcm);
  }
#line 306
  if (err < 0) {
    {
#line 307
    __cil_tmp23 = logtime();
    }
    {
#line 307
    __cil_tmp24 = snd_strerror(err);
#line 307
    logprint("%s %s:%d snd_pcm_close error: %s\n", __cil_tmp23, "test_open", 307,
             __cil_tmp24);
    }
#line 308
    return (0);
  }
#line 311
  return (1);
}
}
#line 314 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static int pcm_probe(char const   *device ) 
{ 
  int err ;
  snd_pcm_t *pcm ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
  {
#line 318
  err = snd_pcm_open(& pcm, device, (snd_pcm_stream_t )0, 0);
  }
#line 318
  if (err < 0) {
#line 319
    return (0);
  }
  {
#line 322
  err = snd_pcm_close(pcm);
  }
#line 322
  if (err < 0) {
    {
#line 323
    __cil_tmp6 = logtime();
    }
    {
#line 323
    __cil_tmp7 = snd_strerror(err);
#line 323
    logprint("%s %s:%d snd_pcm_close error: %s\n", __cil_tmp6, "pcm_probe", 323, __cil_tmp7);
    }
  }
#line 326
  return (1);
}
}
#line 332 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static int alsa_open(char const   *device , unsigned int sample_rate___0 , unsigned int alsa_buffer ,
                     unsigned int alsa_period ) 
{ 
  int err ;
  snd_pcm_hw_params_t *hw_params ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int retry ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;
  char const   *__cil_tmp16 ;
  size_t __cil_tmp17 ;
  int __cil_tmp18 ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;
  int hw ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  char const   *__cil_tmp24 ;
  char const   *__cil_tmp25 ;
  int __cil_tmp26 ;
  char const   *__cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  char const   *__cil_tmp30 ;
  char const   *__cil_tmp31 ;
  snd_pcm_format_t *fmt ;
  snd_pcm_format_t *tmp ;
  int __cil_tmp34 ;
  char const   *__cil_tmp35 ;
  char const   *__cil_tmp36 ;
  char const   *__cil_tmp37 ;
  char const   *__cil_tmp38 ;
  char const   *__cil_tmp39 ;
  int __cil_tmp40 ;
  char const   *__cil_tmp41 ;
  char const   *__cil_tmp42 ;
  unsigned int count ;
  int __cil_tmp44 ;
  char const   *__cil_tmp45 ;
  char const   *__cil_tmp46 ;
  snd_pcm_uframes_t size ;
  int dir ;
  int __cil_tmp49 ;
  char const   *__cil_tmp50 ;
  char const   *__cil_tmp51 ;
  unsigned int time___27 ;
  int dir___0 ;
  int __cil_tmp54 ;
  char const   *__cil_tmp55 ;
  char const   *__cil_tmp56 ;
  snd_pcm_uframes_t size___0 ;
  int __cil_tmp58 ;
  char const   *__cil_tmp59 ;
  char const   *__cil_tmp60 ;
  int __cil_tmp61 ;
  char const   *__cil_tmp62 ;
  char const   *__cil_tmp63 ;
  int __cil_tmp64 ;
  char const   *__cil_tmp65 ;
  char const   *__cil_tmp66 ;
  char const   *__cil_tmp67 ;
  void *__cil_tmp68 ;
  char const   *__cil_tmp69 ;
  int __cil_tmp70 ;
  char const   *__cil_tmp71 ;
  char const   *__cil_tmp72 ;
  static snd_output_t *debug_output ;

  {
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 336
    __cil_tmp7 = snd_pcm_hw_params_sizeof();
#line 336
    __cil_tmp8 = __builtin_alloca(__cil_tmp7);
#line 336
    *(& hw_params) = (snd_pcm_hw_params_t *)__cil_tmp8;
#line 336
    __cil_tmp9 = snd_pcm_hw_params_sizeof();
#line 336
    memset(*(& hw_params), 0, __cil_tmp9);
    }
#line 336
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  if (pcmp) {
    {
#line 339
    alsa_close();
    }
  }
  {
#line 342
  alsa.rate = (unsigned int )0;
#line 346
  alsa.period_size = (snd_pcm_uframes_t )0;
#line 347
  strcpy((char *)alsa.device, device);
#line 349
  __cil_tmp10 = strlen(device);
  }
#line 349
  if (__cil_tmp10 > 123UL) {
    {
#line 350
    __cil_tmp11 = logtime();
#line 350
    logprint("%s %s:%d device name too long: %s\n\ag\301U", __cil_tmp11, "alsa_open\351\ag\301U",
             350, device);
    }
#line 351
    return (- 1);
  }
#line 354
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 354
    __cil_tmp12 = logtime();
#line 354
    logprint("%s %s:%d opening device at: %u\n", __cil_tmp12, "alsa_open", 354, sample_rate___0);
    }
  }
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 359
    err = snd_pcm_open(& pcmp, (char const   *)((char *)alsa.device), (snd_pcm_stream_t )0,
                       0);
    }
#line 359
    if (err < 0) {
      {
#line 360
      __cil_tmp15 = logtime();
      }
      {
#line 360
      __cil_tmp16 = snd_strerror(err);
#line 360
      logprint("%s %s:%d playback open error: %s\n\364\ag\301U", __cil_tmp15, "alsa_open",
               360, __cil_tmp16);
      }
#line 361
      return (err);
    }
    {
#line 365
    __cil_tmp17 = snd_pcm_hw_params_sizeof();
#line 365
    memset(hw_params, 0, __cil_tmp17);
#line 366
    err = snd_pcm_hw_params_any(pcmp, hw_params);
    }
#line 366
    if (err < 0) {
      {
#line 367
      __cil_tmp19 = logtime();
      }
      {
#line 367
      __cil_tmp20 = snd_strerror(err);
#line 367
      logprint("%s %s:%d hwparam init error: %s\n\230", __cil_tmp19, "alsa_open\270\ag\301U",
               367, __cil_tmp20);
      }
#line 368
      return (err);
    }
    {
#line 372
    __cil_tmp22 = strncmp((char const   *)((char *)alsa.device), "hw:g\301U", (unsigned long )3);
#line 372
    hw = ! __cil_tmp22;
#line 373
    retry = 0;
#line 375
    err = snd_pcm_hw_params_set_rate_resample(pcmp, hw_params, (unsigned int )(! hw));
    }
#line 375
    if (err < 0) {
      {
#line 376
      __cil_tmp24 = logtime();
      }
      {
#line 376
      __cil_tmp25 = snd_strerror(err);
#line 376
      logprint("%s %s:%d resampling setup failed: %s\nU", __cil_tmp24, "alsa_open\257\ag\301U",
               376, __cil_tmp25);
      }
#line 377
      return (err);
    }
    {
#line 380
    err = snd_pcm_hw_params_set_rate(pcmp, hw_params, sample_rate___0, 0);
    }
#line 380
    if (err < 0) {
#line 381
      if (hw) {
        {
#line 382
        strcpy((char *)alsa.device + 4, device);
#line 383
        memcpy((char *)alsa.device, "plug", (unsigned long )4);
        }
#line 384
        if ((unsigned int )loglevel___1 >= 2U) {
          {
#line 384
          __cil_tmp27 = logtime();
#line 384
          logprint("%s %s:%d reopening device %s in plug mode as %s for resampling\n",
                   __cil_tmp27, "alsa_open", 384, device, (char *)alsa.device);
          }
        }
        {
#line 385
        snd_pcm_close(pcmp);
#line 386
        retry = 1;
        }
      }
    }
#line 357
    if (! retry) {
#line 357
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 393
  __cil_tmp28 = snd_pcm_hw_params_set_access(pcmp, hw_params, (snd_pcm_access_t )0);
  }
#line 393
  if (! alsa.mmap) {
    _L: /* CIL Label */ 
    {
#line 394
    err = snd_pcm_hw_params_set_access(pcmp, hw_params, (snd_pcm_access_t )3);
    }
#line 394
    if (err < 0) {
      {
#line 395
      __cil_tmp30 = logtime();
      }
      {
#line 395
      __cil_tmp31 = snd_strerror(err);
#line 395
      logprint("%s %s:%d access type not available: %s\n", __cil_tmp30, "alsa_open",
               395, __cil_tmp31);
      }
#line 396
      return (err);
    }
#line 398
    alsa.mmap = 0;
  } else
#line 393
  if (__cil_tmp28 < 0) {
#line 393
    goto _L;
  }
#line 422
  if ((int )alsa.format) {
#line 422
    tmp = & alsa.format;
  } else {
#line 422
    tmp = (snd_pcm_format_t *)((snd_pcm_format_t *)fmts);
  }
#line 422
  fmt = tmp;
  {
#line 423
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 424
    __cil_tmp34 = snd_pcm_hw_params_set_format(pcmp, hw_params, *fmt);
    }
#line 424
    if (__cil_tmp34 >= 0) {
#line 425
      if ((unsigned int )loglevel___1 >= 2U) {
        {
#line 425
        __cil_tmp35 = logtime();
        }
        {
#line 425
        __cil_tmp36 = snd_pcm_format_name(*fmt);
#line 425
        logprint("%s %s:%d opened device %s using format: %s sample rate: %u mmap: %u\n",
                 __cil_tmp35, "alsa_open", 425, (char *)alsa.device, __cil_tmp36,
                 sample_rate___0, alsa.mmap);
        }
      }
#line 426
      alsa.format = *fmt;
#line 427
      goto while_break___1;
    }
#line 429
    if (alsa.format) {
      {
#line 430
      __cil_tmp37 = logtime();
      }
      {
#line 430
      __cil_tmp38 = snd_pcm_format_name(alsa.format);
#line 430
      logprint("%s %s:%d unable to open audio device requested format: %s\n", __cil_tmp37,
               "alsa_open", 430, __cil_tmp38);
      }
#line 431
      return (- 1);
    }
#line 433
    fmt ++;
#line 434
    if ((int )*fmt == -1) {
      {
#line 435
      __cil_tmp39 = logtime();
#line 435
      logprint("%s %s:%d unable to open audio device with any supported format\n",
               __cil_tmp39, "alsa_open", 435);
      }
#line 436
      return (- 1);
    }
#line 423
    if (! ((int )*fmt != -1)) {
#line 423
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 442
  if ((int )alsa.format == 10) {
#line 442
    goto case_10;
  }
#line 444
  if ((int )alsa.format == 6) {
#line 444
    goto case_6;
  }
#line 446
  if ((int )alsa.format == 32) {
#line 446
    goto case_32;
  }
#line 448
  if ((int )alsa.format == 2) {
#line 448
    goto case_2;
  }
#line 462
  goto switch_default;
  case_10: /* CIL Label */ 
#line 443
  output.format = (output_format )0;
#line 443
  goto switch_break;
  case_6: /* CIL Label */ 
#line 445
  output.format = (output_format )1;
#line 445
  goto switch_break;
  case_32: /* CIL Label */ 
#line 447
  output.format = (output_format )2;
#line 447
  goto switch_break;
  case_2: /* CIL Label */ 
#line 449
  output.format = (output_format )3;
#line 449
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 463
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 467
  err = snd_pcm_hw_params_set_channels(pcmp, hw_params, (unsigned int )2);
  }
#line 467
  if (err < 0) {
    {
#line 468
    __cil_tmp41 = logtime();
    }
    {
#line 468
    __cil_tmp42 = snd_strerror(err);
#line 468
    logprint("%s %s:%d channel count not available: %s\n", __cil_tmp41, "alsa_open",
             468, __cil_tmp42);
    }
#line 469
    return (err);
  }
#line 473
  if (alsa_period < 50U) {
    {
#line 474
    count = alsa_period;
#line 475
    err = snd_pcm_hw_params_set_periods_near(pcmp, hw_params, & count, (int *)0);
    }
#line 475
    if (err < 0) {
      {
#line 476
      __cil_tmp45 = logtime();
      }
      {
#line 476
      __cil_tmp46 = snd_strerror(err);
#line 476
      logprint("%s %s:%d unable to set period count %s\n", __cil_tmp45, "alsa_open",
               476, __cil_tmp46);
      }
#line 477
      return (err);
    }
  } else {
    {
#line 480
    size = (snd_pcm_uframes_t )alsa_period;
#line 481
    dir = 0;
#line 482
    err = snd_pcm_hw_params_set_period_size_near(pcmp, hw_params, & size, & dir);
    }
#line 482
    if (err < 0) {
      {
#line 483
      __cil_tmp50 = logtime();
      }
      {
#line 483
      __cil_tmp51 = snd_strerror(err);
#line 483
      logprint("%s %s:%d unable to set period size %s\n", __cil_tmp50, "alsa_open",
               483, __cil_tmp51);
      }
#line 484
      return (err);
    }
  }
#line 489
  if (alsa_buffer < 500U) {
    {
#line 490
    time___27 = alsa_buffer * 1000U;
#line 491
    dir___0 = 0;
#line 492
    err = snd_pcm_hw_params_set_buffer_time_near(pcmp, hw_params, & time___27, & dir___0);
    }
#line 492
    if (err < 0) {
      {
#line 493
      __cil_tmp55 = logtime();
      }
      {
#line 493
      __cil_tmp56 = snd_strerror(err);
#line 493
      logprint("%s %s:%d unable to set buffer time %s\n", __cil_tmp55, "alsa_open",
               493, __cil_tmp56);
      }
#line 494
      return (err);
    }
  } else {
    {
#line 497
    size___0 = (snd_pcm_uframes_t )alsa_buffer;
#line 498
    err = snd_pcm_hw_params_set_buffer_size_near(pcmp, hw_params, & size___0);
    }
#line 498
    if (err < 0) {
      {
#line 499
      __cil_tmp59 = logtime();
      }
      {
#line 499
      __cil_tmp60 = snd_strerror(err);
#line 499
      logprint("%s %s:%d unable to set buffer size %s\n", __cil_tmp59, "alsa_open",
               499, __cil_tmp60);
      }
#line 500
      return (err);
    }
  }
  {
#line 505
  err = snd_pcm_hw_params_get_period_size(hw_params, & alsa.period_size, (int *)0);
  }
#line 505
  if (err < 0) {
    {
#line 506
    __cil_tmp62 = logtime();
    }
    {
#line 506
    __cil_tmp63 = snd_strerror(err);
#line 506
    logprint("%s %s:%d unable to get period size: %s\n", __cil_tmp62, "alsa_open",
             506, __cil_tmp63);
    }
#line 507
    return (err);
  }
  {
#line 511
  err = snd_pcm_hw_params_get_buffer_size(hw_params, & alsa.buffer_size);
  }
#line 511
  if (err < 0) {
    {
#line 512
    __cil_tmp65 = logtime();
    }
    {
#line 512
    __cil_tmp66 = snd_strerror(err);
#line 512
    logprint("%s %s:%d unable to get buffer size: %s\n", __cil_tmp65, "alsa_open",
             512, __cil_tmp66);
    }
#line 513
    return (err);
  }
#line 516
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 516
    __cil_tmp67 = logtime();
#line 516
    logprint("%s %s:%d buffer: %u period: %u -> buffer size: %u period size: %u\n",
             __cil_tmp67, "alsa_open", 516, alsa_buffer, alsa_period, alsa.buffer_size,
             alsa.period_size);
    }
  }
#line 519
  output.start_frames = (unsigned int )(alsa.buffer_size * 2UL);
#line 523
  if (! alsa.write_buf) {
#line 523
    if (! alsa.mmap) {
#line 523
      if ((int )alsa.format != 10) {
        {
#line 524
        alsa.write_buf = (u8_t *)malloc(alsa.buffer_size * 8UL);
        }
#line 525
        if (! alsa.write_buf) {
          {
#line 526
          __cil_tmp69 = logtime();
#line 526
          logprint("%s %s:%d unable to malloc write_buf\n", __cil_tmp69, "alsa_open",
                   526);
          }
#line 527
          return (- 1);
        }
      }
    }
  }
  {
#line 532
  err = snd_pcm_hw_params(pcmp, hw_params);
  }
#line 532
  if (err < 0) {
    {
#line 533
    __cil_tmp71 = logtime();
    }
    {
#line 533
    __cil_tmp72 = snd_strerror(err);
#line 533
    logprint("%s %s:%d unable to set hw params: %s\n", __cil_tmp71, "alsa_open", 533,
             __cil_tmp72);
    }
#line 534
    return (err);
  }
#line 538
  if ((unsigned int )loglevel___1 == 4U) {
    {
#line 540
    snd_output_stdio_attach(& debug_output, stderr, 0);
#line 541
    snd_pcm_dump(pcmp, debug_output);
    }
  }
#line 545
  alsa.rate = sample_rate___0;
#line 550
  return (0);
}
}
#line 553 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static int _write_frames(frames_t out_frames , int silence , s32_t gainL , s32_t gainR ,
                         u8_t flags , s32_t cross_gain_in , s32_t cross_gain_out ,
                         s32_t **cross_ptr ) 
{ 
  snd_pcm_channel_area_t *areas ;
  snd_pcm_uframes_t offset ;
  void *outputptr ;
  s32_t *inputptr ;
  int err ;
  snd_pcm_uframes_t alsa_frames ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  u8_t *tmp ;
  void *tmp___0 ;
  snd_pcm_sframes_t w ;
  snd_pcm_sframes_t __cil_tmp21 ;
  char const   *__cil_tmp22 ;
  snd_pcm_sframes_t w___0 ;
  snd_pcm_sframes_t __cil_tmp24 ;
  int __cil_tmp25 ;
  static unsigned int recover_count ;
  char const   *__cil_tmp27 ;
  char const   *__cil_tmp28 ;
  char const   *__cil_tmp29 ;

  {
#line 562
  if (alsa.mmap) {
    {
#line 563
    alsa_frames = (snd_pcm_uframes_t )out_frames;
#line 565
    snd_pcm_avail_update(pcmp);
#line 567
    err = snd_pcm_mmap_begin(pcmp, & areas, & offset, & alsa_frames);
    }
#line 567
    if (err < 0) {
#line 568
      if ((unsigned int )loglevel___1 >= 1U) {
        {
#line 568
        __cil_tmp16 = logtime();
        }
        {
#line 568
        __cil_tmp17 = snd_strerror(err);
#line 568
        logprint("%s %s:%d error from mmap_begin: %s\n", __cil_tmp16, "_write_frames",
                 568, __cil_tmp17);
        }
      }
#line 569
      return (- 1);
    }
#line 572
    out_frames = (frames_t )alsa_frames;
  }
#line 575
  if (! silence) {
#line 577
    if (*cross_ptr) {
#line 577
      if ((unsigned int )output.fade == 2U) {
#line 577
        if ((unsigned int )output.fade_dir == 3U) {
          {
#line 578
          _apply_cross(outputbuf, out_frames, cross_gain_in, cross_gain_out, cross_ptr);
          }
        }
      }
    }
  }
#line 582
  if (silence) {
#line 582
    tmp = silencebuf;
  } else {
#line 582
    tmp = outputbuf->readp;
  }
#line 582
  inputptr = (s32_t *)tmp;
#line 596
  if (alsa.mmap) {
    _L: /* CIL Label */ 
#line 598
    if (alsa.mmap) {
#line 598
      tmp___0 = (areas + 0)->addr + ((unsigned long )(areas + 0)->first + offset * (unsigned long )(areas + 0)->step) / 8UL;
    } else {
#line 598
      tmp___0 = (void *)alsa.write_buf;
    }
    {
#line 598
    outputptr = (int )tmp___0;
#line 600
    _scale_and_pack_frames(outputptr, inputptr, out_frames, gainL, gainR, flags, output.format);
    }
  } else
#line 596
  if ((int )alsa.format != 10) {
#line 596
    goto _L;
  } else {
#line 604
    outputptr = (void *)inputptr;
#line 606
    if (! silence) {
      {
#line 607
      _apply_gain(outputbuf, out_frames, gainL, gainR, flags);
      }
    }
  }
#line 611
  if (alsa.mmap) {
    {
#line 613
    __cil_tmp21 = snd_pcm_mmap_commit(pcmp, offset, (snd_pcm_uframes_t )out_frames);
#line 613
    w = __cil_tmp21;
    }
#line 614
    if (w < 0L) {
      _L___28: /* CIL Label */ 
#line 615
      if ((unsigned int )loglevel___1 >= 1U) {
        {
#line 615
        __cil_tmp22 = logtime();
#line 615
        logprint("%s %s:%d mmap_commit error\n", __cil_tmp22, "_write_frames", 615);
        }
      }
#line 616
      return (- 1);
    } else
#line 614
    if (w != (long )out_frames) {
#line 614
      goto _L___28;
    }
  } else {
    {
#line 621
    __cil_tmp24 = snd_pcm_writei(pcmp, outputptr, (snd_pcm_uframes_t )out_frames);
#line 621
    w___0 = __cil_tmp24;
    }
#line 622
    if (w___0 < 0L) {
      {
#line 624
      err = snd_pcm_recover(pcmp, (int )w___0, 1);
      }
#line 624
      if (err < 0) {
#line 625
        recover_count = (unsigned int )0;
#line 626
        if ((unsigned int )loglevel___1 >= 1U) {
          {
#line 626
          __cil_tmp27 = logtime();
          }
          {
#line 626
          __cil_tmp28 = snd_strerror(err);
          }
          {
#line 626
          recover_count ++;
#line 626
          logprint("%s %s:%d recover failed: %s [%u]\n\242\bg\301U", __cil_tmp27,
                   "_write_frames", 626, __cil_tmp28, recover_count);
          }
        }
#line 627
        if (recover_count >= 10U) {
          {
#line 628
          recover_count = (unsigned int )0;
#line 629
          alsa_close();
#line 630
          pcmp = (snd_pcm_t *)((void *)0);
          }
        }
      }
#line 633
      return (- 1);
    } else {
#line 635
      if (w___0 != (long )out_frames) {
#line 636
        if ((unsigned int )loglevel___1 >= 1U) {
          {
#line 636
          __cil_tmp29 = logtime();
#line 636
          logprint("%s %s:%d writei only wrote %u of %u\n", __cil_tmp29, "_write_frames",
                   636, w___0, out_frames);
          }
        }
      }
#line 638
      out_frames = (frames_t )w___0;
    }
  }
#line 642
  return ((int )out_frames);
}
}
#line 645 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
static void *output_thread___0(void *arg ) 
{ 
  int start ;
  int output_off ;
  int probe_device ;
  int err ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  snd_pcm_state_t state ;
  snd_pcm_state_t __cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  char const   *__cil_tmp15 ;
  int __cil_tmp16 ;
  char const   *__cil_tmp17 ;
  char const   *__cil_tmp18 ;
  char const   *__cil_tmp19 ;
  snd_pcm_sframes_t avail ;
  snd_pcm_sframes_t __cil_tmp21 ;
  int __cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char const   *__cil_tmp24 ;
  char const   *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  char const   *__cil_tmp28 ;
  char const   *__cil_tmp29 ;
  char const   *__cil_tmp30 ;
  int __cil_tmp31 ;
  char const   *__cil_tmp32 ;
  int __cil_tmp33 ;
  char const   *__cil_tmp34 ;
  char const   *__cil_tmp35 ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  char const   *__cil_tmp38 ;
  char const   *__cil_tmp39 ;
  snd_pcm_sframes_t delay ;
  int __cil_tmp41 ;
  char const   *__cil_tmp42 ;
  char const   *__cil_tmp43 ;
  u32_t __cil_tmp44 ;
  frames_t wrote ;
  frames_t __cil_tmp46 ;
  char const   *__cil_tmp47 ;

  {
#line 646
  start = 1;
#line 647
  output_off = (int )output.state == -1;
#line 648
  probe_device = (int )(arg != (void *)0);
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! running___1) {
#line 651
      goto while_break;
    }
    {
#line 654
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 654
      if (! output_off) {
#line 654
        goto while_break___0;
      }
      {
#line 655
      usleep((__useconds_t )100000);
#line 656
      pthread_mutex_lock(& outputbuf->mutex);
#line 657
      output_off = (int )output.state == -1;
#line 658
      pthread_mutex_unlock(& outputbuf->mutex);
      }
#line 659
      if (! running___1) {
#line 659
        return ((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 663
    if (probe_device) {
      {
#line 664
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 664
        __cil_tmp6 = pcm_probe(output.device);
        }
#line 664
        if (! (! __cil_tmp6)) {
#line 664
          goto while_break___1;
        }
#line 665
        if ((unsigned int )loglevel___1 >= 3U) {
          {
#line 665
          __cil_tmp7 = logtime();
#line 665
          logprint("%s %s:%d waiting for device %s to return\nY\bg\301U", __cil_tmp7,
                   "output_threadU", 665, output.device);
          }
        }
        {
#line 666
        sleep((unsigned int )5);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 668
      probe_device = 0;
    }
#line 674
    if (! pcmp) {
      _L: /* CIL Label */ 
#line 685
      if ((unsigned int )loglevel___1 >= 2U) {
        {
#line 685
        __cil_tmp8 = logtime();
#line 685
        logprint("%s %s:%d open output device: %s\n\230", __cil_tmp8, "output_threadU",
                 685, output.device);
        }
      }
      {
#line 686
      pthread_mutex_lock(& outputbuf->mutex);
      }
#line 690
      if (alsa.reopen) {
        {
#line 694
        alsa_open(output.device, output.current_sample_rate, output.buffer, output.period);
        }
      }
      {
#line 700
      __cil_tmp9 = alsa_open(output.device, output.current_sample_rate, output.buffer,
                             output.period);
      }
#line 700
      if (! (! __cil_tmp9)) {
        {
#line 702
        output.error_opening = 1;
#line 703
        pthread_mutex_unlock(& outputbuf->mutex);
#line 704
        sleep((unsigned int )5);
        }
#line 705
        goto while_continue;
      }
      {
#line 707
      output.error_opening = 0;
#line 708
      start = 1;
#line 709
      pthread_mutex_unlock(& outputbuf->mutex);
      }
    } else
#line 674
    if (alsa.rate != output.current_sample_rate) {
#line 674
      goto _L;
    }
    {
#line 712
    __cil_tmp11 = snd_pcm_state(pcmp);
#line 712
    state = __cil_tmp11;
    }
#line 714
    if ((unsigned int )state == 4U) {
#line 715
      if ((unsigned int )loglevel___1 >= 2U) {
        {
#line 715
        __cil_tmp12 = logtime();
#line 715
        logprint("%s %s:%d XRUN\n", __cil_tmp12, "output_threadU", 715);
        }
      }
      {
#line 716
      err = snd_pcm_recover(pcmp, - 32, 1);
      }
#line 716
      if (err < 0) {
#line 717
        if ((unsigned int )loglevel___1 >= 2U) {
          {
#line 717
          __cil_tmp14 = logtime();
          }
          {
#line 717
          __cil_tmp15 = snd_strerror(err);
#line 717
          logprint("%s %s:%d XRUN recover failed: %s\n", __cil_tmp14, "output_threadU",
                   717, __cil_tmp15);
          }
        }
        {
#line 718
        usleep((__useconds_t )10000);
        }
      }
#line 720
      start = 1;
#line 721
      goto while_continue;
    } else
#line 722
    if ((unsigned int )state == 7U) {
      {
#line 723
      err = snd_pcm_recover(pcmp, - 86, 1);
      }
#line 723
      if (err < 0) {
#line 724
        if ((unsigned int )loglevel___1 >= 2U) {
          {
#line 724
          __cil_tmp17 = logtime();
          }
          {
#line 724
          __cil_tmp18 = snd_strerror(err);
#line 724
          logprint("%s %s:%d SUSPEND recover failed: %s\n", __cil_tmp17, "output_thread",
                   724, __cil_tmp18);
          }
        }
      }
    } else
#line 726
    if ((unsigned int )state == 8U) {
#line 727
      if ((unsigned int )loglevel___1 >= 2U) {
        {
#line 727
        __cil_tmp19 = logtime();
#line 727
        logprint("%s %s:%d Device %s no longer available\n", __cil_tmp19, "output_threadU",
                 727, output.device);
        }
      }
      {
#line 728
      alsa_close();
#line 729
      pcmp = (snd_pcm_t *)((void *)0);
#line 730
      probe_device = 1;
      }
#line 731
      goto while_continue;
    }
    {
#line 734
    __cil_tmp21 = snd_pcm_avail_update(pcmp);
#line 734
    avail = __cil_tmp21;
    }
#line 736
    if (avail < 0L) {
      {
#line 737
      err = snd_pcm_recover(pcmp, (int )avail, 1);
      }
#line 737
      if (err < 0) {
#line 738
        if (err == -19) {
#line 739
          if ((unsigned int )loglevel___1 >= 2U) {
            {
#line 739
            __cil_tmp23 = logtime();
#line 739
            logprint("%s %s:%d Device %s no longer available\n", __cil_tmp23, "output_thread",
                     739, output.device);
            }
          }
          {
#line 740
          alsa_close();
#line 741
          pcmp = (snd_pcm_t *)((void *)0);
#line 742
          probe_device = 1;
          }
#line 743
          goto while_continue;
        }
#line 745
        if ((unsigned int )loglevel___1 >= 1U) {
          {
#line 745
          __cil_tmp24 = logtime();
          }
          {
#line 745
          __cil_tmp25 = snd_strerror(err);
#line 745
          logprint("%s %s:%d recover failed: %s\n\301U", __cil_tmp24, "output_threadU",
                   745, __cil_tmp25);
          }
        }
      }
#line 747
      start = 1;
#line 748
      goto while_continue;
    }
#line 751
    if ((unsigned long )avail < alsa.period_size) {
#line 752
      if (start) {
        {
#line 753
        err = snd_pcm_start(pcmp);
        }
#line 753
        if (alsa.mmap) {
#line 753
          if (err < 0) {
            {
#line 754
            err = snd_pcm_recover(pcmp, err, 1);
            }
#line 754
            if (err < 0) {
#line 755
              if (err == -19) {
#line 756
                if ((unsigned int )loglevel___1 >= 2U) {
                  {
#line 756
                  __cil_tmp28 = logtime();
#line 756
                  logprint("%s %s:%d Device %s no longer available\n", __cil_tmp28,
                           "output_threadU", 756, output.device);
                  }
                }
                {
#line 757
                alsa_close();
#line 758
                pcmp = (snd_pcm_t *)((void *)0);
#line 759
                probe_device = 1;
                }
#line 760
                goto while_continue;
              }
#line 762
              if ((unsigned int )loglevel___1 >= 2U) {
                {
#line 762
                __cil_tmp29 = logtime();
                }
                {
#line 762
                __cil_tmp30 = snd_strerror(err);
#line 762
                logprint("%s %s:%d start error: %s\n\225\bg\301U", __cil_tmp29, "output_threadU",
                         762, __cil_tmp30);
                }
              }
              {
#line 763
              usleep((__useconds_t )10000);
              }
            }
          } else {
#line 766
            start = 0;
          }
        } else {
#line 766
          start = 0;
        }
      } else {
        {
#line 769
        usleep((__useconds_t )10000);
#line 770
        err = snd_pcm_wait(pcmp, 1000);
        }
#line 770
        if (err <= 0) {
#line 771
          if (err == 0) {
#line 772
            if ((unsigned int )loglevel___1 >= 2U) {
              {
#line 772
              __cil_tmp32 = logtime();
#line 772
              logprint("%s %s:%d pcm wait timeout\n\bg\301U", __cil_tmp32, "output_threadU",
                       772);
              }
            }
          }
          {
#line 774
          err = snd_pcm_recover(pcmp, err, 1);
          }
#line 774
          if (err < 0) {
#line 775
            if ((unsigned int )loglevel___1 >= 2U) {
              {
#line 775
              __cil_tmp34 = logtime();
              }
              {
#line 775
              __cil_tmp35 = snd_strerror(err);
#line 775
              logprint("%s %s:%d pcm wait error: %s\n", __cil_tmp34, "output_thread",
                       775, __cil_tmp35);
              }
            }
          }
#line 777
          start = 1;
        }
      }
#line 780
      goto while_continue;
    }
#line 785
    if (alsa.mmap) {
#line 786
      if ((unsigned long )avail < alsa.buffer_size) {
#line 786
        tmp = (unsigned long )avail;
      } else {
#line 786
        tmp = alsa.buffer_size;
      }
#line 786
      avail = (snd_pcm_sframes_t )tmp;
    } else {
#line 788
      if ((unsigned long )avail < alsa.period_size) {
#line 788
        tmp___0 = (unsigned long )avail;
      } else {
#line 788
        tmp___0 = alsa.period_size;
      }
#line 788
      avail = (snd_pcm_sframes_t )tmp___0;
    }
#line 792
    if (avail == 0L) {
#line 793
      if ((unsigned int )loglevel___1 >= 4U) {
        {
#line 793
        __cil_tmp38 = logtime();
#line 793
        logprint("%s %s:%d avail 0 - sleeping\n", __cil_tmp38, "output_threadU", 793);
        }
      }
      {
#line 794
      usleep((__useconds_t )10000);
      }
#line 795
      goto while_continue;
    }
    {
#line 798
    pthread_mutex_lock(& outputbuf->mutex);
    }
#line 801
    if ((int )output.state == -1) {
      {
#line 802
      pthread_mutex_unlock(& outputbuf->mutex);
      }
#line 803
      if ((unsigned int )loglevel___1 >= 2U) {
        {
#line 803
        __cil_tmp39 = logtime();
#line 803
        logprint("%s %s:%d disabling output\n", __cil_tmp39, "output_thread", 803);
        }
      }
      {
#line 804
      alsa_close();
#line 805
      pcmp = (snd_pcm_t *)((void *)0);
#line 806
      output_off = 1;
      }
#line 817
      goto while_continue;
    }
    {
#line 822
    err = snd_pcm_delay(pcmp, & delay);
    }
#line 822
    if (err < 0) {
#line 823
      if (err == -32) {
        {
#line 825
        pthread_mutex_unlock(& outputbuf->mutex);
        }
#line 826
        goto while_continue;
      } else
#line 827
      if (err == -5) {
        {
#line 829
        pthread_mutex_unlock(& outputbuf->mutex);
        }
#line 830
        if ((unsigned int )loglevel___1 >= 4U) {
          {
#line 830
          __cil_tmp42 = logtime();
#line 830
          logprint("%s %s:%d snd_pcm_delay returns: EIO - sleeping\n", __cil_tmp42,
                   "output_thread", 830);
          }
        }
        {
#line 831
        usleep((__useconds_t )100000);
        }
#line 832
        goto while_continue;
      } else
#line 834
      if ((unsigned int )loglevel___1 >= 3U) {
        {
#line 834
        __cil_tmp43 = logtime();
#line 834
        logprint("%s %s:%d snd_pcm_delay returns: %d\ng\301U", __cil_tmp43, "output_threadU",
                 834, err);
        }
      }
    } else {
      {
#line 837
      output.device_frames = (unsigned int )delay;
#line 838
      output.updated = gettime_ms();
#line 839
      output.frames_played_dmp = output.frames_played;
      }
    }
    {
#line 843
    __cil_tmp46 = _output_frames((frames_t )avail);
#line 843
    wrote = __cil_tmp46;
#line 845
    pthread_mutex_unlock(& outputbuf->mutex);
    }
#line 848
    if (! wrote) {
#line 849
      if ((unsigned int )loglevel___1 >= 4U) {
        {
#line 849
        __cil_tmp47 = logtime();
#line 849
        logprint("%s %s:%d wrote 0 - sleeping\n", __cil_tmp47, "output_thread", 849);
        }
      }
      {
#line 850
      usleep((__useconds_t )10000);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  return ((void *)0);
}
}
#line 857 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
int mixer_init_alsa(char const   *device , char const   *mixer , int mixer_index ) 
{ 
  int err ;
  snd_mixer_selem_id_t *sid ;
  int __cil_tmp6 ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;
  int __cil_tmp12 ;
  char const   *__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  char const   *__cil_tmp17 ;
  size_t __cil_tmp18 ;
  void *__cil_tmp19 ;
  size_t __cil_tmp20 ;
  snd_mixer_elem_t *__cil_tmp21 ;
  char const   *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char const   *__cil_tmp26 ;

  {
  {
#line 861
  err = snd_mixer_open(& alsa.mixer_handle, 0);
  }
#line 861
  if (err < 0) {
    {
#line 862
    __cil_tmp7 = logtime();
    }
    {
#line 862
    __cil_tmp8 = snd_strerror(err);
#line 862
    logprint("%s %s:%d open error: %s\n\230", __cil_tmp7, "mixer_init_alsa", 862,
             __cil_tmp8);
    }
#line 863
    return (- 1);
  }
  {
#line 865
  err = snd_mixer_attach(alsa.mixer_handle, device);
  }
#line 865
  if (err < 0) {
    {
#line 866
    __cil_tmp10 = logtime();
    }
    {
#line 866
    __cil_tmp11 = snd_strerror(err);
#line 866
    logprint("%s %s:%d attach error: %s\n", __cil_tmp10, "mixer_init_alsa", 866, __cil_tmp11);
#line 867
    snd_mixer_close(alsa.mixer_handle);
    }
#line 868
    return (- 1);
  }
  {
#line 870
  err = snd_mixer_selem_register(alsa.mixer_handle, (struct snd_mixer_selem_regopt *)((void *)0),
                                 (snd_mixer_class_t **)((void *)0));
  }
#line 870
  if (err < 0) {
    {
#line 871
    __cil_tmp13 = logtime();
    }
    {
#line 871
    __cil_tmp14 = snd_strerror(err);
#line 871
    logprint("%s %s:%d register error: %s\n\301U", __cil_tmp13, "mixer_init_alsa",
             871, __cil_tmp14);
#line 872
    snd_mixer_close(alsa.mixer_handle);
    }
#line 873
    return (- 1);
  }
  {
#line 875
  err = snd_mixer_load(alsa.mixer_handle);
  }
#line 875
  if (err < 0) {
    {
#line 876
    __cil_tmp16 = logtime();
    }
    {
#line 876
    __cil_tmp17 = snd_strerror(err);
#line 876
    logprint("%s %s:%d load error: %s\n\230", __cil_tmp16, "mixer_init_alsa", 876,
             __cil_tmp17);
#line 877
    snd_mixer_close(alsa.mixer_handle);
    }
#line 878
    return (- 1);
  }
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 881
    __cil_tmp18 = snd_mixer_selem_id_sizeof();
#line 881
    __cil_tmp19 = __builtin_alloca(__cil_tmp18);
#line 881
    *(& sid) = (snd_mixer_selem_id_t *)__cil_tmp19;
#line 881
    __cil_tmp20 = snd_mixer_selem_id_sizeof();
#line 881
    memset(*(& sid), 0, __cil_tmp20);
    }
#line 881
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 882
  snd_mixer_selem_id_set_index(sid, (unsigned int )mixer_index);
#line 883
  snd_mixer_selem_id_set_name(sid, mixer);
#line 885
  alsa.mixer_elem = snd_mixer_find_selem(alsa.mixer_handle, sid);
  }
#line 885
  if (alsa.mixer_elem == (void *)0) {
    {
#line 886
    __cil_tmp22 = logtime();
#line 886
    logprint("%s %s:%d error find selem %s\n", __cil_tmp22, "mixer_init_alsa", 886,
             alsa.mixer_handle);
#line 887
    snd_mixer_close(alsa.mixer_handle);
    }
#line 888
    return (- 1);
  }
  {
#line 891
  __cil_tmp23 = snd_mixer_selem_has_playback_switch(alsa.mixer_elem);
  }
#line 891
  if (__cil_tmp23) {
    {
#line 892
    snd_mixer_selem_set_playback_switch_all(alsa.mixer_elem, 1);
    }
  }
  {
#line 895
  err = snd_mixer_selem_get_playback_dB_range(alsa.mixer_elem, & alsa.mixer_min, & alsa.mixer_max);
  }
#line 897
  if (err < 0) {
    _L: /* CIL Label */ 
    _L___29: /* CIL Label */ 
    {
#line 898
    alsa.mixer_linear = 1;
#line 900
    err = snd_mixer_selem_get_playback_volume_range(alsa.mixer_elem, & alsa.mixer_min,
                                                    & alsa.mixer_max);
    }
#line 900
    if (err < 0) {
      {
#line 902
      __cil_tmp26 = logtime();
#line 902
      logprint("%s %s:%d Unable to get volume raw range\n\230", __cil_tmp26, "mixer_init_alsa",
               902);
      }
#line 903
      return (- 1);
    }
  } else
#line 897
  if (alsa.mixer_max - alsa.mixer_min < 1000L) {
#line 897
    goto _L;
  } else
#line 897
  if (alsa.mixer_linear) {
#line 897
    goto _L;
  }
#line 906
  return (0);
}
}
#line 909
static pthread_t thread___1 ;
#line 911 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
void output_init_alsa(log_level level , char const   *device , unsigned int output_buf_size ,
                      char *params , unsigned int rates[] , unsigned int rate_delay ,
                      unsigned int rt_priority , unsigned int idle , char *mixer_device ,
                      char *volume_mixer , int mixer_unmute , int mixer_linear ) 
{ 
  unsigned int alsa_buffer ;
  unsigned int alsa_period ;
  char *alsa_sample_fmt ;
  int alsa_mmap ;
  int alsa_reopen ;
  char *volume_mixer_name ;
  char *__cil_tmp19 ;
  char *volume_mixer_index ;
  char *__cil_tmp21 ;
  char *t ;
  char *__cil_tmp23 ;
  char *c ;
  char *__cil_tmp25 ;
  char *s ;
  char *__cil_tmp27 ;
  char *m___1 ;
  char *__cil_tmp29 ;
  char *r ;
  char *__cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  char const   *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *tmp ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  char const   *__cil_tmp44 ;
  char *tmp___0 ;
  int __cil_tmp46 ;
  int tmp___1 ;
  int __cil_tmp48 ;
  char const   *__cil_tmp49 ;
  int __cil_tmp50 ;
  char const   *__cil_tmp51 ;
  int *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char const   *__cil_tmp54 ;
  char const   *__cil_tmp55 ;
  pthread_attr_t attr ;
  char const   *tmp___2 ;
  struct sched_param param ;
  int __cil_tmp59 ;
  char const   *__cil_tmp60 ;
  int *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char const   *__cil_tmp63 ;

  {
  {
#line 913
  alsa_buffer = (unsigned int )40;
#line 914
  alsa_period = (unsigned int )4;
#line 915
  alsa_sample_fmt = (char *)((void *)0);
#line 916
  alsa_mmap = 1;
#line 917
  alsa_reopen = 0;
#line 919
  __cil_tmp19 = next_param(volume_mixer, (char )',');
#line 919
  volume_mixer_name = __cil_tmp19;
#line 920
  __cil_tmp21 = next_param((char *)((void *)0), (char )',');
#line 920
  volume_mixer_index = __cil_tmp21;
#line 922
  __cil_tmp23 = next_param(params, (char )':');
#line 922
  t = __cil_tmp23;
#line 923
  __cil_tmp25 = next_param((char *)((void *)0), (char )':');
#line 923
  c = __cil_tmp25;
#line 924
  __cil_tmp27 = next_param((char *)((void *)0), (char )':');
#line 924
  s = __cil_tmp27;
#line 925
  __cil_tmp29 = next_param((char *)((void *)0), (char )':');
#line 925
  m___1 = __cil_tmp29;
#line 926
  __cil_tmp31 = next_param((char *)((void *)0), (char )':');
#line 926
  r = __cil_tmp31;
  }
#line 928
  if (t) {
    {
#line 928
    __cil_tmp32 = atoi((char const   *)t);
#line 928
    alsa_buffer = (unsigned int )__cil_tmp32;
    }
  }
#line 929
  if (c) {
    {
#line 929
    __cil_tmp33 = atoi((char const   *)c);
#line 929
    alsa_period = (unsigned int )__cil_tmp33;
    }
  }
#line 930
  if (s) {
#line 930
    alsa_sample_fmt = s;
  }
#line 931
  if (m___1) {
    {
#line 931
    alsa_mmap = atoi((char const   *)m___1);
    }
  }
#line 932
  if (r) {
    {
#line 932
    alsa_reopen = atoi((char const   *)r);
    }
  }
#line 934
  loglevel___1 = level;
#line 936
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 936
    __cil_tmp36 = logtime();
#line 936
    logprint("%s %s:%d init output\n", __cil_tmp36, "output_init_alsa\312\001D", 936);
    }
  }
  {
#line 938
  memset(& output, 0, sizeof(output));
#line 940
  alsa.mmap = alsa_mmap;
#line 941
  alsa.write_buf = (u8_t *)((void *)0);
#line 945
  alsa.format = (snd_pcm_format_t )0;
#line 947
  alsa.reopen = alsa_reopen;
#line 948
  alsa.mixer_handle = (snd_mixer_t *)((void *)0);
#line 949
  alsa.ctl = ctl4device(device);
  }
#line 950
  if (mixer_device) {
    {
#line 950
    __cil_tmp38 = ctl4device((char const   *)mixer_device);
#line 950
    tmp = __cil_tmp38;
    }
  } else {
#line 950
    tmp = alsa.ctl;
  }
#line 950
  alsa.mixer_ctl = tmp;
#line 951
  alsa.volume_mixer_name = (char const   *)volume_mixer_name;
#line 952
  alsa.mixer_linear = mixer_linear;
#line 954
  output.format = (output_format )0;
#line 955
  output.buffer = alsa_buffer;
#line 956
  output.period = alsa_period;
#line 957
  output.start_frames = (unsigned int )0;
#line 958
  output.write_cb = & _write_frames;
#line 959
  output.rate_delay = rate_delay;
#line 961
  if (alsa_sample_fmt) {
    {
#line 968
    __cil_tmp40 = strcmp((char const   *)alsa_sample_fmt, "32\tg\301U");
    }
#line 968
    if (! __cil_tmp40) {
#line 968
      alsa.format = (snd_pcm_format_t )10;
    }
    {
#line 969
    __cil_tmp41 = strcmp((char const   *)alsa_sample_fmt, "24\tg\301U");
    }
#line 969
    if (! __cil_tmp41) {
#line 969
      alsa.format = (snd_pcm_format_t )6;
    }
    {
#line 970
    __cil_tmp42 = strcmp((char const   *)alsa_sample_fmt, "24_3");
    }
#line 970
    if (! __cil_tmp42) {
#line 970
      alsa.format = (snd_pcm_format_t )32;
    }
    {
#line 971
    __cil_tmp43 = strcmp((char const   *)alsa_sample_fmt, "16\tg\301U");
    }
#line 971
    if (! __cil_tmp43) {
#line 971
      alsa.format = (snd_pcm_format_t )2;
    }
  }
#line 975
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 975
    __cil_tmp44 = logtime();
    }
#line 975
    if (alsa_sample_fmt) {
#line 975
      tmp___0 = alsa_sample_fmt;
    } else {
#line 975
      tmp___0 = (char *)"any";
    }
    {
#line 975
    logprint("%s %s:%d requested alsa_buffer: %u alsa_period: %u format: %s mmap: %u\n",
             __cil_tmp44, "output_init_alsa\312\001D", 975, output.buffer, output.period,
             (int )tmp___0, alsa.mmap);
    }
  }
  {
#line 978
  snd_lib_error_set_handler((snd_lib_error_handler_t )(& alsa_error_handler));
#line 980
  output_init_common(level, device, output_buf_size, rates, idle);
  }
#line 982
  if (volume_mixer_name) {
#line 983
    if (volume_mixer_index) {
      {
#line 983
      __cil_tmp46 = atoi((char const   *)volume_mixer_index);
#line 983
      tmp___1 = __cil_tmp46;
      }
    } else {
#line 983
      tmp___1 = 0;
    }
    {
#line 983
    __cil_tmp48 = mixer_init_alsa((char const   *)alsa.mixer_ctl, alsa.volume_mixer_name,
                                  tmp___1);
    }
#line 983
    if (__cil_tmp48 < 0) {
      {
#line 986
      __cil_tmp49 = logtime();
#line 986
      logprint("%s %s:%d Initialization of mixer failed, reverting to software volume\n",
               __cil_tmp49, "output_init_alsa\312\001D", 986);
#line 987
      alsa.mixer_handle = (snd_mixer_t *)((void *)0);
#line 988
      alsa.volume_mixer_name = (char const   *)((void *)0);
      }
    }
  }
#line 991
  if (alsa.volume_mixer_name) {
#line 991
    if (mixer_unmute) {
      {
#line 992
      set_mixer(1, (float )0, (float )0);
#line 993
      alsa.volume_mixer_name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 999
  __cil_tmp50 = mlockall(3);
  }
#line 999
  if (__cil_tmp50 == -1) {
#line 1000
    if ((unsigned int )loglevel___1 >= 2U) {
      {
#line 1000
      __cil_tmp51 = logtime();
      }
      {
#line 1000
      __cil_tmp52 = __errno_location();
#line 1000
      __cil_tmp53 = strerror(*__cil_tmp52);
#line 1000
      logprint("%s %s:%d unable to lock memory: %s\n", __cil_tmp51, "output_init_alsa\312\001Dg\262\034\a",
               1000, __cil_tmp53);
      }
    }
  } else
#line 1002
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 1002
    __cil_tmp54 = logtime();
#line 1002
    logprint("%s %s:%d memory locked\n", __cil_tmp54, "output_init_alsa\312\001DgH\036\a",
             1002);
    }
  }
  {
#line 1006
  mallopt(- 1, - 1);
#line 1007
  mallopt(- 4, 0);
  }
#line 1008
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 1008
    __cil_tmp55 = logtime();
#line 1008
    logprint("%s %s:%d glibc detected using mallopt\n", __cil_tmp55, "output_init_alsa\312\001Dg$!\a",
             1008);
    }
  }
  {
#line 1011
  touch_memory(silencebuf, (size_t )16384);
#line 1012
  touch_memory(outputbuf->buf, outputbuf->size);
#line 1017
  pthread_attr_init(& attr);
#line 1018
  pthread_attr_setstacksize(& attr, (size_t )81920);
  }
#line 1019
  if (rates[0]) {
#line 1019
    tmp___2 = "probe";
  } else {
#line 1019
    tmp___2 = (char const   *)((char *)((void *)0));
  }
  {
#line 1019
  pthread_create(& thread___1, & attr, & output_thread___0, (int )tmp___2);
#line 1020
  pthread_attr_destroy(& attr);
#line 1024
  param.sched_priority = (int )rt_priority;
#line 1025
  __cil_tmp59 = pthread_setschedparam(thread___1, 1, & param);
  }
#line 1025
  if (__cil_tmp59 != 0) {
#line 1026
    if ((unsigned int )loglevel___1 >= 3U) {
      {
#line 1026
      __cil_tmp60 = logtime();
      }
      {
#line 1026
      __cil_tmp61 = __errno_location();
#line 1026
      __cil_tmp62 = strerror(*__cil_tmp61);
#line 1026
      logprint("%s %s:%d unable to set output sched fifo: %s\n", __cil_tmp60, "output_init_alsa\312\001D",
               1026, __cil_tmp62);
      }
    }
  } else
#line 1028
  if ((unsigned int )loglevel___1 >= 3U) {
    {
#line 1028
    __cil_tmp63 = logtime();
#line 1028
    logprint("%s %s:%d set output sched fifo rt: %u\n", __cil_tmp63, "output_init_alsa\312\001DgE*\a",
             1028, param.sched_priority);
    }
  }
  return;
}
}
#line 1032 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output_alsa.c"
void output_close_alsa(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 1033
  if ((unsigned int )loglevel___1 >= 2U) {
    {
#line 1033
    __cil_tmp1 = logtime();
#line 1033
    logprint("%s %s:%d close output\n", __cil_tmp1, "output_close_alsa\331\tg\301U",
             1033);
    }
  }
  {
#line 1035
  pthread_mutex_lock(& outputbuf->mutex);
#line 1036
  running___1 = 0;
#line 1037
  pthread_mutex_unlock(& outputbuf->mutex);
#line 1039
  pthread_join(thread___1, (void **)((void *)0));
  }
#line 1041
  if (alsa.write_buf) {
    {
#line 1041
    free(alsa.write_buf);
    }
  }
#line 1042
  if (alsa.ctl) {
    {
#line 1042
    free(alsa.ctl);
    }
  }
#line 1043
  if (alsa.mixer_ctl) {
    {
#line 1043
    free(alsa.mixer_ctl);
    }
  }
#line 1044
  if (alsa.mixer_handle != (void *)0) {
    {
#line 1044
    snd_mixer_close(alsa.mixer_handle);
    }
  }
  {
#line 1046
  output_close_common();
  }
  return;
}
}
#line 26 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
static log_level loglevel___2 ;
#line 30
static struct buffer buf___0 ;
#line 32 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
struct buffer *outputbuf  =    & buf___0;
#line 39 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
int user_rates  =    0;
#line 46 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
frames_t _output_frames(frames_t avail ) 
{ 
  frames_t frames ;
  frames_t size ;
  int silence ;
  u8_t flags ;
  s32_t cross_gain_in ;
  s32_t cross_gain_out ;
  s32_t *cross_ptr ;
  s32_t gainL ;
  s32_t __cil_tmp10 ;
  unsigned int tmp ;
  s32_t gainR ;
  s32_t __cil_tmp13 ;
  unsigned int tmp___0 ;
  unsigned int __cil_tmp15 ;
  char const   *__cil_tmp16 ;
  frames_t skip ;
  frames_t tmp___1 ;
  char const   *__cil_tmp19 ;
  frames_t cont_frames ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  frames_t tmp___2 ;
  char const   *__cil_tmp24 ;
  frames_t tmp___3 ;
  frames_t tmp___4 ;
  u32_t now ;
  u32_t __cil_tmp28 ;
  u32_t delta_frames ;
  frames_t tmp___5 ;
  frames_t tmp___6 ;
  frames_t tmp___7 ;
  char const   *__cil_tmp33 ;
  frames_t tmp___8 ;
  frames_t out_frames ;
  frames_t cont_frames___0 ;
  unsigned int __cil_tmp37 ;
  int wrote ;
  unsigned int delay ;
  char const   *__cil_tmp40 ;
  u32_t __cil_tmp41 ;
  long tmp___9 ;
  char const   *__cil_tmp43 ;
  long tmp___10 ;
  frames_t cur_f ;
  u8_t *tmp___11 ;
  frames_t dur_f ;
  u8_t *tmp___12 ;
  char const   *__cil_tmp49 ;
  char const   *__cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  char const   *__cil_tmp52 ;
  char const   *__cil_tmp53 ;
  char const   *__cil_tmp54 ;
  long tmp___13 ;
  s32_t fade_gain ;
  s32_t __cil_tmp57 ;
  s32_t __cil_tmp58 ;
  s32_t __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  s32_t __cil_tmp61 ;
  s32_t __cil_tmp62 ;
  s32_t __cil_tmp63 ;
  char const   *__cil_tmp64 ;
  frames_t tmp___14 ;
  frames_t tmp___15 ;
  int __cil_tmp67 ;
  char const   *__cil_tmp68 ;

  {
#line 50
  flags = output.channels;
#line 52
  cross_gain_in = 0;
#line 52
  cross_gain_out = 0;
#line 52
  cross_ptr = (s32_t *)((void *)0);
#line 54
  if (output.current_replay_gain) {
    {
#line 54
    __cil_tmp10 = gain((s32_t )output.gainL, (s32_t )output.current_replay_gain);
#line 54
    tmp = (unsigned int )__cil_tmp10;
    }
  } else {
#line 54
    tmp = output.gainL;
  }
#line 54
  gainL = (s32_t )tmp;
#line 55
  if (output.current_replay_gain) {
    {
#line 55
    __cil_tmp13 = gain((s32_t )output.gainR, (s32_t )output.current_replay_gain);
#line 55
    tmp___0 = (unsigned int )__cil_tmp13;
    }
  } else {
#line 55
    tmp___0 = output.gainR;
  }
#line 55
  gainR = (s32_t )tmp___0;
#line 57
  if (output.invert) {
#line 57
    gainL = - gainL;
#line 57
    gainR = - gainR;
  }
  {
#line 59
  __cil_tmp15 = _buf_used(outputbuf);
#line 59
  frames = __cil_tmp15 / 8U;
#line 60
  silence = 0;
  }
#line 63
  if ((int )output.state == 1) {
#line 63
    if (frames * 8U > (output.threshold * output.next_sample_rate) / 10U) {
#line 63
      if (frames > output.start_frames) {
#line 64
        output.state = (output_state )2;
#line 65
        if ((unsigned int )loglevel___2 >= 2U) {
          {
#line 65
          __cil_tmp16 = logtime();
#line 65
          logprint("%s %s:%d start buffer frames: %u\n", __cil_tmp16, "_output_frames",
                   65, frames);
          }
        }
        {
#line 66
        wake_controller();
        }
      }
    }
  }
#line 70
  if ((int )output.state == 4) {
#line 71
    if (frames > 0U) {
#line 72
      if (frames < output.skip_frames) {
#line 72
        tmp___1 = frames;
      } else {
#line 72
        tmp___1 = output.skip_frames;
      }
#line 72
      skip = tmp___1;
#line 73
      if ((unsigned int )loglevel___2 >= 2U) {
        {
#line 73
        __cil_tmp19 = logtime();
#line 73
        logprint("%s %s:%d skip %u of %u frames\n", __cil_tmp19, "_output_frames",
                 73, skip, output.skip_frames);
        }
      }
#line 74
      frames -= skip;
#line 75
      output.frames_played += skip;
      {
#line 76
      while (1) {
        while_continue: /* CIL Label */ ;
#line 76
        if (! (skip > 0U)) {
#line 76
          goto while_break;
        }
        {
#line 77
        __cil_tmp21 = _buf_cont_read(outputbuf);
        }
#line 77
        if (skip < __cil_tmp21 / 8U) {
#line 77
          tmp___2 = skip;
        } else {
          {
#line 77
          __cil_tmp22 = _buf_cont_read(outputbuf);
#line 77
          tmp___2 = __cil_tmp22 / 8U;
          }
        }
        {
#line 77
        cont_frames = tmp___2;
#line 78
        skip -= cont_frames;
#line 79
        _buf_inc_readp(outputbuf, cont_frames * 8U);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 82
    output.state = (output_state )2;
  }
#line 86
  if ((int )output.state == 3) {
#line 87
    if ((unsigned int )loglevel___2 >= 2U) {
      {
#line 87
      __cil_tmp24 = logtime();
#line 87
      logprint("%s %s:%d pause %u frames\n", __cil_tmp24, "_output_frames", 87, output.pause_frames);
      }
    }
#line 88
    if (output.pause_frames == 0U) {
#line 89
      output.state = (output_state )2;
    } else {
#line 91
      silence = 1;
#line 92
      if (avail < output.pause_frames) {
#line 92
        tmp___3 = avail;
      } else {
#line 92
        tmp___3 = output.pause_frames;
      }
#line 92
      frames = tmp___3;
#line 93
      if (frames < 2048U) {
#line 93
        tmp___4 = frames;
      } else {
#line 93
        tmp___4 = (unsigned int )2048;
      }
#line 93
      frames = tmp___4;
#line 94
      output.pause_frames -= frames;
    }
  }
#line 99
  if ((int )output.state == 5) {
    {
#line 100
    __cil_tmp28 = gettime_ms();
#line 100
    now = __cil_tmp28;
    }
#line 101
    if (now >= output.start_at) {
#line 102
      output.state = (output_state )2;
    } else
#line 101
    if (output.start_at > now + 10000U) {
#line 102
      output.state = (output_state )2;
    } else {
#line 104
      delta_frames = ((output.start_at - now) * output.current_sample_rate) / 1000U;
#line 105
      silence = 1;
#line 106
      if (avail < delta_frames) {
#line 106
        tmp___5 = avail;
      } else {
#line 106
        tmp___5 = delta_frames;
      }
#line 106
      frames = tmp___5;
#line 107
      if (frames < 2048U) {
#line 107
        tmp___6 = frames;
      } else {
#line 107
        tmp___6 = (unsigned int )2048;
      }
#line 107
      frames = tmp___6;
    }
  }
#line 112
  if ((int )output.state <= 1) {
    _L: /* CIL Label */ 
#line 113
    silence = 1;
#line 114
    if (avail < 2048U) {
#line 114
      tmp___7 = avail;
    } else {
#line 114
      tmp___7 = (unsigned int )2048;
    }
#line 114
    frames = tmp___7;
  } else
#line 112
  if (frames == 0U) {
#line 112
    goto _L;
  }
#line 117
  if ((unsigned int )loglevel___2 >= 4U) {
    {
#line 117
    __cil_tmp33 = logtime();
#line 117
    logprint("%s %s:%d avail: %d frames: %d silence: %d\n", __cil_tmp33, "_output_frames",
             117, avail, frames, silence);
    }
  }
#line 118
  if (frames < avail) {
#line 118
    tmp___8 = frames;
  } else {
#line 118
    tmp___8 = avail;
  }
#line 118
  frames = tmp___8;
#line 119
  size = frames;
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (size > 0U)) {
#line 121
      goto while_break___0;
    }
    {
#line 123
    __cil_tmp37 = _buf_cont_read(outputbuf);
#line 123
    cont_frames___0 = __cil_tmp37 / 8U;
    }
#line 126
    if (output.track_start) {
#line 126
      if (! silence) {
#line 127
        if (output.track_start == outputbuf->readp) {
#line 128
          delay = (unsigned int )0;
#line 129
          if (output.current_sample_rate != output.next_sample_rate) {
#line 130
            delay = output.rate_delay;
          }
#line 140
          frames -= size;
#line 142
          if (delay) {
#line 143
            output.state = (output_state )3;
#line 144
            if (! output.delay_active) {
#line 145
              output.pause_frames = (output.current_sample_rate * delay) / 2000U;
#line 146
              output.delay_active = 1;
#line 147
              goto while_break___0;
            } else {
#line 149
              output.pause_frames = (output.next_sample_rate * delay) / 2000U;
#line 150
              output.delay_active = 0;
            }
          }
#line 153
          if ((unsigned int )loglevel___2 >= 2U) {
            {
#line 153
            __cil_tmp40 = logtime();
#line 153
            logprint("%s %s:%d track start sample rate: %u replay_gain: %u\n", __cil_tmp40,
                     "_output_frames", 153, output.next_sample_rate, output.next_replay_gain);
            }
          }
          {
#line 154
          output.frames_played = (unsigned int )0;
#line 155
          output.track_started = 1;
#line 156
          output.track_start_time = gettime_ms();
#line 157
          output.current_sample_rate = output.next_sample_rate;
          }
#line 161
          if ((unsigned int )output.fade == 0U) {
#line 162
            output.current_replay_gain = output.next_replay_gain;
          } else
#line 161
          if ((unsigned int )output.fade_mode != 1U) {
#line 162
            output.current_replay_gain = output.next_replay_gain;
          }
#line 164
          output.track_start = (u8_t *)((void *)0);
#line 165
          goto while_break___0;
        } else
#line 166
        if (output.track_start > outputbuf->readp) {
#line 168
          if ((output.track_start - outputbuf->readp) / 8L < (long )cont_frames___0) {
#line 168
            tmp___9 = (long )cont_frames___0;
          } else {
#line 168
            tmp___9 = (long )((output.track_start - outputbuf->readp) / 8L);
          }
#line 168
          cont_frames___0 = (frames_t )((int )tmp___9);
        }
      }
    }
#line 178
    if ((unsigned int )output.fade) {
#line 178
      if (! silence) {
#line 179
        if ((unsigned int )output.fade == 1U) {
#line 180
          if (output.fade_start == outputbuf->readp) {
#line 181
            if ((unsigned int )loglevel___2 >= 2U) {
              {
#line 181
              __cil_tmp43 = logtime();
#line 181
              logprint("%s %s:%d fade start reached\n", __cil_tmp43, "_output_frames",
                       181);
              }
            }
#line 182
            output.fade = (fade_state )2;
          } else
#line 183
          if (output.fade_start > outputbuf->readp) {
#line 184
            if ((output.fade_start - outputbuf->readp) / 8L < (long )cont_frames___0) {
#line 184
              tmp___10 = (long )cont_frames___0;
            } else {
#line 184
              tmp___10 = (long )((output.fade_start - outputbuf->readp) / 8L);
            }
#line 184
            cont_frames___0 = (frames_t )((int )tmp___10);
          }
        }
#line 187
        if ((unsigned int )output.fade == 2U) {
#line 189
          if (outputbuf->readp >= output.fade_start) {
#line 189
            tmp___11 = (outputbuf->readp - output.fade_start) / 8L;
          } else {
#line 189
            tmp___11 = ((outputbuf->readp + outputbuf->size) - output.fade_start) / 8L;
          }
#line 189
          cur_f = (frames_t )tmp___11;
#line 191
          if (output.fade_end >= output.fade_start) {
#line 191
            tmp___12 = (output.fade_end - output.fade_start) / 8L;
          } else {
#line 191
            tmp___12 = ((output.fade_end + outputbuf->size) - output.fade_start) / 8L;
          }
#line 191
          dur_f = (frames_t )tmp___12;
#line 193
          if (cur_f >= dur_f) {
#line 194
            if ((unsigned int )output.fade_mode == 4U) {
#line 194
              if ((unsigned int )output.fade_dir == 2U) {
#line 195
                if ((unsigned int )loglevel___2 >= 2U) {
                  {
#line 195
                  __cil_tmp49 = logtime();
#line 195
                  logprint("%s %s:%d fade down complete, starting fade up\n", __cil_tmp49,
                           "_output_frames", 195);
                  }
                }
#line 196
                output.fade_dir = (fade_dir )1;
#line 197
                output.fade_start = outputbuf->readp;
#line 198
                output.fade_end = outputbuf->readp + dur_f * 8U;
#line 199
                if (output.fade_end >= outputbuf->wrap) {
#line 200
                  output.fade_end -= outputbuf->size;
                }
#line 202
                cur_f = (frames_t )0;
              } else {
#line 194
                goto _L___30;
              }
            } else
            _L___30: /* CIL Label */ 
#line 203
            if ((unsigned int )output.fade_mode == 1U) {
#line 204
              if ((unsigned int )loglevel___2 >= 2U) {
                {
#line 204
                __cil_tmp50 = logtime();
#line 204
                logprint("%s %s:%d crossfade complete\n", __cil_tmp50, "_output_frames",
                         204);
                }
              }
              {
#line 205
              __cil_tmp51 = _buf_used(outputbuf);
              }
#line 205
              if (__cil_tmp51 >= dur_f * 8U) {
                {
#line 206
                _buf_inc_readp(outputbuf, dur_f * 8U);
                }
#line 207
                if ((unsigned int )loglevel___2 >= 2U) {
                  {
#line 207
                  __cil_tmp52 = logtime();
#line 207
                  logprint("%s %s:%d skipped crossfaded start\n", __cil_tmp52, "_output_frames",
                           207);
                  }
                }
              } else
#line 209
              if ((unsigned int )loglevel___2 >= 1U) {
                {
#line 209
                __cil_tmp53 = logtime();
#line 209
                logprint("%s %s:%d unable to skip crossfaded start\n", __cil_tmp53,
                         "_output_frames", 209);
                }
              }
#line 211
              output.fade = (fade_state )0;
#line 212
              output.current_replay_gain = output.next_replay_gain;
            } else {
#line 214
              if ((unsigned int )loglevel___2 >= 2U) {
                {
#line 214
                __cil_tmp54 = logtime();
#line 214
                logprint("%s %s:%d fade complete\n", __cil_tmp54, "_output_frames",
                         214);
                }
              }
#line 215
              output.fade = (fade_state )0;
            }
          }
#line 219
          if (output.fade) {
#line 220
            if (output.fade_end > outputbuf->readp) {
#line 221
              if ((output.fade_end - outputbuf->readp) / 8L < (long )cont_frames___0) {
#line 221
                tmp___13 = (long )cont_frames___0;
              } else {
#line 221
                tmp___13 = (long )((output.fade_end - outputbuf->readp) / 8L);
              }
#line 221
              cont_frames___0 = (frames_t )((int )tmp___13);
            }
#line 223
            if ((unsigned int )output.fade_dir == 1U) {
              _L___31: /* CIL Label */ 
#line 226
              if ((unsigned int )output.fade_dir == 2U) {
#line 227
                cur_f = dur_f - cur_f;
              }
              {
#line 229
              fade_gain = to_gain((float )cur_f / (float )dur_f);
#line 230
              gainL = gain(gainL, fade_gain);
#line 231
              gainR = gain(gainR, fade_gain);
              }
#line 232
              if (output.invert) {
#line 232
                gainL = - gainL;
#line 232
                gainR = - gainR;
              }
            } else
#line 223
            if ((unsigned int )output.fade_dir == 2U) {
#line 223
              goto _L___31;
            }
#line 234
            if ((unsigned int )output.fade_dir == 3U) {
              {
#line 237
              __cil_tmp60 = _buf_used(outputbuf);
              }
#line 237
              if (__cil_tmp60 / 8U > dur_f + size) {
                {
#line 238
                cross_gain_in = to_gain((float )cur_f / (float )dur_f);
#line 239
                cross_gain_out = 65536 - cross_gain_in;
                }
#line 240
                if (output.current_replay_gain) {
                  {
#line 241
                  cross_gain_out = gain(cross_gain_out, (s32_t )output.current_replay_gain);
                  }
                }
#line 243
                if (output.next_replay_gain) {
                  {
#line 244
                  cross_gain_in = gain(cross_gain_in, (s32_t )output.next_replay_gain);
                  }
                }
#line 246
                gainL = (s32_t )output.gainL;
#line 247
                gainR = (s32_t )output.gainR;
#line 248
                if (output.invert) {
#line 248
                  gainL = - gainL;
#line 248
                  gainR = - gainR;
                }
#line 249
                cross_ptr = (s32_t *)(output.fade_end + cur_f * 8U);
              } else {
#line 251
                if ((unsigned int )loglevel___2 >= 2U) {
                  {
#line 251
                  __cil_tmp64 = logtime();
#line 251
                  logprint("%s %s:%d unable to continue crossfade - too few samples\n\230",
                           __cil_tmp64, "_output_frames", 251);
                  }
                }
#line 252
                output.fade = (fade_state )0;
              }
            }
          }
        }
      }
    }
#line 259
    if (! silence) {
#line 259
      if (size < cont_frames___0) {
#line 259
        tmp___14 = size;
      } else {
#line 259
        tmp___14 = cont_frames___0;
      }
#line 259
      tmp___15 = tmp___14;
    } else {
#line 259
      tmp___15 = size;
    }
    {
#line 259
    out_frames = tmp___15;
#line 267
    wrote = (*(output.write_cb))(out_frames, silence, gainL, gainR, flags, cross_gain_in,
                                 cross_gain_out, & cross_ptr);
    }
#line 269
    if (wrote <= 0) {
#line 270
      frames -= size;
#line 271
      goto while_break___0;
    } else {
#line 273
      out_frames = (frames_t )wrote;
    }
#line 276
    size -= out_frames;
#line 280
    if (! silence) {
      {
#line 281
      _buf_inc_readp(outputbuf, out_frames * 8U);
#line 282
      output.frames_played += out_frames;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  if ((unsigned int )loglevel___2 >= 4U) {
    {
#line 286
    __cil_tmp68 = logtime();
#line 286
    logprint("%s %s:%d wrote %u frames\n", __cil_tmp68, "_output_frames", 286, frames);
    }
  }
#line 288
  return (frames);
}
}
#line 291 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
void _checkfade(int start ) 
{ 
  frames_t bytes ;
  char const   *__cil_tmp3 ;
  char const   *tmp ;
  unsigned int __cil_tmp5 ;
  unsigned long tmp___0 ;
  char const   *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;
  unsigned int tmp___1 ;
  char const   *__cil_tmp11 ;
  char const   *tmp___2 ;
  unsigned int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  frames_t tmp___3 ;
  frames_t tmp___4 ;
  char const   *__cil_tmp19 ;
  char const   *__cil_tmp20 ;

  {
#line 294
  if ((unsigned int )loglevel___2 >= 2U) {
    {
#line 294
    __cil_tmp3 = logtime();
    }
#line 294
    if (start) {
#line 294
      tmp = "track-start";
    } else {
#line 294
      tmp = "track-end";
    }
    {
#line 294
    logprint("%s %s:%d fade mode: %u duration: %u %s\n", __cil_tmp3, "_checkfade",
             294, (unsigned int )output.fade_mode, output.fade_secs, tmp);
    }
  }
#line 296
  bytes = (output.next_sample_rate * 8U) * output.fade_secs;
#line 297
  if ((unsigned int )output.fade_mode == 4U) {
#line 299
    bytes = ((bytes / 2U) / 8U) * 8U;
  }
  {
#line 302
  __cil_tmp5 = _buf_used(outputbuf);
  }
#line 302
  if (start) {
#line 302
    if ((unsigned int )output.fade_mode == 2U) {
      _L: /* CIL Label */ 
#line 303
      if ((unsigned long )bytes < outputbuf->size - 8UL) {
#line 303
        tmp___0 = (unsigned long )bytes;
      } else {
#line 303
        tmp___0 = outputbuf->size - 8UL;
      }
#line 303
      bytes = (frames_t )tmp___0;
#line 304
      if ((unsigned int )loglevel___2 >= 2U) {
        {
#line 304
        __cil_tmp7 = logtime();
#line 304
        logprint("%s %s:%d fade IN: %u frames\n", __cil_tmp7, "_checkfade", 304, bytes / 8U);
        }
      }
#line 305
      output.fade = (fade_state )1;
#line 306
      output.fade_dir = (fade_dir )1;
#line 307
      output.fade_start = outputbuf->writep;
#line 308
      output.fade_end = output.fade_start + bytes;
#line 309
      if (output.fade_end >= outputbuf->wrap) {
#line 310
        output.fade_end -= outputbuf->size;
      }
    } else
#line 302
    if ((unsigned int )output.fade_mode == 4U) {
#line 302
      if (__cil_tmp5 == 0U) {
#line 302
        goto _L;
      }
    }
  }
#line 314
  if (! start) {
#line 314
    if ((unsigned int )output.fade_mode == 3U) {
      _L___32: /* CIL Label */ 
      {
#line 315
      __cil_tmp8 = _buf_used(outputbuf);
      }
#line 315
      if (__cil_tmp8 < bytes) {
        {
#line 315
        __cil_tmp9 = _buf_used(outputbuf);
#line 315
        tmp___1 = __cil_tmp9;
        }
      } else {
#line 315
        tmp___1 = bytes;
      }
#line 315
      bytes = tmp___1;
#line 316
      if ((unsigned int )loglevel___2 >= 2U) {
        {
#line 316
        __cil_tmp11 = logtime();
        }
#line 316
        if ((unsigned int )output.fade_mode == 4U) {
#line 316
          tmp___2 = "IN-OUT";
        } else {
#line 316
          tmp___2 = "OUTg\301U";
        }
        {
#line 316
        logprint("%s %s:%d fade %s: %u frames\n", __cil_tmp11, "_checkfade", 316,
                 tmp___2, bytes / 8U);
        }
      }
#line 317
      output.fade = (fade_state )1;
#line 318
      output.fade_dir = (fade_dir )2;
#line 319
      output.fade_start = outputbuf->writep - bytes;
#line 320
      if (output.fade_start < outputbuf->buf) {
#line 321
        output.fade_start += outputbuf->size;
      }
#line 323
      output.fade_end = outputbuf->writep;
    } else
#line 314
    if ((unsigned int )output.fade_mode == 4U) {
#line 314
      goto _L___32;
    }
  }
#line 326
  if (start) {
#line 326
    if ((unsigned int )output.fade_mode == 1U) {
      {
#line 327
      __cil_tmp13 = _buf_used(outputbuf);
      }
#line 327
      if (__cil_tmp13 != 0U) {
#line 328
        if (output.next_sample_rate != output.current_sample_rate) {
#line 329
          if ((unsigned int )loglevel___2 >= 2U) {
            {
#line 329
            __cil_tmp14 = logtime();
#line 329
            logprint("%s %s:%d crossfade disabled as sample rates differ\ng\301U",
                     __cil_tmp14, "_checkfade(g\301U", 329);
            }
          }
#line 330
          return;
        }
        {
#line 332
        __cil_tmp15 = _buf_used(outputbuf);
        }
#line 332
        if (bytes < __cil_tmp15) {
#line 332
          tmp___3 = bytes;
        } else {
          {
#line 332
          __cil_tmp16 = _buf_used(outputbuf);
#line 332
          tmp___3 = __cil_tmp16;
          }
        }
#line 332
        bytes = tmp___3;
#line 333
        if (bytes < (frames_t )((double )outputbuf->size * 0.900000000001)) {
#line 333
          tmp___4 = bytes;
        } else {
#line 333
          tmp___4 = (frames_t )((double )outputbuf->size * 0.900000000001);
        }
#line 333
        bytes = tmp___4;
#line 334
        if ((unsigned int )loglevel___2 >= 2U) {
          {
#line 334
          __cil_tmp19 = logtime();
#line 334
          logprint("%s %s:%d CROSSFADE: %u frames\n", __cil_tmp19, "_checkfade", 334,
                   bytes / 8U);
          }
        }
#line 335
        output.fade = (fade_state )1;
#line 336
        output.fade_dir = (fade_dir )3;
#line 337
        output.fade_start = outputbuf->writep - bytes;
#line 338
        if (output.fade_start < outputbuf->buf) {
#line 339
          output.fade_start += outputbuf->size;
        }
#line 341
        output.fade_end = outputbuf->writep;
#line 342
        output.track_start = output.fade_start;
      } else
#line 343
      if (outputbuf->readp == outputbuf->buf) {
#line 343
        if (outputbuf->size == 3528000UL) {
#line 345
          if ((unsigned int )loglevel___2 >= 2U) {
            {
#line 345
            __cil_tmp20 = logtime();
#line 345
            logprint("%s %s:%d resize outputbuf for crossfade\n\230", __cil_tmp20,
                     "_checkfade", 345);
            }
          }
          {
#line 346
          _buf_resize(outputbuf, (size_t )4233600);
#line 348
          touch_memory(outputbuf->buf, outputbuf->size);
          }
        }
      }
    }
  }
  return;
}
}
#line 354 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
void output_init_common(log_level level , char const   *device , unsigned int output_buf_size ,
                        unsigned int rates[] , unsigned int idle ) 
{ 
  unsigned int i ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;
  int tmp ;
  int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  char rates_buf[200] ;
  char s[10] ;
  char const   *__cil_tmp17 ;

  {
#line 357
  loglevel___2 = level;
#line 359
  output_buf_size -= output_buf_size % 8U;
#line 360
  if ((unsigned int )loglevel___2 >= 3U) {
    {
#line 360
    __cil_tmp7 = logtime();
#line 360
    logprint("%s %s:%d outputbuf size: %u\n", __cil_tmp7, "output_init_common(g\301U",
             360, output_buf_size);
    }
  }
  {
#line 362
  buf_init(outputbuf, (size_t )output_buf_size);
  }
#line 363
  if (! outputbuf->buf) {
    {
#line 364
    __cil_tmp8 = logtime();
#line 364
    logprint("%s %s:%d unable to malloc output buffer\n\230", __cil_tmp8, "output_init_common)g\301U",
             364);
#line 365
    exit(0);
    }
  }
  {
#line 368
  silencebuf = (u8_t *)malloc((unsigned long )16384);
  }
#line 369
  if (! silencebuf) {
    {
#line 370
    __cil_tmp10 = logtime();
#line 370
    logprint("%s %s:%d unable to malloc silence buffer\n()g\301U", __cil_tmp10, "output_init_common",
             370);
#line 371
    exit(0);
    }
  }
  {
#line 373
  memset(silencebuf, 0, (unsigned long )16384);
  }
#line 384
  if ((unsigned int )loglevel___2 >= 3U) {
    {
#line 384
    __cil_tmp11 = logtime();
#line 384
    logprint("%s %s:%d idle timeout: %u\n(g\301U", __cil_tmp11, "output_init_common",
             384, idle);
    }
  }
#line 386
  if (idle) {
#line 386
    tmp = -1;
  } else {
#line 386
    tmp = 0;
  }
#line 386
  output.state = (output_state )tmp;
#line 387
  output.device = device;
#line 388
  output.fade = (fade_state )0;
#line 389
  output.invert = 0;
#line 390
  output.error_opening = 0;
#line 391
  output.idle_to = (u32_t )idle;
#line 394
  if ((int )*(output.device + 0) == 45) {
    _L: /* CIL Label */ 
#line 395
    i = (unsigned int )0;
    {
#line 395
    while (1) {
      while_continue: /* CIL Label */ ;
#line 395
      if (! (i < 20U)) {
#line 395
        goto while_break;
      }
#line 396
      output.supported_rates[i] = rates[i];
#line 395
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 394
  if (user_rates) {
#line 394
    goto _L;
  } else {
    {
#line 400
    __cil_tmp13 = test_open(output.device, (unsigned int *)output.supported_rates,
                            user_rates);
    }
#line 400
    if (! __cil_tmp13) {
      {
#line 401
      __cil_tmp14 = logtime();
#line 401
      logprint("%s %s:%d unable to open output device: %s\n", __cil_tmp14, "output_init_common\357f\301U",
               401, output.device);
#line 402
      exit(0);
      }
    }
  }
#line 407
  i = (unsigned int )0;
  {
#line 407
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 407
    if (! (i < 20U)) {
#line 407
      goto while_break___0;
    }
#line 408
    if (output.supported_rates[i] == 44100U) {
#line 409
      output.default_sample_rate = (unsigned int )44100;
#line 410
      goto while_break___0;
    }
#line 407
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 413
  if (! output.default_sample_rate) {
#line 414
    output.default_sample_rate = output.supported_rates[0];
  }
#line 417
  output.current_sample_rate = output.default_sample_rate;
#line 419
  if ((unsigned int )loglevel___2 >= 2U) {
#line 420
    rates_buf = "\f";
#line 421
    i = (unsigned int )0;
    {
#line 421
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 421
      if (! output.supported_rates[i]) {
#line 421
        goto while_break___1;
      }
      {
#line 423
      sprintf((char *)s, "%d ", output.supported_rates[i]);
#line 424
      strcat((char *)rates_buf, (char const   *)((char *)s));
      }
#line 421
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 426
    if ((unsigned int )loglevel___2 >= 2U) {
      {
#line 426
      __cil_tmp17 = logtime();
#line 426
      logprint("%s %s:%d supported rates: %s\nU", __cil_tmp17, "output_init_common",
               426, (char *)rates_buf);
      }
    }
  }
  return;
}
}
#line 430 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
void output_close_common(void) 
{ 


  {
  {
#line 431
  buf_destroy(outputbuf);
#line 432
  free(silencebuf);
  }
  return;
}
}
#line 438 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/output.c"
void output_flush(void) 
{ 
  char const   *__cil_tmp1 ;
  u32_t __cil_tmp2 ;

  {
#line 439
  if ((unsigned int )loglevel___2 >= 2U) {
    {
#line 439
    __cil_tmp1 = logtime();
#line 439
    logprint("%s %s:%d flush output buffer\n", __cil_tmp1, "output_flush\301U", 439);
    }
  }
  {
#line 440
  buf_flush(outputbuf);
#line 441
  pthread_mutex_lock(& outputbuf->mutex);
#line 442
  output.fade = (fade_state )0;
  }
#line 443
  if ((int )output.state != -1) {
    {
#line 444
    output.state = (output_state )0;
#line 445
    output.stop_time = gettime_ms();
    }
#line 446
    if (output.error_opening) {
#line 447
      output.current_sample_rate = output.default_sample_rate;
    }
#line 449
    output.delay_active = 0;
  }
  {
#line 451
  output.frames_played = (unsigned int )0;
#line 452
  pthread_mutex_unlock(& outputbuf->mutex);
  }
  return;
}
}
#line 42 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int if_nametoindex(char const   *__ifname ) ;
#line 194
extern  __attribute__((__nothrow__)) char *if_indextoname(unsigned int __ifindex ,
                                                          char __ifname[16] ) ;
#line 199
extern  __attribute__((__nothrow__)) struct if_nameindex *if_nameindex(void) ;
#line 202
extern  __attribute__((__nothrow__)) void if_freenameindex(struct if_nameindex *__ptr ) ;
#line 53 "/usr/include/rpc/netdb.h"
extern  __attribute__((__nothrow__)) void setrpcent(int __stayopen ) ;
#line 54
extern  __attribute__((__nothrow__)) void endrpcent(void) ;
#line 55
extern  __attribute__((__nothrow__)) struct rpcent *getrpcbyname(char const   *__name ) ;
#line 56
extern  __attribute__((__nothrow__)) struct rpcent *getrpcbynumber(int __number ) ;
#line 57
extern  __attribute__((__nothrow__)) struct rpcent *getrpcent(void) ;
#line 60
extern  __attribute__((__nothrow__)) int getrpcbyname_r(char const   *__name , struct rpcent *__result_buf ,
                                                        char *__buffer , size_t __buflen ,
                                                        struct rpcent **__result ) ;
#line 64
extern  __attribute__((__nothrow__)) int getrpcbynumber_r(int __number , struct rpcent *__result_buf ,
                                                          char *__buffer , size_t __buflen ,
                                                          struct rpcent **__result ) ;
#line 68
extern  __attribute__((__nothrow__)) int getrpcent_r(struct rpcent *__result_buf ,
                                                     char *__buffer , size_t __buflen ,
                                                     struct rpcent **__result ) ;
#line 59 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void) ;
#line 90
extern  __attribute__((__nothrow__)) void herror(char const   *__str ) ;
#line 93
extern  __attribute__((__nothrow__)) char const   *hstrerror(int __err_num ) ;
#line 115
extern void sethostent(int __stay_open ) ;
#line 121
extern void endhostent(void) ;
#line 128
extern struct hostent *gethostent(void) ;
#line 135
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 142
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 153
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 165
extern int gethostent_r(struct hostent *__result_buf , char *__buf , size_t __buflen ,
                        struct hostent **__result , int *__h_errnop ) ;
#line 170
extern int gethostbyaddr_r(void const   *__addr , __socklen_t __len , int __type ,
                           struct hostent *__result_buf , char *__buf , size_t __buflen ,
                           struct hostent **__result , int *__h_errnop ) ;
#line 177
extern int gethostbyname_r(char const   *__name , struct hostent *__result_buf , char *__buf ,
                           size_t __buflen , struct hostent **__result , int *__h_errnop ) ;
#line 183
extern int gethostbyname2_r(char const   *__name , int __af , struct hostent *__result_buf ,
                            char *__buf , size_t __buflen , struct hostent **__result ,
                            int *__h_errnop ) ;
#line 196
extern void setnetent(int __stay_open ) ;
#line 202
extern void endnetent(void) ;
#line 209
extern struct netent *getnetent(void) ;
#line 216
extern struct netent *getnetbyaddr(uint32_t __net , int __type ) ;
#line 222
extern struct netent *getnetbyname(char const   *__name ) ;
#line 235
extern int getnetent_r(struct netent *__result_buf , char *__buf , size_t __buflen ,
                       struct netent **__result , int *__h_errnop ) ;
#line 240
extern int getnetbyaddr_r(uint32_t __net , int __type , struct netent *__result_buf ,
                          char *__buf , size_t __buflen , struct netent **__result ,
                          int *__h_errnop ) ;
#line 246
extern int getnetbyname_r(char const   *__name , struct netent *__result_buf , char *__buf ,
                          size_t __buflen , struct netent **__result , int *__h_errnop ) ;
#line 268
extern void setservent(int __stay_open ) ;
#line 274
extern void endservent(void) ;
#line 281
extern struct servent *getservent(void) ;
#line 288
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 295
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 306
extern int getservent_r(struct servent *__result_buf , char *__buf , size_t __buflen ,
                        struct servent **__result ) ;
#line 310
extern int getservbyname_r(char const   *__name , char const   *__proto , struct servent *__result_buf ,
                           char *__buf , size_t __buflen , struct servent **__result ) ;
#line 316
extern int getservbyport_r(int __port , char const   *__proto , struct servent *__result_buf ,
                           char *__buf , size_t __buflen , struct servent **__result ) ;
#line 336
extern void setprotoent(int __stay_open ) ;
#line 342
extern void endprotoent(void) ;
#line 349
extern struct protoent *getprotoent(void) ;
#line 355
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 361
extern struct protoent *getprotobynumber(int __proto ) ;
#line 372
extern int getprotoent_r(struct protoent *__result_buf , char *__buf , size_t __buflen ,
                         struct protoent **__result ) ;
#line 376
extern int getprotobyname_r(char const   *__name , struct protoent *__result_buf ,
                            char *__buf , size_t __buflen , struct protoent **__result ) ;
#line 381
extern int getprotobynumber_r(int __proto , struct protoent *__result_buf , char *__buf ,
                              size_t __buflen , struct protoent **__result ) ;
#line 393
extern int setnetgrent(char const   *__netgroup ) ;
#line 401
extern void endnetgrent(void) ;
#line 410
extern int getnetgrent(char **__hostp , char **__userp , char **__domainp ) ;
#line 421
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *__domain ) ;
#line 430
extern int getnetgrent_r(char **__hostp , char **__userp , char **__domainp , char *__buffer ,
                         size_t __buflen ) ;
#line 449
extern int rcmd(char **__ahost , unsigned short __rport , char const   *__locuser ,
                char const   *__remuser , char const   *__cmd , int *__fd2p ) ;
#line 461
extern int rcmd_af(char **__ahost , unsigned short __rport , char const   *__locuser ,
                   char const   *__remuser , char const   *__cmd , int *__fd2p , sa_family_t __af ) ;
#line 477
extern int rexec(char **__ahost , int __rport , char const   *__name , char const   *__pass ,
                 char const   *__cmd , int *__fd2p ) ;
#line 489
extern int rexec_af(char **__ahost , int __rport , char const   *__name , char const   *__pass ,
                    char const   *__cmd , int *__fd2p , sa_family_t __af ) ;
#line 503
extern int ruserok(char const   *__rhost , int __suser , char const   *__remuser ,
                   char const   *__locuser ) ;
#line 513
extern int ruserok_af(char const   *__rhost , int __suser , char const   *__remuser ,
                      char const   *__locuser , sa_family_t __af ) ;
#line 526
extern int iruserok(uint32_t __raddr , int __suser , char const   *__remuser , char const   *__locuser ) ;
#line 537
extern int iruserok_af(void const   *__raddr , int __suser , char const   *__remuser ,
                       char const   *__locuser , sa_family_t __af ) ;
#line 549
extern int rresvport(int *__alport ) ;
#line 558
extern int rresvport_af(int *__alport , sa_family_t __af ) ;
#line 660
extern int getaddrinfo(char const   *__name , char const   *__service , struct addrinfo *__req ,
                       struct addrinfo **__pai ) ;
#line 666
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 669
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 675
extern int getnameinfo(struct sockaddr *__sa , socklen_t __salen , char *__host ,
                       socklen_t __hostlen , char *__serv , socklen_t __servlen ,
                       int __flags ) ;
#line 62 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
char const   *logtime(void) 
{ 
  static char buf___2[100] ;
  struct timeval tv ;
  struct tm *__cil_tmp3 ;
  unsigned long __cil_tmp4 ;

  {
  {
#line 70
  gettimeofday(& tv, (void *)0);
#line 71
  __cil_tmp3 = localtime(& tv.tv_sec);
#line 71
  strftime((char *)buf___2, sizeof(buf___2), "[%T.", __cil_tmp3);
#line 72
  __cil_tmp4 = strlen((char const   *)((char *)buf___2));
#line 72
  sprintf((char *)buf___2 + __cil_tmp4, "%06ld]", (long )tv.tv_usec);
  }
#line 74
  return ((char const   *)((char *)buf___2));
}
}
#line 77 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void logprint(char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 79
  __builtin_va_start((void *)args, fmt);
#line 80
  vfprintf(stderr, fmt, (void *)args);
#line 81
  __builtin_va_end((void *)args);
#line 82
  fflush(stderr);
  }
  return;
}
}
#line 86 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
char *next_param(char *src , char c ) 
{ 
  static char *str ;
  char *ptr ;
  char *ret ;
  char *__cil_tmp6 ;
  char *tmp ;

  {
#line 87
  str = (char *)((void *)0);
#line 89
  if (src) {
#line 89
    str = src;
  }
  {
#line 90
  ptr = strchr((char const   *)str, (int )c);
  }
#line 90
  if (str) {
#line 90
    if (ptr) {
#line 91
      ret = str;
#line 92
      *ptr = (char )'\000';
#line 93
      str = ptr + 1;
    } else {
#line 95
      ret = str;
#line 96
      str = (char *)((void *)0);
    }
  } else {
#line 95
    ret = str;
#line 96
    str = (char *)((void *)0);
  }
#line 99
  if (ret && (int )*(ret + 0)) {
#line 99
    tmp = ret;
  } else {
#line 99
    tmp = (char *)((void *)0);
  }
#line 99
  return (tmp);
}
}
#line 103 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
u32_t gettime_ms(void) 
{ 
  struct timespec ts ;
  int __cil_tmp2 ;
  struct timeval tv ;

  {
  {
#line 110
  __cil_tmp2 = clock_gettime(1, & ts);
  }
#line 110
  if (! __cil_tmp2) {
#line 114
    return ((u32_t )(ts.tv_sec * 1000L + ts.tv_nsec / 1000000L));
  }
  {
#line 118
  gettimeofday(& tv, (void *)0);
  }
#line 119
  return ((u32_t )(tv.tv_sec * 1000L + tv.tv_usec / 1000L));
}
}
#line 126 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void get_mac(u8_t mac[] ) 
{ 
  char *utmac ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  struct ifreq *ifend ;
  struct ifreq ifreq ;
  struct ifreq ifs[4] ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int s ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  struct ifreq *__cil_tmp15 ;

  {
  {
#line 133
  utmac = getenv("UTMAC");
  }
#line 134
  if (utmac) {
    {
#line 136
    __cil_tmp9 = strlen((char const   *)utmac);
    }
#line 136
    if (__cil_tmp9 == 17UL) {
      {
#line 138
      __cil_tmp10 = sscanf((char const   *)utmac, "%2hhx:%2hhx:%2hhx:%2hhx:%2hhx:%2hhx",
                           & mac[0], & mac[1], & mac[2], & mac[3], & mac[4], & mac[5]);
      }
#line 138
      if (__cil_tmp10 == 6) {
#line 141
        return;
      }
    }
  }
  {
#line 147
  mac[5] = (u8_t )0;
#line 147
  mac[4] = mac[5];
#line 147
  mac[3] = mac[4];
#line 147
  mac[2] = mac[3];
#line 147
  mac[1] = mac[2];
#line 147
  mac[0] = mac[1];
#line 149
  __cil_tmp12 = socket(2, 2, 0);
#line 149
  s = __cil_tmp12;
#line 151
  ifc.ifc_len = (int )sizeof(ifs);
#line 152
  ifc.ifc_ifcu.ifcu_req = (struct ifreq *)ifs;
#line 154
  __cil_tmp13 = ioctl(s, (unsigned long )35090, & ifc);
  }
#line 154
  if (__cil_tmp13 == 0) {
#line 155
    ifend = (struct ifreq *)ifs + (unsigned long )ifc.ifc_len / sizeof(struct ifreq );
#line 157
    ifr = ifc.ifc_ifcu.ifcu_req;
    {
#line 157
    while (1) {
      while_continue: /* CIL Label */ ;
#line 157
      if (! (ifr < ifend)) {
#line 157
        goto while_break;
      }
#line 158
      if ((int )ifr->ifr_ifru.ifru_addr.sa_family == 2) {
        {
#line 160
        strncpy((char *)ifreq.ifr_ifrn.ifrn_name, (char const   *)((char *)ifr->ifr_ifrn.ifrn_name),
                sizeof(ifreq.ifr_ifrn.ifrn_name) - 1UL);
#line 161
        __cil_tmp14 = ioctl(s, (unsigned long )35111, & ifreq);
        }
#line 161
        if (__cil_tmp14 == 0) {
          {
#line 162
          memcpy(mac, (char *)ifreq.ifr_ifru.ifru_hwaddr.sa_data, (unsigned long )6);
          }
#line 163
          if (((int )mac[0] + (int )mac[1]) + (int )mac[2] != 0) {
#line 164
            goto while_break;
          }
        }
      }
#line 157
      ifr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 171
  close(s);
  }
  return;
}
}
#line 280 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void set_nonblock(sockfd s ) 
{ 
  int flags ;
  int __cil_tmp3 ;

  {
  {
#line 285
  __cil_tmp3 = fcntl(s, 3, 0);
#line 285
  flags = __cil_tmp3;
#line 286
  fcntl(s, 4, flags | 2048);
  }
  return;
}
}
#line 291 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
int connect_timeout(sockfd sock___0 , struct sockaddr *addr___0 , socklen_t addrlen ,
                    int timeout ) 
{ 
  fd_set w ;
  fd_set e ;
  struct timeval tval ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  unsigned int __i ;
  fd_set *__arr ;
  struct timeval *tmp ;
  int __cil_tmp13 ;
  int error ;
  socklen_t len ;

  {
  {
#line 295
  __cil_tmp8 = connect(sock___0, addr___0, addrlen);
  }
#line 295
  if (__cil_tmp8 < 0) {
    {
#line 297
    __cil_tmp9 = __errno_location();
    }
#line 297
    if (*__cil_tmp9 != 115) {
#line 301
      return (- 1);
    }
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    __arr = & w;
#line 305
    __i = (unsigned int )0;
    {
#line 305
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 305
      if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 305
        goto while_break___0;
      }
#line 305
      __arr->__fds_bits[__i] = (__fd_mask )0;
#line 305
      __i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 305
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  w.__fds_bits[0] |= (__fd_mask )(1UL << sock___0 % (8 * (int )sizeof(__fd_mask )));
#line 307
  e = w;
#line 308
  tval.tv_sec = (__time_t )timeout;
#line 309
  tval.tv_usec = (__suseconds_t )0;
#line 312
  if (timeout) {
#line 312
    tmp = & tval;
  } else {
#line 312
    tmp = (struct timeval *)((void *)0);
  }
  {
#line 312
  __cil_tmp13 = select(sock___0 + 1, (fd_set *)((void *)0), & w, & e, tmp);
  }
#line 312
  if (__cil_tmp13 == 1) {
#line 312
    if ((w.__fds_bits[0] & (__fd_mask )(1UL << sock___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 313
      error = 0;
#line 314
      len = (socklen_t )sizeof(error);
#line 315
      getsockopt(sock___0, 1, 4, (void *)(& error), & len);
      }
#line 316
      return (error);
    }
  }
#line 319
  return (- 1);
}
}
#line 322 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void server_addr(char *server , in_addr_t *ip_ptr , unsigned int *port_ptr ) 
{ 
  struct addrinfo *res ;
  struct addrinfo hints ;
  char const   *port ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 323
  res = (struct addrinfo *)((void *)0);
#line 325
  port = (char const   *)((void *)0);
#line 327
  __cil_tmp7 = strtok(server, ":XIg\301U");
  }
#line 327
  if (__cil_tmp7) {
    {
#line 328
    __cil_tmp8 = strtok((char *)((void *)0), ":gIg\301U");
#line 328
    port = (char const   *)__cil_tmp8;
    }
#line 329
    if (port) {
      {
#line 330
      __cil_tmp9 = atoi(port);
#line 330
      *port_ptr = (unsigned int )__cil_tmp9;
      }
    }
  }
  {
#line 334
  memset(& hints, 0, sizeof(struct addrinfo ));
#line 335
  hints.ai_family = 2;
#line 337
  getaddrinfo((char const   *)server, (char const   *)((void *)0), & hints, & res);
  }
#line 339
  if (res) {
#line 339
    if (res->ai_addr) {
#line 340
      *ip_ptr = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    }
  }
#line 343
  if (res) {
    {
#line 344
    freeaddrinfo(res);
    }
  }
  return;
}
}
#line 348 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void set_readwake_handles(struct pollfd handles[] , sockfd s , int e ) 
{ 


  {
#line 359
  handles[0].fd = s;
#line 360
  handles[1].fd = e;
#line 361
  handles[0].events = (short )1;
#line 362
  handles[1].events = (short )1;
  return;
}
}
#line 366 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
event_type wait_readwake(struct pollfd handles[] , int timeout ) 
{ 
  int __cil_tmp3 ;
  eventfd_t val ;

  {
  {
#line 378
  __cil_tmp3 = poll(handles, (nfds_t )2, timeout);
  }
#line 378
  if (__cil_tmp3 > 0) {
#line 379
    if (handles[0].revents) {
#line 380
      return ((event_type )1);
    }
#line 382
    if (handles[1].revents) {
      {
#line 383
      eventfd_read(handles[1].fd, & val);
      }
#line 384
      return ((event_type )2);
    }
  }
#line 387
  return ((event_type )0);
}
}
#line 392 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void packN(u32_t *dest , u32_t val ) 
{ 
  u8_t *ptr ;

  {
#line 393
  ptr = (u8_t *)dest;
#line 394
  *ptr = (u8_t )((val >> 24) & 255U);
#line 394
  *(ptr + 1) = (u8_t )((val >> 16) & 255U);
#line 394
  *(ptr + 2) = (u8_t )((val >> 8) & 255U);
#line 394
  *(ptr + 3) = (u8_t )(val & 255U);
  return;
}
}
#line 397 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void packn(u16_t *dest , u16_t val ) 
{ 
  u8_t *ptr ;

  {
#line 398
  ptr = (u8_t *)dest;
#line 399
  *ptr = (u8_t )(((int )val >> 8) & 255);
#line 399
  *(ptr + 1) = (u8_t )((int )val & 255);
  return;
}
}
#line 402 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
u32_t unpackN(u32_t *src ) 
{ 
  u8_t *ptr ;

  {
#line 403
  ptr = (u8_t *)src;
#line 404
  return ((u32_t )(((((int )*ptr << 24) | ((int )*(ptr + 1) << 16)) | ((int )*(ptr + 2) << 8)) | (int )*(ptr + 3)));
}
}
#line 407 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
u16_t unpackn(u16_t *src ) 
{ 
  u8_t *ptr ;

  {
#line 408
  ptr = (u8_t *)src;
#line 409
  return ((u16_t )(((int )*ptr << 8) | (int )*(ptr + 1)));
}
}
#line 484 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/utils.c"
void touch_memory(u8_t *buf___2 , size_t size ) 
{ 
  u8_t *ptr ;
  long __cil_tmp4 ;

  {
#line 486
  ptr = buf___2;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! (ptr < buf___2 + size)) {
#line 486
      goto while_break;
    }
#line 487
    *ptr = (u8_t )0;
    {
#line 486
    __cil_tmp4 = sysconf(30);
    }
#line 486
    ptr += __cil_tmp4;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int renameat2(int __oldfd , char const   *__old ,
                                                   int __newfd , char const   *__new ,
                                                   unsigned int __flags ) ;
#line 200
extern FILE *tmpfile64(void) ;
#line 249
extern int fcloseall(void) ;
#line 283
extern FILE *fopen64(char const   *__filename , char const   *__modes ) ;
#line 286
extern FILE *freopen64(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 300
extern  __attribute__((__nothrow__)) FILE *fopencookie(void *__magic_cookie , char const   *__modes ,
                                                       cookie_io_functions_t __io_funcs ) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 393
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 396
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 615
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 691
extern int fputs_unlocked(char const   *__s , FILE *__stream ) ;
#line 779
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 780
extern __off64_t ftello64(FILE *__stream ) ;
#line 781
extern int fgetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 782
extern int fsetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 844
extern char *cuserid(char *__s ) ;
#line 853
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 856
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 166 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 169
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 172
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 176
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 184
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 186
  __cil_tmp3 = __builtin_va_arg_pack();
#line 186
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 186
  return (__cil_tmp4);
}
}
#line 199
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_va_arg_pack();
#line 202
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 202
  return (__cil_tmp4);
}
}
#line 215
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 215 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 218
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 218
  return (__cil_tmp4);
}
}
#line 222
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 222 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 225
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 225
  return (__cil_tmp4);
}
}
#line 300
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 307
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 314
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 316
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 316
  sz = __cil_tmp5;
#line 317
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 317
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 317
  if (__cil_tmp6) {
#line 317
    if (__n > 0) {
#line 317
      if (__cil_tmp7) {
#line 317
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 318
          __cil_tmp8 = __fgets_unlocked_alias(__s, __n, __stream);
          }
#line 318
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 319
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 319
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 319
  if (__cil_tmp9) {
#line 319
    if (__n > 0) {
#line 319
      if (__cil_tmp10) {
#line 319
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 320
          __cil_tmp11 = __fgets_unlocked_chk_warn(__s, sz, __n, __stream);
          }
#line 320
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 321
  __cil_tmp12 = __fgets_unlocked_chk(__s, sz, __n, __stream);
  }
#line 321
  return (__cil_tmp12);
}
}
#line 141 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int strtof32(char const   *__nptr , char **__endptr ) ;
#line 147
extern  __attribute__((__nothrow__)) int strtof64(char const   *__nptr , char **__endptr ) ;
#line 153
extern  __attribute__((__nothrow__)) int strtof128(char const   *__nptr , char **__endptr ) ;
#line 159
extern  __attribute__((__nothrow__)) int strtof32x(char const   *__nptr , char **__endptr ) ;
#line 165
extern  __attribute__((__nothrow__)) int strtof64x(char const   *__nptr , char **__endptr ) ;
#line 213
extern  __attribute__((__nothrow__)) int strfromd(char *__dest , size_t __size , char const   *__format ,
                                                  double __f ) ;
#line 217
extern  __attribute__((__nothrow__)) int strfromf(char *__dest , size_t __size , char const   *__format ,
                                                  float __f ) ;
#line 221
extern  __attribute__((__nothrow__)) int strfroml(char *__dest , size_t __size , char const   *__format ,
                                                  long double __f ) ;
#line 233
extern  __attribute__((__nothrow__)) int strfromf32(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 239
extern  __attribute__((__nothrow__)) int strfromf64(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 245
extern  __attribute__((__nothrow__)) int strfromf128(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 251
extern  __attribute__((__nothrow__)) int strfromf32x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 257
extern  __attribute__((__nothrow__)) int strfromf64x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 275
extern  __attribute__((__nothrow__)) long strtol_l(char const   *__nptr , char **__endptr ,
                                                   int __base , locale_t __loc ) ;
#line 279
extern  __attribute__((__nothrow__)) unsigned long strtoul_l(char const   *__nptr ,
                                                             char **__endptr , int __base ,
                                                             locale_t __loc ) ;
#line 285
extern  __attribute__((__nothrow__)) long long strtoll_l(char const   *__nptr , char **__endptr ,
                                                         int __base , locale_t __loc ) ;
#line 291
extern  __attribute__((__nothrow__)) unsigned long long strtoull_l(char const   *__nptr ,
                                                                   char **__endptr ,
                                                                   int __base , locale_t __loc ) ;
#line 296
extern  __attribute__((__nothrow__)) double strtod_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 300
extern  __attribute__((__nothrow__)) float strtof_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 304
extern  __attribute__((__nothrow__)) long double strtold_l(char const   *__nptr ,
                                                           char **__endptr , locale_t __loc ) ;
#line 317
extern  __attribute__((__nothrow__)) int strtof32_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 324
extern  __attribute__((__nothrow__)) int strtof64_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 331
extern  __attribute__((__nothrow__)) int strtof128_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 338
extern  __attribute__((__nothrow__)) int strtof32x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 345
extern  __attribute__((__nothrow__)) int strtof64x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 646
extern  __attribute__((__nothrow__)) char *secure_getenv(char const   *__name ) ;
#line 705
extern int mkstemp64(char *__template ) ;
#line 727
extern int mkstemps64(char *__template , int __suffixlen ) ;
#line 749
extern int mkostemp(char *__template , int __flags ) ;
#line 759
extern int mkostemp64(char *__template , int __flags ) ;
#line 769
extern int mkostemps(char *__template , int __suffixlen , int __flags ) ;
#line 781
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) ;
#line 797
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name ) ;
#line 841
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar ,
                    void *__arg ) ;
#line 978
extern int posix_openpt(int __oflag ) ;
#line 986
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 990
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 1006
extern int getpt(void) ;
#line 120 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *rawmemchr(void const   *__s , int __c ) ;
#line 133
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n ) ;
#line 286
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c ) ;
#line 380
extern  __attribute__((__nothrow__)) char *strcasestr(char const   *__haystack , char const   *__needle ) ;
#line 389
extern  __attribute__((__nothrow__)) void *memmem(void const   *__haystack , size_t __haystacklen ,
                                                  void const   *__needle , size_t __needlelen ) ;
#line 397
extern  __attribute__((__nothrow__)) void *__mempcpy(void *__dest , void const   *__src ,
                                                     size_t __n ) ;
#line 400
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 450
extern  __attribute__((__nothrow__)) char const   *strerrordesc_np(int __err ) ;
#line 452
extern  __attribute__((__nothrow__)) char const   *strerrorname_np(int __err ) ;
#line 482
extern  __attribute__((__nothrow__)) char const   *sigabbrev_np(int __sig ) ;
#line 485
extern  __attribute__((__nothrow__)) char const   *sigdescr_np(int __sig ) ;
#line 506
extern  __attribute__((__nothrow__)) int strverscmp(char const   *__s1 , char const   *__s2 ) ;
#line 510
extern  __attribute__((__nothrow__)) char *strfry(char *__string ) ;
#line 513
extern  __attribute__((__nothrow__)) void *memfrob(void *__s , size_t __n ) ;
#line 527
extern  __attribute__((__nothrow__)) char *basename(char const   *__filename ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 45
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 45
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 45
  return (__cil_tmp5);
}
}
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h"
extern  __attribute__((__nothrow__)) long __sysconf(int __name ) ;
#line 292 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type ) ;
#line 296
extern  __attribute__((__nothrow__)) int eaccess(char const   *__name , int __type ) ;
#line 300
extern  __attribute__((__nothrow__)) int execveat(int __fd , char const   *__path ,
                                                  char * const  __argv[] , char * const  __envp[] ,
                                                  int __flags ) ;
#line 350
extern  __attribute__((__nothrow__)) __off64_t lseek64(int __fd , __off64_t __offset ,
                                                       int __whence ) ;
#line 422
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 427
extern ssize_t pwrite64(int __fd , void const   *__buf , size_t __n , __off64_t __offset ) ;
#line 442
extern  __attribute__((__nothrow__)) int pipe2(int __pipedes[2] , int __flags ) ;
#line 537
extern  __attribute__((__nothrow__)) char *get_current_dir_name(void) ;
#line 560
extern  __attribute__((__nothrow__)) int dup3(int __fd , int __fd2 , int __flags ) ;
#line 566
extern char **environ ;
#line 611
extern  __attribute__((__nothrow__)) int execvpe(char const   *__file , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 715
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 755
extern  __attribute__((__nothrow__)) int getresuid(__uid_t *__ruid , __uid_t *__euid ,
                                                   __uid_t *__suid ) ;
#line 760
extern  __attribute__((__nothrow__)) int getresgid(__gid_t *__rgid , __gid_t *__egid ,
                                                   __gid_t *__sgid ) ;
#line 765
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 770
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 793
extern  __attribute__((__nothrow__)) __pid_t _Fork(void) ;
#line 995
extern  __attribute__((__nothrow__)) int syncfs(int __fd ) ;
#line 1038
extern  __attribute__((__nothrow__)) int truncate64(char const   *__file , __off64_t __length ) ;
#line 1059
extern  __attribute__((__nothrow__)) int ftruncate64(int __fd , __off64_t __length ) ;
#line 1124
extern int lockf64(int __fd , int __cmd , __off64_t __len ) ;
#line 1142
ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                        size_t __length , unsigned int __flags ) ;
#line 1168
extern  __attribute__((__nothrow__)) void swab(void const   *__from , void *__to ,
                                               ssize_t __n ) ;
#line 1208
extern  __attribute__((__nothrow__)) int close_range(unsigned int __fd , unsigned int __max_fd ,
                                                     int __flags ) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 92
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 92
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 92
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 92
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 92
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 92
    __cil_tmp9 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 92
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 92
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 92
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 92
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 92
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 92
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 92
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp15 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 92
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 92
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp17 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 92
      tmp = __cil_tmp17;
      }
    }
#line 92
    tmp___0 = tmp;
  }
#line 92
  return (tmp___0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern  __attribute__((__nothrow__)) __pid_t gettid(void) ;
#line 195 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int sendmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags ) ;
#line 235
extern int recvmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags , struct timespec *__tmo ) ;
#line 314
extern int accept4(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len , int __flags ) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__buf, 0);
#line 64
  sz = __cil_tmp8;
#line 65
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 65
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 65
  if (__cil_tmp10) {
#line 65
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 66
      __cil_tmp11 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
      }
#line 66
      return (__cil_tmp11);
    }
  }
  {
#line 67
  __cil_tmp13 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 67
  __cil_tmp12 = __builtin_constant_p(__n);
  }
#line 67
  if (__cil_tmp13) {
#line 67
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 68
      __cil_tmp14 = __recvfrom_chk_warn(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
      }
#line 68
      return (__cil_tmp14);
    }
  }
  {
#line 70
  __cil_tmp15 = __recvfrom_chk(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
  }
#line 70
  return (__cil_tmp15);
}
}
#line 559 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) int inet6_option_space(int __nbytes ) ;
#line 561
extern  __attribute__((__nothrow__)) int inet6_option_init(void *__bp , struct cmsghdr **__cmsgp ,
                                                           int __type ) ;
#line 563
extern  __attribute__((__nothrow__)) int inet6_option_append(struct cmsghdr *__cmsg ,
                                                             uint8_t *__typep , int __multx ,
                                                             int __plusy ) ;
#line 566
extern  __attribute__((__nothrow__)) uint8_t *inet6_option_alloc(struct cmsghdr *__cmsg ,
                                                                 int __datalen , int __multx ,
                                                                 int __plusy ) ;
#line 569
extern  __attribute__((__nothrow__)) int inet6_option_next(struct cmsghdr *__cmsg ,
                                                           uint8_t **__tptrp ) ;
#line 572
extern  __attribute__((__nothrow__)) int inet6_option_find(struct cmsghdr *__cmsg ,
                                                           uint8_t **__tptrp , int __type ) ;
#line 578
extern  __attribute__((__nothrow__)) int inet6_opt_init(void *__extbuf , socklen_t __extlen ) ;
#line 579
extern  __attribute__((__nothrow__)) int inet6_opt_append(void *__extbuf , socklen_t __extlen ,
                                                          int __offset , uint8_t __type ,
                                                          socklen_t __len , uint8_t __align ,
                                                          void **__databufp ) ;
#line 582
extern  __attribute__((__nothrow__)) int inet6_opt_finish(void *__extbuf , socklen_t __extlen ,
                                                          int __offset ) ;
#line 584
extern  __attribute__((__nothrow__)) int inet6_opt_set_val(void *__databuf , int __offset ,
                                                           void *__val , socklen_t __vallen ) ;
#line 586
extern  __attribute__((__nothrow__)) int inet6_opt_next(void *__extbuf , socklen_t __extlen ,
                                                        int __offset , uint8_t *__typep ,
                                                        socklen_t *__lenp , void **__databufp ) ;
#line 589
extern  __attribute__((__nothrow__)) int inet6_opt_find(void *__extbuf , socklen_t __extlen ,
                                                        int __offset , uint8_t __type ,
                                                        socklen_t *__lenp , void **__databufp ) ;
#line 592
extern  __attribute__((__nothrow__)) int inet6_opt_get_val(void *__databuf , int __offset ,
                                                           void *__val , socklen_t __vallen ) ;
#line 597
extern  __attribute__((__nothrow__)) socklen_t inet6_rth_space(int __type , int __segments ) ;
#line 598
extern  __attribute__((__nothrow__)) void *inet6_rth_init(void *__bp , socklen_t __bp_len ,
                                                          int __type , int __segments ) ;
#line 600
extern  __attribute__((__nothrow__)) int inet6_rth_add(void *__bp , struct in6_addr *__addr ) ;
#line 601
extern  __attribute__((__nothrow__)) int inet6_rth_reverse(void const   *__in , void *__out ) ;
#line 602
extern  __attribute__((__nothrow__)) int inet6_rth_segments(void const   *__bp ) ;
#line 603
extern  __attribute__((__nothrow__)) struct in6_addr *inet6_rth_getaddr(void const   *__bp ,
                                                                        int __index ) ;
#line 610
extern  __attribute__((__nothrow__)) int getipv4sourcefilter(int __s , struct in_addr __interface_addr ,
                                                             struct in_addr __group ,
                                                             uint32_t *__fmode , uint32_t *__numsrc ,
                                                             struct in_addr *__slist ) ;
#line 616
extern  __attribute__((__nothrow__)) int setipv4sourcefilter(int __s , struct in_addr __interface_addr ,
                                                             struct in_addr __group ,
                                                             uint32_t __fmode , uint32_t __numsrc ,
                                                             struct in_addr *__slist ) ;
#line 624
extern  __attribute__((__nothrow__)) int getsourcefilter(int __s , uint32_t __interface_addr ,
                                                         struct sockaddr *__group ,
                                                         socklen_t __grouplen , uint32_t *__fmode ,
                                                         uint32_t *__numsrc , struct sockaddr_storage *__slist ) ;
#line 631
extern  __attribute__((__nothrow__)) int setsourcefilter(int __s , uint32_t __interface_addr ,
                                                         struct sockaddr *__group ,
                                                         socklen_t __grouplen , uint32_t __fmode ,
                                                         uint32_t __numsrc , struct sockaddr_storage *__slist ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval __tvp[2] ) ;
#line 64 "/usr/include/x86_64-linux-gnu/sys/poll.h"
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 46 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
extern int __ppoll_alias(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                         __sigset_t *__ss ) ;
#line 49
extern int __ppoll_chk(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                       __sigset_t *__ss , unsigned long __fdslen ) ;
#line 53
extern int __ppoll_chk_warn(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                            __sigset_t *__ss , unsigned long __fdslen ) ;
#line 61
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__fds, 1);
  }
  {
#line 64
  __cil_tmp6 = __builtin_object_size(__fds, 1);
#line 64
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp6 / sizeof(*__fds));
  }
  {
#line 64
  __cil_tmp5 = __builtin_constant_p(__nfds);
  }
#line 64
  if (__cil_tmp7 && (unsigned long )__nfds <= __cil_tmp8 / sizeof(*__fds)) {
    {
#line 64
    __cil_tmp9 = __ppoll_alias(__fds, __nfds, __timeout, __ss);
#line 64
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 64
    __cil_tmp13 = __builtin_object_size(__fds, 1);
    }
    {
#line 64
    __cil_tmp11 = __builtin_object_size(__fds, 1);
#line 64
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp11 / sizeof(*__fds));
    }
    {
#line 64
    __cil_tmp10 = __builtin_constant_p(__nfds);
    }
#line 64
    if (__cil_tmp12 && ! ((unsigned long )__nfds <= __cil_tmp13 / sizeof(*__fds))) {
      {
#line 64
      __cil_tmp14 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp15 = __ppoll_chk_warn(__fds, __nfds, __timeout, __ss, __cil_tmp14);
#line 64
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 64
      __cil_tmp16 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp17 = __ppoll_chk(__fds, __nfds, __timeout, __ss, __cil_tmp16);
#line 64
      tmp = __cil_tmp17;
      }
    }
#line 64
    tmp___0 = tmp;
  }
#line 64
  return (tmp___0);
}
}
#line 60 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h"
extern  __attribute__((__nothrow__)) void _dl_mcount_wrapper_check(void *__selfpc ) ;
#line 71 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlmopen(Lmid_t __nsid , char const   *__file ,
                                                   int __mode ) ;
#line 75
extern  __attribute__((__nothrow__)) void *dlvsym(void *__handle , char const   *__name ,
                                                  char const   *__version ) ;
#line 100
extern  __attribute__((__nothrow__)) int dladdr(void const   *__address , Dl_info *__info ) ;
#line 104
extern  __attribute__((__nothrow__)) int dladdr1(void const   *__address , Dl_info *__info ,
                                                 void **__extra_info , int __flags ) ;
#line 125
extern  __attribute__((__nothrow__)) int dlinfo(void *__handle , int __request , void *__arg ) ;
#line 222
 __attribute__((__nothrow__)) int _dl_find_object(void *__address , struct dl_find_object *__result ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern  __attribute__((__nothrow__)) int clone(int (*__fn)(void * ) , void *__child_stack ,
                                               int __flags , void *__arg  , ...) ;
#line 86
extern  __attribute__((__nothrow__)) int unshare(int __flags ) ;
#line 89
extern  __attribute__((__nothrow__)) int sched_getcpu(void) ;
#line 92
extern  __attribute__((__nothrow__)) int getcpu(unsigned int * , unsigned int * ) ;
#line 95
extern  __attribute__((__nothrow__)) int setns(int __fd , int __nstype ) ;
#line 130 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 134
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern  __attribute__((__nothrow__)) int clock_adjtime(__clockid_t __clock_id , struct timex *__utx ) ;
#line 107 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *strptime(char const   *__s , char const   *__fmt ,
                                                    struct tm *__tp ) ;
#line 123
extern  __attribute__((__nothrow__)) char *strptime_l(char const   *__s , char const   *__fmt ,
                                                      struct tm *__tp , locale_t __loc ) ;
#line 387
extern  __attribute__((__nothrow__)) int timespec_getres(struct timespec *__ts , int __base ) ;
#line 413
extern int getdate_err ;
#line 422
extern struct tm *getdate(char const   *__string ) ;
#line 436
extern int getdate_r(char const   *__string , struct tm *__resbufp ) ;
#line 224 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_tryjoin_np(pthread_t __th , void **__thread_return ) ;
#line 233
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec *__abstime ) ;
#line 243
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec *__abstime ) ;
#line 394
extern  __attribute__((__nothrow__)) int pthread_attr_setaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 401
extern  __attribute__((__nothrow__)) int pthread_attr_getaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 407
extern  __attribute__((__nothrow__)) int pthread_getattr_default_np(pthread_attr_t *__attr ) ;
#line 411
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 417
extern int pthread_attr_getsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 426
extern  __attribute__((__nothrow__)) int pthread_setattr_default_np(pthread_attr_t *__attr ) ;
#line 432
extern  __attribute__((__nothrow__)) int pthread_getattr_np(pthread_t __th , pthread_attr_t *__attr ) ;
#line 458
extern  __attribute__((__nothrow__)) int pthread_getname_np(pthread_t __target_thread ,
                                                            char *__buf , size_t __buflen ) ;
#line 463
extern  __attribute__((__nothrow__)) int pthread_setname_np(pthread_t __target_thread ,
                                                            char const   *__name ) ;
#line 470
extern  __attribute__((__nothrow__)) int pthread_getconcurrency(void) ;
#line 473
extern  __attribute__((__nothrow__)) int pthread_setconcurrency(int __level ) ;
#line 477
extern  __attribute__((__nothrow__)) int pthread_yield(void) ;
#line 489
extern  __attribute__((__nothrow__)) int pthread_setaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 494
extern  __attribute__((__nothrow__)) int pthread_getaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 732
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 745
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 817
extern  __attribute__((__nothrow__)) int pthread_mutex_clocklock(pthread_mutex_t *__mutex ,
                                                                 clockid_t __clockid ,
                                                                 struct timespec *__abstime ) ;
#line 859
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent_np(pthread_mutex_t * ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust_np(pthread_mutexattr_t * ,
                                                                        int * ) ;
#line 951
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * ,
                                                                        int  ) ;
#line 1004
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockrdlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1051
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockwrlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1171
extern int pthread_cond_clockwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  __clockid_t __clock_id , struct timespec *__abstime ) ;
#line 80 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 151
extern int sigpause(int __sig ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigisemptyset(sigset_t *__set ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigandset(sigset_t *__set , sigset_t *__left ,
                                                   sigset_t *__right ) ;
#line 223
extern  __attribute__((__nothrow__)) int sigorset(sigset_t *__set , sigset_t *__left ,
                                                  sigset_t *__right ) ;
#line 355
extern  __attribute__((__nothrow__)) int sighold(int __sig ) ;
#line 359
extern  __attribute__((__nothrow__)) int sigrelse(int __sig ) ;
#line 363
extern  __attribute__((__nothrow__)) int sigignore(int __sig ) ;
#line 367
extern  __attribute__((__nothrow__)) __sighandler_t sigset(int __sig , __sighandler_t __disp ) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigqueue(pthread_t __threadid , int __signo ,
                                                          union sigval __value ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 398 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern  __attribute__((__nothrow__)) __ssize_t readahead(int __fd , __off64_t __offset ,
                                                         size_t __count ) ;
#line 406
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 414
extern __ssize_t vmsplice(int __fdout , struct iovec *__iov , size_t __count , unsigned int __flags ) ;
#line 421
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 429
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
#line 437
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
#line 448
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
#line 454
extern  __attribute__((__nothrow__)) int name_to_handle_at(int __dfd , char const   *__name ,
                                                           struct file_handle *__handle ,
                                                           int *__mnt_id , int __flags ) ;
#line 462
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
#line 158 "/usr/include/fcntl.h"
extern int fcntl64(int __fd , int __cmd  , ...) ;
#line 191
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 216
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 237
extern int creat64(char const   *__file , mode_t __mode ) ;
#line 285
extern  __attribute__((__nothrow__)) int posix_fadvise64(int __fd , off64_t __offset ,
                                                         off64_t __len , int __advise ) ;
#line 306
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open64(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
  {
#line 78
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = __builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = __builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
  {
#line 156
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = __builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = __builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 38 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static log_level loglevel___3 ;
#line 40
static struct buffer buf___1 ;
#line 41 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
struct buffer *streambuf  =    & buf___1;
#line 46
static sockfd fd ;
#line 47
static struct sockaddr_in addr ;
#line 48
static char host[256] ;
#line 49
static int header_mlen ;
#line 104 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static int send_header(void) 
{ 
  char *ptr ;
  int len ;
  unsigned int try ;
  ssize_t n ;
  int error ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  int *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  char const   *__cil_tmp13 ;

  {
#line 105
  ptr = stream.header;
#line 106
  len = (int )stream.header_len;
#line 108
  try = (unsigned int )0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! len) {
#line 112
      goto while_break;
    }
    {
#line 113
    n = send(fd, ptr, (size_t )len, 16384);
    }
#line 114
    if (n <= 0L) {
      {
#line 115
      error = (int )__errno_location();
      }
#line 119
      if (n < 0L) {
#line 119
        if (error == 11) {
#line 119
          if (try < 10U) {
#line 121
            if ((unsigned int )loglevel___3 >= 3U) {
              {
#line 121
              __cil_tmp8 = logtime();
              }
              {
#line 121
              try ++;
#line 121
              logprint("%s %s:%d retrying (%d) writing to socket\n", __cil_tmp8, "send_header",
                       121, try);
              }
            }
            {
#line 122
            usleep((__useconds_t )1000);
            }
#line 123
            goto while_continue;
          }
        }
      }
#line 125
      if ((unsigned int )loglevel___3 >= 1U) {
        {
#line 125
        __cil_tmp9 = logtime();
        }
        {
#line 125
        __cil_tmp10 = __errno_location();
#line 125
        __cil_tmp11 = strerror(*__cil_tmp10);
#line 125
        logprint("%s %s:%d failed writing to socket: %s\n", __cil_tmp9, "send_header",
                 125, __cil_tmp11);
        }
      }
      {
#line 126
      stream.disconnect = (disconnect_code )1;
#line 127
      stream.state = (stream_state )1;
#line 128
      wake_controller();
      }
#line 129
      return (0);
    }
#line 131
    if ((unsigned int )loglevel___3 >= 4U) {
      {
#line 131
      __cil_tmp12 = logtime();
#line 131
      logprint("%s %s:%d wrote %d bytes to socket\n", __cil_tmp12, "send_header",
               131, n);
      }
    }
#line 132
    ptr += n;
#line 133
    len -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  if ((unsigned int )loglevel___3 >= 4U) {
    {
#line 135
    __cil_tmp13 = logtime();
#line 135
    logprint("%s %s:%d wrote header\n", __cil_tmp13, "send_header", 135);
    }
  }
#line 136
  return (1);
}
}
#line 139 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static int running___2  =    1;
#line 141 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static void _disconnect(stream_state state , disconnect_code disconnect ) 
{ 


  {
  {
#line 142
  stream.state = state;
#line 143
  stream.disconnect = disconnect;
#line 151
  close(fd);
#line 152
  fd = - 1;
#line 153
  wake_controller();
  }
  return;
}
}
#line 156 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static int connect_socket(int use_ssl ) 
{ 
  int sock___0 ;
  int __cil_tmp3 ;
  char const   *__cil_tmp4 ;
  char const   *__cil_tmp5 ;
  char *__cil_tmp6 ;
  __uint16_t __cil_tmp7 ;
  int __cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
  {
#line 157
  __cil_tmp3 = socket(2, 1, 0);
#line 157
  sock___0 = __cil_tmp3;
  }
#line 159
  if (sock___0 < 0) {
    {
#line 160
    __cil_tmp4 = logtime();
#line 160
    logprint("%s %s:%d failed to create socket\n", __cil_tmp4, "connect_socket", 160);
    }
#line 161
    return (- 1);
  }
#line 164
  if ((unsigned int )loglevel___3 >= 2U) {
    {
#line 164
    __cil_tmp5 = logtime();
    }
    {
#line 164
    __cil_tmp6 = inet_ntoa(addr.sin_addr);
    }
    {
#line 164
    __cil_tmp7 = __bswap_16(addr.sin_port);
#line 164
    logprint("%s %s:%d connecting to %s:%d\n", __cil_tmp5, "connect_socket", 164,
             __cil_tmp6, (int )__cil_tmp7);
    }
  }
  {
#line 166
  set_nonblock(sock___0);
#line 169
  __cil_tmp8 = connect_timeout(sock___0, (struct sockaddr *)(& addr), (socklen_t )sizeof(addr),
                               10);
  }
#line 169
  if (__cil_tmp8 < 0) {
#line 170
    if ((unsigned int )loglevel___3 >= 2U) {
      {
#line 170
      __cil_tmp9 = logtime();
#line 170
      logprint("%s %s:%d unable to connect to server\n", __cil_tmp9, "connect_socket",
               170);
      }
    }
    {
#line 171
    close(sock___0);
    }
#line 172
    return (- 1);
  }
#line 211
  return (sock___0);
}
}
#line 214 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
static void *stream_thread(void) 
{ 
  struct pollfd pollinfo ;
  size_t space ;
  unsigned int __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int tmp ;
  int n ;
  ssize_t __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;
  int *__cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  char c ;
  static int endtok ;
  int n___0 ;
  ssize_t __cil_tmp20 ;
  int *__cil_tmp21 ;
  char const   *__cil_tmp22 ;
  int *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *tmp___0 ;
  size_t __cil_tmp26 ;
  char const   *__cil_tmp27 ;
  int __cil_tmp28 ;
  char const   *__cil_tmp29 ;
  int tmp___1 ;
  u8_t c___0 ;
  int n___1 ;
  ssize_t __cil_tmp33 ;
  int *__cil_tmp34 ;
  char const   *__cil_tmp35 ;
  int *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *tmp___2 ;
  int n___2 ;
  ssize_t __cil_tmp40 ;
  int *__cil_tmp41 ;
  char const   *__cil_tmp42 ;
  int *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *tmp___3 ;
  char const   *__cil_tmp46 ;
  int n___3 ;
  unsigned int __cil_tmp48 ;
  unsigned int __cil_tmp49 ;
  unsigned int __cil_tmp50 ;
  unsigned int __cil_tmp51 ;
  unsigned int tmp___4 ;
  size_t tmp___5 ;
  ssize_t __cil_tmp54 ;
  char const   *__cil_tmp55 ;
  int *__cil_tmp56 ;
  char const   *__cil_tmp57 ;
  int *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char const   *__cil_tmp60 ;
  char const   *__cil_tmp61 ;

  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! running___2) {
#line 215
      goto while_break;
    }
    {
#line 220
    pthread_mutex_lock(& streambuf->mutex);
#line 222
    __cil_tmp4 = _buf_cont_write(streambuf);
    }
    {
#line 222
    __cil_tmp3 = _buf_space(streambuf);
    }
#line 222
    if (__cil_tmp3 < __cil_tmp4) {
      {
#line 222
      __cil_tmp5 = _buf_space(streambuf);
#line 222
      tmp = __cil_tmp5;
      }
    } else {
      {
#line 222
      __cil_tmp6 = _buf_cont_write(streambuf);
#line 222
      tmp = __cil_tmp6;
      }
    }
#line 222
    space = (size_t )tmp;
#line 224
    if (fd < 0) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& streambuf->mutex);
      }
      }
      {
      {
#line 226
      usleep((__useconds_t )100000);
      }
      }
      }
#line 227
      goto while_continue;
    } else
#line 224
    if (! space) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& streambuf->mutex);
      }
      }
      {
      {
#line 226
      usleep((__useconds_t )100000);
      }
      }
      }
#line 227
      goto while_continue;
    } else
#line 224
    if ((unsigned int )stream.state <= 2U) {
      {
      {
      {
#line 225
      pthread_mutex_unlock(& streambuf->mutex);
      }
      }
      {
      {
#line 226
      usleep((__useconds_t )100000);
      }
      }
      }
#line 227
      goto while_continue;
    }
#line 230
    if ((unsigned int )stream.state == 4U) {
      {
#line 232
      __cil_tmp9 = read(fd, streambuf->writep, space);
#line 232
      n = (int )__cil_tmp9;
      }
#line 233
      if (n == 0) {
#line 234
        if ((unsigned int )loglevel___3 >= 2U) {
          {
#line 234
          __cil_tmp10 = logtime();
#line 234
          logprint("%s %s:%d end of stream\n", __cil_tmp10, "stream_thread", 234);
          }
        }
        {
#line 235
        _disconnect((stream_state )1, (disconnect_code )0);
        }
      }
#line 237
      if (n > 0) {
        {
#line 238
        _buf_inc_writep(streambuf, (unsigned int )n);
#line 239
        stream.bytes += (unsigned long )n;
        }
#line 240
        if ((unsigned int )loglevel___3 >= 4U) {
          {
#line 240
          __cil_tmp11 = logtime();
#line 240
          logprint("%s %s:%d streambuf read %d bytes\n", __cil_tmp11, "stream_thread",
                   240, n);
          }
        }
      }
#line 242
      if (n < 0) {
#line 243
        if ((unsigned int )loglevel___3 >= 1U) {
          {
#line 243
          __cil_tmp12 = logtime();
          }
          {
#line 243
          __cil_tmp13 = __errno_location();
#line 243
          __cil_tmp14 = strerror(*__cil_tmp13);
#line 243
          logprint("%s %s:%d error reading: %s\ng\301U", __cil_tmp12, "stream_threadU",
                   243, __cil_tmp14);
          }
        }
        {
#line 244
        _disconnect((stream_state )1, (disconnect_code )2);
        }
      }
      {
#line 247
      pthread_mutex_unlock(& streambuf->mutex);
      }
#line 248
      goto while_continue;
    } else {
#line 252
      pollinfo.fd = fd;
#line 253
      pollinfo.events = (short )1;
#line 254
      if ((unsigned int )stream.state == 6U) {
#line 255
        pollinfo.events |= 4;
      }
    }
    {
#line 259
    pthread_mutex_unlock(& streambuf->mutex);
#line 261
    __cil_tmp15 = poll(& pollinfo, (nfds_t )1, 100);
    }
#line 261
    if (__cil_tmp15) {
      {
#line 263
      pthread_mutex_lock(& streambuf->mutex);
      }
#line 266
      if (fd < 0) {
        {
#line 267
        pthread_mutex_unlock(& streambuf->mutex);
        }
#line 268
        goto while_continue;
      }
#line 271
      if ((int )pollinfo.revents & 4) {
#line 271
        if ((unsigned int )stream.state == 6U) {
          {
#line 272
          __cil_tmp16 = send_header();
          }
#line 272
          if (__cil_tmp16) {
#line 272
            stream.state = (stream_state )7;
          }
          {
#line 273
          header_mlen = (int )stream.header_len;
#line 274
          stream.header_len = (size_t )0;
#line 275
          pthread_mutex_unlock(& streambuf->mutex);
          }
#line 276
          goto while_continue;
        }
      }
#line 279
      if ((int )pollinfo.revents & 17) {
#line 282
        if ((unsigned int )stream.state == 7U) {
          {
#line 288
          __cil_tmp20 = recv(fd, & c, (size_t )1, 0);
#line 288
          n___0 = (int )__cil_tmp20;
          }
#line 289
          if (n___0 <= 0) {
            {
#line 290
            __cil_tmp21 = __errno_location();
            }
#line 290
            if (n___0 < 0) {
#line 290
              if (*__cil_tmp21 == 11) {
                {
#line 291
                pthread_mutex_unlock(& streambuf->mutex);
                }
#line 292
                goto while_continue;
              }
            }
#line 294
            if ((unsigned int )loglevel___3 >= 2U) {
              {
#line 294
              __cil_tmp22 = logtime();
              }
#line 294
              if (n___0) {
                {
#line 294
                __cil_tmp23 = __errno_location();
#line 294
                __cil_tmp24 = strerror(*__cil_tmp23);
#line 294
                tmp___0 = __cil_tmp24;
                }
              } else {
#line 294
                tmp___0 = (char *)"closed";
              }
              {
#line 294
              logprint("%s %s:%d error reading headers: %s\n", __cil_tmp22, "stream_thread",
                       294, (int )tmp___0);
              }
            }
            {
#line 314
            _disconnect((stream_state )0, (disconnect_code )1);
#line 315
            pthread_mutex_unlock(& streambuf->mutex);
            }
#line 316
            goto while_continue;
          }
#line 319
          *(stream.header + stream.header_len) = c;
#line 320
          (stream.header_len) ++;
#line 322
          if (stream.header_len > 4095UL) {
            {
#line 323
            __cil_tmp27 = logtime();
#line 323
            logprint("%s %s:%d received headers too long: %u\n", __cil_tmp27, "stream_thread",
                     323, stream.header_len);
#line 324
            _disconnect((stream_state )1, (disconnect_code )1);
            }
          }
#line 327
          if (stream.header_len > 1UL) {
#line 327
            if ((int )c == 13) {
              _L: /* CIL Label */ 
#line 328
              endtok ++;
#line 329
              if (endtok == 4) {
#line 330
                *(stream.header + stream.header_len) = (char )'\000';
#line 331
                if ((unsigned int )loglevel___3 >= 2U) {
                  {
#line 331
                  __cil_tmp29 = logtime();
#line 331
                  logprint("%s %s:%d headers: len: %d\n%s\n", __cil_tmp29, "stream_thread",
                           331, stream.header_len, stream.header);
                  }
                }
#line 332
                if (stream.cont_wait) {
#line 332
                  tmp___1 = 2;
                } else {
#line 332
                  tmp___1 = 3;
                }
                {
#line 332
                stream.state = (stream_state )tmp___1;
#line 333
                wake_controller();
                }
              }
            } else
#line 327
            if ((int )c == 10) {
#line 327
              goto _L;
            } else {
#line 336
              endtok = 0;
            }
          } else {
#line 336
            endtok = 0;
          }
          {
#line 339
          pthread_mutex_unlock(& streambuf->mutex);
          }
#line 340
          goto while_continue;
        }
#line 344
        if (stream.meta_interval) {
#line 344
          if (stream.meta_next == 0U) {
#line 346
            if (stream.meta_left == 0U) {
              {
#line 349
              __cil_tmp33 = recv(fd, & c___0, (size_t )1, 0);
#line 349
              n___1 = (int )__cil_tmp33;
              }
#line 350
              if (n___1 <= 0) {
                {
#line 351
                __cil_tmp34 = __errno_location();
                }
#line 351
                if (n___1 < 0) {
#line 351
                  if (*__cil_tmp34 == 11) {
                    {
#line 352
                    pthread_mutex_unlock(& streambuf->mutex);
                    }
#line 353
                    goto while_continue;
                  }
                }
#line 355
                if ((unsigned int )loglevel___3 >= 2U) {
                  {
#line 355
                  __cil_tmp35 = logtime();
                  }
#line 355
                  if (n___1) {
                    {
#line 355
                    __cil_tmp36 = __errno_location();
#line 355
                    __cil_tmp37 = strerror(*__cil_tmp36);
#line 355
                    tmp___2 = __cil_tmp37;
                    }
                  } else {
#line 355
                    tmp___2 = (char *)"closed";
                  }
                  {
#line 355
                  logprint("%s %s:%d error reading icy meta: %s\n", __cil_tmp35, "stream_thread",
                           355, (int )tmp___2);
                  }
                }
                {
#line 356
                _disconnect((stream_state )0, (disconnect_code )1);
#line 357
                pthread_mutex_unlock(& streambuf->mutex);
                }
#line 358
                goto while_continue;
              }
#line 360
              stream.meta_left = (u32_t )(16 * (int )c___0);
#line 361
              stream.header_len = (size_t )0;
            }
#line 365
            if (stream.meta_left) {
              {
#line 366
              __cil_tmp40 = recv(fd, stream.header + stream.header_len, (size_t )stream.meta_left,
                                 0);
#line 366
              n___2 = (int )__cil_tmp40;
              }
#line 367
              if (n___2 <= 0) {
                {
#line 368
                __cil_tmp41 = __errno_location();
                }
#line 368
                if (n___2 < 0) {
#line 368
                  if (*__cil_tmp41 == 11) {
                    {
#line 369
                    pthread_mutex_unlock(& streambuf->mutex);
                    }
#line 370
                    goto while_continue;
                  }
                }
#line 372
                if ((unsigned int )loglevel___3 >= 2U) {
                  {
#line 372
                  __cil_tmp42 = logtime();
                  }
#line 372
                  if (n___2) {
                    {
#line 372
                    __cil_tmp43 = __errno_location();
#line 372
                    __cil_tmp44 = strerror(*__cil_tmp43);
#line 372
                    tmp___3 = __cil_tmp44;
                    }
                  } else {
#line 372
                    tmp___3 = (char *)"closed";
                  }
                  {
#line 372
                  logprint("%s %s:%d error reading icy meta: %s\n", __cil_tmp42, "stream_thread",
                           372, (int )tmp___3);
                  }
                }
                {
#line 373
                _disconnect((stream_state )0, (disconnect_code )1);
#line 374
                pthread_mutex_unlock(& streambuf->mutex);
                }
#line 375
                goto while_continue;
              }
#line 377
              stream.meta_left -= (unsigned int )n___2;
#line 378
              stream.header_len += (unsigned long )n___2;
            }
#line 381
            if (stream.meta_left == 0U) {
#line 382
              if (stream.header_len) {
#line 383
                *(stream.header + stream.header_len) = (char )'\000';
#line 384
                if ((unsigned int )loglevel___3 >= 2U) {
                  {
#line 384
                  __cil_tmp46 = logtime();
#line 384
                  logprint("%s %s:%d icy meta: len: %u\n%s\n", __cil_tmp46, "stream_thread",
                           384, stream.header_len, stream.header);
                  }
                }
                {
#line 385
                stream.meta_send = 1;
#line 386
                wake_controller();
                }
              }
              {
#line 388
              stream.meta_next = stream.meta_interval;
#line 389
              pthread_mutex_unlock(& streambuf->mutex);
              }
#line 390
              goto while_continue;
            }
          } else {
#line 344
            goto _L___33;
          }
        } else {
          _L___33: /* CIL Label */ 
          {
#line 397
          __cil_tmp49 = _buf_cont_write(streambuf);
          }
          {
#line 397
          __cil_tmp48 = _buf_space(streambuf);
          }
#line 397
          if (__cil_tmp48 < __cil_tmp49) {
            {
#line 397
            __cil_tmp50 = _buf_space(streambuf);
#line 397
            tmp___4 = __cil_tmp50;
            }
          } else {
            {
#line 397
            __cil_tmp51 = _buf_cont_write(streambuf);
#line 397
            tmp___4 = __cil_tmp51;
            }
          }
#line 397
          space = (size_t )tmp___4;
#line 398
          if (stream.meta_interval) {
#line 399
            if (space < (unsigned long )stream.meta_next) {
#line 399
              tmp___5 = space;
            } else {
#line 399
              tmp___5 = (unsigned long )stream.meta_next;
            }
#line 399
            space = tmp___5;
          }
          {
#line 402
          __cil_tmp54 = recv(fd, streambuf->writep, space, 0);
#line 402
          n___3 = (int )__cil_tmp54;
          }
#line 403
          if (n___3 == 0) {
#line 404
            if ((unsigned int )loglevel___3 >= 2U) {
              {
#line 404
              __cil_tmp55 = logtime();
#line 404
              logprint("%s %s:%d end of stream (%u bytes)\n", __cil_tmp55, "stream_thread",
                       404, stream.bytes);
              }
            }
            {
#line 405
            _disconnect((stream_state )1, (disconnect_code )0);
            }
          }
          {
#line 407
          __cil_tmp56 = __errno_location();
          }
#line 407
          if (n___3 < 0) {
#line 407
            if (*__cil_tmp56 != 11) {
#line 408
              if ((unsigned int )loglevel___3 >= 2U) {
                {
#line 408
                __cil_tmp57 = logtime();
                }
                {
#line 408
                __cil_tmp58 = __errno_location();
#line 408
                __cil_tmp59 = strerror(*__cil_tmp58);
#line 408
                logprint("%s %s:%d error reading: %s\n", __cil_tmp57, "stream_thread",
                         408, __cil_tmp59);
                }
              }
              {
#line 409
              _disconnect((stream_state )1, (disconnect_code )2);
              }
            }
          }
#line 412
          if (n___3 > 0) {
            {
#line 413
            _buf_inc_writep(streambuf, (unsigned int )n___3);
#line 414
            stream.bytes += (unsigned long )n___3;
            }
#line 415
            if (stream.meta_interval) {
#line 416
              stream.meta_next -= (unsigned int )n___3;
            }
          } else {
            {
#line 419
            pthread_mutex_unlock(& streambuf->mutex);
            }
#line 420
            goto while_continue;
          }
#line 423
          if ((unsigned int )stream.state == 3U) {
#line 423
            if (stream.bytes > (unsigned long )stream.threshold) {
              {
#line 424
              stream.state = (stream_state )5;
#line 425
              wake_controller();
              }
            }
          }
#line 428
          if ((unsigned int )loglevel___3 >= 4U) {
            {
#line 428
            __cil_tmp60 = logtime();
#line 428
            logprint("%s %s:%d streambuf read %d bytes\n", __cil_tmp60, "stream_thread",
                     428, n___3);
            }
          }
        }
      }
      {
#line 432
      pthread_mutex_unlock(& streambuf->mutex);
      }
    } else
#line 436
    if ((unsigned int )loglevel___3 >= 4U) {
      {
#line 436
      __cil_tmp61 = logtime();
#line 436
      logprint("%s %s:%d poll timeout\n", __cil_tmp61, "stream_thread", 436);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  return ((void *)0);
}
}
#line 449
static pthread_t thread___2 ;
#line 451 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
void stream_init(log_level level , unsigned int stream_buf_size ) 
{ 
  char const   *__cil_tmp3 ;
  char const   *__cil_tmp4 ;
  char const   *__cil_tmp5 ;
  void *__cil_tmp6 ;
  pthread_attr_t attr ;
  long __cil_tmp8 ;

  {
#line 452
  loglevel___3 = level;
#line 454
  if ((unsigned int )loglevel___3 >= 2U) {
    {
#line 454
    __cil_tmp3 = logtime();
#line 454
    logprint("%s %s:%d init stream\n", __cil_tmp3, "stream_init", 454);
    }
  }
#line 455
  if ((unsigned int )loglevel___3 >= 3U) {
    {
#line 455
    __cil_tmp4 = logtime();
#line 455
    logprint("%s %s:%d streambuf size: %u\n", __cil_tmp4, "stream_init", 455, stream_buf_size);
    }
  }
  {
#line 457
  buf_init(streambuf, (size_t )stream_buf_size);
  }
#line 458
  if (streambuf->buf == (void *)0) {
    {
#line 459
    __cil_tmp5 = logtime();
#line 459
    logprint("%s %s:%d unable to malloc buffer\n", __cil_tmp5, "stream_initg\301U",
             459);
#line 460
    exit(0);
    }
  }
  {
#line 483
  stream.state = (stream_state )0;
#line 484
  stream.header = (char *)malloc((unsigned long )4096);
#line 485
  *(stream.header) = (char )'\000';
#line 487
  fd = - 1;
#line 490
  touch_memory(streambuf->buf, streambuf->size);
#line 495
  pthread_attr_init(& attr);
#line 497
  __cil_tmp8 = __sysconf(75);
#line 497
  pthread_attr_setstacksize(& attr, (size_t )(__cil_tmp8 + 65536L));
#line 499
  pthread_create(& thread___2, & attr, & stream_thread, (void *)0);
#line 500
  pthread_attr_destroy(& attr);
  }
  return;
}
}
#line 507 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
void stream_close(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 508
  if ((unsigned int )loglevel___3 >= 2U) {
    {
#line 508
    __cil_tmp1 = logtime();
#line 508
    logprint("%s %s:%d close stream\n", __cil_tmp1, "stream_close", 508);
    }
  }
  {
#line 509
  pthread_mutex_lock(& streambuf->mutex);
#line 510
  running___2 = 0;
#line 511
  pthread_mutex_unlock(& streambuf->mutex);
#line 513
  pthread_join(thread___2, (void **)((void *)0));
#line 515
  free(stream.header);
#line 516
  buf_destroy(streambuf);
  }
  return;
}
}
#line 519 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
void stream_file(char const   *header , size_t header_len , unsigned int threshold ) 
{ 
  char const   *__cil_tmp4 ;
  int __cil_tmp5 ;
  char const   *__cil_tmp6 ;

  {
  {
#line 520
  buf_flush(streambuf);
#line 522
  pthread_mutex_lock(& streambuf->mutex);
#line 524
  stream.header_len = header_len;
#line 525
  memcpy(stream.header, header, header_len);
#line 526
  *(stream.header + header_len) = (char )'\000';
  }
#line 528
  if ((unsigned int )loglevel___3 >= 2U) {
    {
#line 528
    __cil_tmp4 = logtime();
#line 528
    logprint("%s %s:%d opening local file: %s\n\230", __cil_tmp4, "stream_file", 528,
             stream.header);
    }
  }
  {
#line 533
  fd = open((char const   *)stream.header, 0);
#line 536
  stream.state = (stream_state )4;
  }
#line 537
  if (fd < 0) {
#line 538
    if ((unsigned int )loglevel___3 >= 2U) {
      {
#line 538
      __cil_tmp6 = logtime();
#line 538
      logprint("%s %s:%d can\'t open file: %s\n", __cil_tmp6, "stream_file", 538,
               stream.header);
      }
    }
#line 539
    stream.state = (stream_state )1;
  }
  {
#line 541
  wake_controller();
#line 543
  stream.cont_wait = 0;
#line 544
  stream.meta_interval = (u32_t )0;
#line 545
  stream.meta_next = (u32_t )0;
#line 546
  stream.meta_left = (u32_t )0;
#line 547
  stream.meta_send = 0;
#line 548
  stream.sent_headers = 0;
#line 549
  stream.bytes = (u64_t )0;
#line 550
  stream.threshold = threshold;
#line 552
  pthread_mutex_unlock(& streambuf->mutex);
  }
  return;
}
}
#line 555 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
void stream_sock(u32_t ip , u16_t port , int use_ssl , char const   *header , size_t header_len ,
                 unsigned int threshold , int cont_wait ) 
{ 
  char *p ;
  int sock___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  __uint16_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char const   *__cil_tmp15 ;

  {
  {
#line 559
  memset(& addr, 0, sizeof(addr));
#line 560
  addr.sin_family = (sa_family_t )2;
#line 561
  addr.sin_addr.s_addr = ip;
#line 562
  addr.sin_port = port;
#line 564
  *((char *)host) = (char )'\000';
#line 565
  p = strcasestr(header, "Host:U");
  }
#line 566
  if (p) {
    {
#line 567
    sscanf((char const   *)p, "Host:%255s", (char *)host);
#line 568
    p = strchr((char const   *)((char *)host), ':');
    }
#line 568
    if (p != (void *)0) {
#line 568
      *p = (char )'\000';
    }
  }
  {
#line 571
  port = __bswap_16(port);
#line 572
  sock___0 = connect_socket(use_ssl || (int )port == 443);
  }
#line 575
  if (sock___0 < 0) {
#line 575
    if ((int )port == 443) {
#line 575
      if (! use_ssl) {
        {
#line 575
        sock___0 = connect_socket(0);
        }
      }
    }
  }
#line 577
  if (sock___0 < 0) {
    {
#line 578
    pthread_mutex_lock(& streambuf->mutex);
#line 579
    stream.state = (stream_state )1;
#line 580
    stream.disconnect = (disconnect_code )3;
#line 581
    pthread_mutex_unlock(& streambuf->mutex);
    }
#line 582
    return;
  }
  {
#line 585
  buf_flush(streambuf);
#line 587
  pthread_mutex_lock(& streambuf->mutex);
#line 589
  fd = sock___0;
#line 590
  stream.state = (stream_state )6;
#line 591
  stream.cont_wait = cont_wait;
#line 592
  stream.meta_interval = (u32_t )0;
#line 593
  stream.meta_next = (u32_t )0;
#line 594
  stream.meta_left = (u32_t )0;
#line 595
  stream.meta_send = 0;
#line 596
  stream.header_len = header_len;
#line 597
  memcpy(stream.header, header, header_len);
#line 598
  *(stream.header + header_len) = (char )'\000';
  }
#line 600
  if ((unsigned int )loglevel___3 >= 2U) {
    {
#line 600
    __cil_tmp15 = logtime();
#line 600
    logprint("%s %s:%d header: %s\n", __cil_tmp15, "stream_sock", 600, stream.header);
    }
  }
  {
#line 602
  stream.sent_headers = 0;
#line 603
  stream.bytes = (u64_t )0;
#line 604
  stream.threshold = threshold;
#line 606
  pthread_mutex_unlock(& streambuf->mutex);
  }
  return;
}
}
#line 609 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/stream.c"
int stream_disconnect(void) 
{ 
  int disc ;

  {
  {
#line 610
  disc = 0;
#line 611
  pthread_mutex_lock(& streambuf->mutex);
  }
#line 619
  if (fd != -1) {
    {
#line 620
    close(fd);
#line 621
    fd = - 1;
#line 622
    disc = 1;
    }
  }
  {
#line 624
  stream.state = (stream_state )0;
#line 625
  pthread_mutex_unlock(& streambuf->mutex);
  }
#line 626
  return (disc);
}
}
#line 33 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
unsigned int _buf_used(struct buffer *buf___2 ) 
{ 
  unsigned long tmp ;

  {
#line 34
  if (buf___2->writep >= buf___2->readp) {
#line 34
    tmp = (unsigned long )(buf___2->writep - buf___2->readp);
  } else {
#line 34
    tmp = buf___2->size - (unsigned long )(buf___2->readp - buf___2->writep);
  }
#line 34
  return ((unsigned int )tmp);
}
}
#line 37 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
unsigned int _buf_space(struct buffer *buf___2 ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 38
  __cil_tmp2 = _buf_used(buf___2);
  }
#line 38
  return ((unsigned int )((buf___2->size - (unsigned long )__cil_tmp2) - 1UL));
}
}
#line 41 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
unsigned int _buf_cont_read(struct buffer *buf___2 ) 
{ 
  u8_t *tmp ;

  {
#line 42
  if (buf___2->writep >= buf___2->readp) {
#line 42
    tmp = buf___2->writep - buf___2->readp;
  } else {
#line 42
    tmp = buf___2->wrap - buf___2->readp;
  }
#line 42
  return ((unsigned int )tmp);
}
}
#line 45 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
unsigned int _buf_cont_write(struct buffer *buf___2 ) 
{ 
  u8_t *tmp ;

  {
#line 46
  if (buf___2->writep >= buf___2->readp) {
#line 46
    tmp = buf___2->wrap - buf___2->writep;
  } else {
#line 46
    tmp = buf___2->readp - buf___2->writep;
  }
#line 46
  return ((unsigned int )tmp);
}
}
#line 49 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void _buf_inc_readp(struct buffer *buf___2 , unsigned int by ) 
{ 


  {
#line 50
  buf___2->readp += by;
#line 51
  if (buf___2->readp >= buf___2->wrap) {
#line 52
    buf___2->readp -= buf___2->size;
  }
  return;
}
}
#line 56 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void _buf_inc_writep(struct buffer *buf___2 , unsigned int by ) 
{ 


  {
#line 57
  buf___2->writep += by;
#line 58
  if (buf___2->writep >= buf___2->wrap) {
#line 59
    buf___2->writep -= buf___2->size;
  }
  return;
}
}
#line 63 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void buf_flush(struct buffer *buf___2 ) 
{ 


  {
  {
#line 64
  pthread_mutex_lock(& buf___2->mutex);
#line 65
  buf___2->readp = buf___2->buf;
#line 66
  buf___2->writep = buf___2->buf;
#line 67
  pthread_mutex_unlock(& buf___2->mutex);
  }
  return;
}
}
#line 71 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void buf_adjust(struct buffer *buf___2 , size_t mod ) 
{ 
  size_t size ;

  {
  {
#line 73
  pthread_mutex_lock(& buf___2->mutex);
#line 74
  size = (unsigned long )((unsigned int )(buf___2->base_size / mod)) * mod;
#line 75
  buf___2->readp = buf___2->buf;
#line 76
  buf___2->writep = buf___2->buf;
#line 77
  buf___2->wrap = buf___2->buf + size;
#line 78
  buf___2->size = size;
#line 79
  pthread_mutex_unlock(& buf___2->mutex);
  }
  return;
}
}
#line 83 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void _buf_resize(struct buffer *buf___2 , size_t size ) 
{ 
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 84
  free(buf___2->buf);
#line 85
  buf___2->buf = (u8_t *)malloc(size);
  }
#line 86
  if (! buf___2->buf) {
    {
#line 87
    size = buf___2->size;
#line 88
    buf___2->buf = (u8_t *)malloc(size);
    }
#line 89
    if (! buf___2->buf) {
#line 90
      size = (size_t )0;
    }
  }
#line 93
  buf___2->readp = buf___2->buf;
#line 94
  buf___2->writep = buf___2->buf;
#line 95
  buf___2->wrap = buf___2->buf + size;
#line 96
  buf___2->size = size;
#line 97
  buf___2->base_size = size;
  return;
}
}
#line 100 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void _buf_unwrap(struct buffer *buf___2 , size_t cont ) 
{ 
  ssize_t len ;
  ssize_t by ;
  size_t size ;
  u8_t *scratch ;
  ssize_t tmp ;
  void *__cil_tmp8 ;

  {
#line 101
  by = (ssize_t )(cont - (unsigned long )(buf___2->wrap - buf___2->readp));
#line 106
  if (by <= 0L) {
#line 106
    return;
  } else
#line 106
  if (cont >= buf___2->size) {
#line 106
    return;
  }
#line 109
  if (buf___2->writep >= buf___2->readp) {
    {
#line 110
    memmove(buf___2->readp - by, buf___2->readp, (unsigned long )(buf___2->writep - buf___2->readp));
#line 111
    buf___2->readp -= by;
#line 112
    buf___2->writep -= by;
    }
#line 113
    return;
  }
#line 117
  size = (size_t )((buf___2->readp - buf___2->writep) - by);
#line 118
  len = buf___2->writep - buf___2->buf;
#line 121
  if (size <= 0UL) {
    {
#line 122
    memmove(buf___2->readp - by, buf___2->readp, (unsigned long )(buf___2->wrap - buf___2->readp));
#line 123
    buf___2->readp -= by;
    }
#line 124
    if (len < by) {
#line 124
      tmp = len;
    } else {
#line 124
      tmp = by;
    }
    {
#line 124
    memcpy(buf___2->wrap - by, buf___2->buf, (unsigned long )tmp);
    }
#line 125
    if (len > by) {
      {
#line 126
      memmove(buf___2->buf, buf___2->buf + by, (unsigned long )(len - by));
#line 127
      buf___2->writep -= by;
      }
    } else {
#line 128
      buf___2->writep += buf___2->size - (unsigned long )by;
    }
#line 129
    return;
  }
  {
#line 132
  scratch = (u8_t *)malloc(size);
  }
#line 135
  if (scratch) {
    {
#line 136
    memcpy(scratch, buf___2->writep - size, size);
#line 137
    memmove(buf___2->readp - by, buf___2->readp, (unsigned long )(buf___2->wrap - buf___2->readp));
#line 138
    buf___2->readp -= by;
#line 139
    memcpy(buf___2->wrap - by, buf___2->buf, (unsigned long )by);
#line 140
    memmove(buf___2->buf, buf___2->buf + by, (unsigned long )(len - by) - size);
#line 141
    buf___2->writep -= by;
#line 142
    memcpy(buf___2->writep - size, scratch, size);
#line 143
    free(scratch);
    }
  } else {
    {
#line 145
    _buf_unwrap(buf___2, cont / 2UL);
#line 146
    _buf_unwrap(buf___2, cont - cont / 2UL);
    }
  }
  return;
}
}
#line 150 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void buf_init(struct buffer *buf___2 , size_t size ) 
{ 
  void *__cil_tmp3 ;
  pthread_mutexattr_t attr ;

  {
  {
#line 151
  buf___2->buf = (u8_t *)malloc(size);
#line 152
  buf___2->readp = buf___2->buf;
#line 153
  buf___2->writep = buf___2->buf;
#line 154
  buf___2->wrap = buf___2->buf + size;
#line 155
  buf___2->size = size;
#line 156
  buf___2->base_size = size;
#line 157
  pthread_mutexattr_init(& attr);
#line 157
  pthread_mutexattr_setprotocol(& attr, 1);
#line 157
  pthread_mutex_init(& buf___2->mutex, & attr);
#line 157
  pthread_mutexattr_destroy(& attr);
  }
  return;
}
}
#line 160 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/buffer.c"
void buf_destroy(struct buffer *buf___2 ) 
{ 


  {
#line 161
  if (buf___2->buf) {
    {
#line 162
    free(buf___2->buf);
#line 163
    buf___2->buf = (u8_t *)((void *)0);
#line 164
    buf___2->size = (size_t )0;
#line 165
    buf___2->base_size = (size_t )0;
#line 166
    pthread_mutex_destroy(& buf___2->mutex);
    }
  }
  return;
}
}
#line 28 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static log_level loglevel___4 ;
#line 44 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static sockfd sock  =    - 1;
#line 45 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static in_addr_t slimproto_ip  =    (in_addr_t )0;
#line 59
int wake_e ;
#line 85
static struct __anonstruct_251 status ;
#line 87
int autostart ;
#line 88
int sentSTMu ;
#line 88
int sentSTMo ;
#line 88
int sentSTMl ;
#line 89
u32_t new_server ;
#line 90
char *new_server_cap ;
#line 92 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
char player_name[65]  =    "`\336\221g\301U";
#line 93 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
char const   *name_file  =    (char const   *)((void *)0);
#line 95 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
void send_packet(u8_t *packet , size_t len ) 
{ 
  u8_t *ptr ;
  unsigned int try ;
  ssize_t n ;
  int error ;
  ssize_t __cil_tmp7 ;
  int *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  char const   *__cil_tmp10 ;
  int *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 96
  ptr = packet;
#line 97
  try = (unsigned int )0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! len) {
#line 101
      goto while_break;
    }
    {
#line 102
    n = send(sock, ptr, len, 16384);
    }
#line 103
    if (n <= 0L) {
      {
#line 104
      error = (int )__errno_location();
      }
#line 108
      if (n < 0L) {
#line 108
        if (error == 11) {
#line 108
          if (try < 10U) {
#line 110
            if ((unsigned int )loglevel___4 >= 3U) {
              {
#line 110
              __cil_tmp9 = logtime();
              }
              {
#line 110
              try ++;
#line 110
              logprint("%s %s:%d retrying (%d) writing to socket\n", __cil_tmp9, "send_packet",
                       110, try);
              }
            }
            {
#line 111
            usleep((__useconds_t )1000);
            }
#line 112
            goto while_continue;
          }
        }
      }
#line 114
      if ((unsigned int )loglevel___4 >= 1U) {
        {
#line 114
        __cil_tmp10 = logtime();
        }
        {
#line 114
        __cil_tmp11 = __errno_location();
#line 114
        __cil_tmp12 = strerror(*__cil_tmp11);
#line 114
        logprint("%s %s:%d failed writing to socket: %s\n", __cil_tmp10, "send_packet",
                 114, __cil_tmp12);
        }
      }
#line 115
      return;
    }
#line 117
    ptr += n;
#line 118
    len -= (unsigned long )n;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 122 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendHELO(int reconnect , char const   *fixed_cap , char const   *var_cap ,
                     u8_t mac[6] ) 
{ 
  char const   *base_cap ;
  struct HELO_packet pkt ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  __uint32_t __cil_tmp10 ;
  int tmp ;
  char const   *__cil_tmp12 ;
  char const   *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;

  {
  {
#line 135
  base_cap = "Model=squeezelite,AccuratePlayPoints=1,HasDigitalOut=1,HasPolarityInversion=1,Balance=1,Firmware=v1.9.9-1395";
#line 138
  memset(& pkt, 0, sizeof(pkt));
#line 139
  memcpy(& pkt.opcode, "HELO", (unsigned long )4);
#line 140
  __cil_tmp9 = strlen(var_cap);
  }
  {
#line 140
  __cil_tmp8 = strlen(fixed_cap);
  }
  {
#line 140
  __cil_tmp7 = strlen(base_cap);
#line 140
  __cil_tmp10 = __bswap_32((__uint32_t )((((sizeof(struct HELO_packet ) - 8UL) + __cil_tmp7) + __cil_tmp8) + __cil_tmp9));
#line 140
  pkt.length = __cil_tmp10;
#line 141
  pkt.deviceid = (u8_t )12;
#line 142
  pkt.revision = (u8_t )0;
  }
#line 143
  if (reconnect) {
#line 143
    tmp = 16384;
  } else {
#line 143
    tmp = 0;
  }
  {
#line 143
  packn(& pkt.wlan_channellist, (u16_t )tmp);
#line 144
  packN(& pkt.bytes_received_H, (u32_t )((u64_t )status.stream_bytes >> 32));
#line 145
  packN(& pkt.bytes_received_L, (u32_t )((u64_t )status.stream_bytes & 4294967295UL));
#line 146
  memcpy((u8_t *)pkt.mac, mac, (unsigned long )6);
  }
#line 148
  if ((unsigned int )loglevel___4 >= 2U) {
    {
#line 148
    __cil_tmp12 = logtime();
#line 148
    logprint("%s %s:%d mac: %02x:%02x:%02x:%02x:%02x:%02x\n", __cil_tmp12, "sendHELO\312\001D",
             148, (int )pkt.mac[0], (int )pkt.mac[1], (int )pkt.mac[2], (int )pkt.mac[3],
             (int )pkt.mac[4], (int )pkt.mac[5]);
    }
  }
#line 150
  if ((unsigned int )loglevel___4 >= 2U) {
    {
#line 150
    __cil_tmp13 = logtime();
#line 150
    logprint("%s %s:%d cap: %s%s%s\n", __cil_tmp13, "sendHELO\312\001D", 150, base_cap,
             fixed_cap, var_cap);
    }
  }
  {
#line 152
  send_packet((u8_t *)(& pkt), sizeof(pkt));
#line 153
  __cil_tmp14 = strlen(base_cap);
#line 153
  send_packet((u8_t *)base_cap, __cil_tmp14);
#line 154
  __cil_tmp15 = strlen(fixed_cap);
#line 154
  send_packet((u8_t *)fixed_cap, __cil_tmp15);
#line 155
  __cil_tmp16 = strlen(var_cap);
#line 155
  send_packet((u8_t *)var_cap, __cil_tmp16);
  }
  return;
}
}
#line 158 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendSTAT(char const   *event , u32_t server_timestamp ) 
{ 
  struct STAT_packet pkt ;
  u32_t now ;
  u32_t __cil_tmp5 ;
  u32_t ms_played ;
  char const   *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;
  __uint32_t __cil_tmp10 ;
  char const   *__cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {
  {
#line 160
  __cil_tmp5 = gettime_ms();
#line 160
  now = __cil_tmp5;
  }
#line 163
  if (status.current_sample_rate) {
#line 163
    if (status.frames_played) {
#line 163
      if (status.frames_played > status.device_frames) {
#line 164
        ms_played = (u32_t )(((u64_t )(status.frames_played - status.device_frames) * 1000UL) / (u64_t )status.current_sample_rate);
#line 165
        if (now > status.updated) {
#line 165
          ms_played += now - status.updated;
        }
#line 166
        if ((unsigned int )loglevel___4 >= 4U) {
          {
#line 166
          __cil_tmp7 = logtime();
#line 166
          logprint("%s %s:%d ms_played: %u (frames_played: %u device_frames: %u)\n",
                   __cil_tmp7, "sendSTAT\312\001D", 166, ms_played, status.frames_played,
                   status.device_frames);
          }
        }
      } else {
#line 163
        goto _L___34;
      }
    } else {
#line 163
      goto _L___34;
    }
  } else
  _L___34: /* CIL Label */ 
  _L___35: /* CIL Label */ 
#line 167
  if (status.frames_played) {
#line 167
    if (now > status.stream_start) {
#line 168
      ms_played = now - status.stream_start;
#line 169
      if ((unsigned int )loglevel___4 >= 4U) {
        {
#line 169
        __cil_tmp8 = logtime();
#line 169
        logprint("%s %s:%d ms_played: %u using elapsed time (frames_played: %u device_frames: %u)\n\230",
                 __cil_tmp8, "sendSTAT\312\001D", 169, ms_played, status.frames_played,
                 status.device_frames);
        }
      }
    } else {
#line 167
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 171
    if ((unsigned int )loglevel___4 >= 4U) {
      {
#line 171
      __cil_tmp9 = logtime();
#line 171
      logprint("%s %s:%d ms_played: 0\n", __cil_tmp9, "sendSTAT\312\001D", 171);
      }
    }
#line 172
    ms_played = (u32_t )0;
  }
  {
#line 175
  memset(& pkt, 0, sizeof(struct STAT_packet ));
#line 176
  memcpy(& pkt.opcode, "STAT", (unsigned long )4);
#line 177
  pkt.length = __bswap_32((__uint32_t )(sizeof(struct STAT_packet ) - 8UL));
#line 178
  memcpy(& pkt.event, event, (unsigned long )4);
#line 181
  packN(& pkt.stream_buffer_fullness, status.stream_full);
#line 182
  packN(& pkt.stream_buffer_size, status.stream_size);
#line 183
  packN(& pkt.bytes_received_H, (u32_t )((u64_t )status.stream_bytes >> 32));
#line 184
  packN(& pkt.bytes_received_L, (u32_t )((u64_t )status.stream_bytes & 4294967295UL));
#line 185
  pkt.signal_strength = (u16_t )65535;
#line 186
  packN(& pkt.jiffies, now);
#line 187
  packN(& pkt.output_buffer_size, status.output_size);
#line 188
  packN(& pkt.output_buffer_fullness, status.output_full);
#line 189
  packN(& pkt.elapsed_seconds, ms_played / 1000U);
#line 191
  packN(& pkt.elapsed_milliseconds, ms_played);
#line 192
  pkt.server_timestamp = server_timestamp;
  }
#line 195
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 195
    __cil_tmp11 = logtime();
#line 195
    logprint("%s %s:%d STAT: %s\n", __cil_tmp11, "sendSTAT\312\001D", 195, event);
    }
  }
#line 197
  if ((unsigned int )loglevel___4 == 4U) {
#line 198
    if ((unsigned int )loglevel___4 >= 4U) {
      {
#line 198
      __cil_tmp12 = logtime();
#line 198
      logprint("%s %s:%d received bytesL: %u streambuf: %u outputbuf: %u calc elapsed: %u real elapsed: %u (diff: %d) device: %u delay: %d\n",
               __cil_tmp12, "sendSTAT\312\001D", 198, (u32_t )status.stream_bytes,
               status.stream_full, status.output_full, ms_played, now - status.stream_start,
               (ms_played - now) + status.stream_start, (status.device_frames * 1000U) / status.current_sample_rate,
               now - status.updated);
      }
    }
  }
  {
#line 203
  send_packet((u8_t *)(& pkt), sizeof(pkt));
  }
  return;
}
}
#line 206 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendDSCO(disconnect_code disconnect ) 
{ 
  struct DSCO_packet pkt ;
  __uint32_t __cil_tmp3 ;
  char const   *__cil_tmp4 ;

  {
  {
#line 209
  memset(& pkt, 0, sizeof(pkt));
#line 210
  memcpy(& pkt.opcode, "DSCO", (unsigned long )4);
#line 211
  pkt.length = __bswap_32((__uint32_t )(sizeof(pkt) - 8UL));
#line 212
  pkt.reason = (u8_t )((unsigned int )disconnect & 255U);
  }
#line 214
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 214
    __cil_tmp4 = logtime();
#line 214
    logprint("%s %s:%d DSCO: %d\n", __cil_tmp4, "sendDSCO\312\001D", 214, (unsigned int )disconnect);
    }
  }
  {
#line 216
  send_packet((u8_t *)(& pkt), sizeof(pkt));
  }
  return;
}
}
#line 219 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendRESP(char const   *header , size_t len ) 
{ 
  struct RESP_header pkt_header ;
  __uint32_t __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 222
  memset(& pkt_header, 0, sizeof(pkt_header));
#line 223
  memcpy(& pkt_header.opcode, "RESP", (unsigned long )4);
#line 224
  pkt_header.length = __bswap_32((__uint32_t )((sizeof(pkt_header) + len) - 8UL));
  }
#line 226
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 226
    __cil_tmp5 = logtime();
#line 226
    logprint("%s %s:%d RESP\n", __cil_tmp5, "sendRESP\312\001D", 226);
    }
  }
  {
#line 228
  send_packet((u8_t *)(& pkt_header), sizeof(pkt_header));
#line 229
  send_packet((u8_t *)header, len);
  }
  return;
}
}
#line 232 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendMETA(char const   *meta , size_t len ) 
{ 
  struct META_header pkt_header ;
  __uint32_t __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 235
  memset(& pkt_header, 0, sizeof(pkt_header));
#line 236
  memcpy(& pkt_header.opcode, "META", (unsigned long )4);
#line 237
  pkt_header.length = __bswap_32((__uint32_t )((sizeof(pkt_header) + len) - 8UL));
  }
#line 239
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 239
    __cil_tmp5 = logtime();
#line 239
    logprint("%s %s:%d META\n", __cil_tmp5, "sendMETA\312\001D", 239);
    }
  }
  {
#line 241
  send_packet((u8_t *)(& pkt_header), sizeof(pkt_header));
#line 242
  send_packet((u8_t *)meta, len);
  }
  return;
}
}
#line 245 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void sendSETDName(char const   *name ) 
{ 
  struct SETD_header pkt_header ;
  unsigned long __cil_tmp3 ;
  __uint32_t __cil_tmp4 ;
  char const   *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 248
  memset(& pkt_header, 0, sizeof(pkt_header));
#line 249
  memcpy(& pkt_header.opcode, "SETD", (unsigned long )4);
#line 251
  pkt_header.id = (u8_t )0;
#line 252
  __cil_tmp3 = strlen(name);
#line 252
  __cil_tmp4 = __bswap_32((__uint32_t )(((sizeof(pkt_header) + __cil_tmp3) + 1UL) - 8UL));
#line 252
  pkt_header.length = __cil_tmp4;
  }
#line 254
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 254
    __cil_tmp5 = logtime();
#line 254
    logprint("%s %s:%d set playername: %s\n", __cil_tmp5, "sendSETDName", 254, name);
    }
  }
  {
#line 256
  send_packet((u8_t *)(& pkt_header), sizeof(pkt_header));
#line 257
  __cil_tmp6 = strlen(name);
#line 257
  send_packet((u8_t *)name, __cil_tmp6 + 1UL);
  }
  return;
}
}
#line 277 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_strm(u8_t *pkt , int len ) 
{ 
  struct strm_packet *strm ;
  char const   *__cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned int interval ;
  u32_t __cil_tmp7 ;
  u32_t __cil_tmp8 ;
  char const   *__cil_tmp9 ;
  unsigned int interval___0 ;
  u32_t __cil_tmp11 ;
  char const   *__cil_tmp12 ;
  unsigned int jiffies ;
  u32_t __cil_tmp14 ;
  int tmp ;
  char const   *__cil_tmp16 ;
  u32_t __cil_tmp17 ;
  unsigned int header_len ;
  char *header ;
  in_addr_t ip ;
  u16_t port ;
  char const   *__cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char const   *__cil_tmp24 ;
  char const   *__cil_tmp25 ;
  u32_t __cil_tmp26 ;
  char const   *__cil_tmp27 ;
  char const   *__cil_tmp28 ;

  {
#line 278
  strm = (struct strm_packet *)pkt;
#line 280
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 280
    __cil_tmp4 = logtime();
#line 280
    logprint("%s %s:%d strm command %c\n", __cil_tmp4, "process_strm", 280, (int )strm->command);
    }
  }
  {
#line 283
  if ((int )strm->command == 't') {
#line 283
    goto case_116;
  }
#line 286
  if ((int )strm->command == 'q') {
#line 286
    goto case_113;
  }
#line 294
  if ((int )strm->command == 'f') {
#line 294
    goto case_102;
  }
#line 303
  if ((int )strm->command == 'p') {
#line 303
    goto case_112;
  }
#line 319
  if ((int )strm->command == 'a') {
#line 319
    goto case_97;
  }
#line 329
  if ((int )strm->command == 'u') {
#line 329
    goto case_117;
  }
#line 341
  if ((int )strm->command == 's') {
#line 341
    goto case_115;
  }
#line 388
  goto switch_default;
  case_116: /* CIL Label */ 
  {
#line 284
  sendSTAT("STMt", strm->replay_gain);
  }
#line 285
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 287
  decode_flush();
  }
  {
#line 288
  output_flush();
#line 289
  status.frames_played = (u32_t )0;
#line 290
  stream_disconnect();
#line 291
  sendSTAT("STMf", (u32_t )0);
#line 292
  buf_flush(streambuf);
  }
#line 293
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 295
  decode_flush();
  }
  {
#line 296
  output_flush();
#line 297
  status.frames_played = (u32_t )0;
#line 298
  __cil_tmp5 = stream_disconnect();
  }
#line 298
  if (__cil_tmp5) {
    {
#line 299
    sendSTAT("STMf", (u32_t )0);
    }
  }
  {
#line 301
  buf_flush(streambuf);
  }
#line 302
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 305
  __cil_tmp7 = unpackN(& strm->replay_gain);
#line 305
  interval = __cil_tmp7;
#line 306
  pthread_mutex_lock(& outputbuf->mutex);
#line 307
  output.pause_frames = (interval * status.current_sample_rate) / 1000U;
  }
#line 308
  if (interval) {
#line 309
    output.state = (output_state )3;
  } else
#line 310
  if ((int )output.state != -1) {
    {
#line 311
    output.state = (output_state )0;
#line 312
    output.stop_time = gettime_ms();
    }
  }
  {
#line 314
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 315
  if (! interval) {
    {
#line 315
    sendSTAT("STMp", (u32_t )0);
    }
  }
#line 316
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 316
    __cil_tmp9 = logtime();
#line 316
    logprint("%s %s:%d pause interval: %u\n\301U", __cil_tmp9, "process_strm", 316,
             interval);
    }
  }
#line 318
  goto switch_break;
  case_97: /* CIL Label */ 
  {
#line 321
  __cil_tmp11 = unpackN(& strm->replay_gain);
#line 321
  interval___0 = __cil_tmp11;
#line 322
  pthread_mutex_lock(& outputbuf->mutex);
#line 323
  output.skip_frames = (interval___0 * status.current_sample_rate) / 1000U;
#line 324
  output.state = (output_state )4;
#line 325
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 326
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 326
    __cil_tmp12 = logtime();
#line 326
    logprint("%s %s:%d skip ahead interval: %u\n", __cil_tmp12, "process_strm", 326,
             interval___0);
    }
  }
#line 328
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 331
  __cil_tmp14 = unpackN(& strm->replay_gain);
#line 331
  jiffies = __cil_tmp14;
#line 332
  pthread_mutex_lock(& outputbuf->mutex);
  }
#line 333
  if (jiffies) {
#line 333
    tmp = 5;
  } else {
#line 333
    tmp = 2;
  }
  {
#line 333
  output.state = (output_state )tmp;
#line 334
  output.start_at = jiffies;
#line 335
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 337
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 337
    __cil_tmp16 = logtime();
    }
    {
#line 337
    __cil_tmp17 = gettime_ms();
#line 337
    logprint("%s %s:%d unpause at: %u now: %u\n\230", __cil_tmp16, "process_strm",
             337, jiffies, __cil_tmp17);
    }
  }
  {
#line 338
  sendSTAT("STMr", (u32_t )0);
  }
#line 340
  goto switch_break;
  case_115: /* CIL Label */ 
#line 343
  header_len = (unsigned int )((unsigned long )len - sizeof(struct strm_packet ));
#line 344
  header = (char *)(pkt + sizeof(struct strm_packet ));
#line 345
  ip = (in_addr_t )strm->server_ip;
#line 346
  port = strm->server_port;
#line 347
  if (ip == 0U) {
#line 347
    ip = slimproto_ip;
  }
#line 349
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 349
    __cil_tmp22 = logtime();
#line 349
    logprint("%s %s:%d strm s autostart: %c transition period: %u transition type: %u codec: %c\n",
             __cil_tmp22, "process_strm", 349, (int )strm->autostart, (int )strm->transition_period,
             (int )strm->transition_type - 48, (int )strm->format);
    }
  }
  {
#line 352
  autostart = (int )strm->autostart - 48;
#line 354
  sendSTAT("STMf", (u32_t )0);
  }
#line 355
  if (header_len > 4095U) {
#line 356
    if ((unsigned int )loglevel___4 >= 1U) {
      {
#line 356
      __cil_tmp23 = logtime();
#line 356
      logprint("%s %s:%d header too long: %u\n", __cil_tmp23, "process_strm", 356,
               header_len);
      }
    }
#line 357
    goto switch_break;
  }
#line 359
  if ((int )strm->format != 63) {
    {
#line 360
    codec_open(strm->format, strm->pcm_sample_size, strm->pcm_sample_rate, strm->pcm_channels,
               strm->pcm_endianness);
    }
  } else
#line 361
  if (autostart >= 2) {
#line 363
    if ((unsigned int )loglevel___4 >= 3U) {
      {
#line 363
      __cil_tmp24 = logtime();
#line 363
      logprint("%s %s:%d streaming unknown codec\n", __cil_tmp24, "process_strm",
               363);
      }
    }
  } else {
#line 365
    if ((unsigned int )loglevel___4 >= 1U) {
      {
#line 365
      __cil_tmp25 = logtime();
#line 365
      logprint("%s %s:%d unknown codec requires autostart >= 2\n", __cil_tmp25, "process_strm",
               365);
      }
    }
#line 366
    goto switch_break;
  }
#line 368
  if (ip == 16777343U) {
#line 368
    if ((int )port == 39693) {
      {
#line 370
      stream_file((char const   *)header, (size_t )header_len, (unsigned int )((int )strm->threshold * 1024));
#line 371
      autostart -= 2;
      }
    } else {
      {
      {
#line 373
      stream_sock(ip, port, (int )strm->flags & 32, (char const   *)header, (size_t )header_len,
                  (unsigned int )((int )strm->threshold * 1024), autostart >= 2);
      }
      }
    }
  } else {
    {
    {
#line 373
    stream_sock(ip, port, (int )strm->flags & 32, (char const   *)header, (size_t )header_len,
                (unsigned int )((int )strm->threshold * 1024), autostart >= 2);
    }
    }
  }
  {
#line 375
  sendSTAT("STMc", (u32_t )0);
#line 376
  sentSTMl = 0;
#line 376
  sentSTMo = sentSTMl;
#line 376
  sentSTMu = sentSTMo;
#line 377
  pthread_mutex_lock(& outputbuf->mutex);
#line 378
  output.threshold = (unsigned int )strm->output_threshold;
#line 379
  output.next_replay_gain = unpackN(& strm->replay_gain);
#line 380
  output.fade_mode = (fade_mode )((int )strm->transition_type - 48);
#line 381
  output.fade_secs = (unsigned int )strm->transition_period;
#line 382
  output.invert = ((int )strm->flags & 3) == 3;
#line 383
  output.channels = (u8_t )(((int )strm->flags & 12) >> 2);
  }
#line 384
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 384
    __cil_tmp27 = logtime();
#line 384
    logprint("%s %s:%d set fade mode: %u, channels: %u, invert: %u\n", __cil_tmp27,
             "process_strm", 384, (unsigned int )output.fade_mode, (int )output.channels,
             output.invert);
    }
  }
  {
#line 385
  pthread_mutex_unlock(& outputbuf->mutex);
  }
#line 387
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 389
  if ((unsigned int )loglevel___4 >= 1U) {
    {
#line 389
    __cil_tmp28 = logtime();
#line 389
    logprint("%s %s:%d unhandled strm %c\n", __cil_tmp28, "process_strm", 389, (int )strm->command);
    }
  }
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  return;
}
}
#line 394 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_cont(u8_t *pkt , int len ) 
{ 
  struct cont_packet *cont ;
  u32_t __cil_tmp4 ;
  char const   *__cil_tmp5 ;

  {
  {
#line 395
  cont = (struct cont_packet *)pkt;
#line 396
  cont->metaint = unpackN(& cont->metaint);
  }
#line 398
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 398
    __cil_tmp5 = logtime();
#line 398
    logprint("%s %s:%d cont metaint: %u loop: %u\n", __cil_tmp5, "process_cont", 398,
             cont->metaint, (int )cont->loop);
    }
  }
#line 400
  if (autostart > 1) {
    {
#line 401
    autostart -= 2;
#line 402
    pthread_mutex_lock(& streambuf->mutex);
    }
#line 403
    if ((unsigned int )stream.state == 2U) {
#line 404
      stream.state = (stream_state )3;
#line 405
      stream.meta_next = cont->metaint;
#line 405
      stream.meta_interval = stream.meta_next;
    }
    {
#line 407
    pthread_mutex_unlock(& streambuf->mutex);
#line 408
    wake_controller();
    }
  }
  return;
}
}
#line 412 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_codc(u8_t *pkt , int len ) 
{ 
  struct codc_packet *codc ;
  char const   *__cil_tmp4 ;

  {
#line 413
  codc = (struct codc_packet *)pkt;
#line 415
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 415
    __cil_tmp4 = logtime();
#line 415
    logprint("%s %s:%d codc: %c\n", __cil_tmp4, "process_codc", 415, (int )codc->format);
    }
  }
  {
#line 416
  codec_open(codc->format, codc->pcm_sample_size, codc->pcm_sample_rate, codc->pcm_channels,
             codc->pcm_endianness);
  }
  return;
}
}
#line 419 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_aude(u8_t *pkt , int len ) 
{ 
  struct aude_packet *aude ;
  char const   *__cil_tmp4 ;
  u32_t __cil_tmp5 ;

  {
#line 420
  aude = (struct aude_packet *)pkt;
#line 422
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 422
    __cil_tmp4 = logtime();
#line 422
    logprint("%s %s:%d enable spdif: %d dac: %d\n", __cil_tmp4, "process_aude", 422,
             (int )aude->enable_spdif, (int )aude->enable_dac);
    }
  }
  {
#line 424
  pthread_mutex_lock(& outputbuf->mutex);
  }
#line 425
  if (! aude->enable_spdif) {
#line 425
    if ((int )output.state != -1) {
#line 426
      output.state = (output_state )-1;
    }
  }
#line 428
  if ((int )aude->enable_spdif) {
#line 428
    if ((int )output.state == -1) {
#line 428
      if (! output.idle_to) {
        {
#line 429
        output.state = (output_state )0;
#line 430
        output.stop_time = gettime_ms();
        }
      }
    }
  }
  {
#line 432
  pthread_mutex_unlock(& outputbuf->mutex);
  }
  return;
}
}
#line 435 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_audg(u8_t *pkt , int len ) 
{ 
  struct audg_packet *audg ;
  u32_t __cil_tmp4 ;
  u32_t __cil_tmp5 ;
  char const   *__cil_tmp6 ;
  u32_t tmp ;
  u32_t tmp___0 ;

  {
  {
#line 436
  audg = (struct audg_packet *)pkt;
#line 437
  audg->gainL = unpackN(& audg->gainL);
#line 438
  audg->gainR = unpackN(& audg->gainR);
  }
#line 440
  if ((unsigned int )loglevel___4 >= 3U) {
    {
#line 440
    __cil_tmp6 = logtime();
#line 440
    logprint("%s %s:%d audg gainL: %u gainR: %u adjust: %u\n", __cil_tmp6, "process_audg",
             440, audg->gainL, audg->gainR, (int )audg->adjust);
    }
  }
#line 442
  if ((int )audg->adjust) {
#line 442
    tmp = audg->gainL;
  } else {
#line 442
    tmp = (unsigned int )65536;
  }
#line 442
  if ((int )audg->adjust) {
#line 442
    tmp___0 = audg->gainR;
  } else {
#line 442
    tmp___0 = (unsigned int )65536;
  }
  {
#line 442
  set_volume(tmp, tmp___0);
  }
  return;
}
}
#line 445 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_setd(u8_t *pkt , int len ) 
{ 
  struct setd_packet *setd ;
  unsigned long __cil_tmp4 ;
  char const   *__cil_tmp5 ;
  FILE *fp ;
  FILE *__cil_tmp7 ;
  char const   *__cil_tmp8 ;
  char const   *__cil_tmp9 ;

  {
#line 446
  setd = (struct setd_packet *)pkt;
#line 449
  if ((int )setd->id == 0) {
#line 450
    if (len == 5) {
      {
#line 451
      __cil_tmp4 = strlen((char const   *)((char *)player_name));
      }
#line 451
      if (__cil_tmp4) {
        {
#line 452
        sendSETDName((char const   *)((char *)player_name));
        }
      }
    } else
#line 454
    if (len > 5) {
      {
#line 455
      strncpy((char *)player_name, (char const   *)((char *)setd->data), (unsigned long )64);
#line 456
      player_name[64] = (char )'\000';
      }
#line 457
      if ((unsigned int )loglevel___4 >= 2U) {
        {
#line 457
        __cil_tmp5 = logtime();
#line 457
        logprint("%s %s:%d set name: %s\n", __cil_tmp5, "process_setd", 457, (char *)setd->data);
        }
      }
      {
#line 459
      sendSETDName((char const   *)((char *)setd->data));
      }
#line 461
      if (name_file) {
        {
#line 462
        __cil_tmp7 = fopen(name_file, "w");
#line 462
        fp = __cil_tmp7;
        }
#line 463
        if (fp) {
#line 464
          if ((unsigned int )loglevel___4 >= 2U) {
            {
#line 464
            __cil_tmp8 = logtime();
#line 464
            logprint("%s %s:%d storing name in %s\n", __cil_tmp8, "process_setd",
                     464, name_file);
            }
          }
          {
#line 465
          fputs((char const   *)((char *)player_name), fp);
#line 466
          fclose(fp);
          }
        } else
#line 468
        if ((unsigned int )loglevel___4 >= 1U) {
          {
#line 468
          __cil_tmp9 = logtime();
#line 468
          logprint("%s %s:%d unable to store new name in %s\n\230", __cil_tmp9, "process_setd",
                   468, name_file);
          }
        }
      }
    }
  }
  return;
}
}
#line 478 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process_serv(u8_t *pkt , int len ) 
{ 
  struct serv_packet *serv ;
  unsigned int slimproto_port ;
  char squeezeserver[22] ;
  char const   *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
#line 479
  serv = (struct serv_packet *)pkt;
#line 481
  slimproto_port = (unsigned int )0;
#line 482
  squeezeserver = "mysqueezebox.com:3483";
#line 484
  if ((int )*(pkt + 4) == 0) {
#line 484
    if ((int )*(pkt + 5) == 0) {
#line 484
      if ((int )*(pkt + 6) == 0) {
#line 484
        if ((int )*(pkt + 7) == 1) {
          {
#line 485
          server_addr((char *)squeezeserver, & new_server, & slimproto_port);
          }
        } else {
#line 487
          new_server = serv->server_ip;
        }
      } else {
#line 487
        new_server = serv->server_ip;
      }
    } else {
#line 487
      new_server = serv->server_ip;
    }
  } else {
#line 487
    new_server = serv->server_ip;
  }
#line 490
  if ((unsigned int )loglevel___4 >= 2U) {
    {
#line 490
    __cil_tmp6 = logtime();
#line 490
    logprint("%s %s:%d switch server\n", __cil_tmp6, "process_serv", 490);
    }
  }
#line 492
  if ((unsigned long )len - sizeof(struct serv_packet ) == 10UL) {
#line 493
    if (! new_server_cap) {
      {
#line 494
      new_server_cap = (char *)malloc((unsigned long )24);
      }
    }
    {
#line 496
    *(new_server_cap + 0) = (char )'\000';
#line 497
    strcat(new_server_cap, ",SyncgroupID=");
#line 498
    strncat(new_server_cap, (char const   *)(pkt + sizeof(struct serv_packet )), (unsigned long )10);
    }
  } else
#line 500
  if (new_server_cap) {
    {
#line 501
    free(new_server_cap);
#line 502
    new_server_cap = (char *)((void *)0);
    }
  }
  return;
}
}
#line 512 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static struct handler handlers[8]  = 
#line 512
  {      {{"strm", & process_strm, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"cont",
       & process_cont, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"codc",
       & process_codc, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"aude",
       & process_aude, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"audg",
       & process_audg, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"setd",
       & process_setd, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"serv",
       & process_serv, (char )0, (char )0, (char )0}, (void (*)(u8_t * , int  ))0}, 
        {{"\251",
       (void (*)(u8_t * , int  ))((void *)0), (char )0, (char )0, (char )0}, (void (*)(u8_t * ,
                                                                                       int  ))0}};
#line 523 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void process___0(u8_t *pack , int len ) 
{ 
  struct handler *h ;
  int __cil_tmp4 ;
  struct handler *__cil_tmp5 ;
  char const   *__cil_tmp6 ;
  char const   *__cil_tmp7 ;

  {
#line 524
  h = (struct handler *)handlers;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 525
    __cil_tmp4 = strncmp((char const   *)((char *)pack), (char const   *)((char *)h->opcode),
                         (unsigned long )4);
    }
#line 525
    if (! (h->handler && __cil_tmp4)) {
#line 525
      goto while_break;
    }
#line 525
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  if (h->handler) {
#line 528
    if ((unsigned int )loglevel___4 >= 3U) {
      {
#line 528
      __cil_tmp6 = logtime();
#line 528
      logprint("%s %s:%d %s\n", __cil_tmp6, "process", 528, (char *)h->opcode);
      }
    }
    {
#line 529
    (*(h->handler))(pack, len);
    }
  } else {
#line 531
    *(pack + 4) = (u8_t )'\000';
#line 532
    if ((unsigned int )loglevel___4 >= 1U) {
      {
#line 532
      __cil_tmp7 = logtime();
#line 532
      logprint("%s %s:%d unhandled %s\n", __cil_tmp7, "process", 532, (char *)pack);
      }
    }
  }
  return;
}
}
#line 536
static int running___3 ;
#line 538 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
static void slimproto_run(void) 
{ 
  static u8_t buffer[4096] ;
  int expect ;
  int got ;
  u32_t now ;
  static u32_t last ;
  struct pollfd ehandles[2] ;
  int timeouts ;
  int wake ;
  event_type ev ;
  event_type __cil_tmp10 ;
  int n ;
  ssize_t __cil_tmp12 ;
  int *__cil_tmp13 ;
  char const   *__cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *tmp ;
  int n___0 ;
  ssize_t __cil_tmp19 ;
  int *__cil_tmp20 ;
  char const   *__cil_tmp21 ;
  int *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *tmp___0 ;
  char const   *__cil_tmp25 ;
  char const   *__cil_tmp26 ;
  char const   *__cil_tmp27 ;
  u32_t __cil_tmp28 ;
  int _sendSTMs ;
  int _sendDSCO ;
  int _sendRESP ;
  int _sendMETA ;
  int _sendSTMd ;
  int _sendSTMt ;
  int _sendSTMl ;
  int _sendSTMu ;
  int _sendSTMo ;
  int _sendSTMn ;
  int _stream_disconnect ;
  int _start_output ;
  decode_state _decode_state ;
  disconnect_code disconnect_code ;
  static char header[4096] ;
  size_t header_len ;
  unsigned int __cil_tmp45 ;
  unsigned int __cil_tmp46 ;
  char const   *__cil_tmp47 ;
  char const   *__cil_tmp48 ;

  {
  {
#line 540
  expect = 0;
#line 541
  got = 0;
#line 543
  last = (u32_t )0;
#line 545
  timeouts = 0;
#line 547
  set_readwake_handles((struct pollfd *)ehandles, sock, wake_e);
  }
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
#line 549
    if (! (running___3 && ! new_server)) {
#line 549
      goto while_break;
    }
    {
#line 551
    wake = 0;
#line 554
    ev = wait_readwake((struct pollfd *)ehandles, 1000);
    }
#line 554
    if ((unsigned int )ev != 0U) {
#line 556
      if ((unsigned int )ev == 1U) {
#line 558
        if (expect > 0) {
          {
#line 559
          __cil_tmp12 = recv(sock, (u8_t *)buffer + got, (size_t )expect, 0);
#line 559
          n = (int )__cil_tmp12;
          }
#line 560
          if (n <= 0) {
            {
#line 561
            __cil_tmp13 = __errno_location();
            }
#line 561
            if (n < 0) {
#line 561
              if (*__cil_tmp13 == 11) {
#line 562
                goto while_continue;
              }
            }
#line 564
            if ((unsigned int )loglevel___4 >= 2U) {
              {
#line 564
              __cil_tmp14 = logtime();
              }
#line 564
              if (n) {
                {
#line 564
                __cil_tmp15 = __errno_location();
#line 564
                __cil_tmp16 = strerror(*__cil_tmp15);
#line 564
                tmp = __cil_tmp16;
                }
              } else {
#line 564
                tmp = (char *)"closed";
              }
              {
#line 564
              logprint("%s %s:%d error reading from socket: %s\n", __cil_tmp14, "slimproto_run",
                       564, (int )tmp);
              }
            }
#line 565
            return;
          }
#line 567
          expect -= n;
#line 568
          got += n;
#line 569
          if (expect == 0) {
            {
#line 570
            process___0((u8_t *)buffer, got);
#line 571
            got = 0;
            }
          }
        } else
#line 573
        if (expect == 0) {
          {
#line 574
          __cil_tmp19 = recv(sock, (u8_t *)buffer + got, (size_t )(2 - got), 0);
#line 574
          n___0 = (int )__cil_tmp19;
          }
#line 575
          if (n___0 <= 0) {
            {
#line 576
            __cil_tmp20 = __errno_location();
            }
#line 576
            if (n___0 < 0) {
#line 576
              if (*__cil_tmp20 == 11) {
#line 577
                goto while_continue;
              }
            }
#line 579
            if ((unsigned int )loglevel___4 >= 2U) {
              {
#line 579
              __cil_tmp21 = logtime();
              }
#line 579
              if (n___0) {
                {
#line 579
                __cil_tmp22 = __errno_location();
#line 579
                __cil_tmp23 = strerror(*__cil_tmp22);
#line 579
                tmp___0 = __cil_tmp23;
                }
              } else {
#line 579
                tmp___0 = (char *)"closed";
              }
              {
#line 579
              logprint("%s %s:%d error reading from socket: %s\n", __cil_tmp21, "slimproto_run",
                       579, (int )tmp___0);
              }
            }
#line 580
            return;
          }
#line 582
          got += n___0;
#line 583
          if (got == 2) {
#line 584
            expect = ((int )buffer[0] << 8) | (int )buffer[1];
#line 585
            got = 0;
#line 586
            if (expect > 4096) {
              {
#line 587
              __cil_tmp25 = logtime();
#line 587
              logprint("%s %s:%d FATAL: slimproto packet too big: %d > %d\n", __cil_tmp25,
                       "slimproto_run", 587, expect, 4096);
              }
#line 588
              return;
            }
          }
        } else {
          {
#line 592
          __cil_tmp26 = logtime();
#line 592
          logprint("%s %s:%d FATAL: negative expect\n\230", __cil_tmp26, "slimproto_run",
                   592);
          }
#line 593
          return;
        }
      }
#line 598
      if ((unsigned int )ev == 2U) {
#line 599
        wake = 1;
      }
#line 602
      timeouts = 0;
    } else {
#line 604
      timeouts ++;
#line 604
      if (timeouts > 35) {
#line 607
        if ((unsigned int )loglevel___4 >= 2U) {
          {
#line 607
          __cil_tmp27 = logtime();
#line 607
          logprint("%s %s:%d No messages from server - connection dead\n", __cil_tmp27,
                   "slimproto_run", 607);
          }
        }
#line 608
        return;
      }
    }
    {
#line 612
    now = gettime_ms();
    }
#line 614
    if (wake) {
      _L___38: /* CIL Label */ 
      _L___39: /* CIL Label */ 
      {
#line 615
      _sendSTMs = 0;
#line 616
      _sendDSCO = 0;
#line 617
      _sendRESP = 0;
#line 618
      _sendMETA = 0;
#line 619
      _sendSTMd = 0;
#line 620
      _sendSTMt = 0;
#line 621
      _sendSTMl = 0;
#line 622
      _sendSTMu = 0;
#line 623
      _sendSTMo = 0;
#line 624
      _sendSTMn = 0;
#line 625
      _stream_disconnect = 0;
#line 626
      _start_output = 0;
#line 630
      header_len = (size_t )0;
#line 635
      last = now;
#line 638
      pthread_mutex_lock(& streambuf->mutex);
#line 639
      status.stream_full = _buf_used(streambuf);
#line 640
      status.stream_size = (u32_t )streambuf->size;
#line 641
      status.stream_bytes = stream.bytes;
#line 642
      status.stream_state = stream.state;
      }
#line 644
      if ((unsigned int )stream.state == 1U) {
#line 645
        disconnect_code = stream.disconnect;
#line 646
        stream.state = (stream_state )0;
#line 647
        _sendDSCO = 1;
      }
#line 649
      if (! stream.sent_headers) {
#line 649
        if ((unsigned int )stream.state == 5U) {
          {
#line 651
          header_len = stream.header_len;
          {
          {
#line 652
          memcpy((char *)header, stream.header, header_len);
          }
          }
#line 653
          _sendRESP = 1;
#line 654
          stream.sent_headers = 1;
          }
        } else
#line 649
        if ((unsigned int )stream.state == 2U) {
          {
#line 651
          header_len = stream.header_len;
          {
          {
#line 652
          memcpy((char *)header, stream.header, header_len);
          }
          }
#line 653
          _sendRESP = 1;
#line 654
          stream.sent_headers = 1;
          }
        } else
#line 649
        if ((unsigned int )stream.state == 3U) {
          {
#line 651
          header_len = stream.header_len;
          {
          {
#line 652
          memcpy((char *)header, stream.header, header_len);
          }
          }
#line 653
          _sendRESP = 1;
#line 654
          stream.sent_headers = 1;
          }
        }
      }
#line 656
      if (stream.meta_send) {
        {
#line 657
        header_len = stream.header_len;
#line 658
        memcpy((char *)header, stream.header, header_len);
#line 659
        _sendMETA = 1;
#line 660
        stream.meta_send = 0;
        }
      }
      {
#line 662
      pthread_mutex_unlock(& streambuf->mutex);
#line 664
      pthread_mutex_lock(& decode.mutex);
      }
#line 665
      if ((unsigned int )status.stream_state == 5U) {
        _L: /* CIL Label */ 
        _L___36: /* CIL Label */ 
#line 665
        if (! sentSTMl) {
#line 665
          if ((unsigned int )decode.state == 1U) {
#line 668
            if (autostart == 0) {
#line 669
              decode.state = (decode_state )2;
#line 670
              _sendSTMl = 1;
#line 671
              sentSTMl = 1;
            } else
#line 672
            if (autostart == 1) {
#line 673
              decode.state = (decode_state )2;
#line 674
              _start_output = 1;
            }
          }
        }
      } else
#line 665
      if ((unsigned int )status.stream_state == 4U) {
#line 665
        goto _L;
      } else
#line 665
      if ((unsigned int )status.stream_state == 1U) {
#line 665
        if ((unsigned int )stream.disconnect == 0U) {
#line 665
          goto _L;
        }
      }
#line 678
      if ((unsigned int )decode.state == 3U) {
        _L___37: /* CIL Label */ 
#line 679
        if ((unsigned int )decode.state == 3U) {
#line 679
          _sendSTMd = 1;
        }
#line 680
        if ((unsigned int )decode.state == 4U) {
#line 680
          _sendSTMn = 1;
        }
#line 681
        decode.state = (decode_state )0;
#line 682
        if ((unsigned int )status.stream_state == 5U) {
#line 683
          _stream_disconnect = 1;
        } else
#line 682
        if ((unsigned int )status.stream_state == 4U) {
#line 683
          _stream_disconnect = 1;
        }
      } else
#line 678
      if ((unsigned int )decode.state == 4U) {
#line 678
        goto _L___37;
      }
      {
#line 686
      _decode_state = decode.state;
#line 687
      pthread_mutex_unlock(& decode.mutex);
#line 689
      pthread_mutex_lock(& outputbuf->mutex);
#line 690
      status.output_full = _buf_used(outputbuf);
#line 691
      status.output_size = (u32_t )outputbuf->size;
#line 692
      status.frames_played = output.frames_played_dmp;
#line 693
      status.current_sample_rate = output.current_sample_rate;
#line 694
      status.updated = output.updated;
#line 695
      status.device_frames = output.device_frames;
      }
#line 697
      if (output.track_started) {
#line 698
        _sendSTMs = 1;
#line 699
        output.track_started = 0;
#line 700
        status.stream_start = output.track_start_time;
      }
#line 708
      if (_start_output) {
#line 708
        if ((int )output.state == 0) {
#line 709
          output.state = (output_state )1;
        } else
#line 708
        if ((int )output.state == -1) {
#line 709
          output.state = (output_state )1;
        }
      }
#line 711
      if ((int )output.state == 2) {
#line 711
        if (! sentSTMu) {
#line 711
          if (status.output_full == 0U) {
#line 711
            if ((unsigned int )status.stream_state <= 1U) {
#line 711
              if ((unsigned int )_decode_state == 0U) {
#line 714
                _sendSTMu = 1;
#line 715
                sentSTMu = 1;
#line 716
                if ((unsigned int )loglevel___4 >= 3U) {
                  {
#line 716
                  __cil_tmp47 = logtime();
#line 716
                  logprint("%s %s:%d output underrun\n", __cil_tmp47, "slimproto_run",
                           716);
                  }
                }
#line 717
                output.state = (output_state )0;
#line 718
                output.stop_time = now;
              }
            }
          }
        }
      }
#line 720
      if ((int )output.state == 2) {
#line 720
        if (! sentSTMo) {
#line 720
          if (status.output_full == 0U) {
#line 720
            if ((unsigned int )status.stream_state == 5U) {
#line 722
              _sendSTMo = 1;
#line 723
              sentSTMo = 1;
            }
          }
        }
      }
#line 725
      if ((int )output.state == 0) {
#line 725
        if (output.idle_to) {
#line 725
          if (now - output.stop_time > output.idle_to) {
#line 726
            output.state = (output_state )-1;
#line 727
            if ((unsigned int )loglevel___4 >= 3U) {
              {
#line 727
              __cil_tmp48 = logtime();
#line 727
              logprint("%s %s:%d output timeout\n\230", __cil_tmp48, "slimproto_run",
                       727);
              }
            }
          }
        }
      }
#line 729
      if ((int )output.state == 2) {
#line 729
        if (now - status.last > 1000U) {
#line 730
          _sendSTMt = 1;
#line 731
          status.last = now;
        }
      }
      {
#line 733
      pthread_mutex_unlock(& outputbuf->mutex);
      }
#line 746
      if (_stream_disconnect) {
        {
#line 746
        stream_disconnect();
        }
      }
#line 749
      if (_sendDSCO) {
        {
#line 749
        sendDSCO(disconnect_code);
        }
      }
#line 750
      if (_sendSTMs) {
        {
#line 750
        sendSTAT("STMs", (u32_t )0);
        }
      }
#line 751
      if (_sendSTMd) {
        {
#line 751
        sendSTAT("STMd", (u32_t )0);
        }
      }
#line 752
      if (_sendSTMt) {
        {
#line 752
        sendSTAT("STMt", (u32_t )0);
        }
      }
#line 753
      if (_sendSTMl) {
        {
#line 753
        sendSTAT("STMl", (u32_t )0);
        }
      }
#line 754
      if (_sendSTMu) {
        {
#line 754
        sendSTAT("STMu", (u32_t )0);
        }
      }
#line 755
      if (_sendSTMo) {
        {
#line 755
        sendSTAT("STMo", (u32_t )0);
        }
      }
#line 756
      if (_sendSTMn) {
        {
#line 756
        sendSTAT("STMn", (u32_t )0);
        }
      }
#line 757
      if (_sendRESP) {
        {
#line 757
        sendRESP((char const   *)((char *)header), header_len);
        }
      }
#line 758
      if (_sendMETA) {
        {
#line 758
        sendMETA((char const   *)((char *)header), header_len);
        }
      }
    } else
#line 614
    if (now - last > 100U) {
#line 614
      goto _L___38;
    } else
#line 614
    if (last > now) {
#line 614
      goto _L___38;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 767 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
void wake_controller(void) 
{ 


  {
  {
#line 768
  eventfd_write(wake_e, (eventfd_t )1);
  }
  return;
}
}
#line 771 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
in_addr_t discover_server(char *default_server ) 
{ 
  struct sockaddr_in d ;
  struct sockaddr_in s ;
  char *buf___2 ;
  struct pollfd pollinfo ;
  unsigned int port ;
  int disc_sock ;
  int __cil_tmp8 ;
  socklen_t enable ;
  __uint16_t __cil_tmp10 ;
  __uint32_t __cil_tmp11 ;
  char const   *__cil_tmp12 ;
  ssize_t __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  int __cil_tmp15 ;
  char readbuf[10] ;
  socklen_t slen ;
  char const   *__cil_tmp18 ;
  char *__cil_tmp19 ;
  __uint16_t __cil_tmp20 ;

  {
  {
#line 778
  __cil_tmp8 = socket(2, 2, 0);
#line 778
  disc_sock = __cil_tmp8;
#line 780
  enable = (socklen_t )1;
#line 781
  setsockopt(disc_sock, 1, 6, (void const   *)(& enable), (socklen_t )sizeof(enable));
#line 783
  buf___2 = "e";
#line 785
  memset(& d, 0, sizeof(d));
#line 786
  d.sin_family = (sa_family_t )2;
#line 787
  d.sin_port = __bswap_16((__uint16_t )3483);
#line 788
  d.sin_addr.s_addr = __bswap_32((in_addr_t )4294967295U);
#line 790
  pollinfo.fd = disc_sock;
#line 791
  pollinfo.events = (short )1;
  }
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if ((unsigned int )loglevel___4 >= 2U) {
      {
#line 795
      __cil_tmp12 = logtime();
#line 795
      logprint("%s %s:%d sending discovery\n", __cil_tmp12, "discover_server", 795);
      }
    }
    {
#line 796
    memset(& s, 0, sizeof(s));
#line 798
    __cil_tmp13 = sendto(disc_sock, buf___2, (size_t )1, 0, (struct sockaddr *)(& d),
                         (socklen_t )sizeof(d));
    }
#line 798
    if (__cil_tmp13 < 0L) {
#line 799
      if ((unsigned int )loglevel___4 >= 2U) {
        {
#line 799
        __cil_tmp14 = logtime();
#line 799
        logprint("%s %s:%d error sending disovery\n\230", __cil_tmp14, "discover_server",
                 799);
        }
      }
    }
    {
#line 802
    __cil_tmp15 = poll(& pollinfo, (nfds_t )1, 5000);
    }
#line 802
    if (__cil_tmp15 == 1) {
      {
#line 804
      slen = (socklen_t )sizeof(s);
#line 805
      recvfrom(disc_sock, (char *)readbuf, (size_t )10, 0, (struct sockaddr *)(& s),
               & slen);
      }
#line 806
      if ((unsigned int )loglevel___4 >= 2U) {
        {
#line 806
        __cil_tmp18 = logtime();
        }
        {
#line 806
        __cil_tmp19 = inet_ntoa(s.sin_addr);
        }
        {
#line 806
        __cil_tmp20 = __bswap_16(s.sin_port);
#line 806
        logprint("%s %s:%d got response from: %s:%d\n\260g\301U", __cil_tmp18, "discover_server",
                 806, __cil_tmp19, (int )__cil_tmp20);
        }
      }
    }
#line 809
    if (default_server) {
      {
#line 810
      server_addr(default_server, & s.sin_addr.s_addr, & port);
      }
    }
#line 793
    if (! (s.sin_addr.s_addr == 0U && running___3)) {
#line 793
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 815
  close(disc_sock);
  }
#line 817
  return (s.sin_addr.s_addr);
}
}
#line 823 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
void slimproto(log_level level , char *server , u8_t mac[6] , char const   *name ,
               char const   *namefile , char const   *modelname , int maxSampleRate ) 
{ 
  struct sockaddr_in serv_addr ;
  static char fixed_cap[256] ;
  static char var_cap[128] ;
  int reconnect ;
  unsigned int failed_connect ;
  unsigned int slimproto_port ;
  in_addr_t previous_server ;
  int i ;
  int __cil_tmp16 ;
  in_addr_t __cil_tmp17 ;
  FILE *fp ;
  FILE *__cil_tmp19 ;
  char *__cil_tmp20 ;
  int len ;
  unsigned long __cil_tmp22 ;
  char const   *__cil_tmp23 ;
  char const   *tmp ;
  unsigned int tmp___0 ;
  unsigned long __cil_tmp26 ;
  int __cil_tmp27 ;
  __uint16_t __cil_tmp28 ;
  char const   *__cil_tmp29 ;
  char *__cil_tmp30 ;
  __uint16_t __cil_tmp31 ;
  char const   *__cil_tmp32 ;
  char *__cil_tmp33 ;
  __uint16_t __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  char const   *__cil_tmp37 ;
  char *__cil_tmp38 ;
  __uint16_t __cil_tmp39 ;
  char const   *__cil_tmp40 ;
  in_addr_t __cil_tmp41 ;
  struct sockaddr_in our_addr ;
  socklen_t len___0 ;
  char const   *__cil_tmp44 ;
  char const   *__cil_tmp45 ;

  {
  {
#line 825
  var_cap = "\002";
#line 826
  reconnect = 0;
#line 827
  failed_connect = (unsigned int )0;
#line 828
  slimproto_port = (unsigned int )0;
#line 829
  previous_server = (in_addr_t )0;
#line 832
  memset(& status, 0, sizeof(status));
#line 834
  wake_e = eventfd((unsigned int )0, 0);
#line 836
  loglevel___4 = level;
#line 837
  running___3 = 1;
  }
#line 839
  if (server) {
    {
#line 840
    server_addr(server, & slimproto_ip, & slimproto_port);
    }
  }
#line 843
  if (! slimproto_ip) {
    {
#line 844
    slimproto_ip = discover_server(server);
    }
  }
#line 847
  if (! slimproto_port) {
#line 848
    slimproto_port = (unsigned int )3483;
  }
#line 851
  if (name) {
    {
#line 852
    strncpy((char *)player_name, name, (unsigned long )64);
#line 853
    player_name[64] = (char )'\000';
    }
  }
#line 856
  if (namefile) {
    {
#line 858
    name_file = namefile;
#line 859
    fp = fopen(namefile, "r");
    }
#line 860
    if (fp) {
      {
#line 861
      __cil_tmp20 = fgets((char *)player_name, 64, fp);
      }
#line 861
      if (! __cil_tmp20) {
#line 862
        player_name[64] = (char )'\000';
      } else {
        {
#line 865
        __cil_tmp22 = strlen((char const   *)((char *)player_name));
#line 865
        len = (int )__cil_tmp22;
        }
#line 866
        if (len > 0) {
#line 866
          if ((int )player_name[len - 1] == 10) {
#line 867
            player_name[len - 1] = (char )'\000';
          }
        }
#line 869
        if ((unsigned int )loglevel___4 >= 2U) {
          {
#line 869
          __cil_tmp23 = logtime();
#line 869
          logprint("%s %s:%d retrieved name %s from %s\n", __cil_tmp23, "slimproto",
                   869, (char *)player_name, name_file);
          }
        }
      }
      {
#line 871
      fclose(fp);
      }
    }
  }
#line 875
  if (! running___3) {
#line 875
    return;
  }
  {
#line 877
  pthread_mutex_lock(& outputbuf->mutex);
  }
#line 878
  if (modelname) {
#line 878
    tmp = modelname;
  } else {
#line 878
    tmp = "SqueezeLite";
  }
#line 878
  if (maxSampleRate > 0 && (unsigned int )maxSampleRate < output.supported_rates[0]) {
#line 878
    tmp___0 = (unsigned int )maxSampleRate;
  } else {
#line 878
    tmp___0 = output.supported_rates[0];
  }
  {
#line 878
  snprintf((char *)fixed_cap, (unsigned long )256, ",ModelName=%s,MaxSampleRate=%u",
           tmp, tmp___0);
#line 885
  i = 0;
  }
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! (i < 10)) {
#line 885
      goto while_break;
    }
    {
#line 886
    __cil_tmp26 = strlen((char const   *)((char *)fixed_cap));
    }
#line 886
    if (codecs[i]) {
#line 886
      if ((int )(codecs[i])->id) {
#line 886
        if (__cil_tmp26 < 246UL) {
          {
#line 887
          strcat((char *)fixed_cap, ",B\261g\301U");
#line 888
          strcat((char *)fixed_cap, (char const   *)(codecs[i])->types);
          }
        }
      }
    }
#line 885
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 891
  pthread_mutex_unlock(& outputbuf->mutex);
#line 893
  memset(& serv_addr, 0, sizeof(serv_addr));
#line 894
  serv_addr.sin_family = (sa_family_t )2;
#line 895
  serv_addr.sin_addr.s_addr = slimproto_ip;
#line 896
  serv_addr.sin_port = __bswap_16((__uint16_t )slimproto_port);
  }
#line 898
  if ((unsigned int )loglevel___4 >= 2U) {
    {
#line 898
    __cil_tmp29 = logtime();
    }
    {
#line 898
    __cil_tmp30 = inet_ntoa(serv_addr.sin_addr);
    }
    {
#line 898
    __cil_tmp31 = __bswap_16(serv_addr.sin_port);
#line 898
    logprint("%s %s:%d connecting to %s:%d\n", __cil_tmp29, "slimproto", 898, __cil_tmp30,
             (int )__cil_tmp31);
    }
  }
#line 900
  new_server = (u32_t )0;
  {
#line 902
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 902
    if (! running___3) {
#line 902
      goto while_break___0;
    }
#line 904
    if (new_server) {
#line 905
      previous_server = slimproto_ip;
#line 906
      serv_addr.sin_addr.s_addr = new_server;
#line 906
      slimproto_ip = serv_addr.sin_addr.s_addr;
#line 907
      if ((unsigned int )loglevel___4 >= 2U) {
        {
#line 907
        __cil_tmp32 = logtime();
        }
        {
#line 907
        __cil_tmp33 = inet_ntoa(serv_addr.sin_addr);
        }
        {
#line 907
        __cil_tmp34 = __bswap_16(serv_addr.sin_port);
#line 907
        logprint("%s %s:%d switching server to %s:%d\ng\301U", __cil_tmp32, "slimprotou\260g\301U",
                 907, __cil_tmp33, (int )__cil_tmp34);
        }
      }
#line 908
      new_server = (u32_t )0;
#line 909
      reconnect = 0;
    }
    {
#line 912
    sock = socket(2, 1, 0);
#line 914
    set_nonblock(sock);
#line 917
    __cil_tmp36 = connect_timeout(sock, (struct sockaddr *)(& serv_addr), (socklen_t )sizeof(serv_addr),
                                  5);
    }
#line 917
    if (__cil_tmp36 != 0) {
#line 919
      if (previous_server) {
#line 920
        serv_addr.sin_addr.s_addr = previous_server;
#line 920
        slimproto_ip = serv_addr.sin_addr.s_addr;
#line 921
        if ((unsigned int )loglevel___4 >= 2U) {
          {
#line 921
          __cil_tmp37 = logtime();
          }
          {
#line 921
          __cil_tmp38 = inet_ntoa(serv_addr.sin_addr);
          }
          {
#line 921
          __cil_tmp39 = __bswap_16(serv_addr.sin_port);
#line 921
          logprint("%s %s:%d new server not reachable, reverting to previous server %s:%d\n",
                   __cil_tmp37, "slimproto", 921, __cil_tmp38, (int )__cil_tmp39);
          }
        }
      } else {
#line 923
        if ((unsigned int )loglevel___4 >= 2U) {
          {
#line 923
          __cil_tmp40 = logtime();
#line 923
          logprint("%s %s:%d unable to connect to server %u\n\230", __cil_tmp40, "slimprotoQ\261g\301U",
                   923, failed_connect);
          }
        }
        {
#line 924
        sleep((unsigned int )5);
        }
      }
#line 928
      failed_connect ++;
#line 928
      if (! server) {
#line 928
        if (failed_connect > 5U) {
          {
#line 929
          slimproto_ip = discover_server((char *)((void *)0));
          }
        }
      }
    } else {
#line 937
      if ((unsigned int )loglevel___4 >= 2U) {
        {
#line 937
        __cil_tmp44 = logtime();
#line 937
        logprint("%s %s:%d connected\ng\301U", __cil_tmp44, "slimprotoa\260g\301U",
                 937);
        }
      }
      {
#line 939
      var_cap[0] = (char )'\000';
#line 940
      failed_connect = (unsigned int )0;
#line 944
      len___0 = (socklen_t )sizeof(our_addr);
#line 945
      getsockname(sock, (struct sockaddr *)(& our_addr), & len___0);
      }
#line 947
      if (our_addr.sin_addr.s_addr == serv_addr.sin_addr.s_addr) {
#line 948
        if ((unsigned int )loglevel___4 >= 2U) {
          {
#line 948
          __cil_tmp45 = logtime();
#line 948
          logprint("%s %s:%d local player\n", __cil_tmp45, "slimproto", 948);
          }
        }
        {
#line 949
        strcat((char *)var_cap, ",loc\301U");
        }
      }
#line 953
      if (new_server_cap) {
        {
#line 954
        strcat((char *)var_cap, (char const   *)new_server_cap);
#line 955
        free(new_server_cap);
#line 956
        new_server_cap = (char *)((void *)0);
        }
      }
      {
#line 959
      sendHELO(reconnect, (char const   *)((char *)fixed_cap), (char const   *)((char *)var_cap),
               mac);
#line 961
      slimproto_run();
      }
#line 963
      if (! reconnect) {
#line 964
        reconnect = 1;
      }
      {
#line 967
      usleep((__useconds_t )100000);
      }
    }
    {
#line 970
    previous_server = (in_addr_t )0;
#line 972
    close(sock);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 976 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/slimproto.c"
void slimproto_stop(void) 
{ 
  char const   *__cil_tmp1 ;

  {
#line 977
  if ((unsigned int )loglevel___4 >= 2U) {
    {
#line 977
    __cil_tmp1 = logtime();
#line 977
    logprint("%s %s:%d slimproto stop\n\230", __cil_tmp1, "slimproto_stop", 977);
    }
  }
#line 978
  running___3 = 0;
  return;
}
}
#line 58 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/main.c"
static void usage(char const   *argv0 ) 
{ 


  {
  {
#line 59
  printf("Squeezelite v1.9.9-1395, Copyright 2012-2015 Adrian Smith, 2015-2021 Ralph Irving. See -t for license terms\nUsage: %s [options]\n  -s <server>[:<port>]\tConnect to specified server, otherwise uses autodiscovery to find server\n  -o <output device>\tSpecify output device, default \"default\", - = output to stdout\n  -l \t\t\tList output devices\n  -a <b>:<p>:<f>:<m>\tSpecify ALSA params to open output device, b = buffer time in ms or size in bytes, p = period count or size in bytes, f sample format (16|24|24_3|32), m = use mmap (0|1)\n  -a <f>\t\tSpecify sample format (16|24|32) of output file when using -o - to output samples to stdout (interleaved little endian only)\n  -b <stream>:<output>\tSpecify internal Stream and Output buffer sizes in Kbytes\n  -c <codec1>,<codec2>\tRestrict codecs to those specified, otherwise load all available codecs; known codecs: flac,pcm,mp3,ogg,aac (mad,mpg for specific mp3 codec)\n  \t\t\tCodecs reported to LMS in order listed, allowing codec priority refinement.\n  -C <timeout>\t\tClose output device when idle after timeout seconds, default is to keep it open while player is \'on\'\n  -d <log>=<level>\tSet logging level, logs: all|slimproto|stream|decode|output, level: info|debug|sdebug\n  -e <codec1>,<codec2>\tExplicitly exclude native support of one or more codecs; known codecs: flac,pcm,mp3,ogg,aac (mad,mpg for specific mp3 codec)\n  -f <logfile>\t\tWrite debug to logfile\n  -m <mac addr>\t\tSet mac address, format: ab:cd:ef:12:34:56\n  -M <modelname>\tSet the squeezelite player model name sent to the server (default: SqueezeLite)\n  -n <name>\t\tSet the player name\n  -N <filename>\t\tStore player name in filename to allow server defined name changes to be shared between servers (not supported with -n)\n  -W\t\t\tRead wave and aiff format from header, ignore server parameters\n  -p <priority>\t\tSet real time priority of output thread (1-99)\n  -P <filename>\t\tStore the process id (PID) in filename\n  -r <rates>[:<delay>]\tSample rates supported, allows output to be off when squeezelite is started; rates = <maxrate>|<minrate>-<maxrate>|<rate1>,<rate2>,<rate3>; delay = optional delay switching rates in ms\n  -O <mixer device>\tSpecify mixer device, defaults to \'output device\'\n  -L \t\t\tList volume controls for output device\n  -U <control>\t\tUnmute ALSA control and set to full volume (not supported with -V)\n  -V <control>\t\tUse ALSA control for volume adjustment, otherwise use software volume adjustment\n  -X \t\t\tUse linear volume adjustments instead of in terms of dB (only for hardware volume control)\n  -z \t\t\tDaemonize\n  -Z <rate>\t\tReport rate to server in helo as the maximum sample rate we can support\n  -t \t\t\tLicense terms\n  -? \t\t\tDisplay this help text\n\nBuild options: LINUX ALSA EVENTFD\n\n",
         argv0);
  }
  return;
}
}
#line 231 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/main.c"
static void license(void) 
{ 


  {
  {
#line 232
  printf("Squeezelite v1.9.9-1395, Copyright 2012-2015 Adrian Smith, 2015-2021 Ralph Irving.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nThe Squeezelite source code is available on github.\n<https://github.com/ralph-irving/squeezelite>\n\nThe source and patches for bundled 3rd party libraries can be found on\nSourceForge. <https://sourceforge.net/projects/lmsclients/files/source/>\n\nOption to allow server side upsampling for PCM streams (-W) from\nsqueezelite-R2 (c) Marco Curti 2015, marcoc1712@gmail.com.\n\n");
  }
  return;
}
}
#line 276 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/main.c"
static void sighandler(int signum ) 
{ 


  {
  {
#line 277
  slimproto_stop();
#line 280
  signal(signum, (__sighandler_t )0);
  }
  return;
}
}
#line 283 "/root/patron-artifact/pkg/i_files/squeezelite-pulseaudio_tmp/squeezelite-1.9.9-1395+git20220104.874e4f9/main.c"
int main(int argc , char **argv ) 
{ 
  char *server ;
  char *output_device ;
  char *include_codecs ;
  char *exclude_codecs ;
  char *name ;
  char *namefile ;
  char *modelname ;
  extern int pcm_check_header___0 ;
  extern int user_rates___0 ;
  char *logfile ;
  u8_t mac[6] ;
  unsigned int stream_buf_size ;
  unsigned int output_buf_size ;
  unsigned int rates[20] ;
  unsigned int tmp ;
  unsigned int rate_delay ;
  char *resample ;
  char *output_params ;
  unsigned int idle ;
  int daemonize ;
  char *pidfile ;
  FILE *pidfp ;
  unsigned int rt_priority ;
  char *mixer_device ;
  char *output_mixer ;
  int output_mixer_unmute ;
  int linear_volume ;
  log_level log_output ;
  log_level log_stream ;
  log_level log_decode ;
  log_level log_slimproto ;
  int maxSampleRate ;
  char *optarg___40 ;
  int optind___41 ;
  int i ;
  char cmdline[512] ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  char *opt ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *s ;
  char *__cil_tmp47 ;
  char *o ;
  char *__cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  char *l ;
  char *__cil_tmp55 ;
  char *v___0 ;
  char *__cil_tmp57 ;
  log_level new ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int byte ;
  char *tmp___0 ;
  int __cil_tmp72 ;
  char const   *__cil_tmp73 ;
  char *t ;
  char *__cil_tmp75 ;
  int __cil_tmp76 ;
  unsigned long __cil_tmp77 ;
  char *__cil_tmp78 ;
  char *rstr ;
  char *__cil_tmp80 ;
  char *dstr ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *r ;
  char *__cil_tmp85 ;
  unsigned int tmp___1[20] ;
  unsigned int tmp___42 ;
  int i___43 ;
  int j ;
  int last ;
  int __cil_tmp91 ;
  char *__cil_tmp92 ;
  int largest ;
  unsigned int ref[20] ;
  char *str1 ;
  char *__cil_tmp96 ;
  char *str2 ;
  char *__cil_tmp98 ;
  unsigned int max ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int min ;
  int __cil_tmp105 ;
  int tmp___45 ;
  unsigned int tmp___46 ;
  int i___44 ;
  int j___0 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  unsigned int scale___0 ;
  FILE *__cil_tmp115 ;
  int *__cil_tmp116 ;
  char *__cil_tmp117 ;
  FILE *__cil_tmp118 ;
  int *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  int tmp___47 ;
  int __cil_tmp123 ;
  int *__cil_tmp124 ;
  char *__cil_tmp125 ;
  __pid_t __cil_tmp126 ;
  int __cil_tmp127 ;
  int __cil_tmp128 ;

  {
#line 284
  server = (char *)((void *)0);
#line 285
  output_device = "default";
#line 286
  include_codecs = (char *)((void *)0);
#line 287
  exclude_codecs = "\220";
#line 288
  name = (char *)((void *)0);
#line 289
  namefile = (char *)((void *)0);
#line 290
  modelname = (char *)((void *)0);
#line 293
  logfile = (char *)((void *)0);
#line 295
  stream_buf_size = (unsigned int )2097152;
#line 296
  output_buf_size = (unsigned int )0;
#line 297
  rates[0] = (unsigned int )0;
#line 297
  tmp = (unsigned int )1;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (tmp >= 20) {
#line 297
      goto while_break;
    }
#line 297
    rates[tmp] = 0;
#line 297
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 298
  rate_delay = (unsigned int )0;
#line 299
  resample = (char *)((void *)0);
#line 300
  output_params = (char *)((void *)0);
#line 301
  idle = (unsigned int )0;
#line 303
  daemonize = 0;
#line 304
  pidfile = (char *)((void *)0);
#line 305
  pidfp = (FILE *)((void *)0);
#line 308
  rt_priority = (unsigned int )45;
#line 309
  mixer_device = output_device;
#line 310
  output_mixer = (char *)((void *)0);
#line 311
  output_mixer_unmute = 0;
#line 312
  linear_volume = 0;
#line 325
  log_output = (log_level )1;
#line 326
  log_stream = (log_level )1;
#line 327
  log_decode = (log_level )1;
#line 328
  log_slimproto = (log_level )1;
#line 333
  maxSampleRate = 0;
#line 335
  optarg___40 = (char *)((void *)0);
#line 336
  optind___41 = 1;
#line 340
  cmdline = "\f";
#line 342
  get_mac((u8_t *)mac);
#line 344
  i = 0;
  }
  {
#line 344
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 344
    if (! (i < argc && (__cil_tmp39 + __cil_tmp40) + 2UL < 512UL)) {
#line 344
      goto while_break___0;
    }
    {
#line 345
    strcat((char *)cmdline, (char const   *)*(argv + i));
#line 346
    strcat((char *)cmdline, " ");
    }
#line 344
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 349
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 349
    __cil_tmp42 = strlen((char const   *)*(argv + optind___41));
    }
#line 349
    if (! ((optind___41 < argc && __cil_tmp42 >= 2UL) && (int )*(*(argv + optind___41) + 0) == 45)) {
#line 349
      goto while_break___1;
    }
    {
#line 350
    opt = *(argv + optind___41) + 1;
#line 351
    __cil_tmp44 = strstr("oabcCdefmMnNpPrsZUVO\230\001", (char const   *)opt);
    }
#line 351
    if (__cil_tmp44) {
#line 351
      if (optind___41 < argc - 1) {
#line 356
        optarg___40 = *(argv + (optind___41 + 1));
#line 357
        optind___41 += 2;
      } else {
#line 351
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 358
      __cil_tmp45 = strstr("ltz?WLX", (char const   *)opt);
      }
#line 358
      if (__cil_tmp45) {
#line 382
        optarg___40 = (char *)((void *)0);
#line 383
        optind___41 ++;
      } else {
        {
#line 385
        fprintf(stderr, "\nOption error: -%s\n\n", opt);
#line 386
        usage((char const   *)*(argv + 0));
#line 387
        exit(1);
        }
      }
    }
    {
#line 391
    if ((int )*(opt + 0) == 'o') {
#line 391
      goto case_111;
    }
#line 397
    if ((int )*(opt + 0) == 'a') {
#line 397
      goto case_97;
    }
#line 400
    if ((int )*(opt + 0) == 'b') {
#line 400
      goto case_98;
    }
#line 408
    if ((int )*(opt + 0) == 'c') {
#line 408
      goto case_99;
    }
#line 411
    if ((int )*(opt + 0) == 'C') {
#line 411
      goto case_67;
    }
#line 416
    if ((int )*(opt + 0) == 'e') {
#line 416
      goto case_101;
    }
#line 419
    if ((int )*(opt + 0) == 'd') {
#line 419
      goto case_100;
    }
#line 442
    if ((int )*(opt + 0) == 'f') {
#line 442
      goto case_102;
    }
#line 445
    if ((int )*(opt + 0) == 'm') {
#line 445
      goto case_109;
    }
#line 460
    if ((int )*(opt + 0) == 'M') {
#line 460
      goto case_77;
    }
#line 463
    if ((int )*(opt + 0) == 'r') {
#line 463
      goto case_114;
    }
#line 511
    if ((int )*(opt + 0) == 's') {
#line 511
      goto case_115;
    }
#line 514
    if ((int )*(opt + 0) == 'n') {
#line 514
      goto case_110;
    }
#line 517
    if ((int )*(opt + 0) == 'N') {
#line 517
      goto case_78;
    }
#line 520
    if ((int )*(opt + 0) == 'Z') {
#line 520
      goto case_90;
    }
#line 523
    if ((int )*(opt + 0) == 'W') {
#line 523
      goto case_87;
    }
#line 527
    if ((int )*(opt + 0) == 'p') {
#line 527
      goto case_112;
    }
#line 537
    if ((int )*(opt + 0) == 'P') {
#line 537
      goto case_80;
    }
#line 541
    if ((int )*(opt + 0) == 'l') {
#line 541
      goto case_108;
    }
#line 581
    if ((int )*(opt + 0) == 'O') {
#line 581
      goto case_79;
    }
#line 584
    if ((int )*(opt + 0) == 'L') {
#line 584
      goto case_76;
    }
#line 588
    if ((int )*(opt + 0) == 'X') {
#line 588
      goto case_88;
    }
#line 591
    if ((int )*(opt + 0) == 'U') {
#line 591
      goto case_85;
    }
#line 593
    if ((int )*(opt + 0) == 'V') {
#line 593
      goto case_86;
    }
#line 670
    if ((int )*(opt + 0) == 'z') {
#line 670
      goto case_122;
    }
#line 677
    if ((int )*(opt + 0) == 't') {
#line 677
      goto case_116;
    }
#line 680
    if ((int )*(opt + 0) == '?') {
#line 680
      goto case_63;
    }
#line 683
    goto switch_default;
    case_111: /* CIL Label */ 
#line 392
    output_device = optarg___40;
#line 394
    mixer_device = optarg___40;
#line 396
    goto switch_break;
    case_97: /* CIL Label */ 
#line 398
    output_params = optarg___40;
#line 399
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 402
    __cil_tmp47 = next_param(optarg___40, (char )':');
#line 402
    s = __cil_tmp47;
#line 403
    __cil_tmp49 = next_param((char *)((void *)0), (char )':');
#line 403
    o = __cil_tmp49;
    }
#line 404
    if (s) {
      {
#line 404
      __cil_tmp50 = atoi((char const   *)s);
#line 404
      stream_buf_size = (unsigned int )(__cil_tmp50 * 1024);
      }
    }
#line 405
    if (o) {
      {
#line 405
      __cil_tmp51 = atoi((char const   *)o);
#line 405
      output_buf_size = (unsigned int )(__cil_tmp51 * 1024);
      }
    }
#line 407
    goto switch_break;
    case_99: /* CIL Label */ 
#line 409
    include_codecs = optarg___40;
#line 410
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 412
    __cil_tmp52 = atoi((char const   *)optarg___40);
    }
#line 412
    if (__cil_tmp52 > 0) {
      {
#line 413
      __cil_tmp53 = atoi((char const   *)optarg___40);
#line 413
      idle = (unsigned int )(__cil_tmp53 * 1000);
      }
    }
#line 415
    goto switch_break;
    case_101: /* CIL Label */ 
#line 417
    exclude_codecs = optarg___40;
#line 418
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 421
    __cil_tmp55 = strtok(optarg___40, "=");
#line 421
    l = __cil_tmp55;
#line 422
    __cil_tmp57 = strtok((char *)((void *)0), "=");
#line 422
    v___0 = __cil_tmp57;
#line 423
    new = (log_level )1;
    }
#line 424
    if (l) {
#line 424
      if (v___0) {
        {
#line 425
        __cil_tmp59 = strcmp((char const   *)v___0, "info");
        }
#line 425
        if (! __cil_tmp59) {
#line 425
          new = (log_level )2;
        }
        {
#line 426
        __cil_tmp60 = strcmp((char const   *)v___0, "debug");
        }
#line 426
        if (! __cil_tmp60) {
#line 426
          new = (log_level )3;
        }
        {
#line 427
        __cil_tmp61 = strcmp((char const   *)v___0, "sdebug");
        }
#line 427
        if (! __cil_tmp61) {
#line 427
          new = (log_level )4;
        }
        {
#line 428
        __cil_tmp63 = strcmp((char const   *)l, "slimproto");
        }
        {
#line 428
        __cil_tmp62 = strcmp((char const   *)l, "all");
        }
#line 428
        if (! __cil_tmp62) {
#line 428
          log_slimproto = new;
        } else
#line 428
        if (! __cil_tmp63) {
#line 428
          log_slimproto = new;
        }
        {
#line 429
        __cil_tmp65 = strcmp((char const   *)l, "stream");
        }
        {
#line 429
        __cil_tmp64 = strcmp((char const   *)l, "all");
        }
#line 429
        if (! __cil_tmp64) {
#line 429
          log_stream = new;
        } else
#line 429
        if (! __cil_tmp65) {
#line 429
          log_stream = new;
        }
        {
#line 430
        __cil_tmp67 = strcmp((char const   *)l, "decode");
        }
        {
#line 430
        __cil_tmp66 = strcmp((char const   *)l, "all");
        }
#line 430
        if (! __cil_tmp66) {
#line 430
          log_decode = new;
        } else
#line 430
        if (! __cil_tmp67) {
#line 430
          log_decode = new;
        }
        {
#line 431
        __cil_tmp69 = strcmp((char const   *)l, "output");
        }
        {
#line 431
        __cil_tmp68 = strcmp((char const   *)l, "all");
        }
#line 431
        if (! __cil_tmp68) {
#line 431
          log_output = new;
        } else
#line 431
        if (! __cil_tmp69) {
#line 431
          log_output = new;
        }
      } else {
        {
        {
#line 436
        fprintf(stderr, "\nDebug settings error: -d %s\n\n", optarg___40);
        }
        {
#line 437
        usage((char const   *)*(argv + 0));
        }
        {
#line 438
        exit(1);
        }
        }
      }
    } else {
      {
      {
#line 436
      fprintf(stderr, "\nDebug settings error: -d %s\n\n", optarg___40);
      }
      {
#line 437
      usage((char const   *)*(argv + 0));
      }
      {
#line 438
      exit(1);
      }
      }
    }
#line 441
    goto switch_break;
    case_102: /* CIL Label */ 
#line 443
    logfile = optarg___40;
#line 444
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 447
    byte = 0;
#line 449
    __cil_tmp72 = strncmp((char const   *)optarg___40, "00:04:20\251", (unsigned long )8);
    }
#line 449
    if (! __cil_tmp72) {
      {
#line 450
      __cil_tmp73 = logtime();
#line 450
      logprint("%s %s:%d ignoring mac address from hardware player range 00:04:20:**:**:**\n",
               __cil_tmp73, "main", 450);
      }
    } else {
      {
#line 452
      __cil_tmp75 = strtok(optarg___40, ":");
#line 452
      t = __cil_tmp75;
      }
      {
#line 453
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 453
        if (! (t && byte < 6)) {
#line 453
          goto while_break___2;
        }
        {
#line 454
        __cil_tmp77 = strtoul((char const   *)t, & tmp___0, 16);
        }
        {
#line 454
        __cil_tmp76 = byte;
#line 454
        byte ++;
#line 454
        mac[__cil_tmp76] = (u8_t )__cil_tmp77;
#line 455
        t = strtok((char *)((void *)0), ":");
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 459
    goto switch_break;
    case_77: /* CIL Label */ 
#line 461
    modelname = optarg___40;
#line 462
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 465
    __cil_tmp80 = next_param(optarg___40, (char )':');
#line 465
    rstr = __cil_tmp80;
#line 466
    __cil_tmp82 = next_param((char *)((void *)0), (char )':');
#line 466
    dstr = __cil_tmp82;
#line 467
    __cil_tmp83 = strstr((char const   *)rstr, ",");
    }
#line 467
    if (rstr) {
#line 467
      if (__cil_tmp83) {
        {
#line 469
        __cil_tmp85 = next_param(rstr, (char )',');
#line 469
        r = __cil_tmp85;
#line 470
        tmp___1[0] = (unsigned int )0;
        }
#line 470
        tmp___42 = (unsigned int )1;
        {
#line 470
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 470
          if (tmp___42 >= 20) {
#line 470
            goto while_break___3;
          }
#line 470
          tmp___1[tmp___42] = 0;
#line 470
          tmp___42 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 472
        last = 999999;
#line 473
        i___43 = 0;
        {
#line 473
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 473
          if (! (r && i___43 < 20)) {
#line 473
            goto while_break___4;
          }
          {
#line 474
          __cil_tmp91 = atoi((char const   *)r);
#line 474
          tmp___1[i___43] = (unsigned int )__cil_tmp91;
#line 475
          r = next_param((char *)((void *)0), (char )',');
          }
#line 473
          i___43 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 477
        i___43 = 0;
        {
#line 477
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 477
          if (! (i___43 < 20)) {
#line 477
            goto while_break___5;
          }
#line 478
          largest = 0;
#line 479
          j = 0;
          {
#line 479
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 479
            if (! (j < 20)) {
#line 479
              goto while_break___6;
            }
#line 480
            if (tmp___1[j] > (unsigned int )largest) {
#line 480
              if (tmp___1[j] < (unsigned int )last) {
#line 481
                largest = (int )tmp___1[j];
              }
            }
#line 479
            j ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 484
          last = largest;
#line 484
          rates[i___43] = (unsigned int )last;
#line 477
          i___43 ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
#line 467
        goto _L___45;
      }
    } else
    _L___45: /* CIL Label */ 
#line 486
    if (rstr) {
      {
#line 488
      ref[0] = (unsigned int )1536000;
#line 488
      ref[1] = (unsigned int )1411200;
#line 488
      ref[2] = (unsigned int )768000;
#line 488
      ref[3] = (unsigned int )705600;
#line 488
      ref[4] = (unsigned int )384000;
#line 488
      ref[5] = (unsigned int )352800;
#line 488
      ref[6] = (unsigned int )192000;
#line 488
      ref[7] = (unsigned int )176400;
#line 488
      ref[8] = (unsigned int )96000;
#line 488
      ref[9] = (unsigned int )88200;
#line 488
      ref[10] = (unsigned int )48000;
#line 488
      ref[11] = (unsigned int )44100;
#line 488
      ref[12] = (unsigned int )32000;
#line 488
      ref[13] = (unsigned int )24000;
#line 488
      ref[14] = (unsigned int )22500;
#line 488
      ref[15] = (unsigned int )16000;
#line 488
      ref[16] = (unsigned int )12000;
#line 488
      ref[17] = (unsigned int )11025;
#line 488
      ref[18] = (unsigned int )8000;
#line 488
      ref[19] = (unsigned int )0;
#line 489
      __cil_tmp96 = next_param(rstr, (char )'-');
#line 489
      str1 = __cil_tmp96;
#line 490
      __cil_tmp98 = next_param((char *)((void *)0), (char )'-');
#line 490
      str2 = __cil_tmp98;
      }
#line 491
      if (str2) {
        {
#line 491
        __cil_tmp100 = atoi((char const   *)str2);
#line 491
        tmp___44 = (unsigned int )__cil_tmp100;
        }
      } else {
#line 491
        if (str1) {
          {
#line 491
          __cil_tmp101 = atoi((char const   *)str1);
#line 491
          tmp___43 = (unsigned int )__cil_tmp101;
          }
        } else {
#line 491
          tmp___43 = ref[0];
        }
#line 491
        tmp___44 = tmp___43;
      }
#line 491
      max = tmp___44;
#line 492
      if (str1 && str2) {
        {
#line 492
        __cil_tmp105 = atoi((char const   *)str1);
#line 492
        tmp___45 = __cil_tmp105;
        }
      } else {
#line 492
        tmp___45 = 0;
      }
#line 492
      min = (unsigned int )tmp___45;
#line 495
      if (max < min) {
#line 495
        tmp___46 = max;
#line 495
        max = min;
#line 495
        min = tmp___46;
      }
#line 496
      rates[0] = max;
#line 497
      j___0 = 1;
#line 497
      i___44 = 0;
      {
#line 497
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 497
        if (! (i___44 < 20)) {
#line 497
          goto while_break___7;
        }
#line 498
        if (ref[i___44] < rates[j___0 - 1]) {
#line 498
          if (ref[i___44] >= min) {
#line 499
            __cil_tmp110 = j___0;
#line 499
            j___0 ++;
#line 499
            rates[__cil_tmp110] = ref[i___44];
          }
        }
#line 497
        i___44 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 503
    if (dstr) {
      {
#line 504
      __cil_tmp111 = atoi((char const   *)dstr);
#line 504
      rate_delay = (unsigned int )__cil_tmp111;
      }
    }
#line 506
    if (rates[0]) {
#line 507
      user_rates___0 = 1;
    }
#line 510
    goto switch_break;
    case_115: /* CIL Label */ 
#line 512
    server = optarg___40;
#line 513
    goto switch_break;
    case_110: /* CIL Label */ 
#line 515
    name = optarg___40;
#line 516
    goto switch_break;
    case_78: /* CIL Label */ 
#line 518
    namefile = optarg___40;
#line 519
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 521
    maxSampleRate = atoi((char const   *)optarg___40);
    }
#line 522
    goto switch_break;
    case_87: /* CIL Label */ 
#line 524
    pcm_check_header___0 = 1;
#line 525
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 528
    __cil_tmp113 = atoi((char const   *)optarg___40);
#line 528
    rt_priority = (unsigned int )__cil_tmp113;
    }
#line 529
    if (rt_priority > 99U) {
      {
      {
#line 530
      fprintf(stderr, "\nError: invalid priority: %s\n\n", optarg___40);
      }
      {
#line 531
      usage((char const   *)*(argv + 0));
      }
      {
#line 532
      exit(1);
      }
      }
    } else
#line 529
    if (rt_priority < 1U) {
      {
      {
#line 530
      fprintf(stderr, "\nError: invalid priority: %s\n\n", optarg___40);
      }
      {
#line 531
      usage((char const   *)*(argv + 0));
      }
      {
#line 532
      exit(1);
      }
      }
    }
#line 534
    goto switch_break;
    case_80: /* CIL Label */ 
#line 538
    pidfile = optarg___40;
#line 539
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 542
    list_devices();
    }
    {
#line 543
    exit(0);
    }
#line 544
    goto switch_break;
    case_79: /* CIL Label */ 
#line 582
    mixer_device = optarg___40;
#line 583
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 585
    list_mixers((char const   *)mixer_device);
    }
    {
#line 586
    exit(0);
    }
#line 587
    goto switch_break;
    case_88: /* CIL Label */ 
#line 589
    linear_volume = 1;
#line 590
    goto switch_break;
    case_85: /* CIL Label */ 
#line 592
    output_mixer_unmute = 1;
    case_86: /* CIL Label */ 
#line 594
    if (output_mixer) {
      {
#line 595
      fprintf(stderr, "-U and -V option should not be used at same time\n");
#line 596
      exit(1);
      }
    }
#line 598
    output_mixer = optarg___40;
#line 599
    goto switch_break;
    case_122: /* CIL Label */ 
#line 671
    daemonize = 1;
#line 675
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 678
    license();
    }
    {
#line 679
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 681
    usage((char const   *)*(argv + 0));
    }
    {
#line 682
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 684
    fprintf(stderr, "Arg error: %s\n", *(argv + optind___41));
    }
#line 685
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 690
  if (optind___41 < argc) {
    {
#line 691
    fprintf(stderr, "\nError: command line argument error\n\n");
#line 692
    usage((char const   *)*(argv + 0));
#line 693
    exit(1);
    }
  }
  {
#line 696
  signal(2, & sighandler);
#line 697
  signal(15, & sighandler);
#line 699
  signal(3, & sighandler);
#line 702
  signal(1, & sighandler);
  }
#line 710
  if (! output_buf_size) {
#line 711
    output_buf_size = (unsigned int )3528000;
#line 712
    if (resample) {
#line 713
      scale___0 = (unsigned int )8;
#line 714
      if (rates[0]) {
#line 715
        scale___0 = rates[0] / 44100U;
#line 716
        if (scale___0 > 8U) {
#line 716
          scale___0 = (unsigned int )8;
        }
#line 717
        if (scale___0 < 1U) {
#line 717
          scale___0 = (unsigned int )1;
        }
      }
#line 719
      output_buf_size *= scale___0;
    }
  }
#line 723
  if (logfile) {
    {
#line 724
    __cil_tmp115 = freopen((char const   *)logfile, "a", stderr);
    }
#line 724
    if (! __cil_tmp115) {
      {
#line 725
      __cil_tmp116 = __errno_location();
#line 725
      __cil_tmp117 = strerror(*__cil_tmp116);
#line 725
      fprintf(stderr, "error opening logfile %s: %s\n", logfile, __cil_tmp117);
      }
    } else
#line 727
    if ((unsigned int )log_output >= 2U) {
      {
      {
      {
      {
#line 728
      fprintf(stderr, "\n%s\n", (char *)cmdline);
      }
      }
      }
      }
    } else
#line 727
    if ((unsigned int )log_stream >= 2U) {
      {
      {
      {
      {
#line 728
      fprintf(stderr, "\n%s\n", (char *)cmdline);
      }
      }
      }
      }
    } else
#line 727
    if ((unsigned int )log_decode >= 2U) {
      {
      {
      {
      {
#line 728
      fprintf(stderr, "\n%s\n", (char *)cmdline);
      }
      }
      }
      }
    } else
#line 727
    if ((unsigned int )log_slimproto >= 2U) {
      {
      {
      {
      {
#line 728
      fprintf(stderr, "\n%s\n", (char *)cmdline);
      }
      }
      }
      }
    }
  }
#line 734
  if (pidfile) {
    {
#line 735
    pidfp = fopen((char const   *)pidfile, "w");
    }
#line 735
    if (! pidfp) {
      {
#line 736
      __cil_tmp119 = __errno_location();
#line 736
      __cil_tmp120 = strerror(*__cil_tmp119);
#line 736
      fprintf(stderr, "Error opening pidfile %s: %s\n", pidfile, __cil_tmp120);
#line 737
      exit(1);
      }
    }
    {
#line 739
    pidfile = realpath((char const   *)pidfile, (char *)((void *)0));
    }
  }
#line 742
  if (daemonize) {
#line 743
    if (logfile) {
#line 743
      tmp___47 = 1;
    } else {
#line 743
      tmp___47 = 0;
    }
    {
#line 743
    __cil_tmp123 = daemon(0, tmp___47);
    }
#line 743
    if (__cil_tmp123) {
      {
#line 744
      __cil_tmp124 = __errno_location();
#line 744
      __cil_tmp125 = strerror(*__cil_tmp124);
#line 744
      fprintf(stderr, "error daemonizing: %s\n", __cil_tmp125);
      }
    }
  }
#line 748
  if (pidfp) {
    {
#line 749
    __cil_tmp126 = getpid();
#line 749
    fprintf(pidfp, "%d\n", (int )__cil_tmp126);
#line 750
    fclose(pidfp);
    }
  }
  {
#line 758
  stream_init(log_stream, stream_buf_size);
#line 760
  __cil_tmp127 = strcmp((char const   *)output_device, "-");
  }
#line 760
  if (! __cil_tmp127) {
    {
#line 761
    output_init_stdout(log_output, output_buf_size, output_params, (unsigned int *)rates,
                       rate_delay);
    }
  } else {
    {
#line 764
    output_init_alsa(log_output, (char const   *)output_device, output_buf_size, output_params,
                     (unsigned int *)rates, rate_delay, rt_priority, idle, mixer_device,
                     output_mixer, output_mixer_unmute, linear_volume);
    }
  }
  {
#line 785
  decode_init(log_decode, (char const   *)include_codecs, (char const   *)exclude_codecs);
  }
#line 799
  if (name) {
#line 799
    if (namefile) {
      {
#line 800
      fprintf(stderr, "-n and -N option should not be used at same time\n");
#line 801
      exit(1);
      }
    }
  }
  {
#line 804
  slimproto(log_slimproto, server, (u8_t *)mac, (char const   *)name, (char const   *)namefile,
            (char const   *)modelname, maxSampleRate);
#line 806
  decode_close();
#line 807
  stream_close();
#line 809
  __cil_tmp128 = strcmp((char const   *)output_device, "-");
  }
#line 809
  if (! __cil_tmp128) {
    {
#line 810
    output_close_stdout();
    }
  } else {
    {
#line 813
    output_close_alsa();
    }
  }
#line 832
  if (pidfile) {
    {
#line 833
    unlink((char const   *)pidfile);
#line 834
    free(pidfile);
    }
  }
  {
#line 842
  exit(0);
  }
}
}
