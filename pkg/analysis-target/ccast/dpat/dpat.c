/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_3 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_3 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_4 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_4 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_5 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_5 lldiv_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 64 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 97 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 103 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_6 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_6 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_7 {
   __fd_mask __fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_7 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_9 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_8 {
   unsigned long long __value64 ;
   struct __anonstruct_9 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_8 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_10 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_10 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_11 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_11 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_12 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_12 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_13 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_13 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_14 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_14 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_15 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_15 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_16 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_16 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_17 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_17 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_18 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_18 pthread_barrierattr_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 934
enum __anonenum__19 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 49 "/usr/include/time.h"
struct sigevent ;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_22 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_23 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_24 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_25 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_28 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_27 {
   struct __anonstruct_28 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_26 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_27 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_29 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_30 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_21 {
   int _pad[28] ;
   struct __anonstruct_22 _kill ;
   struct __anonstruct_23 _timer ;
   struct __anonstruct_24 _rt ;
   struct __anonstruct_25 _sigchld ;
   struct __anonstruct_26 _sigfault ;
   struct __anonstruct_29 _sigpoll ;
   struct __anonstruct_30 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_20 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_21 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_20 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__31 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__32 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__33 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__34 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__35 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 176
enum __anonenum__36 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__37 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_39 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_38 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_39 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_38 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__40 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_41 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_41 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_42 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_42  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_43 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_43 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_44 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_44 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__45 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__46 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__47 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum__48 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 82 "/usr/include/glob.h"
struct __anonstruct_49 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * , void * ) ;
   int (*gl_stat)(char const   * , void * ) ;
};
#line 105 "/usr/include/glob.h"
typedef struct __anonstruct_49 glob_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_50 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_50 cpu_set_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__51 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__52 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0
} ;
#line 69
enum __anonenum__53 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__54 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__55 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__56 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__57 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__58 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__59 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__60 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_61 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_61 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 290 "numlib/numsup.h"
struct _a1log {
   int refc ;
   char *tag ;
   int verb ;
   int debug ;
   void *cntx ;
   void (*logv)(void * , struct _a1log * , char * , va_list  ) ;
   void (*logd)(void * , struct _a1log * , char * , va_list  ) ;
   void (*loge)(void * , struct _a1log * , char * , va_list  ) ;
   int errc ;
   char errm[500] ;
   pthread_mutex_t lock ;
};
#line 313 "numlib/numsup.h"
typedef struct _a1log a1log;
#line 147 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.h"
struct _athread {
   pthread_t thid ;
   int reusable ;
   int dofinish ;
   pthread_mutex_t startm ;
   pthread_cond_t startc ;
   int startv ;
   pthread_mutex_t stopm ;
   pthread_cond_t stopc ;
   int stopv ;
   int joined ;
   int result ;
   int (*function)(void * ) ;
   void *context ;
   void (*start)(struct _athread * ) ;
   int (*wait_stop)(struct _athread * ) ;
   int (*wait)(struct _athread * ) ;
   void (*terminate)(struct _athread * ) ;
   void (*del)(struct _athread * ) ;
};
#line 198 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.h"
typedef struct _athread athread;
#line 233 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.h"
struct _kkill_nproc_ctx {
   athread *th ;
   char **pname ;
   a1log *log ;
   int stop ;
   int done ;
   void (*del)(struct _kkill_nproc_ctx * ) ;
};
#line 240 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.h"
typedef struct _kkill_nproc_ctx kkill_nproc_ctx;
#line 34 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
enum __anonenum__62 {
    xdg_data = 0,
    xdg_conf = 1,
    xdg_cache = 2
} ;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
typedef enum __anonenum__62 xdg_storage_type;
#line 41
enum __anonenum__63 {
    xdg_write = 0,
    xdg_read = 1
} ;
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
typedef enum __anonenum__63 xdg_op_type;
#line 49
enum __anonenum__64 {
    xdg_user = 0,
    xdg_local = 1
} ;
#line 52 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
typedef enum __anonenum__64 xdg_scope;
#line 55
enum __anonenum__65 {
    xdg_none = 0,
    xdg_all_matches = 1
} ;
#line 58 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
typedef enum __anonenum__65 xdg_options;
#line 61
enum __anonenum__66 {
    xdg_ok = 0,
    xdg_alloc = 1,
    xdg_nohome = 2,
    xdg_noalluserprofile = 3,
    xdg_nopath = 4,
    xdg_mallformed = 5
} ;
#line 68 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
typedef enum __anonenum__66 xdg_error;
#line 32 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.h"
struct __anonstruct_67 {
   glob_t g ;
   int rv ;
   size_t ix ;
   int merr ;
};
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.h"
typedef struct __anonstruct_67 aglob;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios-struct.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__84 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__85 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum__86 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 114
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 130 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 143 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 28 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/pollem.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__95 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__96 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum__97 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 934 "/usr/include/math.h"
enum __anonenum__98 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__100 {
    PTHREAD_CREATE_JOINABLE___0 = 0,
    PTHREAD_CREATE_DETACHED___0 = 1
} ;
#line 47
enum __anonenum__101 {
    PTHREAD_MUTEX_TIMED_NP___0 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___0 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___0 = 3,
    PTHREAD_MUTEX_NORMAL___0 = 0,
    PTHREAD_MUTEX_RECURSIVE___0 = 1,
    PTHREAD_MUTEX_ERRORCHECK___0 = 2,
    PTHREAD_MUTEX_DEFAULT___0 = 0
} ;
#line 69
enum __anonenum__102 {
    PTHREAD_MUTEX_STALLED___0 = 0,
    PTHREAD_MUTEX_STALLED_NP___0 = 0,
    PTHREAD_MUTEX_ROBUST___0 = 1,
    PTHREAD_MUTEX_ROBUST_NP___0 = 1
} ;
#line 81
enum __anonenum__103 {
    PTHREAD_PRIO_NONE___0 = 0,
    PTHREAD_PRIO_INHERIT___0 = 1,
    PTHREAD_PRIO_PROTECT___0 = 2
} ;
#line 104
enum __anonenum__104 {
    PTHREAD_RWLOCK_PREFER_READER_NP___0 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___0 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___0 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___0 = 0
} ;
#line 124
enum __anonenum__105 {
    PTHREAD_INHERIT_SCHED___0 = 0,
    PTHREAD_EXPLICIT_SCHED___0 = 1
} ;
#line 134
enum __anonenum__106 {
    PTHREAD_SCOPE_SYSTEM___0 = 0,
    PTHREAD_SCOPE_PROCESS___0 = 1
} ;
#line 144
enum __anonenum__107 {
    PTHREAD_PROCESS_PRIVATE___0 = 0,
    PTHREAD_PROCESS_SHARED___0 = 1
} ;
#line 168
enum __anonenum__108 {
    PTHREAD_CANCEL_ENABLE___0 = 0,
    PTHREAD_CANCEL_DISABLE___0 = 1
} ;
#line 175
enum __anonenum__109 {
    PTHREAD_CANCEL_DEFERRED___0 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___0 = 1
} ;
#line 71 "cgats/pars.h"
struct _cgatsAlloc {
   void *(*malloc)(struct _cgatsAlloc * , size_t  ) ;
   void *(*calloc)(struct _cgatsAlloc * , size_t  , size_t  ) ;
   void *(*realloc)(struct _cgatsAlloc * , void * , size_t  ) ;
   void (*free)(struct _cgatsAlloc * , void * ) ;
   void (*del)(struct _cgatsAlloc * ) ;
};
#line 73 "cgats/pars.h"
typedef struct _cgatsAlloc cgatsAlloc;
#line 79 "cgats/pars.h"
struct _cgatsAllocStd {
   void *(*malloc)(struct _cgatsAlloc * , size_t  ) ;
   void *(*calloc)(struct _cgatsAlloc * , size_t  , size_t  ) ;
   void *(*realloc)(struct _cgatsAlloc * , void * , size_t  ) ;
   void (*free)(struct _cgatsAlloc * , void * ) ;
   void (*del)(struct _cgatsAlloc * ) ;
};
#line 81 "cgats/pars.h"
typedef struct _cgatsAllocStd cgatsAllocStd;
#line 125 "cgats/pars.h"
struct _cgatsFile {
   size_t (*get_size)(struct _cgatsFile * ) ;
   int (*seek)(struct _cgatsFile * , unsigned int  ) ;
   size_t (*read)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*getch)(struct _cgatsFile * ) ;
   size_t (*write)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _cgatsFile * , char const   *  , ...) ;
   int (*flush)(struct _cgatsFile * ) ;
   char *(*fname)(struct _cgatsFile * ) ;
   int (*get_buf)(struct _cgatsFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _cgatsFile * ) ;
};
#line 127 "cgats/pars.h"
typedef struct _cgatsFile cgatsFile;
#line 135 "cgats/pars.h"
struct _cgatsFileStd {
   size_t (*get_size)(struct _cgatsFile * ) ;
   int (*seek)(struct _cgatsFile * , unsigned int  ) ;
   size_t (*read)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*getch)(struct _cgatsFile * ) ;
   size_t (*write)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _cgatsFile * , char const   *  , ...) ;
   int (*flush)(struct _cgatsFile * ) ;
   char *(*fname)(struct _cgatsFile * ) ;
   int (*get_buf)(struct _cgatsFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _cgatsFile * ) ;
   cgatsAlloc *al ;
   int del_al ;
   FILE *fp ;
   int doclose ;
   char *filename ;
   size_t size ;
};
#line 148 "cgats/pars.h"
typedef struct _cgatsFileStd cgatsFileStd;
#line 170 "cgats/pars.h"
struct _cgatsFileMem {
   size_t (*get_size)(struct _cgatsFile * ) ;
   int (*seek)(struct _cgatsFile * , unsigned int  ) ;
   size_t (*read)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*getch)(struct _cgatsFile * ) ;
   size_t (*write)(struct _cgatsFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _cgatsFile * , char const   *  , ...) ;
   int (*flush)(struct _cgatsFile * ) ;
   char *(*fname)(struct _cgatsFile * ) ;
   int (*get_buf)(struct _cgatsFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _cgatsFile * ) ;
   cgatsAlloc *al ;
   int del_al ;
   int del_buf ;
   unsigned char *start ;
   unsigned char *cur ;
   unsigned char *end ;
   unsigned char *aend ;
};
#line 179 "cgats/pars.h"
typedef struct _cgatsFileMem cgatsFileMem;
#line 202 "cgats/pars.h"
struct _parse {
   int line ;
   int token ;
   void (*del)(struct _parse * ) ;
   void (*reset_del)(struct _parse * ) ;
   void (*add_del)(struct _parse * , char * , char * , char * , char * ) ;
   int (*read_line)(struct _parse * ) ;
   char *(*get_token)(struct _parse * ) ;
   cgatsAlloc *al ;
   int del_al ;
   cgatsFile *fp ;
   int ltflag ;
   int q ;
   char *b ;
   int bs ;
   int bo ;
   int to ;
   char *tb ;
   int tbs ;
   char delf[256] ;
   char err[200] ;
   int errc ;
};
#line 239 "cgats/pars.h"
typedef struct _parse parse;
#line 34 "cgats/cgats.h"
enum __anonenum__111 {
    it8_7_1 = 0,
    it8_7_2 = 1,
    it8_7_3 = 2,
    it8_7_4 = 3,
    cgats_5 = 4,
    cgats_X = 5,
    tt_other = 6,
    tt_none = 7
} ;
#line 34 "cgats/cgats.h"
typedef enum __anonenum__111 table_type;
#line 37
enum __anonenum__112 {
    r_t = 0,
    i_t = 1,
    cs_t = 2,
    nqcs_t = 3,
    none_t = 4
} ;
#line 37 "cgats/cgats.h"
typedef enum __anonenum__112 data_type;
#line 39 "cgats/cgats.h"
union _cgats_set_elem {
   int i ;
   double d ;
   char *c ;
};
#line 43 "cgats/cgats.h"
typedef union _cgats_set_elem cgats_set_elem;
#line 45 "cgats/cgats.h"
struct _cgats_table {
   cgatsAlloc *al ;
   table_type tt ;
   int oi ;
   int nkwords ;
   int nfields ;
   int nsets ;
   char **ksym ;
   char **kdata ;
   char **fsym ;
   data_type *ftype ;
   char ***rfdata ;
   void ***fdata ;
   int nkwordsa ;
   int nfieldsa ;
   int nsetsa ;
   char **kcom ;
   int ndf ;
   int sup_id ;
   int sup_kwords ;
   int sup_fields ;
};
#line 73 "cgats/cgats.h"
typedef struct _cgats_table cgats_table;
#line 75 "cgats/cgats.h"
struct _cgats {
   cgatsAlloc *al ;
   int del_al ;
   int ntables ;
   cgats_table *t ;
   char *cgats_type ;
   int nothers ;
   char **others ;
   int emit_keywords ;
   int (*set_cgats_type)(struct _cgats * , char const   * ) ;
   int (*add_other)(struct _cgats * , char const   * ) ;
   int (*get_oi)(struct _cgats * , char const   * ) ;
   int (*read)(struct _cgats * , cgatsFile * ) ;
   int (*read_name)(struct _cgats * , char const   * ) ;
   int (*find_kword)(struct _cgats * , int  , char const   * ) ;
   int (*find_field)(struct _cgats * , int  , char const   * ) ;
   int (*add_table)(struct _cgats * , table_type  , int  ) ;
   int (*set_table_type)(struct _cgats * , int  , table_type  , int  ) ;
   int (*set_table_flags)(struct _cgats * , int  , int  , int  , int  ) ;
   int (*add_kword)(struct _cgats * , int  , char const   * , char const   * , char const   * ) ;
   int (*add_kword_at)(struct _cgats * , int  , int  , char const   * , char const   * ,
                       char const   * ) ;
   int (*add_field)(struct _cgats * , int  , char const   * , data_type  ) ;
   int (*add_set)(struct _cgats * , int   , ...) ;
   int (*add_setarr)(struct _cgats * , int  , cgats_set_elem * ) ;
   int (*write)(struct _cgats * , cgatsFile * ) ;
   int (*get_setarr)(struct _cgats * , int  , int  , cgats_set_elem * ) ;
   int (*write_name)(struct _cgats * , char const   * ) ;
   int (*error)(struct _cgats * , char ** ) ;
   void (*del)(struct _cgats * ) ;
   char err[2000] ;
   int errc ;
   char ferr[2000] ;
   int ferrc ;
};
#line 167 "cgats/cgats.h"
typedef struct _cgats cgats;
#line 151 "icc/iccV43.h"
typedef int32_t icSignature;
#line 154 "icc/iccV43.h"
typedef uint8_t icUInt8Number;
#line 155 "icc/iccV43.h"
typedef uint16_t icUInt16Number;
#line 156 "icc/iccV43.h"
typedef uint32_t icUInt32Number;
#line 157 "icc/iccV43.h"
typedef uint32_t icUInt64Number[2];
#line 160 "icc/iccV43.h"
typedef int8_t icInt8Number;
#line 161 "icc/iccV43.h"
typedef int16_t icInt16Number;
#line 162 "icc/iccV43.h"
typedef int32_t icInt32Number;
#line 163 "icc/iccV43.h"
typedef int32_t icInt64Number[2];
#line 166 "icc/iccV43.h"
typedef int32_t icS15Fixed16Number;
#line 167 "icc/iccV43.h"
typedef uint32_t icU16Fixed16Number;
#line 193
enum __anonenum__113 {
    icSigAToB0Tag = 1093812784,
    icSigAToB1Tag = 1093812785,
    icSigAToB2Tag = 1093812786,
    icSigBlueMatrixColumnTag = 1649957210,
    icSigBlueTRCTag = 1649693251,
    icSigBToA0Tag = 1110589744,
    icSigBToA1Tag = 1110589745,
    icSigBToA2Tag = 1110589746,
    icSigBToD0Tag = 1110590512,
    icSigBToD1Tag = 1110590513,
    icSigBToD2Tag = 1110590514,
    icSigBToD3Tag = 1110590515,
    icSigCalibrationDateTimeTag = 1667329140,
    icSigCharTargetTag = 1952543335,
    icSigChromaticAdaptationTag = 1667785060,
    icSigChromaticityTag = 1667789421,
    icSigColorantOrderTag = 1668051567,
    icSigColorantTableTag = 1668051572,
    icSigColorantTableOutTag = 1668050804,
    icSigColorimetricIntentImageStateTag = 1667852659,
    icSigCopyrightTag = 1668313716,
    icSigCrdInfoTag = 1668441193,
    icSigDataTag = 1684108385,
    icSigDateTimeTag = 1685350765,
    icSigDeviceMfgDescTag = 1684893284,
    icSigDeviceModelDescTag = 1684890724,
    icSigDeviceSettingsTag = 1684371059,
    icSigDToB0Tag = 1144144432,
    icSigDToB1Tag = 1144144433,
    icSigDToB2Tag = 1144144434,
    icSigDToB3Tag = 1144144435,
    icSigGamutTag = 1734438260,
    icSigGrayTRCTag = 1800688195,
    icSigGreenMatrixColumnTag = 1733843290,
    icSigGreenTRCTag = 1733579331,
    icSigLuminanceTag = 1819635049,
    icSigMeasurementTag = 1835360627,
    icSigMediaBlackPointTag = 1651208308,
    icSigMediaWhitePointTag = 2004119668,
    icSigNamedColorTag = 1852010348,
    icSigNamedColor2Tag = 1852009522,
    icSigOutputResponseTag = 1919251312,
    icSigPerceptualRenderingIntentGamutTag = 1919510320,
    icSigPreview0Tag = 1886545200,
    icSigPreview1Tag = 1886545201,
    icSigPreview2Tag = 1886545202,
    icSigProfileDescriptionTag = 1684370275,
    icSigProfileSequenceDescTag = 1886610801,
    icSigProfileSequenceIdentifierTag = 1886611812,
    icSigPs2CRD0Tag = 1886610480,
    icSigPs2CRD1Tag = 1886610481,
    icSigPs2CRD2Tag = 1886610482,
    icSigPs2CRD3Tag = 1886610483,
    icSigPs2CSATag = 1886597747,
    icSigPs2RenderingIntentTag = 1886597737,
    icSigRedMatrixColumnTag = 1918392666,
    icSigRedTRCTag = 1918128707,
    icSigSaturationRenderingIntentGamutTag = 1919510322,
    icSigScreeningDescTag = 1935897188,
    icSigScreeningTag = 1935897198,
    icSigTechnologyTag = 1952801640,
    icSigUcrBgTag = 1650877472,
    icSigVideoCardGammaTag = 1986226036,
    icSigViewingCondDescTag = 1987405156,
    icSigViewingConditionsTag = 1986618743,
    icMaxEnumTag = -1
} ;
#line 260 "icc/iccV43.h"
typedef enum __anonenum__113 icTagSignature;
#line 268
enum __anonenum__114 {
    icSigChromaticityType = 1667789421,
    icSigColorantOrderType = 1668051567,
    icSigColorantTableType = 1668051572,
    icSigCrdInfoType = 1668441193,
    icSigCurveType = 1668641398,
    icSigDataType = 1684108385,
    icSigDateTimeType = 1685350765,
    icSigDeviceSettingsType = 1684371059,
    icSigLut16Type = 1835430962,
    icSigLut8Type = 1835430961,
    icSigLutAToBType = 1832993312,
    icSigLutBToAType = 1833058592,
    icSigMeasurementType = 1835360627,
    icSigMultiLocalizedUnicodeType = 1835824483,
    icSigMultiProcessElementsType = 1836082548,
    icSigNamedColorType = 1852010348,
    icSigNamedColor2Type = 1852009522,
    icSigParametricCurveType = 1885434465,
    icSigProfileSequenceDescType = 1886610801,
    icSigProfileSequenceIdentifierType = 1886611812,
    icSigResponseCurveSet16Type = 1919120178,
    icSigS15Fixed16ArrayType = 1936077618,
    icSigScreeningType = 1935897198,
    icSigSignatureType = 1936287520,
    icSigTextType = 1952807028,
    icSigTextDescriptionType = 1684370275,
    icSigU16Fixed16ArrayType = 1969632050,
    icSigUcrBgType = 1650877472,
    icSigUInt16ArrayType = 1969828150,
    icSigUInt32ArrayType = 1969828658,
    icSigUInt64ArrayType = 1969829428,
    icSigUInt8ArrayType = 1969827896,
    icSigVideoCardGammaType = 1986226036,
    icSigViewingConditionsType = 1986618743,
    icSigXYZType = 1482250784,
    icMaxEnumType = -1
} ;
#line 305 "icc/iccV43.h"
typedef enum __anonenum__114 icTagTypeSignature;
#line 315
enum __anonenum__115 {
    icSigXYZData = 1482250784,
    icSigLabData = 1281450528,
    icSigLuvData = 1282766368,
    icSigYCbCrData = 1497588338,
    icSigYxyData = 1501067552,
    icSigRgbData = 1380401696,
    icSigGrayData = 1196573017,
    icSigHsvData = 1213421088,
    icSigHlsData = 1212961568,
    icSigCmykData = 1129142603,
    icSigCmyData = 1129142560,
    icSig2colorData = 843271250,
    icSig3colorData = 860048466,
    icSig4colorData = 876825682,
    icSig5colorData = 893602898,
    icSig6colorData = 910380114,
    icSig7colorData = 927157330,
    icSig8colorData = 943934546,
    icSig9colorData = 960711762,
    icSig10colorData = 1094929490,
    icSig11colorData = 1111706706,
    icSig12colorData = 1128483922,
    icSig13colorData = 1145261138,
    icSig14colorData = 1162038354,
    icSig15colorData = 1178815570,
    icSigMch5Data = 1296255029,
    icSigMch6Data = 1296255030,
    icSigMch7Data = 1296255031,
    icSigMch8Data = 1296255032,
    icSigNamedData = 1852662636,
    icMaxEnumData = -1
} ;
#line 350 "icc/iccV43.h"
typedef enum __anonenum__115 icColorSpaceSignature;
#line 353
enum __anonenum__116 {
    icSigInputClass = 1935896178,
    icSigDisplayClass = 1835955314,
    icSigOutputClass = 1886549106,
    icSigLinkClass = 1818848875,
    icSigAbstractClass = 1633842036,
    icSigColorSpaceClass = 1936744803,
    icSigNamedColorClass = 1852662636,
    icMaxEnumClass = -1
} ;
#line 362 "icc/iccV43.h"
typedef enum __anonenum__116 icProfileClassSignature;
#line 365
enum __anonenum__117 {
    icSigMacintosh = 1095782476,
    icSigMicrosoft = 1297303124,
    icSigSolaris = 1398099543,
    icSigSGI = 1397180704,
    icSigTaligent = 1413959252,
    icMaxEnumPlatform = -1
} ;
#line 372 "icc/iccV43.h"
typedef enum __anonenum__117 icPlatformSignature;
#line 375
enum __anonenum__118 {
    icSigPerceptualReferenceMediumGamut = 1886547303,
    icMaxEnumReferenceMediumGamut = -1
} ;
#line 378 "icc/iccV43.h"
typedef enum __anonenum__118 icReferenceMediumGamutSignature;
#line 381
enum __anonenum__119 {
    icSigFilmScanner = 1718838126,
    icSigDigitalCamera = 1684234605,
    icSigReflectiveScanner = 1920164718,
    icSigInkJetPrinter = 1768580468,
    icSigThermalWaxPrinter = 1953980792,
    icSigElectrophotographicPrinter = 1701865583,
    icSigElectrostaticPrinter = 1702065249,
    icSigDyeSublimationPrinter = 1685288290,
    icSigPhotographicPaperPrinter = 1919969391,
    icSigFilmWriter = 1718645358,
    icSigVideoMonitor = 1986618477,
    icSigVideoCamera = 1986618467,
    icSigProjectionTelevision = 1886024822,
    icSigCRTDisplay = 1129468960,
    icSigPMDisplay = 1347240992,
    icSigAMDisplay = 1095582752,
    icSigPhotoCD = 1263551300,
    icSigPhotoImageSetter = 1768777587,
    icSigGravure = 1735549302,
    icSigOffsetLithography = 1868981875,
    icSigSilkscreen = 1936288875,
    icSigFlexography = 1718379896,
    icSigMotionPictureFilmScanner = 1836082803,
    icSigMotionPictureFilmRecorder = 1836082803,
    icSigDigitalMotionPictureCamera = 1684893795,
    icSigDigitalCinemaProjector = 1684236912,
    icMaxEnumTechnology = -1
} ;
#line 409 "icc/iccV43.h"
typedef enum __anonenum__119 icTechnologySignature;
#line 417
enum __anonenum__120 {
    icFlare0 = 0,
    icFlare100 = 1,
    icMaxFlare = -1
} ;
#line 421 "icc/iccV43.h"
typedef enum __anonenum__120 icMeasurementFlare;
#line 424
enum __anonenum__121 {
    icGeometryUnknown = 0,
    icGeometry045or450 = 1,
    icGeometry0dord0 = 2,
    icMaxGeometry = -1
} ;
#line 429 "icc/iccV43.h"
typedef enum __anonenum__121 icMeasurementGeometry;
#line 432
enum __anonenum__122 {
    icPerceptual = 0,
    icRelativeColorimetric = 1,
    icSaturation = 2,
    icAbsoluteColorimetric = 3,
    icMaxEnumIntent = -1
} ;
#line 438 "icc/iccV43.h"
typedef enum __anonenum__122 icRenderingIntent;
#line 441
enum __anonenum__123 {
    icSpotShapeUnknown = 0,
    icSpotShapePrinterDefault = 1,
    icSpotShapeRound = 2,
    icSpotShapeDiamond = 3,
    icSpotShapeEllipse = 4,
    icSpotShapeLine = 5,
    icSpotShapeSquare = 6,
    icSpotShapeCross = 7,
    icMaxEnumSpot = -1
} ;
#line 451 "icc/iccV43.h"
typedef enum __anonenum__123 icSpotShape;
#line 454
enum __anonenum__124 {
    icStdObsUnknown = 0,
    icStdObs1931TwoDegrees = 1,
    icStdObs1964TenDegrees = 2,
    icMaxStdObs = -1
} ;
#line 459 "icc/iccV43.h"
typedef enum __anonenum__124 icStandardObserver;
#line 462
enum __anonenum__125 {
    icIlluminantUnknown = 0,
    icIlluminantD50 = 1,
    icIlluminantD65 = 2,
    icIlluminantD93 = 3,
    icIlluminantF2 = 4,
    icIlluminantD55 = 5,
    icIlluminantA = 6,
    icIlluminantEquiPowerE = 7,
    icIlluminantF8 = 8,
    icMaxEnumIlluminant = -1
} ;
#line 473 "icc/iccV43.h"
typedef enum __anonenum__125 icIlluminant;
#line 476
enum __anonenum__126 {
    icLanguageCodeEnglish = 25966,
    icLanguageCodeGerman = 25701,
    icLanguageCodeItalian = 26996,
    icLanguageCodeDutch = 28268,
    icLanguageCodeSweden = 29558,
    icLanguageCodeSpanish = 25971,
    icLanguageCodeDanish = 25697,
    icLanguageCodeNorwegian = 28271,
    icLanguageCodeJapanese = 27233,
    icLanguageCodeFinish = 26217,
    icLanguageCodeTurkish = 29810,
    icLanguageCodeKorean = 27503,
    icLanguageCodeChienese = 31336,
    icLanguageCodeFrench = 26226,
    icMaxEnumLanguageCode = 65535
} ;
#line 492 "icc/iccV43.h"
typedef enum __anonenum__126 icEnumLanguageCode;
#line 495
enum __anonenum__127 {
    icRegionCodeUSA = 21843,
    icRegionCodeUnitedKingdom = 21835,
    icRegionCodeGermany = 17477,
    icRegionCodeItaly = 18772,
    icRegionCodeNetherlands = 20044,
    icRegionCodeSpain = 17731,
    icRegionCodeDenmark = 17483,
    icRegionCodeNorway = 20047,
    icRegionCodeJapan = 19024,
    icRegionCodeFinland = 17993,
    icRegionCodeTurkey = 21586,
    icRegionCodeKorea = 19282,
    icRegionCodeChina = 17230,
    icRegionCodeTaiwan = 21591,
    icRegionCodeFrance = 18002,
    icMaxEnumRegionCode = 65535
} ;
#line 512 "icc/iccV43.h"
typedef enum __anonenum__127 icEnumRegionCode;
#line 515
enum __anonenum__128 {
    icStandard = 1,
    icTrans = 2,
    icGloss = 3,
    icUser1 = 256,
    icMaxDeviceMedia = -1
} ;
#line 521 "icc/iccV43.h"
typedef enum __anonenum__128 icDeviceMedia;
#line 524
enum __anonenum__129 {
    icNone = 1,
    icCoarse = 2,
    icFine = 3,
    icLineArt = 4,
    icErrorDiffusion = 5,
    icReserved6 = 6,
    icReserved7 = 7,
    icReserved8 = 8,
    icReserved9 = 9,
    icGrayScale = 10,
    icUser2 = 256,
    icMaxDither = -1
} ;
#line 537 "icc/iccV43.h"
typedef enum __anonenum__129 icDeviceDither;
#line 540
enum __anonenum__130 {
    icSigResolution = 1920167022,
    icSigMedia = 1836349808,
    icSigHalftone = 1751544942,
    icMaxSettings = -1
} ;
#line 545 "icc/iccV43.h"
typedef enum __anonenum__130 icSettingsSig;
#line 548
enum __anonenum__131 {
    icStaA = 1400136001,
    icStaE = 1400136005,
    icStaI = 1400136009,
    icStaT = 1400136020,
    icStaM = 1400136013,
    icDN = 1145970720,
    icDNP = 1145970768,
    icDNN = 1145982496,
    icDNNP = 1145982544,
    icMaxUnits = -1
} ;
#line 559 "icc/iccV43.h"
typedef enum __anonenum__131 icMeasUnitsSig;
#line 562
enum __anonenum__132 {
    icCurveFunction1 = 0,
    icCurveFunction3 = 1,
    icCurveFunction4 = 2,
    icCurveFunction5 = 3,
    icCurveFunction7 = 4
} ;
#line 568 "icc/iccV43.h"
typedef enum __anonenum__132 icParametricCurveFunctionType;
#line 571
enum __anonenum__133 {
    icSceneColorimetryEstimates = 1935896421,
    icSceneAppearanceEstimates = 1935765605,
    icFocalPlaneColorimetryEstimates = 1718641509,
    icReflectionHardcopyOriginalColorimetry = 1919446883,
    icReflectionPrintOutputColorimetry = 1919971171
} ;
#line 577 "icc/iccV43.h"
typedef enum __anonenum__133 icColorimetricIntentImageStateType;
#line 581
enum __anonenum__134 {
    icPerceptualReferenceMediumGamut = 1886547303
} ;
#line 583 "icc/iccV43.h"
typedef enum __anonenum__134 icSigRenderingIntentGamutType;
#line 227 "icc/icc.h"
struct _icmAlloc {
   void *(*malloc)(struct _icmAlloc * , size_t  ) ;
   void *(*calloc)(struct _icmAlloc * , size_t  , size_t  ) ;
   void *(*realloc)(struct _icmAlloc * , void * , size_t  ) ;
   void (*free)(struct _icmAlloc * , void * ) ;
   void (*del)(struct _icmAlloc * ) ;
};
#line 229 "icc/icc.h"
typedef struct _icmAlloc icmAlloc;
#line 234 "icc/icc.h"
struct _icmAllocStd {
   void *(*malloc)(struct _icmAlloc * , size_t  ) ;
   void *(*calloc)(struct _icmAlloc * , size_t  , size_t  ) ;
   void *(*realloc)(struct _icmAlloc * , void * , size_t  ) ;
   void (*free)(struct _icmAlloc * , void * ) ;
   void (*del)(struct _icmAlloc * ) ;
};
#line 236 "icc/icc.h"
typedef struct _icmAllocStd icmAllocStd;
#line 270 "icc/icc.h"
struct _icmFile {
   size_t (*get_size)(struct _icmFile * ) ;
   int (*seek)(struct _icmFile * , unsigned int  ) ;
   size_t (*read)(struct _icmFile * , void * , size_t  , size_t  ) ;
   size_t (*write)(struct _icmFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _icmFile * , char const   *  , ...) ;
   int (*flush)(struct _icmFile * ) ;
   int (*get_buf)(struct _icmFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _icmFile * ) ;
};
#line 272 "icc/icc.h"
typedef struct _icmFile icmFile;
#line 280 "icc/icc.h"
struct _icmFileStd {
   size_t (*get_size)(struct _icmFile * ) ;
   int (*seek)(struct _icmFile * , unsigned int  ) ;
   size_t (*read)(struct _icmFile * , void * , size_t  , size_t  ) ;
   size_t (*write)(struct _icmFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _icmFile * , char const   *  , ...) ;
   int (*flush)(struct _icmFile * ) ;
   int (*get_buf)(struct _icmFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _icmFile * ) ;
   icmAlloc *al ;
   int del_al ;
   FILE *fp ;
   int doclose ;
   size_t size ;
};
#line 292 "icc/icc.h"
typedef struct _icmFileStd icmFileStd;
#line 312 "icc/icc.h"
struct _icmFileMem {
   size_t (*get_size)(struct _icmFile * ) ;
   int (*seek)(struct _icmFile * , unsigned int  ) ;
   size_t (*read)(struct _icmFile * , void * , size_t  , size_t  ) ;
   size_t (*write)(struct _icmFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _icmFile * , char const   *  , ...) ;
   int (*flush)(struct _icmFile * ) ;
   int (*get_buf)(struct _icmFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _icmFile * ) ;
   icmAlloc *al ;
   int del_al ;
   int del_buf ;
   unsigned char *start ;
   unsigned char *cur ;
   unsigned char *end ;
   unsigned char *aend ;
};
#line 321 "icc/icc.h"
typedef struct _icmFileMem icmFileMem;
#line 348 "icc/icc.h"
typedef int icmSig;
#line 407 "icc/icc.h"
struct __anonstruct_135 {
   uint32_t l ;
   int32_t h ;
};
#line 410 "icc/icc.h"
typedef struct __anonstruct_135 icmInt64;
#line 412 "icc/icc.h"
struct __anonstruct_136 {
   uint32_t l ;
   uint32_t h ;
};
#line 414 "icc/icc.h"
typedef struct __anonstruct_136 icmUint64;
#line 417 "icc/icc.h"
struct __anonstruct_137 {
   double X ;
   double Y ;
   double Z ;
};
#line 421 "icc/icc.h"
typedef struct __anonstruct_137 icmXYZNumber;
#line 424 "icc/icc.h"
struct __anonstruct_138 {
   double deviceValue ;
   double measurement ;
};
#line 427 "icc/icc.h"
typedef struct __anonstruct_138 icmResponse16Number;
#line 453
struct _icc ;
#line 452 "icc/icc.h"
struct _icmBase {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
};
#line 454 "icc/icc.h"
typedef struct _icmBase icmBase;
#line 459 "icc/icc.h"
struct _icmUnknown {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   icTagTypeSignature uttype ;
   unsigned int size ;
   unsigned char *data ;
};
#line 469 "icc/icc.h"
typedef struct _icmUnknown icmUnknown;
#line 473 "icc/icc.h"
struct _icmUInt8Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   unsigned int *data ;
};
#line 482 "icc/icc.h"
typedef struct _icmUInt8Array icmUInt8Array;
#line 486 "icc/icc.h"
struct _icmUInt16Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   unsigned int *data ;
};
#line 495 "icc/icc.h"
typedef struct _icmUInt16Array icmUInt16Array;
#line 499 "icc/icc.h"
struct _icmUInt32Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   unsigned int *data ;
};
#line 508 "icc/icc.h"
typedef struct _icmUInt32Array icmUInt32Array;
#line 512 "icc/icc.h"
struct _icmUInt64Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   icmUint64 *data ;
};
#line 521 "icc/icc.h"
typedef struct _icmUInt64Array icmUInt64Array;
#line 525 "icc/icc.h"
struct _icmU16Fixed16Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   double *data ;
};
#line 534 "icc/icc.h"
typedef struct _icmU16Fixed16Array icmU16Fixed16Array;
#line 538 "icc/icc.h"
struct _icmS15Fixed16Array {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   double *data ;
};
#line 547 "icc/icc.h"
typedef struct _icmS15Fixed16Array icmS15Fixed16Array;
#line 551 "icc/icc.h"
struct _icmXYZArray {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   icmXYZNumber *data ;
};
#line 560 "icc/icc.h"
typedef struct _icmXYZArray icmXYZArray;
#line 564
enum __anonenum__139 {
    icmCurveUndef = -1,
    icmCurveLin = 0,
    icmCurveGamma = 1,
    icmCurveSpec = 2
} ;
#line 569 "icc/icc.h"
typedef enum __anonenum__139 icmCurveStyle;
#line 572 "icc/icc.h"
struct __anonstruct_140 {
   int inited ;
   double rmin ;
   double rmax ;
   double qscale ;
   int rsize ;
   unsigned int **rlists ;
   unsigned int size ;
   double *data ;
};
#line 583 "icc/icc.h"
typedef struct __anonstruct_140 icmRevTable;
#line 585 "icc/icc.h"
struct _icmCurve {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   icmRevTable rt ;
   icmCurveStyle flag ;
   unsigned int size ;
   double *data ;
   int (*lookup_fwd)(struct _icmCurve * , double * , double * ) ;
   int (*lookup_bwd)(struct _icmCurve * , double * , double * ) ;
};
#line 601 "icc/icc.h"
typedef struct _icmCurve icmCurve;
#line 605
enum __anonenum__141 {
    icmDataUndef = -1,
    icmDataASCII = 0,
    icmDataBin = 1
} ;
#line 609 "icc/icc.h"
typedef enum __anonenum__141 icmDataStyle;
#line 611 "icc/icc.h"
struct _icmData {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   icmDataStyle flag ;
   unsigned int size ;
   unsigned char *data ;
};
#line 621 "icc/icc.h"
typedef struct _icmData icmData;
#line 625 "icc/icc.h"
struct _icmText {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int size ;
   char *data ;
};
#line 635 "icc/icc.h"
typedef struct _icmText icmText;
#line 639 "icc/icc.h"
struct _icmDateTimeNumber {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int year ;
   unsigned int month ;
   unsigned int day ;
   unsigned int hours ;
   unsigned int minutes ;
   unsigned int seconds ;
};
#line 649 "icc/icc.h"
typedef struct _icmDateTimeNumber icmDateTimeNumber;
#line 735 "icc/icc.h"
struct __anonstruct_142 {
   double fth ;
   char bthff ;
   char athff ;
};
#line 739 "icc/icc.h"
typedef struct __anonstruct_142 sx_flip_info;
#line 749 "icc/icc.h"
struct _icmLut {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   int dinc[15] ;
   int dcube[32768] ;
   icmRevTable rit[15] ;
   icmRevTable rot[15] ;
   sx_flip_info finfo[15] ;
   unsigned int inputTable_size ;
   unsigned int clutTable_size ;
   unsigned int outputTable_size ;
   unsigned short *oso_ffa ;
   unsigned short *oso_ffb ;
   int odinc[15] ;
   void (*min_max)(struct _icmLut * , double * , double * , int  ) ;
   int (*lookup_matrix)(struct _icmLut * , double * , double * ) ;
   int (*lookup_input)(struct _icmLut * , double * , double * ) ;
   int (*lookup_clut_nl)(struct _icmLut * , double * , double * ) ;
   int (*lookup_clut_sx)(struct _icmLut * , double * , double * ) ;
   int (*lookup_output)(struct _icmLut * , double * , double * ) ;
   int (*nu_matrix)(struct _icmLut * ) ;
   unsigned int inputChan ;
   unsigned int outputChan ;
   unsigned int clutPoints ;
   unsigned int inputEnt ;
   unsigned int outputEnt ;
   double e[3][3] ;
   double *inputTable ;
   double *clutTable ;
   double *outputTable ;
   int (*set_tables)(struct _icmLut * , int  , void * , icColorSpaceSignature  , icColorSpaceSignature  ,
                     void (*)(void * , double * , double * ) , double * , double * ,
                     void (*)(void * , double * , double * ) , double * , double * ,
                     void (*)(void * , double * , double * ) , int * , int * ) ;
   int (*tune_value)(struct _icmLut * , double * , double * ) ;
};
#line 833 "icc/icc.h"
typedef struct _icmLut icmLut;
#line 871 "icc/icc.h"
struct _icmMeasurement {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   icStandardObserver observer ;
   icmXYZNumber backing ;
   icMeasurementGeometry geometry ;
   double flare ;
   icIlluminant illuminant ;
};
#line 880 "icc/icc.h"
typedef struct _icmMeasurement icmMeasurement;
#line 903 "icc/icc.h"
struct __anonstruct_143 {
   struct _icc *icp ;
   char root[32] ;
   double pcsCoords[3] ;
   double deviceCoords[15] ;
};
#line 908 "icc/icc.h"
typedef struct __anonstruct_143 icmNamedColorVal;
#line 910 "icc/icc.h"
struct _icmNamedColor {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _count ;
   unsigned int vendorFlag ;
   unsigned int count ;
   unsigned int nDeviceCoords ;
   char prefix[32] ;
   char suffix[32] ;
   icmNamedColorVal *data ;
};
#line 923 "icc/icc.h"
typedef struct _icmNamedColor icmNamedColor;
#line 930 "icc/icc.h"
struct __anonstruct_144 {
   struct _icc *icp ;
   char name[32] ;
   double pcsCoords[3] ;
};
#line 934 "icc/icc.h"
typedef struct __anonstruct_144 icmColorantTableVal;
#line 936 "icc/icc.h"
struct _icmColorantTable {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _count ;
   unsigned int count ;
   icmColorantTableVal *data ;
};
#line 945 "icc/icc.h"
typedef struct _icmColorantTable icmColorantTable;
#line 949 "icc/icc.h"
struct _icmTextDescription {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _size ;
   unsigned int uc_size ;
   int (*core_read)(struct _icmTextDescription * , char ** , char * ) ;
   int (*core_write)(struct _icmTextDescription * , char ** ) ;
   unsigned int size ;
   char *desc ;
   unsigned int ucLangCode ;
   unsigned int ucSize ;
   uint16_t *ucDesc ;
   uint16_t scCode ;
   unsigned int scSize ;
   uint8_t scDesc[67] ;
};
#line 970 "icc/icc.h"
typedef struct _icmTextDescription icmTextDescription;
#line 974 "icc/icc.h"
struct _icmDescStruct {
   struct _icc *icp ;
   int (*allocate)(struct _icmDescStruct * ) ;
   icmSig deviceMfg ;
   unsigned int deviceModel ;
   icmUint64 attributes ;
   icTechnologySignature technology ;
   icmTextDescription device ;
   icmTextDescription model ;
};
#line 986 "icc/icc.h"
typedef struct _icmDescStruct icmDescStruct;
#line 989 "icc/icc.h"
struct _icmProfileSequenceDesc {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _count ;
   unsigned int count ;
   icmDescStruct *data ;
};
#line 998 "icc/icc.h"
typedef struct _icmProfileSequenceDesc icmProfileSequenceDesc;
#line 1019 "icc/icc.h"
struct _icmSignature {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   icTechnologySignature sig ;
};
#line 1024 "icc/icc.h"
typedef struct _icmSignature icmSignature;
#line 1028 "icc/icc.h"
struct __anonstruct_145 {
   double frequency ;
   double angle ;
   icSpotShape spotShape ;
};
#line 1033 "icc/icc.h"
typedef struct __anonstruct_145 icmScreeningData;
#line 1035 "icc/icc.h"
struct _icmScreening {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _channels ;
   unsigned int screeningFlag ;
   unsigned int channels ;
   icmScreeningData *data ;
};
#line 1045 "icc/icc.h"
typedef struct _icmScreening icmScreening;
#line 1049 "icc/icc.h"
struct _icmUcrBg {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int UCR_count ;
   unsigned int BG_count ;
   unsigned int _size ;
   unsigned int UCRcount ;
   double *UCRcurve ;
   unsigned int BGcount ;
   double *BGcurve ;
   unsigned int size ;
   char *string ;
};
#line 1066 "icc/icc.h"
typedef struct _icmUcrBg icmUcrBg;
#line 1070 "icc/icc.h"
struct _icmViewingConditions {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   icmXYZNumber illuminant ;
   icmXYZNumber surround ;
   icIlluminant stdIlluminant ;
};
#line 1077 "icc/icc.h"
typedef struct _icmViewingConditions icmViewingConditions;
#line 1081 "icc/icc.h"
struct _icmCrdInfo {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   unsigned int _ppsize ;
   unsigned int _crdsize[4] ;
   unsigned int ppsize ;
   char *ppname ;
   unsigned int crdsize[4] ;
   char *crdname[4] ;
};
#line 1092 "icc/icc.h"
typedef struct _icmCrdInfo icmCrdInfo;
#line 1096 "icc/icc.h"
struct _icmVideoCardGammaTable {
   unsigned short channels ;
   unsigned short entryCount ;
   unsigned short entrySize ;
   void *data ;
};
#line 1101 "icc/icc.h"
typedef struct _icmVideoCardGammaTable icmVideoCardGammaTable;
#line 1103 "icc/icc.h"
struct _icmVideoCardGammaFormula {
   unsigned short channels ;
   double redGamma ;
   double redMin ;
   double redMax ;
   double greenGamma ;
   double greenMin ;
   double greenMax ;
   double blueGamma ;
   double blueMin ;
   double blueMax ;
};
#line 1114 "icc/icc.h"
typedef struct _icmVideoCardGammaFormula icmVideoCardGammaFormula;
#line 1116
enum __anonenum__146 {
    icmVideoCardGammaTableType = 0,
    icmVideoCardGammaFormulaType = 1
} ;
#line 1119 "icc/icc.h"
typedef enum __anonenum__146 icmVideoCardGammaTagType;
#line 1124 "icc/icc.h"
union __anonunion_147 {
   icmVideoCardGammaTable table ;
   icmVideoCardGammaFormula formula ;
};
#line 1121 "icc/icc.h"
struct _icmVideoCardGamma {
   icTagTypeSignature ttype ;
   struct _icc *icp ;
   int touched ;
   int refcount ;
   unsigned int (*get_size)(struct _icmBase * ) ;
   int (*read)(struct _icmBase * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmBase * , unsigned int  ) ;
   void (*del)(struct _icmBase * ) ;
   void (*dump)(struct _icmBase * , icmFile * , int  ) ;
   int (*allocate)(struct _icmBase * ) ;
   icmVideoCardGammaTagType tagType ;
   union __anonunion_147 u ;
   double (*lookup)(struct _icmVideoCardGamma * , int  , double  ) ;
};
#line 1131 "icc/icc.h"
typedef struct _icmVideoCardGamma icmVideoCardGamma;
#line 1136 "icc/icc.h"
struct _icmHeader {
   unsigned int (*get_size)(struct _icmHeader * ) ;
   int (*read)(struct _icmHeader * , unsigned int  , unsigned int  ) ;
   int (*write)(struct _icmHeader * , unsigned int  , int  ) ;
   void (*del)(struct _icmHeader * ) ;
   struct _icc *icp ;
   unsigned int size ;
   void (*dump)(struct _icmHeader * , icmFile * , int  ) ;
   icProfileClassSignature deviceClass ;
   icColorSpaceSignature colorSpace ;
   icColorSpaceSignature pcs ;
   icRenderingIntent renderingIntent ;
   icmSig manufacturer ;
   icmSig model ;
   icmUint64 attributes ;
   unsigned int flags ;
   icmSig creator ;
   icmSig cmmId ;
   int majv ;
   int minv ;
   int bfv ;
   icmDateTimeNumber date ;
   icPlatformSignature platform ;
   icmXYZNumber illuminant ;
   unsigned char id[16] ;
};
#line 1176 "icc/icc.h"
typedef struct _icmHeader icmHeader;
#line 1188
enum __anonenum__148 {
    icmFwd = 0,
    icmBwd = 1,
    icmGamut = 2,
    icmPreview = 3
} ;
#line 1193 "icc/icc.h"
typedef enum __anonenum__148 icmLookupFunc;
#line 1196
enum __anonenum__149 {
    icmLuOrdNorm = 0,
    icmLuOrdRev = 1
} ;
#line 1199 "icc/icc.h"
typedef enum __anonenum__149 icmLookupOrder;
#line 1202
enum __anonenum__150 {
    icmMonoFwdType = 0,
    icmMonoBwdType = 1,
    icmMatrixFwdType = 2,
    icmMatrixBwdType = 3,
    icmLutType = 4,
    icmNamedType = 5
} ;
#line 1209 "icc/icc.h"
typedef enum __anonenum__150 icmLuAlgType;
#line 1315 "icc/icc.h"
struct _icmLuBase {
   icmLuAlgType ttype ;
   struct _icc *icp ;
   icRenderingIntent intent ;
   icmLookupFunc function ;
   icmLookupOrder order ;
   icmXYZNumber pcswht ;
   icmXYZNumber whitePoint ;
   icmXYZNumber blackPoint ;
   int blackisassumed ;
   double toAbs[3][3] ;
   double fromAbs[3][3] ;
   icColorSpaceSignature inSpace ;
   icColorSpaceSignature outSpace ;
   icColorSpaceSignature pcs ;
   icColorSpaceSignature e_inSpace ;
   icColorSpaceSignature e_outSpace ;
   icColorSpaceSignature e_pcs ;
   void (*del)(struct _icmLuBase * ) ;
   void (*lutspaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                     int * , icColorSpaceSignature * ) ;
   void (*spaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                  int * , icmLuAlgType * , icRenderingIntent * , icmLookupFunc * ,
                  icColorSpaceSignature * , icmLookupOrder * ) ;
   void (*XYZ_Rel2Abs)(struct _icmLuBase * , double * , double * ) ;
   void (*XYZ_Abs2Rel)(struct _icmLuBase * , double * , double * ) ;
   void (*get_lutranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   void (*get_ranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   int (*init_wh_bk)(struct _icmLuBase * ) ;
   int (*wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lu_wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_in)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_core)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_out)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_inv_in)(struct _icmLuBase * , double * , double * ) ;
};
#line 1317 "icc/icc.h"
typedef struct _icmLuBase icmLuBase;
#line 1323 "icc/icc.h"
struct _icmLuMono {
   icmLuAlgType ttype ;
   struct _icc *icp ;
   icRenderingIntent intent ;
   icmLookupFunc function ;
   icmLookupOrder order ;
   icmXYZNumber pcswht ;
   icmXYZNumber whitePoint ;
   icmXYZNumber blackPoint ;
   int blackisassumed ;
   double toAbs[3][3] ;
   double fromAbs[3][3] ;
   icColorSpaceSignature inSpace ;
   icColorSpaceSignature outSpace ;
   icColorSpaceSignature pcs ;
   icColorSpaceSignature e_inSpace ;
   icColorSpaceSignature e_outSpace ;
   icColorSpaceSignature e_pcs ;
   void (*del)(struct _icmLuBase * ) ;
   void (*lutspaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                     int * , icColorSpaceSignature * ) ;
   void (*spaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                  int * , icmLuAlgType * , icRenderingIntent * , icmLookupFunc * ,
                  icColorSpaceSignature * , icmLookupOrder * ) ;
   void (*XYZ_Rel2Abs)(struct _icmLuBase * , double * , double * ) ;
   void (*XYZ_Abs2Rel)(struct _icmLuBase * , double * , double * ) ;
   void (*get_lutranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   void (*get_ranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   int (*init_wh_bk)(struct _icmLuBase * ) ;
   int (*wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lu_wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_in)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_core)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_out)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_inv_in)(struct _icmLuBase * , double * , double * ) ;
   icmCurve *grayCurve ;
   int (*fwd_lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*bwd_lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*fwd_curve)(struct _icmLuMono * , double * , double * ) ;
   int (*fwd_map)(struct _icmLuMono * , double * , double * ) ;
   int (*fwd_abs)(struct _icmLuMono * , double * , double * ) ;
   int (*bwd_abs)(struct _icmLuMono * , double * , double * ) ;
   int (*bwd_map)(struct _icmLuMono * , double * , double * ) ;
   int (*bwd_curve)(struct _icmLuMono * , double * , double * ) ;
};
#line 1339 "icc/icc.h"
typedef struct _icmLuMono icmLuMono;
#line 1342 "icc/icc.h"
struct _icmLuMatrix {
   icmLuAlgType ttype ;
   struct _icc *icp ;
   icRenderingIntent intent ;
   icmLookupFunc function ;
   icmLookupOrder order ;
   icmXYZNumber pcswht ;
   icmXYZNumber whitePoint ;
   icmXYZNumber blackPoint ;
   int blackisassumed ;
   double toAbs[3][3] ;
   double fromAbs[3][3] ;
   icColorSpaceSignature inSpace ;
   icColorSpaceSignature outSpace ;
   icColorSpaceSignature pcs ;
   icColorSpaceSignature e_inSpace ;
   icColorSpaceSignature e_outSpace ;
   icColorSpaceSignature e_pcs ;
   void (*del)(struct _icmLuBase * ) ;
   void (*lutspaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                     int * , icColorSpaceSignature * ) ;
   void (*spaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                  int * , icmLuAlgType * , icRenderingIntent * , icmLookupFunc * ,
                  icColorSpaceSignature * , icmLookupOrder * ) ;
   void (*XYZ_Rel2Abs)(struct _icmLuBase * , double * , double * ) ;
   void (*XYZ_Abs2Rel)(struct _icmLuBase * , double * , double * ) ;
   void (*get_lutranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   void (*get_ranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   int (*init_wh_bk)(struct _icmLuBase * ) ;
   int (*wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lu_wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_in)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_core)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_out)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_inv_in)(struct _icmLuBase * , double * , double * ) ;
   icmCurve *redCurve ;
   icmCurve *greenCurve ;
   icmCurve *blueCurve ;
   icmXYZArray *redColrnt ;
   icmXYZArray *greenColrnt ;
   icmXYZArray *blueColrnt ;
   double mx[3][3] ;
   double bmx[3][3] ;
   int (*fwd_lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*bwd_lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*fwd_curve)(struct _icmLuMatrix * , double * , double * ) ;
   int (*fwd_matrix)(struct _icmLuMatrix * , double * , double * ) ;
   int (*fwd_abs)(struct _icmLuMatrix * , double * , double * ) ;
   int (*bwd_abs)(struct _icmLuMatrix * , double * , double * ) ;
   int (*bwd_matrix)(struct _icmLuMatrix * , double * , double * ) ;
   int (*bwd_curve)(struct _icmLuMatrix * , double * , double * ) ;
};
#line 1361 "icc/icc.h"
typedef struct _icmLuMatrix icmLuMatrix;
#line 1364 "icc/icc.h"
struct _icmLuLut {
   icmLuAlgType ttype ;
   struct _icc *icp ;
   icRenderingIntent intent ;
   icmLookupFunc function ;
   icmLookupOrder order ;
   icmXYZNumber pcswht ;
   icmXYZNumber whitePoint ;
   icmXYZNumber blackPoint ;
   int blackisassumed ;
   double toAbs[3][3] ;
   double fromAbs[3][3] ;
   icColorSpaceSignature inSpace ;
   icColorSpaceSignature outSpace ;
   icColorSpaceSignature pcs ;
   icColorSpaceSignature e_inSpace ;
   icColorSpaceSignature e_outSpace ;
   icColorSpaceSignature e_pcs ;
   void (*del)(struct _icmLuBase * ) ;
   void (*lutspaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                     int * , icColorSpaceSignature * ) ;
   void (*spaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                  int * , icmLuAlgType * , icRenderingIntent * , icmLookupFunc * ,
                  icColorSpaceSignature * , icmLookupOrder * ) ;
   void (*XYZ_Rel2Abs)(struct _icmLuBase * , double * , double * ) ;
   void (*XYZ_Abs2Rel)(struct _icmLuBase * , double * , double * ) ;
   void (*get_lutranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   void (*get_ranges)(struct _icmLuBase * , double * , double * , double * , double * ) ;
   int (*init_wh_bk)(struct _icmLuBase * ) ;
   int (*wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lu_wh_bk_points)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_in)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_core)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_out)(struct _icmLuBase * , double * , double * ) ;
   int (*lookup_inv_in)(struct _icmLuBase * , double * , double * ) ;
   icmLut *lut ;
   int usematrix ;
   double imx[3][3] ;
   int imx_valid ;
   void (*in_normf)(double * , double * ) ;
   void (*in_denormf)(double * , double * ) ;
   void (*out_normf)(double * , double * ) ;
   void (*out_denormf)(double * , double * ) ;
   void (*e_in_denormf)(double * , double * ) ;
   void (*e_out_denormf)(double * , double * ) ;
   int (*lookup_clut)(struct _icmLut * , double * , double * ) ;
   int (*in_abs)(struct _icmLuLut * , double * , double * ) ;
   int (*matrix)(struct _icmLuLut * , double * , double * ) ;
   int (*input)(struct _icmLuLut * , double * , double * ) ;
   int (*clut)(struct _icmLuLut * , double * , double * ) ;
   int (*output)(struct _icmLuLut * , double * , double * ) ;
   int (*out_abs)(struct _icmLuLut * , double * , double * ) ;
   int (*inv_out_abs)(struct _icmLuLut * , double * , double * ) ;
   int (*inv_output)(struct _icmLuLut * , double * , double * ) ;
   int (*inv_input)(struct _icmLuLut * , double * , double * ) ;
   int (*inv_matrix)(struct _icmLuLut * , double * , double * ) ;
   int (*inv_in_abs)(struct _icmLuLut * , double * , double * ) ;
   void (*get_info)(struct _icmLuLut * , icmLut ** , icmXYZNumber * , icmXYZNumber * ,
                    icmXYZNumber * ) ;
   void (*get_matrix)(struct _icmLuLut * , double [3][3] ) ;
};
#line 1410 "icc/icc.h"
typedef struct _icmLuLut icmLuLut;
#line 1413 "icc/icc.h"
struct _icmLuNamed {
   icmLuAlgType ttype ;
   struct _icc *icp ;
   icRenderingIntent intent ;
   icmLookupFunc function ;
   icmLookupOrder order ;
   icmXYZNumber pcswht ;
   icmXYZNumber whitePoint ;
   icmXYZNumber blackPoint ;
   int blackisassumed ;
   double toAbs[3][3] ;
   double fromAbs[3][3] ;
   icColorSpaceSignature inSpace ;
   icColorSpaceSignature outSpace ;
   icColorSpaceSignature pcs ;
   icColorSpaceSignature e_inSpace ;
   icColorSpaceSignature e_outSpace ;
   icColorSpaceSignature e_pcs ;
   void (*del)(struct _icmLuBase * ) ;
   void (*lutspaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                     int * , icColorSpaceSignature * ) ;
   void (*spaces)(struct _icmLuBase * , icColorSpaceSignature * , int * , icColorSpaceSignature * ,
                  int * , icmLuAlgType * , icRenderingIntent * , icmLookupFunc * ,
                  icColorSpaceSignature * , icmLookupOrder * ) ;
   void (*XYZ_Rel2Abs)(struct _icmLuBase * , double * , double * ) ;
   void (*XYZ_Abs2Rel)(struct _icmLuBase * , double * , double * ) ;
   void (*get_info)(struct _icmLuLut * , icmXYZNumber * , icmXYZNumber * , icmXYZNumber * ,
                    int * , int * , char * , char * ) ;
   int (*fullname_lookup)(struct _icmLuNamed * , double * , double * , char * ) ;
   int (*name_lookup)(struct _icmLuNamed * , double * , double * , char * ) ;
   int (*pcs_lookup)(struct _icmLuNamed * , char ** , int  , double * ) ;
   int (*dev_lookup)(struct _icmLuNamed * , char ** , int  , double * ) ;
};
#line 1440 "icc/icc.h"
typedef struct _icmLuNamed icmLuNamed;
#line 1445 "icc/icc.h"
struct _sig2type {
   icTagSignature sig ;
   icTagTypeSignature ttypes[6] ;
};
#line 1448 "icc/icc.h"
typedef struct _sig2type sig2type;
#line 1451 "icc/icc.h"
struct __anonstruct_151 {
   icTagSignature sig ;
   icTagTypeSignature ttype ;
   unsigned int offset ;
   unsigned int size ;
   unsigned int pad ;
   icmBase *objp ;
};
#line 1458 "icc/icc.h"
typedef struct __anonstruct_151 icmTag;
#line 1479
enum __anonenum__152 {
    icmVersionDefault = 0,
    icmVersion2_3 = 1,
    icmVersion2_4 = 2,
    icmVersion4_1 = 3
} ;
#line 1484 "icc/icc.h"
typedef enum __anonenum__152 icmICCVersion;
#line 1487 "icc/icc.h"
struct _icc {
   icmFile *(*get_rfp)(struct _icc * ) ;
   int (*set_version)(struct _icc * , icmICCVersion  ) ;
   unsigned int (*get_size)(struct _icc * ) ;
   int (*read)(struct _icc * , icmFile * , unsigned int  ) ;
   int (*read_x)(struct _icc * , icmFile * , unsigned int  , int  ) ;
   int (*write)(struct _icc * , icmFile * , unsigned int  ) ;
   int (*write_x)(struct _icc * , icmFile * , unsigned int  , int  ) ;
   void (*dump)(struct _icc * , icmFile * , int  ) ;
   void (*del)(struct _icc * ) ;
   int (*find_tag)(struct _icc * , icTagSignature  ) ;
   icmBase *(*read_tag)(struct _icc * , icTagSignature  ) ;
   icmBase *(*read_tag_any)(struct _icc * , icTagSignature  ) ;
   icmBase *(*add_tag)(struct _icc * , icTagSignature  , icTagTypeSignature  ) ;
   int (*rename_tag)(struct _icc * , icTagSignature  , icTagSignature  ) ;
   icmBase *(*link_tag)(struct _icc * , icTagSignature  , icTagSignature  ) ;
   int (*unread_tag)(struct _icc * , icTagSignature  ) ;
   int (*read_all_tags)(struct _icc * ) ;
   int (*delete_tag)(struct _icc * , icTagSignature  ) ;
   int (*check_id)(struct _icc * , uint8_t * ) ;
   double (*get_tac)(struct _icc * , double * , void (*)(void * , double * , double * ) ,
                     void * ) ;
   void (*set_illum)(struct _icc * , double [3] ) ;
   void (*chromAdaptMatrix)(struct _icc * , int  , double [3][3] , double [3][3] ,
                            icmXYZNumber  , icmXYZNumber  ) ;
   icmLuBase *(*get_luobj)(struct _icc * , icmLookupFunc  , icRenderingIntent  , icColorSpaceSignature  ,
                           icmLookupOrder  ) ;
   icmLuBase *(*new_clutluobj)(struct _icc * , icTagSignature  , icColorSpaceSignature  ,
                               icColorSpaceSignature  , icColorSpaceSignature  , icColorSpaceSignature  ,
                               icColorSpaceSignature  , icColorSpaceSignature  , icRenderingIntent  ,
                               icmLookupFunc  ) ;
   icmHeader *header ;
   char err[512] ;
   int errc ;
   int warnc ;
   int allowclutPoints256 ;
   int useLinWpchtmx ;
   icProfileClassSignature wpchtmx_class ;
   double wpchtmx[3][3] ;
   double iwpchtmx[3][3] ;
   int useArts ;
   double illwp[3] ;
   int illwpValid ;
   int naturalChad ;
   int chadmxValid ;
   double chadmx[3][3] ;
   int wrDChad ;
   int wrOChad ;
   int tempChad ;
   icmXYZNumber tempWP ;
   icmAlloc *al ;
   int del_al ;
   icmFile *fp ;
   int del_fp ;
   unsigned int of ;
   unsigned int count ;
   icmTag *data ;
   icmICCVersion ver ;
   sig2type *sigtypetable ;
};
#line 1637 "icc/icc.h"
typedef struct _icc icc;
#line 1643
enum __anonenum__153 {
    icmUInt8Number = 0,
    icmUInt16Number = 1,
    icmUInt32Number = 2,
    icmUInt64Number = 3,
    icmU8Fixed8Number = 4,
    icmU16Fixed16Number = 5,
    icmSInt8Number = 6,
    icmSInt16Number = 7,
    icmSInt32Number = 8,
    icmSInt64Number = 9,
    icmS15Fixed16Number = 10,
    icmDCS8Number = 11,
    icmDCS16Number = 12,
    icmPCSNumber = 13,
    icmPCSXYZNumber = 14,
    icmPCSLab8Number = 15,
    icmPCSLabNumber = 16,
    icmPCSLabV2Number = 17,
    icmPCSLabV4Number = 18
} ;
#line 1663 "icc/icc.h"
typedef enum __anonenum__153 icmPrimType;
#line 1666 "icc/icc.h"
struct _psh {
   int di ;
   unsigned int res ;
   unsigned int bits ;
   unsigned int ix ;
   unsigned int tmask ;
   unsigned int count ;
};
#line 1673 "icc/icc.h"
typedef struct _psh psh;
#line 1676
enum __anonenum__154 {
    icmScreenEncodings = 0,
    icmDeviceAttributes = 1,
    icmProfileHeaderFlags = 2,
    icmAsciiOrBinaryData = 3,
    icmTagSignature = 4,
    icmTechnologySignature = 5,
    icmTypeSignature = 6,
    icmColorSpaceSignature = 7,
    icmProfileClassSignature = 8,
    icmPlatformSignature = 9,
    icmMeasurementFlare = 10,
    icmMeasurementGeometry = 11,
    icmRenderingIntent = 12,
    icmTransformLookupFunc = 13,
    icmSpotShape = 14,
    icmStandardObserver = 15,
    icmIlluminant = 16,
    icmLuAlg = 17
} ;
#line 1695 "icc/icc.h"
typedef enum __anonenum__154 icmEnumType;
#line 1699 "icc/icc.h"
struct _icmMD5 {
   icmAlloc *al ;
   int del_al ;
   int fin ;
   uint32_t sum[4] ;
   unsigned int tlen ;
   uint8_t buf[64] ;
   void (*reset)(struct _icmMD5 * ) ;
   void (*add)(struct _icmMD5 * , uint8_t * , unsigned int  ) ;
   void (*get)(struct _icmMD5 * , uint8_t [16] ) ;
   void (*del)(struct _icmMD5 * ) ;
};
#line 1715 "icc/icc.h"
typedef struct _icmMD5 icmMD5;
#line 1725 "icc/icc.h"
struct _icmFileMD5 {
   size_t (*get_size)(struct _icmFile * ) ;
   int (*seek)(struct _icmFile * , unsigned int  ) ;
   size_t (*read)(struct _icmFile * , void * , size_t  , size_t  ) ;
   size_t (*write)(struct _icmFile * , void * , size_t  , size_t  ) ;
   int (*gprintf)(struct _icmFile * , char const   *  , ...) ;
   int (*flush)(struct _icmFile * ) ;
   int (*get_buf)(struct _icmFile * , unsigned char ** , size_t * ) ;
   int (*del)(struct _icmFile * ) ;
   int (*get_errc)(struct _icmFile * ) ;
   icmAlloc *al ;
   icmMD5 *md5 ;
   unsigned int of ;
   int errc ;
   size_t size ;
};
#line 1738 "icc/icc.h"
typedef struct _icmFileMD5 icmFileMD5;
#line 40 "xicc/xspect.h"
enum __anonenum__155 {
    inst_mrt_none = 0,
    inst_mrt_emission = 1,
    inst_mrt_ambient = 2,
    inst_mrt_emission_flash = 3,
    inst_mrt_ambient_flash = 4,
    inst_mrt_reflective = 5,
    inst_mrt_transmissive = 6,
    inst_mrt_sensitivity = 7,
    inst_mrt_frequency = 8
} ;
#line 50 "xicc/xspect.h"
typedef enum __anonenum__155 inst_meas_type;
#line 56
enum __anonenum__156 {
    inst_mrc_none = 0,
    inst_mrc_D50 = 1,
    inst_mrc_D65 = 2,
    inst_mrc_uvcut = 3,
    inst_mrc_pol = 4,
    inst_mrc_custom = 5
} ;
#line 63 "xicc/xspect.h"
typedef enum __anonenum__156 inst_meas_cond;
#line 83 "xicc/xspect.h"
struct __anonstruct_157 {
   int spec_n ;
   double spec_wl_short ;
   double spec_wl_long ;
   double norm ;
   double spec[601] ;
};
#line 89 "xicc/xspect.h"
typedef struct __anonstruct_157 xspect;
#line 249
enum __anonenum__158 {
    icxIT_default = 0,
    icxIT_none = 1,
    icxIT_custom = 2,
    icxIT_A = 3,
    icxIT_C = 4,
    icxIT_D50 = 5,
    icxIT_D50M2 = 6,
    icxIT_D55 = 7,
    icxIT_D65 = 8,
    icxIT_D75 = 9,
    icxIT_E = 10,
    icxIT_F5 = 11,
    icxIT_F8 = 12,
    icxIT_F10 = 13,
    icxIT_Spectrocam = 14,
    icxIT_ODtemp = 15,
    icxIT_Dtemp = 16,
    icxIT_OPtemp = 17,
    icxIT_Ptemp = 18
} ;
#line 271 "xicc/xspect.h"
typedef enum __anonenum__158 icxIllumeType;
#line 304
enum __anonenum__159 {
    icxOT_default = 0,
    icxOT_none = 1,
    icxOT_custom = 2,
    icxOT_CIE_1931_2 = 3,
    icxOT_CIE_1964_10 = 4,
    icxOT_CIE_2012_2 = 5,
    icxOT_CIE_2012_10 = 6,
    icxOT_Stiles_Burch_2 = 7,
    icxOT_Judd_Voss_2 = 8,
    icxOT_CIE_1964_10c = 9,
    icxOT_Shaw_Fairchild_2 = 10,
    icxOT_EBU_2012 = 11
} ;
#line 319 "xicc/xspect.h"
typedef enum __anonenum__159 icxObserverType;
#line 329
enum __anonenum__160 {
    icxDT_none = 0,
    icxDT_ISO = 1,
    icxDT_A = 2,
    icxDT_M = 3,
    icxDT_T = 4,
    icxDT_E = 5
} ;
#line 336 "xicc/xspect.h"
typedef enum __anonenum__160 icxDensityType;
#line 339
enum __anonenum__161 {
    icxNoClamp = 0,
    icxClamp = 1
} ;
#line 342 "xicc/xspect.h"
typedef enum __anonenum__161 icxClamping;
#line 345 "xicc/xspect.h"
struct _xsp2cie {
   xspect illuminant ;
   int isemis ;
   xspect observer[3] ;
   int doLab ;
   icxClamping clamp ;
   int spec_bw ;
   double spec_wl_short ;
   double spec_wl_long ;
   double fwa_bw ;
   xspect iillum ;
   xspect imedia ;
   xspect emits ;
   xspect media ;
   xspect tillum ;
   xspect oillum ;
   double Sm ;
   double FWAc ;
   int insteqtarget ;
   void (*del)(struct _xsp2cie * ) ;
   void (*set_int_steps)(struct _xsp2cie * , double  , double  , double  ) ;
   void (*photo2rad)(struct _xsp2cie * , double * , double * , xspect * , xspect * ) ;
   void (*convert)(struct _xsp2cie * , double * , xspect * ) ;
   void (*sconvert)(struct _xsp2cie * , xspect * , double * , xspect * ) ;
   void (*get_cie_il)(struct _xsp2cie * , double * ) ;
   int (*set_fwa)(struct _xsp2cie * , xspect * , xspect * , xspect * ) ;
   int (*update_fwa_custillum)(struct _xsp2cie * , xspect * , xspect * ) ;
   void (*get_fwa_info)(struct _xsp2cie * , double * ) ;
   int (*set_mw)(struct _xsp2cie * , xspect * ) ;
   int (*extract)(struct _xsp2cie * , xspect * , xspect * ) ;
   int (*apply)(struct _xsp2cie * , xspect * , xspect * ) ;
};
#line 477 "xicc/xspect.h"
typedef struct _xsp2cie xsp2cie;
#line 572
struct _xslpoly ;
#line 572 "xicc/xspect.h"
typedef struct _xslpoly xslpoly;
#line 574
enum __anonenum__162 {
    icxLT_none = 0,
    icxLT_spectral = 1,
    icxLT_daylight = 2,
    icxLT_plankian = 3
} ;
#line 579 "xicc/xspect.h"
typedef enum __anonenum__162 icxLocusType;
#line 27 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
enum __anonenum__163 {
    devUnknown = 0,
    instDTP22 = 1,
    instDTP41 = 2,
    instDTP51 = 3,
    instSpectrolino = 4,
    instSpectroScan = 5,
    instSpectroScanT = 6,
    instSpectrocam = 7,
    instSpecbos1201 = 8,
    instSpecbos = 9,
    instSpectraval = 10,
    instKleinK10 = 11,
    instSMCube = 12,
    instDTP20 = 13,
    instDTP92 = 14,
    instDTP94 = 15,
    instI1Disp1 = 16,
    instI1Disp2 = 17,
    instI1Disp3 = 18,
    instI1Monitor = 19,
    instI1Pro = 20,
    instI1Pro2 = 21,
    instI1Pro3 = 22,
    instColorMunki = 23,
    instHCFR = 24,
    instSpyder1 = 25,
    instSpyder2 = 26,
    instSpyder3 = 27,
    instSpyder4 = 28,
    instSpyder5 = 29,
    instSpyderX = 30,
    instHuey = 31,
    instSmile = 32,
    instEX1 = 33,
    instColorHug = 34,
    instColorHug2 = 35,
    instFakeDisp = 9998
} ;
#line 81 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef enum __anonenum__163 devType;
#line 85 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef devType instType;
#line 86 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef devType vcLUTType;
#line 87 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef devType vtpgType;
#line 88 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef devType printerType;
#line 90
struct _icoms ;
#line 91
enum _icom_type {

} ;
#line 137
enum __anonenum__164 {
    xcalstd_none = -2,
    xcalstd_native = -1,
    xcalstd_xrdi = 0,
    xcalstd_gmdi = 1,
    xcalstd_xrga = 2
} ;
#line 143 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
typedef enum __anonenum__164 xcalstd;
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
enum __anonenum__171 {
    icomuf_none = 0,
    icomuf_detach = 1,
    icomuf_no_open_clear = 2,
    icomuf_reset_before_close = 4,
    icomuf_resetep_before_read = 8
} ;
#line 51 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__171 icomuflags;
#line 53
enum __anonenum__172 {
    icomt_unknown = 0,
    icomt_instrument = 65536,
    icomt_v3dlut = 131072,
    icomt_vtpg = 262144,
    icomt_printer = 524288,
    icomt_cat_any = 4128768,
    icomt_cat_mask = 16711680,
    icomt_serial = 1,
    icomt_usb = 2,
    icomt_hid = 4,
    icomt_bt = 8,
    icomt_port_mask = 255,
    icomt_fastserial = 256,
    icomt_btserial = 512,
    icomt_seriallike = 1024,
    icomt_attr_mask = 65280,
    icomt_portattr_mask = 65535,
    icomt_portattr_all = 65535
} ;
#line 88 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__172 icom_type;
#line 114
struct _icompath ;
#line 114 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef struct _icompath icompath;
#line 115
struct _icompaths ;
#line 115 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef struct _icompaths icompaths;
#line 116 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef struct _icoms icoms;
#line 120
struct usb_idevice ;
#line 121
struct hid_idevice ;
#line 124 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
struct __anonstruct_173 {
   int valid ;
   int addr ;
   int packetsize ;
   int type ;
   int interface ;
};
#line 136 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef struct __anonstruct_173 usb_ep;
#line 165 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/usbio.h"
struct _usbio_req ;
#line 149 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/usbio.h"
struct usb_idevice {
   char *dpath ;
   int nconfig ;
   int config ;
   int nifce ;
   usb_ep ep[32] ;
   int fd ;
   pthread_t thread ;
   int shutdown ;
   int sd_pipe[2] ;
   int running ;
   pthread_mutex_t lock ;
   struct _usbio_req *reqs ;
};
#line 176
enum __anonenum__174 {
    icom_usb_trantype_command = 0,
    icom_usb_trantype_interrutpt = 1,
    icom_usb_trantype_bulk = 2
} ;
#line 180 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/usbio.h"
typedef enum __anonenum__174 icom_usb_trantype;
#line 186 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/usbio.h"
struct _usb_cancelt {
   pthread_mutex_t cmtx ;
   int state ;
   pthread_mutex_t condx ;
   void *hcancel ;
};
#line 56 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/hidio.h"
struct hid_idevice {

};
#line 150 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
struct _icompath {
   devType dtype ;
   char *name ;
   icom_type dctype ;
   char *spath ;
   int nep ;
   unsigned int vid ;
   unsigned int pid ;
   struct usb_idevice *usbd ;
   struct hid_idevice *hidd ;
};
#line 169
enum __anonenum__175 {
    dtix_combined = 0,
    dtix_inst = 1,
    dtix_3dlut = 2,
    dtix_vtpg = 3,
    dtix_printer = 4,
    dtix_number = 5
} ;
#line 177 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__175 icom_dtix;
#line 180 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
struct _icompaths {
   a1log *log ;
   icompath **dpaths[5] ;
   int ndpaths[5] ;
   icompath **paths ;
   int npaths ;
   int (*refresh)(struct _icompaths * ) ;
   int (*refresh_sel)(struct _icompaths * , icom_type  ) ;
   icompath *(*get_path)(struct _icompaths * , int  ) ;
   icompath *(*get_path_sel)(struct _icompaths * , icom_dtix  , int  ) ;
   void (*clear)(struct _icompaths * ) ;
   void (*del)(struct _icompaths * ) ;
   int exno ;
   char **exlist ;
   int (*fs_excluded)(struct _icompaths * , struct _icompath * ) ;
   int (*add_serial)(struct _icompaths * , char * , char * , icom_type  ) ;
   int (*add_usb)(struct _icompaths * , char * , unsigned int  , unsigned int  , int  ,
                  struct usb_idevice * , devType  ) ;
   int (*add_hid)(struct _icompaths * , char * , unsigned int  , unsigned int  , int  ,
                  struct hid_idevice * , devType  ) ;
   void (*del_last_path)(struct _icompaths * ) ;
   icompath *(*get_last_path)(struct _icompaths * ) ;
};
#line 267
enum __anonenum__176 {
    fc_nc = 0,
    fc_None = 1,
    fc_XonXOff = 2,
    fc_Hardware = 3,
    fc_HardwareDTR = 4
} ;
#line 273 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__176 flow_control;
#line 276
enum __anonenum__177 {
    baud_nc = 0,
    baud_110 = 1,
    baud_300 = 2,
    baud_600 = 3,
    baud_1200 = 4,
    baud_2400 = 5,
    baud_4800 = 6,
    baud_9600 = 7,
    baud_14400 = 8,
    baud_19200 = 9,
    baud_38400 = 10,
    baud_57600 = 11,
    baud_115200 = 12,
    baud_230400 = 13,
    baud_921600 = 14
} ;
#line 292 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__177 baud_rate;
#line 297
enum __anonenum__178 {
    parity_nc = 0,
    parity_none = 1,
    parity_odd = 2,
    parity_even = 3
} ;
#line 302 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__178 parity;
#line 305
enum __anonenum__179 {
    stop_nc = 0,
    stop_1 = 1,
    stop_2 = 2
} ;
#line 309 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__179 stop_bits;
#line 312
enum __anonenum__180 {
    length_nc = 0,
    length_5 = 1,
    length_6 = 2,
    length_7 = 3,
    length_8 = 4
} ;
#line 318 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__180 word_length;
#line 321
enum __anonenum__181 {
    icomi_data_available = 0
} ;
#line 323 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef enum __anonenum__181 icom_int;
#line 327 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
typedef struct _usb_cancelt usb_cancelt;
#line 335 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
struct _icoms {
   icom_type dctype ;
   devType dtype ;
   char *name ;
   int is_open ;
   void *icntx ;
   char *spath ;
   int fd ;
   flow_control fc ;
   baud_rate br ;
   parity py ;
   stop_bits sb ;
   word_length wl ;
   struct usb_idevice *usbd ;
   icomuflags uflags ;
   unsigned int vid ;
   unsigned int pid ;
   int nconfig ;
   int config ;
   int cconfig ;
   int nifce ;
   int nep ;
   int wr_ep ;
   int rd_ep ;
   int rd_qa ;
   int ms_bytes ;
   int latmsec ;
   int (*interp_ms)(struct _icoms * , unsigned char * ) ;
   usb_ep ep[32] ;
   struct hid_idevice *hidd ;
   int lserr ;
   a1log *log ;
   int debug ;
   struct _icoms *next ;
   icom_type (*dev_cat)(struct _icoms * ) ;
   icom_type (*port_type)(struct _icoms * ) ;
   icom_type (*port_attr)(struct _icoms * ) ;
   int (*set_ser_port_ex)(struct _icoms * , flow_control  , baud_rate  , parity  ,
                          stop_bits  , word_length  , int  ) ;
   int (*set_ser_port)(struct _icoms * , flow_control  , baud_rate  , parity  , stop_bits  ,
                       word_length  ) ;
   int (*set_usb_port)(struct _icoms * , int  , int  , int  , icomuflags  , int  ,
                       char ** ) ;
   int (*set_hid_port)(struct _icoms * , icomuflags  , int  , char ** ) ;
   void (*close_port)(struct _icoms * ) ;
   int (*write)(struct _icoms * , char * , int  , double  ) ;
   int (*read)(struct _icoms * , char * , int  , int * , char * , int  , double  ) ;
   int (*write_read)(struct _icoms * , char * , int  , char * , int  , int * , char * ,
                     int  , double  ) ;
   int (*write_read_ex)(struct _icoms * , char * , int  , char * , int  , int * ,
                        char * , int  , double  , int  ) ;
   void (*ser_clearerr)(struct _icoms * ) ;
   int (*usb_control)(struct _icoms * , int  , int  , int  , int  , unsigned char * ,
                      int  , int * , double  ) ;
   int (*usb_read)(struct _icoms * , usb_cancelt * , int  , unsigned char * , int  ,
                   int * , double  ) ;
   int (*usb_write)(struct _icoms * , usb_cancelt * , int  , unsigned char * , int  ,
                    int * , double  ) ;
   int (*usb_wait_io)(struct _icoms * , usb_cancelt * ) ;
   int (*usb_cancel_io)(struct _icoms * , usb_cancelt * ) ;
   int (*usb_resetep)(struct _icoms * , int  ) ;
   int (*usb_clearhalt)(struct _icoms * , int  ) ;
   int (*hid_read)(struct _icoms * , unsigned char * , int  , int * , double  ) ;
   int (*hid_write)(struct _icoms * , unsigned char * , int  , int * , double  ) ;
   int (*interrupt)(struct _icoms * , int  ) ;
   void (*del)(struct _icoms * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__182 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__183 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum__184 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__199 {
    PTHREAD_CREATE_JOINABLE___1 = 0,
    PTHREAD_CREATE_DETACHED___1 = 1
} ;
#line 47
enum __anonenum__200 {
    PTHREAD_MUTEX_TIMED_NP___1 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___1 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___1 = 3,
    PTHREAD_MUTEX_NORMAL___1 = 0,
    PTHREAD_MUTEX_RECURSIVE___1 = 1,
    PTHREAD_MUTEX_ERRORCHECK___1 = 2,
    PTHREAD_MUTEX_DEFAULT___1 = 0
} ;
#line 69
enum __anonenum__201 {
    PTHREAD_MUTEX_STALLED___1 = 0,
    PTHREAD_MUTEX_STALLED_NP___1 = 0,
    PTHREAD_MUTEX_ROBUST___1 = 1,
    PTHREAD_MUTEX_ROBUST_NP___1 = 1
} ;
#line 81
enum __anonenum__202 {
    PTHREAD_PRIO_NONE___1 = 0,
    PTHREAD_PRIO_INHERIT___1 = 1,
    PTHREAD_PRIO_PROTECT___1 = 2
} ;
#line 104
enum __anonenum__203 {
    PTHREAD_RWLOCK_PREFER_READER_NP___1 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___1 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___1 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___1 = 0
} ;
#line 124
enum __anonenum__204 {
    PTHREAD_INHERIT_SCHED___1 = 0,
    PTHREAD_EXPLICIT_SCHED___1 = 1
} ;
#line 134
enum __anonenum__205 {
    PTHREAD_SCOPE_SYSTEM___1 = 0,
    PTHREAD_SCOPE_PROCESS___1 = 1
} ;
#line 144
enum __anonenum__206 {
    PTHREAD_PROCESS_PRIVATE___1 = 0,
    PTHREAD_PROCESS_SHARED___1 = 1
} ;
#line 168
enum __anonenum__207 {
    PTHREAD_CANCEL_ENABLE___1 = 0,
    PTHREAD_CANCEL_DISABLE___1 = 1
} ;
#line 175
enum __anonenum__208 {
    PTHREAD_CANCEL_DEFERRED___1 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___1 = 1
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__210 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__217 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 934
enum __anonenum__19___0 {
    FP_NAN___2 = 0,
    FP_INFINITE___2 = 1,
    FP_ZERO___2 = 2,
    FP_SUBNORMAL___2 = 3,
    FP_NORMAL___2 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220 {
    PTHREAD_CREATE_JOINABLE___2 = 0,
    PTHREAD_CREATE_DETACHED___2 = 1
} ;
#line 47
enum __anonenum__221 {
    PTHREAD_MUTEX_TIMED_NP___2 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___2 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___2 = 3,
    PTHREAD_MUTEX_NORMAL___2 = 0,
    PTHREAD_MUTEX_RECURSIVE___2 = 1,
    PTHREAD_MUTEX_ERRORCHECK___2 = 2,
    PTHREAD_MUTEX_DEFAULT___2 = 0
} ;
#line 69
enum __anonenum__222 {
    PTHREAD_MUTEX_STALLED___2 = 0,
    PTHREAD_MUTEX_STALLED_NP___2 = 0,
    PTHREAD_MUTEX_ROBUST___2 = 1,
    PTHREAD_MUTEX_ROBUST_NP___2 = 1
} ;
#line 81
enum __anonenum__223 {
    PTHREAD_PRIO_NONE___2 = 0,
    PTHREAD_PRIO_INHERIT___2 = 1,
    PTHREAD_PRIO_PROTECT___2 = 2
} ;
#line 104
enum __anonenum__224 {
    PTHREAD_RWLOCK_PREFER_READER_NP___2 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___2 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___2 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___2 = 0
} ;
#line 124
enum __anonenum__225 {
    PTHREAD_INHERIT_SCHED___2 = 0,
    PTHREAD_EXPLICIT_SCHED___2 = 1
} ;
#line 134
enum __anonenum__226 {
    PTHREAD_SCOPE_SYSTEM___2 = 0,
    PTHREAD_SCOPE_PROCESS___2 = 1
} ;
#line 144
enum __anonenum__227 {
    PTHREAD_PROCESS_PRIVATE___2 = 0,
    PTHREAD_PROCESS_SHARED___2 = 1
} ;
#line 168
enum __anonenum__228 {
    PTHREAD_CANCEL_ENABLE___2 = 0,
    PTHREAD_CANCEL_DISABLE___2 = 1
} ;
#line 175
enum __anonenum__229 {
    PTHREAD_CANCEL_DEFERRED___2 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___2 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___1 {
    FP_NAN___3 = 0,
    FP_INFINITE___3 = 1,
    FP_ZERO___3 = 2,
    FP_SUBNORMAL___3 = 3,
    FP_NORMAL___3 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___0 {
    PTHREAD_CREATE_JOINABLE___3 = 0,
    PTHREAD_CREATE_DETACHED___3 = 1
} ;
#line 47
enum __anonenum__221___0 {
    PTHREAD_MUTEX_TIMED_NP___3 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___3 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___3 = 3,
    PTHREAD_MUTEX_NORMAL___3 = 0,
    PTHREAD_MUTEX_RECURSIVE___3 = 1,
    PTHREAD_MUTEX_ERRORCHECK___3 = 2,
    PTHREAD_MUTEX_DEFAULT___3 = 0
} ;
#line 69
enum __anonenum__222___0 {
    PTHREAD_MUTEX_STALLED___3 = 0,
    PTHREAD_MUTEX_STALLED_NP___3 = 0,
    PTHREAD_MUTEX_ROBUST___3 = 1,
    PTHREAD_MUTEX_ROBUST_NP___3 = 1
} ;
#line 81
enum __anonenum__223___0 {
    PTHREAD_PRIO_NONE___3 = 0,
    PTHREAD_PRIO_INHERIT___3 = 1,
    PTHREAD_PRIO_PROTECT___3 = 2
} ;
#line 104
enum __anonenum__224___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___3 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___3 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___3 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___3 = 0
} ;
#line 124
enum __anonenum__225___0 {
    PTHREAD_INHERIT_SCHED___3 = 0,
    PTHREAD_EXPLICIT_SCHED___3 = 1
} ;
#line 134
enum __anonenum__226___0 {
    PTHREAD_SCOPE_SYSTEM___3 = 0,
    PTHREAD_SCOPE_PROCESS___3 = 1
} ;
#line 144
enum __anonenum__227___0 {
    PTHREAD_PROCESS_PRIVATE___3 = 0,
    PTHREAD_PROCESS_SHARED___3 = 1
} ;
#line 168
enum __anonenum__228___0 {
    PTHREAD_CANCEL_ENABLE___3 = 0,
    PTHREAD_CANCEL_DISABLE___3 = 1
} ;
#line 175
enum __anonenum__229___0 {
    PTHREAD_CANCEL_DEFERRED___3 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___3 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___2 {
    FP_NAN___4 = 0,
    FP_INFINITE___4 = 1,
    FP_ZERO___4 = 2,
    FP_SUBNORMAL___4 = 3,
    FP_NORMAL___4 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___1 {
    PTHREAD_CREATE_JOINABLE___4 = 0,
    PTHREAD_CREATE_DETACHED___4 = 1
} ;
#line 47
enum __anonenum__221___1 {
    PTHREAD_MUTEX_TIMED_NP___4 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___4 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___4 = 3,
    PTHREAD_MUTEX_NORMAL___4 = 0,
    PTHREAD_MUTEX_RECURSIVE___4 = 1,
    PTHREAD_MUTEX_ERRORCHECK___4 = 2,
    PTHREAD_MUTEX_DEFAULT___4 = 0
} ;
#line 69
enum __anonenum__222___1 {
    PTHREAD_MUTEX_STALLED___4 = 0,
    PTHREAD_MUTEX_STALLED_NP___4 = 0,
    PTHREAD_MUTEX_ROBUST___4 = 1,
    PTHREAD_MUTEX_ROBUST_NP___4 = 1
} ;
#line 81
enum __anonenum__223___1 {
    PTHREAD_PRIO_NONE___4 = 0,
    PTHREAD_PRIO_INHERIT___4 = 1,
    PTHREAD_PRIO_PROTECT___4 = 2
} ;
#line 104
enum __anonenum__224___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___4 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___4 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___4 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___4 = 0
} ;
#line 124
enum __anonenum__225___1 {
    PTHREAD_INHERIT_SCHED___4 = 0,
    PTHREAD_EXPLICIT_SCHED___4 = 1
} ;
#line 134
enum __anonenum__226___1 {
    PTHREAD_SCOPE_SYSTEM___4 = 0,
    PTHREAD_SCOPE_PROCESS___4 = 1
} ;
#line 144
enum __anonenum__227___1 {
    PTHREAD_PROCESS_PRIVATE___4 = 0,
    PTHREAD_PROCESS_SHARED___4 = 1
} ;
#line 168
enum __anonenum__228___1 {
    PTHREAD_CANCEL_ENABLE___4 = 0,
    PTHREAD_CANCEL_DISABLE___4 = 1
} ;
#line 175
enum __anonenum__229___1 {
    PTHREAD_CANCEL_DEFERRED___4 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___4 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___3 {
    FP_NAN___5 = 0,
    FP_INFINITE___5 = 1,
    FP_ZERO___5 = 2,
    FP_SUBNORMAL___5 = 3,
    FP_NORMAL___5 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___2 {
    PTHREAD_CREATE_JOINABLE___5 = 0,
    PTHREAD_CREATE_DETACHED___5 = 1
} ;
#line 47
enum __anonenum__221___2 {
    PTHREAD_MUTEX_TIMED_NP___5 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___5 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___5 = 3,
    PTHREAD_MUTEX_NORMAL___5 = 0,
    PTHREAD_MUTEX_RECURSIVE___5 = 1,
    PTHREAD_MUTEX_ERRORCHECK___5 = 2,
    PTHREAD_MUTEX_DEFAULT___5 = 0
} ;
#line 69
enum __anonenum__222___2 {
    PTHREAD_MUTEX_STALLED___5 = 0,
    PTHREAD_MUTEX_STALLED_NP___5 = 0,
    PTHREAD_MUTEX_ROBUST___5 = 1,
    PTHREAD_MUTEX_ROBUST_NP___5 = 1
} ;
#line 81
enum __anonenum__223___2 {
    PTHREAD_PRIO_NONE___5 = 0,
    PTHREAD_PRIO_INHERIT___5 = 1,
    PTHREAD_PRIO_PROTECT___5 = 2
} ;
#line 104
enum __anonenum__224___2 {
    PTHREAD_RWLOCK_PREFER_READER_NP___5 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___5 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___5 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___5 = 0
} ;
#line 124
enum __anonenum__225___2 {
    PTHREAD_INHERIT_SCHED___5 = 0,
    PTHREAD_EXPLICIT_SCHED___5 = 1
} ;
#line 134
enum __anonenum__226___2 {
    PTHREAD_SCOPE_SYSTEM___5 = 0,
    PTHREAD_SCOPE_PROCESS___5 = 1
} ;
#line 144
enum __anonenum__227___2 {
    PTHREAD_PROCESS_PRIVATE___5 = 0,
    PTHREAD_PROCESS_SHARED___5 = 1
} ;
#line 168
enum __anonenum__228___2 {
    PTHREAD_CANCEL_ENABLE___5 = 0,
    PTHREAD_CANCEL_DISABLE___5 = 1
} ;
#line 175
enum __anonenum__229___2 {
    PTHREAD_CANCEL_DEFERRED___5 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___5 = 1
} ;
#line 12 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.h"
struct _sobol {
   int dim ;
   unsigned int count ;
   double recipd ;
   int lastq[40] ;
   int dir[30][40] ;
   int (*next)(struct _sobol * , double * ) ;
   void (*reset)(struct _sobol * ) ;
   void (*del)(struct _sobol * ) ;
};
#line 33 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.h"
typedef struct _sobol sobol;
#line 934 "/usr/include/math.h"
enum __anonenum__231 {
    FP_NAN___6 = 0,
    FP_INFINITE___6 = 1,
    FP_ZERO___6 = 2,
    FP_SUBNORMAL___6 = 3,
    FP_NORMAL___6 = 4
} ;
#line 934
enum __anonenum__19___4 {
    FP_NAN___7 = 0,
    FP_INFINITE___7 = 1,
    FP_ZERO___7 = 2,
    FP_SUBNORMAL___7 = 3,
    FP_NORMAL___7 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___3 {
    PTHREAD_CREATE_JOINABLE___6 = 0,
    PTHREAD_CREATE_DETACHED___6 = 1
} ;
#line 47
enum __anonenum__221___3 {
    PTHREAD_MUTEX_TIMED_NP___6 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___6 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___6 = 3,
    PTHREAD_MUTEX_NORMAL___6 = 0,
    PTHREAD_MUTEX_RECURSIVE___6 = 1,
    PTHREAD_MUTEX_ERRORCHECK___6 = 2,
    PTHREAD_MUTEX_DEFAULT___6 = 0
} ;
#line 69
enum __anonenum__222___3 {
    PTHREAD_MUTEX_STALLED___6 = 0,
    PTHREAD_MUTEX_STALLED_NP___6 = 0,
    PTHREAD_MUTEX_ROBUST___6 = 1,
    PTHREAD_MUTEX_ROBUST_NP___6 = 1
} ;
#line 81
enum __anonenum__223___3 {
    PTHREAD_PRIO_NONE___6 = 0,
    PTHREAD_PRIO_INHERIT___6 = 1,
    PTHREAD_PRIO_PROTECT___6 = 2
} ;
#line 104
enum __anonenum__224___3 {
    PTHREAD_RWLOCK_PREFER_READER_NP___6 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___6 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___6 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___6 = 0
} ;
#line 124
enum __anonenum__225___3 {
    PTHREAD_INHERIT_SCHED___6 = 0,
    PTHREAD_EXPLICIT_SCHED___6 = 1
} ;
#line 134
enum __anonenum__226___3 {
    PTHREAD_SCOPE_SYSTEM___6 = 0,
    PTHREAD_SCOPE_PROCESS___6 = 1
} ;
#line 144
enum __anonenum__227___3 {
    PTHREAD_PROCESS_PRIVATE___6 = 0,
    PTHREAD_PROCESS_SHARED___6 = 1
} ;
#line 168
enum __anonenum__228___3 {
    PTHREAD_CANCEL_ENABLE___6 = 0,
    PTHREAD_CANCEL_DISABLE___6 = 1
} ;
#line 175
enum __anonenum__229___3 {
    PTHREAD_CANCEL_DEFERRED___6 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___6 = 1
} ;
#line 75 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.h"
struct __anonstruct_232 {
   int pvs_inited ;
   unsigned int ran ;
   unsigned int last ;
   unsigned int pvs[2843] ;
   int r2 ;
   double nr2 ;
};
#line 83 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.h"
typedef struct __anonstruct_232 rand_state;
#line 934 "/usr/include/math.h"
enum __anonenum__19___5 {
    FP_NAN___8 = 0,
    FP_INFINITE___8 = 1,
    FP_ZERO___8 = 2,
    FP_SUBNORMAL___8 = 3,
    FP_NORMAL___8 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___4 {
    PTHREAD_CREATE_JOINABLE___7 = 0,
    PTHREAD_CREATE_DETACHED___7 = 1
} ;
#line 47
enum __anonenum__221___4 {
    PTHREAD_MUTEX_TIMED_NP___7 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___7 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___7 = 3,
    PTHREAD_MUTEX_NORMAL___7 = 0,
    PTHREAD_MUTEX_RECURSIVE___7 = 1,
    PTHREAD_MUTEX_ERRORCHECK___7 = 2,
    PTHREAD_MUTEX_DEFAULT___7 = 0
} ;
#line 69
enum __anonenum__222___4 {
    PTHREAD_MUTEX_STALLED___7 = 0,
    PTHREAD_MUTEX_STALLED_NP___7 = 0,
    PTHREAD_MUTEX_ROBUST___7 = 1,
    PTHREAD_MUTEX_ROBUST_NP___7 = 1
} ;
#line 81
enum __anonenum__223___4 {
    PTHREAD_PRIO_NONE___7 = 0,
    PTHREAD_PRIO_INHERIT___7 = 1,
    PTHREAD_PRIO_PROTECT___7 = 2
} ;
#line 104
enum __anonenum__224___4 {
    PTHREAD_RWLOCK_PREFER_READER_NP___7 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___7 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___7 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___7 = 0
} ;
#line 124
enum __anonenum__225___4 {
    PTHREAD_INHERIT_SCHED___7 = 0,
    PTHREAD_EXPLICIT_SCHED___7 = 1
} ;
#line 134
enum __anonenum__226___4 {
    PTHREAD_SCOPE_SYSTEM___7 = 0,
    PTHREAD_SCOPE_PROCESS___7 = 1
} ;
#line 144
enum __anonenum__227___4 {
    PTHREAD_PROCESS_PRIVATE___7 = 0,
    PTHREAD_PROCESS_SHARED___7 = 1
} ;
#line 168
enum __anonenum__228___4 {
    PTHREAD_CANCEL_ENABLE___7 = 0,
    PTHREAD_CANCEL_DISABLE___7 = 1
} ;
#line 175
enum __anonenum__229___4 {
    PTHREAD_CANCEL_DEFERRED___7 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___7 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___6 {
    FP_NAN___9 = 0,
    FP_INFINITE___9 = 1,
    FP_ZERO___9 = 2,
    FP_SUBNORMAL___9 = 3,
    FP_NORMAL___9 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___5 {
    PTHREAD_CREATE_JOINABLE___8 = 0,
    PTHREAD_CREATE_DETACHED___8 = 1
} ;
#line 47
enum __anonenum__221___5 {
    PTHREAD_MUTEX_TIMED_NP___8 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___8 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___8 = 3,
    PTHREAD_MUTEX_NORMAL___8 = 0,
    PTHREAD_MUTEX_RECURSIVE___8 = 1,
    PTHREAD_MUTEX_ERRORCHECK___8 = 2,
    PTHREAD_MUTEX_DEFAULT___8 = 0
} ;
#line 69
enum __anonenum__222___5 {
    PTHREAD_MUTEX_STALLED___8 = 0,
    PTHREAD_MUTEX_STALLED_NP___8 = 0,
    PTHREAD_MUTEX_ROBUST___8 = 1,
    PTHREAD_MUTEX_ROBUST_NP___8 = 1
} ;
#line 81
enum __anonenum__223___5 {
    PTHREAD_PRIO_NONE___8 = 0,
    PTHREAD_PRIO_INHERIT___8 = 1,
    PTHREAD_PRIO_PROTECT___8 = 2
} ;
#line 104
enum __anonenum__224___5 {
    PTHREAD_RWLOCK_PREFER_READER_NP___8 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___8 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___8 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___8 = 0
} ;
#line 124
enum __anonenum__225___5 {
    PTHREAD_INHERIT_SCHED___8 = 0,
    PTHREAD_EXPLICIT_SCHED___8 = 1
} ;
#line 134
enum __anonenum__226___5 {
    PTHREAD_SCOPE_SYSTEM___8 = 0,
    PTHREAD_SCOPE_PROCESS___8 = 1
} ;
#line 144
enum __anonenum__227___5 {
    PTHREAD_PROCESS_PRIVATE___8 = 0,
    PTHREAD_PROCESS_SHARED___8 = 1
} ;
#line 168
enum __anonenum__228___5 {
    PTHREAD_CANCEL_ENABLE___8 = 0,
    PTHREAD_CANCEL_DISABLE___8 = 1
} ;
#line 175
enum __anonenum__229___5 {
    PTHREAD_CANCEL_DEFERRED___8 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___8 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__233 {
    FP_NAN___10 = 0,
    FP_INFINITE___10 = 1,
    FP_ZERO___10 = 2,
    FP_SUBNORMAL___10 = 3,
    FP_NORMAL___10 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__234 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__235 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__236 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum__237 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__249 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__250 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__251 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__252 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__253 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 176
enum __anonenum__254 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__255 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__258 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__263 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__265 {
    PTHREAD_CREATE_JOINABLE___9 = 0,
    PTHREAD_CREATE_DETACHED___9 = 1
} ;
#line 47
enum __anonenum__266 {
    PTHREAD_MUTEX_TIMED_NP___9 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___9 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___9 = 3,
    PTHREAD_MUTEX_NORMAL___9 = 0,
    PTHREAD_MUTEX_RECURSIVE___9 = 1,
    PTHREAD_MUTEX_ERRORCHECK___9 = 2,
    PTHREAD_MUTEX_DEFAULT___9 = 0
} ;
#line 69
enum __anonenum__267 {
    PTHREAD_MUTEX_STALLED___9 = 0,
    PTHREAD_MUTEX_STALLED_NP___9 = 0,
    PTHREAD_MUTEX_ROBUST___9 = 1,
    PTHREAD_MUTEX_ROBUST_NP___9 = 1
} ;
#line 81
enum __anonenum__268 {
    PTHREAD_PRIO_NONE___9 = 0,
    PTHREAD_PRIO_INHERIT___9 = 1,
    PTHREAD_PRIO_PROTECT___9 = 2
} ;
#line 104
enum __anonenum__269 {
    PTHREAD_RWLOCK_PREFER_READER_NP___9 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___9 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___9 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___9 = 0
} ;
#line 124
enum __anonenum__270 {
    PTHREAD_INHERIT_SCHED___9 = 0,
    PTHREAD_EXPLICIT_SCHED___9 = 1
} ;
#line 134
enum __anonenum__271 {
    PTHREAD_SCOPE_SYSTEM___9 = 0,
    PTHREAD_SCOPE_PROCESS___9 = 1
} ;
#line 144
enum __anonenum__272 {
    PTHREAD_PROCESS_PRIVATE___9 = 0,
    PTHREAD_PROCESS_SHARED___9 = 1
} ;
#line 168
enum __anonenum__273 {
    PTHREAD_CANCEL_ENABLE___9 = 0,
    PTHREAD_CANCEL_DISABLE___9 = 1
} ;
#line 175
enum __anonenum__274 {
    PTHREAD_CANCEL_DEFERRED___9 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___9 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___7 {
    FP_NAN___11 = 0,
    FP_INFINITE___11 = 1,
    FP_ZERO___11 = 2,
    FP_SUBNORMAL___11 = 3,
    FP_NORMAL___11 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___6 {
    PTHREAD_CREATE_JOINABLE___10 = 0,
    PTHREAD_CREATE_DETACHED___10 = 1
} ;
#line 47
enum __anonenum__221___6 {
    PTHREAD_MUTEX_TIMED_NP___10 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___10 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___10 = 3,
    PTHREAD_MUTEX_NORMAL___10 = 0,
    PTHREAD_MUTEX_RECURSIVE___10 = 1,
    PTHREAD_MUTEX_ERRORCHECK___10 = 2,
    PTHREAD_MUTEX_DEFAULT___10 = 0
} ;
#line 69
enum __anonenum__222___6 {
    PTHREAD_MUTEX_STALLED___10 = 0,
    PTHREAD_MUTEX_STALLED_NP___10 = 0,
    PTHREAD_MUTEX_ROBUST___10 = 1,
    PTHREAD_MUTEX_ROBUST_NP___10 = 1
} ;
#line 81
enum __anonenum__223___6 {
    PTHREAD_PRIO_NONE___10 = 0,
    PTHREAD_PRIO_INHERIT___10 = 1,
    PTHREAD_PRIO_PROTECT___10 = 2
} ;
#line 104
enum __anonenum__224___6 {
    PTHREAD_RWLOCK_PREFER_READER_NP___10 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___10 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___10 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___10 = 0
} ;
#line 124
enum __anonenum__225___6 {
    PTHREAD_INHERIT_SCHED___10 = 0,
    PTHREAD_EXPLICIT_SCHED___10 = 1
} ;
#line 134
enum __anonenum__226___6 {
    PTHREAD_SCOPE_SYSTEM___10 = 0,
    PTHREAD_SCOPE_PROCESS___10 = 1
} ;
#line 144
enum __anonenum__227___6 {
    PTHREAD_PROCESS_PRIVATE___10 = 0,
    PTHREAD_PROCESS_SHARED___10 = 1
} ;
#line 168
enum __anonenum__228___6 {
    PTHREAD_CANCEL_ENABLE___10 = 0,
    PTHREAD_CANCEL_DISABLE___10 = 1
} ;
#line 175
enum __anonenum__229___6 {
    PTHREAD_CANCEL_DEFERRED___10 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___10 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___8 {
    FP_NAN___12 = 0,
    FP_INFINITE___12 = 1,
    FP_ZERO___12 = 2,
    FP_SUBNORMAL___12 = 3,
    FP_NORMAL___12 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___7 {
    PTHREAD_CREATE_JOINABLE___11 = 0,
    PTHREAD_CREATE_DETACHED___11 = 1
} ;
#line 47
enum __anonenum__221___7 {
    PTHREAD_MUTEX_TIMED_NP___11 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___11 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___11 = 3,
    PTHREAD_MUTEX_NORMAL___11 = 0,
    PTHREAD_MUTEX_RECURSIVE___11 = 1,
    PTHREAD_MUTEX_ERRORCHECK___11 = 2,
    PTHREAD_MUTEX_DEFAULT___11 = 0
} ;
#line 69
enum __anonenum__222___7 {
    PTHREAD_MUTEX_STALLED___11 = 0,
    PTHREAD_MUTEX_STALLED_NP___11 = 0,
    PTHREAD_MUTEX_ROBUST___11 = 1,
    PTHREAD_MUTEX_ROBUST_NP___11 = 1
} ;
#line 81
enum __anonenum__223___7 {
    PTHREAD_PRIO_NONE___11 = 0,
    PTHREAD_PRIO_INHERIT___11 = 1,
    PTHREAD_PRIO_PROTECT___11 = 2
} ;
#line 104
enum __anonenum__224___7 {
    PTHREAD_RWLOCK_PREFER_READER_NP___11 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___11 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___11 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___11 = 0
} ;
#line 124
enum __anonenum__225___7 {
    PTHREAD_INHERIT_SCHED___11 = 0,
    PTHREAD_EXPLICIT_SCHED___11 = 1
} ;
#line 134
enum __anonenum__226___7 {
    PTHREAD_SCOPE_SYSTEM___11 = 0,
    PTHREAD_SCOPE_PROCESS___11 = 1
} ;
#line 144
enum __anonenum__227___7 {
    PTHREAD_PROCESS_PRIVATE___11 = 0,
    PTHREAD_PROCESS_SHARED___11 = 1
} ;
#line 168
enum __anonenum__228___7 {
    PTHREAD_CANCEL_ENABLE___11 = 0,
    PTHREAD_CANCEL_DISABLE___11 = 1
} ;
#line 175
enum __anonenum__229___7 {
    PTHREAD_CANCEL_DEFERRED___11 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___11 = 1
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__19___9 {
    FP_NAN___13 = 0,
    FP_INFINITE___13 = 1,
    FP_ZERO___13 = 2,
    FP_SUBNORMAL___13 = 3,
    FP_NORMAL___13 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___8 {
    PTHREAD_CREATE_JOINABLE___12 = 0,
    PTHREAD_CREATE_DETACHED___12 = 1
} ;
#line 47
enum __anonenum__221___8 {
    PTHREAD_MUTEX_TIMED_NP___12 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___12 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___12 = 3,
    PTHREAD_MUTEX_NORMAL___12 = 0,
    PTHREAD_MUTEX_RECURSIVE___12 = 1,
    PTHREAD_MUTEX_ERRORCHECK___12 = 2,
    PTHREAD_MUTEX_DEFAULT___12 = 0
} ;
#line 69
enum __anonenum__222___8 {
    PTHREAD_MUTEX_STALLED___12 = 0,
    PTHREAD_MUTEX_STALLED_NP___12 = 0,
    PTHREAD_MUTEX_ROBUST___12 = 1,
    PTHREAD_MUTEX_ROBUST_NP___12 = 1
} ;
#line 81
enum __anonenum__223___8 {
    PTHREAD_PRIO_NONE___12 = 0,
    PTHREAD_PRIO_INHERIT___12 = 1,
    PTHREAD_PRIO_PROTECT___12 = 2
} ;
#line 104
enum __anonenum__224___8 {
    PTHREAD_RWLOCK_PREFER_READER_NP___12 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___12 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___12 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___12 = 0
} ;
#line 124
enum __anonenum__225___8 {
    PTHREAD_INHERIT_SCHED___12 = 0,
    PTHREAD_EXPLICIT_SCHED___12 = 1
} ;
#line 134
enum __anonenum__226___8 {
    PTHREAD_SCOPE_SYSTEM___12 = 0,
    PTHREAD_SCOPE_PROCESS___12 = 1
} ;
#line 144
enum __anonenum__227___8 {
    PTHREAD_PROCESS_PRIVATE___12 = 0,
    PTHREAD_PROCESS_SHARED___12 = 1
} ;
#line 168
enum __anonenum__228___8 {
    PTHREAD_CANCEL_ENABLE___12 = 0,
    PTHREAD_CANCEL_DISABLE___12 = 1
} ;
#line 175
enum __anonenum__229___8 {
    PTHREAD_CANCEL_DEFERRED___12 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___12 = 1
} ;
#line 18 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
typedef long bool;
#line 934 "/usr/include/math.h"
enum __anonenum__19___10 {
    FP_NAN___14 = 0,
    FP_INFINITE___14 = 1,
    FP_ZERO___14 = 2,
    FP_SUBNORMAL___14 = 3,
    FP_NORMAL___14 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__220___9 {
    PTHREAD_CREATE_JOINABLE___13 = 0,
    PTHREAD_CREATE_DETACHED___13 = 1
} ;
#line 47
enum __anonenum__221___9 {
    PTHREAD_MUTEX_TIMED_NP___13 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___13 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___13 = 3,
    PTHREAD_MUTEX_NORMAL___13 = 0,
    PTHREAD_MUTEX_RECURSIVE___13 = 1,
    PTHREAD_MUTEX_ERRORCHECK___13 = 2,
    PTHREAD_MUTEX_DEFAULT___13 = 0
} ;
#line 69
enum __anonenum__222___9 {
    PTHREAD_MUTEX_STALLED___13 = 0,
    PTHREAD_MUTEX_STALLED_NP___13 = 0,
    PTHREAD_MUTEX_ROBUST___13 = 1,
    PTHREAD_MUTEX_ROBUST_NP___13 = 1
} ;
#line 81
enum __anonenum__223___9 {
    PTHREAD_PRIO_NONE___13 = 0,
    PTHREAD_PRIO_INHERIT___13 = 1,
    PTHREAD_PRIO_PROTECT___13 = 2
} ;
#line 104
enum __anonenum__224___9 {
    PTHREAD_RWLOCK_PREFER_READER_NP___13 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___13 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___13 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___13 = 0
} ;
#line 124
enum __anonenum__225___9 {
    PTHREAD_INHERIT_SCHED___13 = 0,
    PTHREAD_EXPLICIT_SCHED___13 = 1
} ;
#line 134
enum __anonenum__226___9 {
    PTHREAD_SCOPE_SYSTEM___13 = 0,
    PTHREAD_SCOPE_PROCESS___13 = 1
} ;
#line 144
enum __anonenum__227___9 {
    PTHREAD_PROCESS_PRIVATE___13 = 0,
    PTHREAD_PROCESS_SHARED___13 = 1
} ;
#line 168
enum __anonenum__228___9 {
    PTHREAD_CANCEL_ENABLE___13 = 0,
    PTHREAD_CANCEL_DISABLE___13 = 1
} ;
#line 175
enum __anonenum__229___9 {
    PTHREAD_CANCEL_DEFERRED___13 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___13 = 1
} ;
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_276 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_276 max_align_t;
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.h"
struct aat_atree ;
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.h"
typedef struct aat_atree aat_atree_t;
#line 38
struct aat_atrav ;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.h"
typedef struct aat_atrav aat_atrav_t;
#line 42 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.h"
typedef int (*cmp_f)(void const   * , void const   * );
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
struct aat_anode {
   int level ;
   void *data ;
   struct aat_anode *link[2] ;
};
#line 39 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
typedef struct aat_anode aat_anode_t;
#line 41 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
struct aat_atree {
   aat_anode_t *root ;
   aat_anode_t *nil ;
   cmp_f cmp ;
   size_t size ;
};
#line 48 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
struct aat_atrav {
   aat_atree_t *tree ;
   aat_anode_t *it ;
   aat_anode_t *path[64] ;
   size_t top ;
};
#line 62 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
typedef int64_t longlong;
#line 137 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
typedef void *(*yajl_malloc_func)(void * , size_t  );
#line 141 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
typedef void (*yajl_free_func)(void * , void * );
#line 144 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
typedef void *(*yajl_realloc_func)(void * , void * , size_t  );
#line 148 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
struct __anonstruct_295 {
   yajl_malloc_func malloc ;
   yajl_realloc_func realloc ;
   yajl_free_func free ;
   void *ctx ;
};
#line 159 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_common.h"
typedef struct __anonstruct_295 yajl_alloc_funcs;
#line 41 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
enum __anonenum__317 {
    yajl_t_string = 1,
    yajl_t_number = 2,
    yajl_t_object = 3,
    yajl_t_array = 4,
    yajl_t_true = 5,
    yajl_t_false = 6,
    yajl_t_null = 7,
    yajl_t_any = 8
} ;
#line 53 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
typedef enum __anonenum__317 yajl_type;
#line 59
struct yajl_val_s ;
#line 59 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
typedef struct yajl_val_s *yajl_val;
#line 78 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
struct __anonstruct_319 {
   longlong i ;
   double d ;
   char *r ;
   unsigned int flags ;
};
#line 87 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
struct __anonstruct_320 {
   char const   **keys ;
   yajl_val *values ;
   size_t len ;
};
#line 92 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
struct __anonstruct_321 {
   yajl_val *values ;
   size_t len ;
};
#line 75 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
union __anonunion_318 {
   char *string ;
   struct __anonstruct_319 number ;
   struct __anonstruct_320 object ;
   struct __anonstruct_321 array ;
};
#line 68 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
struct yajl_val_s {
   yajl_type type ;
   union __anonunion_318 u ;
};
#line 33 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
enum __anonenum__322 {
    yajl_status_ok = 0,
    yajl_status_client_canceled = 1,
    yajl_status_error = 2
} ;
#line 41 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
typedef enum __anonenum__322 yajl_status;
#line 47
struct yajl_handle_t ;
#line 47 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
typedef struct yajl_handle_t *yajl_handle;
#line 74 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
struct __anonstruct_323 {
   int (*yajl_null)(void * ) ;
   int (*yajl_boolean)(void * , int  ) ;
   int (*yajl_integer)(void * , longlong  ) ;
   int (*yajl_double)(void * , double  ) ;
   int (*yajl_number)(void * , char const   * , size_t  ) ;
   int (*yajl_string)(void * , unsigned char const   * , size_t  ) ;
   int (*yajl_c_comment)(void * , unsigned char const   * , unsigned int  ) ;
   int (*yajl_cpp_comment)(void * , unsigned char const   * , unsigned int  ) ;
   int (*yajl_start_map)(void * ) ;
   int (*yajl_map_key)(void * , unsigned char const   * , size_t  ) ;
   int (*yajl_end_map)(void * ) ;
   int (*yajl_start_array)(void * ) ;
   int (*yajl_end_array)(void * ) ;
};
#line 102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
typedef struct __anonstruct_323 yajl_callbacks;
#line 121
enum __anonenum__324 {
    yajl_allow_comments = 1,
    yajl_dont_validate_strings = 2,
    yajl_allow_trailing_garbage = 4,
    yajl_allow_multiple_values = 8,
    yajl_allow_partial_values = 16
} ;
#line 166 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
typedef enum __anonenum__324 yajl_option;
#line 29 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_bytestack.h"
struct yajl_bytestack_t {
   unsigned char *stack ;
   size_t size ;
   size_t used ;
   yajl_alloc_funcs *yaf ;
};
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_bytestack.h"
typedef struct yajl_bytestack_t yajl_bytestack;
#line 34 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.h"
struct yajl_buf_t ;
#line 34 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.h"
typedef struct yajl_buf_t *yajl_buf;
#line 22 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.h"
enum __anonenum__325 {
    yajl_tok_bool = 0,
    yajl_tok_colon = 1,
    yajl_tok_comma = 2,
    yajl_tok_eof = 3,
    yajl_tok_error = 4,
    yajl_tok_left_brace = 5,
    yajl_tok_left_bracket = 6,
    yajl_tok_null = 7,
    yajl_tok_right_brace = 8,
    yajl_tok_right_bracket = 9,
    yajl_tok_integer = 10,
    yajl_tok_double = 11,
    yajl_tok_string = 12,
    yajl_tok_string_with_escapes = 13,
    yajl_tok_c_comment = 14,
    yajl_tok_cpp_comment = 15
} ;
#line 48 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.h"
typedef enum __anonenum__325 yajl_tok;
#line 50
struct yajl_lexer_t ;
#line 50 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.h"
typedef struct yajl_lexer_t *yajl_lexer;
#line 89
enum __anonenum__326 {
    yajl_lex_e_ok = 0,
    yajl_lex_string_invalid_utf8 = 1,
    yajl_lex_string_invalid_escaped_char = 2,
    yajl_lex_string_invalid_json_char = 3,
    yajl_lex_string_invalid_hex_char = 4,
    yajl_lex_invalid_char = 5,
    yajl_lex_invalid_string = 6,
    yajl_lex_missing_integer_after_decimal = 7,
    yajl_lex_missing_integer_after_exponent = 8,
    yajl_lex_missing_integer_after_minus = 9,
    yajl_lex_unallowed_comment = 10
} ;
#line 101 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.h"
typedef enum __anonenum__326 yajl_lex_error;
#line 26 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.h"
enum __anonenum__327 {
    yajl_state_start = 0,
    yajl_state_parse_complete = 1,
    yajl_state_parse_error = 2,
    yajl_state_lexical_error = 3,
    yajl_state_map_start = 4,
    yajl_state_map_sep = 5,
    yajl_state_map_need_val = 6,
    yajl_state_map_got_val = 7,
    yajl_state_map_need_key = 8,
    yajl_state_array_start = 9,
    yajl_state_array_got_val = 10,
    yajl_state_array_need_val = 11,
    yajl_state_got_value = 12
} ;
#line 40 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.h"
typedef enum __anonenum__327 yajl_state;
#line 42 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.h"
struct yajl_handle_t {
   yajl_callbacks *callbacks ;
   void *ctx ;
   yajl_lexer lexer ;
   char const   *parseError ;
   size_t bytesConsumed ;
   yajl_buf decodeBuf ;
   yajl_bytestack stateStack ;
   yajl_alloc_funcs alloc ;
   unsigned int flags ;
};
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
struct stack_elem_s ;
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
typedef struct stack_elem_s stack_elem_t;
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
struct stack_elem_s {
   char *key ;
   yajl_val value ;
   stack_elem_t *next ;
};
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
struct context_s {
   stack_elem_t *stack ;
   yajl_val root ;
   char *errbuf ;
   size_t errbuf_size ;
};
#line 51 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
typedef struct context_s context_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__330 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__331 {
    FP_NAN___15 = 0,
    FP_INFINITE___15 = 1,
    FP_ZERO___15 = 2,
    FP_SUBNORMAL___15 = 3,
    FP_NORMAL___15 = 4
} ;
#line 33 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
enum __anonenum__340 {
    yajl_gen_status_ok = 0,
    yajl_gen_keys_must_be_strings = 1,
    yajl_max_depth_exceeded = 2,
    yajl_gen_in_error_state = 3,
    yajl_gen_generation_complete = 4,
    yajl_gen_invalid_number = 5,
    yajl_gen_no_buf = 6,
    yajl_gen_invalid_string = 7
} ;
#line 57 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
typedef enum __anonenum__340 yajl_gen_status;
#line 60
struct yajl_gen_t ;
#line 60 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
typedef struct yajl_gen_t *yajl_gen;
#line 63 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
typedef void (*yajl_print_t)(void * , char const   * , size_t  );
#line 70
enum __anonenum__341 {
    yajl_gen_beautify = 1,
    yajl_gen_indent_string = 2,
    yajl_gen_print_callback = 4,
    yajl_gen_validate_utf8 = 8,
    yajl_gen_escape_solidus = 16
} ;
#line 102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
typedef enum __anonenum__341 yajl_gen_option;
#line 70 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
struct yajl_lexer_t {
   size_t lineOff ;
   size_t charOff ;
   yajl_lex_error error ;
   yajl_buf buf ;
   size_t bufOff ;
   unsigned int bufInUse ;
   unsigned int allowComments ;
   unsigned int validateUTF8 ;
   yajl_alloc_funcs *alloc ;
};
#line 934 "/usr/include/math.h"
enum __anonenum__19___11 {
    FP_NAN___16 = 0,
    FP_INFINITE___16 = 1,
    FP_ZERO___16 = 2,
    FP_SUBNORMAL___16 = 3,
    FP_NORMAL___16 = 4
} ;
#line 27 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
enum __anonenum__368 {
    yajl_gen_start = 0,
    yajl_gen_map_start = 1,
    yajl_gen_map_key = 2,
    yajl_gen_map_val = 3,
    yajl_gen_array_start = 4,
    yajl_gen_in_array = 5,
    yajl_gen_complete = 6,
    yajl_gen_error = 7
} ;
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
typedef enum __anonenum__368 yajl_gen_state;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
struct yajl_gen_t {
   unsigned int flags ;
   unsigned int depth ;
   char const   *indentString ;
   yajl_gen_state state[128] ;
   yajl_print_t print ;
   void *ctx ;
   unsigned char *pendingComment ;
   unsigned int pendingLen ;
   int pendingCpp ;
   yajl_alloc_funcs alloc ;
};
#line 25 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
struct yajl_buf_t {
   size_t len ;
   size_t used ;
   unsigned char *data ;
   yajl_alloc_funcs *alloc ;
};
#line 237 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
enum __anonenum__441 {
    PROTOBUF_C_FIELD_FLAG_PACKED = 1,
    PROTOBUF_C_FIELD_FLAG_DEPRECATED = 2
} ;
#line 243 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef enum __anonenum__441 ProtobufCFieldFlag;
#line 253
enum __anonenum__442 {
    PROTOBUF_C_LABEL_REQUIRED = 0,
    PROTOBUF_C_LABEL_OPTIONAL = 1,
    PROTOBUF_C_LABEL_REPEATED = 2
} ;
#line 269 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef enum __anonenum__442 ProtobufCLabel;
#line 279
enum __anonenum__443 {
    PROTOBUF_C_TYPE_INT32 = 0,
    PROTOBUF_C_TYPE_SINT32 = 1,
    PROTOBUF_C_TYPE_SFIXED32 = 2,
    PROTOBUF_C_TYPE_INT64 = 3,
    PROTOBUF_C_TYPE_SINT64 = 4,
    PROTOBUF_C_TYPE_SFIXED64 = 5,
    PROTOBUF_C_TYPE_UINT32 = 6,
    PROTOBUF_C_TYPE_FIXED32 = 7,
    PROTOBUF_C_TYPE_UINT64 = 8,
    PROTOBUF_C_TYPE_FIXED64 = 9,
    PROTOBUF_C_TYPE_FLOAT = 10,
    PROTOBUF_C_TYPE_DOUBLE = 11,
    PROTOBUF_C_TYPE_BOOL = 12,
    PROTOBUF_C_TYPE_ENUM = 13,
    PROTOBUF_C_TYPE_STRING = 14,
    PROTOBUF_C_TYPE_BYTES = 15,
    PROTOBUF_C_TYPE_MESSAGE = 16
} ;
#line 297 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef enum __anonenum__443 ProtobufCType;
#line 307
enum __anonenum__444 {
    PROTOBUF_C_WIRE_TYPE_VARINT = 0,
    PROTOBUF_C_WIRE_TYPE_64BIT = 1,
    PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED = 2,
    PROTOBUF_C_WIRE_TYPE_32BIT = 5
} ;
#line 313 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef enum __anonenum__444 ProtobufCWireType;
#line 315
struct ProtobufCAllocator ;
#line 316
struct ProtobufCBinaryData ;
#line 317
struct ProtobufCBuffer ;
#line 318
struct ProtobufCBufferSimple ;
#line 319
struct ProtobufCEnumDescriptor ;
#line 320
struct ProtobufCEnumValue ;
#line 321
struct ProtobufCEnumValueIndex ;
#line 322
struct ProtobufCFieldDescriptor ;
#line 323
struct ProtobufCIntRange ;
#line 324
struct ProtobufCMessage ;
#line 325
struct ProtobufCMessageDescriptor ;
#line 326
struct ProtobufCMessageUnknownField ;
#line 327
struct ProtobufCMethodDescriptor ;
#line 328
struct ProtobufCService ;
#line 329
struct ProtobufCServiceDescriptor ;
#line 331 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCAllocator ProtobufCAllocator;
#line 332 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCBinaryData ProtobufCBinaryData;
#line 333 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCBuffer ProtobufCBuffer;
#line 334 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCBufferSimple ProtobufCBufferSimple;
#line 335 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCEnumDescriptor ProtobufCEnumDescriptor;
#line 336 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCEnumValue ProtobufCEnumValue;
#line 337 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCEnumValueIndex ProtobufCEnumValueIndex;
#line 338 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCFieldDescriptor ProtobufCFieldDescriptor;
#line 339 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCIntRange ProtobufCIntRange;
#line 340 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCMessage ProtobufCMessage;
#line 341 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCMessageDescriptor ProtobufCMessageDescriptor;
#line 342 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCMessageUnknownField ProtobufCMessageUnknownField;
#line 343 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCMethodDescriptor ProtobufCMethodDescriptor;
#line 344 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCService ProtobufCService;
#line 345 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef struct ProtobufCServiceDescriptor ProtobufCServiceDescriptor;
#line 348 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef int protobuf_c_boolean;
#line 350 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef void (*ProtobufCClosure)(ProtobufCMessage * , void * );
#line 351 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef void (*ProtobufCMessageInit)(ProtobufCMessage * );
#line 352 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
typedef void (*ProtobufCServiceDestroy)(ProtobufCService * );
#line 357 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCAllocator {
   void *(*alloc)(void * , size_t  ) ;
   void (*free)(void * , void * ) ;
   void *allocator_data ;
};
#line 375 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCBinaryData {
   size_t len ;
   uint8_t *data ;
};
#line 415 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCBuffer {
   void (*append)(ProtobufCBuffer * , size_t  , uint8_t * ) ;
};
#line 450 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCBufferSimple {
   ProtobufCBuffer base ;
   size_t alloced ;
   size_t len ;
   uint8_t *data ;
   protobuf_c_boolean must_free_data ;
   ProtobufCAllocator *allocator ;
};
#line 468 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCEnumDescriptor {
   uint32_t magic ;
   char const   *name ;
   char const   *short_name ;
   char const   *c_name ;
   char const   *package_name ;
   unsigned int n_values ;
   ProtobufCEnumValue *values ;
   unsigned int n_value_names ;
   ProtobufCEnumValueIndex *values_by_name ;
   unsigned int n_value_ranges ;
   ProtobufCIntRange *value_ranges ;
   void *reserved1 ;
   void *reserved2 ;
   void *reserved3 ;
   void *reserved4 ;
};
#line 509 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCEnumValue {
   char const   *name ;
   char const   *c_name ;
   int value ;
};
#line 523 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCEnumValueIndex {
   char const   *name ;
   unsigned int index ;
};
#line 533 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCFieldDescriptor {
   char const   *name ;
   uint32_t id ;
   ProtobufCLabel label ;
   ProtobufCType type ;
   unsigned int quantifier_offset ;
   unsigned int offset ;
   void const   *descriptor ;
   void const   *default_value ;
   uint32_t flags ;
   unsigned int reserved_flags ;
   void *reserved2 ;
   void *reserved3 ;
};
#line 597 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCIntRange {
   int start_value ;
   unsigned int orig_index ;
};
#line 622 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCMessage {
   ProtobufCMessageDescriptor *descriptor ;
   unsigned int n_unknown_fields ;
   ProtobufCMessageUnknownField *unknown_fields ;
};
#line 634 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCMessageDescriptor {
   uint32_t magic ;
   char const   *name ;
   char const   *short_name ;
   char const   *c_name ;
   char const   *package_name ;
   size_t sizeof_message ;
   unsigned int n_fields ;
   ProtobufCFieldDescriptor *fields ;
   unsigned int const   *fields_sorted_by_name ;
   unsigned int n_field_ranges ;
   ProtobufCIntRange *field_ranges ;
   ProtobufCMessageInit message_init ;
   void *reserved1 ;
   void *reserved2 ;
   void *reserved3 ;
};
#line 679 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCMessageUnknownField {
   uint32_t tag ;
   ProtobufCWireType wire_type ;
   size_t len ;
   uint8_t *data ;
};
#line 693 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCMethodDescriptor {
   char const   *name ;
   ProtobufCMessageDescriptor *input ;
   ProtobufCMessageDescriptor *output ;
};
#line 705 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCService {
   ProtobufCServiceDescriptor *descriptor ;
   void (*invoke)(ProtobufCService * , unsigned int  , ProtobufCMessage * , ProtobufCClosure  ,
                  void * ) ;
   void (*destroy)(ProtobufCService * ) ;
};
#line 721 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
struct ProtobufCServiceDescriptor {
   uint32_t magic ;
   char const   *name ;
   char const   *short_name ;
   char const   *c_name ;
   char const   *package ;
   unsigned int n_methods ;
   ProtobufCMethodDescriptor *methods ;
   unsigned int const   *method_indices_by_name ;
};
#line 1844 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
struct _ScannedMember ;
#line 1844 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
typedef struct _ScannedMember ScannedMember;
#line 1846 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
struct _ScannedMember {
   uint32_t tag ;
   uint8_t wire_type ;
   uint8_t length_prefix_len ;
   ProtobufCFieldDescriptor *field ;
   size_t len ;
   uint8_t *data ;
};
#line 3132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
typedef void (*GenericHandler)(void * , ProtobufCMessage * , ProtobufCClosure  , void * );
#line 934 "/usr/include/math.h"
enum __anonenum__233___0 {
    FP_NAN___17 = 0,
    FP_INFINITE___17 = 1,
    FP_ZERO___17 = 2,
    FP_SUBNORMAL___17 = 3,
    FP_NORMAL___17 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__446 {
    PTHREAD_CREATE_JOINABLE___14 = 0,
    PTHREAD_CREATE_DETACHED___14 = 1
} ;
#line 47
enum __anonenum__447 {
    PTHREAD_MUTEX_TIMED_NP___14 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___14 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___14 = 3,
    PTHREAD_MUTEX_NORMAL___14 = 0,
    PTHREAD_MUTEX_RECURSIVE___14 = 1,
    PTHREAD_MUTEX_ERRORCHECK___14 = 2,
    PTHREAD_MUTEX_DEFAULT___14 = 0
} ;
#line 69
enum __anonenum__448 {
    PTHREAD_MUTEX_STALLED___14 = 0,
    PTHREAD_MUTEX_STALLED_NP___14 = 0,
    PTHREAD_MUTEX_ROBUST___14 = 1,
    PTHREAD_MUTEX_ROBUST_NP___14 = 1
} ;
#line 81
enum __anonenum__449 {
    PTHREAD_PRIO_NONE___14 = 0,
    PTHREAD_PRIO_INHERIT___14 = 1,
    PTHREAD_PRIO_PROTECT___14 = 2
} ;
#line 104
enum __anonenum__450 {
    PTHREAD_RWLOCK_PREFER_READER_NP___14 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___14 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___14 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___14 = 0
} ;
#line 124
enum __anonenum__451 {
    PTHREAD_INHERIT_SCHED___14 = 0,
    PTHREAD_EXPLICIT_SCHED___14 = 1
} ;
#line 134
enum __anonenum__452 {
    PTHREAD_SCOPE_SYSTEM___14 = 0,
    PTHREAD_SCOPE_PROCESS___14 = 1
} ;
#line 144
enum __anonenum__453 {
    PTHREAD_PROCESS_PRIVATE___14 = 0,
    PTHREAD_PROCESS_SHARED___14 = 1
} ;
#line 168
enum __anonenum__454 {
    PTHREAD_CANCEL_ENABLE___14 = 0,
    PTHREAD_CANCEL_DISABLE___14 = 1
} ;
#line 175
enum __anonenum__455 {
    PTHREAD_CANCEL_DEFERRED___14 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___14 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__459 {
    _PC_LINK_MAX___4 = 0,
    _PC_MAX_CANON___4 = 1,
    _PC_MAX_INPUT___4 = 2,
    _PC_NAME_MAX___4 = 3,
    _PC_PATH_MAX___4 = 4,
    _PC_PIPE_BUF___4 = 5,
    _PC_CHOWN_RESTRICTED___4 = 6,
    _PC_NO_TRUNC___4 = 7,
    _PC_VDISABLE___4 = 8,
    _PC_SYNC_IO___4 = 9,
    _PC_ASYNC_IO___4 = 10,
    _PC_PRIO_IO___4 = 11,
    _PC_SOCK_MAXBUF___4 = 12,
    _PC_FILESIZEBITS___4 = 13,
    _PC_REC_INCR_XFER_SIZE___4 = 14,
    _PC_REC_MAX_XFER_SIZE___4 = 15,
    _PC_REC_MIN_XFER_SIZE___4 = 16,
    _PC_REC_XFER_ALIGN___4 = 17,
    _PC_ALLOC_SIZE_MIN___4 = 18,
    _PC_SYMLINK_MAX___4 = 19,
    _PC_2_SYMLINKS___4 = 20
} ;
#line 71
enum __anonenum__460 {
    _SC_ARG_MAX___4 = 0,
    _SC_CHILD_MAX___4 = 1,
    _SC_CLK_TCK___4 = 2,
    _SC_NGROUPS_MAX___4 = 3,
    _SC_OPEN_MAX___4 = 4,
    _SC_STREAM_MAX___4 = 5,
    _SC_TZNAME_MAX___4 = 6,
    _SC_JOB_CONTROL___4 = 7,
    _SC_SAVED_IDS___4 = 8,
    _SC_REALTIME_SIGNALS___4 = 9,
    _SC_PRIORITY_SCHEDULING___4 = 10,
    _SC_TIMERS___4 = 11,
    _SC_ASYNCHRONOUS_IO___4 = 12,
    _SC_PRIORITIZED_IO___4 = 13,
    _SC_SYNCHRONIZED_IO___4 = 14,
    _SC_FSYNC___4 = 15,
    _SC_MAPPED_FILES___4 = 16,
    _SC_MEMLOCK___4 = 17,
    _SC_MEMLOCK_RANGE___4 = 18,
    _SC_MEMORY_PROTECTION___4 = 19,
    _SC_MESSAGE_PASSING___4 = 20,
    _SC_SEMAPHORES___4 = 21,
    _SC_SHARED_MEMORY_OBJECTS___4 = 22,
    _SC_AIO_LISTIO_MAX___4 = 23,
    _SC_AIO_MAX___4 = 24,
    _SC_AIO_PRIO_DELTA_MAX___4 = 25,
    _SC_DELAYTIMER_MAX___4 = 26,
    _SC_MQ_OPEN_MAX___4 = 27,
    _SC_MQ_PRIO_MAX___4 = 28,
    _SC_VERSION___4 = 29,
    _SC_PAGESIZE___4 = 30,
    _SC_RTSIG_MAX___4 = 31,
    _SC_SEM_NSEMS_MAX___4 = 32,
    _SC_SEM_VALUE_MAX___4 = 33,
    _SC_SIGQUEUE_MAX___4 = 34,
    _SC_TIMER_MAX___4 = 35,
    _SC_BC_BASE_MAX___4 = 36,
    _SC_BC_DIM_MAX___4 = 37,
    _SC_BC_SCALE_MAX___4 = 38,
    _SC_BC_STRING_MAX___4 = 39,
    _SC_COLL_WEIGHTS_MAX___4 = 40,
    _SC_EQUIV_CLASS_MAX___4 = 41,
    _SC_EXPR_NEST_MAX___4 = 42,
    _SC_LINE_MAX___4 = 43,
    _SC_RE_DUP_MAX___4 = 44,
    _SC_CHARCLASS_NAME_MAX___4 = 45,
    _SC_2_VERSION___4 = 46,
    _SC_2_C_BIND___4 = 47,
    _SC_2_C_DEV___4 = 48,
    _SC_2_FORT_DEV___4 = 49,
    _SC_2_FORT_RUN___4 = 50,
    _SC_2_SW_DEV___4 = 51,
    _SC_2_LOCALEDEF___4 = 52,
    _SC_PII___4 = 53,
    _SC_PII_XTI___4 = 54,
    _SC_PII_SOCKET___4 = 55,
    _SC_PII_INTERNET___4 = 56,
    _SC_PII_OSI___4 = 57,
    _SC_POLL___4 = 58,
    _SC_SELECT___4 = 59,
    _SC_UIO_MAXIOV___4 = 60,
    _SC_IOV_MAX___4 = 60,
    _SC_PII_INTERNET_STREAM___4 = 61,
    _SC_PII_INTERNET_DGRAM___4 = 62,
    _SC_PII_OSI_COTS___4 = 63,
    _SC_PII_OSI_CLTS___4 = 64,
    _SC_PII_OSI_M___4 = 65,
    _SC_T_IOV_MAX___4 = 66,
    _SC_THREADS___4 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___4 = 68,
    _SC_GETGR_R_SIZE_MAX___4 = 69,
    _SC_GETPW_R_SIZE_MAX___4 = 70,
    _SC_LOGIN_NAME_MAX___4 = 71,
    _SC_TTY_NAME_MAX___4 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___4 = 73,
    _SC_THREAD_KEYS_MAX___4 = 74,
    _SC_THREAD_STACK_MIN___4 = 75,
    _SC_THREAD_THREADS_MAX___4 = 76,
    _SC_THREAD_ATTR_STACKADDR___4 = 77,
    _SC_THREAD_ATTR_STACKSIZE___4 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___4 = 79,
    _SC_THREAD_PRIO_INHERIT___4 = 80,
    _SC_THREAD_PRIO_PROTECT___4 = 81,
    _SC_THREAD_PROCESS_SHARED___4 = 82,
    _SC_NPROCESSORS_CONF___4 = 83,
    _SC_NPROCESSORS_ONLN___4 = 84,
    _SC_PHYS_PAGES___4 = 85,
    _SC_AVPHYS_PAGES___4 = 86,
    _SC_ATEXIT_MAX___4 = 87,
    _SC_PASS_MAX___4 = 88,
    _SC_XOPEN_VERSION___4 = 89,
    _SC_XOPEN_XCU_VERSION___4 = 90,
    _SC_XOPEN_UNIX___4 = 91,
    _SC_XOPEN_CRYPT___4 = 92,
    _SC_XOPEN_ENH_I18N___4 = 93,
    _SC_XOPEN_SHM___4 = 94,
    _SC_2_CHAR_TERM___4 = 95,
    _SC_2_C_VERSION___4 = 96,
    _SC_2_UPE___4 = 97,
    _SC_XOPEN_XPG2___4 = 98,
    _SC_XOPEN_XPG3___4 = 99,
    _SC_XOPEN_XPG4___4 = 100,
    _SC_CHAR_BIT___4 = 101,
    _SC_CHAR_MAX___4 = 102,
    _SC_CHAR_MIN___4 = 103,
    _SC_INT_MAX___4 = 104,
    _SC_INT_MIN___4 = 105,
    _SC_LONG_BIT___4 = 106,
    _SC_WORD_BIT___4 = 107,
    _SC_MB_LEN_MAX___4 = 108,
    _SC_NZERO___4 = 109,
    _SC_SSIZE_MAX___4 = 110,
    _SC_SCHAR_MAX___4 = 111,
    _SC_SCHAR_MIN___4 = 112,
    _SC_SHRT_MAX___4 = 113,
    _SC_SHRT_MIN___4 = 114,
    _SC_UCHAR_MAX___4 = 115,
    _SC_UINT_MAX___4 = 116,
    _SC_ULONG_MAX___4 = 117,
    _SC_USHRT_MAX___4 = 118,
    _SC_NL_ARGMAX___4 = 119,
    _SC_NL_LANGMAX___4 = 120,
    _SC_NL_MSGMAX___4 = 121,
    _SC_NL_NMAX___4 = 122,
    _SC_NL_SETMAX___4 = 123,
    _SC_NL_TEXTMAX___4 = 124,
    _SC_XBS5_ILP32_OFF32___4 = 125,
    _SC_XBS5_ILP32_OFFBIG___4 = 126,
    _SC_XBS5_LP64_OFF64___4 = 127,
    _SC_XBS5_LPBIG_OFFBIG___4 = 128,
    _SC_XOPEN_LEGACY___4 = 129,
    _SC_XOPEN_REALTIME___4 = 130,
    _SC_XOPEN_REALTIME_THREADS___4 = 131,
    _SC_ADVISORY_INFO___4 = 132,
    _SC_BARRIERS___4 = 133,
    _SC_BASE___4 = 134,
    _SC_C_LANG_SUPPORT___4 = 135,
    _SC_C_LANG_SUPPORT_R___4 = 136,
    _SC_CLOCK_SELECTION___4 = 137,
    _SC_CPUTIME___4 = 138,
    _SC_THREAD_CPUTIME___4 = 139,
    _SC_DEVICE_IO___4 = 140,
    _SC_DEVICE_SPECIFIC___4 = 141,
    _SC_DEVICE_SPECIFIC_R___4 = 142,
    _SC_FD_MGMT___4 = 143,
    _SC_FIFO___4 = 144,
    _SC_PIPE___4 = 145,
    _SC_FILE_ATTRIBUTES___4 = 146,
    _SC_FILE_LOCKING___4 = 147,
    _SC_FILE_SYSTEM___4 = 148,
    _SC_MONOTONIC_CLOCK___4 = 149,
    _SC_MULTI_PROCESS___4 = 150,
    _SC_SINGLE_PROCESS___4 = 151,
    _SC_NETWORKING___4 = 152,
    _SC_READER_WRITER_LOCKS___4 = 153,
    _SC_SPIN_LOCKS___4 = 154,
    _SC_REGEXP___4 = 155,
    _SC_REGEX_VERSION___4 = 156,
    _SC_SHELL___4 = 157,
    _SC_SIGNALS___4 = 158,
    _SC_SPAWN___4 = 159,
    _SC_SPORADIC_SERVER___4 = 160,
    _SC_THREAD_SPORADIC_SERVER___4 = 161,
    _SC_SYSTEM_DATABASE___4 = 162,
    _SC_SYSTEM_DATABASE_R___4 = 163,
    _SC_TIMEOUTS___4 = 164,
    _SC_TYPED_MEMORY_OBJECTS___4 = 165,
    _SC_USER_GROUPS___4 = 166,
    _SC_USER_GROUPS_R___4 = 167,
    _SC_2_PBS___4 = 168,
    _SC_2_PBS_ACCOUNTING___4 = 169,
    _SC_2_PBS_LOCATE___4 = 170,
    _SC_2_PBS_MESSAGE___4 = 171,
    _SC_2_PBS_TRACK___4 = 172,
    _SC_SYMLOOP_MAX___4 = 173,
    _SC_STREAMS___4 = 174,
    _SC_2_PBS_CHECKPOINT___4 = 175,
    _SC_V6_ILP32_OFF32___4 = 176,
    _SC_V6_ILP32_OFFBIG___4 = 177,
    _SC_V6_LP64_OFF64___4 = 178,
    _SC_V6_LPBIG_OFFBIG___4 = 179,
    _SC_HOST_NAME_MAX___4 = 180,
    _SC_TRACE___4 = 181,
    _SC_TRACE_EVENT_FILTER___4 = 182,
    _SC_TRACE_INHERIT___4 = 183,
    _SC_TRACE_LOG___4 = 184,
    _SC_LEVEL1_ICACHE_SIZE___4 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___4 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___4 = 187,
    _SC_LEVEL1_DCACHE_SIZE___4 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___4 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___4 = 190,
    _SC_LEVEL2_CACHE_SIZE___4 = 191,
    _SC_LEVEL2_CACHE_ASSOC___4 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___4 = 193,
    _SC_LEVEL3_CACHE_SIZE___4 = 194,
    _SC_LEVEL3_CACHE_ASSOC___4 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___4 = 196,
    _SC_LEVEL4_CACHE_SIZE___4 = 197,
    _SC_LEVEL4_CACHE_ASSOC___4 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___4 = 199,
    _SC_IPV6___4 = 235,
    _SC_RAW_SOCKETS___4 = 236,
    _SC_V7_ILP32_OFF32___4 = 237,
    _SC_V7_ILP32_OFFBIG___4 = 238,
    _SC_V7_LP64_OFF64___4 = 239,
    _SC_V7_LPBIG_OFFBIG___4 = 240,
    _SC_SS_REPL_MAX___4 = 241,
    _SC_TRACE_EVENT_NAME_MAX___4 = 242,
    _SC_TRACE_NAME_MAX___4 = 243,
    _SC_TRACE_SYS_MAX___4 = 244,
    _SC_TRACE_USER_EVENT_MAX___4 = 245,
    _SC_XOPEN_STREAMS___4 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___4 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___4 = 248,
    _SC_MINSIGSTKSZ___4 = 249,
    _SC_SIGSTKSZ___4 = 250
} ;
#line 539
enum __anonenum__461 {
    _CS_PATH___4 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___4 = 1,
    _CS_GNU_LIBC_VERSION___4 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___4 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___4 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___4 = 5,
    _CS_LFS_CFLAGS___4 = 1000,
    _CS_LFS_LDFLAGS___4 = 1001,
    _CS_LFS_LIBS___4 = 1002,
    _CS_LFS_LINTFLAGS___4 = 1003,
    _CS_LFS64_CFLAGS___4 = 1004,
    _CS_LFS64_LDFLAGS___4 = 1005,
    _CS_LFS64_LIBS___4 = 1006,
    _CS_LFS64_LINTFLAGS___4 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___4 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___4 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___4 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___4 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___4 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___4 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___4 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___4 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___4 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___4 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___4 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___4 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___4 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___4 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___4 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___4 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___4 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___4 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___4 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___4 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___4 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___4 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___4 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___4 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___4 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___4 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___4 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___4 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___4 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___4 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___4 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___4 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___4 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___4 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___4 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___4 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___4 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___4 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___4 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___4 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___4 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___4 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___4 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___4 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___4 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___4 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___4 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___4 = 1147,
    _CS_V6_ENV___4 = 1148,
    _CS_V7_ENV___4 = 1149
} ;
#line 24 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.h"
enum __anonenum__479 {
    cctyp_unkn = 0,
    cctyp_1 = 1,
    cctyp_2 = 2,
    cctyp_Audio = 3,
    cctyp_Ultra = 4,
    cctyp_Other = 5
} ;
#line 31 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.h"
typedef enum __anonenum__479 cctype;
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.h"
struct _ccast_id {
   char *name ;
   char *ip ;
   cctype typ ;
};
#line 40 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.h"
typedef struct _ccast_id ccast_id;
#line 23 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
enum __anonenum__480 {
    ccpacket_OK = 0,
    ccpacket_malloc = 1,
    ccpacket_context = 2,
    ccpacket_connect = 3,
    ccpacket_ssl = 4,
    ccpacket_timeout = 5,
    ccpacket_send = 6,
    ccpacket_recv = 7
} ;
#line 33 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
typedef enum __anonenum__480 ccpacket_err;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
struct _ccpacket {
   void (*del)(struct _ccpacket * ) ;
   ccpacket_err (*connect)(struct _ccpacket * , char * , int  ) ;
   ccpacket_err (*reconnect)(struct _ccpacket * ) ;
   ccpacket_err (*send)(struct _ccpacket * , uint8_t * , uint32_t  ) ;
   ccpacket_err (*receive)(struct _ccpacket * , uint8_t ** , uint32_t * ) ;
};
#line 78 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
typedef struct _ccpacket ccpacket;
#line 25 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
struct _ccmes {
   struct _ccmes *next ;
   yajl_val tnode ;
   char *mtype ;
   int rqid ;
   char *source_id ;
   char *destination_id ;
   char *namespace ;
   int binary ;
   uint8_t *data ;
   uint32_t bin_len ;
};
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
typedef struct _ccmes ccmes;
#line 53
enum __anonenum__481 {
    ccmessv_OK = 0,
    ccmessv_malloc = 1,
    ccmessv_context = 2,
    ccmessv_connect = 3,
    ccmessv_ssl = 4,
    ccmessv_send = 5,
    ccmessv_recv = 6,
    ccmessv_unpack = 7,
    ccmessv_timeout = 8,
    ccmessv_closed = 9
} ;
#line 65 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
typedef enum __anonenum__481 ccmessv_err;
#line 72 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
struct _ccmessv {
   void (*del)(struct _ccmessv * ) ;
   ccmessv_err (*send)(struct _ccmessv * , ccmes * ) ;
   ccmessv_err (*receive)(struct _ccmessv * , ccmes * ) ;
   ccpacket *pk ;
   pthread_mutex_t slock ;
};
#line 91 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
typedef struct _ccmessv ccmessv;
#line 27 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.h"
struct _ccast {
   ccast_id id ;
   struct _ccmessv *messv ;
   int requestId ;
   char *sessionId ;
   char *transportId ;
   void (*del)(struct _ccast * ) ;
   int (*load)(struct _ccast * , char * , unsigned char * , size_t  , double [3] ,
               double  , double  , double  , double  ) ;
   void (*shutdown)(struct _ccast * ) ;
   int (*get_load_delay)(struct _ccast * ) ;
   int (*get_direct_send)(struct _ccast * ) ;
   athread *rmesth ;
   struct _ccmes *rmes ;
   pthread_mutex_t rlock ;
   pthread_cond_t rcond ;
   int w_rq ;
   char *w_rqns ;
   int w_rqid ;
   int stop ;
   int stopped ;
   int mediaSessionId ;
   int loaded1 ;
   int forcedef ;
   int patgenrcv ;
   int load_delay ;
   struct _ccast *next ;
};
#line 71 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.h"
typedef struct _ccast ccast;
#line 315 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
struct optcntx {
   int di ;
   double *val ;
   double (*ressur)[8][3] ;
};
#line 319 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
typedef struct optcntx optcntx;
#line 364 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
struct __anonstruct_482 {
   int x ;
   int y ;
};
#line 934 "/usr/include/math.h"
enum __anonenum__502 {
    FP_NAN___18 = 0,
    FP_INFINITE___18 = 1,
    FP_ZERO___18 = 2,
    FP_SUBNORMAL___18 = 3,
    FP_NORMAL___18 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__503 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__505 {
    PTHREAD_CREATE_JOINABLE___15 = 0,
    PTHREAD_CREATE_DETACHED___15 = 1
} ;
#line 47
enum __anonenum__506 {
    PTHREAD_MUTEX_TIMED_NP___15 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___15 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___15 = 3,
    PTHREAD_MUTEX_NORMAL___15 = 0,
    PTHREAD_MUTEX_RECURSIVE___15 = 1,
    PTHREAD_MUTEX_ERRORCHECK___15 = 2,
    PTHREAD_MUTEX_DEFAULT___15 = 0
} ;
#line 69
enum __anonenum__507 {
    PTHREAD_MUTEX_STALLED___15 = 0,
    PTHREAD_MUTEX_STALLED_NP___15 = 0,
    PTHREAD_MUTEX_ROBUST___15 = 1,
    PTHREAD_MUTEX_ROBUST_NP___15 = 1
} ;
#line 81
enum __anonenum__508 {
    PTHREAD_PRIO_NONE___15 = 0,
    PTHREAD_PRIO_INHERIT___15 = 1,
    PTHREAD_PRIO_PROTECT___15 = 2
} ;
#line 104
enum __anonenum__509 {
    PTHREAD_RWLOCK_PREFER_READER_NP___15 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___15 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___15 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___15 = 0
} ;
#line 124
enum __anonenum__510 {
    PTHREAD_INHERIT_SCHED___15 = 0,
    PTHREAD_EXPLICIT_SCHED___15 = 1
} ;
#line 134
enum __anonenum__511 {
    PTHREAD_SCOPE_SYSTEM___15 = 0,
    PTHREAD_SCOPE_PROCESS___15 = 1
} ;
#line 144
enum __anonenum__512 {
    PTHREAD_PROCESS_PRIVATE___15 = 0,
    PTHREAD_PROCESS_SHARED___15 = 1
} ;
#line 168
enum __anonenum__513 {
    PTHREAD_CANCEL_ENABLE___15 = 0,
    PTHREAD_CANCEL_DISABLE___15 = 1
} ;
#line 175
enum __anonenum__514 {
    PTHREAD_CANCEL_DEFERRED___15 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___15 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__517 {
    _PC_LINK_MAX___5 = 0,
    _PC_MAX_CANON___5 = 1,
    _PC_MAX_INPUT___5 = 2,
    _PC_NAME_MAX___5 = 3,
    _PC_PATH_MAX___5 = 4,
    _PC_PIPE_BUF___5 = 5,
    _PC_CHOWN_RESTRICTED___5 = 6,
    _PC_NO_TRUNC___5 = 7,
    _PC_VDISABLE___5 = 8,
    _PC_SYNC_IO___5 = 9,
    _PC_ASYNC_IO___5 = 10,
    _PC_PRIO_IO___5 = 11,
    _PC_SOCK_MAXBUF___5 = 12,
    _PC_FILESIZEBITS___5 = 13,
    _PC_REC_INCR_XFER_SIZE___5 = 14,
    _PC_REC_MAX_XFER_SIZE___5 = 15,
    _PC_REC_MIN_XFER_SIZE___5 = 16,
    _PC_REC_XFER_ALIGN___5 = 17,
    _PC_ALLOC_SIZE_MIN___5 = 18,
    _PC_SYMLINK_MAX___5 = 19,
    _PC_2_SYMLINKS___5 = 20
} ;
#line 71
enum __anonenum__518 {
    _SC_ARG_MAX___5 = 0,
    _SC_CHILD_MAX___5 = 1,
    _SC_CLK_TCK___5 = 2,
    _SC_NGROUPS_MAX___5 = 3,
    _SC_OPEN_MAX___5 = 4,
    _SC_STREAM_MAX___5 = 5,
    _SC_TZNAME_MAX___5 = 6,
    _SC_JOB_CONTROL___5 = 7,
    _SC_SAVED_IDS___5 = 8,
    _SC_REALTIME_SIGNALS___5 = 9,
    _SC_PRIORITY_SCHEDULING___5 = 10,
    _SC_TIMERS___5 = 11,
    _SC_ASYNCHRONOUS_IO___5 = 12,
    _SC_PRIORITIZED_IO___5 = 13,
    _SC_SYNCHRONIZED_IO___5 = 14,
    _SC_FSYNC___5 = 15,
    _SC_MAPPED_FILES___5 = 16,
    _SC_MEMLOCK___5 = 17,
    _SC_MEMLOCK_RANGE___5 = 18,
    _SC_MEMORY_PROTECTION___5 = 19,
    _SC_MESSAGE_PASSING___5 = 20,
    _SC_SEMAPHORES___5 = 21,
    _SC_SHARED_MEMORY_OBJECTS___5 = 22,
    _SC_AIO_LISTIO_MAX___5 = 23,
    _SC_AIO_MAX___5 = 24,
    _SC_AIO_PRIO_DELTA_MAX___5 = 25,
    _SC_DELAYTIMER_MAX___5 = 26,
    _SC_MQ_OPEN_MAX___5 = 27,
    _SC_MQ_PRIO_MAX___5 = 28,
    _SC_VERSION___5 = 29,
    _SC_PAGESIZE___5 = 30,
    _SC_RTSIG_MAX___5 = 31,
    _SC_SEM_NSEMS_MAX___5 = 32,
    _SC_SEM_VALUE_MAX___5 = 33,
    _SC_SIGQUEUE_MAX___5 = 34,
    _SC_TIMER_MAX___5 = 35,
    _SC_BC_BASE_MAX___5 = 36,
    _SC_BC_DIM_MAX___5 = 37,
    _SC_BC_SCALE_MAX___5 = 38,
    _SC_BC_STRING_MAX___5 = 39,
    _SC_COLL_WEIGHTS_MAX___5 = 40,
    _SC_EQUIV_CLASS_MAX___5 = 41,
    _SC_EXPR_NEST_MAX___5 = 42,
    _SC_LINE_MAX___5 = 43,
    _SC_RE_DUP_MAX___5 = 44,
    _SC_CHARCLASS_NAME_MAX___5 = 45,
    _SC_2_VERSION___5 = 46,
    _SC_2_C_BIND___5 = 47,
    _SC_2_C_DEV___5 = 48,
    _SC_2_FORT_DEV___5 = 49,
    _SC_2_FORT_RUN___5 = 50,
    _SC_2_SW_DEV___5 = 51,
    _SC_2_LOCALEDEF___5 = 52,
    _SC_PII___5 = 53,
    _SC_PII_XTI___5 = 54,
    _SC_PII_SOCKET___5 = 55,
    _SC_PII_INTERNET___5 = 56,
    _SC_PII_OSI___5 = 57,
    _SC_POLL___5 = 58,
    _SC_SELECT___5 = 59,
    _SC_UIO_MAXIOV___5 = 60,
    _SC_IOV_MAX___5 = 60,
    _SC_PII_INTERNET_STREAM___5 = 61,
    _SC_PII_INTERNET_DGRAM___5 = 62,
    _SC_PII_OSI_COTS___5 = 63,
    _SC_PII_OSI_CLTS___5 = 64,
    _SC_PII_OSI_M___5 = 65,
    _SC_T_IOV_MAX___5 = 66,
    _SC_THREADS___5 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___5 = 68,
    _SC_GETGR_R_SIZE_MAX___5 = 69,
    _SC_GETPW_R_SIZE_MAX___5 = 70,
    _SC_LOGIN_NAME_MAX___5 = 71,
    _SC_TTY_NAME_MAX___5 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___5 = 73,
    _SC_THREAD_KEYS_MAX___5 = 74,
    _SC_THREAD_STACK_MIN___5 = 75,
    _SC_THREAD_THREADS_MAX___5 = 76,
    _SC_THREAD_ATTR_STACKADDR___5 = 77,
    _SC_THREAD_ATTR_STACKSIZE___5 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___5 = 79,
    _SC_THREAD_PRIO_INHERIT___5 = 80,
    _SC_THREAD_PRIO_PROTECT___5 = 81,
    _SC_THREAD_PROCESS_SHARED___5 = 82,
    _SC_NPROCESSORS_CONF___5 = 83,
    _SC_NPROCESSORS_ONLN___5 = 84,
    _SC_PHYS_PAGES___5 = 85,
    _SC_AVPHYS_PAGES___5 = 86,
    _SC_ATEXIT_MAX___5 = 87,
    _SC_PASS_MAX___5 = 88,
    _SC_XOPEN_VERSION___5 = 89,
    _SC_XOPEN_XCU_VERSION___5 = 90,
    _SC_XOPEN_UNIX___5 = 91,
    _SC_XOPEN_CRYPT___5 = 92,
    _SC_XOPEN_ENH_I18N___5 = 93,
    _SC_XOPEN_SHM___5 = 94,
    _SC_2_CHAR_TERM___5 = 95,
    _SC_2_C_VERSION___5 = 96,
    _SC_2_UPE___5 = 97,
    _SC_XOPEN_XPG2___5 = 98,
    _SC_XOPEN_XPG3___5 = 99,
    _SC_XOPEN_XPG4___5 = 100,
    _SC_CHAR_BIT___5 = 101,
    _SC_CHAR_MAX___5 = 102,
    _SC_CHAR_MIN___5 = 103,
    _SC_INT_MAX___5 = 104,
    _SC_INT_MIN___5 = 105,
    _SC_LONG_BIT___5 = 106,
    _SC_WORD_BIT___5 = 107,
    _SC_MB_LEN_MAX___5 = 108,
    _SC_NZERO___5 = 109,
    _SC_SSIZE_MAX___5 = 110,
    _SC_SCHAR_MAX___5 = 111,
    _SC_SCHAR_MIN___5 = 112,
    _SC_SHRT_MAX___5 = 113,
    _SC_SHRT_MIN___5 = 114,
    _SC_UCHAR_MAX___5 = 115,
    _SC_UINT_MAX___5 = 116,
    _SC_ULONG_MAX___5 = 117,
    _SC_USHRT_MAX___5 = 118,
    _SC_NL_ARGMAX___5 = 119,
    _SC_NL_LANGMAX___5 = 120,
    _SC_NL_MSGMAX___5 = 121,
    _SC_NL_NMAX___5 = 122,
    _SC_NL_SETMAX___5 = 123,
    _SC_NL_TEXTMAX___5 = 124,
    _SC_XBS5_ILP32_OFF32___5 = 125,
    _SC_XBS5_ILP32_OFFBIG___5 = 126,
    _SC_XBS5_LP64_OFF64___5 = 127,
    _SC_XBS5_LPBIG_OFFBIG___5 = 128,
    _SC_XOPEN_LEGACY___5 = 129,
    _SC_XOPEN_REALTIME___5 = 130,
    _SC_XOPEN_REALTIME_THREADS___5 = 131,
    _SC_ADVISORY_INFO___5 = 132,
    _SC_BARRIERS___5 = 133,
    _SC_BASE___5 = 134,
    _SC_C_LANG_SUPPORT___5 = 135,
    _SC_C_LANG_SUPPORT_R___5 = 136,
    _SC_CLOCK_SELECTION___5 = 137,
    _SC_CPUTIME___5 = 138,
    _SC_THREAD_CPUTIME___5 = 139,
    _SC_DEVICE_IO___5 = 140,
    _SC_DEVICE_SPECIFIC___5 = 141,
    _SC_DEVICE_SPECIFIC_R___5 = 142,
    _SC_FD_MGMT___5 = 143,
    _SC_FIFO___5 = 144,
    _SC_PIPE___5 = 145,
    _SC_FILE_ATTRIBUTES___5 = 146,
    _SC_FILE_LOCKING___5 = 147,
    _SC_FILE_SYSTEM___5 = 148,
    _SC_MONOTONIC_CLOCK___5 = 149,
    _SC_MULTI_PROCESS___5 = 150,
    _SC_SINGLE_PROCESS___5 = 151,
    _SC_NETWORKING___5 = 152,
    _SC_READER_WRITER_LOCKS___5 = 153,
    _SC_SPIN_LOCKS___5 = 154,
    _SC_REGEXP___5 = 155,
    _SC_REGEX_VERSION___5 = 156,
    _SC_SHELL___5 = 157,
    _SC_SIGNALS___5 = 158,
    _SC_SPAWN___5 = 159,
    _SC_SPORADIC_SERVER___5 = 160,
    _SC_THREAD_SPORADIC_SERVER___5 = 161,
    _SC_SYSTEM_DATABASE___5 = 162,
    _SC_SYSTEM_DATABASE_R___5 = 163,
    _SC_TIMEOUTS___5 = 164,
    _SC_TYPED_MEMORY_OBJECTS___5 = 165,
    _SC_USER_GROUPS___5 = 166,
    _SC_USER_GROUPS_R___5 = 167,
    _SC_2_PBS___5 = 168,
    _SC_2_PBS_ACCOUNTING___5 = 169,
    _SC_2_PBS_LOCATE___5 = 170,
    _SC_2_PBS_MESSAGE___5 = 171,
    _SC_2_PBS_TRACK___5 = 172,
    _SC_SYMLOOP_MAX___5 = 173,
    _SC_STREAMS___5 = 174,
    _SC_2_PBS_CHECKPOINT___5 = 175,
    _SC_V6_ILP32_OFF32___5 = 176,
    _SC_V6_ILP32_OFFBIG___5 = 177,
    _SC_V6_LP64_OFF64___5 = 178,
    _SC_V6_LPBIG_OFFBIG___5 = 179,
    _SC_HOST_NAME_MAX___5 = 180,
    _SC_TRACE___5 = 181,
    _SC_TRACE_EVENT_FILTER___5 = 182,
    _SC_TRACE_INHERIT___5 = 183,
    _SC_TRACE_LOG___5 = 184,
    _SC_LEVEL1_ICACHE_SIZE___5 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___5 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___5 = 187,
    _SC_LEVEL1_DCACHE_SIZE___5 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___5 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___5 = 190,
    _SC_LEVEL2_CACHE_SIZE___5 = 191,
    _SC_LEVEL2_CACHE_ASSOC___5 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___5 = 193,
    _SC_LEVEL3_CACHE_SIZE___5 = 194,
    _SC_LEVEL3_CACHE_ASSOC___5 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___5 = 196,
    _SC_LEVEL4_CACHE_SIZE___5 = 197,
    _SC_LEVEL4_CACHE_ASSOC___5 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___5 = 199,
    _SC_IPV6___5 = 235,
    _SC_RAW_SOCKETS___5 = 236,
    _SC_V7_ILP32_OFF32___5 = 237,
    _SC_V7_ILP32_OFFBIG___5 = 238,
    _SC_V7_LP64_OFF64___5 = 239,
    _SC_V7_LPBIG_OFFBIG___5 = 240,
    _SC_SS_REPL_MAX___5 = 241,
    _SC_TRACE_EVENT_NAME_MAX___5 = 242,
    _SC_TRACE_NAME_MAX___5 = 243,
    _SC_TRACE_SYS_MAX___5 = 244,
    _SC_TRACE_USER_EVENT_MAX___5 = 245,
    _SC_XOPEN_STREAMS___5 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___5 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___5 = 248,
    _SC_MINSIGSTKSZ___5 = 249,
    _SC_SIGSTKSZ___5 = 250
} ;
#line 539
enum __anonenum__519 {
    _CS_PATH___5 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___5 = 1,
    _CS_GNU_LIBC_VERSION___5 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___5 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___5 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___5 = 5,
    _CS_LFS_CFLAGS___5 = 1000,
    _CS_LFS_LDFLAGS___5 = 1001,
    _CS_LFS_LIBS___5 = 1002,
    _CS_LFS_LINTFLAGS___5 = 1003,
    _CS_LFS64_CFLAGS___5 = 1004,
    _CS_LFS64_LDFLAGS___5 = 1005,
    _CS_LFS64_LIBS___5 = 1006,
    _CS_LFS64_LINTFLAGS___5 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___5 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___5 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___5 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___5 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___5 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___5 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___5 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___5 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___5 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___5 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___5 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___5 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___5 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___5 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___5 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___5 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___5 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___5 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___5 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___5 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___5 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___5 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___5 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___5 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___5 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___5 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___5 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___5 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___5 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___5 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___5 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___5 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___5 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___5 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___5 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___5 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___5 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___5 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___5 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___5 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___5 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___5 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___5 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___5 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___5 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___5 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___5 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___5 = 1147,
    _CS_V6_ENV___5 = 1148,
    _CS_V7_ENV___5 = 1149
} ;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_526 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_526 imaxdiv_t;
#line 257 "/usr/include/openssl/e_os2.h"
typedef intmax_t ossl_intmax_t;
#line 258 "/usr/include/openssl/e_os2.h"
typedef uintmax_t ossl_uintmax_t;
#line 23 "/usr/include/openssl/stack.h"
struct stack_st ;
#line 23 "/usr/include/openssl/stack.h"
typedef struct stack_st OPENSSL_STACK;
#line 25 "/usr/include/openssl/stack.h"
typedef int (*OPENSSL_sk_compfunc)(void const   * , void const   * );
#line 26 "/usr/include/openssl/stack.h"
typedef void (*OPENSSL_sk_freefunc)(void * );
#line 27 "/usr/include/openssl/stack.h"
typedef void *(*OPENSSL_sk_copyfunc)(void const   * );
#line 195 "/usr/include/openssl/safestack.h"
typedef char *OPENSSL_STRING;
#line 196 "/usr/include/openssl/safestack.h"
typedef char const   *OPENSSL_CSTRING;
#line 205
struct stack_st_OPENSSL_STRING ;
#line 205 "/usr/include/openssl/safestack.h"
typedef int (*sk_OPENSSL_STRING_compfunc)(char const   * const  * , char const   * const  * );
#line 205 "/usr/include/openssl/safestack.h"
typedef void (*sk_OPENSSL_STRING_freefunc)(char * );
#line 205 "/usr/include/openssl/safestack.h"
typedef char *(*sk_OPENSSL_STRING_copyfunc)(char const   * );
#line 231
struct stack_st_OPENSSL_CSTRING ;
#line 231 "/usr/include/openssl/safestack.h"
typedef int (*sk_OPENSSL_CSTRING_compfunc)(char const   * const  * , char const   * const  * );
#line 231 "/usr/include/openssl/safestack.h"
typedef void (*sk_OPENSSL_CSTRING_freefunc)(char * );
#line 231 "/usr/include/openssl/safestack.h"
typedef char *(*sk_OPENSSL_CSTRING_copyfunc)(char const   * );
#line 264 "/usr/include/openssl/safestack.h"
typedef void *OPENSSL_BLOCK;
#line 265
struct stack_st_OPENSSL_BLOCK ;
#line 265 "/usr/include/openssl/safestack.h"
typedef int (*sk_OPENSSL_BLOCK_compfunc)(void const   * const  * , void const   * const  * );
#line 265 "/usr/include/openssl/safestack.h"
typedef void (*sk_OPENSSL_BLOCK_freefunc)(void * );
#line 265 "/usr/include/openssl/safestack.h"
typedef void *(*sk_OPENSSL_BLOCK_copyfunc)(void const   * );
#line 24 "/usr/include/openssl/types.h"
struct ossl_provider_st ;
#line 24 "/usr/include/openssl/types.h"
typedef struct ossl_provider_st OSSL_PROVIDER;
#line 45
struct asn1_string_st ;
#line 45 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 46 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 47 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 48 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 49 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 50 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 51 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 52 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 53 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 54 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 55 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 56 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_TIME;
#line 57 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 58 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 59 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 60 "/usr/include/openssl/types.h"
typedef struct asn1_string_st ASN1_STRING;
#line 61 "/usr/include/openssl/types.h"
typedef int ASN1_BOOLEAN;
#line 62 "/usr/include/openssl/types.h"
typedef int ASN1_NULL;
#line 65
struct asn1_type_st ;
#line 65 "/usr/include/openssl/types.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 66
struct asn1_object_st ;
#line 66 "/usr/include/openssl/types.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 67
struct asn1_string_table_st ;
#line 67 "/usr/include/openssl/types.h"
typedef struct asn1_string_table_st ASN1_STRING_TABLE;
#line 69
struct ASN1_ITEM_st ;
#line 69 "/usr/include/openssl/types.h"
typedef struct ASN1_ITEM_st ASN1_ITEM;
#line 70
struct asn1_pctx_st ;
#line 70 "/usr/include/openssl/types.h"
typedef struct asn1_pctx_st ASN1_PCTX;
#line 71
struct asn1_sctx_st ;
#line 71 "/usr/include/openssl/types.h"
typedef struct asn1_sctx_st ASN1_SCTX;
#line 86
struct bio_st ;
#line 86 "/usr/include/openssl/types.h"
typedef struct bio_st BIO;
#line 87
struct bignum_st ;
#line 87 "/usr/include/openssl/types.h"
typedef struct bignum_st BIGNUM;
#line 88
struct bignum_ctx ;
#line 88 "/usr/include/openssl/types.h"
typedef struct bignum_ctx BN_CTX;
#line 89
struct bn_blinding_st ;
#line 89 "/usr/include/openssl/types.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 90
struct bn_mont_ctx_st ;
#line 90 "/usr/include/openssl/types.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 91
struct bn_recp_ctx_st ;
#line 91 "/usr/include/openssl/types.h"
typedef struct bn_recp_ctx_st BN_RECP_CTX;
#line 92
struct bn_gencb_st ;
#line 92 "/usr/include/openssl/types.h"
typedef struct bn_gencb_st BN_GENCB;
#line 94
struct buf_mem_st ;
#line 94 "/usr/include/openssl/types.h"
typedef struct buf_mem_st BUF_MEM;
#line 96
struct stack_st_BIGNUM ;
#line 97
struct stack_st_BIGNUM_const ;
#line 99
struct err_state_st ;
#line 99 "/usr/include/openssl/types.h"
typedef struct err_state_st ERR_STATE;
#line 101
struct evp_cipher_st ;
#line 101 "/usr/include/openssl/types.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 102
struct evp_cipher_ctx_st ;
#line 102 "/usr/include/openssl/types.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 103
struct evp_md_st ;
#line 103 "/usr/include/openssl/types.h"
typedef struct evp_md_st EVP_MD;
#line 104
struct evp_md_ctx_st ;
#line 104 "/usr/include/openssl/types.h"
typedef struct evp_md_ctx_st EVP_MD_CTX;
#line 105
struct evp_mac_st ;
#line 105 "/usr/include/openssl/types.h"
typedef struct evp_mac_st EVP_MAC;
#line 106
struct evp_mac_ctx_st ;
#line 106 "/usr/include/openssl/types.h"
typedef struct evp_mac_ctx_st EVP_MAC_CTX;
#line 107
struct evp_pkey_st ;
#line 107 "/usr/include/openssl/types.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 109
struct evp_pkey_asn1_method_st ;
#line 109 "/usr/include/openssl/types.h"
typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
#line 111
struct evp_pkey_method_st ;
#line 111 "/usr/include/openssl/types.h"
typedef struct evp_pkey_method_st EVP_PKEY_METHOD;
#line 112
struct evp_pkey_ctx_st ;
#line 112 "/usr/include/openssl/types.h"
typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
#line 114
struct evp_keymgmt_st ;
#line 114 "/usr/include/openssl/types.h"
typedef struct evp_keymgmt_st EVP_KEYMGMT;
#line 116
struct evp_kdf_st ;
#line 116 "/usr/include/openssl/types.h"
typedef struct evp_kdf_st EVP_KDF;
#line 117
struct evp_kdf_ctx_st ;
#line 117 "/usr/include/openssl/types.h"
typedef struct evp_kdf_ctx_st EVP_KDF_CTX;
#line 119
struct evp_rand_st ;
#line 119 "/usr/include/openssl/types.h"
typedef struct evp_rand_st EVP_RAND;
#line 120
struct evp_rand_ctx_st ;
#line 120 "/usr/include/openssl/types.h"
typedef struct evp_rand_ctx_st EVP_RAND_CTX;
#line 122
struct evp_keyexch_st ;
#line 122 "/usr/include/openssl/types.h"
typedef struct evp_keyexch_st EVP_KEYEXCH;
#line 124
struct evp_signature_st ;
#line 124 "/usr/include/openssl/types.h"
typedef struct evp_signature_st EVP_SIGNATURE;
#line 126
struct evp_asym_cipher_st ;
#line 126 "/usr/include/openssl/types.h"
typedef struct evp_asym_cipher_st EVP_ASYM_CIPHER;
#line 128
struct evp_kem_st ;
#line 128 "/usr/include/openssl/types.h"
typedef struct evp_kem_st EVP_KEM;
#line 130
struct evp_Encode_Ctx_st ;
#line 130 "/usr/include/openssl/types.h"
typedef struct evp_Encode_Ctx_st EVP_ENCODE_CTX;
#line 132
struct hmac_ctx_st ;
#line 132 "/usr/include/openssl/types.h"
typedef struct hmac_ctx_st HMAC_CTX;
#line 134
struct dh_st ;
#line 134 "/usr/include/openssl/types.h"
typedef struct dh_st DH;
#line 135
struct dh_method ;
#line 135 "/usr/include/openssl/types.h"
typedef struct dh_method DH_METHOD;
#line 138
struct dsa_st ;
#line 138 "/usr/include/openssl/types.h"
typedef struct dsa_st DSA;
#line 139
struct dsa_method ;
#line 139 "/usr/include/openssl/types.h"
typedef struct dsa_method DSA_METHOD;
#line 143
struct rsa_st ;
#line 143 "/usr/include/openssl/types.h"
typedef struct rsa_st RSA;
#line 144
struct rsa_meth_st ;
#line 144 "/usr/include/openssl/types.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 146
struct rsa_pss_params_st ;
#line 146 "/usr/include/openssl/types.h"
typedef struct rsa_pss_params_st RSA_PSS_PARAMS;
#line 149
struct ec_key_st ;
#line 149 "/usr/include/openssl/types.h"
typedef struct ec_key_st EC_KEY;
#line 150
struct ec_key_method_st ;
#line 150 "/usr/include/openssl/types.h"
typedef struct ec_key_method_st EC_KEY_METHOD;
#line 153
struct rand_meth_st ;
#line 153 "/usr/include/openssl/types.h"
typedef struct rand_meth_st RAND_METHOD;
#line 154
struct rand_drbg_st ;
#line 154 "/usr/include/openssl/types.h"
typedef struct rand_drbg_st RAND_DRBG;
#line 156
struct ssl_dane_st ;
#line 156 "/usr/include/openssl/types.h"
typedef struct ssl_dane_st SSL_DANE;
#line 157
struct x509_st ;
#line 157 "/usr/include/openssl/types.h"
typedef struct x509_st X509;
#line 158
struct X509_algor_st ;
#line 158 "/usr/include/openssl/types.h"
typedef struct X509_algor_st X509_ALGOR;
#line 159
struct X509_crl_st ;
#line 159 "/usr/include/openssl/types.h"
typedef struct X509_crl_st X509_CRL;
#line 160
struct x509_crl_method_st ;
#line 160 "/usr/include/openssl/types.h"
typedef struct x509_crl_method_st X509_CRL_METHOD;
#line 161
struct x509_revoked_st ;
#line 161 "/usr/include/openssl/types.h"
typedef struct x509_revoked_st X509_REVOKED;
#line 162
struct X509_name_st ;
#line 162 "/usr/include/openssl/types.h"
typedef struct X509_name_st X509_NAME;
#line 163
struct X509_pubkey_st ;
#line 163 "/usr/include/openssl/types.h"
typedef struct X509_pubkey_st X509_PUBKEY;
#line 164
struct x509_store_st ;
#line 164 "/usr/include/openssl/types.h"
typedef struct x509_store_st X509_STORE;
#line 165
struct x509_store_ctx_st ;
#line 165 "/usr/include/openssl/types.h"
typedef struct x509_store_ctx_st X509_STORE_CTX;
#line 167
struct x509_object_st ;
#line 167 "/usr/include/openssl/types.h"
typedef struct x509_object_st X509_OBJECT;
#line 168
struct x509_lookup_st ;
#line 168 "/usr/include/openssl/types.h"
typedef struct x509_lookup_st X509_LOOKUP;
#line 169
struct x509_lookup_method_st ;
#line 169 "/usr/include/openssl/types.h"
typedef struct x509_lookup_method_st X509_LOOKUP_METHOD;
#line 170
struct X509_VERIFY_PARAM_st ;
#line 170 "/usr/include/openssl/types.h"
typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
#line 172
struct x509_sig_info_st ;
#line 172 "/usr/include/openssl/types.h"
typedef struct x509_sig_info_st X509_SIG_INFO;
#line 174
struct pkcs8_priv_key_info_st ;
#line 174 "/usr/include/openssl/types.h"
typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;
#line 176
struct v3_ext_ctx ;
#line 176 "/usr/include/openssl/types.h"
typedef struct v3_ext_ctx X509V3_CTX;
#line 177
struct conf_st ;
#line 177 "/usr/include/openssl/types.h"
typedef struct conf_st CONF;
#line 178
struct ossl_init_settings_st ;
#line 178 "/usr/include/openssl/types.h"
typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;
#line 180
struct ui_st ;
#line 180 "/usr/include/openssl/types.h"
typedef struct ui_st UI;
#line 181
struct ui_method_st ;
#line 181 "/usr/include/openssl/types.h"
typedef struct ui_method_st UI_METHOD;
#line 183
struct engine_st ;
#line 183 "/usr/include/openssl/types.h"
typedef struct engine_st ENGINE;
#line 184
struct ssl_st ;
#line 184 "/usr/include/openssl/types.h"
typedef struct ssl_st SSL;
#line 185
struct ssl_ctx_st ;
#line 185 "/usr/include/openssl/types.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 187
struct comp_ctx_st ;
#line 187 "/usr/include/openssl/types.h"
typedef struct comp_ctx_st COMP_CTX;
#line 188
struct comp_method_st ;
#line 188 "/usr/include/openssl/types.h"
typedef struct comp_method_st COMP_METHOD;
#line 190
struct X509_POLICY_NODE_st ;
#line 190 "/usr/include/openssl/types.h"
typedef struct X509_POLICY_NODE_st X509_POLICY_NODE;
#line 191
struct X509_POLICY_LEVEL_st ;
#line 191 "/usr/include/openssl/types.h"
typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL;
#line 192
struct X509_POLICY_TREE_st ;
#line 192 "/usr/include/openssl/types.h"
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
#line 193
struct X509_POLICY_CACHE_st ;
#line 193 "/usr/include/openssl/types.h"
typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;
#line 195
struct AUTHORITY_KEYID_st ;
#line 195 "/usr/include/openssl/types.h"
typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;
#line 196
struct DIST_POINT_st ;
#line 196 "/usr/include/openssl/types.h"
typedef struct DIST_POINT_st DIST_POINT;
#line 197
struct ISSUING_DIST_POINT_st ;
#line 197 "/usr/include/openssl/types.h"
typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;
#line 198
struct NAME_CONSTRAINTS_st ;
#line 198 "/usr/include/openssl/types.h"
typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;
#line 200
struct crypto_ex_data_st ;
#line 200 "/usr/include/openssl/types.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 202
struct ossl_http_req_ctx_st ;
#line 202 "/usr/include/openssl/types.h"
typedef struct ossl_http_req_ctx_st OSSL_HTTP_REQ_CTX;
#line 203
struct ocsp_response_st ;
#line 203 "/usr/include/openssl/types.h"
typedef struct ocsp_response_st OCSP_RESPONSE;
#line 204
struct ocsp_responder_id_st ;
#line 204 "/usr/include/openssl/types.h"
typedef struct ocsp_responder_id_st OCSP_RESPID;
#line 206
struct sct_st ;
#line 206 "/usr/include/openssl/types.h"
typedef struct sct_st SCT;
#line 207
struct sct_ctx_st ;
#line 207 "/usr/include/openssl/types.h"
typedef struct sct_ctx_st SCT_CTX;
#line 208
struct ctlog_st ;
#line 208 "/usr/include/openssl/types.h"
typedef struct ctlog_st CTLOG;
#line 209
struct ctlog_store_st ;
#line 209 "/usr/include/openssl/types.h"
typedef struct ctlog_store_st CTLOG_STORE;
#line 210
struct ct_policy_eval_ctx_st ;
#line 210 "/usr/include/openssl/types.h"
typedef struct ct_policy_eval_ctx_st CT_POLICY_EVAL_CTX;
#line 212
struct ossl_store_info_st ;
#line 212 "/usr/include/openssl/types.h"
typedef struct ossl_store_info_st OSSL_STORE_INFO;
#line 213
struct ossl_store_search_st ;
#line 213 "/usr/include/openssl/types.h"
typedef struct ossl_store_search_st OSSL_STORE_SEARCH;
#line 215
struct ossl_lib_ctx_st ;
#line 215 "/usr/include/openssl/types.h"
typedef struct ossl_lib_ctx_st OSSL_LIB_CTX;
#line 217
struct ossl_dispatch_st ;
#line 217 "/usr/include/openssl/types.h"
typedef struct ossl_dispatch_st OSSL_DISPATCH;
#line 218
struct ossl_item_st ;
#line 218 "/usr/include/openssl/types.h"
typedef struct ossl_item_st OSSL_ITEM;
#line 219
struct ossl_algorithm_st ;
#line 219 "/usr/include/openssl/types.h"
typedef struct ossl_algorithm_st OSSL_ALGORITHM;
#line 220
struct ossl_param_st ;
#line 220 "/usr/include/openssl/types.h"
typedef struct ossl_param_st OSSL_PARAM;
#line 221
struct ossl_param_bld_st ;
#line 221 "/usr/include/openssl/types.h"
typedef struct ossl_param_bld_st OSSL_PARAM_BLD;
#line 223 "/usr/include/openssl/types.h"
typedef int pem_password_cb(char * , int  , int  , void * );
#line 225
struct ossl_encoder_st ;
#line 225 "/usr/include/openssl/types.h"
typedef struct ossl_encoder_st OSSL_ENCODER;
#line 226
struct ossl_encoder_ctx_st ;
#line 226 "/usr/include/openssl/types.h"
typedef struct ossl_encoder_ctx_st OSSL_ENCODER_CTX;
#line 227
struct ossl_decoder_st ;
#line 227 "/usr/include/openssl/types.h"
typedef struct ossl_decoder_st OSSL_DECODER;
#line 228
struct ossl_decoder_ctx_st ;
#line 228 "/usr/include/openssl/types.h"
typedef struct ossl_decoder_ctx_st OSSL_DECODER_CTX;
#line 230
struct ossl_self_test_st ;
#line 230 "/usr/include/openssl/types.h"
typedef struct ossl_self_test_st OSSL_SELF_TEST;
#line 30 "/usr/include/openssl/core.h"
struct ossl_core_handle_st ;
#line 30 "/usr/include/openssl/core.h"
typedef struct ossl_core_handle_st OSSL_CORE_HANDLE;
#line 31
struct openssl_core_ctx_st ;
#line 31 "/usr/include/openssl/core.h"
typedef struct openssl_core_ctx_st OPENSSL_CORE_CTX;
#line 32
struct ossl_core_bio_st ;
#line 32 "/usr/include/openssl/core.h"
typedef struct ossl_core_bio_st OSSL_CORE_BIO;
#line 40 "/usr/include/openssl/core.h"
struct ossl_dispatch_st {
   int function_id ;
   void (*function)(void) ;
};
#line 58 "/usr/include/openssl/core.h"
struct ossl_item_st {
   unsigned int id ;
   void *ptr ;
};
#line 69 "/usr/include/openssl/core.h"
struct ossl_algorithm_st {
   char const   *algorithm_names ;
   char const   *property_definition ;
   OSSL_DISPATCH *implementation ;
   char const   *algorithm_description ;
};
#line 82 "/usr/include/openssl/core.h"
struct ossl_param_st {
   char const   *key ;
   unsigned int data_type ;
   void *data ;
   size_t data_size ;
   size_t return_size ;
};
#line 169 "/usr/include/openssl/core.h"
typedef void (*OSSL_thread_stop_handler_fn)(void * );
#line 190 "/usr/include/openssl/core.h"
typedef int OSSL_provider_init_fn(OSSL_CORE_HANDLE * , OSSL_DISPATCH * , OSSL_DISPATCH ** ,
                                  void ** );
#line 216 "/usr/include/openssl/core.h"
typedef int OSSL_CALLBACK(OSSL_PARAM [] , void * );
#line 217 "/usr/include/openssl/core.h"
typedef int OSSL_INOUT_CALLBACK(OSSL_PARAM [] , OSSL_PARAM [] , void * );
#line 225 "/usr/include/openssl/core.h"
typedef int OSSL_PASSPHRASE_CALLBACK(char * , size_t  , size_t * , OSSL_PARAM [] ,
                                     void * );
#line 73 "/usr/include/openssl/crypto.h"
struct __anonstruct_527 {
   int dummy ;
};
#line 75 "/usr/include/openssl/crypto.h"
typedef struct __anonstruct_527 CRYPTO_dynlock;
#line 79 "/usr/include/openssl/crypto.h"
typedef void CRYPTO_RWLOCK;
#line 182
struct stack_st_void ;
#line 180 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   OSSL_LIB_CTX *ctx ;
   struct stack_st_void *sk ;
};
#line 185 "/usr/include/openssl/crypto.h"
typedef int (*sk_void_compfunc)(void const   * const  * , void const   * const  * );
#line 185 "/usr/include/openssl/crypto.h"
typedef void (*sk_void_freefunc)(void * );
#line 185 "/usr/include/openssl/crypto.h"
typedef void *(*sk_void_copyfunc)(void const   * );
#line 238 "/usr/include/openssl/crypto.h"
typedef void CRYPTO_EX_new(void * , void * , CRYPTO_EX_DATA * , int  , long  , void * );
#line 240 "/usr/include/openssl/crypto.h"
typedef void CRYPTO_EX_free(void * , void * , CRYPTO_EX_DATA * , int  , long  , void * );
#line 242 "/usr/include/openssl/crypto.h"
typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA * , CRYPTO_EX_DATA * , void ** , int  , long  ,
                          void * );
#line 306 "/usr/include/openssl/crypto.h"
struct crypto_threadid_st {
   int dummy ;
};
#line 308 "/usr/include/openssl/crypto.h"
typedef struct crypto_threadid_st CRYPTO_THREADID;
#line 333 "/usr/include/openssl/crypto.h"
typedef void *(*CRYPTO_malloc_fn)(size_t  , char const   * , int  );
#line 334 "/usr/include/openssl/crypto.h"
typedef void *(*CRYPTO_realloc_fn)(void * , size_t  , char const   * , int  );
#line 336 "/usr/include/openssl/crypto.h"
typedef void (*CRYPTO_free_fn)(void * , char const   * , int  );
#line 520 "/usr/include/openssl/crypto.h"
typedef pthread_once_t CRYPTO_ONCE;
#line 521 "/usr/include/openssl/crypto.h"
typedef pthread_key_t CRYPTO_THREAD_LOCAL;
#line 522 "/usr/include/openssl/crypto.h"
typedef pthread_t CRYPTO_THREAD_ID;
#line 213 "/usr/include/openssl/bio.h"
union bio_addr_st ;
#line 213 "/usr/include/openssl/bio.h"
typedef union bio_addr_st BIO_ADDR;
#line 214
struct bio_addrinfo_st ;
#line 214 "/usr/include/openssl/bio.h"
typedef struct bio_addrinfo_st BIO_ADDRINFO;
#line 276 "/usr/include/openssl/bio.h"
typedef long (*BIO_callback_fn)(BIO * , int  , char const   * , int  , long  , long  );
#line 285 "/usr/include/openssl/bio.h"
typedef long (*BIO_callback_fn_ex)(BIO * , int  , char const   * , size_t  , int  ,
                                   long  , int  , size_t * );
#line 296
struct bio_method_st ;
#line 296 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 301 "/usr/include/openssl/bio.h"
typedef int BIO_info_cb(BIO * , int  , int  );
#line 302 "/usr/include/openssl/bio.h"
typedef BIO_info_cb bio_info_cb;
#line 304
struct stack_st_BIO ;
#line 304 "/usr/include/openssl/bio.h"
typedef int (*sk_BIO_compfunc)(BIO * const  * , BIO * const  * );
#line 304 "/usr/include/openssl/bio.h"
typedef void (*sk_BIO_freefunc)(BIO * );
#line 304 "/usr/include/openssl/bio.h"
typedef BIO *(*sk_BIO_copyfunc)(BIO * );
#line 334 "/usr/include/openssl/bio.h"
typedef int asn1_ps_func(BIO * , unsigned char ** , int * , void * );
#line 337 "/usr/include/openssl/bio.h"
typedef void (*BIO_dgram_sctp_notification_handler_fn)(BIO * , void * , void * );
#line 747
enum BIO_hostserv_priorities {
    BIO_PARSE_PRIO_HOST = 0,
    BIO_PARSE_PRIO_SERV = 1
} ;
#line 752
enum BIO_lookup_type {
    BIO_LOOKUP_CLIENT = 0,
    BIO_LOOKUP_SERVER = 1
} ;
#line 770
struct hostent ;
#line 777 "/usr/include/openssl/bio.h"
union BIO_sock_info_u {
   BIO_ADDR *addr ;
};
#line 780
enum BIO_sock_info_type {
    BIO_SOCK_INFO_ADDRESS = 0
} ;
#line 42 "/usr/include/openssl/buffer.h"
struct buf_mem_st {
   size_t length ;
   char *data ;
   size_t max ;
   unsigned long flags ;
};
#line 64 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_core_gettable_params_fn(OSSL_CORE_HANDLE * );
#line 67 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_get_params_fn(OSSL_CORE_HANDLE * , OSSL_PARAM [] );
#line 70 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_thread_start_fn(OSSL_CORE_HANDLE * , OSSL_thread_stop_handler_fn  ,
                                           void * );
#line 74 "/usr/include/openssl/core_dispatch.h"
typedef OPENSSL_CORE_CTX *OSSL_FUNC_core_get_libctx_fn(OSSL_CORE_HANDLE * );
#line 77 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_core_new_error_fn(OSSL_CORE_HANDLE * );
#line 79 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_core_set_error_debug_fn(OSSL_CORE_HANDLE * , char const   * ,
                                               int  , char const   * );
#line 83 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_core_vset_error_fn(OSSL_CORE_HANDLE * , uint32_t  , char const   * ,
                                          va_list  );
#line 87 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_set_error_mark_fn(OSSL_CORE_HANDLE * );
#line 89 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_clear_last_error_mark_fn(OSSL_CORE_HANDLE * );
#line 92 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_pop_error_to_mark_fn(OSSL_CORE_HANDLE * );
#line 100 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_obj_add_sigid_fn(OSSL_CORE_HANDLE * , char const   * ,
                                            char const   * , char const   * );
#line 103 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_core_obj_create_fn(OSSL_CORE_HANDLE * , char const   * , char const   * ,
                                         char const   * );
#line 109 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_malloc_fn(size_t  , char const   * , int  );
#line 112 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_zalloc_fn(size_t  , char const   * , int  );
#line 115 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_CRYPTO_free_fn(void * , char const   * , int  );
#line 118 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_CRYPTO_clear_free_fn(void * , size_t  , char const   * , int  );
#line 121 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_realloc_fn(void * , size_t  , char const   * , int  );
#line 124 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_clear_realloc_fn(void * , size_t  , size_t  , char const   * ,
                                                int  );
#line 128 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_secure_malloc_fn(size_t  , char const   * , int  );
#line 131 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_CRYPTO_secure_zalloc_fn(size_t  , char const   * , int  );
#line 134 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_CRYPTO_secure_free_fn(void * , char const   * , int  );
#line 137 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_CRYPTO_secure_clear_free_fn(void * , size_t  , char const   * ,
                                                   int  );
#line 141 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_CRYPTO_secure_allocated_fn(void const   * );
#line 144 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_OPENSSL_cleanse_fn(void * , size_t  );
#line 161 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_CORE_BIO *OSSL_FUNC_BIO_new_file_fn(char const   * , char const   * );
#line 163 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_CORE_BIO *OSSL_FUNC_BIO_new_membuf_fn(void const   * , int  );
#line 164 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_read_ex_fn(OSSL_CORE_BIO * , void * , size_t  , size_t * );
#line 166 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_write_ex_fn(OSSL_CORE_BIO * , void const   * , size_t  ,
                                      size_t * );
#line 168 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_gets_fn(OSSL_CORE_BIO * , char * , int  );
#line 169 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_puts_fn(OSSL_CORE_BIO * , char const   * );
#line 170 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_up_ref_fn(OSSL_CORE_BIO * );
#line 171 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_free_fn(OSSL_CORE_BIO * );
#line 172 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_vprintf_fn(OSSL_CORE_BIO * , char const   * , va_list  );
#line 174 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_vsnprintf_fn(char * , size_t  , char const   * , va_list  );
#line 176 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_BIO_ctrl_fn(OSSL_CORE_BIO * , int  , long  , void * );
#line 180 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_self_test_cb_fn(OPENSSL_CORE_CTX * , OSSL_CALLBACK ** , void ** );
#line 188 "/usr/include/openssl/core_dispatch.h"
typedef size_t OSSL_FUNC_get_entropy_fn(OSSL_CORE_HANDLE * , unsigned char ** , int  ,
                                        size_t  , size_t  );
#line 191 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_cleanup_entropy_fn(OSSL_CORE_HANDLE * , unsigned char * , size_t  );
#line 193 "/usr/include/openssl/core_dispatch.h"
typedef size_t OSSL_FUNC_get_nonce_fn(OSSL_CORE_HANDLE * , unsigned char ** , size_t  ,
                                      size_t  , void const   * , size_t  );
#line 197 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_cleanup_nonce_fn(OSSL_CORE_HANDLE * , unsigned char * , size_t  );
#line 209 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_register_child_cb_fn(OSSL_CORE_HANDLE * , int (*)(OSSL_CORE_HANDLE * ,
                                                                                 void * ) ,
                                                    int (*)(OSSL_CORE_HANDLE * , void * ) ,
                                                    int (*)(char const   * , void * ) ,
                                                    void * );
#line 215 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_provider_deregister_child_cb_fn(OSSL_CORE_HANDLE * );
#line 217 "/usr/include/openssl/core_dispatch.h"
typedef char const   *OSSL_FUNC_provider_name_fn(OSSL_CORE_HANDLE * );
#line 219 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_provider_get0_provider_ctx_fn(OSSL_CORE_HANDLE * );
#line 221 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_DISPATCH *OSSL_FUNC_provider_get0_dispatch_fn(OSSL_CORE_HANDLE * );
#line 223 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_up_ref_fn(OSSL_CORE_HANDLE * , int  );
#line 225 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_free_fn(OSSL_CORE_HANDLE * , int  );
#line 230 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_provider_teardown_fn(void * );
#line 232 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_provider_gettable_params_fn(void * );
#line 235 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_get_params_fn(void * , OSSL_PARAM [] );
#line 238 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_ALGORITHM *OSSL_FUNC_provider_query_operation_fn(void * , int  , int * );
#line 241 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_provider_unquery_operation_fn(void * , int  , OSSL_ALGORITHM * );
#line 244 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_ITEM *OSSL_FUNC_provider_get_reason_strings_fn(void * );
#line 247 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_get_capabilities_fn(void * , char const   * , OSSL_CALLBACK * ,
                                                   void * );
#line 250 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_provider_self_test_fn(void * );
#line 287 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_digest_newctx_fn(void * );
#line 288 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_init_fn(void * , OSSL_PARAM [] );
#line 289 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_update_fn(void * , unsigned char const   * , size_t  );
#line 291 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_final_fn(void * , unsigned char * , size_t * , size_t  );
#line 294 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_digest_fn(void * , unsigned char const   * , size_t  ,
                                       unsigned char * , size_t * , size_t  );
#line 298 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_digest_freectx_fn(void * );
#line 299 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_digest_dupctx_fn(void * );
#line 301 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_get_params_fn(OSSL_PARAM [] );
#line 302 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 304 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_digest_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 306 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_digest_gettable_params_fn(void * );
#line 308 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_digest_settable_ctx_params_fn(void * , void * );
#line 310 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_digest_gettable_ctx_params_fn(void * , void * );
#line 330 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_cipher_newctx_fn(void * );
#line 331 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_encrypt_init_fn(void * , unsigned char const   * , size_t  ,
                                             unsigned char const   * , size_t  , OSSL_PARAM [] );
#line 337 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_decrypt_init_fn(void * , unsigned char const   * , size_t  ,
                                             unsigned char const   * , size_t  , OSSL_PARAM [] );
#line 343 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_update_fn(void * , unsigned char * , size_t * , size_t  ,
                                       unsigned char const   * , size_t  );
#line 347 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_final_fn(void * , unsigned char * , size_t * , size_t  );
#line 350 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_cipher_fn(void * , unsigned char * , size_t * , size_t  ,
                                       unsigned char const   * , size_t  );
#line 354 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_cipher_freectx_fn(void * );
#line 355 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_cipher_dupctx_fn(void * );
#line 356 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_get_params_fn(OSSL_PARAM [] );
#line 357 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 359 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_cipher_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 361 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_cipher_gettable_params_fn(void * );
#line 363 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_cipher_settable_ctx_params_fn(void * , void * );
#line 365 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_cipher_gettable_ctx_params_fn(void * , void * );
#line 383 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_mac_newctx_fn(void * );
#line 384 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_mac_dupctx_fn(void * );
#line 385 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_mac_freectx_fn(void * );
#line 386 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_init_fn(void * , unsigned char const   * , size_t  , OSSL_PARAM [] );
#line 388 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_update_fn(void * , unsigned char const   * , size_t  );
#line 390 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_final_fn(void * , unsigned char * , size_t * , size_t  );
#line 393 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_mac_gettable_params_fn(void * );
#line 394 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_mac_gettable_ctx_params_fn(void * , void * );
#line 396 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_mac_settable_ctx_params_fn(void * , void * );
#line 398 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_get_params_fn(OSSL_PARAM [] );
#line 399 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 401 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_mac_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 418 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_kdf_newctx_fn(void * );
#line 419 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_kdf_dupctx_fn(void * );
#line 420 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_kdf_freectx_fn(void * );
#line 421 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_kdf_reset_fn(void * );
#line 422 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kdf_derive_fn(void * , unsigned char * , size_t  , OSSL_PARAM [] );
#line 424 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_kdf_gettable_params_fn(void * );
#line 425 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_kdf_gettable_ctx_params_fn(void * , void * );
#line 427 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_kdf_settable_ctx_params_fn(void * , void * );
#line 429 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kdf_get_params_fn(OSSL_PARAM [] );
#line 430 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kdf_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 432 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kdf_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 457 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_rand_newctx_fn(void * , void * , OSSL_DISPATCH * );
#line 460 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_rand_freectx_fn(void * );
#line 461 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_instantiate_fn(void * , unsigned int  , int  , unsigned char const   * ,
                                          size_t  , OSSL_PARAM [] );
#line 466 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_uninstantiate_fn(void * );
#line 467 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_generate_fn(void * , unsigned char * , size_t  , unsigned int  ,
                                       int  , unsigned char const   * , size_t  );
#line 471 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_reseed_fn(void * , int  , unsigned char const   * , size_t  ,
                                     unsigned char const   * , size_t  );
#line 475 "/usr/include/openssl/core_dispatch.h"
typedef size_t OSSL_FUNC_rand_nonce_fn(void * , unsigned char * , unsigned int  ,
                                       size_t  , size_t  );
#line 478 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_enable_locking_fn(void * );
#line 479 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_lock_fn(void * );
#line 480 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_rand_unlock_fn(void * );
#line 481 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_rand_gettable_params_fn(void * );
#line 482 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_rand_gettable_ctx_params_fn(void * , void * );
#line 484 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_rand_settable_ctx_params_fn(void * , void * );
#line 486 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_get_params_fn(OSSL_PARAM [] );
#line 487 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 489 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 491 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_rand_set_callbacks_fn(void * , OSSL_INOUT_CALLBACK * , OSSL_CALLBACK * ,
                                             OSSL_INOUT_CALLBACK * , OSSL_CALLBACK * ,
                                             void * );
#line 496 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_rand_verify_zeroization_fn(void * );
#line 498 "/usr/include/openssl/core_dispatch.h"
typedef size_t OSSL_FUNC_rand_get_seed_fn(void * , unsigned char ** , int  , size_t  ,
                                          size_t  , int  , unsigned char const   * ,
                                          size_t  );
#line 503 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_rand_clear_seed_fn(void * , unsigned char * , size_t  );
#line 561 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keymgmt_new_fn(void * );
#line 570 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keymgmt_gen_init_fn(void * , int  , OSSL_PARAM [] );
#line 572 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_gen_set_template_fn(void * , void * );
#line 574 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_gen_set_params_fn(void * , OSSL_PARAM [] );
#line 576 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keymgmt_gen_settable_params_fn(void * , void * );
#line 579 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keymgmt_gen_fn(void * , OSSL_CALLBACK * , void * );
#line 581 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_keymgmt_gen_cleanup_fn(void * );
#line 585 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keymgmt_load_fn(void const   * , size_t  );
#line 590 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_keymgmt_free_fn(void * );
#line 595 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_get_params_fn(void * , OSSL_PARAM [] );
#line 597 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keymgmt_gettable_params_fn(void * );
#line 602 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_set_params_fn(void * , OSSL_PARAM [] );
#line 604 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keymgmt_settable_params_fn(void * );
#line 609 "/usr/include/openssl/core_dispatch.h"
typedef char const   *OSSL_FUNC_keymgmt_query_operation_name_fn(int  );
#line 614 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_has_fn(void const   * , int  );
#line 618 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_validate_fn(void const   * , int  , int  );
#line 623 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_match_fn(void const   * , void const   * , int  );
#line 632 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_import_fn(void * , int  , OSSL_PARAM [] );
#line 634 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keymgmt_import_types_fn(int  );
#line 636 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keymgmt_export_fn(void * , int  , OSSL_CALLBACK * , void * );
#line 639 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keymgmt_export_types_fn(int  );
#line 644 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keymgmt_dup_fn(void const   * , int  );
#line 660 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keyexch_newctx_fn(void * );
#line 661 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keyexch_init_fn(void * , void * , OSSL_PARAM [] );
#line 663 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keyexch_derive_fn(void * , unsigned char * , size_t * , size_t  );
#line 665 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keyexch_set_peer_fn(void * , void * );
#line 666 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_keyexch_freectx_fn(void * );
#line 667 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_keyexch_dupctx_fn(void * );
#line 668 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keyexch_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 670 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keyexch_settable_ctx_params_fn(void * , void * );
#line 672 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_keyexch_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 674 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_keyexch_gettable_ctx_params_fn(void * , void * );
#line 705 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_signature_newctx_fn(void * , char const   * );
#line 707 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_sign_init_fn(void * , void * , OSSL_PARAM [] );
#line 709 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_sign_fn(void * , unsigned char * , size_t * , size_t  ,
                                        unsigned char const   * , size_t  );
#line 713 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_verify_init_fn(void * , void * , OSSL_PARAM [] );
#line 715 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_verify_fn(void * , unsigned char const   * , size_t  ,
                                          unsigned char const   * , size_t  );
#line 720 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_verify_recover_init_fn(void * , void * , OSSL_PARAM [] );
#line 722 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_verify_recover_fn(void * , unsigned char * , size_t * ,
                                                  size_t  , unsigned char const   * ,
                                                  size_t  );
#line 725 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_sign_init_fn(void * , char const   * , void * ,
                                                    OSSL_PARAM [] );
#line 728 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_sign_update_fn(void * , unsigned char const   * ,
                                                      size_t  );
#line 730 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_sign_final_fn(void * , unsigned char * , size_t * ,
                                                     size_t  );
#line 733 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_sign_fn(void * , unsigned char * , size_t * ,
                                               size_t  , unsigned char const   * ,
                                               size_t  );
#line 736 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_verify_init_fn(void * , char const   * , void * ,
                                                      OSSL_PARAM [] );
#line 739 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_verify_update_fn(void * , unsigned char const   * ,
                                                        size_t  );
#line 741 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_verify_final_fn(void * , unsigned char const   * ,
                                                       size_t  );
#line 743 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_digest_verify_fn(void * , unsigned char const   * ,
                                                 size_t  , unsigned char const   * ,
                                                 size_t  );
#line 746 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_signature_freectx_fn(void * );
#line 747 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_signature_dupctx_fn(void * );
#line 748 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 750 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_signature_gettable_ctx_params_fn(void * , void * );
#line 752 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 754 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_signature_settable_ctx_params_fn(void * , void * );
#line 756 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_get_ctx_md_params_fn(void * , OSSL_PARAM [] );
#line 758 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_signature_gettable_ctx_md_params_fn(void * );
#line 760 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_signature_set_ctx_md_params_fn(void * , OSSL_PARAM [] );
#line 762 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_signature_settable_ctx_md_params_fn(void * );
#line 780 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_asym_cipher_newctx_fn(void * );
#line 781 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_encrypt_init_fn(void * , void * , OSSL_PARAM [] );
#line 783 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_encrypt_fn(void * , unsigned char * , size_t * ,
                                             size_t  , unsigned char const   * , size_t  );
#line 788 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_decrypt_init_fn(void * , void * , OSSL_PARAM [] );
#line 790 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_decrypt_fn(void * , unsigned char * , size_t * ,
                                             size_t  , unsigned char const   * , size_t  );
#line 795 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_asym_cipher_freectx_fn(void * );
#line 796 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_asym_cipher_dupctx_fn(void * );
#line 797 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 799 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_asym_cipher_gettable_ctx_params_fn(void * , void * );
#line 801 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_asym_cipher_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 803 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_asym_cipher_settable_ctx_params_fn(void * , void * );
#line 819 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_kem_newctx_fn(void * );
#line 820 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_encapsulate_init_fn(void * , void * , OSSL_PARAM [] );
#line 822 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_encapsulate_fn(void * , unsigned char * , size_t * , unsigned char * ,
                                         size_t * );
#line 826 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_decapsulate_init_fn(void * , void * , OSSL_PARAM [] );
#line 828 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_decapsulate_fn(void * , unsigned char * , size_t * , unsigned char const   * ,
                                         size_t  );
#line 831 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_kem_freectx_fn(void * );
#line 832 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_kem_dupctx_fn(void * );
#line 833 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_get_ctx_params_fn(void * , OSSL_PARAM [] );
#line 834 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_kem_gettable_ctx_params_fn(void * , void * );
#line 836 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_kem_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 838 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_kem_settable_ctx_params_fn(void * , void * );
#line 852 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_encoder_newctx_fn(void * );
#line 853 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_encoder_freectx_fn(void * );
#line 854 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_encoder_get_params_fn(OSSL_PARAM [] );
#line 855 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_encoder_gettable_params_fn(void * );
#line 857 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_encoder_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 859 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_encoder_settable_ctx_params_fn(void * );
#line 862 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_encoder_does_selection_fn(void * , int  );
#line 864 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_encoder_encode_fn(void * , OSSL_CORE_BIO * , void const   * ,
                                        OSSL_PARAM [] , int  , OSSL_PASSPHRASE_CALLBACK * ,
                                        void * );
#line 870 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_encoder_import_object_fn(void * , int  , OSSL_PARAM [] );
#line 872 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_encoder_free_object_fn(void * );
#line 883 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_decoder_newctx_fn(void * );
#line 884 "/usr/include/openssl/core_dispatch.h"
typedef void OSSL_FUNC_decoder_freectx_fn(void * );
#line 885 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_decoder_get_params_fn(OSSL_PARAM [] );
#line 886 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_decoder_gettable_params_fn(void * );
#line 888 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_decoder_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 890 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_decoder_settable_ctx_params_fn(void * );
#line 893 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_decoder_does_selection_fn(void * , int  );
#line 895 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_decoder_decode_fn(void * , OSSL_CORE_BIO * , int  , OSSL_CALLBACK * ,
                                        void * , OSSL_PASSPHRASE_CALLBACK * , void * );
#line 899 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_decoder_export_object_fn(void * , void const   * , size_t  ,
                                               OSSL_CALLBACK * , void * );
#line 923 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_store_open_fn(void * , char const   * );
#line 924 "/usr/include/openssl/core_dispatch.h"
typedef void *OSSL_FUNC_store_attach_fn(void * , OSSL_CORE_BIO * );
#line 925 "/usr/include/openssl/core_dispatch.h"
typedef OSSL_PARAM *OSSL_FUNC_store_settable_ctx_params_fn(void * );
#line 927 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_store_set_ctx_params_fn(void * , OSSL_PARAM [] );
#line 929 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_store_load_fn(void * , OSSL_CALLBACK * , void * , OSSL_PASSPHRASE_CALLBACK * ,
                                    void * );
#line 933 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_store_eof_fn(void * );
#line 934 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_store_close_fn(void * );
#line 935 "/usr/include/openssl/core_dispatch.h"
typedef int OSSL_FUNC_store_export_object_fn(void * , void const   * , size_t  , OSSL_CALLBACK * ,
                                             void * );
#line 129 "/usr/include/openssl/asn1.h"
struct stack_st_X509_ALGOR ;
#line 129 "/usr/include/openssl/asn1.h"
typedef int (*sk_X509_ALGOR_compfunc)(X509_ALGOR * const  * , X509_ALGOR * const  * );
#line 129 "/usr/include/openssl/asn1.h"
typedef void (*sk_X509_ALGOR_freefunc)(X509_ALGOR * );
#line 129 "/usr/include/openssl/asn1.h"
typedef X509_ALGOR *(*sk_X509_ALGOR_copyfunc)(X509_ALGOR * );
#line 183 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 201 "/usr/include/openssl/asn1.h"
struct ASN1_ENCODING_st {
   unsigned char *enc ;
   long len ;
   int modified ;
};
#line 205 "/usr/include/openssl/asn1.h"
typedef struct ASN1_ENCODING_st ASN1_ENCODING;
#line 223 "/usr/include/openssl/asn1.h"
struct asn1_string_table_st {
   int nid ;
   long minsize ;
   long maxsize ;
   unsigned long mask ;
   unsigned long flags ;
};
#line 231
struct stack_st_ASN1_STRING_TABLE ;
#line 231 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_STRING_TABLE_compfunc)(ASN1_STRING_TABLE * const  * , ASN1_STRING_TABLE * const  * );
#line 231 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_STRING_TABLE_freefunc)(ASN1_STRING_TABLE * );
#line 231 "/usr/include/openssl/asn1.h"
typedef ASN1_STRING_TABLE *(*sk_ASN1_STRING_TABLE_copyfunc)(ASN1_STRING_TABLE * );
#line 273
struct ASN1_TEMPLATE_st ;
#line 273 "/usr/include/openssl/asn1.h"
typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;
#line 274
struct ASN1_TLC_st ;
#line 274 "/usr/include/openssl/asn1.h"
typedef struct ASN1_TLC_st ASN1_TLC;
#line 276
struct ASN1_VALUE_st ;
#line 276 "/usr/include/openssl/asn1.h"
typedef struct ASN1_VALUE_st ASN1_VALUE;
#line 369 "/usr/include/openssl/asn1.h"
typedef void *d2i_of_void(void ** , unsigned char const   ** , long  );
#line 370 "/usr/include/openssl/asn1.h"
typedef int i2d_of_void(void const   * , unsigned char ** );
#line 415 "/usr/include/openssl/asn1.h"
typedef ASN1_ITEM *ASN1_ITEM_EXP(void);
#line 522 "/usr/include/openssl/asn1.h"
union __anonunion_528 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
#line 520 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_528 value ;
};
#line 551
struct stack_st_ASN1_TYPE ;
#line 551 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_TYPE_compfunc)(ASN1_TYPE * const  * , ASN1_TYPE * const  * );
#line 551 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_TYPE_freefunc)(ASN1_TYPE * );
#line 551 "/usr/include/openssl/asn1.h"
typedef ASN1_TYPE *(*sk_ASN1_TYPE_copyfunc)(ASN1_TYPE * );
#line 579 "/usr/include/openssl/asn1.h"
typedef struct stack_st_ASN1_TYPE ASN1_SEQUENCE_ANY;
#line 585 "/usr/include/openssl/asn1.h"
struct BIT_STRING_BITNAME_st {
   int bitnum ;
   char const   *lname ;
   char const   *sname ;
};
#line 589 "/usr/include/openssl/asn1.h"
typedef struct BIT_STRING_BITNAME_st BIT_STRING_BITNAME;
#line 631
struct stack_st_ASN1_OBJECT ;
#line 631 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_OBJECT_compfunc)(ASN1_OBJECT * const  * , ASN1_OBJECT * const  * );
#line 631 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_OBJECT_freefunc)(ASN1_OBJECT * );
#line 631 "/usr/include/openssl/asn1.h"
typedef ASN1_OBJECT *(*sk_ASN1_OBJECT_copyfunc)(ASN1_OBJECT * );
#line 697
struct stack_st_ASN1_INTEGER ;
#line 697 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_INTEGER_compfunc)(ASN1_INTEGER * const  * , ASN1_INTEGER * const  * );
#line 697 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_INTEGER_freefunc)(ASN1_INTEGER * );
#line 697 "/usr/include/openssl/asn1.h"
typedef ASN1_INTEGER *(*sk_ASN1_INTEGER_copyfunc)(ASN1_INTEGER * );
#line 759
struct stack_st_ASN1_UTF8STRING ;
#line 759 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_UTF8STRING_compfunc)(ASN1_UTF8STRING * const  * , ASN1_UTF8STRING * const  * );
#line 759 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_UTF8STRING_freefunc)(ASN1_UTF8STRING * );
#line 759 "/usr/include/openssl/asn1.h"
typedef ASN1_UTF8STRING *(*sk_ASN1_UTF8STRING_copyfunc)(ASN1_UTF8STRING * );
#line 796
struct stack_st_ASN1_GENERALSTRING ;
#line 796 "/usr/include/openssl/asn1.h"
typedef int (*sk_ASN1_GENERALSTRING_compfunc)(ASN1_GENERALSTRING * const  * , ASN1_GENERALSTRING * const  * );
#line 796 "/usr/include/openssl/asn1.h"
typedef void (*sk_ASN1_GENERALSTRING_freefunc)(ASN1_GENERALSTRING * );
#line 796 "/usr/include/openssl/asn1.h"
typedef ASN1_GENERALSTRING *(*sk_ASN1_GENERALSTRING_copyfunc)(ASN1_GENERALSTRING * );
#line 43 "/usr/include/openssl/objects.h"
struct obj_name_st {
   int type ;
   int alias ;
   char const   *name ;
   char const   *data ;
};
#line 48 "/usr/include/openssl/objects.h"
typedef struct obj_name_st OBJ_NAME;
#line 448 "/usr/include/openssl/evp.h"
struct __anonstruct_529 {
   unsigned char *out ;
   unsigned char const   *inp ;
   size_t len ;
   unsigned int interleave ;
};
#line 453 "/usr/include/openssl/evp.h"
typedef struct __anonstruct_529 EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM;
#line 478 "/usr/include/openssl/evp.h"
struct evp_cipher_info_st {
   EVP_CIPHER *cipher ;
   unsigned char iv[16] ;
};
#line 481 "/usr/include/openssl/evp.h"
typedef struct evp_cipher_info_st EVP_CIPHER_INFO;
#line 485 "/usr/include/openssl/evp.h"
typedef int EVP_PBE_KEYGEN(EVP_CIPHER_CTX * , char const   * , int  , ASN1_TYPE * ,
                           EVP_CIPHER * , EVP_MD * , int  );
#line 490 "/usr/include/openssl/evp.h"
typedef int EVP_PBE_KEYGEN_EX(EVP_CIPHER_CTX * , char const   * , int  , ASN1_TYPE * ,
                              EVP_CIPHER * , EVP_MD * , int  , OSSL_LIB_CTX * , char const   * );
#line 1933 "/usr/include/openssl/evp.h"
typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX * );
#line 78 "/usr/include/openssl/ec.h"
enum __anonenum__530 {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6
} ;
#line 87 "/usr/include/openssl/ec.h"
typedef enum __anonenum__530 point_conversion_form_t;
#line 105
struct ec_method_st ;
#line 105 "/usr/include/openssl/ec.h"
typedef struct ec_method_st EC_METHOD;
#line 107
struct ec_group_st ;
#line 107 "/usr/include/openssl/ec.h"
typedef struct ec_group_st EC_GROUP;
#line 108
struct ec_point_st ;
#line 108 "/usr/include/openssl/ec.h"
typedef struct ec_point_st EC_POINT;
#line 109
struct ecpk_parameters_st ;
#line 109 "/usr/include/openssl/ec.h"
typedef struct ecpk_parameters_st ECPKPARAMETERS;
#line 110
struct ec_parameters_st ;
#line 110 "/usr/include/openssl/ec.h"
typedef struct ec_parameters_st ECPARAMETERS;
#line 518 "/usr/include/openssl/ec.h"
struct __anonstruct_531 {
   int nid ;
   char const   *comment ;
};
#line 521 "/usr/include/openssl/ec.h"
typedef struct __anonstruct_531 EC_builtin_curve;
#line 1304
struct ECDSA_SIG_st ;
#line 1304 "/usr/include/openssl/ec.h"
typedef struct ECDSA_SIG_st ECDSA_SIG;
#line 320 "/usr/include/openssl/rsa.h"
struct rsa_pss_params_st {
   X509_ALGOR *hashAlgorithm ;
   X509_ALGOR *maskGenAlgorithm ;
   ASN1_INTEGER *saltLength ;
   ASN1_INTEGER *trailerField ;
   X509_ALGOR *maskHash ;
};
#line 332 "/usr/include/openssl/rsa.h"
struct rsa_oaep_params_st {
   X509_ALGOR *hashFunc ;
   X509_ALGOR *maskGenFunc ;
   X509_ALGOR *pSourceFunc ;
   X509_ALGOR *maskHash ;
};
#line 338 "/usr/include/openssl/rsa.h"
typedef struct rsa_oaep_params_st RSA_OAEP_PARAMS;
#line 61 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st ;
#line 61 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 42 "/usr/include/openssl/sha.h"
struct SHAstate_st {
   unsigned int h0 ;
   unsigned int h1 ;
   unsigned int h2 ;
   unsigned int h3 ;
   unsigned int h4 ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
};
#line 47 "/usr/include/openssl/sha.h"
typedef struct SHAstate_st SHA_CTX;
#line 62 "/usr/include/openssl/sha.h"
struct SHA256state_st {
   unsigned int h[8] ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   unsigned int num ;
   unsigned int md_len ;
};
#line 67 "/usr/include/openssl/sha.h"
typedef struct SHA256state_st SHA256_CTX;
#line 112 "/usr/include/openssl/sha.h"
union __anonunion_532 {
   unsigned long long d[16] ;
   unsigned char p[128] ;
};
#line 109 "/usr/include/openssl/sha.h"
struct SHA512state_st {
   unsigned long long h[8] ;
   unsigned long long Nl ;
   unsigned long long Nh ;
   union __anonunion_532 u ;
   unsigned int num ;
   unsigned int md_len ;
};
#line 117 "/usr/include/openssl/sha.h"
typedef struct SHA512state_st SHA512_CTX;
#line 49 "/usr/include/openssl/x509.h"
struct stack_st_X509_NAME ;
#line 49 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_NAME_compfunc)(X509_NAME * const  * , X509_NAME * const  * );
#line 49 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_NAME_freefunc)(X509_NAME * );
#line 49 "/usr/include/openssl/x509.h"
typedef X509_NAME *(*sk_X509_NAME_copyfunc)(X509_NAME * );
#line 75
struct stack_st_X509 ;
#line 75 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_compfunc)(X509 * const  * , X509 * const  * );
#line 75 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_freefunc)(X509 * );
#line 75 "/usr/include/openssl/x509.h"
typedef X509 *(*sk_X509_copyfunc)(X509 * );
#line 101
struct stack_st_X509_REVOKED ;
#line 101 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_REVOKED_compfunc)(X509_REVOKED * const  * , X509_REVOKED * const  * );
#line 101 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_REVOKED_freefunc)(X509_REVOKED * );
#line 101 "/usr/include/openssl/x509.h"
typedef X509_REVOKED *(*sk_X509_REVOKED_copyfunc)(X509_REVOKED * );
#line 127
struct stack_st_X509_CRL ;
#line 127 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_CRL_compfunc)(X509_CRL * const  * , X509_CRL * const  * );
#line 127 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_CRL_freefunc)(X509_CRL * );
#line 127 "/usr/include/openssl/x509.h"
typedef X509_CRL *(*sk_X509_CRL_copyfunc)(X509_CRL * );
#line 176 "/usr/include/openssl/x509.h"
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
#line 181 "/usr/include/openssl/x509.h"
typedef struct stack_st_X509_ALGOR X509_ALGORS;
#line 183 "/usr/include/openssl/x509.h"
struct X509_val_st {
   ASN1_TIME *notBefore ;
   ASN1_TIME *notAfter ;
};
#line 186 "/usr/include/openssl/x509.h"
typedef struct X509_val_st X509_VAL;
#line 188
struct X509_sig_st ;
#line 188 "/usr/include/openssl/x509.h"
typedef struct X509_sig_st X509_SIG;
#line 190
struct X509_name_entry_st ;
#line 190 "/usr/include/openssl/x509.h"
typedef struct X509_name_entry_st X509_NAME_ENTRY;
#line 192
struct stack_st_X509_NAME_ENTRY ;
#line 192 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_NAME_ENTRY_compfunc)(X509_NAME_ENTRY * const  * , X509_NAME_ENTRY * const  * );
#line 192 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_NAME_ENTRY_freefunc)(X509_NAME_ENTRY * );
#line 192 "/usr/include/openssl/x509.h"
typedef X509_NAME_ENTRY *(*sk_X509_NAME_ENTRY_copyfunc)(X509_NAME_ENTRY * );
#line 222
struct X509_extension_st ;
#line 222 "/usr/include/openssl/x509.h"
typedef struct X509_extension_st X509_EXTENSION;
#line 223
struct stack_st_X509_EXTENSION ;
#line 223 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_EXTENSION_compfunc)(X509_EXTENSION * const  * , X509_EXTENSION * const  * );
#line 223 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_EXTENSION_freefunc)(X509_EXTENSION * );
#line 223 "/usr/include/openssl/x509.h"
typedef X509_EXTENSION *(*sk_X509_EXTENSION_copyfunc)(X509_EXTENSION * );
#line 250 "/usr/include/openssl/x509.h"
typedef struct stack_st_X509_EXTENSION X509_EXTENSIONS;
#line 251
struct x509_attributes_st ;
#line 251 "/usr/include/openssl/x509.h"
typedef struct x509_attributes_st X509_ATTRIBUTE;
#line 252
struct stack_st_X509_ATTRIBUTE ;
#line 252 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_ATTRIBUTE_compfunc)(X509_ATTRIBUTE * const  * , X509_ATTRIBUTE * const  * );
#line 252 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_ATTRIBUTE_freefunc)(X509_ATTRIBUTE * );
#line 252 "/usr/include/openssl/x509.h"
typedef X509_ATTRIBUTE *(*sk_X509_ATTRIBUTE_copyfunc)(X509_ATTRIBUTE * );
#line 279
struct X509_req_info_st ;
#line 279 "/usr/include/openssl/x509.h"
typedef struct X509_req_info_st X509_REQ_INFO;
#line 280
struct X509_req_st ;
#line 280 "/usr/include/openssl/x509.h"
typedef struct X509_req_st X509_REQ;
#line 281
struct x509_cert_aux_st ;
#line 281 "/usr/include/openssl/x509.h"
typedef struct x509_cert_aux_st X509_CERT_AUX;
#line 282
struct x509_cinf_st ;
#line 282 "/usr/include/openssl/x509.h"
typedef struct x509_cinf_st X509_CINF;
#line 362
struct X509_crl_info_st ;
#line 362 "/usr/include/openssl/x509.h"
typedef struct X509_crl_info_st X509_CRL_INFO;
#line 364 "/usr/include/openssl/x509.h"
struct private_key_st {
   int version ;
   X509_ALGOR *enc_algor ;
   ASN1_OCTET_STRING *enc_pkey ;
   EVP_PKEY *dec_pkey ;
   int key_length ;
   char *key_data ;
   int key_free ;
   EVP_CIPHER_INFO cipher ;
};
#line 377 "/usr/include/openssl/x509.h"
typedef struct private_key_st X509_PKEY;
#line 379 "/usr/include/openssl/x509.h"
struct X509_info_st {
   X509 *x509 ;
   X509_CRL *crl ;
   X509_PKEY *x_pkey ;
   EVP_CIPHER_INFO enc_cipher ;
   int enc_len ;
   char *enc_data ;
};
#line 386 "/usr/include/openssl/x509.h"
typedef struct X509_info_st X509_INFO;
#line 387
struct stack_st_X509_INFO ;
#line 387 "/usr/include/openssl/x509.h"
typedef int (*sk_X509_INFO_compfunc)(X509_INFO * const  * , X509_INFO * const  * );
#line 387 "/usr/include/openssl/x509.h"
typedef void (*sk_X509_INFO_freefunc)(X509_INFO * );
#line 387 "/usr/include/openssl/x509.h"
typedef X509_INFO *(*sk_X509_INFO_copyfunc)(X509_INFO * );
#line 419 "/usr/include/openssl/x509.h"
struct Netscape_spkac_st {
   X509_PUBKEY *pubkey ;
   ASN1_IA5STRING *challenge ;
};
#line 422 "/usr/include/openssl/x509.h"
typedef struct Netscape_spkac_st NETSCAPE_SPKAC;
#line 424 "/usr/include/openssl/x509.h"
struct Netscape_spki_st {
   NETSCAPE_SPKAC *spkac ;
   X509_ALGOR sig_algor ;
   ASN1_BIT_STRING *signature ;
};
#line 428 "/usr/include/openssl/x509.h"
typedef struct Netscape_spki_st NETSCAPE_SPKI;
#line 431 "/usr/include/openssl/x509.h"
struct Netscape_certificate_sequence {
   ASN1_OBJECT *type ;
   struct stack_st_X509 *certs ;
};
#line 434 "/usr/include/openssl/x509.h"
typedef struct Netscape_certificate_sequence NETSCAPE_CERT_SEQUENCE;
#line 445 "/usr/include/openssl/x509.h"
struct PBEPARAM_st {
   ASN1_OCTET_STRING *salt ;
   ASN1_INTEGER *iter ;
};
#line 448 "/usr/include/openssl/x509.h"
typedef struct PBEPARAM_st PBEPARAM;
#line 452 "/usr/include/openssl/x509.h"
struct PBE2PARAM_st {
   X509_ALGOR *keyfunc ;
   X509_ALGOR *encryption ;
};
#line 455 "/usr/include/openssl/x509.h"
typedef struct PBE2PARAM_st PBE2PARAM;
#line 457 "/usr/include/openssl/x509.h"
struct PBKDF2PARAM_st {
   ASN1_TYPE *salt ;
   ASN1_INTEGER *iter ;
   ASN1_INTEGER *keylength ;
   X509_ALGOR *prf ;
};
#line 463 "/usr/include/openssl/x509.h"
typedef struct PBKDF2PARAM_st PBKDF2PARAM;
#line 466 "/usr/include/openssl/x509.h"
struct SCRYPT_PARAMS_st {
   ASN1_OCTET_STRING *salt ;
   ASN1_INTEGER *costParameter ;
   ASN1_INTEGER *blockSize ;
   ASN1_INTEGER *parallelizationParameter ;
   ASN1_INTEGER *keyLength ;
};
#line 472 "/usr/include/openssl/x509.h"
typedef struct SCRYPT_PARAMS_st SCRYPT_PARAMS;
#line 32 "/usr/include/openssl/lhash.h"
struct lhash_node_st ;
#line 32 "/usr/include/openssl/lhash.h"
typedef struct lhash_node_st OPENSSL_LH_NODE;
#line 33 "/usr/include/openssl/lhash.h"
typedef int (*OPENSSL_LH_COMPFUNC)(void const   * , void const   * );
#line 34 "/usr/include/openssl/lhash.h"
typedef unsigned long (*OPENSSL_LH_HASHFUNC)(void const   * );
#line 35 "/usr/include/openssl/lhash.h"
typedef void (*OPENSSL_LH_DOALL_FUNC)(void * );
#line 36 "/usr/include/openssl/lhash.h"
typedef void (*OPENSSL_LH_DOALL_FUNCARG)(void * , void * );
#line 37
struct lhash_st ;
#line 37 "/usr/include/openssl/lhash.h"
typedef struct lhash_st OPENSSL_LHASH;
#line 252 "/usr/include/openssl/lhash.h"
union lh_OPENSSL_STRING_dummy {
   void *d1 ;
   unsigned long d2 ;
   int d3 ;
};
#line 252 "/usr/include/openssl/lhash.h"
struct lhash_st_OPENSSL_STRING {
   union lh_OPENSSL_STRING_dummy dummy ;
};
#line 252 "/usr/include/openssl/lhash.h"
typedef int (*lh_OPENSSL_STRING_compfunc)(OPENSSL_STRING * , OPENSSL_STRING * );
#line 252 "/usr/include/openssl/lhash.h"
typedef unsigned long (*lh_OPENSSL_STRING_hashfunc)(OPENSSL_STRING * );
#line 252 "/usr/include/openssl/lhash.h"
typedef void (*lh_OPENSSL_STRING_doallfunc)(OPENSSL_STRING * );
#line 267 "/usr/include/openssl/lhash.h"
union lh_OPENSSL_CSTRING_dummy {
   void *d1 ;
   unsigned long d2 ;
   int d3 ;
};
#line 267 "/usr/include/openssl/lhash.h"
struct lhash_st_OPENSSL_CSTRING {
   union lh_OPENSSL_CSTRING_dummy dummy ;
};
#line 267 "/usr/include/openssl/lhash.h"
typedef int (*lh_OPENSSL_CSTRING_compfunc)(OPENSSL_CSTRING * , OPENSSL_CSTRING * );
#line 267 "/usr/include/openssl/lhash.h"
typedef unsigned long (*lh_OPENSSL_CSTRING_hashfunc)(OPENSSL_CSTRING * );
#line 267 "/usr/include/openssl/lhash.h"
typedef void (*lh_OPENSSL_CSTRING_doallfunc)(OPENSSL_CSTRING * );
#line 58 "/usr/include/openssl/x509_vfy.h"
enum __anonenum__533 {
    X509_LU_NONE = 0,
    X509_LU_X509 = 1,
    X509_LU_CRL = 2
} ;
#line 61 "/usr/include/openssl/x509_vfy.h"
typedef enum __anonenum__533 X509_LOOKUP_TYPE;
#line 68
struct stack_st_X509_LOOKUP ;
#line 68 "/usr/include/openssl/x509_vfy.h"
typedef int (*sk_X509_LOOKUP_compfunc)(X509_LOOKUP * const  * , X509_LOOKUP * const  * );
#line 68 "/usr/include/openssl/x509_vfy.h"
typedef void (*sk_X509_LOOKUP_freefunc)(X509_LOOKUP * );
#line 68 "/usr/include/openssl/x509_vfy.h"
typedef X509_LOOKUP *(*sk_X509_LOOKUP_copyfunc)(X509_LOOKUP * );
#line 94
struct stack_st_X509_OBJECT ;
#line 94 "/usr/include/openssl/x509_vfy.h"
typedef int (*sk_X509_OBJECT_compfunc)(X509_OBJECT * const  * , X509_OBJECT * const  * );
#line 94 "/usr/include/openssl/x509_vfy.h"
typedef void (*sk_X509_OBJECT_freefunc)(X509_OBJECT * );
#line 94 "/usr/include/openssl/x509_vfy.h"
typedef X509_OBJECT *(*sk_X509_OBJECT_copyfunc)(X509_OBJECT * );
#line 120
struct stack_st_X509_VERIFY_PARAM ;
#line 120 "/usr/include/openssl/x509_vfy.h"
typedef int (*sk_X509_VERIFY_PARAM_compfunc)(X509_VERIFY_PARAM * const  * , X509_VERIFY_PARAM * const  * );
#line 120 "/usr/include/openssl/x509_vfy.h"
typedef void (*sk_X509_VERIFY_PARAM_freefunc)(X509_VERIFY_PARAM * );
#line 120 "/usr/include/openssl/x509_vfy.h"
typedef X509_VERIFY_PARAM *(*sk_X509_VERIFY_PARAM_copyfunc)(X509_VERIFY_PARAM * );
#line 149 "/usr/include/openssl/x509_vfy.h"
struct x509_trust_st {
   int trust ;
   int flags ;
   int (*check_trust)(struct x509_trust_st * , X509 * , int  ) ;
   char *name ;
   int arg1 ;
   void *arg2 ;
};
#line 156 "/usr/include/openssl/x509_vfy.h"
typedef struct x509_trust_st X509_TRUST;
#line 157
struct stack_st_X509_TRUST ;
#line 157 "/usr/include/openssl/x509_vfy.h"
typedef int (*sk_X509_TRUST_compfunc)(X509_TRUST * const  * , X509_TRUST * const  * );
#line 157 "/usr/include/openssl/x509_vfy.h"
typedef void (*sk_X509_TRUST_freefunc)(X509_TRUST * );
#line 157 "/usr/include/openssl/x509_vfy.h"
typedef X509_TRUST *(*sk_X509_TRUST_copyfunc)(X509_TRUST * );
#line 245 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_verify_cb)(int  , X509_STORE_CTX * );
#line 247 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX * );
#line 248 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_get_issuer_fn)(X509 ** , X509_STORE_CTX * , X509 * );
#line 250 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_check_issued_fn)(X509_STORE_CTX * , X509 * , X509 * );
#line 252 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_check_revocation_fn)(X509_STORE_CTX * );
#line 253 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_get_crl_fn)(X509_STORE_CTX * , X509_CRL ** , X509 * );
#line 255 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_check_crl_fn)(X509_STORE_CTX * , X509_CRL * );
#line 256 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_cert_crl_fn)(X509_STORE_CTX * , X509_CRL * , X509 * );
#line 258 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_check_policy_fn)(X509_STORE_CTX * );
#line 260 "/usr/include/openssl/x509_vfy.h"
typedef struct stack_st_X509 *(*X509_STORE_CTX_lookup_certs_fn)(X509_STORE_CTX * ,
                                                                X509_NAME * );
#line 263 "/usr/include/openssl/x509_vfy.h"
typedef struct stack_st_X509_CRL *(*X509_STORE_CTX_lookup_crls_fn)(X509_STORE_CTX * ,
                                                                   X509_NAME * );
#line 265 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_STORE_CTX_cleanup_fn)(X509_STORE_CTX * );
#line 608 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_ctrl_fn)(X509_LOOKUP * , int  , char const   * , long  ,
                                   char ** );
#line 610 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_ctrl_ex_fn)(X509_LOOKUP * , int  , char const   * , long  ,
                                      char ** , OSSL_LIB_CTX * , char const   * );
#line 614 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_get_by_subject_fn)(X509_LOOKUP * , X509_LOOKUP_TYPE  , X509_NAME * ,
                                             X509_OBJECT * );
#line 618 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_get_by_subject_ex_fn)(X509_LOOKUP * , X509_LOOKUP_TYPE  ,
                                                X509_NAME * , X509_OBJECT * , OSSL_LIB_CTX * ,
                                                char const   * );
#line 624 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_get_by_issuer_serial_fn)(X509_LOOKUP * , X509_LOOKUP_TYPE  ,
                                                   X509_NAME * , ASN1_INTEGER * ,
                                                   X509_OBJECT * );
#line 629 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_get_by_fingerprint_fn)(X509_LOOKUP * , X509_LOOKUP_TYPE  ,
                                                 unsigned char const   * , int  ,
                                                 X509_OBJECT * );
#line 634 "/usr/include/openssl/x509_vfy.h"
typedef int (*X509_LOOKUP_get_by_alias_fn)(X509_LOOKUP * , X509_LOOKUP_TYPE  , char const   * ,
                                           int  , X509_OBJECT * );
#line 873
struct stack_st_X509_POLICY_NODE ;
#line 886
struct stack_st_POLICYQUALINFO ;
#line 44 "/usr/include/openssl/pkcs7.h"
struct PKCS7_CTX_st {
   OSSL_LIB_CTX *libctx ;
   char *propq ;
};
#line 47 "/usr/include/openssl/pkcs7.h"
typedef struct PKCS7_CTX_st PKCS7_CTX;
#line 49 "/usr/include/openssl/pkcs7.h"
struct pkcs7_issuer_and_serial_st {
   X509_NAME *issuer ;
   ASN1_INTEGER *serial ;
};
#line 52 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_issuer_and_serial_st PKCS7_ISSUER_AND_SERIAL;
#line 54 "/usr/include/openssl/pkcs7.h"
struct pkcs7_signer_info_st {
   ASN1_INTEGER *version ;
   PKCS7_ISSUER_AND_SERIAL *issuer_and_serial ;
   X509_ALGOR *digest_alg ;
   struct stack_st_X509_ATTRIBUTE *auth_attr ;
   X509_ALGOR *digest_enc_alg ;
   ASN1_OCTET_STRING *enc_digest ;
   struct stack_st_X509_ATTRIBUTE *unauth_attr ;
   EVP_PKEY *pkey ;
   PKCS7_CTX *ctx ;
};
#line 65 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_signer_info_st PKCS7_SIGNER_INFO;
#line 66
struct stack_st_PKCS7_SIGNER_INFO ;
#line 66 "/usr/include/openssl/pkcs7.h"
typedef int (*sk_PKCS7_SIGNER_INFO_compfunc)(PKCS7_SIGNER_INFO * const  * , PKCS7_SIGNER_INFO * const  * );
#line 66 "/usr/include/openssl/pkcs7.h"
typedef void (*sk_PKCS7_SIGNER_INFO_freefunc)(PKCS7_SIGNER_INFO * );
#line 66 "/usr/include/openssl/pkcs7.h"
typedef PKCS7_SIGNER_INFO *(*sk_PKCS7_SIGNER_INFO_copyfunc)(PKCS7_SIGNER_INFO * );
#line 94 "/usr/include/openssl/pkcs7.h"
struct pkcs7_recip_info_st {
   ASN1_INTEGER *version ;
   PKCS7_ISSUER_AND_SERIAL *issuer_and_serial ;
   X509_ALGOR *key_enc_algor ;
   ASN1_OCTET_STRING *enc_key ;
   X509 *cert ;
   PKCS7_CTX *ctx ;
};
#line 101 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_recip_info_st PKCS7_RECIP_INFO;
#line 102
struct stack_st_PKCS7_RECIP_INFO ;
#line 102 "/usr/include/openssl/pkcs7.h"
typedef int (*sk_PKCS7_RECIP_INFO_compfunc)(PKCS7_RECIP_INFO * const  * , PKCS7_RECIP_INFO * const  * );
#line 102 "/usr/include/openssl/pkcs7.h"
typedef void (*sk_PKCS7_RECIP_INFO_freefunc)(PKCS7_RECIP_INFO * );
#line 102 "/usr/include/openssl/pkcs7.h"
typedef PKCS7_RECIP_INFO *(*sk_PKCS7_RECIP_INFO_copyfunc)(PKCS7_RECIP_INFO * );
#line 137
struct pkcs7_st ;
#line 131 "/usr/include/openssl/pkcs7.h"
struct pkcs7_signed_st {
   ASN1_INTEGER *version ;
   struct stack_st_X509_ALGOR *md_algs ;
   struct stack_st_X509 *cert ;
   struct stack_st_X509_CRL *crl ;
   struct stack_st_PKCS7_SIGNER_INFO *signer_info ;
   struct pkcs7_st *contents ;
};
#line 138 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_signed_st PKCS7_SIGNED;
#line 144 "/usr/include/openssl/pkcs7.h"
struct pkcs7_enc_content_st {
   ASN1_OBJECT *content_type ;
   X509_ALGOR *algorithm ;
   ASN1_OCTET_STRING *enc_data ;
   EVP_CIPHER *cipher ;
   PKCS7_CTX *ctx ;
};
#line 150 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_enc_content_st PKCS7_ENC_CONTENT;
#line 152 "/usr/include/openssl/pkcs7.h"
struct pkcs7_enveloped_st {
   ASN1_INTEGER *version ;
   struct stack_st_PKCS7_RECIP_INFO *recipientinfo ;
   PKCS7_ENC_CONTENT *enc_data ;
};
#line 156 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_enveloped_st PKCS7_ENVELOPE;
#line 158 "/usr/include/openssl/pkcs7.h"
struct pkcs7_signedandenveloped_st {
   ASN1_INTEGER *version ;
   struct stack_st_X509_ALGOR *md_algs ;
   struct stack_st_X509 *cert ;
   struct stack_st_X509_CRL *crl ;
   struct stack_st_PKCS7_SIGNER_INFO *signer_info ;
   PKCS7_ENC_CONTENT *enc_data ;
   struct stack_st_PKCS7_RECIP_INFO *recipientinfo ;
};
#line 166 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_signedandenveloped_st PKCS7_SIGN_ENVELOPE;
#line 168 "/usr/include/openssl/pkcs7.h"
struct pkcs7_digest_st {
   ASN1_INTEGER *version ;
   X509_ALGOR *md ;
   struct pkcs7_st *contents ;
   ASN1_OCTET_STRING *digest ;
};
#line 173 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_digest_st PKCS7_DIGEST;
#line 175 "/usr/include/openssl/pkcs7.h"
struct pkcs7_encrypted_st {
   ASN1_INTEGER *version ;
   PKCS7_ENC_CONTENT *enc_data ;
};
#line 178 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_encrypted_st PKCS7_ENCRYPT;
#line 198 "/usr/include/openssl/pkcs7.h"
union __anonunion_534 {
   char *ptr ;
   ASN1_OCTET_STRING *data ;
   PKCS7_SIGNED *sign ;
   PKCS7_ENVELOPE *enveloped ;
   PKCS7_SIGN_ENVELOPE *signed_and_enveloped ;
   PKCS7_DIGEST *digest ;
   PKCS7_ENCRYPT *encrypted ;
   ASN1_TYPE *other ;
};
#line 180 "/usr/include/openssl/pkcs7.h"
struct pkcs7_st {
   unsigned char *asn1 ;
   long length ;
   int state ;
   int detached ;
   ASN1_OBJECT *type ;
   union __anonunion_534 d ;
   PKCS7_CTX ctx ;
};
#line 216 "/usr/include/openssl/pkcs7.h"
typedef struct pkcs7_st PKCS7;
#line 217
struct stack_st_PKCS7 ;
#line 217 "/usr/include/openssl/pkcs7.h"
typedef int (*sk_PKCS7_compfunc)(PKCS7 * const  * , PKCS7 * const  * );
#line 217 "/usr/include/openssl/pkcs7.h"
typedef void (*sk_PKCS7_freefunc)(PKCS7 * );
#line 217 "/usr/include/openssl/pkcs7.h"
typedef PKCS7 *(*sk_PKCS7_copyfunc)(PKCS7 * );
#line 35 "/usr/include/openssl/conf.h"
struct __anonstruct_535 {
   char *section ;
   char *name ;
   char *value ;
};
#line 39 "/usr/include/openssl/conf.h"
typedef struct __anonstruct_535 CONF_VALUE;
#line 41
struct stack_st_CONF_VALUE ;
#line 41 "/usr/include/openssl/conf.h"
typedef int (*sk_CONF_VALUE_compfunc)(CONF_VALUE * const  * , CONF_VALUE * const  * );
#line 41 "/usr/include/openssl/conf.h"
typedef void (*sk_CONF_VALUE_freefunc)(CONF_VALUE * );
#line 41 "/usr/include/openssl/conf.h"
typedef CONF_VALUE *(*sk_CONF_VALUE_copyfunc)(CONF_VALUE * );
#line 67 "/usr/include/openssl/conf.h"
union lh_CONF_VALUE_dummy {
   void *d1 ;
   unsigned long d2 ;
   int d3 ;
};
#line 67 "/usr/include/openssl/conf.h"
struct lhash_st_CONF_VALUE {
   union lh_CONF_VALUE_dummy dummy ;
};
#line 67 "/usr/include/openssl/conf.h"
typedef int (*lh_CONF_VALUE_compfunc)(CONF_VALUE * , CONF_VALUE * );
#line 67 "/usr/include/openssl/conf.h"
typedef unsigned long (*lh_CONF_VALUE_hashfunc)(CONF_VALUE * );
#line 67 "/usr/include/openssl/conf.h"
typedef void (*lh_CONF_VALUE_doallfunc)(CONF_VALUE * );
#line 85
struct conf_method_st ;
#line 86 "/usr/include/openssl/conf.h"
typedef struct conf_method_st CONF_METHOD;
#line 21 "/usr/include/openssl/conftypes.h"
struct conf_method_st {
   char const   *name ;
   CONF *(*create)(CONF_METHOD * ) ;
   int (*init)(CONF * ) ;
   int (*destroy)(CONF * ) ;
   int (*destroy_data)(CONF * ) ;
   int (*load_bio)(CONF * , BIO * , long * ) ;
   int (*dump)(CONF * , BIO * ) ;
   int (*is_number)(CONF * , char  ) ;
   int (*to_int)(CONF * , char  ) ;
   int (*load)(CONF * , char const   * , long * ) ;
};
#line 34 "/usr/include/openssl/conftypes.h"
struct conf_st {
   CONF_METHOD *meth ;
   void *meth_data ;
   struct lhash_st_CONF_VALUE *data ;
   int flag_dollarid ;
   int flag_abspath ;
   char *includedir ;
   OSSL_LIB_CTX *libctx ;
};
#line 93 "/usr/include/openssl/conf.h"
struct conf_imodule_st ;
#line 93 "/usr/include/openssl/conf.h"
typedef struct conf_imodule_st CONF_IMODULE;
#line 94
struct conf_module_st ;
#line 94 "/usr/include/openssl/conf.h"
typedef struct conf_module_st CONF_MODULE;
#line 96
struct stack_st_CONF_MODULE ;
#line 97
struct stack_st_CONF_IMODULE ;
#line 100 "/usr/include/openssl/conf.h"
typedef int conf_init_func(CONF_IMODULE * , CONF * );
#line 101 "/usr/include/openssl/conf.h"
typedef void conf_finish_func(CONF_IMODULE * );
#line 63 "/usr/include/openssl/http.h"
typedef BIO *(*OSSL_HTTP_bio_cb_t)(BIO * , void * , int  , int  );
#line 34 "/usr/include/openssl/x509v3.h"
struct v3_ext_method ;
#line 39 "/usr/include/openssl/x509v3.h"
typedef void *(*X509V3_EXT_NEW)(void);
#line 40 "/usr/include/openssl/x509v3.h"
typedef void (*X509V3_EXT_FREE)(void * );
#line 41 "/usr/include/openssl/x509v3.h"
typedef void *(*X509V3_EXT_D2I)(void * , unsigned char const   ** , long  );
#line 42 "/usr/include/openssl/x509v3.h"
typedef int (*X509V3_EXT_I2D)(void const   * , unsigned char ** );
#line 44 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_CONF_VALUE *(*X509V3_EXT_I2V)(struct v3_ext_method * , void * ,
                                                      struct stack_st_CONF_VALUE * );
#line 46 "/usr/include/openssl/x509v3.h"
typedef void *(*X509V3_EXT_V2I)(struct v3_ext_method * , struct v3_ext_ctx * , struct stack_st_CONF_VALUE * );
#line 49 "/usr/include/openssl/x509v3.h"
typedef char *(*X509V3_EXT_I2S)(struct v3_ext_method * , void * );
#line 51 "/usr/include/openssl/x509v3.h"
typedef void *(*X509V3_EXT_S2I)(struct v3_ext_method * , struct v3_ext_ctx * , char const   * );
#line 53 "/usr/include/openssl/x509v3.h"
typedef int (*X509V3_EXT_I2R)(struct v3_ext_method * , void * , BIO * , int  );
#line 55 "/usr/include/openssl/x509v3.h"
typedef void *(*X509V3_EXT_R2I)(struct v3_ext_method * , struct v3_ext_ctx * , char const   * );
#line 60 "/usr/include/openssl/x509v3.h"
struct v3_ext_method {
   int ext_nid ;
   int ext_flags ;
   ASN1_ITEM_EXP *it ;
   X509V3_EXT_NEW ext_new ;
   X509V3_EXT_FREE ext_free ;
   X509V3_EXT_D2I d2i ;
   X509V3_EXT_I2D i2d ;
   X509V3_EXT_I2S i2s ;
   X509V3_EXT_S2I s2i ;
   X509V3_EXT_I2V i2v ;
   X509V3_EXT_V2I v2i ;
   X509V3_EXT_I2R i2r ;
   X509V3_EXT_R2I r2i ;
   void *usr_data ;
};
#line 82 "/usr/include/openssl/x509v3.h"
struct X509V3_CONF_METHOD_st {
   char *(*get_string)(void * , char const   * , char const   * ) ;
   struct stack_st_CONF_VALUE *(*get_section)(void * , char const   * ) ;
   void (*free_string)(void * , char * ) ;
   void (*free_section)(void * , struct stack_st_CONF_VALUE * ) ;
};
#line 87 "/usr/include/openssl/x509v3.h"
typedef struct X509V3_CONF_METHOD_st X509V3_CONF_METHOD;
#line 90 "/usr/include/openssl/x509v3.h"
struct v3_ext_ctx {
   int flags ;
   X509 *issuer_cert ;
   X509 *subject_cert ;
   X509_REQ *subject_req ;
   X509_CRL *crl ;
   X509V3_CONF_METHOD *db_meth ;
   void *db ;
   EVP_PKEY *issuer_pkey ;
};
#line 107 "/usr/include/openssl/x509v3.h"
typedef struct v3_ext_method X509V3_EXT_METHOD;
#line 109
struct stack_st_X509V3_EXT_METHOD ;
#line 109 "/usr/include/openssl/x509v3.h"
typedef int (*sk_X509V3_EXT_METHOD_compfunc)(X509V3_EXT_METHOD * const  * , X509V3_EXT_METHOD * const  * );
#line 109 "/usr/include/openssl/x509v3.h"
typedef void (*sk_X509V3_EXT_METHOD_freefunc)(X509V3_EXT_METHOD * );
#line 109 "/usr/include/openssl/x509v3.h"
typedef X509V3_EXT_METHOD *(*sk_X509V3_EXT_METHOD_copyfunc)(X509V3_EXT_METHOD * );
#line 142 "/usr/include/openssl/x509v3.h"
typedef BIT_STRING_BITNAME ENUMERATED_NAMES;
#line 144 "/usr/include/openssl/x509v3.h"
struct BASIC_CONSTRAINTS_st {
   int ca ;
   ASN1_INTEGER *pathlen ;
};
#line 147 "/usr/include/openssl/x509v3.h"
typedef struct BASIC_CONSTRAINTS_st BASIC_CONSTRAINTS;
#line 149 "/usr/include/openssl/x509v3.h"
struct PKEY_USAGE_PERIOD_st {
   ASN1_GENERALIZEDTIME *notBefore ;
   ASN1_GENERALIZEDTIME *notAfter ;
};
#line 152 "/usr/include/openssl/x509v3.h"
typedef struct PKEY_USAGE_PERIOD_st PKEY_USAGE_PERIOD;
#line 154 "/usr/include/openssl/x509v3.h"
struct otherName_st {
   ASN1_OBJECT *type_id ;
   ASN1_TYPE *value ;
};
#line 157 "/usr/include/openssl/x509v3.h"
typedef struct otherName_st OTHERNAME;
#line 159 "/usr/include/openssl/x509v3.h"
struct EDIPartyName_st {
   ASN1_STRING *nameAssigner ;
   ASN1_STRING *partyName ;
};
#line 162 "/usr/include/openssl/x509v3.h"
typedef struct EDIPartyName_st EDIPARTYNAME;
#line 175 "/usr/include/openssl/x509v3.h"
union __anonunion_536 {
   char *ptr ;
   OTHERNAME *otherName ;
   ASN1_IA5STRING *rfc822Name ;
   ASN1_IA5STRING *dNSName ;
   ASN1_STRING *x400Address ;
   X509_NAME *directoryName ;
   EDIPARTYNAME *ediPartyName ;
   ASN1_IA5STRING *uniformResourceIdentifier ;
   ASN1_OCTET_STRING *iPAddress ;
   ASN1_OBJECT *registeredID ;
   ASN1_OCTET_STRING *ip ;
   X509_NAME *dirn ;
   ASN1_IA5STRING *ia5 ;
   ASN1_OBJECT *rid ;
   ASN1_TYPE *other ;
};
#line 164 "/usr/include/openssl/x509v3.h"
struct GENERAL_NAME_st {
   int type ;
   union __anonunion_536 d ;
};
#line 194 "/usr/include/openssl/x509v3.h"
typedef struct GENERAL_NAME_st GENERAL_NAME;
#line 196 "/usr/include/openssl/x509v3.h"
struct ACCESS_DESCRIPTION_st {
   ASN1_OBJECT *method ;
   GENERAL_NAME *location ;
};
#line 199 "/usr/include/openssl/x509v3.h"
typedef struct ACCESS_DESCRIPTION_st ACCESS_DESCRIPTION;
#line 201
struct stack_st_ACCESS_DESCRIPTION ;
#line 201 "/usr/include/openssl/x509v3.h"
typedef int (*sk_ACCESS_DESCRIPTION_compfunc)(ACCESS_DESCRIPTION * const  * , ACCESS_DESCRIPTION * const  * );
#line 201 "/usr/include/openssl/x509v3.h"
typedef void (*sk_ACCESS_DESCRIPTION_freefunc)(ACCESS_DESCRIPTION * );
#line 201 "/usr/include/openssl/x509v3.h"
typedef ACCESS_DESCRIPTION *(*sk_ACCESS_DESCRIPTION_copyfunc)(ACCESS_DESCRIPTION * );
#line 227
struct stack_st_GENERAL_NAME ;
#line 227 "/usr/include/openssl/x509v3.h"
typedef int (*sk_GENERAL_NAME_compfunc)(GENERAL_NAME * const  * , GENERAL_NAME * const  * );
#line 227 "/usr/include/openssl/x509v3.h"
typedef void (*sk_GENERAL_NAME_freefunc)(GENERAL_NAME * );
#line 227 "/usr/include/openssl/x509v3.h"
typedef GENERAL_NAME *(*sk_GENERAL_NAME_copyfunc)(GENERAL_NAME * );
#line 255 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_ACCESS_DESCRIPTION AUTHORITY_INFO_ACCESS;
#line 256 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_ASN1_OBJECT EXTENDED_KEY_USAGE;
#line 257 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_ASN1_INTEGER TLS_FEATURE;
#line 258 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_GENERAL_NAME GENERAL_NAMES;
#line 260
struct stack_st_GENERAL_NAMES ;
#line 260 "/usr/include/openssl/x509v3.h"
typedef int (*sk_GENERAL_NAMES_compfunc)(GENERAL_NAMES * const  * , GENERAL_NAMES * const  * );
#line 260 "/usr/include/openssl/x509v3.h"
typedef void (*sk_GENERAL_NAMES_freefunc)(GENERAL_NAMES * );
#line 260 "/usr/include/openssl/x509v3.h"
typedef GENERAL_NAMES *(*sk_GENERAL_NAMES_copyfunc)(GENERAL_NAMES * );
#line 290 "/usr/include/openssl/x509v3.h"
union __anonunion_537 {
   GENERAL_NAMES *fullname ;
   struct stack_st_X509_NAME_ENTRY *relativename ;
};
#line 288 "/usr/include/openssl/x509v3.h"
struct DIST_POINT_NAME_st {
   int type ;
   union __anonunion_537 name ;
   X509_NAME *dpname ;
};
#line 296 "/usr/include/openssl/x509v3.h"
typedef struct DIST_POINT_NAME_st DIST_POINT_NAME;
#line 312 "/usr/include/openssl/x509v3.h"
struct DIST_POINT_st {
   DIST_POINT_NAME *distpoint ;
   ASN1_BIT_STRING *reasons ;
   GENERAL_NAMES *CRLissuer ;
   int dp_reasons ;
};
#line 319
struct stack_st_DIST_POINT ;
#line 319 "/usr/include/openssl/x509v3.h"
typedef int (*sk_DIST_POINT_compfunc)(DIST_POINT * const  * , DIST_POINT * const  * );
#line 319 "/usr/include/openssl/x509v3.h"
typedef void (*sk_DIST_POINT_freefunc)(DIST_POINT * );
#line 319 "/usr/include/openssl/x509v3.h"
typedef DIST_POINT *(*sk_DIST_POINT_copyfunc)(DIST_POINT * );
#line 347 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_DIST_POINT CRL_DIST_POINTS;
#line 349 "/usr/include/openssl/x509v3.h"
struct AUTHORITY_KEYID_st {
   ASN1_OCTET_STRING *keyid ;
   GENERAL_NAMES *issuer ;
   ASN1_INTEGER *serial ;
};
#line 357 "/usr/include/openssl/x509v3.h"
struct SXNET_ID_st {
   ASN1_INTEGER *zone ;
   ASN1_OCTET_STRING *user ;
};
#line 360 "/usr/include/openssl/x509v3.h"
typedef struct SXNET_ID_st SXNETID;
#line 362
struct stack_st_SXNETID ;
#line 362 "/usr/include/openssl/x509v3.h"
typedef int (*sk_SXNETID_compfunc)(SXNETID * const  * , SXNETID * const  * );
#line 362 "/usr/include/openssl/x509v3.h"
typedef void (*sk_SXNETID_freefunc)(SXNETID * );
#line 362 "/usr/include/openssl/x509v3.h"
typedef SXNETID *(*sk_SXNETID_copyfunc)(SXNETID * );
#line 391 "/usr/include/openssl/x509v3.h"
struct SXNET_st {
   ASN1_INTEGER *version ;
   struct stack_st_SXNETID *ids ;
};
#line 394 "/usr/include/openssl/x509v3.h"
typedef struct SXNET_st SXNET;
#line 396 "/usr/include/openssl/x509v3.h"
struct ISSUER_SIGN_TOOL_st {
   ASN1_UTF8STRING *signTool ;
   ASN1_UTF8STRING *cATool ;
   ASN1_UTF8STRING *signToolCert ;
   ASN1_UTF8STRING *cAToolCert ;
};
#line 401 "/usr/include/openssl/x509v3.h"
typedef struct ISSUER_SIGN_TOOL_st ISSUER_SIGN_TOOL;
#line 403 "/usr/include/openssl/x509v3.h"
struct NOTICEREF_st {
   ASN1_STRING *organization ;
   struct stack_st_ASN1_INTEGER *noticenos ;
};
#line 406 "/usr/include/openssl/x509v3.h"
typedef struct NOTICEREF_st NOTICEREF;
#line 408 "/usr/include/openssl/x509v3.h"
struct USERNOTICE_st {
   NOTICEREF *noticeref ;
   ASN1_STRING *exptext ;
};
#line 411 "/usr/include/openssl/x509v3.h"
typedef struct USERNOTICE_st USERNOTICE;
#line 415 "/usr/include/openssl/x509v3.h"
union __anonunion_538 {
   ASN1_IA5STRING *cpsuri ;
   USERNOTICE *usernotice ;
   ASN1_TYPE *other ;
};
#line 413 "/usr/include/openssl/x509v3.h"
struct POLICYQUALINFO_st {
   ASN1_OBJECT *pqualid ;
   union __anonunion_538 d ;
};
#line 420 "/usr/include/openssl/x509v3.h"
typedef struct POLICYQUALINFO_st POLICYQUALINFO;
#line 422 "/usr/include/openssl/x509v3.h"
typedef int (*sk_POLICYQUALINFO_compfunc)(POLICYQUALINFO * const  * , POLICYQUALINFO * const  * );
#line 422 "/usr/include/openssl/x509v3.h"
typedef void (*sk_POLICYQUALINFO_freefunc)(POLICYQUALINFO * );
#line 422 "/usr/include/openssl/x509v3.h"
typedef POLICYQUALINFO *(*sk_POLICYQUALINFO_copyfunc)(POLICYQUALINFO * );
#line 451 "/usr/include/openssl/x509v3.h"
struct POLICYINFO_st {
   ASN1_OBJECT *policyid ;
   struct stack_st_POLICYQUALINFO *qualifiers ;
};
#line 454 "/usr/include/openssl/x509v3.h"
typedef struct POLICYINFO_st POLICYINFO;
#line 456
struct stack_st_POLICYINFO ;
#line 456 "/usr/include/openssl/x509v3.h"
typedef int (*sk_POLICYINFO_compfunc)(POLICYINFO * const  * , POLICYINFO * const  * );
#line 456 "/usr/include/openssl/x509v3.h"
typedef void (*sk_POLICYINFO_freefunc)(POLICYINFO * );
#line 456 "/usr/include/openssl/x509v3.h"
typedef POLICYINFO *(*sk_POLICYINFO_copyfunc)(POLICYINFO * );
#line 484 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_POLICYINFO CERTIFICATEPOLICIES;
#line 486 "/usr/include/openssl/x509v3.h"
struct POLICY_MAPPING_st {
   ASN1_OBJECT *issuerDomainPolicy ;
   ASN1_OBJECT *subjectDomainPolicy ;
};
#line 489 "/usr/include/openssl/x509v3.h"
typedef struct POLICY_MAPPING_st POLICY_MAPPING;
#line 491
struct stack_st_POLICY_MAPPING ;
#line 491 "/usr/include/openssl/x509v3.h"
typedef int (*sk_POLICY_MAPPING_compfunc)(POLICY_MAPPING * const  * , POLICY_MAPPING * const  * );
#line 491 "/usr/include/openssl/x509v3.h"
typedef void (*sk_POLICY_MAPPING_freefunc)(POLICY_MAPPING * );
#line 491 "/usr/include/openssl/x509v3.h"
typedef POLICY_MAPPING *(*sk_POLICY_MAPPING_copyfunc)(POLICY_MAPPING * );
#line 519 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_POLICY_MAPPING POLICY_MAPPINGS;
#line 521 "/usr/include/openssl/x509v3.h"
struct GENERAL_SUBTREE_st {
   GENERAL_NAME *base ;
   ASN1_INTEGER *minimum ;
   ASN1_INTEGER *maximum ;
};
#line 525 "/usr/include/openssl/x509v3.h"
typedef struct GENERAL_SUBTREE_st GENERAL_SUBTREE;
#line 527
struct stack_st_GENERAL_SUBTREE ;
#line 527 "/usr/include/openssl/x509v3.h"
typedef int (*sk_GENERAL_SUBTREE_compfunc)(GENERAL_SUBTREE * const  * , GENERAL_SUBTREE * const  * );
#line 527 "/usr/include/openssl/x509v3.h"
typedef void (*sk_GENERAL_SUBTREE_freefunc)(GENERAL_SUBTREE * );
#line 527 "/usr/include/openssl/x509v3.h"
typedef GENERAL_SUBTREE *(*sk_GENERAL_SUBTREE_copyfunc)(GENERAL_SUBTREE * );
#line 555 "/usr/include/openssl/x509v3.h"
struct NAME_CONSTRAINTS_st {
   struct stack_st_GENERAL_SUBTREE *permittedSubtrees ;
   struct stack_st_GENERAL_SUBTREE *excludedSubtrees ;
};
#line 560 "/usr/include/openssl/x509v3.h"
struct POLICY_CONSTRAINTS_st {
   ASN1_INTEGER *requireExplicitPolicy ;
   ASN1_INTEGER *inhibitPolicyMapping ;
};
#line 563 "/usr/include/openssl/x509v3.h"
typedef struct POLICY_CONSTRAINTS_st POLICY_CONSTRAINTS;
#line 566 "/usr/include/openssl/x509v3.h"
struct PROXY_POLICY_st {
   ASN1_OBJECT *policyLanguage ;
   ASN1_OCTET_STRING *policy ;
};
#line 569 "/usr/include/openssl/x509v3.h"
typedef struct PROXY_POLICY_st PROXY_POLICY;
#line 571 "/usr/include/openssl/x509v3.h"
struct PROXY_CERT_INFO_EXTENSION_st {
   ASN1_INTEGER *pcPathLengthConstraint ;
   PROXY_POLICY *proxyPolicy ;
};
#line 574 "/usr/include/openssl/x509v3.h"
typedef struct PROXY_CERT_INFO_EXTENSION_st PROXY_CERT_INFO_EXTENSION;
#line 579 "/usr/include/openssl/x509v3.h"
struct ISSUING_DIST_POINT_st {
   DIST_POINT_NAME *distpoint ;
   int onlyuser ;
   int onlyCA ;
   ASN1_BIT_STRING *onlysomereasons ;
   int indirectCRL ;
   int onlyattr ;
};
#line 694 "/usr/include/openssl/x509v3.h"
struct x509_purpose_st {
   int purpose ;
   int trust ;
   int flags ;
   int (*check_purpose)(struct x509_purpose_st * , X509 * , int  ) ;
   char *name ;
   char *sname ;
   void *usr_data ;
};
#line 702 "/usr/include/openssl/x509v3.h"
typedef struct x509_purpose_st X509_PURPOSE;
#line 704
struct stack_st_X509_PURPOSE ;
#line 704 "/usr/include/openssl/x509v3.h"
typedef int (*sk_X509_PURPOSE_compfunc)(X509_PURPOSE * const  * , X509_PURPOSE * const  * );
#line 704 "/usr/include/openssl/x509v3.h"
typedef void (*sk_X509_PURPOSE_freefunc)(X509_PURPOSE * );
#line 704 "/usr/include/openssl/x509v3.h"
typedef X509_PURPOSE *(*sk_X509_PURPOSE_copyfunc)(X509_PURPOSE * );
#line 1048 "/usr/include/openssl/x509v3.h"
typedef int (*sk_X509_POLICY_NODE_compfunc)(X509_POLICY_NODE * const  * , X509_POLICY_NODE * const  * );
#line 1048 "/usr/include/openssl/x509v3.h"
typedef void (*sk_X509_POLICY_NODE_freefunc)(X509_POLICY_NODE * );
#line 1048 "/usr/include/openssl/x509v3.h"
typedef X509_POLICY_NODE *(*sk_X509_POLICY_NODE_copyfunc)(X509_POLICY_NODE * );
#line 1078 "/usr/include/openssl/x509v3.h"
struct ASRange_st {
   ASN1_INTEGER *min ;
   ASN1_INTEGER *max ;
};
#line 1080 "/usr/include/openssl/x509v3.h"
typedef struct ASRange_st ASRange;
#line 1087 "/usr/include/openssl/x509v3.h"
union __anonunion_539 {
   ASN1_INTEGER *id ;
   ASRange *range ;
};
#line 1085 "/usr/include/openssl/x509v3.h"
struct ASIdOrRange_st {
   int type ;
   union __anonunion_539 u ;
};
#line 1091 "/usr/include/openssl/x509v3.h"
typedef struct ASIdOrRange_st ASIdOrRange;
#line 1093
struct stack_st_ASIdOrRange ;
#line 1093 "/usr/include/openssl/x509v3.h"
typedef int (*sk_ASIdOrRange_compfunc)(ASIdOrRange * const  * , ASIdOrRange * const  * );
#line 1093 "/usr/include/openssl/x509v3.h"
typedef void (*sk_ASIdOrRange_freefunc)(ASIdOrRange * );
#line 1093 "/usr/include/openssl/x509v3.h"
typedef ASIdOrRange *(*sk_ASIdOrRange_copyfunc)(ASIdOrRange * );
#line 1121 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_ASIdOrRange ASIdOrRanges;
#line 1128 "/usr/include/openssl/x509v3.h"
union __anonunion_540 {
   ASN1_NULL *inherit ;
   ASIdOrRanges *asIdsOrRanges ;
};
#line 1126 "/usr/include/openssl/x509v3.h"
struct ASIdentifierChoice_st {
   int type ;
   union __anonunion_540 u ;
};
#line 1132 "/usr/include/openssl/x509v3.h"
typedef struct ASIdentifierChoice_st ASIdentifierChoice;
#line 1134 "/usr/include/openssl/x509v3.h"
struct ASIdentifiers_st {
   ASIdentifierChoice *asnum ;
   ASIdentifierChoice *rdi ;
};
#line 1136 "/usr/include/openssl/x509v3.h"
typedef struct ASIdentifiers_st ASIdentifiers;
#line 1143 "/usr/include/openssl/x509v3.h"
struct IPAddressRange_st {
   ASN1_BIT_STRING *min ;
   ASN1_BIT_STRING *max ;
};
#line 1145 "/usr/include/openssl/x509v3.h"
typedef struct IPAddressRange_st IPAddressRange;
#line 1152 "/usr/include/openssl/x509v3.h"
union __anonunion_541 {
   ASN1_BIT_STRING *addressPrefix ;
   IPAddressRange *addressRange ;
};
#line 1150 "/usr/include/openssl/x509v3.h"
struct IPAddressOrRange_st {
   int type ;
   union __anonunion_541 u ;
};
#line 1156 "/usr/include/openssl/x509v3.h"
typedef struct IPAddressOrRange_st IPAddressOrRange;
#line 1158
struct stack_st_IPAddressOrRange ;
#line 1158 "/usr/include/openssl/x509v3.h"
typedef int (*sk_IPAddressOrRange_compfunc)(IPAddressOrRange * const  * , IPAddressOrRange * const  * );
#line 1158 "/usr/include/openssl/x509v3.h"
typedef void (*sk_IPAddressOrRange_freefunc)(IPAddressOrRange * );
#line 1158 "/usr/include/openssl/x509v3.h"
typedef IPAddressOrRange *(*sk_IPAddressOrRange_copyfunc)(IPAddressOrRange * );
#line 1186 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_IPAddressOrRange IPAddressOrRanges;
#line 1193 "/usr/include/openssl/x509v3.h"
union __anonunion_542 {
   ASN1_NULL *inherit ;
   IPAddressOrRanges *addressesOrRanges ;
};
#line 1191 "/usr/include/openssl/x509v3.h"
struct IPAddressChoice_st {
   int type ;
   union __anonunion_542 u ;
};
#line 1197 "/usr/include/openssl/x509v3.h"
typedef struct IPAddressChoice_st IPAddressChoice;
#line 1199 "/usr/include/openssl/x509v3.h"
struct IPAddressFamily_st {
   ASN1_OCTET_STRING *addressFamily ;
   IPAddressChoice *ipAddressChoice ;
};
#line 1202 "/usr/include/openssl/x509v3.h"
typedef struct IPAddressFamily_st IPAddressFamily;
#line 1204
struct stack_st_IPAddressFamily ;
#line 1204 "/usr/include/openssl/x509v3.h"
typedef int (*sk_IPAddressFamily_compfunc)(IPAddressFamily * const  * , IPAddressFamily * const  * );
#line 1204 "/usr/include/openssl/x509v3.h"
typedef void (*sk_IPAddressFamily_freefunc)(IPAddressFamily * );
#line 1204 "/usr/include/openssl/x509v3.h"
typedef IPAddressFamily *(*sk_IPAddressFamily_copyfunc)(IPAddressFamily * );
#line 1233 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_IPAddressFamily IPAddrBlocks;
#line 1305
struct stack_st_ASN1_STRING ;
#line 1305 "/usr/include/openssl/x509v3.h"
typedef int (*sk_ASN1_STRING_compfunc)(ASN1_STRING * const  * , ASN1_STRING * const  * );
#line 1305 "/usr/include/openssl/x509v3.h"
typedef void (*sk_ASN1_STRING_freefunc)(ASN1_STRING * );
#line 1305 "/usr/include/openssl/x509v3.h"
typedef ASN1_STRING *(*sk_ASN1_STRING_copyfunc)(ASN1_STRING * );
#line 1336
struct NamingAuthority_st ;
#line 1336 "/usr/include/openssl/x509v3.h"
typedef struct NamingAuthority_st NAMING_AUTHORITY;
#line 1337
struct ProfessionInfo_st ;
#line 1337 "/usr/include/openssl/x509v3.h"
typedef struct ProfessionInfo_st PROFESSION_INFO;
#line 1338
struct Admissions_st ;
#line 1338 "/usr/include/openssl/x509v3.h"
typedef struct Admissions_st ADMISSIONS;
#line 1339
struct AdmissionSyntax_st ;
#line 1339 "/usr/include/openssl/x509v3.h"
typedef struct AdmissionSyntax_st ADMISSION_SYNTAX;
#line 1344
struct stack_st_PROFESSION_INFO ;
#line 1344 "/usr/include/openssl/x509v3.h"
typedef int (*sk_PROFESSION_INFO_compfunc)(PROFESSION_INFO * const  * , PROFESSION_INFO * const  * );
#line 1344 "/usr/include/openssl/x509v3.h"
typedef void (*sk_PROFESSION_INFO_freefunc)(PROFESSION_INFO * );
#line 1344 "/usr/include/openssl/x509v3.h"
typedef PROFESSION_INFO *(*sk_PROFESSION_INFO_copyfunc)(PROFESSION_INFO * );
#line 1370
struct stack_st_ADMISSIONS ;
#line 1370 "/usr/include/openssl/x509v3.h"
typedef int (*sk_ADMISSIONS_compfunc)(ADMISSIONS * const  * , ADMISSIONS * const  * );
#line 1370 "/usr/include/openssl/x509v3.h"
typedef void (*sk_ADMISSIONS_freefunc)(ADMISSIONS * );
#line 1370 "/usr/include/openssl/x509v3.h"
typedef ADMISSIONS *(*sk_ADMISSIONS_copyfunc)(ADMISSIONS * );
#line 1397 "/usr/include/openssl/x509v3.h"
typedef struct stack_st_PROFESSION_INFO PROFESSION_INFOS;
#line 89 "/usr/include/openssl/ocsp.h"
struct ocsp_cert_id_st ;
#line 89 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_cert_id_st OCSP_CERTID;
#line 90
struct ocsp_one_request_st ;
#line 90 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_one_request_st OCSP_ONEREQ;
#line 91
struct ocsp_req_info_st ;
#line 91 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_req_info_st OCSP_REQINFO;
#line 92
struct ocsp_signature_st ;
#line 92 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_signature_st OCSP_SIGNATURE;
#line 93
struct ocsp_request_st ;
#line 93 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_request_st OCSP_REQUEST;
#line 95
struct stack_st_OCSP_CERTID ;
#line 95 "/usr/include/openssl/ocsp.h"
typedef int (*sk_OCSP_CERTID_compfunc)(OCSP_CERTID * const  * , OCSP_CERTID * const  * );
#line 95 "/usr/include/openssl/ocsp.h"
typedef void (*sk_OCSP_CERTID_freefunc)(OCSP_CERTID * );
#line 95 "/usr/include/openssl/ocsp.h"
typedef OCSP_CERTID *(*sk_OCSP_CERTID_copyfunc)(OCSP_CERTID * );
#line 121
struct stack_st_OCSP_ONEREQ ;
#line 121 "/usr/include/openssl/ocsp.h"
typedef int (*sk_OCSP_ONEREQ_compfunc)(OCSP_ONEREQ * const  * , OCSP_ONEREQ * const  * );
#line 121 "/usr/include/openssl/ocsp.h"
typedef void (*sk_OCSP_ONEREQ_freefunc)(OCSP_ONEREQ * );
#line 121 "/usr/include/openssl/ocsp.h"
typedef OCSP_ONEREQ *(*sk_OCSP_ONEREQ_copyfunc)(OCSP_ONEREQ * );
#line 156
struct ocsp_resp_bytes_st ;
#line 156 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_resp_bytes_st OCSP_RESPBYTES;
#line 161
struct stack_st_OCSP_RESPID ;
#line 161 "/usr/include/openssl/ocsp.h"
typedef int (*sk_OCSP_RESPID_compfunc)(OCSP_RESPID * const  * , OCSP_RESPID * const  * );
#line 161 "/usr/include/openssl/ocsp.h"
typedef void (*sk_OCSP_RESPID_freefunc)(OCSP_RESPID * );
#line 161 "/usr/include/openssl/ocsp.h"
typedef OCSP_RESPID *(*sk_OCSP_RESPID_copyfunc)(OCSP_RESPID * );
#line 189
struct ocsp_revoked_info_st ;
#line 189 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_revoked_info_st OCSP_REVOKEDINFO;
#line 195
struct ocsp_cert_status_st ;
#line 195 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_cert_status_st OCSP_CERTSTATUS;
#line 196
struct ocsp_single_response_st ;
#line 196 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_single_response_st OCSP_SINGLERESP;
#line 198
struct stack_st_OCSP_SINGLERESP ;
#line 198 "/usr/include/openssl/ocsp.h"
typedef int (*sk_OCSP_SINGLERESP_compfunc)(OCSP_SINGLERESP * const  * , OCSP_SINGLERESP * const  * );
#line 198 "/usr/include/openssl/ocsp.h"
typedef void (*sk_OCSP_SINGLERESP_freefunc)(OCSP_SINGLERESP * );
#line 198 "/usr/include/openssl/ocsp.h"
typedef OCSP_SINGLERESP *(*sk_OCSP_SINGLERESP_copyfunc)(OCSP_SINGLERESP * );
#line 226
struct ocsp_response_data_st ;
#line 226 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_response_data_st OCSP_RESPDATA;
#line 228
struct ocsp_basic_response_st ;
#line 228 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_basic_response_st OCSP_BASICRESP;
#line 230
struct ocsp_crl_id_st ;
#line 230 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_crl_id_st OCSP_CRLID;
#line 231
struct ocsp_service_locator_st ;
#line 231 "/usr/include/openssl/ocsp.h"
typedef struct ocsp_service_locator_st OCSP_SERVICELOC;
#line 274 "/usr/include/openssl/ocsp.h"
typedef OSSL_HTTP_REQ_CTX OCSP_REQ_CTX;
#line 38 "/usr/include/openssl/async.h"
struct async_job_st ;
#line 38 "/usr/include/openssl/async.h"
typedef struct async_job_st ASYNC_JOB;
#line 39
struct async_wait_ctx_st ;
#line 39 "/usr/include/openssl/async.h"
typedef struct async_wait_ctx_st ASYNC_WAIT_CTX;
#line 40 "/usr/include/openssl/async.h"
typedef int (*ASYNC_callback_fn)(void * );
#line 42 "/usr/include/openssl/ct.h"
struct stack_st_SCT ;
#line 42 "/usr/include/openssl/ct.h"
typedef int (*sk_SCT_compfunc)(SCT * const  * , SCT * const  * );
#line 42 "/usr/include/openssl/ct.h"
typedef void (*sk_SCT_freefunc)(SCT * );
#line 42 "/usr/include/openssl/ct.h"
typedef SCT *(*sk_SCT_copyfunc)(SCT * );
#line 68
struct stack_st_CTLOG ;
#line 68 "/usr/include/openssl/ct.h"
typedef int (*sk_CTLOG_compfunc)(CTLOG * const  * , CTLOG * const  * );
#line 68 "/usr/include/openssl/ct.h"
typedef void (*sk_CTLOG_freefunc)(CTLOG * );
#line 68 "/usr/include/openssl/ct.h"
typedef CTLOG *(*sk_CTLOG_copyfunc)(CTLOG * );
#line 97
enum __anonenum__543 {
    CT_LOG_ENTRY_TYPE_NOT_SET = -1,
    CT_LOG_ENTRY_TYPE_X509 = 0,
    CT_LOG_ENTRY_TYPE_PRECERT = 1
} ;
#line 101 "/usr/include/openssl/ct.h"
typedef enum __anonenum__543 ct_log_entry_type_t;
#line 103
enum __anonenum__544 {
    SCT_VERSION_NOT_SET = -1,
    SCT_VERSION_V1 = 0
} ;
#line 106 "/usr/include/openssl/ct.h"
typedef enum __anonenum__544 sct_version_t;
#line 108
enum __anonenum__545 {
    SCT_SOURCE_UNKNOWN = 0,
    SCT_SOURCE_TLS_EXTENSION = 1,
    SCT_SOURCE_X509V3_EXTENSION = 2,
    SCT_SOURCE_OCSP_STAPLED_RESPONSE = 3
} ;
#line 113 "/usr/include/openssl/ct.h"
typedef enum __anonenum__545 sct_source_t;
#line 115
enum __anonenum__546 {
    SCT_VALIDATION_STATUS_NOT_SET = 0,
    SCT_VALIDATION_STATUS_UNKNOWN_LOG = 1,
    SCT_VALIDATION_STATUS_VALID = 2,
    SCT_VALIDATION_STATUS_INVALID = 3,
    SCT_VALIDATION_STATUS_UNVERIFIED = 4,
    SCT_VALIDATION_STATUS_UNKNOWN_VERSION = 5
} ;
#line 122 "/usr/include/openssl/ct.h"
typedef enum __anonenum__546 sct_validation_status_t;
#line 227 "/usr/include/openssl/ssl.h"
typedef struct ssl_st *ssl_crock_st;
#line 228
struct tls_session_ticket_ext_st ;
#line 228 "/usr/include/openssl/ssl.h"
typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
#line 229
struct ssl_method_st ;
#line 229 "/usr/include/openssl/ssl.h"
typedef struct ssl_method_st SSL_METHOD;
#line 230
struct ssl_cipher_st ;
#line 230 "/usr/include/openssl/ssl.h"
typedef struct ssl_cipher_st SSL_CIPHER;
#line 231
struct ssl_session_st ;
#line 231 "/usr/include/openssl/ssl.h"
typedef struct ssl_session_st SSL_SESSION;
#line 232
struct tls_sigalgs_st ;
#line 232 "/usr/include/openssl/ssl.h"
typedef struct tls_sigalgs_st TLS_SIGALGS;
#line 233
struct ssl_conf_ctx_st ;
#line 233 "/usr/include/openssl/ssl.h"
typedef struct ssl_conf_ctx_st SSL_CONF_CTX;
#line 234
struct ssl_comp_st ;
#line 234 "/usr/include/openssl/ssl.h"
typedef struct ssl_comp_st SSL_COMP;
#line 236
struct stack_st_SSL_CIPHER ;
#line 237
struct stack_st_SSL_COMP ;
#line 240 "/usr/include/openssl/ssl.h"
struct srtp_protection_profile_st {
   char const   *name ;
   unsigned long id ;
};
#line 243 "/usr/include/openssl/ssl.h"
typedef struct srtp_protection_profile_st SRTP_PROTECTION_PROFILE;
#line 244
struct stack_st_SRTP_PROTECTION_PROFILE ;
#line 244 "/usr/include/openssl/ssl.h"
typedef int (*sk_SRTP_PROTECTION_PROFILE_compfunc)(SRTP_PROTECTION_PROFILE * const  * ,
                                                   SRTP_PROTECTION_PROFILE * const  * );
#line 244 "/usr/include/openssl/ssl.h"
typedef void (*sk_SRTP_PROTECTION_PROFILE_freefunc)(SRTP_PROTECTION_PROFILE * );
#line 244 "/usr/include/openssl/ssl.h"
typedef SRTP_PROTECTION_PROFILE *(*sk_SRTP_PROTECTION_PROFILE_copyfunc)(SRTP_PROTECTION_PROFILE * );
#line 273 "/usr/include/openssl/ssl.h"
typedef int (*tls_session_ticket_ext_cb_fn)(SSL * , unsigned char const   * , int  ,
                                            void * );
#line 275 "/usr/include/openssl/ssl.h"
typedef int (*tls_session_secret_cb_fn)(SSL * , void * , int * , struct stack_st_SSL_CIPHER * ,
                                        SSL_CIPHER ** , void * );
#line 306 "/usr/include/openssl/ssl.h"
typedef int (*custom_ext_add_cb)(SSL * , unsigned int  , unsigned char const   ** ,
                                 size_t * , int * , void * );
#line 310 "/usr/include/openssl/ssl.h"
typedef void (*custom_ext_free_cb)(SSL * , unsigned int  , unsigned char const   * ,
                                   void * );
#line 313 "/usr/include/openssl/ssl.h"
typedef int (*custom_ext_parse_cb)(SSL * , unsigned int  , unsigned char const   * ,
                                   size_t  , int * , void * );
#line 318 "/usr/include/openssl/ssl.h"
typedef int (*SSL_custom_ext_add_cb_ex)(SSL * , unsigned int  , unsigned int  , unsigned char const   ** ,
                                        size_t * , X509 * , size_t  , int * , void * );
#line 325 "/usr/include/openssl/ssl.h"
typedef void (*SSL_custom_ext_free_cb_ex)(SSL * , unsigned int  , unsigned int  ,
                                          unsigned char const   * , void * );
#line 330 "/usr/include/openssl/ssl.h"
typedef int (*SSL_custom_ext_parse_cb_ex)(SSL * , unsigned int  , unsigned int  ,
                                          unsigned char const   * , size_t  , X509 * ,
                                          size_t  , int * , void * );
#line 338 "/usr/include/openssl/ssl.h"
typedef int (*SSL_verify_cb)(int  , X509_STORE_CTX * );
#line 341 "/usr/include/openssl/ssl.h"
typedef int (*SSL_async_callback_fn)(SSL * , void * );
#line 683 "/usr/include/openssl/ssl.h"
typedef int (*GEN_SESSION_CB)(SSL * , unsigned char * , unsigned int * );
#line 698
struct lhash_st_SSL_SESSION ;
#line 781 "/usr/include/openssl/ssl.h"
typedef int (*SSL_CTX_npn_advertised_cb_func)(SSL * , unsigned char const   ** , unsigned int * ,
                                              void * );
#line 790 "/usr/include/openssl/ssl.h"
typedef int (*SSL_CTX_npn_select_cb_func)(SSL * , unsigned char ** , unsigned char * ,
                                          unsigned char const   * , unsigned int  ,
                                          void * );
#line 819 "/usr/include/openssl/ssl.h"
typedef int (*SSL_CTX_alpn_select_cb_func)(SSL * , unsigned char const   ** , unsigned char * ,
                                           unsigned char const   * , unsigned int  ,
                                           void * );
#line 838 "/usr/include/openssl/ssl.h"
typedef unsigned int (*SSL_psk_client_cb_func)(SSL * , char const   * , char * , unsigned int  ,
                                               unsigned char * , unsigned int  );
#line 847 "/usr/include/openssl/ssl.h"
typedef unsigned int (*SSL_psk_server_cb_func)(SSL * , char const   * , unsigned char * ,
                                               unsigned int  );
#line 860 "/usr/include/openssl/ssl.h"
typedef int (*SSL_psk_find_session_cb_func)(SSL * , unsigned char const   * , size_t  ,
                                            SSL_SESSION ** );
#line 864 "/usr/include/openssl/ssl.h"
typedef int (*SSL_psk_use_session_cb_func)(SSL * , EVP_MD * , unsigned char const   ** ,
                                           size_t * , SSL_SESSION ** );
#line 935 "/usr/include/openssl/ssl.h"
typedef void (*SSL_CTX_keylog_cb_func)(SSL * , char const   * );
#line 1215 "/usr/include/openssl/tls1.h"
struct tls_session_ticket_ext_st {
   unsigned short length ;
   void *data ;
};
#line 977 "/usr/include/openssl/ssl.h"
typedef int (*sk_SSL_CIPHER_compfunc)(SSL_CIPHER * const  * , SSL_CIPHER * const  * );
#line 977 "/usr/include/openssl/ssl.h"
typedef void (*sk_SSL_CIPHER_freefunc)(SSL_CIPHER * );
#line 977 "/usr/include/openssl/ssl.h"
typedef SSL_CIPHER *(*sk_SSL_CIPHER_copyfunc)(SSL_CIPHER * );
#line 1003 "/usr/include/openssl/ssl.h"
typedef int (*sk_SSL_COMP_compfunc)(SSL_COMP * const  * , SSL_COMP * const  * );
#line 1003 "/usr/include/openssl/ssl.h"
typedef void (*sk_SSL_COMP_freefunc)(SSL_COMP * );
#line 1003 "/usr/include/openssl/ssl.h"
typedef SSL_COMP *(*sk_SSL_COMP_copyfunc)(SSL_COMP * );
#line 1063
enum __anonenum__547 {
    TLS_ST_BEFORE = 0,
    TLS_ST_OK = 1,
    DTLS_ST_CR_HELLO_VERIFY_REQUEST = 2,
    TLS_ST_CR_SRVR_HELLO = 3,
    TLS_ST_CR_CERT = 4,
    TLS_ST_CR_CERT_STATUS = 5,
    TLS_ST_CR_KEY_EXCH = 6,
    TLS_ST_CR_CERT_REQ = 7,
    TLS_ST_CR_SRVR_DONE = 8,
    TLS_ST_CR_SESSION_TICKET = 9,
    TLS_ST_CR_CHANGE = 10,
    TLS_ST_CR_FINISHED = 11,
    TLS_ST_CW_CLNT_HELLO = 12,
    TLS_ST_CW_CERT = 13,
    TLS_ST_CW_KEY_EXCH = 14,
    TLS_ST_CW_CERT_VRFY = 15,
    TLS_ST_CW_CHANGE = 16,
    TLS_ST_CW_NEXT_PROTO = 17,
    TLS_ST_CW_FINISHED = 18,
    TLS_ST_SW_HELLO_REQ = 19,
    TLS_ST_SR_CLNT_HELLO = 20,
    DTLS_ST_SW_HELLO_VERIFY_REQUEST = 21,
    TLS_ST_SW_SRVR_HELLO = 22,
    TLS_ST_SW_CERT = 23,
    TLS_ST_SW_KEY_EXCH = 24,
    TLS_ST_SW_CERT_REQ = 25,
    TLS_ST_SW_SRVR_DONE = 26,
    TLS_ST_SR_CERT = 27,
    TLS_ST_SR_KEY_EXCH = 28,
    TLS_ST_SR_CERT_VRFY = 29,
    TLS_ST_SR_NEXT_PROTO = 30,
    TLS_ST_SR_CHANGE = 31,
    TLS_ST_SR_FINISHED = 32,
    TLS_ST_SW_SESSION_TICKET = 33,
    TLS_ST_SW_CERT_STATUS = 34,
    TLS_ST_SW_CHANGE = 35,
    TLS_ST_SW_FINISHED = 36,
    TLS_ST_SW_ENCRYPTED_EXTENSIONS = 37,
    TLS_ST_CR_ENCRYPTED_EXTENSIONS = 38,
    TLS_ST_CR_CERT_VRFY = 39,
    TLS_ST_SW_CERT_VRFY = 40,
    TLS_ST_CR_HELLO_REQ = 41,
    TLS_ST_SW_KEY_UPDATE = 42,
    TLS_ST_CW_KEY_UPDATE = 43,
    TLS_ST_SR_KEY_UPDATE = 44,
    TLS_ST_CR_KEY_UPDATE = 45,
    TLS_ST_EARLY_DATA = 46,
    TLS_ST_PENDING_EARLY_DATA_END = 47,
    TLS_ST_CW_END_OF_EARLY_DATA = 48,
    TLS_ST_SR_END_OF_EARLY_DATA = 49
} ;
#line 1114 "/usr/include/openssl/ssl.h"
typedef enum __anonenum__547 OSSL_HANDSHAKE_STATE;
#line 1913 "/usr/include/openssl/ssl.h"
typedef int (*SSL_client_hello_cb_fn)(SSL * , int * , void * );
#line 2329 "/usr/include/openssl/ssl.h"
typedef int (*ssl_ct_validation_cb)(CT_POLICY_EVAL_CTX * , struct stack_st_SCT * ,
                                    void * );
#line 2359
enum __anonenum__548 {
    SSL_CT_VALIDATION_PERMISSIVE = 0,
    SSL_CT_VALIDATION_STRICT = 1
} ;
#line 2515
struct openssl_ssl_test_functions ;
#line 2523 "/usr/include/openssl/ssl.h"
typedef int SSL_TICKET_STATUS;
#line 2542 "/usr/include/openssl/ssl.h"
typedef int SSL_TICKET_RETURN;
#line 2555 "/usr/include/openssl/ssl.h"
typedef int (*SSL_CTX_generate_session_ticket_fn)(SSL * , void * );
#line 2556 "/usr/include/openssl/ssl.h"
typedef SSL_TICKET_RETURN (*SSL_CTX_decrypt_session_ticket_fn)(SSL * , SSL_SESSION * ,
                                                               unsigned char const   * ,
                                                               size_t  , SSL_TICKET_STATUS  ,
                                                               void * );
#line 2568 "/usr/include/openssl/ssl.h"
typedef unsigned int (*DTLS_timer_cb)(SSL * , unsigned int  );
#line 2573 "/usr/include/openssl/ssl.h"
typedef int (*SSL_allow_early_data_cb_fn)(SSL * , void * );
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__560 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__561 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__562 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__563 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__564 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 176
enum __anonenum__565 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__566 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__569 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__574 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 74 "/usr/include/x86_64-linux-gnu/sys/wait.h"
enum __anonenum__575 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/wait.h"
typedef enum __anonenum__575 idtype_t;
#line 140
struct rusage ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h"
enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048
} ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 193 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[118] ;
   unsigned long __ss_align ;
};
#line 202
enum __anonenum__576 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824
} ;
#line 259 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 277 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 334
enum __anonenum__577 {
    SCM_RIGHTS = 1
} ;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct_578 {
   unsigned long fds_bits[16] ;
};
#line 27 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct_578 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct_579 {
   int val[2] ;
};
#line 81 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct_579 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 363 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h"
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__580 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2
} ;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_opts {
   struct in_addr ip_dst ;
   char ip_opts[40] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
#line 158 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__581 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_ETHERNET = 143,
    IPPROTO_RAW = 255,
    IPPROTO_MPTCP = 262,
    IPPROTO_MAX = 263
} ;
#line 103
enum __anonenum__582 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135
} ;
#line 123 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 126
enum __anonenum__583 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000
} ;
#line 221 "/usr/include/netinet/in.h"
union __anonunion_584 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 219 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion_584 __in6_u ;
};
#line 245 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[8] ;
};
#line 260 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 272 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 281 "/usr/include/netinet/in.h"
struct ip_mreq_source {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
   struct in_addr imr_sourceaddr ;
};
#line 296 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 308 "/usr/include/netinet/in.h"
struct group_req {
   uint32_t gr_interface ;
   struct sockaddr_storage gr_group ;
};
#line 317 "/usr/include/netinet/in.h"
struct group_source_req {
   uint32_t gsr_interface ;
   struct sockaddr_storage gsr_group ;
   struct sockaddr_storage gsr_source ;
};
#line 331 "/usr/include/netinet/in.h"
struct ip_msfilter {
   struct in_addr imsf_multiaddr ;
   struct in_addr imsf_interface ;
   uint32_t imsf_fmode ;
   uint32_t imsf_numsrc ;
   struct in_addr imsf_slist[1] ;
};
#line 352 "/usr/include/netinet/in.h"
struct group_filter {
   uint32_t gf_interface ;
   struct sockaddr_storage gf_group ;
   uint32_t gf_fmode ;
   uint32_t gf_numsrc ;
   struct sockaddr_storage gf_slist[1] ;
};
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 98 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 255 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 324 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__585 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 83 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
typedef int SOCKET;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
struct _ccpacket___0 {
   void (*del)(struct _ccpacket___0 * ) ;
   ccpacket_err (*connect)(struct _ccpacket___0 * , char * , int  ) ;
   ccpacket_err (*reconnect)(struct _ccpacket___0 * ) ;
   ccpacket_err (*send)(struct _ccpacket___0 * , uint8_t * , uint32_t  ) ;
   ccpacket_err (*receive)(struct _ccpacket___0 * , uint8_t ** , uint32_t * ) ;
   char *dip ;
   int dport ;
   SOCKET sock ;
   SSL_CTX *ctx ;
   SSL *ssl ;
   pthread_mutex_t lock ;
};
#line 78 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
typedef struct _ccpacket___0 ccpacket___0;
#line 934 "/usr/include/math.h"
enum __anonenum__502___0 {
    FP_NAN___19 = 0,
    FP_INFINITE___19 = 1,
    FP_ZERO___19 = 2,
    FP_SUBNORMAL___19 = 3,
    FP_NORMAL___19 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__503___0 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__505___0 {
    PTHREAD_CREATE_JOINABLE___16 = 0,
    PTHREAD_CREATE_DETACHED___16 = 1
} ;
#line 47
enum __anonenum__506___0 {
    PTHREAD_MUTEX_TIMED_NP___16 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___16 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___16 = 3,
    PTHREAD_MUTEX_NORMAL___16 = 0,
    PTHREAD_MUTEX_RECURSIVE___16 = 1,
    PTHREAD_MUTEX_ERRORCHECK___16 = 2,
    PTHREAD_MUTEX_DEFAULT___16 = 0
} ;
#line 69
enum __anonenum__507___0 {
    PTHREAD_MUTEX_STALLED___16 = 0,
    PTHREAD_MUTEX_STALLED_NP___16 = 0,
    PTHREAD_MUTEX_ROBUST___16 = 1,
    PTHREAD_MUTEX_ROBUST_NP___16 = 1
} ;
#line 81
enum __anonenum__508___0 {
    PTHREAD_PRIO_NONE___16 = 0,
    PTHREAD_PRIO_INHERIT___16 = 1,
    PTHREAD_PRIO_PROTECT___16 = 2
} ;
#line 104
enum __anonenum__509___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___16 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___16 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___16 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___16 = 0
} ;
#line 124
enum __anonenum__510___0 {
    PTHREAD_INHERIT_SCHED___16 = 0,
    PTHREAD_EXPLICIT_SCHED___16 = 1
} ;
#line 134
enum __anonenum__511___0 {
    PTHREAD_SCOPE_SYSTEM___16 = 0,
    PTHREAD_SCOPE_PROCESS___16 = 1
} ;
#line 144
enum __anonenum__512___0 {
    PTHREAD_PROCESS_PRIVATE___16 = 0,
    PTHREAD_PROCESS_SHARED___16 = 1
} ;
#line 168
enum __anonenum__513___0 {
    PTHREAD_CANCEL_ENABLE___16 = 0,
    PTHREAD_CANCEL_DISABLE___16 = 1
} ;
#line 175
enum __anonenum__514___0 {
    PTHREAD_CANCEL_DEFERRED___16 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___16 = 1
} ;
#line 2359 "/usr/include/openssl/ssl.h"
enum __anonenum__609 {
    SSL_CT_VALIDATION_PERMISSIVE___0 = 0,
    SSL_CT_VALIDATION_STRICT___0 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__621 {
    _PC_LINK_MAX___6 = 0,
    _PC_MAX_CANON___6 = 1,
    _PC_MAX_INPUT___6 = 2,
    _PC_NAME_MAX___6 = 3,
    _PC_PATH_MAX___6 = 4,
    _PC_PIPE_BUF___6 = 5,
    _PC_CHOWN_RESTRICTED___6 = 6,
    _PC_NO_TRUNC___6 = 7,
    _PC_VDISABLE___6 = 8,
    _PC_SYNC_IO___6 = 9,
    _PC_ASYNC_IO___6 = 10,
    _PC_PRIO_IO___6 = 11,
    _PC_SOCK_MAXBUF___6 = 12,
    _PC_FILESIZEBITS___6 = 13,
    _PC_REC_INCR_XFER_SIZE___6 = 14,
    _PC_REC_MAX_XFER_SIZE___6 = 15,
    _PC_REC_MIN_XFER_SIZE___6 = 16,
    _PC_REC_XFER_ALIGN___6 = 17,
    _PC_ALLOC_SIZE_MIN___6 = 18,
    _PC_SYMLINK_MAX___6 = 19,
    _PC_2_SYMLINKS___6 = 20
} ;
#line 71
enum __anonenum__622 {
    _SC_ARG_MAX___6 = 0,
    _SC_CHILD_MAX___6 = 1,
    _SC_CLK_TCK___6 = 2,
    _SC_NGROUPS_MAX___6 = 3,
    _SC_OPEN_MAX___6 = 4,
    _SC_STREAM_MAX___6 = 5,
    _SC_TZNAME_MAX___6 = 6,
    _SC_JOB_CONTROL___6 = 7,
    _SC_SAVED_IDS___6 = 8,
    _SC_REALTIME_SIGNALS___6 = 9,
    _SC_PRIORITY_SCHEDULING___6 = 10,
    _SC_TIMERS___6 = 11,
    _SC_ASYNCHRONOUS_IO___6 = 12,
    _SC_PRIORITIZED_IO___6 = 13,
    _SC_SYNCHRONIZED_IO___6 = 14,
    _SC_FSYNC___6 = 15,
    _SC_MAPPED_FILES___6 = 16,
    _SC_MEMLOCK___6 = 17,
    _SC_MEMLOCK_RANGE___6 = 18,
    _SC_MEMORY_PROTECTION___6 = 19,
    _SC_MESSAGE_PASSING___6 = 20,
    _SC_SEMAPHORES___6 = 21,
    _SC_SHARED_MEMORY_OBJECTS___6 = 22,
    _SC_AIO_LISTIO_MAX___6 = 23,
    _SC_AIO_MAX___6 = 24,
    _SC_AIO_PRIO_DELTA_MAX___6 = 25,
    _SC_DELAYTIMER_MAX___6 = 26,
    _SC_MQ_OPEN_MAX___6 = 27,
    _SC_MQ_PRIO_MAX___6 = 28,
    _SC_VERSION___6 = 29,
    _SC_PAGESIZE___6 = 30,
    _SC_RTSIG_MAX___6 = 31,
    _SC_SEM_NSEMS_MAX___6 = 32,
    _SC_SEM_VALUE_MAX___6 = 33,
    _SC_SIGQUEUE_MAX___6 = 34,
    _SC_TIMER_MAX___6 = 35,
    _SC_BC_BASE_MAX___6 = 36,
    _SC_BC_DIM_MAX___6 = 37,
    _SC_BC_SCALE_MAX___6 = 38,
    _SC_BC_STRING_MAX___6 = 39,
    _SC_COLL_WEIGHTS_MAX___6 = 40,
    _SC_EQUIV_CLASS_MAX___6 = 41,
    _SC_EXPR_NEST_MAX___6 = 42,
    _SC_LINE_MAX___6 = 43,
    _SC_RE_DUP_MAX___6 = 44,
    _SC_CHARCLASS_NAME_MAX___6 = 45,
    _SC_2_VERSION___6 = 46,
    _SC_2_C_BIND___6 = 47,
    _SC_2_C_DEV___6 = 48,
    _SC_2_FORT_DEV___6 = 49,
    _SC_2_FORT_RUN___6 = 50,
    _SC_2_SW_DEV___6 = 51,
    _SC_2_LOCALEDEF___6 = 52,
    _SC_PII___6 = 53,
    _SC_PII_XTI___6 = 54,
    _SC_PII_SOCKET___6 = 55,
    _SC_PII_INTERNET___6 = 56,
    _SC_PII_OSI___6 = 57,
    _SC_POLL___6 = 58,
    _SC_SELECT___6 = 59,
    _SC_UIO_MAXIOV___6 = 60,
    _SC_IOV_MAX___6 = 60,
    _SC_PII_INTERNET_STREAM___6 = 61,
    _SC_PII_INTERNET_DGRAM___6 = 62,
    _SC_PII_OSI_COTS___6 = 63,
    _SC_PII_OSI_CLTS___6 = 64,
    _SC_PII_OSI_M___6 = 65,
    _SC_T_IOV_MAX___6 = 66,
    _SC_THREADS___6 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___6 = 68,
    _SC_GETGR_R_SIZE_MAX___6 = 69,
    _SC_GETPW_R_SIZE_MAX___6 = 70,
    _SC_LOGIN_NAME_MAX___6 = 71,
    _SC_TTY_NAME_MAX___6 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___6 = 73,
    _SC_THREAD_KEYS_MAX___6 = 74,
    _SC_THREAD_STACK_MIN___6 = 75,
    _SC_THREAD_THREADS_MAX___6 = 76,
    _SC_THREAD_ATTR_STACKADDR___6 = 77,
    _SC_THREAD_ATTR_STACKSIZE___6 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___6 = 79,
    _SC_THREAD_PRIO_INHERIT___6 = 80,
    _SC_THREAD_PRIO_PROTECT___6 = 81,
    _SC_THREAD_PROCESS_SHARED___6 = 82,
    _SC_NPROCESSORS_CONF___6 = 83,
    _SC_NPROCESSORS_ONLN___6 = 84,
    _SC_PHYS_PAGES___6 = 85,
    _SC_AVPHYS_PAGES___6 = 86,
    _SC_ATEXIT_MAX___6 = 87,
    _SC_PASS_MAX___6 = 88,
    _SC_XOPEN_VERSION___6 = 89,
    _SC_XOPEN_XCU_VERSION___6 = 90,
    _SC_XOPEN_UNIX___6 = 91,
    _SC_XOPEN_CRYPT___6 = 92,
    _SC_XOPEN_ENH_I18N___6 = 93,
    _SC_XOPEN_SHM___6 = 94,
    _SC_2_CHAR_TERM___6 = 95,
    _SC_2_C_VERSION___6 = 96,
    _SC_2_UPE___6 = 97,
    _SC_XOPEN_XPG2___6 = 98,
    _SC_XOPEN_XPG3___6 = 99,
    _SC_XOPEN_XPG4___6 = 100,
    _SC_CHAR_BIT___6 = 101,
    _SC_CHAR_MAX___6 = 102,
    _SC_CHAR_MIN___6 = 103,
    _SC_INT_MAX___6 = 104,
    _SC_INT_MIN___6 = 105,
    _SC_LONG_BIT___6 = 106,
    _SC_WORD_BIT___6 = 107,
    _SC_MB_LEN_MAX___6 = 108,
    _SC_NZERO___6 = 109,
    _SC_SSIZE_MAX___6 = 110,
    _SC_SCHAR_MAX___6 = 111,
    _SC_SCHAR_MIN___6 = 112,
    _SC_SHRT_MAX___6 = 113,
    _SC_SHRT_MIN___6 = 114,
    _SC_UCHAR_MAX___6 = 115,
    _SC_UINT_MAX___6 = 116,
    _SC_ULONG_MAX___6 = 117,
    _SC_USHRT_MAX___6 = 118,
    _SC_NL_ARGMAX___6 = 119,
    _SC_NL_LANGMAX___6 = 120,
    _SC_NL_MSGMAX___6 = 121,
    _SC_NL_NMAX___6 = 122,
    _SC_NL_SETMAX___6 = 123,
    _SC_NL_TEXTMAX___6 = 124,
    _SC_XBS5_ILP32_OFF32___6 = 125,
    _SC_XBS5_ILP32_OFFBIG___6 = 126,
    _SC_XBS5_LP64_OFF64___6 = 127,
    _SC_XBS5_LPBIG_OFFBIG___6 = 128,
    _SC_XOPEN_LEGACY___6 = 129,
    _SC_XOPEN_REALTIME___6 = 130,
    _SC_XOPEN_REALTIME_THREADS___6 = 131,
    _SC_ADVISORY_INFO___6 = 132,
    _SC_BARRIERS___6 = 133,
    _SC_BASE___6 = 134,
    _SC_C_LANG_SUPPORT___6 = 135,
    _SC_C_LANG_SUPPORT_R___6 = 136,
    _SC_CLOCK_SELECTION___6 = 137,
    _SC_CPUTIME___6 = 138,
    _SC_THREAD_CPUTIME___6 = 139,
    _SC_DEVICE_IO___6 = 140,
    _SC_DEVICE_SPECIFIC___6 = 141,
    _SC_DEVICE_SPECIFIC_R___6 = 142,
    _SC_FD_MGMT___6 = 143,
    _SC_FIFO___6 = 144,
    _SC_PIPE___6 = 145,
    _SC_FILE_ATTRIBUTES___6 = 146,
    _SC_FILE_LOCKING___6 = 147,
    _SC_FILE_SYSTEM___6 = 148,
    _SC_MONOTONIC_CLOCK___6 = 149,
    _SC_MULTI_PROCESS___6 = 150,
    _SC_SINGLE_PROCESS___6 = 151,
    _SC_NETWORKING___6 = 152,
    _SC_READER_WRITER_LOCKS___6 = 153,
    _SC_SPIN_LOCKS___6 = 154,
    _SC_REGEXP___6 = 155,
    _SC_REGEX_VERSION___6 = 156,
    _SC_SHELL___6 = 157,
    _SC_SIGNALS___6 = 158,
    _SC_SPAWN___6 = 159,
    _SC_SPORADIC_SERVER___6 = 160,
    _SC_THREAD_SPORADIC_SERVER___6 = 161,
    _SC_SYSTEM_DATABASE___6 = 162,
    _SC_SYSTEM_DATABASE_R___6 = 163,
    _SC_TIMEOUTS___6 = 164,
    _SC_TYPED_MEMORY_OBJECTS___6 = 165,
    _SC_USER_GROUPS___6 = 166,
    _SC_USER_GROUPS_R___6 = 167,
    _SC_2_PBS___6 = 168,
    _SC_2_PBS_ACCOUNTING___6 = 169,
    _SC_2_PBS_LOCATE___6 = 170,
    _SC_2_PBS_MESSAGE___6 = 171,
    _SC_2_PBS_TRACK___6 = 172,
    _SC_SYMLOOP_MAX___6 = 173,
    _SC_STREAMS___6 = 174,
    _SC_2_PBS_CHECKPOINT___6 = 175,
    _SC_V6_ILP32_OFF32___6 = 176,
    _SC_V6_ILP32_OFFBIG___6 = 177,
    _SC_V6_LP64_OFF64___6 = 178,
    _SC_V6_LPBIG_OFFBIG___6 = 179,
    _SC_HOST_NAME_MAX___6 = 180,
    _SC_TRACE___6 = 181,
    _SC_TRACE_EVENT_FILTER___6 = 182,
    _SC_TRACE_INHERIT___6 = 183,
    _SC_TRACE_LOG___6 = 184,
    _SC_LEVEL1_ICACHE_SIZE___6 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___6 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___6 = 187,
    _SC_LEVEL1_DCACHE_SIZE___6 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___6 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___6 = 190,
    _SC_LEVEL2_CACHE_SIZE___6 = 191,
    _SC_LEVEL2_CACHE_ASSOC___6 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___6 = 193,
    _SC_LEVEL3_CACHE_SIZE___6 = 194,
    _SC_LEVEL3_CACHE_ASSOC___6 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___6 = 196,
    _SC_LEVEL4_CACHE_SIZE___6 = 197,
    _SC_LEVEL4_CACHE_ASSOC___6 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___6 = 199,
    _SC_IPV6___6 = 235,
    _SC_RAW_SOCKETS___6 = 236,
    _SC_V7_ILP32_OFF32___6 = 237,
    _SC_V7_ILP32_OFFBIG___6 = 238,
    _SC_V7_LP64_OFF64___6 = 239,
    _SC_V7_LPBIG_OFFBIG___6 = 240,
    _SC_SS_REPL_MAX___6 = 241,
    _SC_TRACE_EVENT_NAME_MAX___6 = 242,
    _SC_TRACE_NAME_MAX___6 = 243,
    _SC_TRACE_SYS_MAX___6 = 244,
    _SC_TRACE_USER_EVENT_MAX___6 = 245,
    _SC_XOPEN_STREAMS___6 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___6 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___6 = 248,
    _SC_MINSIGSTKSZ___6 = 249,
    _SC_SIGSTKSZ___6 = 250
} ;
#line 539
enum __anonenum__623 {
    _CS_PATH___6 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___6 = 1,
    _CS_GNU_LIBC_VERSION___6 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___6 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___6 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___6 = 5,
    _CS_LFS_CFLAGS___6 = 1000,
    _CS_LFS_LDFLAGS___6 = 1001,
    _CS_LFS_LIBS___6 = 1002,
    _CS_LFS_LINTFLAGS___6 = 1003,
    _CS_LFS64_CFLAGS___6 = 1004,
    _CS_LFS64_LDFLAGS___6 = 1005,
    _CS_LFS64_LIBS___6 = 1006,
    _CS_LFS64_LINTFLAGS___6 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___6 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___6 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___6 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___6 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___6 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___6 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___6 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___6 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___6 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___6 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___6 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___6 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___6 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___6 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___6 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___6 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___6 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___6 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___6 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___6 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___6 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___6 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___6 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___6 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___6 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___6 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___6 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___6 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___6 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___6 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___6 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___6 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___6 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___6 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___6 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___6 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___6 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___6 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___6 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___6 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___6 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___6 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___6 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___6 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___6 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___6 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___6 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___6 = 1147,
    _CS_V6_ENV___6 = 1148,
    _CS_V7_ENV___6 = 1149
} ;
#line 18 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__CastMessage ;
#line 18 "ccast/chan/cast_channel.pb-c.h"
typedef struct _Extensions__Api__CastChannel__CastMessage Extensions__Api__CastChannel__CastMessage;
#line 19
struct _Extensions__Api__CastChannel__AuthChallenge ;
#line 19 "ccast/chan/cast_channel.pb-c.h"
typedef struct _Extensions__Api__CastChannel__AuthChallenge Extensions__Api__CastChannel__AuthChallenge;
#line 20
struct _Extensions__Api__CastChannel__AuthResponse ;
#line 20 "ccast/chan/cast_channel.pb-c.h"
typedef struct _Extensions__Api__CastChannel__AuthResponse Extensions__Api__CastChannel__AuthResponse;
#line 21
struct _Extensions__Api__CastChannel__AuthError ;
#line 21 "ccast/chan/cast_channel.pb-c.h"
typedef struct _Extensions__Api__CastChannel__AuthError Extensions__Api__CastChannel__AuthError;
#line 22
struct _Extensions__Api__CastChannel__DeviceAuthMessage ;
#line 22 "ccast/chan/cast_channel.pb-c.h"
typedef struct _Extensions__Api__CastChannel__DeviceAuthMessage Extensions__Api__CastChannel__DeviceAuthMessage;
#line 27
enum _Extensions__Api__CastChannel__CastMessage__ProtocolVersion {
    EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PROTOCOL_VERSION__CASTV2_1_0 = 0,
    _EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PROTOCOL_VERSION_IS_INT_SIZE = 2147483647
} ;
#line 30 "ccast/chan/cast_channel.pb-c.h"
typedef enum _Extensions__Api__CastChannel__CastMessage__ProtocolVersion Extensions__Api__CastChannel__CastMessage__ProtocolVersion;
#line 31
enum _Extensions__Api__CastChannel__CastMessage__PayloadType {
    EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PAYLOAD_TYPE__STRING = 0,
    EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PAYLOAD_TYPE__BINARY = 1,
    _EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PAYLOAD_TYPE_IS_INT_SIZE = 2147483647
} ;
#line 35 "ccast/chan/cast_channel.pb-c.h"
typedef enum _Extensions__Api__CastChannel__CastMessage__PayloadType Extensions__Api__CastChannel__CastMessage__PayloadType;
#line 36
enum _Extensions__Api__CastChannel__AuthError__ErrorType {
    EXTENSIONS__API__CAST_CHANNEL__AUTH_ERROR__ERROR_TYPE__INTERNAL_ERROR = 0,
    EXTENSIONS__API__CAST_CHANNEL__AUTH_ERROR__ERROR_TYPE__NO_TLS = 1,
    _EXTENSIONS__API__CAST_CHANNEL__AUTH_ERROR__ERROR_TYPE_IS_INT_SIZE = 2147483647
} ;
#line 40 "ccast/chan/cast_channel.pb-c.h"
typedef enum _Extensions__Api__CastChannel__AuthError__ErrorType Extensions__Api__CastChannel__AuthError__ErrorType;
#line 44 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__CastMessage {
   ProtobufCMessage base ;
   Extensions__Api__CastChannel__CastMessage__ProtocolVersion protocol_version ;
   char *source_id ;
   char *destination_id ;
   char *namespace_ ;
   Extensions__Api__CastChannel__CastMessage__PayloadType payload_type ;
   char *payload_utf8 ;
   protobuf_c_boolean has_payload_binary ;
   ProtobufCBinaryData payload_binary ;
};
#line 61 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__AuthChallenge {
   ProtobufCMessage base ;
};
#line 70 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__AuthResponse {
   ProtobufCMessage base ;
   ProtobufCBinaryData signature ;
   ProtobufCBinaryData client_auth_certificate ;
};
#line 81 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__AuthError {
   ProtobufCMessage base ;
   Extensions__Api__CastChannel__AuthError__ErrorType error_type ;
};
#line 91 "ccast/chan/cast_channel.pb-c.h"
struct _Extensions__Api__CastChannel__DeviceAuthMessage {
   ProtobufCMessage base ;
   Extensions__Api__CastChannel__AuthChallenge *challenge ;
   Extensions__Api__CastChannel__AuthResponse *response ;
   Extensions__Api__CastChannel__AuthError *error ;
};
#line 200 "ccast/chan/cast_channel.pb-c.h"
typedef void (*Extensions__Api__CastChannel__CastMessage_Closure)(Extensions__Api__CastChannel__CastMessage * ,
                                                                  void * );
#line 203 "ccast/chan/cast_channel.pb-c.h"
typedef void (*Extensions__Api__CastChannel__AuthChallenge_Closure)(Extensions__Api__CastChannel__AuthChallenge * ,
                                                                    void * );
#line 206 "ccast/chan/cast_channel.pb-c.h"
typedef void (*Extensions__Api__CastChannel__AuthResponse_Closure)(Extensions__Api__CastChannel__AuthResponse * ,
                                                                   void * );
#line 209 "ccast/chan/cast_channel.pb-c.h"
typedef void (*Extensions__Api__CastChannel__AuthError_Closure)(Extensions__Api__CastChannel__AuthError * ,
                                                                void * );
#line 212 "ccast/chan/cast_channel.pb-c.h"
typedef void (*Extensions__Api__CastChannel__DeviceAuthMessage_Closure)(Extensions__Api__CastChannel__DeviceAuthMessage * ,
                                                                        void * );
#line 934 "/usr/include/math.h"
enum __anonenum__502___1 {
    FP_NAN___20 = 0,
    FP_INFINITE___20 = 1,
    FP_ZERO___20 = 2,
    FP_SUBNORMAL___20 = 3,
    FP_NORMAL___20 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__503___1 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__505___1 {
    PTHREAD_CREATE_JOINABLE___17 = 0,
    PTHREAD_CREATE_DETACHED___17 = 1
} ;
#line 47
enum __anonenum__506___1 {
    PTHREAD_MUTEX_TIMED_NP___17 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___17 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___17 = 3,
    PTHREAD_MUTEX_NORMAL___17 = 0,
    PTHREAD_MUTEX_RECURSIVE___17 = 1,
    PTHREAD_MUTEX_ERRORCHECK___17 = 2,
    PTHREAD_MUTEX_DEFAULT___17 = 0
} ;
#line 69
enum __anonenum__507___1 {
    PTHREAD_MUTEX_STALLED___17 = 0,
    PTHREAD_MUTEX_STALLED_NP___17 = 0,
    PTHREAD_MUTEX_ROBUST___17 = 1,
    PTHREAD_MUTEX_ROBUST_NP___17 = 1
} ;
#line 81
enum __anonenum__508___1 {
    PTHREAD_PRIO_NONE___17 = 0,
    PTHREAD_PRIO_INHERIT___17 = 1,
    PTHREAD_PRIO_PROTECT___17 = 2
} ;
#line 104
enum __anonenum__509___1 {
    PTHREAD_RWLOCK_PREFER_READER_NP___17 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___17 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___17 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___17 = 0
} ;
#line 124
enum __anonenum__510___1 {
    PTHREAD_INHERIT_SCHED___17 = 0,
    PTHREAD_EXPLICIT_SCHED___17 = 1
} ;
#line 134
enum __anonenum__511___1 {
    PTHREAD_SCOPE_SYSTEM___17 = 0,
    PTHREAD_SCOPE_PROCESS___17 = 1
} ;
#line 144
enum __anonenum__512___1 {
    PTHREAD_PROCESS_PRIVATE___17 = 0,
    PTHREAD_PROCESS_SHARED___17 = 1
} ;
#line 168
enum __anonenum__513___1 {
    PTHREAD_CANCEL_ENABLE___17 = 0,
    PTHREAD_CANCEL_DISABLE___17 = 1
} ;
#line 175
enum __anonenum__514___1 {
    PTHREAD_CANCEL_DEFERRED___17 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___17 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__517___0 {
    _PC_LINK_MAX___7 = 0,
    _PC_MAX_CANON___7 = 1,
    _PC_MAX_INPUT___7 = 2,
    _PC_NAME_MAX___7 = 3,
    _PC_PATH_MAX___7 = 4,
    _PC_PIPE_BUF___7 = 5,
    _PC_CHOWN_RESTRICTED___7 = 6,
    _PC_NO_TRUNC___7 = 7,
    _PC_VDISABLE___7 = 8,
    _PC_SYNC_IO___7 = 9,
    _PC_ASYNC_IO___7 = 10,
    _PC_PRIO_IO___7 = 11,
    _PC_SOCK_MAXBUF___7 = 12,
    _PC_FILESIZEBITS___7 = 13,
    _PC_REC_INCR_XFER_SIZE___7 = 14,
    _PC_REC_MAX_XFER_SIZE___7 = 15,
    _PC_REC_MIN_XFER_SIZE___7 = 16,
    _PC_REC_XFER_ALIGN___7 = 17,
    _PC_ALLOC_SIZE_MIN___7 = 18,
    _PC_SYMLINK_MAX___7 = 19,
    _PC_2_SYMLINKS___7 = 20
} ;
#line 71
enum __anonenum__518___0 {
    _SC_ARG_MAX___7 = 0,
    _SC_CHILD_MAX___7 = 1,
    _SC_CLK_TCK___7 = 2,
    _SC_NGROUPS_MAX___7 = 3,
    _SC_OPEN_MAX___7 = 4,
    _SC_STREAM_MAX___7 = 5,
    _SC_TZNAME_MAX___7 = 6,
    _SC_JOB_CONTROL___7 = 7,
    _SC_SAVED_IDS___7 = 8,
    _SC_REALTIME_SIGNALS___7 = 9,
    _SC_PRIORITY_SCHEDULING___7 = 10,
    _SC_TIMERS___7 = 11,
    _SC_ASYNCHRONOUS_IO___7 = 12,
    _SC_PRIORITIZED_IO___7 = 13,
    _SC_SYNCHRONIZED_IO___7 = 14,
    _SC_FSYNC___7 = 15,
    _SC_MAPPED_FILES___7 = 16,
    _SC_MEMLOCK___7 = 17,
    _SC_MEMLOCK_RANGE___7 = 18,
    _SC_MEMORY_PROTECTION___7 = 19,
    _SC_MESSAGE_PASSING___7 = 20,
    _SC_SEMAPHORES___7 = 21,
    _SC_SHARED_MEMORY_OBJECTS___7 = 22,
    _SC_AIO_LISTIO_MAX___7 = 23,
    _SC_AIO_MAX___7 = 24,
    _SC_AIO_PRIO_DELTA_MAX___7 = 25,
    _SC_DELAYTIMER_MAX___7 = 26,
    _SC_MQ_OPEN_MAX___7 = 27,
    _SC_MQ_PRIO_MAX___7 = 28,
    _SC_VERSION___7 = 29,
    _SC_PAGESIZE___7 = 30,
    _SC_RTSIG_MAX___7 = 31,
    _SC_SEM_NSEMS_MAX___7 = 32,
    _SC_SEM_VALUE_MAX___7 = 33,
    _SC_SIGQUEUE_MAX___7 = 34,
    _SC_TIMER_MAX___7 = 35,
    _SC_BC_BASE_MAX___7 = 36,
    _SC_BC_DIM_MAX___7 = 37,
    _SC_BC_SCALE_MAX___7 = 38,
    _SC_BC_STRING_MAX___7 = 39,
    _SC_COLL_WEIGHTS_MAX___7 = 40,
    _SC_EQUIV_CLASS_MAX___7 = 41,
    _SC_EXPR_NEST_MAX___7 = 42,
    _SC_LINE_MAX___7 = 43,
    _SC_RE_DUP_MAX___7 = 44,
    _SC_CHARCLASS_NAME_MAX___7 = 45,
    _SC_2_VERSION___7 = 46,
    _SC_2_C_BIND___7 = 47,
    _SC_2_C_DEV___7 = 48,
    _SC_2_FORT_DEV___7 = 49,
    _SC_2_FORT_RUN___7 = 50,
    _SC_2_SW_DEV___7 = 51,
    _SC_2_LOCALEDEF___7 = 52,
    _SC_PII___7 = 53,
    _SC_PII_XTI___7 = 54,
    _SC_PII_SOCKET___7 = 55,
    _SC_PII_INTERNET___7 = 56,
    _SC_PII_OSI___7 = 57,
    _SC_POLL___7 = 58,
    _SC_SELECT___7 = 59,
    _SC_UIO_MAXIOV___7 = 60,
    _SC_IOV_MAX___7 = 60,
    _SC_PII_INTERNET_STREAM___7 = 61,
    _SC_PII_INTERNET_DGRAM___7 = 62,
    _SC_PII_OSI_COTS___7 = 63,
    _SC_PII_OSI_CLTS___7 = 64,
    _SC_PII_OSI_M___7 = 65,
    _SC_T_IOV_MAX___7 = 66,
    _SC_THREADS___7 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___7 = 68,
    _SC_GETGR_R_SIZE_MAX___7 = 69,
    _SC_GETPW_R_SIZE_MAX___7 = 70,
    _SC_LOGIN_NAME_MAX___7 = 71,
    _SC_TTY_NAME_MAX___7 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___7 = 73,
    _SC_THREAD_KEYS_MAX___7 = 74,
    _SC_THREAD_STACK_MIN___7 = 75,
    _SC_THREAD_THREADS_MAX___7 = 76,
    _SC_THREAD_ATTR_STACKADDR___7 = 77,
    _SC_THREAD_ATTR_STACKSIZE___7 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___7 = 79,
    _SC_THREAD_PRIO_INHERIT___7 = 80,
    _SC_THREAD_PRIO_PROTECT___7 = 81,
    _SC_THREAD_PROCESS_SHARED___7 = 82,
    _SC_NPROCESSORS_CONF___7 = 83,
    _SC_NPROCESSORS_ONLN___7 = 84,
    _SC_PHYS_PAGES___7 = 85,
    _SC_AVPHYS_PAGES___7 = 86,
    _SC_ATEXIT_MAX___7 = 87,
    _SC_PASS_MAX___7 = 88,
    _SC_XOPEN_VERSION___7 = 89,
    _SC_XOPEN_XCU_VERSION___7 = 90,
    _SC_XOPEN_UNIX___7 = 91,
    _SC_XOPEN_CRYPT___7 = 92,
    _SC_XOPEN_ENH_I18N___7 = 93,
    _SC_XOPEN_SHM___7 = 94,
    _SC_2_CHAR_TERM___7 = 95,
    _SC_2_C_VERSION___7 = 96,
    _SC_2_UPE___7 = 97,
    _SC_XOPEN_XPG2___7 = 98,
    _SC_XOPEN_XPG3___7 = 99,
    _SC_XOPEN_XPG4___7 = 100,
    _SC_CHAR_BIT___7 = 101,
    _SC_CHAR_MAX___7 = 102,
    _SC_CHAR_MIN___7 = 103,
    _SC_INT_MAX___7 = 104,
    _SC_INT_MIN___7 = 105,
    _SC_LONG_BIT___7 = 106,
    _SC_WORD_BIT___7 = 107,
    _SC_MB_LEN_MAX___7 = 108,
    _SC_NZERO___7 = 109,
    _SC_SSIZE_MAX___7 = 110,
    _SC_SCHAR_MAX___7 = 111,
    _SC_SCHAR_MIN___7 = 112,
    _SC_SHRT_MAX___7 = 113,
    _SC_SHRT_MIN___7 = 114,
    _SC_UCHAR_MAX___7 = 115,
    _SC_UINT_MAX___7 = 116,
    _SC_ULONG_MAX___7 = 117,
    _SC_USHRT_MAX___7 = 118,
    _SC_NL_ARGMAX___7 = 119,
    _SC_NL_LANGMAX___7 = 120,
    _SC_NL_MSGMAX___7 = 121,
    _SC_NL_NMAX___7 = 122,
    _SC_NL_SETMAX___7 = 123,
    _SC_NL_TEXTMAX___7 = 124,
    _SC_XBS5_ILP32_OFF32___7 = 125,
    _SC_XBS5_ILP32_OFFBIG___7 = 126,
    _SC_XBS5_LP64_OFF64___7 = 127,
    _SC_XBS5_LPBIG_OFFBIG___7 = 128,
    _SC_XOPEN_LEGACY___7 = 129,
    _SC_XOPEN_REALTIME___7 = 130,
    _SC_XOPEN_REALTIME_THREADS___7 = 131,
    _SC_ADVISORY_INFO___7 = 132,
    _SC_BARRIERS___7 = 133,
    _SC_BASE___7 = 134,
    _SC_C_LANG_SUPPORT___7 = 135,
    _SC_C_LANG_SUPPORT_R___7 = 136,
    _SC_CLOCK_SELECTION___7 = 137,
    _SC_CPUTIME___7 = 138,
    _SC_THREAD_CPUTIME___7 = 139,
    _SC_DEVICE_IO___7 = 140,
    _SC_DEVICE_SPECIFIC___7 = 141,
    _SC_DEVICE_SPECIFIC_R___7 = 142,
    _SC_FD_MGMT___7 = 143,
    _SC_FIFO___7 = 144,
    _SC_PIPE___7 = 145,
    _SC_FILE_ATTRIBUTES___7 = 146,
    _SC_FILE_LOCKING___7 = 147,
    _SC_FILE_SYSTEM___7 = 148,
    _SC_MONOTONIC_CLOCK___7 = 149,
    _SC_MULTI_PROCESS___7 = 150,
    _SC_SINGLE_PROCESS___7 = 151,
    _SC_NETWORKING___7 = 152,
    _SC_READER_WRITER_LOCKS___7 = 153,
    _SC_SPIN_LOCKS___7 = 154,
    _SC_REGEXP___7 = 155,
    _SC_REGEX_VERSION___7 = 156,
    _SC_SHELL___7 = 157,
    _SC_SIGNALS___7 = 158,
    _SC_SPAWN___7 = 159,
    _SC_SPORADIC_SERVER___7 = 160,
    _SC_THREAD_SPORADIC_SERVER___7 = 161,
    _SC_SYSTEM_DATABASE___7 = 162,
    _SC_SYSTEM_DATABASE_R___7 = 163,
    _SC_TIMEOUTS___7 = 164,
    _SC_TYPED_MEMORY_OBJECTS___7 = 165,
    _SC_USER_GROUPS___7 = 166,
    _SC_USER_GROUPS_R___7 = 167,
    _SC_2_PBS___7 = 168,
    _SC_2_PBS_ACCOUNTING___7 = 169,
    _SC_2_PBS_LOCATE___7 = 170,
    _SC_2_PBS_MESSAGE___7 = 171,
    _SC_2_PBS_TRACK___7 = 172,
    _SC_SYMLOOP_MAX___7 = 173,
    _SC_STREAMS___7 = 174,
    _SC_2_PBS_CHECKPOINT___7 = 175,
    _SC_V6_ILP32_OFF32___7 = 176,
    _SC_V6_ILP32_OFFBIG___7 = 177,
    _SC_V6_LP64_OFF64___7 = 178,
    _SC_V6_LPBIG_OFFBIG___7 = 179,
    _SC_HOST_NAME_MAX___7 = 180,
    _SC_TRACE___7 = 181,
    _SC_TRACE_EVENT_FILTER___7 = 182,
    _SC_TRACE_INHERIT___7 = 183,
    _SC_TRACE_LOG___7 = 184,
    _SC_LEVEL1_ICACHE_SIZE___7 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___7 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___7 = 187,
    _SC_LEVEL1_DCACHE_SIZE___7 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___7 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___7 = 190,
    _SC_LEVEL2_CACHE_SIZE___7 = 191,
    _SC_LEVEL2_CACHE_ASSOC___7 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___7 = 193,
    _SC_LEVEL3_CACHE_SIZE___7 = 194,
    _SC_LEVEL3_CACHE_ASSOC___7 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___7 = 196,
    _SC_LEVEL4_CACHE_SIZE___7 = 197,
    _SC_LEVEL4_CACHE_ASSOC___7 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___7 = 199,
    _SC_IPV6___7 = 235,
    _SC_RAW_SOCKETS___7 = 236,
    _SC_V7_ILP32_OFF32___7 = 237,
    _SC_V7_ILP32_OFFBIG___7 = 238,
    _SC_V7_LP64_OFF64___7 = 239,
    _SC_V7_LPBIG_OFFBIG___7 = 240,
    _SC_SS_REPL_MAX___7 = 241,
    _SC_TRACE_EVENT_NAME_MAX___7 = 242,
    _SC_TRACE_NAME_MAX___7 = 243,
    _SC_TRACE_SYS_MAX___7 = 244,
    _SC_TRACE_USER_EVENT_MAX___7 = 245,
    _SC_XOPEN_STREAMS___7 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___7 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___7 = 248,
    _SC_MINSIGSTKSZ___7 = 249,
    _SC_SIGSTKSZ___7 = 250
} ;
#line 539
enum __anonenum__519___0 {
    _CS_PATH___7 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___7 = 1,
    _CS_GNU_LIBC_VERSION___7 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___7 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___7 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___7 = 5,
    _CS_LFS_CFLAGS___7 = 1000,
    _CS_LFS_LDFLAGS___7 = 1001,
    _CS_LFS_LIBS___7 = 1002,
    _CS_LFS_LINTFLAGS___7 = 1003,
    _CS_LFS64_CFLAGS___7 = 1004,
    _CS_LFS64_LDFLAGS___7 = 1005,
    _CS_LFS64_LIBS___7 = 1006,
    _CS_LFS64_LINTFLAGS___7 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___7 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___7 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___7 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___7 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___7 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___7 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___7 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___7 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___7 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___7 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___7 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___7 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___7 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___7 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___7 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___7 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___7 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___7 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___7 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___7 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___7 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___7 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___7 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___7 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___7 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___7 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___7 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___7 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___7 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___7 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___7 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___7 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___7 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___7 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___7 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___7 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___7 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___7 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___7 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___7 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___7 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___7 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___7 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___7 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___7 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___7 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___7 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___7 = 1147,
    _CS_V6_ENV___7 = 1148,
    _CS_V7_ENV___7 = 1149
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__648 {
    SI_ASYNCNL___2 = -60,
    SI_DETHREAD___2 = -7,
    SI_TKILL___2 = -6,
    SI_SIGIO___2 = -5,
    SI_ASYNCIO___2 = -4,
    SI_MESGQ___2 = -3,
    SI_TIMER___2 = -2,
    SI_QUEUE___2 = -1,
    SI_USER___2 = 0,
    SI_KERNEL___2 = 128
} ;
#line 71
enum __anonenum__649 {
    ILL_ILLOPC___2 = 1,
    ILL_ILLOPN___2 = 2,
    ILL_ILLADR___2 = 3,
    ILL_ILLTRP___2 = 4,
    ILL_PRVOPC___2 = 5,
    ILL_PRVREG___2 = 6,
    ILL_COPROC___2 = 7,
    ILL_BADSTK___2 = 8,
    ILL_BADIADDR___2 = 9
} ;
#line 94
enum __anonenum__650 {
    FPE_INTDIV___2 = 1,
    FPE_INTOVF___2 = 2,
    FPE_FLTDIV___2 = 3,
    FPE_FLTOVF___2 = 4,
    FPE_FLTUND___2 = 5,
    FPE_FLTRES___2 = 6,
    FPE_FLTINV___2 = 7,
    FPE_FLTSUB___2 = 8,
    FPE_FLTUNK___2 = 14,
    FPE_CONDTRAP___2 = 15
} ;
#line 119
enum __anonenum__651 {
    SEGV_MAPERR___2 = 1,
    SEGV_ACCERR___2 = 2,
    SEGV_BNDERR___2 = 3,
    SEGV_PKUERR___2 = 4,
    SEGV_ACCADI___2 = 5,
    SEGV_ADIDERR___2 = 6,
    SEGV_ADIPERR___2 = 7,
    SEGV_MTEAERR___2 = 8,
    SEGV_MTESERR___2 = 9
} ;
#line 142
enum __anonenum__652 {
    BUS_ADRALN___2 = 1,
    BUS_ADRERR___2 = 2,
    BUS_OBJERR___2 = 3,
    BUS_MCEERR_AR___2 = 4,
    BUS_MCEERR_AO___2 = 5
} ;
#line 176
enum __anonenum__653 {
    CLD_EXITED___2 = 1,
    CLD_KILLED___2 = 2,
    CLD_DUMPED___2 = 3,
    CLD_TRAPPED___2 = 4,
    CLD_STOPPED___2 = 5,
    CLD_CONTINUED___2 = 6
} ;
#line 193
enum __anonenum__654 {
    POLL_IN___2 = 1,
    POLL_OUT___2 = 2,
    POLL_MSG___2 = 3,
    POLL_ERR___2 = 4,
    POLL_PRI___2 = 5,
    POLL_HUP___2 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__657 {
    SIGEV_SIGNAL___2 = 0,
    SIGEV_NONE___2 = 1,
    SIGEV_THREAD___2 = 2,
    SIGEV_THREAD_ID___2 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__662 {
    SS_ONSTACK___2 = 1,
    SS_DISABLE___2 = 2
} ;
#line 202 "/usr/include/x86_64-linux-gnu/bits/socket.h"
enum __anonenum__664 {
    MSG_OOB___0 = 1,
    MSG_PEEK___0 = 2,
    MSG_DONTROUTE___0 = 4,
    MSG_CTRUNC___0 = 8,
    MSG_PROXY___0 = 16,
    MSG_TRUNC___0 = 32,
    MSG_DONTWAIT___0 = 64,
    MSG_EOR___0 = 128,
    MSG_WAITALL___0 = 256,
    MSG_FIN___0 = 512,
    MSG_SYN___0 = 1024,
    MSG_CONFIRM___0 = 2048,
    MSG_RST___0 = 4096,
    MSG_ERRQUEUE___0 = 8192,
    MSG_NOSIGNAL___0 = 16384,
    MSG_MORE___0 = 32768,
    MSG_WAITFORONE___0 = 65536,
    MSG_BATCH___0 = 262144,
    MSG_ZEROCOPY___0 = 67108864,
    MSG_FASTOPEN___0 = 536870912,
    MSG_CMSG_CLOEXEC___0 = 1073741824
} ;
#line 334
enum __anonenum__665 {
    SCM_RIGHTS___0 = 1
} ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__668 {
    SHUT_RD___0 = 0,
    SHUT_WR___0 = 1,
    SHUT_RDWR___0 = 2
} ;
#line 40 "/usr/include/netinet/in.h"
enum __anonenum__669 {
    IPPROTO_IP___0 = 0,
    IPPROTO_ICMP___0 = 1,
    IPPROTO_IGMP___0 = 2,
    IPPROTO_IPIP___0 = 4,
    IPPROTO_TCP___0 = 6,
    IPPROTO_EGP___0 = 8,
    IPPROTO_PUP___0 = 12,
    IPPROTO_UDP___0 = 17,
    IPPROTO_IDP___0 = 22,
    IPPROTO_TP___0 = 29,
    IPPROTO_DCCP___0 = 33,
    IPPROTO_IPV6___0 = 41,
    IPPROTO_RSVP___0 = 46,
    IPPROTO_GRE___0 = 47,
    IPPROTO_ESP___0 = 50,
    IPPROTO_AH___0 = 51,
    IPPROTO_MTP___0 = 92,
    IPPROTO_BEETPH___0 = 94,
    IPPROTO_ENCAP___0 = 98,
    IPPROTO_PIM___0 = 103,
    IPPROTO_COMP___0 = 108,
    IPPROTO_SCTP___0 = 132,
    IPPROTO_UDPLITE___0 = 136,
    IPPROTO_MPLS___0 = 137,
    IPPROTO_ETHERNET___0 = 143,
    IPPROTO_RAW___0 = 255,
    IPPROTO_MPTCP___0 = 262,
    IPPROTO_MAX___0 = 263
} ;
#line 103
enum __anonenum__670 {
    IPPROTO_HOPOPTS___0 = 0,
    IPPROTO_ROUTING___0 = 43,
    IPPROTO_FRAGMENT___0 = 44,
    IPPROTO_ICMPV6___0 = 58,
    IPPROTO_NONE___0 = 59,
    IPPROTO_DSTOPTS___0 = 60,
    IPPROTO_MH___0 = 135
} ;
#line 126
enum __anonenum__671 {
    IPPORT_ECHO___0 = 7,
    IPPORT_DISCARD___0 = 9,
    IPPORT_SYSTAT___0 = 11,
    IPPORT_DAYTIME___0 = 13,
    IPPORT_NETSTAT___0 = 15,
    IPPORT_FTP___0 = 21,
    IPPORT_TELNET___0 = 23,
    IPPORT_SMTP___0 = 25,
    IPPORT_TIMESERVER___0 = 37,
    IPPORT_NAMESERVER___0 = 42,
    IPPORT_WHOIS___0 = 43,
    IPPORT_MTP___0 = 57,
    IPPORT_TFTP___0 = 69,
    IPPORT_RJE___0 = 77,
    IPPORT_FINGER___0 = 79,
    IPPORT_TTYLINK___0 = 87,
    IPPORT_SUPDUP___0 = 95,
    IPPORT_EXECSERVER___0 = 512,
    IPPORT_LOGINSERVER___0 = 513,
    IPPORT_CMDSERVER___0 = 514,
    IPPORT_EFSSERVER___0 = 520,
    IPPORT_BIFFUDP___0 = 512,
    IPPORT_WHOSERVER___0 = 513,
    IPPORT_ROUTESERVER___0 = 520,
    IPPORT_RESERVED___0 = 1024,
    IPPORT_USERRESERVED___0 = 5000
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__674 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__233___1 {
    FP_NAN___21 = 0,
    FP_INFINITE___21 = 1,
    FP_ZERO___21 = 2,
    FP_SUBNORMAL___21 = 3,
    FP_NORMAL___21 = 4
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__686 {
    SI_ASYNCNL___3 = -60,
    SI_DETHREAD___3 = -7,
    SI_TKILL___3 = -6,
    SI_SIGIO___3 = -5,
    SI_ASYNCIO___3 = -4,
    SI_MESGQ___3 = -3,
    SI_TIMER___3 = -2,
    SI_QUEUE___3 = -1,
    SI_USER___3 = 0,
    SI_KERNEL___3 = 128
} ;
#line 71
enum __anonenum__687 {
    ILL_ILLOPC___3 = 1,
    ILL_ILLOPN___3 = 2,
    ILL_ILLADR___3 = 3,
    ILL_ILLTRP___3 = 4,
    ILL_PRVOPC___3 = 5,
    ILL_PRVREG___3 = 6,
    ILL_COPROC___3 = 7,
    ILL_BADSTK___3 = 8,
    ILL_BADIADDR___3 = 9
} ;
#line 94
enum __anonenum__688 {
    FPE_INTDIV___3 = 1,
    FPE_INTOVF___3 = 2,
    FPE_FLTDIV___3 = 3,
    FPE_FLTOVF___3 = 4,
    FPE_FLTUND___3 = 5,
    FPE_FLTRES___3 = 6,
    FPE_FLTINV___3 = 7,
    FPE_FLTSUB___3 = 8,
    FPE_FLTUNK___3 = 14,
    FPE_CONDTRAP___3 = 15
} ;
#line 119
enum __anonenum__689 {
    SEGV_MAPERR___3 = 1,
    SEGV_ACCERR___3 = 2,
    SEGV_BNDERR___3 = 3,
    SEGV_PKUERR___3 = 4,
    SEGV_ACCADI___3 = 5,
    SEGV_ADIDERR___3 = 6,
    SEGV_ADIPERR___3 = 7,
    SEGV_MTEAERR___3 = 8,
    SEGV_MTESERR___3 = 9
} ;
#line 142
enum __anonenum__690 {
    BUS_ADRALN___3 = 1,
    BUS_ADRERR___3 = 2,
    BUS_OBJERR___3 = 3,
    BUS_MCEERR_AR___3 = 4,
    BUS_MCEERR_AO___3 = 5
} ;
#line 176
enum __anonenum__691 {
    CLD_EXITED___3 = 1,
    CLD_KILLED___3 = 2,
    CLD_DUMPED___3 = 3,
    CLD_TRAPPED___3 = 4,
    CLD_STOPPED___3 = 5,
    CLD_CONTINUED___3 = 6
} ;
#line 193
enum __anonenum__692 {
    POLL_IN___3 = 1,
    POLL_OUT___3 = 2,
    POLL_MSG___3 = 3,
    POLL_ERR___3 = 4,
    POLL_PRI___3 = 5,
    POLL_HUP___3 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__695 {
    SIGEV_SIGNAL___3 = 0,
    SIGEV_NONE___3 = 1,
    SIGEV_THREAD___3 = 2,
    SIGEV_THREAD_ID___3 = 4
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__700 {
    SS_ONSTACK___3 = 1,
    SS_DISABLE___3 = 2
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__701 {
    PTHREAD_CREATE_JOINABLE___18 = 0,
    PTHREAD_CREATE_DETACHED___18 = 1
} ;
#line 47
enum __anonenum__702 {
    PTHREAD_MUTEX_TIMED_NP___18 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___18 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___18 = 3,
    PTHREAD_MUTEX_NORMAL___18 = 0,
    PTHREAD_MUTEX_RECURSIVE___18 = 1,
    PTHREAD_MUTEX_ERRORCHECK___18 = 2,
    PTHREAD_MUTEX_DEFAULT___18 = 0
} ;
#line 69
enum __anonenum__703 {
    PTHREAD_MUTEX_STALLED___18 = 0,
    PTHREAD_MUTEX_STALLED_NP___18 = 0,
    PTHREAD_MUTEX_ROBUST___18 = 1,
    PTHREAD_MUTEX_ROBUST_NP___18 = 1
} ;
#line 81
enum __anonenum__704 {
    PTHREAD_PRIO_NONE___18 = 0,
    PTHREAD_PRIO_INHERIT___18 = 1,
    PTHREAD_PRIO_PROTECT___18 = 2
} ;
#line 104
enum __anonenum__705 {
    PTHREAD_RWLOCK_PREFER_READER_NP___18 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___18 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___18 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___18 = 0
} ;
#line 124
enum __anonenum__706 {
    PTHREAD_INHERIT_SCHED___18 = 0,
    PTHREAD_EXPLICIT_SCHED___18 = 1
} ;
#line 134
enum __anonenum__707 {
    PTHREAD_SCOPE_SYSTEM___18 = 0,
    PTHREAD_SCOPE_PROCESS___18 = 1
} ;
#line 144
enum __anonenum__708 {
    PTHREAD_PROCESS_PRIVATE___18 = 0,
    PTHREAD_PROCESS_SHARED___18 = 1
} ;
#line 168
enum __anonenum__709 {
    PTHREAD_CANCEL_ENABLE___18 = 0,
    PTHREAD_CANCEL_DISABLE___18 = 1
} ;
#line 175
enum __anonenum__710 {
    PTHREAD_CANCEL_DEFERRED___18 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___18 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__714 {
    _PC_LINK_MAX___8 = 0,
    _PC_MAX_CANON___8 = 1,
    _PC_MAX_INPUT___8 = 2,
    _PC_NAME_MAX___8 = 3,
    _PC_PATH_MAX___8 = 4,
    _PC_PIPE_BUF___8 = 5,
    _PC_CHOWN_RESTRICTED___8 = 6,
    _PC_NO_TRUNC___8 = 7,
    _PC_VDISABLE___8 = 8,
    _PC_SYNC_IO___8 = 9,
    _PC_ASYNC_IO___8 = 10,
    _PC_PRIO_IO___8 = 11,
    _PC_SOCK_MAXBUF___8 = 12,
    _PC_FILESIZEBITS___8 = 13,
    _PC_REC_INCR_XFER_SIZE___8 = 14,
    _PC_REC_MAX_XFER_SIZE___8 = 15,
    _PC_REC_MIN_XFER_SIZE___8 = 16,
    _PC_REC_XFER_ALIGN___8 = 17,
    _PC_ALLOC_SIZE_MIN___8 = 18,
    _PC_SYMLINK_MAX___8 = 19,
    _PC_2_SYMLINKS___8 = 20
} ;
#line 71
enum __anonenum__715 {
    _SC_ARG_MAX___8 = 0,
    _SC_CHILD_MAX___8 = 1,
    _SC_CLK_TCK___8 = 2,
    _SC_NGROUPS_MAX___8 = 3,
    _SC_OPEN_MAX___8 = 4,
    _SC_STREAM_MAX___8 = 5,
    _SC_TZNAME_MAX___8 = 6,
    _SC_JOB_CONTROL___8 = 7,
    _SC_SAVED_IDS___8 = 8,
    _SC_REALTIME_SIGNALS___8 = 9,
    _SC_PRIORITY_SCHEDULING___8 = 10,
    _SC_TIMERS___8 = 11,
    _SC_ASYNCHRONOUS_IO___8 = 12,
    _SC_PRIORITIZED_IO___8 = 13,
    _SC_SYNCHRONIZED_IO___8 = 14,
    _SC_FSYNC___8 = 15,
    _SC_MAPPED_FILES___8 = 16,
    _SC_MEMLOCK___8 = 17,
    _SC_MEMLOCK_RANGE___8 = 18,
    _SC_MEMORY_PROTECTION___8 = 19,
    _SC_MESSAGE_PASSING___8 = 20,
    _SC_SEMAPHORES___8 = 21,
    _SC_SHARED_MEMORY_OBJECTS___8 = 22,
    _SC_AIO_LISTIO_MAX___8 = 23,
    _SC_AIO_MAX___8 = 24,
    _SC_AIO_PRIO_DELTA_MAX___8 = 25,
    _SC_DELAYTIMER_MAX___8 = 26,
    _SC_MQ_OPEN_MAX___8 = 27,
    _SC_MQ_PRIO_MAX___8 = 28,
    _SC_VERSION___8 = 29,
    _SC_PAGESIZE___8 = 30,
    _SC_RTSIG_MAX___8 = 31,
    _SC_SEM_NSEMS_MAX___8 = 32,
    _SC_SEM_VALUE_MAX___8 = 33,
    _SC_SIGQUEUE_MAX___8 = 34,
    _SC_TIMER_MAX___8 = 35,
    _SC_BC_BASE_MAX___8 = 36,
    _SC_BC_DIM_MAX___8 = 37,
    _SC_BC_SCALE_MAX___8 = 38,
    _SC_BC_STRING_MAX___8 = 39,
    _SC_COLL_WEIGHTS_MAX___8 = 40,
    _SC_EQUIV_CLASS_MAX___8 = 41,
    _SC_EXPR_NEST_MAX___8 = 42,
    _SC_LINE_MAX___8 = 43,
    _SC_RE_DUP_MAX___8 = 44,
    _SC_CHARCLASS_NAME_MAX___8 = 45,
    _SC_2_VERSION___8 = 46,
    _SC_2_C_BIND___8 = 47,
    _SC_2_C_DEV___8 = 48,
    _SC_2_FORT_DEV___8 = 49,
    _SC_2_FORT_RUN___8 = 50,
    _SC_2_SW_DEV___8 = 51,
    _SC_2_LOCALEDEF___8 = 52,
    _SC_PII___8 = 53,
    _SC_PII_XTI___8 = 54,
    _SC_PII_SOCKET___8 = 55,
    _SC_PII_INTERNET___8 = 56,
    _SC_PII_OSI___8 = 57,
    _SC_POLL___8 = 58,
    _SC_SELECT___8 = 59,
    _SC_UIO_MAXIOV___8 = 60,
    _SC_IOV_MAX___8 = 60,
    _SC_PII_INTERNET_STREAM___8 = 61,
    _SC_PII_INTERNET_DGRAM___8 = 62,
    _SC_PII_OSI_COTS___8 = 63,
    _SC_PII_OSI_CLTS___8 = 64,
    _SC_PII_OSI_M___8 = 65,
    _SC_T_IOV_MAX___8 = 66,
    _SC_THREADS___8 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___8 = 68,
    _SC_GETGR_R_SIZE_MAX___8 = 69,
    _SC_GETPW_R_SIZE_MAX___8 = 70,
    _SC_LOGIN_NAME_MAX___8 = 71,
    _SC_TTY_NAME_MAX___8 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___8 = 73,
    _SC_THREAD_KEYS_MAX___8 = 74,
    _SC_THREAD_STACK_MIN___8 = 75,
    _SC_THREAD_THREADS_MAX___8 = 76,
    _SC_THREAD_ATTR_STACKADDR___8 = 77,
    _SC_THREAD_ATTR_STACKSIZE___8 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___8 = 79,
    _SC_THREAD_PRIO_INHERIT___8 = 80,
    _SC_THREAD_PRIO_PROTECT___8 = 81,
    _SC_THREAD_PROCESS_SHARED___8 = 82,
    _SC_NPROCESSORS_CONF___8 = 83,
    _SC_NPROCESSORS_ONLN___8 = 84,
    _SC_PHYS_PAGES___8 = 85,
    _SC_AVPHYS_PAGES___8 = 86,
    _SC_ATEXIT_MAX___8 = 87,
    _SC_PASS_MAX___8 = 88,
    _SC_XOPEN_VERSION___8 = 89,
    _SC_XOPEN_XCU_VERSION___8 = 90,
    _SC_XOPEN_UNIX___8 = 91,
    _SC_XOPEN_CRYPT___8 = 92,
    _SC_XOPEN_ENH_I18N___8 = 93,
    _SC_XOPEN_SHM___8 = 94,
    _SC_2_CHAR_TERM___8 = 95,
    _SC_2_C_VERSION___8 = 96,
    _SC_2_UPE___8 = 97,
    _SC_XOPEN_XPG2___8 = 98,
    _SC_XOPEN_XPG3___8 = 99,
    _SC_XOPEN_XPG4___8 = 100,
    _SC_CHAR_BIT___8 = 101,
    _SC_CHAR_MAX___8 = 102,
    _SC_CHAR_MIN___8 = 103,
    _SC_INT_MAX___8 = 104,
    _SC_INT_MIN___8 = 105,
    _SC_LONG_BIT___8 = 106,
    _SC_WORD_BIT___8 = 107,
    _SC_MB_LEN_MAX___8 = 108,
    _SC_NZERO___8 = 109,
    _SC_SSIZE_MAX___8 = 110,
    _SC_SCHAR_MAX___8 = 111,
    _SC_SCHAR_MIN___8 = 112,
    _SC_SHRT_MAX___8 = 113,
    _SC_SHRT_MIN___8 = 114,
    _SC_UCHAR_MAX___8 = 115,
    _SC_UINT_MAX___8 = 116,
    _SC_ULONG_MAX___8 = 117,
    _SC_USHRT_MAX___8 = 118,
    _SC_NL_ARGMAX___8 = 119,
    _SC_NL_LANGMAX___8 = 120,
    _SC_NL_MSGMAX___8 = 121,
    _SC_NL_NMAX___8 = 122,
    _SC_NL_SETMAX___8 = 123,
    _SC_NL_TEXTMAX___8 = 124,
    _SC_XBS5_ILP32_OFF32___8 = 125,
    _SC_XBS5_ILP32_OFFBIG___8 = 126,
    _SC_XBS5_LP64_OFF64___8 = 127,
    _SC_XBS5_LPBIG_OFFBIG___8 = 128,
    _SC_XOPEN_LEGACY___8 = 129,
    _SC_XOPEN_REALTIME___8 = 130,
    _SC_XOPEN_REALTIME_THREADS___8 = 131,
    _SC_ADVISORY_INFO___8 = 132,
    _SC_BARRIERS___8 = 133,
    _SC_BASE___8 = 134,
    _SC_C_LANG_SUPPORT___8 = 135,
    _SC_C_LANG_SUPPORT_R___8 = 136,
    _SC_CLOCK_SELECTION___8 = 137,
    _SC_CPUTIME___8 = 138,
    _SC_THREAD_CPUTIME___8 = 139,
    _SC_DEVICE_IO___8 = 140,
    _SC_DEVICE_SPECIFIC___8 = 141,
    _SC_DEVICE_SPECIFIC_R___8 = 142,
    _SC_FD_MGMT___8 = 143,
    _SC_FIFO___8 = 144,
    _SC_PIPE___8 = 145,
    _SC_FILE_ATTRIBUTES___8 = 146,
    _SC_FILE_LOCKING___8 = 147,
    _SC_FILE_SYSTEM___8 = 148,
    _SC_MONOTONIC_CLOCK___8 = 149,
    _SC_MULTI_PROCESS___8 = 150,
    _SC_SINGLE_PROCESS___8 = 151,
    _SC_NETWORKING___8 = 152,
    _SC_READER_WRITER_LOCKS___8 = 153,
    _SC_SPIN_LOCKS___8 = 154,
    _SC_REGEXP___8 = 155,
    _SC_REGEX_VERSION___8 = 156,
    _SC_SHELL___8 = 157,
    _SC_SIGNALS___8 = 158,
    _SC_SPAWN___8 = 159,
    _SC_SPORADIC_SERVER___8 = 160,
    _SC_THREAD_SPORADIC_SERVER___8 = 161,
    _SC_SYSTEM_DATABASE___8 = 162,
    _SC_SYSTEM_DATABASE_R___8 = 163,
    _SC_TIMEOUTS___8 = 164,
    _SC_TYPED_MEMORY_OBJECTS___8 = 165,
    _SC_USER_GROUPS___8 = 166,
    _SC_USER_GROUPS_R___8 = 167,
    _SC_2_PBS___8 = 168,
    _SC_2_PBS_ACCOUNTING___8 = 169,
    _SC_2_PBS_LOCATE___8 = 170,
    _SC_2_PBS_MESSAGE___8 = 171,
    _SC_2_PBS_TRACK___8 = 172,
    _SC_SYMLOOP_MAX___8 = 173,
    _SC_STREAMS___8 = 174,
    _SC_2_PBS_CHECKPOINT___8 = 175,
    _SC_V6_ILP32_OFF32___8 = 176,
    _SC_V6_ILP32_OFFBIG___8 = 177,
    _SC_V6_LP64_OFF64___8 = 178,
    _SC_V6_LPBIG_OFFBIG___8 = 179,
    _SC_HOST_NAME_MAX___8 = 180,
    _SC_TRACE___8 = 181,
    _SC_TRACE_EVENT_FILTER___8 = 182,
    _SC_TRACE_INHERIT___8 = 183,
    _SC_TRACE_LOG___8 = 184,
    _SC_LEVEL1_ICACHE_SIZE___8 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___8 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___8 = 187,
    _SC_LEVEL1_DCACHE_SIZE___8 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___8 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___8 = 190,
    _SC_LEVEL2_CACHE_SIZE___8 = 191,
    _SC_LEVEL2_CACHE_ASSOC___8 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___8 = 193,
    _SC_LEVEL3_CACHE_SIZE___8 = 194,
    _SC_LEVEL3_CACHE_ASSOC___8 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___8 = 196,
    _SC_LEVEL4_CACHE_SIZE___8 = 197,
    _SC_LEVEL4_CACHE_ASSOC___8 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___8 = 199,
    _SC_IPV6___8 = 235,
    _SC_RAW_SOCKETS___8 = 236,
    _SC_V7_ILP32_OFF32___8 = 237,
    _SC_V7_ILP32_OFFBIG___8 = 238,
    _SC_V7_LP64_OFF64___8 = 239,
    _SC_V7_LPBIG_OFFBIG___8 = 240,
    _SC_SS_REPL_MAX___8 = 241,
    _SC_TRACE_EVENT_NAME_MAX___8 = 242,
    _SC_TRACE_NAME_MAX___8 = 243,
    _SC_TRACE_SYS_MAX___8 = 244,
    _SC_TRACE_USER_EVENT_MAX___8 = 245,
    _SC_XOPEN_STREAMS___8 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___8 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___8 = 248,
    _SC_MINSIGSTKSZ___8 = 249,
    _SC_SIGSTKSZ___8 = 250
} ;
#line 539
enum __anonenum__716 {
    _CS_PATH___8 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___8 = 1,
    _CS_GNU_LIBC_VERSION___8 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___8 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___8 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___8 = 5,
    _CS_LFS_CFLAGS___8 = 1000,
    _CS_LFS_LDFLAGS___8 = 1001,
    _CS_LFS_LIBS___8 = 1002,
    _CS_LFS_LINTFLAGS___8 = 1003,
    _CS_LFS64_CFLAGS___8 = 1004,
    _CS_LFS64_LDFLAGS___8 = 1005,
    _CS_LFS64_LIBS___8 = 1006,
    _CS_LFS64_LINTFLAGS___8 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___8 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___8 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___8 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___8 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___8 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___8 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___8 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___8 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___8 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___8 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___8 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___8 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___8 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___8 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___8 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___8 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___8 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___8 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___8 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___8 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___8 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___8 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___8 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___8 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___8 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___8 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___8 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___8 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___8 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___8 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___8 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___8 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___8 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___8 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___8 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___8 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___8 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___8 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___8 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___8 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___8 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___8 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___8 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___8 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___8 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___8 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___8 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___8 = 1147,
    _CS_V6_ENV___8 = 1148,
    _CS_V7_ENV___8 = 1149
} ;
#line 934 "/usr/include/math.h"
enum __anonenum__233___2 {
    FP_NAN___22 = 0,
    FP_INFINITE___22 = 1,
    FP_ZERO___22 = 2,
    FP_SUBNORMAL___22 = 3,
    FP_NORMAL___22 = 4
} ;
#line 37 "/usr/include/pthread.h"
enum __anonenum__446___0 {
    PTHREAD_CREATE_JOINABLE___19 = 0,
    PTHREAD_CREATE_DETACHED___19 = 1
} ;
#line 47
enum __anonenum__447___0 {
    PTHREAD_MUTEX_TIMED_NP___19 = 0,
    PTHREAD_MUTEX_RECURSIVE_NP___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP___19 = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP___19 = 3,
    PTHREAD_MUTEX_NORMAL___19 = 0,
    PTHREAD_MUTEX_RECURSIVE___19 = 1,
    PTHREAD_MUTEX_ERRORCHECK___19 = 2,
    PTHREAD_MUTEX_DEFAULT___19 = 0
} ;
#line 69
enum __anonenum__448___0 {
    PTHREAD_MUTEX_STALLED___19 = 0,
    PTHREAD_MUTEX_STALLED_NP___19 = 0,
    PTHREAD_MUTEX_ROBUST___19 = 1,
    PTHREAD_MUTEX_ROBUST_NP___19 = 1
} ;
#line 81
enum __anonenum__449___0 {
    PTHREAD_PRIO_NONE___19 = 0,
    PTHREAD_PRIO_INHERIT___19 = 1,
    PTHREAD_PRIO_PROTECT___19 = 2
} ;
#line 104
enum __anonenum__450___0 {
    PTHREAD_RWLOCK_PREFER_READER_NP___19 = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP___19 = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP___19 = 2,
    PTHREAD_RWLOCK_DEFAULT_NP___19 = 0
} ;
#line 124
enum __anonenum__451___0 {
    PTHREAD_INHERIT_SCHED___19 = 0,
    PTHREAD_EXPLICIT_SCHED___19 = 1
} ;
#line 134
enum __anonenum__452___0 {
    PTHREAD_SCOPE_SYSTEM___19 = 0,
    PTHREAD_SCOPE_PROCESS___19 = 1
} ;
#line 144
enum __anonenum__453___0 {
    PTHREAD_PROCESS_PRIVATE___19 = 0,
    PTHREAD_PROCESS_SHARED___19 = 1
} ;
#line 168
enum __anonenum__454___0 {
    PTHREAD_CANCEL_ENABLE___19 = 0,
    PTHREAD_CANCEL_DISABLE___19 = 1
} ;
#line 175
enum __anonenum__455___0 {
    PTHREAD_CANCEL_DEFERRED___19 = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS___19 = 1
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__459___0 {
    _PC_LINK_MAX___9 = 0,
    _PC_MAX_CANON___9 = 1,
    _PC_MAX_INPUT___9 = 2,
    _PC_NAME_MAX___9 = 3,
    _PC_PATH_MAX___9 = 4,
    _PC_PIPE_BUF___9 = 5,
    _PC_CHOWN_RESTRICTED___9 = 6,
    _PC_NO_TRUNC___9 = 7,
    _PC_VDISABLE___9 = 8,
    _PC_SYNC_IO___9 = 9,
    _PC_ASYNC_IO___9 = 10,
    _PC_PRIO_IO___9 = 11,
    _PC_SOCK_MAXBUF___9 = 12,
    _PC_FILESIZEBITS___9 = 13,
    _PC_REC_INCR_XFER_SIZE___9 = 14,
    _PC_REC_MAX_XFER_SIZE___9 = 15,
    _PC_REC_MIN_XFER_SIZE___9 = 16,
    _PC_REC_XFER_ALIGN___9 = 17,
    _PC_ALLOC_SIZE_MIN___9 = 18,
    _PC_SYMLINK_MAX___9 = 19,
    _PC_2_SYMLINKS___9 = 20
} ;
#line 71
enum __anonenum__460___0 {
    _SC_ARG_MAX___9 = 0,
    _SC_CHILD_MAX___9 = 1,
    _SC_CLK_TCK___9 = 2,
    _SC_NGROUPS_MAX___9 = 3,
    _SC_OPEN_MAX___9 = 4,
    _SC_STREAM_MAX___9 = 5,
    _SC_TZNAME_MAX___9 = 6,
    _SC_JOB_CONTROL___9 = 7,
    _SC_SAVED_IDS___9 = 8,
    _SC_REALTIME_SIGNALS___9 = 9,
    _SC_PRIORITY_SCHEDULING___9 = 10,
    _SC_TIMERS___9 = 11,
    _SC_ASYNCHRONOUS_IO___9 = 12,
    _SC_PRIORITIZED_IO___9 = 13,
    _SC_SYNCHRONIZED_IO___9 = 14,
    _SC_FSYNC___9 = 15,
    _SC_MAPPED_FILES___9 = 16,
    _SC_MEMLOCK___9 = 17,
    _SC_MEMLOCK_RANGE___9 = 18,
    _SC_MEMORY_PROTECTION___9 = 19,
    _SC_MESSAGE_PASSING___9 = 20,
    _SC_SEMAPHORES___9 = 21,
    _SC_SHARED_MEMORY_OBJECTS___9 = 22,
    _SC_AIO_LISTIO_MAX___9 = 23,
    _SC_AIO_MAX___9 = 24,
    _SC_AIO_PRIO_DELTA_MAX___9 = 25,
    _SC_DELAYTIMER_MAX___9 = 26,
    _SC_MQ_OPEN_MAX___9 = 27,
    _SC_MQ_PRIO_MAX___9 = 28,
    _SC_VERSION___9 = 29,
    _SC_PAGESIZE___9 = 30,
    _SC_RTSIG_MAX___9 = 31,
    _SC_SEM_NSEMS_MAX___9 = 32,
    _SC_SEM_VALUE_MAX___9 = 33,
    _SC_SIGQUEUE_MAX___9 = 34,
    _SC_TIMER_MAX___9 = 35,
    _SC_BC_BASE_MAX___9 = 36,
    _SC_BC_DIM_MAX___9 = 37,
    _SC_BC_SCALE_MAX___9 = 38,
    _SC_BC_STRING_MAX___9 = 39,
    _SC_COLL_WEIGHTS_MAX___9 = 40,
    _SC_EQUIV_CLASS_MAX___9 = 41,
    _SC_EXPR_NEST_MAX___9 = 42,
    _SC_LINE_MAX___9 = 43,
    _SC_RE_DUP_MAX___9 = 44,
    _SC_CHARCLASS_NAME_MAX___9 = 45,
    _SC_2_VERSION___9 = 46,
    _SC_2_C_BIND___9 = 47,
    _SC_2_C_DEV___9 = 48,
    _SC_2_FORT_DEV___9 = 49,
    _SC_2_FORT_RUN___9 = 50,
    _SC_2_SW_DEV___9 = 51,
    _SC_2_LOCALEDEF___9 = 52,
    _SC_PII___9 = 53,
    _SC_PII_XTI___9 = 54,
    _SC_PII_SOCKET___9 = 55,
    _SC_PII_INTERNET___9 = 56,
    _SC_PII_OSI___9 = 57,
    _SC_POLL___9 = 58,
    _SC_SELECT___9 = 59,
    _SC_UIO_MAXIOV___9 = 60,
    _SC_IOV_MAX___9 = 60,
    _SC_PII_INTERNET_STREAM___9 = 61,
    _SC_PII_INTERNET_DGRAM___9 = 62,
    _SC_PII_OSI_COTS___9 = 63,
    _SC_PII_OSI_CLTS___9 = 64,
    _SC_PII_OSI_M___9 = 65,
    _SC_T_IOV_MAX___9 = 66,
    _SC_THREADS___9 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___9 = 68,
    _SC_GETGR_R_SIZE_MAX___9 = 69,
    _SC_GETPW_R_SIZE_MAX___9 = 70,
    _SC_LOGIN_NAME_MAX___9 = 71,
    _SC_TTY_NAME_MAX___9 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___9 = 73,
    _SC_THREAD_KEYS_MAX___9 = 74,
    _SC_THREAD_STACK_MIN___9 = 75,
    _SC_THREAD_THREADS_MAX___9 = 76,
    _SC_THREAD_ATTR_STACKADDR___9 = 77,
    _SC_THREAD_ATTR_STACKSIZE___9 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___9 = 79,
    _SC_THREAD_PRIO_INHERIT___9 = 80,
    _SC_THREAD_PRIO_PROTECT___9 = 81,
    _SC_THREAD_PROCESS_SHARED___9 = 82,
    _SC_NPROCESSORS_CONF___9 = 83,
    _SC_NPROCESSORS_ONLN___9 = 84,
    _SC_PHYS_PAGES___9 = 85,
    _SC_AVPHYS_PAGES___9 = 86,
    _SC_ATEXIT_MAX___9 = 87,
    _SC_PASS_MAX___9 = 88,
    _SC_XOPEN_VERSION___9 = 89,
    _SC_XOPEN_XCU_VERSION___9 = 90,
    _SC_XOPEN_UNIX___9 = 91,
    _SC_XOPEN_CRYPT___9 = 92,
    _SC_XOPEN_ENH_I18N___9 = 93,
    _SC_XOPEN_SHM___9 = 94,
    _SC_2_CHAR_TERM___9 = 95,
    _SC_2_C_VERSION___9 = 96,
    _SC_2_UPE___9 = 97,
    _SC_XOPEN_XPG2___9 = 98,
    _SC_XOPEN_XPG3___9 = 99,
    _SC_XOPEN_XPG4___9 = 100,
    _SC_CHAR_BIT___9 = 101,
    _SC_CHAR_MAX___9 = 102,
    _SC_CHAR_MIN___9 = 103,
    _SC_INT_MAX___9 = 104,
    _SC_INT_MIN___9 = 105,
    _SC_LONG_BIT___9 = 106,
    _SC_WORD_BIT___9 = 107,
    _SC_MB_LEN_MAX___9 = 108,
    _SC_NZERO___9 = 109,
    _SC_SSIZE_MAX___9 = 110,
    _SC_SCHAR_MAX___9 = 111,
    _SC_SCHAR_MIN___9 = 112,
    _SC_SHRT_MAX___9 = 113,
    _SC_SHRT_MIN___9 = 114,
    _SC_UCHAR_MAX___9 = 115,
    _SC_UINT_MAX___9 = 116,
    _SC_ULONG_MAX___9 = 117,
    _SC_USHRT_MAX___9 = 118,
    _SC_NL_ARGMAX___9 = 119,
    _SC_NL_LANGMAX___9 = 120,
    _SC_NL_MSGMAX___9 = 121,
    _SC_NL_NMAX___9 = 122,
    _SC_NL_SETMAX___9 = 123,
    _SC_NL_TEXTMAX___9 = 124,
    _SC_XBS5_ILP32_OFF32___9 = 125,
    _SC_XBS5_ILP32_OFFBIG___9 = 126,
    _SC_XBS5_LP64_OFF64___9 = 127,
    _SC_XBS5_LPBIG_OFFBIG___9 = 128,
    _SC_XOPEN_LEGACY___9 = 129,
    _SC_XOPEN_REALTIME___9 = 130,
    _SC_XOPEN_REALTIME_THREADS___9 = 131,
    _SC_ADVISORY_INFO___9 = 132,
    _SC_BARRIERS___9 = 133,
    _SC_BASE___9 = 134,
    _SC_C_LANG_SUPPORT___9 = 135,
    _SC_C_LANG_SUPPORT_R___9 = 136,
    _SC_CLOCK_SELECTION___9 = 137,
    _SC_CPUTIME___9 = 138,
    _SC_THREAD_CPUTIME___9 = 139,
    _SC_DEVICE_IO___9 = 140,
    _SC_DEVICE_SPECIFIC___9 = 141,
    _SC_DEVICE_SPECIFIC_R___9 = 142,
    _SC_FD_MGMT___9 = 143,
    _SC_FIFO___9 = 144,
    _SC_PIPE___9 = 145,
    _SC_FILE_ATTRIBUTES___9 = 146,
    _SC_FILE_LOCKING___9 = 147,
    _SC_FILE_SYSTEM___9 = 148,
    _SC_MONOTONIC_CLOCK___9 = 149,
    _SC_MULTI_PROCESS___9 = 150,
    _SC_SINGLE_PROCESS___9 = 151,
    _SC_NETWORKING___9 = 152,
    _SC_READER_WRITER_LOCKS___9 = 153,
    _SC_SPIN_LOCKS___9 = 154,
    _SC_REGEXP___9 = 155,
    _SC_REGEX_VERSION___9 = 156,
    _SC_SHELL___9 = 157,
    _SC_SIGNALS___9 = 158,
    _SC_SPAWN___9 = 159,
    _SC_SPORADIC_SERVER___9 = 160,
    _SC_THREAD_SPORADIC_SERVER___9 = 161,
    _SC_SYSTEM_DATABASE___9 = 162,
    _SC_SYSTEM_DATABASE_R___9 = 163,
    _SC_TIMEOUTS___9 = 164,
    _SC_TYPED_MEMORY_OBJECTS___9 = 165,
    _SC_USER_GROUPS___9 = 166,
    _SC_USER_GROUPS_R___9 = 167,
    _SC_2_PBS___9 = 168,
    _SC_2_PBS_ACCOUNTING___9 = 169,
    _SC_2_PBS_LOCATE___9 = 170,
    _SC_2_PBS_MESSAGE___9 = 171,
    _SC_2_PBS_TRACK___9 = 172,
    _SC_SYMLOOP_MAX___9 = 173,
    _SC_STREAMS___9 = 174,
    _SC_2_PBS_CHECKPOINT___9 = 175,
    _SC_V6_ILP32_OFF32___9 = 176,
    _SC_V6_ILP32_OFFBIG___9 = 177,
    _SC_V6_LP64_OFF64___9 = 178,
    _SC_V6_LPBIG_OFFBIG___9 = 179,
    _SC_HOST_NAME_MAX___9 = 180,
    _SC_TRACE___9 = 181,
    _SC_TRACE_EVENT_FILTER___9 = 182,
    _SC_TRACE_INHERIT___9 = 183,
    _SC_TRACE_LOG___9 = 184,
    _SC_LEVEL1_ICACHE_SIZE___9 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___9 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___9 = 187,
    _SC_LEVEL1_DCACHE_SIZE___9 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___9 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___9 = 190,
    _SC_LEVEL2_CACHE_SIZE___9 = 191,
    _SC_LEVEL2_CACHE_ASSOC___9 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___9 = 193,
    _SC_LEVEL3_CACHE_SIZE___9 = 194,
    _SC_LEVEL3_CACHE_ASSOC___9 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___9 = 196,
    _SC_LEVEL4_CACHE_SIZE___9 = 197,
    _SC_LEVEL4_CACHE_ASSOC___9 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___9 = 199,
    _SC_IPV6___9 = 235,
    _SC_RAW_SOCKETS___9 = 236,
    _SC_V7_ILP32_OFF32___9 = 237,
    _SC_V7_ILP32_OFFBIG___9 = 238,
    _SC_V7_LP64_OFF64___9 = 239,
    _SC_V7_LPBIG_OFFBIG___9 = 240,
    _SC_SS_REPL_MAX___9 = 241,
    _SC_TRACE_EVENT_NAME_MAX___9 = 242,
    _SC_TRACE_NAME_MAX___9 = 243,
    _SC_TRACE_SYS_MAX___9 = 244,
    _SC_TRACE_USER_EVENT_MAX___9 = 245,
    _SC_XOPEN_STREAMS___9 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___9 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___9 = 248,
    _SC_MINSIGSTKSZ___9 = 249,
    _SC_SIGSTKSZ___9 = 250
} ;
#line 539
enum __anonenum__461___0 {
    _CS_PATH___9 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___9 = 1,
    _CS_GNU_LIBC_VERSION___9 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___9 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___9 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___9 = 5,
    _CS_LFS_CFLAGS___9 = 1000,
    _CS_LFS_LDFLAGS___9 = 1001,
    _CS_LFS_LIBS___9 = 1002,
    _CS_LFS_LINTFLAGS___9 = 1003,
    _CS_LFS64_CFLAGS___9 = 1004,
    _CS_LFS64_LDFLAGS___9 = 1005,
    _CS_LFS64_LIBS___9 = 1006,
    _CS_LFS64_LINTFLAGS___9 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___9 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___9 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___9 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___9 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___9 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___9 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___9 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___9 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___9 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___9 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___9 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___9 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___9 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___9 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___9 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___9 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___9 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___9 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___9 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___9 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___9 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___9 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___9 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___9 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___9 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___9 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___9 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___9 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___9 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___9 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___9 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___9 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___9 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___9 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___9 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___9 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___9 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___9 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___9 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___9 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___9 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___9 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___9 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___9 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___9 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___9 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___9 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___9 = 1147,
    _CS_V6_ENV___9 = 1148,
    _CS_V7_ENV___9 = 1149
} ;
#line 364 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
struct __anonstruct_743 {
   int x ;
   int y ;
};
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 402 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 791
extern int system(char const   *__command ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 432
extern  __attribute__((__nothrow__)) int strerror_r(int __errnum , char *__buf , size_t __buflen ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 187
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 187
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 191
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 191
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 198
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 198
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 203
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 220
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 262
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 262
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 279
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 329
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 340
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 340
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 435
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 435
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 435
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 333
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 309
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 339
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern  __attribute__((__nothrow__)) void closefrom(int __lowfd ) ;
#line 371
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 389
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 437
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 452
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 498
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 503
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 517
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 521
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 531
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 545
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 552
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 555
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 564
extern char **__environ ;
#line 572
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 578
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 589
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 594
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 599
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 605
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 619
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 624
extern void _exit(int __status ) ;
#line 633
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 637
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 640
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 644
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 650
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 653
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 656
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 659
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 661
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 668
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 689
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 697
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 706
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 722
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 732
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 749
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 778
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 799
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 803
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 809
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 814
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 819
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 832
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 838
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 847
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 851
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 858
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 862
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 867
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 871
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 874
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 895
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 911 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 919
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 924
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 930
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 933
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 939
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 942
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 950
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 958
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 962
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 963
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 964
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 970
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 977
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 981
extern char *getpass(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 1011
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 1026
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1049
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1070
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1076
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1091
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1114
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1159
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1198
int getentropy(void *__buffer , size_t __length ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 29
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 36
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 38
  __cil_tmp7 = __builtin_object_size(__buf, 0);
  }
  {
#line 38
  __cil_tmp5 = __builtin_object_size(__buf, 0);
#line 38
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 38
  __cil_tmp4 = __builtin_constant_p(__nbytes);
  }
#line 38
  if (__cil_tmp6 && (unsigned long )__nbytes <= __cil_tmp7 / sizeof(char )) {
    {
#line 38
    __cil_tmp8 = __read_alias(__fd, __buf, __nbytes);
#line 38
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 38
    __cil_tmp12 = __builtin_object_size(__buf, 0);
    }
    {
#line 38
    __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 38
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 38
    __cil_tmp9 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (__cil_tmp11 && ! ((unsigned long )__nbytes <= __cil_tmp12 / sizeof(char ))) {
      {
#line 38
      __cil_tmp13 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp14 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp13);
#line 38
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 38
      __cil_tmp15 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp16 = __read_chk(__fd, __buf, __nbytes, __cil_tmp15);
#line 38
      tmp = __cil_tmp16;
      }
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  return (tmp___0);
}
}
#line 44
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 47
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 50
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 54
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 74
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 74
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 74
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 74
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 74
    __cil_tmp9 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 74
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 74
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 74
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 74
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 74
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 74
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 74
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp15 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 74
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 74
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp17 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 74
      tmp = __cil_tmp17;
      }
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 100
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 104
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 108
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 119
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 119
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 119
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 119
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 119
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 119
    __cil_tmp8 = __readlink_alias(__path, __buf, __len);
#line 119
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 119
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 119
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 119
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 119
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 119
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp14 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp13);
#line 119
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 119
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp16 = __readlink_chk(__path, __buf, __len, __cil_tmp15);
#line 119
      tmp = __cil_tmp16;
      }
    }
#line 119
    tmp___0 = tmp;
  }
#line 119
  return (tmp___0);
}
}
#line 126
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 130
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 135
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 147
  __cil_tmp8 = __builtin_object_size(__buf, 1);
  }
  {
#line 147
  __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 147
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 147
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 147
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 147
    __cil_tmp9 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 147
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 147
    __cil_tmp13 = __builtin_object_size(__buf, 1);
    }
    {
#line 147
    __cil_tmp11 = __builtin_object_size(__buf, 1);
#line 147
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 147
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 147
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 147
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp15 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp14);
#line 147
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 147
      __cil_tmp16 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp17 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp16);
#line 147
      tmp = __cil_tmp17;
      }
    }
#line 147
    tmp___0 = tmp;
  }
#line 147
  return (tmp___0);
}
}
#line 153
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 155
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 157
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 164
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 164 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 166
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 166
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 166
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 166
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 166
  if (__cil_tmp5 && (unsigned long )__size <= __cil_tmp6 / sizeof(char )) {
    {
#line 166
    __cil_tmp7 = __getcwd_alias(__buf, __size);
#line 166
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 166
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 166
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 166
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 166
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 166
    if (__cil_tmp10 && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(char ))) {
      {
#line 166
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp13 = __getcwd_chk_warn(__buf, __size, __cil_tmp12);
#line 166
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 166
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp15 = __getcwd_chk(__buf, __size, __cil_tmp14);
#line 166
      tmp = __cil_tmp15;
      }
    }
#line 166
    tmp___0 = tmp;
  }
#line 166
  return (tmp___0);
}
}
#line 172
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 174
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 181
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 182
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 182
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 182
    return (__cil_tmp4);
  }
  {
#line 183
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 183
  return (__cil_tmp5);
}
}
#line 187
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 190
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 193
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 202
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 202
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 202
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 202
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 202
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 202
    __cil_tmp8 = __confstr_alias(__name, __buf, __len);
#line 202
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 202
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 202
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 202
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 202
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 202
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 202
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp14 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp13);
#line 202
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 202
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp16 = __confstr_chk(__name, __buf, __len, __cil_tmp15);
#line 202
      tmp = __cil_tmp16;
      }
    }
#line 202
    tmp___0 = tmp;
  }
#line 202
  return (tmp___0);
}
}
#line 208
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 210
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 212
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 219
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 219 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  __cil_tmp6 = __builtin_object_size(__list, 1);
  }
  {
#line 221
  __cil_tmp4 = __builtin_object_size(__list, 1);
#line 221
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(__gid_t ));
  }
  {
#line 221
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 221
  if (((__cil_tmp3 && __size > 0) && __cil_tmp5) && (unsigned long )__size <= __cil_tmp6 / sizeof(__gid_t )) {
    {
#line 221
    __cil_tmp7 = __getgroups_alias(__size, __list);
#line 221
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 221
    __cil_tmp11 = __builtin_object_size(__list, 1);
    }
    {
#line 221
    __cil_tmp9 = __builtin_object_size(__list, 1);
#line 221
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(__gid_t ));
    }
    {
#line 221
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 221
    if (((__cil_tmp8 && __size > 0) && __cil_tmp10) && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(__gid_t ))) {
      {
#line 221
      __cil_tmp12 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp13 = __getgroups_chk_warn(__size, __list, __cil_tmp12);
#line 221
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 221
      __cil_tmp14 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp15 = __getgroups_chk(__size, __list, __cil_tmp14);
#line 221
      tmp = __cil_tmp15;
      }
    }
#line 221
    tmp___0 = tmp;
  }
#line 221
  return (tmp___0);
}
}
#line 227
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 230
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 233
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 242
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 242
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 242
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 242
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 242
    __cil_tmp8 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 242
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 242
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 242
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 242
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 242
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 242
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 242
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp14 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 242
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 242
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp16 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 242
      tmp = __cil_tmp16;
      }
    }
#line 242
    tmp___0 = tmp;
  }
#line 242
  return (tmp___0);
}
}
#line 249
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 251
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 253
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 260
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 260 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 262
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 262
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 262
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 262
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 262
    __cil_tmp7 = __getlogin_r_alias(__buf, __buflen);
#line 262
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 262
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 262
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 262
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 262
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 262
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 262
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp13 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp12);
#line 262
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 262
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp15 = __getlogin_r_chk(__buf, __buflen, __cil_tmp14);
#line 262
      tmp = __cil_tmp15;
      }
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return (tmp___0);
}
}
#line 270
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 272
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 275
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 282
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 284
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 284
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 284
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 284
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 284
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 284
    __cil_tmp7 = __gethostname_alias(__buf, __buflen);
#line 284
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 284
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 284
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 284
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 284
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 284
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 284
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp13 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 284
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 284
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp15 = __gethostname_chk(__buf, __buflen, __cil_tmp14);
#line 284
      tmp = __cil_tmp15;
      }
    }
#line 284
    tmp___0 = tmp;
  }
#line 284
  return (tmp___0);
}
}
#line 292
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 294
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 298
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 306
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 308
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 308
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 308
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 308
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 308
    __cil_tmp7 = __getdomainname_alias(__buf, __buflen);
#line 308
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 308
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 308
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 308
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 308
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 308
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 308
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp13 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 308
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 308
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp15 = __getdomainname_chk(__buf, __buflen, __cil_tmp14);
#line 308
      tmp = __cil_tmp15;
      }
    }
#line 308
    tmp___0 = tmp;
  }
#line 308
  return (tmp___0);
}
}
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int glob(char const   *__pattern , int __flags ,
                                              int (*__errfunc)(char const   * , int  ) ,
                                              glob_t *__pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void globfree(glob_t *__pglob ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat(char const   *__file , struct stat *__buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__buf ) ;
#line 264
extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__file ,
                                                 struct stat *__buf , int __flag ) ;
#line 313
extern  __attribute__((__nothrow__)) int lstat(char const   *__file , struct stat *__buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 359
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 365
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 371
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 380
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 389
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 396
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 404
extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                               __dev_t __dev ) ;
#line 411
extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                 __mode_t __mode , __dev_t __dev ) ;
#line 418
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 425
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 433
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 7 "h/copyright.h"
static char __copyright__[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 320 "numlib/numsup.h"
a1log *new_a1log(a1log *log___0 , int verb , int debug , void *cntx , void (*logv)(void * ,
                                                                                   a1log * ,
                                                                                   char * ,
                                                                                   va_list  ) ,
                 void (*logd)(void * , a1log * , char * , va_list  ) , void (*loge)(void * ,
                                                                                    a1log * ,
                                                                                    char * ,
                                                                                    va_list  ) ) ;
#line 334
a1log *new_a1log_d(a1log *log___0 ) ;
#line 338
a1log *del_a1log(a1log *log___0 ) ;
#line 341
void a1log_debug(a1log *log___0 , int level ) ;
#line 344
void a1log_verb(a1log *log___0 , int level ) ;
#line 347
void a1log_tag(a1log *log___0 , char *tag ) ;
#line 350
void a1logv(a1log *log___0 , int level , char *fmt  , ...) ;
#line 353
void a1logd(a1log *log___0 , int level , char *fmt  , ...) ;
#line 356
void a1logw(a1log *log___0 , char *fmt  , ...) ;
#line 360
void a1loge(a1log *log___0 , int ecode , char *fmt  , ...) ;
#line 364
void a1logue(a1log *log___0 ) ;
#line 368
void dump_bytes(FILE *fp , char *pfx , unsigned char *buf , int base , int len ) ;
#line 372
void adump_bytes(a1log *log___0 , char *pfx , unsigned char *buf , int base , int len ) ;
#line 376
char *exe_path ;
#line 380
a1log *g_log ;
#line 384
void set_exe_path(char *argv0 ) ;
#line 386
void error(char *fmt  , ...) ;
#line 387
void warning(char *fmt  , ...) ;
#line 388
void verbose(int level , char *fmt  , ...) ;
#line 390
int ret_null_on_malloc_fail ;
#line 392
void check_if_not_interactive(void) ;
#line 393
int not_interactive ;
#line 394
char cr_char ;
#line 402
void *recalloc(void *ptr , size_t cnum , size_t csize , size_t nnum , size_t nsize ) ;
#line 434
double *dvector(int nl , int nh ) ;
#line 435
double *dvectorz(int nl , int nh ) ;
#line 436
void free_dvector(double *v , int nl , int nh ) ;
#line 438
double **dmatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 439
double **dmatrixz(int nrl , int nrh , int ncl , int nch ) ;
#line 440
void free_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) ;
#line 441
void dmatrix_reset(double **m , int nrl , int nrh , int ncl , int nch ) ;
#line 443
double **dhmatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 444
double **dhmatrixz(int nrl , int nrh , int ncl , int nch ) ;
#line 445
void free_dhmatrix(double **m , int nrl , int nrh , int ncl , int nch ) ;
#line 447
void copy_dmatrix(double **dst , double **src , int nrl , int nrh , int ncl , int nch ) ;
#line 448
void copy_dmatrix_to3x3(double dst[3][3] , double **src , int nrl , int nrh , int ncl ,
                        int nch ) ;
#line 451
double **convert_dmatrix(double *a , int nrl , int nrh , int ncl , int nch ) ;
#line 452
void free_convert_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) ;
#line 456
float *fvector(int nl , int nh ) ;
#line 457
float *fvectorz(int nl , int nh ) ;
#line 458
void free_fvector(float *v , int nl , int nh ) ;
#line 460
float **fmatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 461
float **fmatrixz(int nrl , int nrh , int ncl , int nch ) ;
#line 462
void free_fmatrix(float **m , int nrl , int nrh , int ncl , int nch ) ;
#line 466
int *ivector(int nl , int nh ) ;
#line 467
int *ivectorz(int nl , int nh ) ;
#line 468
void free_ivector(int *v , int nl , int nh ) ;
#line 470
int **imatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 471
int **imatrixz(int nrl , int nrh , int ncl , int nch ) ;
#line 472
void free_imatrix(int **m , int nrl , int nrh , int ncl , int nch ) ;
#line 476
short *svector(int nl , int nh ) ;
#line 477
short *svectorz(int nl , int nh ) ;
#line 478
void free_svector(short *v , int nl , int nh ) ;
#line 480
short **smatrix(int nrl , int nrh , int ncl , int nch ) ;
#line 481
short **smatrixz(int nrl , int nrh , int ncl , int nch ) ;
#line 482
void free_smatrix(short **m , int nrl , int nrh , int ncl , int nch ) ;
#line 488
void matrix_trans(double **d , double **s , int nr , int nc ) ;
#line 491
void sym_matrix_trans(double **m , int n ) ;
#line 494
int matrix_mult(double **d , int nr , int nc , double **s1 , int nr1 , int nc1 , double **s2 ,
                int nr2 , int nc2 ) ;
#line 503
int matrix_trans_mult(double **d , int nr , int nc , double **ts1 , int nr1 , int nc1 ,
                      double **s2 , int nr2 , int nc2 ) ;
#line 511
int matrix_mult_trans(double **d , int nr , int nc , double **s1 , int nr1 , int nc1 ,
                      double **ts2 , int nr2 , int nc2 ) ;
#line 519
int matrix_vect_mult(double *d , int nd , double **m , int nr , int nc , double *v ,
                     int nv ) ;
#line 527
int matrix_trans_vect_mult(double *d , int nd , double **m , int nr , int nc , double *v ,
                           int nv ) ;
#line 534
void matrix_add(double **d , double **s1 , double **s2 , int nr , int nc ) ;
#line 537
void matrix_scaled_add(double **d , double **s1 , double scale , double **s2 , int nr ,
                       int nc ) ;
#line 540
void matrix_cpy(double **d , double **s , int nr , int nc ) ;
#line 543
void matrix_set(double **d , double v , int nr , int nc ) ;
#line 546
double matrix_max_diff(double **d , double **s , int nr , int nc ) ;
#line 550
void vect_set(double *d , double v , int len ) ;
#line 561
void vect_neg(double *d , double *s , int len ) ;
#line 565
void vect_add(double *d , double *v , int len ) ;
#line 568
void vect_add3(double *d , double *s1 , double *s2 , int len ) ;
#line 572
void vect_sub(double *d , double *v , int len ) ;
#line 575
void vect_sub3(double *d , double *s1 , double *s2 , int len ) ;
#line 578
void vect_invert(double *d , double *s , int len ) ;
#line 581
void vect_mul(double *d , double *s , int len ) ;
#line 584
void vect_mul3(double *d , double *s1 , double *s2 , int len ) ;
#line 587
void vect_div(double *d , double *s , int len ) ;
#line 590
void vect_div3(double *d , double *s1 , double *s2 , int len ) ;
#line 594
void vect_div3_safe(double *d , double *s1 , double *s2 , int len ) ;
#line 597
void vect_muldiv(double *d , double *s1 , double *s2 , int len ) ;
#line 601
void vect_muldiv_safe(double *d , double *s1 , double *s2 , int len ) ;
#line 604
void vect_muldiv3(double *d , double *s1 , double *s2 , double *s3 , int len ) ;
#line 607
void vect_max_elem(double *d , double *s , int len ) ;
#line 610
void vect_max_elem3(double *d , double *s1 , double *s2 , int len ) ;
#line 614
void vect_blend(double *d , double *s0 , double *s1 , double bl , int len ) ;
#line 618
void vect_scale(double *d , double *s , double scale , int len ) ;
#line 621
void vect_scale1(double *d , double scale , int len ) ;
#line 624
void vect_scaleadd(double *d , double *s , double scale , int len ) ;
#line 627
double vect_dot(double *s1 , double *s2 , int len ) ;
#line 630
double vect_mag(double *s , int len ) ;
#line 633
double vect_magsq(double *s , int len ) ;
#line 636
double vect_diffmag(double *s1 , double *s2 , int len ) ;
#line 639
double vect_sum(double *s , int len ) ;
#line 642
double vect_avg(double *s , int len ) ;
#line 646
int vect_normalize(double *d , double *s , int len ) ;
#line 649
double vect_max_mag(double *s , int len ) ;
#line 652
double vect_max(double *s , int len ) ;
#line 655
double vect_max2(double *s1 , int len1 , double *s2 , int len2 ) ;
#line 658
double vect_min(double *s , int len ) ;
#line 661
void vect_abs(double *d , double *s , int len ) ;
#line 664
void vect_spow(double *d , double *s , double pv , int len ) ;
#line 669
int vect_clip(double *d , double *s , double min , double max , int len ) ;
#line 672
int vect_cmp(double *s1 , double *s2 , int len ) ;
#line 680
int vect_lsearch(double *p , double in , int len ) ;
#line 686
int vect_bsearch(double *p , double in , int len ) ;
#line 691
double vect_lerp(double *s , double in , int len ) ;
#line 699
double vect_rev_lerp(double *s , double in , int len ) ;
#line 707
double vect_lerp2x(double *p , double *v , double in , int len ) ;
#line 710
double vect_lerp2(double *p , double *v , double in , int len ) ;
#line 716
void ivect_set(int *d , int v , int len ) ;
#line 724
void dump_dmatrix(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ) ;
#line 725
void dump_fmatrix(FILE *fp , char *id , char *pfx , float **a , int nr , int nc ) ;
#line 726
void dump_imatrix(FILE *fp , char *id , char *pfx , int **a , int nr , int nc ) ;
#line 727
void dump_smatrix(FILE *fp , char *id , char *pfx , short **a , int nr , int nc ) ;
#line 729
void dump_dvector(FILE *fp , char *id , char *pfx , double *a , int nc ) ;
#line 730
void dump_fvector(FILE *fp , char *id , char *pfx , float *a , int nc ) ;
#line 731
void dump_ivector(FILE *fp , char *id , char *pfx , int *a , int nc ) ;
#line 732
void dump_svector(FILE *fp , char *id , char *pfx , short *a , int nc ) ;
#line 734
void dump_dmatrix_fmt(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ,
                      char *fmt ) ;
#line 735
void dump_dvector_fmt(FILE *fp , char *id , char *pfx , double *a , int nc , char *fmt ) ;
#line 738
void adump_dmatrix(a1log *log___0 , char *id , char *pfx , double **a , int nr , int nc ) ;
#line 739
void adump_fmatrix(a1log *log___0 , char *id , char *pfx , float **a , int nr , int nc ) ;
#line 740
void adump_imatrix(a1log *log___0 , char *id , char *pfx , int **a , int nr , int nc ) ;
#line 741
void adump_smatrix(a1log *log___0 , char *id , char *pfx , short **a , int nr , int nc ) ;
#line 743
void adump_dvector(a1log *log___0 , char *id , char *pfx , double *a , int nc ) ;
#line 744
void adump_fvector(a1log *log___0 , char *id , char *pfx , float *a , int nc ) ;
#line 745
void adump_ivector(a1log *log___0 , char *id , char *pfx , int *a , int nc ) ;
#line 746
void adump_svector(a1log *log___0 , char *id , char *pfx , short *a , int nc ) ;
#line 748
void adump_dmatrix_fmt(a1log *log___0 , char *id , char *pfx , double **a , int nr ,
                       int nc , char *fmt ) ;
#line 749
void adump_dvector_fmt(a1log *log___0 , char *id , char *pfx , double *a , int nc ,
                       char *fmt ) ;
#line 752
void adump_C_dmatrix(a1log *log___0 , char *id , char *pfx , double *a , int nr ,
                     int nc ) ;
#line 759
double vect_ClipNmarg(int n , double *out , double *in ) ;
#line 763
void vect_MulByNxN(int n , double *out , double *mat , double *in ) ;
#line 767
void vect_MulByMxN(int n , int m , double *out , double *mat , double *in ) ;
#line 771
void vect_MulByNxM(int n , int m , double *out , double *mat , double *in ) ;
#line 774
void matrix_TransposeNxN(int n , double *out , double *in ) ;
#line 782
void acode_dmatrix(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ,
                   int hb ) ;
#line 784
void acode_dvector(FILE *fp , char *id , char *pfx , double *v , int nc , int hb ) ;
#line 790
uint32_t doubletoIEEE754(double d ) ;
#line 794
double IEEE754todouble(uint32_t ip ) ;
#line 799
uint64_t doubletoIEEE754_64(double d ) ;
#line 803
double IEEE754_64todouble(uint64_t ip ) ;
#line 808
char *ctime_32(int32_t *timer ) ;
#line 812
char *ctime_64(int64_t *timer ) ;
#line 824
unsigned int read_ORD8(uint8_t *p ) ;
#line 825
void write_ORD8(uint8_t *p , unsigned int d ) ;
#line 828
int read_INR8(uint8_t *p ) ;
#line 829
void write_INR8(uint8_t *p , int d ) ;
#line 833
unsigned int read_ORD16_be(uint8_t *p ) ;
#line 834
unsigned int read_ORD16_le(uint8_t *p ) ;
#line 835
void write_ORD16_be(uint8_t *p , unsigned int d ) ;
#line 836
void write_ORD16_le(uint8_t *p , unsigned int d ) ;
#line 839
int read_INR16_be(uint8_t *p ) ;
#line 840
int read_INR16_le(uint8_t *p ) ;
#line 841
void write_INR16_be(uint8_t *p , int d ) ;
#line 842
void write_INR16_le(uint8_t *p , int d ) ;
#line 846
unsigned int read_ORD32_be(uint8_t *p ) ;
#line 847
unsigned int read_ORD32_le(uint8_t *p ) ;
#line 848
void write_ORD32_be(uint8_t *p , unsigned int d ) ;
#line 849
void write_ORD32_le(uint8_t *p , unsigned int d ) ;
#line 852
int read_INR32_be(uint8_t *p ) ;
#line 853
int read_INR32_le(uint8_t *p ) ;
#line 854
void write_INR32_be(uint8_t *p , int d ) ;
#line 855
void write_INR32_le(uint8_t *p , int d ) ;
#line 859
uint64_t read_ORD64_be(uint8_t *p ) ;
#line 860
uint64_t read_ORD64_le(uint8_t *p ) ;
#line 861
void write_ORD64_be(uint8_t *p , uint64_t d ) ;
#line 862
void write_ORD64_le(uint8_t *p , uint64_t d ) ;
#line 865
int64_t read_INR64_be(uint8_t *p ) ;
#line 866
int64_t read_INR64_le(uint8_t *p ) ;
#line 867
void write_INR64_be(uint8_t *p , int64_t d ) ;
#line 868
void write_INR64_le(uint8_t *p , int64_t d ) ;
#line 872
double read_FLT32_be(uint8_t *p ) ;
#line 873
double read_FLT32_le(uint8_t *p ) ;
#line 874
void write_FLT32_be(uint8_t *p , double d ) ;
#line 875
void write_FLT32_le(uint8_t *p , double d ) ;
#line 878
double read_FLT64_be(uint8_t *p ) ;
#line 879
double read_FLT64_le(uint8_t *p ) ;
#line 880
void write_FLT64_be(uint8_t *p , double d ) ;
#line 881
void write_FLT64_le(uint8_t *p , double d ) ;
#line 886
void msec_sleep(unsigned int msec ) ;
#line 890
unsigned int msec_time(void) ;
#line 894
double usec_time(void) ;
#line 901
char *debPiv(int di , int *p ) ;
#line 905
char *debPdv(int di , double *p ) ;
#line 909
char *debPdvf(int di , char *fmt , double *p ) ;
#line 913
char *debPfv(int di , float *p ) ;
#line 926
double gamma_func(double x ) ;
#line 50 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.h"
int next_con_char(void) ;
#line 54
int poll_con_char(void) ;
#line 58
void empty_con_chars(void) ;
#line 62
void msec_beep(int delay , int freq , int msec ) ;
#line 64
void normal_beep() ;
#line 65
void good_beep() ;
#line 66
void bad_beep() ;
#line 139
int acond_timedwait_imp(pthread_cond_t *cond , pthread_mutex_t *lock , int msec ) ;
#line 208
athread *new_athread_reusable(int (*function)(void * ) , void *context , int reusable ) ;
#line 217
char *login_HOME(void) ;
#line 220
void delete_file(char *fname ) ;
#line 224
int create_parent_directories(char *path ) ;
#line 229
int system_processors(void) ;
#line 99 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.h"
int xdg_bds(xdg_error *er , char ***paths , xdg_storage_type st , xdg_op_type op ,
            xdg_scope sc , xdg_options opt , char *pfname ) ;
#line 110
void xdg_free(char **paths , int nopaths ) ;
#line 113
char *xdg_errstr(xdg_error er ) ;
#line 53 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.h"
int aglob_create(aglob *g , char *spath ) ;
#line 57
char *aglob_next(aglob *g ) ;
#line 60
void aglob_cleanup(aglob *g ) ;
#line 147 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
static void mputenv(char *ss ) 
{ 
  int ll ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 148
  __cil_tmp3 = strlen((char const   *)ss);
#line 148
  ll = (int )__cil_tmp3;
#line 149
  ss = strdup((char const   *)ss);
  }
#line 150
  if (ll > 0) {
#line 150
    if ((int )*(ss + (ll - 1)) == 61) {
      {
#line 151
      *(ss + (ll - 1)) = (char )'\000';
#line 152
      unsetenv((char const   *)ss);
      }
    } else {
      {
      {
#line 154
      putenv(ss);
      }
      }
    }
  } else {
    {
    {
#line 154
    putenv(ss);
    }
    }
  }
  return;
}
}
#line 163 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
static char *append(char *in , char *app ) 
{ 
  char *rv ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 166
  __cil_tmp5 = strlen((char const   *)app);
  }
  {
#line 166
  __cil_tmp4 = strlen((char const   *)in);
#line 166
  __cil_tmp6 = malloc((__cil_tmp4 + __cil_tmp5) + 1UL);
#line 166
  rv = __cil_tmp6;
  }
#line 166
  if (rv == (void *)0) {
    {
#line 167
    a1loge(g_log, 1, "xdg_bds: append malloc failed\n");
#line 168
    free(in);
    }
#line 169
    return ((char *)((void *)0));
  }
  {
#line 171
  strcpy(rv, (char const   *)in);
#line 172
  strcat(rv, (char const   *)app);
#line 173
  free(in);
  }
#line 175
  return (rv);
}
}
#line 180 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
static char *cappend(char *in , char *app ) 
{ 
  int inlen ;
  int aplen ;
  char *rv ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 184
  __cil_tmp6 = strlen((char const   *)in);
#line 184
  inlen = (int )__cil_tmp6;
#line 185
  __cil_tmp7 = strlen((char const   *)app);
#line 185
  aplen = (int )__cil_tmp7;
#line 187
  rv = (char *)malloc((unsigned long )(((inlen + 1) + aplen) + 1));
  }
#line 187
  if (rv == (void *)0) {
    {
#line 188
    a1loge(g_log, 1, "xdg_bds: cappend malloc failed\n");
#line 189
    free(in);
    }
#line 190
    return ((char *)((void *)0));
  }
  {
#line 192
  strcpy(rv, (char const   *)in);
  }
#line 193
  if (inlen > 0) {
#line 193
    if ((int )*(in + (inlen - 1)) != 58) {
#line 193
      if (aplen > 0) {
        {
#line 194
        strcat(rv, ":n8\026\313U");
        }
      }
    }
  }
  {
#line 195
  strcat(rv, (char const   *)app);
#line 196
  free(in);
  }
#line 198
  return (rv);
}
}
#line 203 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
static char *dappend(char *in , char *app ) 
{ 
  int inlen ;
  int aplen ;
  char *rv ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 207
  __cil_tmp6 = strlen((char const   *)in);
#line 207
  inlen = (int )__cil_tmp6;
#line 208
  __cil_tmp7 = strlen((char const   *)app);
#line 208
  aplen = (int )__cil_tmp7;
#line 210
  rv = (char *)malloc((unsigned long )(((inlen + 1) + aplen) + 1));
  }
#line 210
  if (rv == (void *)0) {
    {
#line 211
    a1loge(g_log, 1, "xdg_bds: dappend malloc failed\n");
#line 212
    free(in);
    }
#line 213
    return ((char *)((void *)0));
  }
  {
#line 215
  strcpy(rv, (char const   *)in);
  }
#line 216
  if (inlen > 0) {
#line 216
    if ((int )*(in + (inlen - 1)) != 47) {
      {
#line 217
      strcat(rv, "/");
      }
    }
  }
  {
#line 218
  strcat(rv, (char const   *)app);
#line 219
  free(in);
  }
#line 221
  return (rv);
}
}
#line 227 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
static void xdg_ifree(char ***paths , char **fnames , int nopaths ) 
{ 
  int i ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 230
  if (paths != (void *)0) {
#line 231
    if (*paths != (void *)0) {
#line 232
      i = 0;
      {
#line 232
      while (1) {
        while_continue: /* CIL Label */ ;
#line 232
        if (! (i < nopaths)) {
#line 232
          goto while_break;
        }
#line 233
        if (*(*paths + i) != (void *)0) {
          {
#line 234
          free(*(*paths + i));
          }
        }
#line 232
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 237
    free(*paths);
#line 238
    *paths = (char **)((void *)0);
    }
  }
#line 240
  if (fnames != (void *)0) {
#line 241
    i = 0;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! (i < nopaths)) {
#line 241
        goto while_break___0;
      }
#line 242
      if (*(fnames + i) != (void *)0) {
        {
#line 243
        free(*(fnames + i));
        }
      }
#line 241
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 245
    free(fnames);
    }
  }
  return;
}
}
#line 250 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
void xdg_free(char **paths , int nopaths ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 253
  if (paths != (void *)0) {
#line 254
    i = 0;
    {
#line 254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 254
      if (! (i < nopaths)) {
#line 254
        goto while_break;
      }
#line 255
      if (*(paths + i) != (void *)0) {
        {
#line 256
        free(*(paths + i));
        }
      }
#line 254
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 258
    free(paths);
    }
  }
  return;
}
}
#line 279 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
int xdg_bds(xdg_error *er , char ***paths , xdg_storage_type st , xdg_op_type op ,
            xdg_scope sc , xdg_options opt , char *pfname ) 
{ 
  char *path ;
  char **fnames ;
  int npaths ;
  int napaths ;
  char *__cil_tmp12 ;
  char *xdg ;
  char *home ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *xdg___0 ;
  char *home___0 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *xdg___1 ;
  char *home___1 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *xdg___2 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  char *spath ;
  char *cp ;
  char *ep ;
  char *sname ;
  char *ncp ;
  char *nep ;
  char *__cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  void *__cil_tmp50 ;
  int rlen ;
  char *pp ;
  char *schpath ;
  char *__cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  void *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *fpath ;
  aglob gg ;
  int __cil_tmp62 ;
  int i ;
  char *__cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  int __cil_tmp71 ;
  char *pp___3 ;
  struct stat sbuf ;
  mode_t mode ;
  __uid_t __cil_tmp75 ;
  char *uids ;
  char *gids ;
  int uid ;
  int gid ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  __uid_t __cil_tmp86 ;
  __uid_t __cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  __gid_t __cil_tmp90 ;
  int __cil_tmp91 ;
  __uid_t __cil_tmp92 ;
  int __cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  char *__cil_tmp98 ;
  void *__cil_tmp99 ;
  int __cil_tmp100 ;

  {
  {
#line 288
  path = (char *)((void *)0);
#line 289
  fnames = (char **)((void *)0);
#line 290
  npaths = 0;
#line 291
  napaths = 0;
#line 299
  *paths = (char **)((void *)0);
#line 302
  path = strdup("\220");
  }
#line 302
  if (path == (void *)0) {
#line 303
    if (er != (void *)0) {
#line 303
      *er = (xdg_error )1;
    }
    {
#line 304
    a1loge(g_log, 1, "xdg_bds: malloc failed\n");
#line 305
    xdg_ifree(paths, fnames, npaths);
    }
#line 306
    return (0);
  }
#line 312
  if ((unsigned int )op == 1U) {
    _L: /* CIL Label */ 
#line 313
    if ((unsigned int )st == 0U) {
      {
#line 315
      xdg = getenv("XDG_DATA_HOME");
      }
#line 315
      if (xdg != (void *)0) {
        {
#line 316
        path = cappend(path, xdg);
        }
#line 316
        if (path == (void *)0) {
#line 317
          if (er != (void *)0) {
#line 317
            *er = (xdg_error )1;
          }
          {
#line 318
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 319
          return (0);
        }
      } else {
        {
#line 330
        home = login_HOME();
        }
#line 330
        if (home == (void *)0) {
#line 335
          if (er != (void *)0) {
#line 335
            *er = (xdg_error )2;
          }
          {
#line 336
          free(path);
          }
#line 338
          return (0);
        }
        {
#line 340
        path = cappend(path, home);
        }
#line 340
        if (path == (void *)0) {
#line 341
          if (er != (void *)0) {
#line 341
            *er = (xdg_error )1;
          }
          {
#line 342
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 343
          return (0);
        }
        {
#line 352
        path = dappend(path, ".local/share");
        }
#line 355
        if (path == (void *)0) {
#line 356
          if (er != (void *)0) {
#line 356
            *er = (xdg_error )1;
          }
          {
#line 357
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 358
          return (0);
        }
      }
    } else
#line 361
    if ((unsigned int )st == 1U) {
      {
#line 363
      xdg___0 = getenv("XDG_CONFIG_HOME");
      }
#line 363
      if (xdg___0 != (void *)0) {
        {
#line 364
        path = cappend(path, xdg___0);
        }
#line 364
        if (path == (void *)0) {
#line 365
          if (er != (void *)0) {
#line 365
            *er = (xdg_error )1;
          }
          {
#line 366
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 367
          return (0);
        }
      } else {
        {
#line 378
        home___0 = login_HOME();
        }
#line 378
        if (home___0 == (void *)0) {
#line 383
          if (er != (void *)0) {
#line 383
            *er = (xdg_error )2;
          }
          {
#line 384
          free(path);
          }
#line 386
          return (0);
        }
        {
#line 388
        path = cappend(path, home___0);
        }
#line 388
        if (path == (void *)0) {
#line 389
          if (er != (void *)0) {
#line 389
            *er = (xdg_error )1;
          }
          {
#line 390
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 391
          return (0);
        }
        {
#line 400
        path = dappend(path, ".config");
        }
#line 403
        if (path == (void *)0) {
#line 404
          if (er != (void *)0) {
#line 404
            *er = (xdg_error )1;
          }
          {
#line 405
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 406
          return (0);
        }
      }
    } else
#line 409
    if ((unsigned int )st == 2U) {
      {
#line 411
      xdg___1 = getenv("XDG_CACHE_HOME");
      }
#line 411
      if (xdg___1 != (void *)0) {
        {
#line 412
        path = cappend(path, xdg___1);
        }
#line 412
        if (path == (void *)0) {
#line 413
          if (er != (void *)0) {
#line 413
            *er = (xdg_error )1;
          }
          {
#line 414
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 415
          return (0);
        }
      } else {
        {
#line 431
        home___1 = login_HOME();
        }
#line 431
        if (home___1 == (void *)0) {
#line 436
          if (er != (void *)0) {
#line 436
            *er = (xdg_error )2;
          }
          {
#line 437
          free(path);
          }
#line 439
          return (0);
        }
        {
#line 441
        path = cappend(path, home___1);
        }
#line 441
        if (path == (void *)0) {
#line 442
          if (er != (void *)0) {
#line 442
            *er = (xdg_error )1;
          }
          {
#line 443
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 444
          return (0);
        }
        {
#line 455
        path = dappend(path, ".cache");
        }
#line 458
        if (path == (void *)0) {
#line 459
          if (er != (void *)0) {
#line 459
            *er = (xdg_error )1;
          }
          {
#line 460
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 461
          return (0);
        }
      }
    }
  } else
#line 312
  if ((unsigned int )sc == 0U) {
#line 312
    goto _L;
  }
#line 467
  if ((unsigned int )op == 1U) {
    _L___0: /* CIL Label */ 
#line 469
    if ((unsigned int )st == 0U) {
      {
#line 470
      xdg___2 = getenv("XDG_DATA_DIRS");
      }
#line 470
      if (xdg___2 != (void *)0) {
        {
#line 471
        path = cappend(path, xdg___2);
        }
#line 471
        if (path == (void *)0) {
#line 472
          if (er != (void *)0) {
#line 472
            *er = (xdg_error )1;
          }
          {
#line 473
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 474
          return (0);
        }
      } else {
        {
#line 497
        path = cappend(path, "/usr/local/share:/usr/share");
        }
#line 500
        if (path == (void *)0) {
#line 501
          if (er != (void *)0) {
#line 501
            *er = (xdg_error )1;
          }
          {
#line 502
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 503
          return (0);
        }
      }
    } else
#line 506
    if ((unsigned int )st == 1U) {
      {
#line 507
      xdg___2 = getenv("XDG_CONFIG_DIRS");
      }
#line 507
      if (xdg___2 != (void *)0) {
        {
#line 508
        path = cappend(path, xdg___2);
        }
#line 508
        if (path == (void *)0) {
#line 509
          if (er != (void *)0) {
#line 509
            *er = (xdg_error )1;
          }
          {
#line 510
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 511
          return (0);
        }
      } else {
        {
#line 528
        path = cappend(path, "/etc/xdg\220");
        }
#line 531
        if (path == (void *)0) {
#line 532
          if (er != (void *)0) {
#line 532
            *er = (xdg_error )1;
          }
          {
#line 533
          a1loge(g_log, 1, "xdg_bds: malloc failed\n");
          }
#line 534
          return (0);
        }
      }
    }
  } else
#line 467
  if ((unsigned int )sc == 1U) {
#line 467
    goto _L___0;
  }
  {
#line 554
  __cil_tmp41 = strlen((char const   *)path);
  }
#line 554
  if (__cil_tmp41 == 0UL) {
    {
#line 555
    free(path);
    }
#line 556
    if (er != (void *)0) {
#line 556
      *er = (xdg_error )4;
    }
#line 557
    *paths = (char **)((void *)0);
#line 558
    return (0);
  }
#line 562
  spath = (char *)((void *)0);
#line 566
  cp = path;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! ((int )*cp != 0)) {
#line 566
      goto while_break;
    }
    {
#line 567
    sname = (char *)((void *)0);
#line 571
    ep = strchr((char const   *)cp, ':');
    }
#line 571
    if (ep == (void *)0) {
      {
#line 572
      __cil_tmp49 = strlen((char const   *)cp);
#line 572
      ep = cp + __cil_tmp49;
      }
    }
#line 573
    if (ep - cp == 0L) {
      {
#line 574
      free(path);
      }
#line 575
      if (er != (void *)0) {
#line 575
        *er = (xdg_error )5;
      }
      {
#line 576
      xdg_ifree(paths, fnames, npaths);
      }
#line 577
      return (0);
    }
    {
#line 579
    __cil_tmp50 = malloc((unsigned long )((ep - cp) + 1L));
#line 579
    spath = (char *)__cil_tmp50;
    }
#line 579
    if (spath == (void *)0) {
      {
#line 580
      a1loge(g_log, 1, "xdg_bds: malloc failed\n");
#line 581
      free(path);
      }
#line 582
      if (er != (void *)0) {
#line 582
        *er = (xdg_error )1;
      }
      {
#line 583
      xdg_ifree(paths, fnames, npaths);
      }
#line 584
      return (0);
    }
    {
#line 586
    memmove(spath, cp, (unsigned long )(ep - cp));
#line 587
    *(spath + (ep - cp)) = (char )'\000';
#line 590
    ncp = pfname;
    }
    {
#line 590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 590
      if (! ((int )*ncp != 0)) {
#line 590
        goto while_break___0;
      }
      {
#line 591
      rlen = 0;
#line 596
      nep = strchr((char const   *)ncp, ':');
      }
#line 596
      if (nep == (void *)0) {
        {
#line 597
        __cil_tmp55 = strlen((char const   *)ncp);
#line 597
        nep = ncp + __cil_tmp55;
        }
      }
#line 598
      if (nep - ncp == 0L) {
        {
#line 599
        free(spath);
#line 600
        free(path);
        }
#line 601
        if (er != (void *)0) {
#line 601
          *er = (xdg_error )5;
        }
        {
#line 602
        xdg_ifree(paths, fnames, npaths);
        }
#line 603
        return (0);
      }
      {
#line 605
      __cil_tmp56 = malloc((unsigned long )((nep - ncp) + 1L));
#line 605
      sname = (char *)__cil_tmp56;
      }
#line 605
      if (sname == (void *)0) {
        {
#line 606
        a1loge(g_log, 1, "xdg_bds: malloc failed\n");
#line 607
        free(spath);
#line 608
        free(path);
        }
#line 609
        if (er != (void *)0) {
#line 609
          *er = (xdg_error )1;
        }
        {
#line 610
        xdg_ifree(paths, fnames, npaths);
        }
#line 611
        return (0);
      }
      {
#line 613
      memmove(sname, ncp, (unsigned long )(nep - ncp));
#line 614
      *(sname + (nep - ncp)) = (char )'\000';
#line 617
      schpath = dappend(schpath, sname);
      }
      {
#line 617
      schpath = strdup((char const   *)spath);
      }
#line 617
      if (schpath == (void *)0) {
        _L___1: /* CIL Label */ 
        {
#line 619
        free(sname);
#line 620
        free(spath);
#line 621
        free(path);
        }
#line 622
        if (er != (void *)0) {
#line 622
          *er = (xdg_error )1;
        }
        {
#line 623
        xdg_ifree(paths, fnames, npaths);
        }
#line 624
        return (0);
      } else
#line 617
      if (schpath == (void *)0) {
#line 617
        goto _L___1;
      }
      {
#line 629
      pp = strrchr((char const   *)schpath, '/');
      }
#line 629
      if (pp == (void *)0) {
#line 630
        rlen = 0;
      } else {
#line 632
        rlen = (int )((pp - schpath) + 1L);
      }
#line 634
      if ((unsigned int )op == 1U) {
        {
#line 639
        __cil_tmp62 = aglob_create(& gg, schpath);
        }
#line 639
        if (__cil_tmp62) {
          {
#line 640
          free(schpath);
#line 641
          free(sname);
#line 642
          free(spath);
#line 643
          free(path);
          }
#line 644
          if (er != (void *)0) {
#line 644
            *er = (xdg_error )1;
          }
          {
#line 645
          xdg_ifree(paths, fnames, npaths);
          }
#line 646
          return (0);
        }
        {
#line 651
        free(schpath);
        }
        {
#line 652
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 652
          if (! 1) {
#line 652
            goto while_break___1;
          }
          {
#line 655
          fpath = aglob_next(& gg);
          }
#line 655
          if (fpath == (void *)0) {
#line 656
            if (gg.merr) {
              {
#line 657
              free(sname);
#line 658
              free(spath);
#line 659
              free(path);
#line 660
              aglob_cleanup(& gg);
              }
#line 661
              if (er != (void *)0) {
#line 661
                *er = (xdg_error )1;
              }
              {
#line 662
              xdg_ifree(paths, fnames, npaths);
              }
#line 663
              return (0);
            }
#line 665
            goto while_break___1;
          }
#line 669
          if ((unsigned int )opt != 1U) {
#line 672
            i = 0;
            {
#line 672
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 672
              if (! (i < npaths)) {
#line 672
                goto while_break___2;
              }
              {
#line 673
              __cil_tmp65 = strcmp((char const   *)(fpath + rlen), (char const   *)*(fnames + i));
              }
#line 673
              if (__cil_tmp65 == 0) {
#line 675
                goto while_break___2;
              }
#line 672
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 678
            if (i < npaths) {
              {
#line 679
              free(fpath);
              }
#line 681
              goto while_continue___1;
            }
          }
#line 686
          if (npaths >= napaths) {
            {
#line 687
            napaths = napaths * 2 + 1;
#line 688
            fnames = (char **)realloc(fnames, sizeof(char *) * (unsigned long )napaths);
            }
            {
#line 688
            *paths = (char **)realloc(*paths, sizeof(char *) * (unsigned long )napaths);
            }
#line 688
            if (*paths == (void *)0) {
              _L___2: /* CIL Label */ 
              {
#line 690
              a1loge(g_log, 1, "xdg_bds: realloc failed\n\220");
#line 691
              free(fpath);
#line 692
              free(sname);
#line 693
              free(spath);
#line 694
              free(path);
#line 695
              aglob_cleanup(& gg);
              }
#line 696
              if (er != (void *)0) {
#line 696
                *er = (xdg_error )1;
              }
              {
#line 697
              xdg_ifree(paths, fnames, npaths);
              }
#line 698
              return (0);
            } else
#line 688
            if (fnames == (void *)0) {
#line 688
              goto _L___2;
            }
          }
          {
#line 701
          *(*paths + npaths) = strdup((char const   *)fpath);
          }
#line 701
          if (*(*paths + npaths) == (void *)0) {
            {
#line 702
            a1loge(g_log, 1, "xdg_bds: strdup failed\n");
#line 703
            free(fpath);
#line 704
            free(sname);
#line 705
            free(spath);
#line 706
            free(path);
#line 707
            aglob_cleanup(& gg);
            }
#line 708
            if (er != (void *)0) {
#line 708
              *er = (xdg_error )1;
            }
            {
#line 709
            xdg_ifree(paths, fnames, npaths);
            }
#line 710
            return (0);
          }
          {
#line 713
          *(fnames + npaths) = strdup((char const   *)(fpath + rlen));
          }
#line 713
          if (*(fnames + npaths) == (void *)0) {
            {
#line 714
            a1loge(g_log, 1, "xdg_bds: strdup failed\n");
#line 715
            free(*(*paths + npaths));
#line 716
            free(fpath);
#line 717
            free(sname);
#line 718
            free(spath);
#line 719
            free(path);
#line 720
            aglob_cleanup(& gg);
            }
#line 721
            if (er != (void *)0) {
#line 721
              *er = (xdg_error )1;
            }
            {
#line 722
            xdg_ifree(paths, fnames, npaths);
            }
#line 723
            return (0);
          }
          {
#line 725
          free(fpath);
#line 726
          fpath = (char *)((void *)0);
#line 727
          npaths ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 729
        aglob_cleanup(& gg);
        }
      } else {
#line 734
        pp___3 = schpath;
#line 736
        mode = (mode_t )448;
#line 738
        if ((unsigned int )sc == 0U) {
#line 739
          mode = (mode_t )448;
        } else {
#line 741
          mode = (mode_t )493;
        }
        {
#line 744
        __cil_tmp75 = geteuid();
        }
#line 744
        if ((unsigned int )sc == 0U) {
#line 744
          if (__cil_tmp75 == 0U) {
            {
#line 749
            gids = getenv("SUDO_GID\220");
            }
            {
#line 749
            uids = getenv("SUDO_UID\220");
            }
#line 749
            if (uids != (void *)0) {
#line 749
              if (gids != (void *)0) {
                {
#line 751
                uid = atoi((char const   *)uids);
#line 752
                gid = atoi((char const   *)gids);
#line 753
                __cil_tmp85 = seteuid((__uid_t )uid);
                }
                {
#line 753
                __cil_tmp84 = setegid((__gid_t )gid);
                }
#line 753
                if (! __cil_tmp84) {
#line 753
                  if (__cil_tmp85) {

                  }
                }
              }
            }
          } else {
#line 744
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 760
          __cil_tmp87 = geteuid();
          }
          {
#line 760
          __cil_tmp86 = getuid();
          }
#line 760
          if ((unsigned int )sc == 1U) {
#line 760
            if (__cil_tmp86 == 0U) {
#line 760
              if (__cil_tmp87 != 0U) {
                {
#line 761
                __cil_tmp89 = getenv("SUDO_GID\220");
                }
                {
#line 761
                __cil_tmp88 = getenv("SUDO_UID\220");
                }
#line 761
                if (__cil_tmp88 != (void *)0) {
#line 761
                  if (__cil_tmp89 != (void *)0) {
                    {
#line 764
                    __cil_tmp92 = getuid();
#line 764
                    __cil_tmp93 = seteuid(__cil_tmp92);
                    }
                    {
#line 764
                    __cil_tmp90 = getgid();
#line 764
                    __cil_tmp91 = setegid(__cil_tmp90);
                    }
#line 764
                    if (! __cil_tmp91) {
#line 764
                      if (__cil_tmp93) {

                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 779
        if ((int )*pp___3 == 47) {
#line 780
          pp___3 ++;
        }
        {
#line 785
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 785
          if (! (pp___3 != (void *)0 && (int )*pp___3 != 0)) {
#line 785
            goto while_break___3;
          }
          {
#line 786
          pp___3 = strchr((char const   *)pp___3, '/');
          }
#line 786
          if (pp___3 != (void *)0) {
            {
#line 787
            *pp___3 = (char )'\000';
#line 789
            __cil_tmp96 = stat((char const   *)schpath, & sbuf);
            }
#line 789
            if (__cil_tmp96 != 0) {
              {
#line 792
              __cil_tmp97 = mkdir((char const   *)schpath, mode);
              }
#line 792
              if (__cil_tmp97 != 0) {

              }
            } else {
#line 799
              mode = sbuf.st_mode;
            }
#line 801
            *pp___3 = (char )'/';
#line 802
            pp___3 ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 809
        if (pp___3 == (void *)0) {
          _L___5: /* CIL Label */ 
          {
#line 811
          *paths = (char **)malloc(sizeof(char *));
          }
#line 811
          if (*paths == (void *)0) {
            {
#line 812
            a1loge(g_log, 1, "xdg_bds: malloc failed\n");
#line 813
            free(schpath);
#line 814
            free(sname);
#line 815
            free(spath);
#line 816
            free(path);
            }
#line 817
            if (er != (void *)0) {
#line 817
              *er = (xdg_error )1;
            }
#line 818
            return (0);
          }
#line 820
          *(*paths + npaths) = schpath;
#line 820
          if (*(*paths + npaths) == (void *)0) {
            {
#line 821
            free(sname);
#line 822
            free(spath);
#line 823
            free(path);
            }
#line 824
            if (er != (void *)0) {
#line 824
              *er = (xdg_error )1;
            }
            {
#line 825
            free(*paths);
            }
#line 826
            return (0);
          }
          {
#line 828
          npaths ++;
#line 830
          free(sname);
#line 831
          free(spath);
#line 832
          free(path);
          }
#line 833
          return (npaths);
        } else
#line 809
        if ((int )*pp___3 == 0) {
#line 809
          goto _L___5;
        }
      }
      {
#line 838
      free(sname);
#line 838
      sname = (char *)((void *)0);
      }
#line 839
      if ((int )*nep == 58) {
#line 840
        ncp = nep + 1;
      } else {
#line 842
        ncp = nep;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 846
    free(spath);
#line 846
    spath = (char *)((void *)0);
    }
#line 847
    if ((int )*ep == 58) {
#line 848
      cp = ep + 1;
    } else {
#line 850
      cp = ep;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 855
  free(path);
  }
#line 857
  if (npaths == 0) {
#line 858
    if (er != (void *)0) {
#line 858
      *er = (xdg_error )4;
    }
    {
#line 859
    xdg_ifree(paths, fnames, npaths);
    }
  } else {
    {
#line 861
    xdg_ifree((char ***)((void *)0), fnames, npaths);
    }
  }
#line 871
  return (npaths);
}
}
#line 875 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/xdg_bds.c"
char *xdg_errstr(xdg_error er ) 
{ 


  {
  {
#line 877
  if ((unsigned int )er == (unsigned int )0) {
#line 877
    goto case_0;
  }
#line 879
  if ((unsigned int )er == (unsigned int )1) {
#line 879
    goto case_1;
  }
#line 881
  if ((unsigned int )er == (unsigned int )2) {
#line 881
    goto case_2;
  }
#line 883
  if ((unsigned int )er == (unsigned int )3) {
#line 883
    goto case_3;
  }
#line 885
  if ((unsigned int )er == (unsigned int )4) {
#line 885
    goto case_4;
  }
#line 887
  if ((unsigned int )er == (unsigned int )5) {
#line 887
    goto case_5;
  }
#line 889
  goto switch_default;
  case_0: /* CIL Label */ 
#line 878
  return ("OK");
  case_1: /* CIL Label */ 
#line 880
  return ("memory allocation failed\220");
  case_2: /* CIL Label */ 
#line 882
  return ("There is no $HOME");
  case_3: /* CIL Label */ 
#line 884
  return ("There\'s no $ALLUSERSPROFILE is no $ALLUSERSPROFILE");
  case_4: /* CIL Label */ 
#line 886
  return ("There is no resulting path");
  case_5: /* CIL Label */ 
#line 888
  return ("Malformed path fount");
  switch_default: /* CIL Label */ 
#line 890
  return ("unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t cfgetospeed(struct termios *__termios_p ) ;
#line 51
extern  __attribute__((__nothrow__)) speed_t cfgetispeed(struct termios *__termios_p ) ;
#line 54
extern  __attribute__((__nothrow__)) int cfsetospeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int cfsetispeed(struct termios *__termios_p ,
                                                     speed_t __speed ) ;
#line 61
extern  __attribute__((__nothrow__)) int cfsetspeed(struct termios *__termios_p ,
                                                    speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void cfmakeraw(struct termios *__termios_p ) ;
#line 80
extern  __attribute__((__nothrow__)) int tcsendbreak(int __fd , int __duration ) ;
#line 86
extern int tcdrain(int __fd ) ;
#line 90
extern  __attribute__((__nothrow__)) int tcflush(int __fd , int __queue_selector ) ;
#line 94
extern  __attribute__((__nothrow__)) int tcflow(int __fd , int __action ) ;
#line 99
extern  __attribute__((__nothrow__)) __pid_t tcgetsid(int __fd ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 67 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval *__tv , void *__tz ) ;
#line 86
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval *__tv , struct timezone *__tz ) ;
#line 94
extern  __attribute__((__nothrow__)) int adjtime(struct timeval *__delta , struct timeval *__olddelta ) ;
#line 149
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 155
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval *__new ,
                                                   struct itimerval *__old ) ;
#line 162
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 189
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval __tvp[2] ) ;
#line 193
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval __tvp[2] ) ;
#line 40 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/pollem.h"
int pollem(struct pollfd *fds , unsigned long nfds , int timeout ) ;
#line 39 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/pollem.c"
int pollem(struct pollfd *fds , unsigned long nfds , int timeout ) 
{ 
  int i ;
  int nfd ;
  fd_set rd_ary ;
  fd_set wr_ary ;
  fd_set ex_ary ;
  struct timeval tv ;
  struct timeval *ptv ;
  int result ;
  unsigned int __i ;
  fd_set *__arr ;
  unsigned int __i___0 ;
  fd_set *__arr___0 ;
  unsigned int __i___1 ;
  fd_set *__arr___1 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 45
  ptv = & tv;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    __arr = & rd_ary;
#line 49
    __i = (unsigned int )0;
    {
#line 49
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! ((unsigned long )__i < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 49
        goto while_break___0;
      }
#line 49
      __arr->__fds_bits[__i] = (__fd_mask )0;
#line 49
      __i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 50
    __arr___0 = & wr_ary;
#line 50
    __i___0 = (unsigned int )0;
    {
#line 50
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 50
      if (! ((unsigned long )__i___0 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 50
        goto while_break___2;
      }
#line 50
      __arr___0->__fds_bits[__i___0] = (__fd_mask )0;
#line 50
      __i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 50
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 51
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 51
    __arr___1 = & ex_ary;
#line 51
    __i___1 = (unsigned int )0;
    {
#line 51
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 51
      if (! ((unsigned long )__i___1 < sizeof(fd_set ) / sizeof(__fd_mask ))) {
#line 51
        goto while_break___4;
      }
#line 51
      __arr___1->__fds_bits[__i___1] = (__fd_mask )0;
#line 51
      __i___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 51
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 53
  nfd = 0;
#line 53
  i = nfd;
  {
#line 53
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 53
    if (! ((unsigned long )i < nfds)) {
#line 53
      goto while_break___5;
    }
#line 54
    (fds + i)->revents = (short )0;
#line 56
    if ((int )(fds + i)->events & 1) {
#line 57
      rd_ary.__fds_bits[0] |= (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )));
#line 58
      if ((fds + i)->fd > nfd) {
#line 59
        nfd = (fds + i)->fd;
      }
    }
#line 62
    if ((int )(fds + i)->events & 2) {
#line 63
      ex_ary.__fds_bits[0] |= (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )));
#line 64
      if ((fds + i)->fd > nfd) {
#line 65
        nfd = (fds + i)->fd;
      }
    }
#line 68
    if ((int )(fds + i)->events & 4) {
#line 69
      wr_ary.__fds_bits[0] |= (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )));
#line 70
      if ((fds + i)->fd > nfd) {
#line 71
        nfd = (fds + i)->fd;
      }
    }
#line 53
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 74
  nfd ++;
#line 77
  if (timeout == -1) {
#line 78
    ptv = (struct timeval *)((void *)0);
  } else
#line 80
  if (timeout == 0) {
#line 81
    tv.tv_sec = (__time_t )0;
#line 82
    tv.tv_usec = (__suseconds_t )0;
  } else {
#line 85
    tv.tv_sec = (__time_t )(timeout / 1000);
#line 86
    tv.tv_usec = ((long )timeout - tv.tv_sec * 1000L) * 1000L;
  }
  {
#line 90
  result = select(nfd, & rd_ary, & wr_ary, & ex_ary, ptv);
  }
#line 90
  if (result > 0) {
#line 92
    i = 0;
    {
#line 92
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 92
      if (! ((unsigned long )i < nfds)) {
#line 92
        goto while_break___6;
      }
#line 93
      (fds + i)->revents = (short )0;
#line 95
      if ((ex_ary.__fds_bits[0] & (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 96
        (fds + i)->revents |= 2;
      }
#line 98
      if ((rd_ary.__fds_bits[0] & (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 99
        (fds + i)->revents |= 1;
      }
#line 101
      if ((wr_ary.__fds_bits[0] & (__fd_mask )(1UL << (fds + i)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 102
        (fds + i)->revents |= 4;
      }
#line 92
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 106
  return (result);
}
}
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 94
extern struct passwd *fgetpwent(FILE *__stream ) ;
#line 102
extern int putpwent(struct passwd *__p , FILE *__f ) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 139
extern int getpwent_r(struct passwd *__resultbuf , char *__buffer , size_t __buflen ,
                      struct passwd **__result ) ;
#line 146
extern int getpwuid_r(__uid_t __uid , struct passwd *__resultbuf , char *__buffer ,
                      size_t __buflen , struct passwd **__result ) ;
#line 153
extern int getpwnam_r(char const   *__name , struct passwd *__resultbuf , char *__buffer ,
                      size_t __buflen , struct passwd **__result ) ;
#line 169
extern int fgetpwent_r(FILE *__stream , struct passwd *__resultbuf , char *__buffer ,
                       size_t __buflen , struct passwd **__result ) ;
#line 7 "h/copyright.h"
static char __copyright_____0[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 84 "cgats/pars.h"
cgatsAlloc *new_cgatsAllocStd(void) ;
#line 151
cgatsFile *new_cgatsFileStd_name(char const   *name , char const   *mode ) ;
#line 154
cgatsFile *new_cgatsFileStd_fp(FILE *fp ) ;
#line 157
cgatsFile *new_cgatsFileStd_name_a(char const   *name , char const   *mode , cgatsAlloc *al ) ;
#line 160
cgatsFile *new_cgatsFileStd_fp_a(FILE *fp , cgatsAlloc *al ) ;
#line 183
cgatsFile *new_cgatsFileMem_a(void *base , size_t length , cgatsAlloc *al ) ;
#line 187
cgatsFile *new_cgatsFileMem_ad(void *base , size_t length , cgatsAlloc *al ) ;
#line 193
cgatsFile *new_cgatsFileMem(void *base , size_t length ) ;
#line 197
cgatsFile *new_cgatsFileMem_d(void *base , size_t length ) ;
#line 242
extern parse *new_parse_al(cgatsAlloc *al , cgatsFile *fp ) ;
#line 245
extern parse *new_parse(cgatsFile *fp ) ;
#line 170 "cgats/cgats.h"
extern cgats *new_cgats_al(cgatsAlloc *al ) ;
#line 179
extern cgats *new_cgats(void) ;
#line 182
int cgats_read_name(cgats *p , char const   *filename ) ;
#line 183
int cgats_write_name(cgats *p , char const   *filename ) ;
#line 239 "icc/icc.h"
icmAlloc *new_icmAllocStd(void) ;
#line 295
icmFile *new_icmFileStd_name(char *name , char *mode ) ;
#line 298
icmFile *new_icmFileStd_fp(FILE *fp ) ;
#line 301
icmFile *new_icmFileStd_name_a(char *name , char *mode , icmAlloc *al ) ;
#line 304
icmFile *new_icmFileStd_fp_a(FILE *fp , icmAlloc *al ) ;
#line 325
icmFile *new_icmFileMem_a(void *base , size_t length , icmAlloc *al ) ;
#line 329
icmFile *new_icmFileMem_ad(void *base , size_t length , icmAlloc *al ) ;
#line 334
icmFile *new_icmFileMem(void *base , size_t length ) ;
#line 338
icmFile *new_icmFileMem_d(void *base , size_t length ) ;
#line 843
int icmSetMultiLutTables(int ntables , struct _icmLut **p , int flags , void *cbctx ,
                         icColorSpaceSignature insig , icColorSpaceSignature outsig ,
                         void (*infunc)(void * , double * , double * ) , double *inmin ,
                         double *inmax , void (*clutfunc)(void * , double * , double * ) ,
                         double *clutmin , double *clutmax , void (*outfunc)(void * ,
                                                                             double * ,
                                                                             double * ) ,
                         int *apxls_gmin , int *apxls_gmax ) ;
#line 1719
extern icmMD5 *new_icmMD5_a(icmAlloc *al ) ;
#line 1722
extern icmMD5 *new_icmMD5(void) ;
#line 1741
icmFile *new_icmFileMD5_a(icmMD5 *md5 , icmAlloc *al ) ;
#line 1747
extern icc *new_icc_a(icmAlloc *al ) ;
#line 1750
extern icc *new_icc(void) ;
#line 1766
extern int read_Primitive(icc *icpp , icmPrimType ptype , void *prim , char *p ) ;
#line 1769
extern int write_Primitive(icc *icp , icmPrimType ptype , char *p , void *prim ) ;
#line 1772
extern char *tag2str(int tag ) ;
#line 1775
extern unsigned int str2tag(char const   *str ) ;
#line 1785
extern char const   *icm2str(icmEnumType etype , int enumval ) ;
#line 1788
extern unsigned int icmCSSig2nchan(icColorSpaceSignature sig ) ;
#line 1793
extern unsigned int icmCSSig2chanNames(icColorSpaceSignature sig , char *cvals[] ) ;
#line 1827
void icmClamp3(double out[3] , double in[3] ) ;
#line 1830
void icmInv3(double out[3] , double in[3] ) ;
#line 1833
void icmAdd3(double out[3] , double in1[3] , double in2[3] ) ;
#line 1838
void icmSub3(double out[3] , double in1[3] , double in2[3] ) ;
#line 1843
void icmDiv3(double out[3] , double in1[3] , double in2[3] ) ;
#line 1848
void icmMul3(double out[3] , double in1[3] , double in2[3] ) ;
#line 1853
void icmPow3(double out[3] , double in[3] , double p ) ;
#line 1856
void icmSqr3(double out[3] , double in[3] ) ;
#line 1859
void icmSqrt3(double out[3] , double in[3] ) ;
#line 1862
void icmAbs3(double out[3] , double in[3] ) ;
#line 1868
double icmDot3(double in1[3] , double in2[3] ) ;
#line 1873
void icmCross3(double out[3] , double in1[3] , double in2[3] ) ;
#line 1876
double icmNorm3sq(double in[3] ) ;
#line 1881
double icmNorm3(double in[3] ) ;
#line 1886
void icmScale3(double out[3] , double in[3] , double rat ) ;
#line 1891
void icmScaleAdd3(double out[3] , double in2[3] , double in1[3] , double rat ) ;
#line 1894
void icmBlend3(double out[3] , double in0[3] , double in1[3] , double bf ) ;
#line 1897
void icmClip3(double out[3] , double in[3] ) ;
#line 1901
int icmClip3sig(double out[3] , double in[3] ) ;
#line 1905
double icmClip3marg(double out[3] , double in[3] ) ;
#line 1908
int icmNormalize3(double out[3] , double in[3] , double len ) ;
#line 1911
double icmNorm33sq(double in1[3] , double in0[3] ) ;
#line 1914
double icmNorm33(double in1[3] , double in0[3] ) ;
#line 1917
void icmScale33(double out[3] , double in1[3] , double in0[3] , double rat ) ;
#line 1922
int icmNormalize33(double out[3] , double in1[3] , double in0[3] , double len ) ;
#line 1925
void icmDump3x3(FILE *fp , char *id , char *pfx , double a[3][3] ) ;
#line 1928
void icmSetVal3x3(double mat[3][3] , double val ) ;
#line 1931
void icmSetUnity3x3(double mat[3][3] ) ;
#line 1934
void icmCpy3x3(double out[3][3] , double mat[3][3] ) ;
#line 1937
void icmAdd3x3(double dst[3][3] , double src1[3][3] , double src2[3][3] ) ;
#line 1940
void icmScale3x3(double dst[3][3] , double src[3][3] , double scale ) ;
#line 1944
void icmMulBy3x3(double out[3] , double mat[3][3] , double in[3] ) ;
#line 1948
void icmTensMul3(double dst[3][3] , double src1[3] , double src2[3] ) ;
#line 1952
void icmMul3x3(double dst[3][3] , double src[3][3] ) ;
#line 1956
void icmMul3x3_2(double dst[3][3] , double src1[3][3] , double src2[3][3] ) ;
#line 1959
double icmDet3x3(double in[3][3] ) ;
#line 1962
int icmInverse3x3(double out[3][3] , double in[3][3] ) ;
#line 1965
void icmTranspose3x3(double out[3][3] , double in[3][3] ) ;
#line 1970
void icmRotMat(double mat[3][3] , double src[3] , double targ[3] ) ;
#line 1973
void icmCpy3x4(double out[3][4] , double mat[3][4] ) ;
#line 1976
void icmMul3By3x4(double out[3] , double mat[3][4] , double in[3] ) ;
#line 1981
void icmVecRotMat(double m[3][4] , double s1[3] , double s0[3] , double t1[3] , double t0[3] ) ;
#line 1986
int icmVecPlaneIsect(double isect[3] , double pl_const , double pl_norm[3] , double ve_1[3] ,
                     double ve_0[3] ) ;
#line 1990
int icmLinePointClosest(double ca[3] , double *pa , double la0[3] , double la1[3] ,
                        double pp[3] ) ;
#line 1996
int icmLineLineClosest(double ca[3] , double cb[3] , double *pa , double *pb , double la0[3] ,
                       double la1[3] , double lb0[3] , double lb1[3] ) ;
#line 2003
int icmPlaneEqn3(double eq[4] , double p0[3] , double p1[3] , double p2[3] ) ;
#line 2007
double icmPlaneDist3(double eq[4] , double p[3] ) ;
#line 2013
void icmMulBy4x4(double out[4] , double mat[4][4] , double in[4] ) ;
#line 2016
void icmTranspose4x4(double out[4][4] , double in[4][4] ) ;
#line 2020
double icmClip4marg(double out[4] , double in[4] ) ;
#line 2029
double icmNorm22(double in1[2] , double in0[2] ) ;
#line 2032
double icmNorm22sq(double in1[2] , double in0[2] ) ;
#line 2035
double icmDot2(double in1[2] , double in2[2] ) ;
#line 2041
double icmDot22(double in1[2] , double in2[2] , double in3[2] , double in4[2] ) ;
#line 2044
int icmNormalize2(double out[2] , double in[2] , double len ) ;
#line 2047
void icmOrthog2(double out[2] , double in[2] ) ;
#line 2053
int icmPlaneEqn2(double eq[3] , double p0[2] , double p1[2] ) ;
#line 2057
double icmPlaneDist2(double eq[3] , double p[2] ) ;
#line 2061
double icmImpLinePointClosest2(double cp[2] , double eq[3] , double pp[2] ) ;
#line 2065
int icmImpLineIntersect2(double res[2] , double eq1[3] , double eq2[3] ) ;
#line 2071
int icmLinePointClosest2(double cp[2] , double *pa , double la0[2] , double la1[2] ,
                         double pp[2] ) ;
#line 2076
int icmLineIntersect2(double res[2] , double p1[2] , double p2[2] , double p3[2] ,
                      double p4[2] ) ;
#line 2082
int icmParmLineIntersect2(double ares[2] , double aprm[2] , double p1[2] , double p2[2] ,
                          double p3[2] , double p4[2] ) ;
#line 2085
void icmSetUnity2x2(double mat[2][2] ) ;
#line 2088
int icmInverse2x2(double out[2][2] , double in[2][2] ) ;
#line 2091
void icmMulBy2x2(double out[2] , double mat[2][2] , double in[2] ) ;
#line 2094
void icmBlend2(double out[2] , double in0[2] , double in1[2] , double bf ) ;
#line 2097
void icmScale2(double out[2] , double in[2] , double rat ) ;
#line 2100
void icmScaleAdd2(double out[2] , double in2[3] , double in1[2] , double rat ) ;
#line 2120
double icmY2L(double val ) ;
#line 2123
double icmL2Y(double val ) ;
#line 2126
extern void icmXYZ2Lab(icmXYZNumber *w , double *out , double *in ) ;
#line 2129
extern void icmLab2XYZ(icmXYZNumber *w , double *out , double *in ) ;
#line 2132
extern void icmXYZ2Lpt(icmXYZNumber *w , double *out , double *in ) ;
#line 2135
extern void icmLpt2XYZ(icmXYZNumber *w , double *out , double *in ) ;
#line 2138
extern void icmLCh2Lab(double *out , double *in ) ;
#line 2141
extern void icmLab2LCh(double *out , double *in ) ;
#line 2145
extern void icmXYZ2Luv(icmXYZNumber *w , double *out , double *in ) ;
#line 2148
extern void icmLuv2XYZ(icmXYZNumber *w , double *out , double *in ) ;
#line 2152
extern void icmXYZ2Yxy(double *out , double *in ) ;
#line 2155
extern void icmYxy2XYZ(double *out , double *in ) ;
#line 2158
extern void icmXYZ2xy(double *out , double *in ) ;
#line 2161
extern void icmY_xy2XYZ(double *out , double *xy , double Y ) ;
#line 2166
extern void icmXYZ21976UCS(double *out , double *in ) ;
#line 2169
extern void icm1976UCS2XYZ(double *out , double *in ) ;
#line 2173
extern void icmXYZ21976UCSuv(double *out , double *in ) ;
#line 2176
extern void icm1976UCSY_uv2XYZ(double *out , double *uv , double Y ) ;
#line 2188
extern void icmXYZ21960UCS(double *out , double *in ) ;
#line 2191
extern void icm1960UCS2XYZ(double *out , double *in ) ;
#line 2196
extern void icmXYZ21964WUV(icmXYZNumber *w , double *out , double *in ) ;
#line 2199
extern void icm1964WUV2XYZ(icmXYZNumber *w , double *out , double *in ) ;
#line 2202
extern void icm1960UCS21964WUV(icmXYZNumber *w , double *out , double *in ) ;
#line 2208
extern icmXYZNumber icmD50 ;
#line 2209
extern icmXYZNumber icmD50_100 ;
#line 2210
extern double icmD50_ary3[3] ;
#line 2211
extern double icmD50_100_ary3[3] ;
#line 2214
extern icmXYZNumber icmD65 ;
#line 2215
extern icmXYZNumber icmD65_100 ;
#line 2216
extern double icmD65_ary3[3] ;
#line 2217
extern double icmD65_100_ary3[3] ;
#line 2221
extern icmXYZNumber icmBlack ;
#line 2224
extern double icmWrongVonKries[3][3] ;
#line 2227
extern double icmBradford[3][3] ;
#line 2230
extern unsigned int psh_init(psh *p , int di , unsigned int res , int co[] ) ;
#line 2233
extern void psh_reset(psh *p ) ;
#line 2237
extern int psh_inc(psh *p , int co[] ) ;
#line 2242
extern double icmLabDE(double *in0 , double *in1 ) ;
#line 2245
extern double icmLabDEsq(double *in0 , double *in1 ) ;
#line 2248
extern double icmXYZLabDEsq(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2251
extern double icmXYZLabDE(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2254
extern double icmXYZLptDEsq(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2257
extern double icmXYZLptDE(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2261
extern double icmCIE94(double *in0 , double *in1 ) ;
#line 2264
extern double icmCIE94sq(double *in0 , double *in1 ) ;
#line 2267
extern double icmXYZCIE94(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2271
extern double icmCIE2K(double *in0 , double *in1 ) ;
#line 2274
extern double icmCIE2Ksq(double *in0 , double *in1 ) ;
#line 2277
extern double icmXYZCIE2K(icmXYZNumber *w , double *in0 , double *in1 ) ;
#line 2283
int icmClipLab(double out[3] , double in[3] ) ;
#line 2287
int icmClipXYZ(double out[3] , double in[3] ) ;
#line 2294
int icmRGBXYZprim2matrix(double red[3] , double green[3] , double blue[3] , double white[3] ,
                         double mat[3][3] ) ;
#line 2305
int icmRGBYxyprim2matrix(double red[3] , double green[3] , double blue[3] , double white[3] ,
                         double mat[3][3] , double wXYZ[3] ) ;
#line 2327
void icmChromAdaptMatrix(int flags , icmXYZNumber d_wp , icmXYZNumber s_wp , double mat[3][3] ) ;
#line 2337
void quantizeRGBprimsS15Fixed16(double mat[3][3] ) ;
#line 2345
void icmQuantize3x3S15Fixed16(double targ[3] , double mat[3][3] , double in[3] ) ;
#line 2355
void icmLut2YCbCr(double *out , double *in ) ;
#line 2358
void icmYCbCr2Lut(double *out , double *in ) ;
#line 2363
void icmRec601_RGBd_2_YPbPr(double out[3] , double in[3] ) ;
#line 2367
void icmRec601_YPbPr_2_RGBd(double out[3] , double in[3] ) ;
#line 2372
void icmRec709_RGBd_2_YPbPr(double out[3] , double in[3] ) ;
#line 2376
void icmRec709_YPbPr_2_RGBd(double out[3] , double in[3] ) ;
#line 2380
void icmRec709_50_RGBd_2_YPbPr(double out[3] , double in[3] ) ;
#line 2384
void icmRec709_50_YPbPr_2_RGBd(double out[3] , double in[3] ) ;
#line 2389
void icmRec2020_NCL_RGBd_2_YPbPr(double out[3] , double in[3] ) ;
#line 2393
void icmRec2020_NCL_YPbPr_2_RGBd(double out[3] , double in[3] ) ;
#line 2397
void icmRec2020_CL_RGBd_2_YPbPr(double out[3] , double in[3] ) ;
#line 2401
void icmRec2020_CL_YPbPr_2_RGBd(double out[3] , double in[3] ) ;
#line 2407
void icmRecXXX_YPbPr_2_YCbCr(double out[3] , double in[3] ) ;
#line 2412
void icmRecXXX_YCbCr_2_YPbPr(double out[3] , double in[3] ) ;
#line 2416
void icmRGB_2_VidRGB(double out[3] , double in[3] ) ;
#line 2419
void icmVidRGB_2_RGB(double out[3] , double in[3] ) ;
#line 2426
double icmDICOM_fwd(double jnd ) ;
#line 2429
double icmDICOM_bwd(double L ) ;
#line 2437
void icmRad2RGB(double rgb[3] , double ang ) ;
#line 2442
char *icmPiv(int di , int *p ) ;
#line 2446
char *icmPdv(int di , double *p ) ;
#line 2450
char *icmPfv(int di , float *p ) ;
#line 2454
char *icmPLab(double *p ) ;
#line 53 "xicc/xspect.h"
char *meas_type2str(inst_meas_type mt ) ;
#line 66
char *meas_cond2str(inst_meas_cond mc ) ;
#line 142
int write_xspect(char *fname , inst_meas_type mt , inst_meas_cond mc , xspect *s ) ;
#line 144
int read_xspect(xspect *sp , inst_meas_type *mt , inst_meas_cond *mc , char *fname ) ;
#line 146
int write_C_xspect(char *fname , xspect *s ) ;
#line 154
int write_xspect_1(cgats **ocgp , inst_meas_type mt , inst_meas_cond mc , xspect *s ) ;
#line 157
int write_xspect_2(cgats *ocg , char *fname ) ;
#line 160
int read_xspect_1(cgats **picg , xspect *sp , inst_meas_type *mt , inst_meas_cond *mc ,
                  char *fname ) ;
#line 163
int read_xspect_2(cgats *icg ) ;
#line 167
int write_nxspect(char *fname , inst_meas_type mt , inst_meas_cond mc , xspect *sp ,
                  int nspec , int type ) ;
#line 172
int read_nxspect(xspect *sp , inst_meas_type *mt , inst_meas_cond *mc , char *fname ,
                 int *nret , int off , int nspec , int type ) ;
#line 177
int write_nxspect_1(cgats **pocg , inst_meas_type mt , inst_meas_cond mc , xspect *sp ,
                    int nspec , int type ) ;
#line 179
int write_nxspect_2(cgats *ocg , char *fname ) ;
#line 180
int read_nxspect_1(cgats **picg , xspect *sp , inst_meas_type *mt , inst_meas_cond *mc ,
                   char *fname , int *nret , int off , int nspec , int type ) ;
#line 182
int read_nxspect_2(cgats *icg ) ;
#line 188
int write_cmf(char *fname , xspect cmf[3] ) ;
#line 189
int read_cmf(xspect cmf[3] , char *fname ) ;
#line 195
int getval_xspec(xspect *sp , double *rv , double wl ) ;
#line 198
double value_xspect(xspect *sp , double wl ) ;
#line 201
double value_xspect_lin(xspect *sp , double wl ) ;
#line 204
double value_xspect_poly(xspect *sp , double wl ) ;
#line 208
void xspect_denorm(xspect *sp ) ;
#line 211
void xspect_scale(xspect *sp , double scale ) ;
#line 215
void xspect2xspect_wloff(xspect *dst , xspect *targ , xspect *src , double wloff ) ;
#line 218
void xspect2xspect(xspect *dst , xspect *targ , xspect *src ) ;
#line 221
void xspect_dump(xspect *sp ) ;
#line 224
void xspect_plot_w(xspect *sp1 , xspect *sp2 , xspect *sp3 , int wait ) ;
#line 227
void xspect_plot(xspect *sp1 , xspect *sp2 , xspect *sp3 ) ;
#line 230
void xspect_plotN(xspect *sp , int n ) ;
#line 233
void xspect_plotNp(xspect *sp[16] , int n ) ;
#line 236
void xspect_plotNp_w(xspect *sp[16] , int n , int wait ) ;
#line 275
int standardIlluminant(xspect *sp , icxIllumeType ilType , double temp ) ;
#line 282
char *standardIlluminant_name(icxIllumeType ilType , double temp ) ;
#line 289
void xsp_setUV(xspect *out , xspect *in , double uvlevel ) ;
#line 295
int planckian_il_sp(xspect *sp , double ct ) ;
#line 301
static int planckian_il(xspect *sp , double ct ) ;
#line 323
int standardObserver(xspect *sp[3] , icxObserverType obType ) ;
#line 326
char *standardObserverDescription(icxObserverType obType ) ;
#line 479
xsp2cie *new_xsp2cie(icxIllumeType ilType , double temp , xspect *custIllum , icxObserverType obType ,
                     xspect custObserver[3] , icColorSpaceSignature rcs , icxClamping clamp ) ;
#line 499
int icx_sp2XYZ(double xyz[3] , icxObserverType obType , xspect custObserver[3] , icxIllumeType ilType ,
               double ct , xspect *custIllum , xspect *sp ) ;
#line 513
int icx_ill_sp2XYZ(double xyz[3] , icxObserverType obType , xspect custObserver[3] ,
                   icxIllumeType ilType , double temp , xspect *custIllum , int abs ) ;
#line 533
double icx_XYZ2ill_ct2(double txyz[3] , icxIllumeType ilType , icxObserverType obType ,
                       double xyz[3] , int viscct ) ;
#line 547
void icx_ill_ct2XYZ(double xyz[3] , icxIllumeType ilType , icxObserverType obType ,
                    int viscct , double tin , double Yin ) ;
#line 561
int icx_spectrum_locus_range(double *min_wl , double *max_wl , icxObserverType obType ) ;
#line 567
int icx_spectrum_locus(double xyz[3] , double in , icxObserverType obType ) ;
#line 583
xslpoly *chrom_locus_poligon(icxLocusType locus_type , icxObserverType obType , int cspace ) ;
#line 589
int icx_outside_spec_locus(xslpoly *p , double xyz[3] ) ;
#line 599
double icx_XYZ2ill_ct(double txyz[3] , icxIllumeType ilType , icxObserverType obType ,
                      xspect custObserver[3] , double xyz[3] , xspect *insp0 , int viscct ) ;
#line 612
double icx_CIE1995_CRI(int *invalid , double cris[14] , xspect *sample ) ;
#line 622
double icx_EBU2012_TLCI(int *invalid , xspect *sample ) ;
#line 37 "xicc/tm3015.h"
int icx_IES_TM_30_15(double *pRf , double *pRg , double *pcct , double *pdc , double pbins[16][2][3] ,
                     xspect *tsamp ) ;
#line 632 "xicc/xspect.h"
double icx_ARPANSA_UV_exp(xspect *sample ) ;
#line 637
double aprox_CCT(double xyz[3] ) ;
#line 642
void aprox_plankian(double Yxy[3] , double ct ) ;
#line 649
void xsp_density(double out[4] , xspect *in , icxDensityType dt ) ;
#line 656
char *xsp_density_desc(icxDensityType dt ) ;
#line 660
void icx_XYZ2Tdens(double *out , double *in ) ;
#line 667
void icx_XYZ2dens(double *out , double *in ) ;
#line 674
void icx_XYZ2sRGB(double *out , double *wp , double *in ) ;
#line 682
void icx_sRGB2XYZ(double *out , double *wp , double *in ) ;
#line 690
void icx_XYZ2RGB_ds(double *out , double *in , double desat ) ;
#line 698
void icx_wl2RGB_ds(double *out , double wl , double desat ) ;
#line 101 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/insttypes.h"
extern char *inst_sname(instType itype ) ;
#line 105
extern char *inst_name(instType itype ) ;
#line 110
extern instType inst_enum(char *name ) ;
#line 117
extern instType inst_usb_match(unsigned int idVendor , unsigned int idProduct , int nep ) ;
#line 131
extern int inst_illuminant(xspect *sp , instType itype ) ;
#line 146
char *xcalstd2str(xcalstd std ) ;
#line 150
xcalstd str2xcalstd(char *str ) ;
#line 200 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/usbio.h"
int usb_get_paths(struct _icompaths *p ) ;
#line 202
void usb_close_port(icoms *p ) ;
#line 205
void usb_set_usb_methods(icoms *p ) ;
#line 209
int usb_copy_usb_idevice(icoms *d , icompath *s ) ;
#line 212
void usb_del_usb_idevice(struct usb_idevice *dev ) ;
#line 215
void usb_del_usb(icoms *p ) ;
#line 219
void usb_install_signal_handlers(icoms *p ) ;
#line 223
void usb_delete_from_cleanup_list(icoms *p ) ;
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/hidio.h"
int hid_get_paths(struct _icompaths *p ) ;
#line 40
void hid_close_port(icoms *p ) ;
#line 43
void hid_set_hid_methods(icoms *p ) ;
#line 47
int hid_copy_hid_idevice(icoms *d , icompath *s ) ;
#line 50
void hid_del_hid_idevice(struct hid_idevice *hidd ) ;
#line 53
void hid_del_hid(icoms *p ) ;
#line 166 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/icoms.h"
extern icompath icomFakeDevice ;
#line 257
icompaths *new_icompaths(a1log *log ) ;
#line 260
icompaths *new_icompaths_sel(a1log *log , icom_type mask ) ;
#line 294
char *baud_rate_to_str(baud_rate br ) ;
#line 330
void usb_init_cancel(usb_cancelt *p ) ;
#line 331
void usb_uninit_cancel(usb_cancelt *p ) ;
#line 332
void usb_reinit_cancel(usb_cancelt *p ) ;
#line 599
extern icoms *new_icoms(icompath *ipath , a1log *log ) ;
#line 606
char *icoms_fix(char *s ) ;
#line 609
char *icoms_tohex(unsigned char *s , int len ) ;
#line 615
int icoms_ser_write(icoms *p , char *wbuf , int nwch , double tout ) ;
#line 616
int icoms_ser_read(icoms *p , char *rbuf , int bsize , int *bread , char *tc , int ntc ,
                   double tout ) ;
#line 623 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
int next_con_char(void) 
{ 
  struct pollfd pa[1] ;
  struct termios origs ;
  struct termios news ;
  char rv ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  char tb[3] ;
  ssize_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 626
  rv = (char )0;
#line 628
  if (! not_interactive) {
    {
#line 630
    __cil_tmp5 = tcgetattr(0, & origs);
    }
#line 630
    if (__cil_tmp5 < 0) {
      {
#line 631
      __cil_tmp6 = __errno_location();
#line 631
      __cil_tmp7 = strerror(*__cil_tmp6);
#line 631
      a1logw(g_log, "next_con_char: tcgetattr failed with \'%s\' on stdin", __cil_tmp7);
      }
    }
    {
#line 632
    news = origs;
#line 633
    news.c_lflag &= (unsigned int )(~ 10);
#line 634
    news.c_cc[5] = (cc_t )0;
#line 635
    news.c_cc[6] = (cc_t )1;
#line 636
    __cil_tmp8 = tcsetattr(0, 0, & news);
    }
#line 636
    if (__cil_tmp8 < 0) {
      {
#line 637
      __cil_tmp9 = __errno_location();
#line 637
      __cil_tmp10 = strerror(*__cil_tmp9);
#line 637
      a1logw(g_log, "next_con_char: tcsetattr failed with \'%s\' on stdin", __cil_tmp10);
      }
    }
  }
  {
#line 641
  pa[0].fd = 0;
#line 642
  pa[0].events = (short )3;
#line 643
  pa[0].revents = (short )0;
#line 645
  __cil_tmp11 = pollem((struct pollfd *)pa, (unsigned long )1, - 1);
  }
#line 645
  if (__cil_tmp11 > 0) {
#line 645
    if ((int )pa[0].revents == 1) {
      _L___6: /* CIL Label */ 
      {
#line 649
      __cil_tmp13 = read(0, (char *)tb, (size_t )1);
      }
#line 649
      if (__cil_tmp13 > 0L) {
#line 650
        rv = tb[0];
      }
    } else
#line 645
    if ((int )pa[0].revents == 2) {
#line 645
      goto _L___6;
    } else {
#line 645
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 653
    if (! not_interactive) {
      {
#line 654
      tcsetattr(0, 0, & origs);
      }
    }
    {
#line 655
    a1logw(g_log, "next_con_char: poll on stdin returned unexpected value 0x%x", (int )pa[0].revents);
    }
  }
  {
#line 659
  __cil_tmp14 = tcsetattr(0, 0, & origs);
  }
#line 659
  if (! not_interactive) {
#line 659
    if (__cil_tmp14 < 0) {
      {
#line 660
      __cil_tmp15 = __errno_location();
#line 660
      __cil_tmp16 = strerror(*__cil_tmp15);
#line 660
      a1logw(g_log, "next_con_char: tcsetattr failed with \'%s\' on stdin", __cil_tmp16);
      }
    }
  }
#line 663
  return ((int )rv);
}
}
#line 668 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
int poll_con_char(void) 
{ 
  struct pollfd pa[1] ;
  struct termios origs ;
  struct termios news ;
  char rv ;
  int __cil_tmp5 ;
  int *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  char tb[3] ;
  ssize_t __cil_tmp13 ;
  int __cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 671
  rv = (char )0;
#line 673
  if (! not_interactive) {
    {
#line 675
    __cil_tmp5 = tcgetattr(0, & origs);
    }
#line 675
    if (__cil_tmp5 < 0) {
      {
#line 676
      __cil_tmp6 = __errno_location();
#line 676
      __cil_tmp7 = strerror(*__cil_tmp6);
#line 676
      a1logw(g_log, "poll_con_char: tcgetattr failed with \'%s\' on stdin", __cil_tmp7);
      }
    }
    {
#line 677
    news = origs;
#line 678
    news.c_lflag &= (unsigned int )(~ 10);
#line 679
    news.c_cc[5] = (cc_t )0;
#line 680
    news.c_cc[6] = (cc_t )1;
#line 681
    __cil_tmp8 = tcsetattr(0, 0, & news);
    }
#line 681
    if (__cil_tmp8 < 0) {
      {
#line 682
      __cil_tmp9 = __errno_location();
#line 682
      __cil_tmp10 = strerror(*__cil_tmp9);
#line 682
      a1logw(g_log, "poll_con_char: tcsetattr failed with \'%s\' on stdin", __cil_tmp10);
      }
    }
  }
  {
#line 686
  pa[0].fd = 0;
#line 687
  pa[0].events = (short )3;
#line 688
  pa[0].revents = (short )0;
#line 690
  __cil_tmp11 = pollem((struct pollfd *)pa, (unsigned long )1, 0);
  }
#line 690
  if (__cil_tmp11 > 0) {
#line 690
    if ((int )pa[0].revents == 1) {
      _L: /* CIL Label */ 
      {
#line 694
      __cil_tmp13 = read(0, (char *)tb, (size_t )1);
      }
#line 694
      if (__cil_tmp13 > 0L) {
#line 695
        rv = tb[0];
      }
    } else
#line 690
    if ((int )pa[0].revents == 2) {
#line 690
      goto _L;
    }
  }
  {
#line 700
  __cil_tmp14 = tcsetattr(0, 0, & origs);
  }
#line 700
  if (! not_interactive) {
#line 700
    if (__cil_tmp14 < 0) {
      {
#line 701
      __cil_tmp15 = __errno_location();
#line 701
      __cil_tmp16 = strerror(*__cil_tmp15);
#line 701
      a1logw(g_log, "poll_con_char: tcsetattr failed with \'%s\' on stdin", __cil_tmp16);
      }
    }
  }
#line 703
  return ((int )rv);
}
}
#line 708 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
void empty_con_chars(void) 
{ 


  {
#line 709
  if (not_interactive) {
#line 710
    return;
  }
  {
#line 712
  tcflush(0, 0);
  }
  return;
}
}
#line 717 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
int acond_timedwait_imp(pthread_cond_t *cond , pthread_mutex_t *lock , int msec ) 
{ 
  struct timeval tv ;
  struct timespec ts ;
  int rv ;
  __time_t __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 723
  gettimeofday(& tv, (void *)0);
#line 724
  ts.tv_sec = tv.tv_sec + (long )(msec / 1000);
#line 725
  ts.tv_nsec = (tv.tv_usec + (long )((msec % 1000) * 1000)) * 1000L;
  }
#line 726
  if (ts.tv_nsec > 1000000000L) {
#line 727
    ts.tv_nsec -= 1000000000L;
#line 728
    (ts.tv_sec) ++;
  }
  {
#line 731
  rv = pthread_cond_timedwait(cond, lock, & ts);
  }
#line 733
  return (rv);
}
}
#line 820 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static athread *beep_thread  =    (athread *)((void *)0);
#line 821
static int beep_delay ;
#line 822
static int beep_freq ;
#line 823
static int beep_msec ;
#line 826 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static int delayed_beep(void *pp ) 
{ 


  {
  {
#line 827
  msec_sleep((unsigned int )beep_delay);
#line 828
  a1logd(g_log, 8, "msec_beep activate\n\026\313U");
#line 840
  fprintf(stdout, "\aK\203\026\313U");
#line 840
  fflush(stdout);
  }
#line 842
  return (0);
}
}
#line 846 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
void msec_beep(int delay , int freq , int msec ) 
{ 
  athread *__cil_tmp4 ;

  {
  {
#line 847
  a1logd(g_log, 8, "msec_beep %d msec\n\203\026\313U", msec);
  }
#line 848
  if (delay > 0) {
#line 849
    if (beep_thread != (void *)0) {
      {
#line 850
      (*(beep_thread->del))(beep_thread);
      }
    }
    {
#line 851
    beep_delay = delay;
#line 852
    beep_freq = freq;
#line 853
    beep_msec = msec;
#line 854
    beep_thread = new_athread_reusable(& delayed_beep, (void *)0, 0);
    }
#line 854
    if (beep_thread == (void *)0) {
      {
#line 855
      a1logw(g_log, "msec_beep: Delayed beep failed to create thread\n\220");
      }
    }
  } else {
    {
#line 857
    a1logd(g_log, 8, "msec_beep activate\n\026\313U");
#line 865
    fprintf(stdout, "\a");
#line 865
    fflush(stdout);
    }
  }
  return;
}
}
#line 917 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static void athread_start(athread *p ) 
{ 


  {

#line 921
  if (! p->reusable) {
#line 922
    return;
  }
  {
#line 925
  pthread_mutex_lock(& p->startm);
#line 926
  p->startv = 1;
#line 927
  pthread_cond_signal(& p->startc);
#line 928
  pthread_mutex_unlock(& p->startm);
  }
  return;
}
}
#line 932 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static int athread_wait_stop(athread *p ) 
{ 


  {

#line 936
  if (! p->reusable) {
#line 937
    return (p->result);
  }
  {
#line 940
  pthread_mutex_lock(& p->stopm);
  }
  {
#line 941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 941
    if (! (p->stopv == 0)) {
#line 941
      goto while_break;
    }
    {
#line 942
    pthread_cond_wait(& p->stopc, & p->stopm);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 943
  p->stopv = 0;
#line 944
  pthread_mutex_unlock(& p->stopm);
  }
#line 946
  return (p->result);
}
}
#line 950 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static int athread_wait(struct _athread *p ) 
{ 
  int rv ;
  int __cil_tmp3 ;

  {
#line 953
  if (p->reusable) {
    {
#line 954
    p->dofinish = 1;
#line 955
    athread_start(p);
    }
  }
#line 958
  if (p->joined) {
#line 959
    return (p->result);
  }
  {
#line 961
  rv = pthread_join(p->thid, (void **)((void *)0));
  }
#line 961
  if (rv != 0) {
    {
#line 962
    warning("pthread_join of thid %d failed with %d", p->thid, rv);
    }
  }
#line 963
  p->joined = 1;
#line 965
  return (p->result);
}
}
#line 969 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static void athread_terminate(athread *p ) 
{ 


  {

#line 974
  if (p == (void *)0) {
#line 975
    return;
  } else
#line 974
  if (p->joined) {
#line 975
    return;
  }
#line 977
  if (p->thid != 0UL) {
    {
#line 979
    pthread_cancel(p->thid);
    }
  }
#line 982
  p->joined = 1;
  return;
}
}
#line 986 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static void athread_del(athread *p ) 
{ 
  int rv ;
  int __cil_tmp3 ;

  {

#line 991
  if (p == (void *)0) {
#line 992
    return;
  }
#line 994
  if (p->thid != 0UL) {
#line 994
    if (! p->joined) {
      {
#line 996
      rv = pthread_join(p->thid, (void **)((void *)0));
      }
#line 996
      if (rv != 0) {
        {
#line 997
        warning("pthread_join of thid %d failed with %d", p->thid, rv);
        }
      }
    }
  }
#line 1000
  if (p->reusable) {
    {
#line 1001
    pthread_cond_destroy(& p->startc);
#line 1002
    pthread_mutex_destroy(& p->startm);
#line 1003
    pthread_cond_destroy(& p->stopc);
#line 1004
    pthread_mutex_destroy(& p->stopm);
    }
  }
  {
#line 1007
  free(p);
  }
  return;
}
}
#line 1010 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
static void *threadproc(void *param ) 
{ 
  athread *p ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 1013
  p = (athread *)param;
#line 1021
  if (p->reusable) {
    {
#line 1022
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1022
      if (! 1) {
#line 1022
        goto while_break;
      }
      {
#line 1025
      pthread_mutex_lock(& p->startm);
      }
      {
#line 1026
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1026
        if (! (p->startv == 0)) {
#line 1026
          goto while_break___0;
        }
        {
#line 1027
        pthread_cond_wait(& p->startc, & p->startm);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1028
      p->startv = 0;
#line 1029
      pthread_mutex_unlock(& p->startm);
      }
#line 1031
      if (p->dofinish) {
#line 1032
        goto while_break;
      }
      {
#line 1034
      p->result = (*(p->function))(p->context);
#line 1037
      pthread_mutex_lock(& p->stopm);
#line 1038
      p->stopv = 1;
#line 1039
      pthread_cond_signal(& p->stopc);
#line 1040
      pthread_mutex_unlock(& p->stopm);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1044
    p->result = (*(p->function))(p->context);
    }
  }
#line 1048
  return ((void *)0);
}
}
#line 1052 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
athread *new_athread_reusable(int (*function)(void * ) , void *context , int reusable ) 
{ 
  int rv ;
  athread *p ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 1058
  p = (athread *)((void *)0);
#line 1062
  __cil_tmp6 = calloc(sizeof(athread ), (unsigned long )1);
#line 1062
  p = (athread *)__cil_tmp6;
  }
#line 1062
  if (p == (void *)0) {
    {
#line 1063
    a1loge(g_log, 1, "new_athread: calloc failed\n");
    }
#line 1064
    return ((athread *)((void *)0));
  }
#line 1067
  p->reusable = reusable;
#line 1068
  if (p->reusable) {
    {
#line 1069
    pthread_mutex_init(& p->startm, (pthread_mutexattr_t *)((void *)0));
#line 1070
    p->startv = 0;
#line 1071
    pthread_cond_init(& p->startc, (pthread_condattr_t *)((void *)0));
#line 1073
    pthread_mutex_init(& p->stopm, (pthread_mutexattr_t *)((void *)0));
#line 1074
    p->stopv = 0;
#line 1075
    pthread_cond_init(& p->stopc, (pthread_condattr_t *)((void *)0));
    }
  }
  {
#line 1078
  p->function = function;
#line 1079
  p->context = context;
#line 1080
  p->start = & athread_start;
#line 1081
  p->wait_stop = & athread_wait_stop;
#line 1082
  p->wait = & athread_wait;
#line 1083
  p->del = & athread_del;
#line 1107
  rv = pthread_create(& p->thid, (pthread_attr_t *)((void *)0), & threadproc, (void *)p);
  }
#line 1108
  if (rv != 0) {
    {
#line 1109
    a1loge(g_log, 1, "new_athread: pthread_create failed with %d\n", rv);
#line 1110
    p->thid = (pthread_t )0;
#line 1111
    athread_del(p);
    }
#line 1112
    return ((athread *)((void *)0));
  }

#line 1117
  return (p);
}
}
#line 1124 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
char *login_HOME(void) 
{ 
  __uid_t __cil_tmp1 ;
  char *uids ;
  char *__cil_tmp3 ;
  int uid ;
  struct passwd *pwd ;
  int __cil_tmp6 ;
  struct passwd *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1126
  __cil_tmp1 = getuid();
  }
#line 1126
  if (__cil_tmp1 == 0U) {
    {
#line 1129
    uids = getenv("SUDO_UID");
    }
#line 1129
    if (uids != (void *)0) {
      {
#line 1133
      uid = atoi((char const   *)uids);
#line 1135
      pwd = getpwuid((__uid_t )uid);
      }
#line 1135
      if (pwd != (void *)0) {
#line 1136
        return (pwd->pw_dir);
      }
    }
  }
  {
#line 1141
  __cil_tmp8 = getenv("HOME\313U");
  }
#line 1141
  return (__cil_tmp8);
}
}
#line 1146 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
void delete_file(char *fname ) 
{ 


  {
  {
#line 1147
  unlink((char const   *)fname);
  }
  return;
}
}
#line 1152 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
int create_parent_directories(char *path ) 
{ 
  struct stat sbuf ;
  char *pp ;
  mode_t mode ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1154
  pp = path;
#line 1155
  mode = (mode_t )448;
#line 1157
  if ((int )*pp == 47) {
#line 1158
    pp ++;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1159
    if (! (pp != (void *)0 && (int )*pp != 0)) {
#line 1159
      goto while_break;
    }
    {
#line 1160
    pp = strchr((char const   *)pp, '/');
    }
#line 1160
    if (pp != (void *)0) {
      {
#line 1161
      *pp = (char )'\000';
#line 1162
      __cil_tmp7 = stat((char const   *)path, & sbuf);
      }
#line 1162
      if (__cil_tmp7 != 0) {
        {
#line 1164
        __cil_tmp8 = mkdir((char const   *)path, mode);
        }
#line 1164
        if (__cil_tmp8 != 0) {
#line 1165
          return (1);
        }
      } else {
#line 1167
        mode = sbuf.st_mode;
      }
#line 1168
      *pp = (char )'/';
#line 1169
      pp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1172
  return (0);
}
}
#line 1178 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/conv.c"
int system_processors(void) 
{ 
  long __cil_tmp1 ;

  {
  {
#line 1179
  __cil_tmp1 = sysconf(84);
  }
#line 1179
  return ((int )__cil_tmp1);
}
}
#line 30 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/base64.h"
void ebase64(int *dlen , char *dst , unsigned char *src , int slen ) ;
#line 38
void dbase64(int *dlen , unsigned char *dst , char *src ) ;
#line 24 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/base64.c"
static int enc(int val ) 
{ 


  {
#line 25
  val &= 63;
#line 27
  if (val <= 25) {
#line 28
    return (65 + val);
  }
#line 29
  if (val <= 51) {
#line 30
    return ((97 + val) - 26);
  }
#line 31
  if (val <= 61) {
#line 32
    return ((48 + val) - 52);
  }
#line 33
  if (val == 62) {
#line 34
    return ('+');
  }
#line 35
  return ('/');
}
}
#line 41 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/base64.c"
void ebase64(int *dlen , char *dst , unsigned char *src , int slen ) 
{ 
  unsigned char buf[3] ;
  int i ;
  int j ;
  int ib ;
  int tmp ;
  int tmp___0 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 46
  i = 0;
#line 46
  j = i;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < slen)) {
#line 46
      goto while_break;
    }
#line 50
    buf[0] = *(src + i);
#line 50
    ib = 8;
#line 51
    if (i + 1 < slen) {
#line 51
      ib += 8;
#line 51
      tmp = (int )*(src + (i + 1));
    } else {
#line 51
      tmp = 0;
    }
#line 51
    buf[1] = (unsigned char )tmp;
#line 52
    if (i + 2 < slen) {
#line 52
      ib += 8;
#line 52
      tmp___0 = (int )*(src + (i + 2));
    } else {
#line 52
      tmp___0 = 0;
    }
#line 52
    buf[2] = (unsigned char )tmp___0;
#line 55
    __cil_tmp12 = j;
#line 55
    j ++;
    {
#line 55
    __cil_tmp11 = enc((int )buf[0] >> 2);
#line 55
    *(dst + j) = (char )__cil_tmp11;
    }
#line 56
    if (ib > 6) {
#line 57
      __cil_tmp14 = j;
#line 57
      j ++;
      {
#line 57
      __cil_tmp13 = enc(((int )buf[0] << 4) | ((int )buf[1] >> 4));
#line 57
      *(dst + j) = (char )__cil_tmp13;
      }
#line 58
      if (ib > 12) {
#line 59
        __cil_tmp16 = j;
#line 59
        j ++;
        {
#line 59
        __cil_tmp15 = enc(((int )buf[1] << 2) | ((int )buf[2] >> 6));
#line 59
        *(dst + j) = (char )__cil_tmp15;
        }
#line 60
        if (ib > 18) {
#line 61
          __cil_tmp18 = j;
#line 61
          j ++;
          {
#line 61
          __cil_tmp17 = enc((int )buf[2]);
#line 61
          *(dst + j) = (char )__cil_tmp17;
          }
        }
      }
    }
#line 46
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (dlen != (void *)0) {
#line 66
    *dlen = j;
  }
#line 68
  __cil_tmp19 = j;
#line 68
  j ++;
#line 68
  *(dst + __cil_tmp19) = (char )'\000';
  return;
}
}
#line 74 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/base64.c"
static int dec(int val ) 
{ 


  {
#line 75
  val &= 255;
#line 77
  if (val == 0) {
#line 78
    return (- 2);
  }
#line 79
  if (val == 43) {
#line 80
    return (62);
  }
#line 81
  if (val == 47) {
#line 82
    return (63);
  }
#line 83
  if (val < 48) {
#line 84
    return (- 1);
  }
#line 85
  if (val <= 57) {
#line 86
    return ((val - 48) + 52);
  }
#line 87
  if (val < 65) {
#line 88
    return (- 1);
  }
#line 89
  if (val <= 90) {
#line 90
    return (val - 65);
  }
#line 91
  if (val < 97) {
#line 92
    return (- 1);
  }
#line 93
  if (val <= 122) {
#line 94
    return ((val - 97) + 26);
  }
#line 95
  return (- 1);
}
}
#line 101 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/base64.c"
void dbase64(int *dlen , unsigned char *dst , char *src ) 
{ 
  int buf[4] ;
  int j ;
  int v ;
  int ib ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 106
  j = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! 1) {
#line 106
      goto while_break;
    }
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 110
      __cil_tmp8 = src;
#line 110
      src ++;
#line 110
      __cil_tmp9 = dec((int )*__cil_tmp8);
#line 110
      buf[0] = __cil_tmp9;
      }
#line 110
      if (! (buf[0] == -1)) {
#line 110
        goto while_break___0;
      }

    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    if (buf[0] == -2) {
#line 113
      goto while_break;
    }
#line 114
    ib = 6;
    {
#line 115
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 115
      __cil_tmp10 = src;
#line 115
      src ++;
#line 115
      __cil_tmp11 = dec((int )*__cil_tmp10);
#line 115
      buf[1] = __cil_tmp11;
      }
#line 115
      if (! (buf[1] == -1)) {
#line 115
        goto while_break___1;
      }

    }
    while_break___1: /* CIL Label */ ;
    }
#line 117
    if (buf[1] != -2) {
#line 118
      ib += 6;
      {
#line 119
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 119
        __cil_tmp12 = src;
#line 119
        src ++;
#line 119
        __cil_tmp13 = dec((int )*__cil_tmp12);
#line 119
        buf[2] = __cil_tmp13;
        }
#line 119
        if (! (buf[2] == -1)) {
#line 119
          goto while_break___2;
        }

      }
      while_break___2: /* CIL Label */ ;
      }
#line 121
      if (buf[2] != -2) {
#line 122
        ib += 6;
        {
#line 123
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 123
          __cil_tmp14 = src;
#line 123
          src ++;
#line 123
          __cil_tmp15 = dec((int )*__cil_tmp14);
#line 123
          buf[3] = __cil_tmp15;
          }
#line 123
          if (! (buf[3] == -1)) {
#line 123
            goto while_break___3;
          }

        }
        while_break___3: /* CIL Label */ ;
        }
#line 125
        if (buf[3] != -2) {
#line 126
          ib += 6;
        } else {
#line 128
          buf[3] = 0;
        }
      } else {
#line 130
        buf[2] = 0;
      }
    } else {
#line 132
      buf[1] = 0;
    }
#line 135
    __cil_tmp16 = j;
#line 135
    j ++;
#line 135
    *(dst + j) = (unsigned char )((buf[0] << 2) | (buf[1] >> 4));
#line 136
    if (ib > 12) {
#line 137
      __cil_tmp17 = j;
#line 137
      j ++;
#line 137
      *(dst + j) = (unsigned char )((buf[1] << 4) | (buf[2] >> 2));
#line 138
      if (ib > 18) {
#line 139
        __cil_tmp18 = j;
#line 139
        j ++;
#line 139
        *(dst + j) = (unsigned char )((buf[2] << 6) | buf[3]);
#line 140
        goto while_continue;
      }
    }
#line 143
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  if (dlen != (void *)0) {
#line 146
    *dlen = j;
  }
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 84 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.c"
int aglob_create(aglob *g , char *spath ) 
{ 
  char *tpath ;
  char *d ;
  char *s ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  unsigned short const   **__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 109
  __cil_tmp6 = strlen((char const   *)spath);
#line 109
  __cil_tmp7 = malloc(4UL * __cil_tmp6 + 1UL);
#line 109
  tpath = __cil_tmp7;
  }
#line 109
  if (tpath == (void *)0) {
    {
#line 110
    a1loge(g_log, 1, "aglob_create: malloc failed\n");
    }
#line 111
    return (1);
  }
  {
#line 113
  strcpy(tpath, (char const   *)spath);
#line 116
  s = strrchr((char const   *)spath, '.');
  }
#line 116
  if (s != (void *)0) {
#line 117
    d = tpath + (s - spath);
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      if (! ((int )*s != 0)) {
#line 118
        goto while_break;
      }
      {
#line 119
      __cil_tmp9 = __ctype_b_loc();
      }
#line 119
      if ((int )*(*__cil_tmp9 + (int )*s) & 1024) {
#line 120
        __cil_tmp10 = d;
#line 120
        d ++;
#line 120
        *__cil_tmp10 = (char )'[';
#line 121
        __cil_tmp11 = d;
#line 121
        d ++;
#line 121
        *__cil_tmp11 = (char )0;
#line 122
        __cil_tmp12 = d;
#line 122
        d ++;
#line 122
        *__cil_tmp12 = (char )0;
#line 123
        __cil_tmp13 = d;
#line 123
        d ++;
#line 123
        *__cil_tmp13 = (char )']';
      } else {
#line 125
        __cil_tmp15 = s;
#line 125
        s ++;
#line 125
        __cil_tmp14 = d;
#line 125
        d ++;
#line 125
        *__cil_tmp14 = *__cil_tmp15;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 128
    __cil_tmp16 = d;
#line 128
    d ++;
#line 128
    *__cil_tmp16 = (char )'\000';
  }
  {
#line 131
  memset(& g->g, 0, sizeof(g->g));
#line 132
  g->rv = glob((char const   *)tpath, 1 << 2, (int (*)(char const   * , int  ))((void *)0),
               & g->g);
#line 133
  free(tpath);
#line 134
  a1logd(g_log, 2, " glob \'%s\' returns %d and gl_pathc %d\n", spath, g->rv, g->g.gl_pathc);
  }
#line 135
  if (g->rv == 1) {
    {
#line 136
    a1loge(g_log, 1, "aglob_create: glob returned GLOB_NOSPACE\n");
    }
#line 137
    return (1);
  }
#line 139
  g->ix = (size_t )0;
#line 141
  g->merr = 0;
#line 142
  return (0);
}
}
#line 147 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.c"
char *aglob_next(aglob *g ) 
{ 
  char *fpath ;
  char *__cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
#line 171
  if (g->rv != 0) {
#line 172
    return ((char *)((void *)0));
  } else
#line 171
  if (g->ix >= g->g.gl_pathc) {
#line 172
    return ((char *)((void *)0));
  }
  {
#line 173
  fpath = strdup((char const   *)*(g->g.gl_pathv + g->ix));
  }
#line 173
  if (fpath == (void *)0) {
    {
#line 174
    a1loge(g_log, 1, "aglob_next: strdup failed\n");
#line 175
    g->merr = 1;
    }
#line 176
    return ((char *)((void *)0));
  }
#line 178
  (g->ix) ++;
#line 179
  return (fpath);
}
}
#line 183 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/spectro/aglob.c"
void aglob_cleanup(aglob *g ) 
{ 


  {
#line 189
  if (g->rv == 0) {
    {
#line 190
    globfree(& g->g);
    }
  }
  return;
}
}
#line 22 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/zbrent.h"
int zbrac(double *x1p , double *x2p , double (*func)(void * , double  ) , void *fdata ) ;
#line 32
int zbrent(double *rv , double ax , double bx , double tol , double (*func)(void * ,
                                                                            double  ) ,
           void *fdata ) ;
#line 28 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/zbrent.c"
int zbrac(double *x1p , double *x2p , double (*func)(void * , double  ) , void *fdata ) 
{ 
  int i ;
  double x1 ;
  double x2 ;
  double f1 ;
  double f2 ;
  double gold ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double tx1 ;
  double tf1 ;
  double __cil_tmp17 ;
  double tx2 ;
  double tf2 ;
  double __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 37
  gold = 1.618034;
#line 39
  x1 = *x1p;
#line 40
  x2 = *x2p;
#line 41
  if (x1 == x2) {
#line 42
    return (- 1);
  }
  {
#line 44
  f1 = (*func)(fdata, x1);
#line 45
  f2 = (*func)(fdata, x2);
#line 47
  i = 0;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (i < 40)) {
#line 47
      goto while_break;
    }
#line 48
    if (f1 * f2 < 0.) {
#line 49
      *x1p = x1;
#line 50
      *x2p = x2;
#line 51
      return (0);
    }
    {
#line 53
    __cil_tmp14 = fabs(f1);
    }
    {
#line 53
    __cil_tmp13 = fabs(f2);
    }
#line 53
    if (__cil_tmp13 > __cil_tmp14) {
      {
#line 55
      tx1 = x1 + gold * (x1 - x2);
#line 56
      tf1 = (*func)(fdata, tx1);
      }
#line 57
      if (tf1 < f1) {
#line 58
        x1 = tx1;
#line 59
        f1 = tf1;
      } else {
#line 61
        gold *= 0.5;
      }
    } else {
      {
#line 65
      tx2 = x1 + gold * (x2 - x1);
#line 66
      tf2 = (*func)(fdata, tx2);
      }
#line 67
      if (tf2 > f2) {
#line 68
        x2 = tx2;
#line 69
        f2 = tf2;
      } else {
#line 71
        gold *= 0.5;
      }
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (- 2);
}
}
#line 88 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/zbrent.c"
int zbrent(double *rv , double ax , double bx , double tol , double (*func)(void * ,
                                                                            double  ) ,
           void *fdata ) 
{ 
  int i ;
  double cx ;
  double af ;
  double bf ;
  double cf ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double xdel ;
  double del ;
  double pdel ;
  double tol1 ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;
  double __cil_tmp24 ;
  double P ;
  double Q ;
  double R ;
  double R___0 ;
  double S ;
  double T ;
  double __cil_tmp31 ;
  double min1 ;
  double min2 ;
  double __cil_tmp34 ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  double tmp ;
  double __cil_tmp38 ;
  int __cil_tmp39 ;

  {
  {
#line 100
  af = (*func)(fdata, ax);
#line 101
  bf = (*func)(fdata, bx);
  }
#line 104
  if (af * bf > 0.) {
#line 105
    return (- 1);
  }
#line 107
  cx = bx;
#line 108
  cf = bf;
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < 100)) {
#line 109
      goto while_break;
    }
#line 111
    del = 1.00000000001e+80;
#line 112
    pdel = 1.00000000001e+80;
#line 116
    if (bf * cf > 0.) {
#line 117
      cx = ax;
#line 118
      cf = af;
#line 119
      del = bx - ax;
#line 119
      pdel = del;
    }
    {
#line 123
    __cil_tmp19 = fabs(bf);
    }
    {
#line 123
    __cil_tmp18 = fabs(cf);
    }
#line 123
    if (__cil_tmp18 < __cil_tmp19) {
#line 124
      ax = bx;
#line 125
      af = bf;
#line 126
      bx = cx;
#line 127
      bf = cf;
#line 128
      cx = ax;
#line 129
      cf = af;
    }
    {
#line 131
    __cil_tmp20 = fabs(bx);
#line 131
    tol1 = 0.5 * tol + (2. * (double )2.22044604926e-16L) * __cil_tmp20;
#line 132
    xdel = 0.5 * (cx - bx);
#line 134
    __cil_tmp21 = fabs(xdel);
    }
#line 134
    if (bf == 0.) {
#line 135
      *rv = bx;
#line 136
      return (0);
    } else
#line 134
    if (__cil_tmp21 <= tol1) {
#line 135
      *rv = bx;
#line 136
      return (0);
    }
    {
#line 138
    __cil_tmp24 = fabs(bf);
    }
    {
#line 138
    __cil_tmp23 = fabs(af);
    }
    {
#line 138
    __cil_tmp22 = fabs(pdel);
    }
#line 138
    if (__cil_tmp22 >= tol1) {
#line 138
      if (__cil_tmp23 > __cil_tmp24) {
#line 141
        if (ax == cx) {
#line 143
          R = bf / cf;
#line 144
          P = (cx - bx) * R;
#line 145
          Q = R - 1.;
        } else {
#line 148
          R___0 = bf / cf;
#line 149
          S = bf / af;
#line 150
          T = af / cf;
#line 151
          P = S * ((T * (R___0 - T)) * (cx - bx) - (1. - R___0) * (bx - ax));
#line 152
          Q = ((T - 1.) * (R___0 - 1.)) * (S - 1.);
        }
#line 154
        if (P < 0.) {
#line 155
          Q = - Q;
        }
        {
#line 156
        P = fabs(P);
#line 159
        __cil_tmp34 = fabs(Q);
#line 159
        min1 = (3. * xdel) * Q - tol1 * __cil_tmp34;
#line 160
        min2 = fabs(pdel * Q);
        }
#line 161
        if (min2 < min1) {
#line 162
          min1 = min2;
        }
#line 164
        if (2. * P < min1) {
#line 165
          pdel = del;
#line 166
          del = P / Q;
        } else {
#line 168
          del = xdel;
#line 168
          pdel = del;
        }
      } else {
#line 172
        del = xdel;
#line 172
        pdel = del;
      }
    } else {
#line 172
      del = xdel;
#line 172
      pdel = del;
    }
    {
#line 174
    ax = bx;
#line 175
    af = bf;
#line 176
    __cil_tmp36 = fabs(del);
    }
#line 176
    if (__cil_tmp36 > tol1) {
#line 177
      bx += del;
    } else {
#line 179
      if (xdel > 0.) {
#line 179
        tmp = tol1;
      } else {
#line 179
        tmp = - tol1;
      }
#line 179
      bx += tmp;
    }
    {
#line 180
    bf = (*func)(fdata, bx);
    }
#line 109
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (- 2);
}
}
#line 24 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/powell.h"
int powell(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
           double (*func)(void * , double [] ) , void *fdata , void (*prog)(void * ,
                                                                            int  ) ,
           void *pdata ) ;
#line 40
int conjgrad(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
             double (*func)(void * , double [] ) , double (*dfunc)(void * , double [] ,
                                                                   double [] ) , void *fdata ,
             void (*prog)(void * , int  ) , void *pdata ) ;
#line 56
double powell_funk(void *fdata , double tp[] ) ;
#line 62
double linmin(double cp[] , double xi[] , int di , double ftol , double (*func)(void * ,
                                                                                double [] ) ,
              void *fdata ) ;
#line 77
double linmind(double cp[] , double xi[] , int di , double ftol , double (*func)(void * ,
                                                                                 double [] ) ,
               double (*dfunc)(void * , double [] , double [] ) , void *fdata ) ;
#line 21 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/varmet.h"
int varmet(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
           double (*func)(void * , double [] ) , double (*dfunc)(void * , double [] ,
                                                                 double [] ) , void *fdata ) ;
#line 34
double varmet_funk(void *fdata , double tp[] ) ;
#line 39
double brentnd(double ax , double bx , double cx , double ftol , double *xmin , int n ,
               double (*func)(void * , double [] ) , void *fdata , double pcom[] ,
               double xicom[] ) ;
#line 49 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/varmet.c"
void linesearch(int di , double cpold[] , double fpold , double dp[] , double sdir[] ,
                double cpnew[] , double *pfp , double maxstep , double (*func)(void * ,
                                                                               double [] ) ,
                void *fdata ) ;
#line 56 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/varmet.c"
int varmet(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
           double (*func)(void * , double [] ) , double (*dfunc)(void * , double [] ,
                                                                 double [] ) , void *fdata ) 
{ 
  int iter ;
  int fails ;
  double fp ;
  double sumsq ;
  double maxstep ;
  double *sdir ;
  double sumsdir ;
  double *dp ;
  double *lastdp ;
  double **hessian ;
  double *hlastdp ;
  double *cpnew ;
  double *dels ;
  double test ;
  double den ;
  double fac ;
  double fad ;
  double fae ;
  double sumdg ;
  int i ;
  int j ;
  double xtol ;
  double pfp ;
  double stopth ;
  double curdel ;
  double *__cil_tmp35 ;
  double *__cil_tmp36 ;
  double *__cil_tmp37 ;
  double **__cil_tmp38 ;
  double *__cil_tmp39 ;
  double *__cil_tmp40 ;
  double *__cil_tmp41 ;
  double __cil_tmp42 ;
  double __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  double __cil_tmp47 ;
  double __cil_tmp48 ;
  double tmp ;
  int __cil_tmp50 ;
  double tt ;
  double __cil_tmp52 ;
  double __cil_tmp53 ;
  double __cil_tmp54 ;
  double tmp___0 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  double __cil_tmp58 ;
  double __cil_tmp59 ;
  double tmp___1 ;
  int __cil_tmp61 ;
  double __cil_tmp62 ;
  double avgdel ;
  int __cil_tmp64 ;
  double __cil_tmp65 ;
  double __cil_tmp66 ;
  double __cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  double __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;

  {
  {
#line 83
  xtol = (double )4 * 1.00000000001e-10;
#line 85
  pfp = 1e+38;
#line 87
  sdir = dvector(0, di - 1);
#line 88
  dp = dvector(0, di - 1);
#line 89
  lastdp = dvector(0, di - 1);
#line 90
  hessian = dmatrix(0, di - 1, 0, di - 1);
#line 91
  hlastdp = dvector(0, di - 1);
#line 92
  cpnew = dvector(0, di - 1);
#line 93
  dels = dvector(0, di - 1);
#line 96
  fp = (*dfunc)(fdata, dp, cp);
  }
#line 97
  if (fp == 1.00000000001e+100) {
    {
#line 98
    fp = (*func)(fdata, cp);
    }
  }
#line 101
  sumsq = 0.;
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < di)) {
#line 102
      goto while_break;
    }
#line 103
    *(sdir + i) = - *(dp + i);
#line 104
    sumsq += cp[i] * cp[i];
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (! (i < di)) {
#line 110
      goto while_break___0;
    }
#line 111
    j = 0;
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 111
      if (! (j < di)) {
#line 111
        goto while_break___1;
      }
#line 112
      if (i == j) {
#line 113
        *(*(hessian + i) + j) = 1.;
      } else {
#line 115
        *(*(hessian + i) + j) = 0.;
      }
#line 111
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 120
  __cil_tmp47 = sqrt(sumsq);
  }
#line 120
  if (__cil_tmp47 > (double )di) {
    {
#line 120
    __cil_tmp48 = sqrt(sumsq);
#line 120
    tmp = __cil_tmp48;
    }
  } else {
#line 120
    tmp = (double )di;
  }
#line 120
  maxstep = 100. * tmp;
#line 124
  iter = 0;
#line 124
  fails = iter;
  {
#line 124
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 124
    if (! (fails < di && iter < maxit)) {
#line 124
      goto while_break___2;
    }
    {
#line 128
    linesearch(di, cp, fp, dp, sdir, cpnew, & fp, maxstep, func, fdata);
#line 130
    i = 0;
    }
    {
#line 130
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 130
      if (! (i < di)) {
#line 130
        goto while_break___3;
      }
#line 131
      *(sdir + i) = *(cpnew + i) - cp[i];
#line 132
      cp[i] = *(cpnew + i);
#line 130
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 137
    i = 0;
#line 137
    test = 0.;
    {
#line 137
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 137
      if (! (i < di)) {
#line 137
        goto while_break___4;
      }
      {
#line 138
      __cil_tmp53 = fabs(cp[i]);
      }
#line 138
      if (__cil_tmp53 > 1.) {
        {
#line 138
        __cil_tmp54 = fabs(cp[i]);
#line 138
        tmp___0 = __cil_tmp54;
        }
      } else {
#line 138
        tmp___0 = 1.;
      }
      {
#line 138
      __cil_tmp52 = fabs(*(sdir + i));
#line 138
      tt = __cil_tmp52 / tmp___0;
      }
#line 139
      if (tt > test) {
#line 140
        test = tt;
      }
#line 137
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 143
    if (test < xtol) {
#line 148
      sumsq = 0.;
#line 149
      i = 0;
      {
#line 149
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 149
        if (! (i < di)) {
#line 149
          goto while_break___5;
        }
#line 150
        *(sdir + i) = - *(dp + i);
#line 151
        sumsq += cp[i] * cp[i];
#line 149
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 154
      __cil_tmp58 = sqrt(sumsq);
      }
#line 154
      if (__cil_tmp58 > (double )di) {
        {
#line 154
        __cil_tmp59 = sqrt(sumsq);
#line 154
        tmp___1 = __cil_tmp59;
        }
      } else {
#line 154
        tmp___1 = (double )di;
      }
#line 154
      maxstep = 100. * tmp___1;
#line 158
      fails ++;
#line 160
      goto while_continue___2;
    }
    {
#line 163
    fails = 0;
#line 167
    curdel = fabs(pfp - fp);
#line 168
    *(dels + iter % di) = curdel;
    }
#line 170
    if (iter > di) {
#line 173
      i = 0;
#line 173
      avgdel = 0.;
      {
#line 173
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 173
        if (! (i < di)) {
#line 173
          goto while_break___6;
        }
#line 174
        avgdel += *(dels + i) * *(dels + i);
#line 173
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 175
      avgdel = sqrt(avgdel / (double )di);
#line 177
      __cil_tmp67 = fabs(fp);
      }
      {
#line 177
      __cil_tmp66 = fabs(pfp);
#line 177
      stopth = (ftol * 0.5) * ((__cil_tmp66 + __cil_tmp67) + (double )2.22044604926e-16L);
      }
#line 180
      if (avgdel <= stopth) {
#line 182
        goto while_break___2;
      }
    }
#line 188
    pfp = fp;
#line 190
    i = 0;
    {
#line 190
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 190
      if (! (i < di)) {
#line 190
        goto while_break___7;
      }
#line 191
      *(lastdp + i) = *(dp + i);
#line 190
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 194
    (*dfunc)(fdata, dp, cp);
#line 213
    i = 0;
    }
    {
#line 213
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 213
      if (! (i < di)) {
#line 213
        goto while_break___8;
      }
#line 214
      *(lastdp + i) = *(dp + i) - *(lastdp + i);
#line 213
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 216
    i = 0;
    {
#line 216
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 216
      if (! (i < di)) {
#line 216
        goto while_break___9;
      }
#line 217
      *(hlastdp + i) = 0.;
#line 218
      j = 0;
      {
#line 218
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 218
        if (! (j < di)) {
#line 218
          goto while_break___10;
        }
#line 219
        *(hlastdp + i) += *(*(hessian + i) + j) * *(lastdp + j);
#line 218
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 216
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 223
    sumsdir = 0.;
#line 223
    sumdg = sumsdir;
#line 223
    fae = sumdg;
#line 223
    fac = fae;
#line 224
    i = 0;
    {
#line 224
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 224
      if (! (i < di)) {
#line 224
        goto while_break___11;
      }
#line 225
      fac += *(lastdp + i) * *(sdir + i);
#line 226
      fae += *(lastdp + i) * *(hlastdp + i);
#line 227
      sumdg += *(lastdp + i) * *(lastdp + i);
#line 228
      sumsdir += *(sdir + i) * *(sdir + i);
#line 224
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 230
    __cil_tmp73 = sqrt((1.00000000001e-10 * sumdg) * sumsdir);
    }
#line 230
    if (fac > __cil_tmp73) {
#line 231
      fac = 1. / fac;
#line 232
      fad = 1. / fae;
#line 234
      i = 0;
      {
#line 234
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 234
        if (! (i < di)) {
#line 234
          goto while_break___12;
        }
#line 235
        *(lastdp + i) = fac * *(sdir + i) - fad * *(hlastdp + i);
#line 234
        i ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 236
      i = 0;
      {
#line 236
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 236
        if (! (i < di)) {
#line 236
          goto while_break___13;
        }
#line 237
        j = i;
        {
#line 237
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 237
          if (! (j < di)) {
#line 237
            goto while_break___14;
          }
#line 238
          *(*(hessian + i) + j) += ((fac * *(sdir + i)) * *(sdir + j) - (fad * *(hlastdp + i)) * *(hlastdp + j)) + (fae * *(lastdp + i)) * *(lastdp + j);
#line 240
          *(*(hessian + j) + i) = *(*(hessian + i) + j);
#line 237
          j ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 236
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 244
    i = 0;
    {
#line 244
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 244
      if (! (i < di)) {
#line 244
        goto while_break___15;
      }
#line 245
      *(sdir + i) = 0.;
#line 246
      j = 0;
      {
#line 246
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 246
        if (! (j < di)) {
#line 246
          goto while_break___16;
        }
#line 247
        *(sdir + i) -= *(*(hessian + i) + j) * *(dp + j);
#line 246
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 244
      i ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 124
    iter ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 253
  free_dvector(dels, 0, di - 1);
#line 254
  free_dvector(cpnew, 0, di - 1);
#line 255
  free_dvector(hlastdp, 0, di - 1);
#line 256
  free_dmatrix(hessian, 0, di - 1, 0, di - 1);
#line 257
  free_dvector(lastdp, 0, di - 1);
#line 258
  free_dvector(dp, 0, di - 1);
#line 259
  free_dvector(sdir, 0, di - 1);
  }
#line 260
  if (rv != (void *)0) {
#line 261
    *rv = fp;
  }
#line 262
  return (0);
}
}
#line 273 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/varmet.c"
void linesearch(int di , double cpold[] , double fpold , double dp[] , double sdir[] ,
                double cpnew[] , double *pfp , double maxstep , double (*func)(void * ,
                                                                               double [] ) ,
                void *fdata ) 
{ 
  double sum ;
  double slope ;
  double slen ;
  double slen_2 ;
  double slen_min ;
  double test ;
  double fp_2 ;
  int i ;
  int __cil_tmp19 ;
  double __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  double tt ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double __cil_tmp26 ;
  double tmp ;
  int __cil_tmp28 ;
  double slen_t ;
  int __cil_tmp30 ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  double aa ;
  double bb ;
  double rhs_1 ;
  double rhs_2 ;
  double dd ;
  double __cil_tmp38 ;
  double __cil_tmp39 ;
  double tmp___0 ;

  {
#line 286
  slen_2 = 0.;
#line 287
  fp_2 = 0.;
#line 290
  i = 0;
#line 290
  sum = 0.;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < di)) {
#line 290
      goto while_break;
    }
#line 291
    sum += sdir[i] * sdir[i];
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  sum = sqrt(sum);
  }
#line 296
  if (sum > maxstep) {
#line 298
    i = 0;
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (! (i < di)) {
#line 298
        goto while_break___0;
      }
#line 299
      sdir[i] *= maxstep / sum;
#line 298
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 301
  i = 0;
#line 301
  slope = 0.;
  {
#line 301
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 301
    if (! (i < di)) {
#line 301
      goto while_break___1;
    }
#line 302
    slope += dp[i] * sdir[i];
#line 301
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }

#line 306
  if (slope >= 0.) {
    {
#line 307
    warning("varmet:linesearch: slope is >= 0@g\355\026\313U");
    }
#line 311
    return;
  }
#line 316
  i = 0;
#line 316
  test = 0.;
  {
#line 316
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 316
    if (! (i < di)) {
#line 316
      goto while_break___2;
    }
    {
#line 317
    __cil_tmp25 = fabs(cpold[i]);
    }
#line 317
    if (__cil_tmp25 > 1.) {
      {
#line 317
      __cil_tmp26 = fabs(cpold[i]);
#line 317
      tmp = __cil_tmp26;
      }
    } else {
#line 317
      tmp = 1.;
    }
    {
#line 317
    __cil_tmp24 = fabs(sdir[i]);
#line 317
    tt = __cil_tmp24 / tmp;
    }
#line 318
    if (tt > test) {
#line 319
      test = tt;
    }
#line 316
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 322
  slen_min = 1e-07 / test;
#line 323
  slen = 1.;
  {
#line 326
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 326
    if (! 1) {
#line 326
      goto while_break___3;
    }
#line 332
    i = 0;
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      if (! (i < di)) {
#line 332
        goto while_break___4;
      }
#line 333
      cpnew[i] = cpold[i] + slen * sdir[i];
#line 332
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 335
    *pfp = (*func)(fdata, cpnew);
    }
#line 338
    if (slen < slen_min) {
#line 340
      i = 0;
      {
#line 340
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 340
        if (! (i < di)) {
#line 340
          goto while_break___5;
        }
#line 341
        cpnew[i] = cpold[i];
#line 340
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 342
      *pfp = fp_2;
#line 343
      slen = slen_min;
#line 348
      return;
    } else
#line 351
    if (*pfp <= fpold + (0.000100000000001 * slen) * slope) {

#line 356
      return;
    } else {

#line 366
      if (slen == 1.) {
#line 367
        slen_t = - slope / (2. * ((*pfp - fpold) - slope));
      } else {
#line 378
        rhs_1 = (*pfp - fpold) - slen * slope;
#line 379
        rhs_2 = (fp_2 - fpold) - slen_2 * slope;
#line 380
        aa = (rhs_1 / (slen * slen) - rhs_2 / (slen_2 * slen_2)) / (slen - slen_2);
#line 381
        bb = ((- slen_2 * rhs_1) / (slen * slen) + (slen * rhs_2) / (slen_2 * slen_2)) / (slen - slen_2);
#line 385
        if (aa == 0.) {
#line 386
          slen_t = - slope / (2. * bb);
        } else {
#line 389
          dd = bb * bb - (3. * aa) * slope;
#line 391
          if (dd < 0.) {
#line 392
            slen_t = 0.5 * slen;
          } else
#line 394
          if (bb <= 0.) {
            {
#line 395
            __cil_tmp38 = sqrt(dd);
#line 395
            slen_t = (- bb + __cil_tmp38) / (3. * aa);
            }
          } else {
            {
#line 398
            __cil_tmp39 = sqrt(dd);
#line 398
            slen_t = - slope / (bb + __cil_tmp39);
            }
          }
        }
#line 402
        if (slen_t > 0.5 * slen) {
#line 404
          slen_t = 0.5 * slen;
        }
      }
    }
#line 408
    fp_2 = *pfp;
#line 409
    slen_2 = slen;
#line 410
    if (slen_t > 0.100000000001 * slen) {
#line 410
      tmp___0 = slen_t;
    } else {
#line 410
      tmp___0 = 0.100000000001 * slen;
    }
#line 410
    slen = tmp___0;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 52 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.h"
int svdecomp(double **a , double *w , double **v , int m , int n ) ;
#line 61
void svdthresh(double w[] , int n ) ;
#line 67
void svdsetthresh(double w[] , int n , int dof ) ;
#line 75
int svdbacksub(double **u , double *w , double **v , double b[] , double x[] , int m ,
               int n ) ;
#line 89
int svdsolve(double **a , double b[] , int m , int n ) ;
#line 100
int svdsolve_s(double **a , double b[] , int m , int n , int s ) ;
#line 111
int gen_solve_se(double **a , double b[] , int m , int n ) ;
#line 119
static void svdinverse(double **u , double *w , double **v , double **ia , int m ,
                       int n ) ;
#line 22 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
double pythag(double a , double b ) 
{ 
  double aba ;
  double abb ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double boa ;
  double __cil_tmp8 ;
  double aob ;
  double __cil_tmp10 ;

  {
  {
#line 27
  aba = fabs(a);
#line 28
  abb = fabs(b);
  }
#line 30
  if (aba > abb) {
    {
#line 32
    boa = abb / aba;
#line 33
    __cil_tmp8 = sqrt(1. + boa * boa);
    }
#line 33
    return (aba * __cil_tmp8);
  } else {
#line 36
    if (abb == 0.) {
#line 37
      return (0.);
    }
    {
#line 38
    aob = aba / abb;
#line 39
    __cil_tmp10 = sqrt(1. + aob * aob);
    }
#line 39
    return (abb * __cil_tmp10);
  }
}
}
#line 52 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
int svdecomp(double **a , double *w , double **v , int m , int n ) 
{ 
  double eps ;
  double tol ;
  double *rv1 ;
  double RV1[100] ;
  double anm ;
  int i ;
  int j ;
  int k ;
  int its ;
  double *__cil_tmp15 ;
  int ip1 ;
  double ss ;
  double ff ;
  int __cil_tmp19 ;
  double gg ;
  double hh ;
  double __cil_tmp22 ;
  double tmp ;
  double tt ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  double ss___0 ;
  double ff___0 ;
  int __cil_tmp30 ;
  double gg___0 ;
  double hh___0 ;
  double __cil_tmp33 ;
  double tmp___0 ;
  double tt___0 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  double tt___1 ;
  double __cil_tmp40 ;
  double __cil_tmp41 ;
  int __cil_tmp42 ;
  int ip1___0 ;
  double gg___1 ;
  int __cil_tmp45 ;
  double ss___1 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  int tmp___1 ;
  int ip1___1 ;
  double gg___2 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  double ss___2 ;
  double ff___1 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int flag ;
  int lm1 ;
  int ll ;
  double zz ;
  double __cil_tmp68 ;
  double __cil_tmp69 ;
  int __cil_tmp70 ;
  double cc ;
  double ss___3 ;
  double ff___2 ;
  double gg___3 ;
  double hh___1 ;
  double __cil_tmp76 ;
  double __cil_tmp77 ;
  double y1___7 ;
  double z1 ;
  int __cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  double ff___3 ;
  double gg___4 ;
  double hh___2 ;
  double cc___0 ;
  double ss___4 ;
  double xx ;
  double yy ;
  int km1 ;
  double __cil_tmp91 ;
  double tmp___2 ;
  double f2 ;
  double g2 ;
  double y2 ;
  double h2 ;
  double z2 ;
  int jp1 ;
  double __cil_tmp99 ;
  double x1 ;
  double z1___0 ;
  int __cil_tmp102 ;
  double __cil_tmp103 ;
  double y1___8 ;
  double z1___1 ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;

  {
#line 59
  eps = (double )2.22044604926e-16L;
#line 60
  tol = (double )2.22507385851e-308L / eps;
#line 66
  if (n <= 100) {
#line 67
    rv1 = (double *)RV1;
  } else {
    {
#line 69
    rv1 = dvector(0, n - 1);
    }
  }
#line 72
  anm = 0.;
#line 73
  *(rv1 + 0) = 0.;
#line 74
  i = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < n)) {
#line 74
      goto while_break;
    }
#line 75
    ip1 = i + 1;
#line 78
    *(w + i) = 0.;
#line 79
    if (i < m) {
#line 80
      ff = 0.;
#line 82
      k = m - 1;
#line 82
      ss = 0.;
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 82
        if (! (k >= i)) {
#line 82
          goto while_break___0;
        }
#line 83
        ff = *(*(a + k) + i);
#line 84
        ss += ff * ff;
#line 82
        __cil_tmp19 = k;
#line 82
        k --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 86
      if (ss >= tol) {
        {
#line 88
        gg = sqrt(ss);
        }
#line 89
        if (ff < 0.) {
#line 89
          tmp = gg;
        } else {
#line 89
          tmp = - gg;
        }
#line 89
        gg = tmp;
#line 89
        *(w + i) = gg;
#line 90
        hh = ff * gg - ss;
#line 91
        *(*(a + i) + i) = ff - gg;
#line 94
        j = ip1;
        {
#line 94
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 94
          if (! (j < n)) {
#line 94
            goto while_break___1;
          }
#line 96
          k = i;
#line 96
          ss = 0.;
          {
#line 96
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 96
            if (! (k < m)) {
#line 96
              goto while_break___2;
            }
#line 97
            ss += *(*(a + k) + j) * *(*(a + k) + i);
#line 96
            k ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 98
          tt = ss / hh;
#line 99
          k = i;
          {
#line 99
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 99
            if (! (k < m)) {
#line 99
              goto while_break___3;
            }
#line 100
            *(*(a + k) + j) += tt * *(*(a + k) + i);
#line 99
            k ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 94
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 106
    if (ip1 < n) {
#line 107
      *(rv1 + ip1) = 0.;
#line 108
      if (i < m) {
#line 109
        ff___0 = 0.;
#line 110
        k = n - 1;
#line 110
        ss___0 = 0.;
        {
#line 110
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 110
          if (! (k >= ip1)) {
#line 110
            goto while_break___4;
          }
#line 111
          ff___0 = *(*(a + i) + k);
#line 112
          ss___0 += ff___0 * ff___0;
#line 110
          __cil_tmp30 = k;
#line 110
          k --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 114
        if (ss___0 >= tol) {
          {
#line 116
          gg___0 = sqrt(ss___0);
          }
#line 117
          if (ff___0 < 0.) {
#line 117
            tmp___0 = gg___0;
          } else {
#line 117
            tmp___0 = - gg___0;
          }
#line 117
          gg___0 = tmp___0;
#line 117
          *(rv1 + ip1) = gg___0;
#line 118
          hh___0 = ff___0 * gg___0 - ss___0;
#line 119
          *(*(a + i) + ip1) = ff___0 - gg___0;
#line 122
          j = ip1;
          {
#line 122
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 122
            if (! (j < m)) {
#line 122
              goto while_break___5;
            }
#line 124
            k = ip1;
#line 124
            ss___0 = 0.;
            {
#line 124
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 124
              if (! (k < n)) {
#line 124
                goto while_break___6;
              }
#line 125
              ss___0 += *(*(a + j) + k) * *(*(a + i) + k);
#line 124
              k ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 126
            tt___0 = ss___0 / hh___0;
#line 127
            k = ip1;
            {
#line 127
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 127
              if (! (k < n)) {
#line 127
                goto while_break___7;
              }
#line 128
              *(*(a + j) + k) += tt___0 * *(*(a + i) + k);
#line 127
              k ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 122
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 135
    __cil_tmp41 = fabs(*(rv1 + i));
    }
    {
#line 135
    __cil_tmp40 = fabs(*(w + i));
#line 135
    tt___1 = __cil_tmp40 + __cil_tmp41;
    }
#line 136
    if (tt___1 > anm) {
#line 137
      anm = tt___1;
    }
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  i = n - 1;
  {
#line 142
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 142
    if (! (i >= 0)) {
#line 142
      goto while_break___8;
    }
#line 143
    ip1___0 = i + 1;
#line 144
    if (ip1___0 < n) {
#line 146
      gg___1 = *(rv1 + ip1___0);
#line 147
      if (gg___1 != 0.) {
#line 148
        gg___1 = 1. / gg___1;
#line 149
        j = ip1___0;
        {
#line 149
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 149
          if (! (j < n)) {
#line 149
            goto while_break___9;
          }
#line 150
          *(*(v + j) + i) = (*(*(a + i) + j) / *(*(a + i) + ip1___0)) * gg___1;
#line 149
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 151
        j = ip1___0;
        {
#line 151
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 151
          if (! (j < n)) {
#line 151
            goto while_break___10;
          }
#line 153
          k = ip1___0;
#line 153
          ss___1 = 0.;
          {
#line 153
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 153
            if (! (k < n)) {
#line 153
              goto while_break___11;
            }
#line 154
            ss___1 += *(*(a + i) + k) * *(*(v + k) + j);
#line 153
            k ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 155
          k = ip1___0;
          {
#line 155
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 155
            if (! (k < n)) {
#line 155
              goto while_break___12;
            }
#line 156
            *(*(v + k) + j) += ss___1 * *(*(v + k) + i);
#line 155
            k ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 151
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 159
      j = ip1___0;
      {
#line 159
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 159
        if (! (j < n)) {
#line 159
          goto while_break___13;
        }
#line 160
        *(*(v + j) + i) = 0.;
#line 160
        *(*(v + i) + j) = *(*(v + j) + i);
#line 159
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 162
    *(*(v + i) + i) = 1.;
#line 142
    __cil_tmp51 = i;
#line 142
    i --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 165
  if (n < m) {
#line 165
    tmp___1 = n - 1;
  } else {
#line 165
    tmp___1 = m - 1;
  }
#line 165
  i = tmp___1;
  {
#line 165
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 165
    if (! (i >= 0)) {
#line 165
      goto while_break___14;
    }
#line 166
    ip1___1 = i + 1;
#line 167
    gg___2 = *(w + i);
#line 168
    if (ip1___1 < n) {
#line 169
      j = ip1___1;
      {
#line 169
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 169
        if (! (j < n)) {
#line 169
          goto while_break___15;
        }
#line 170
        *(*(a + i) + j) = 0.;
#line 169
        j ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
#line 171
    if (gg___2 == 0.) {
#line 172
      j = i;
      {
#line 172
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 172
        if (! (j < m)) {
#line 172
          goto while_break___16;
        }
#line 173
        *(*(a + j) + i) = 0.;
#line 172
        j ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    } else {
#line 175
      gg___2 = 1. / gg___2;
#line 176
      if (ip1___1 < n) {
#line 177
        j = ip1___1;
        {
#line 177
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 177
          if (! (j < n)) {
#line 177
            goto while_break___17;
          }
#line 179
          k = ip1___1;
#line 179
          ss___2 = 0.;
          {
#line 179
          while (1) {
            while_continue___18: /* CIL Label */ ;
#line 179
            if (! (k < m)) {
#line 179
              goto while_break___18;
            }
#line 180
            ss___2 += *(*(a + k) + i) * *(*(a + k) + j);
#line 179
            k ++;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 181
          ff___1 = (ss___2 / *(*(a + i) + i)) * gg___2;
#line 182
          k = i;
          {
#line 182
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 182
            if (! (k < m)) {
#line 182
              goto while_break___19;
            }
#line 183
            *(*(a + k) + j) += ff___1 * *(*(a + k) + i);
#line 182
            k ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 177
          j ++;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
#line 186
      j = i;
      {
#line 186
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 186
        if (! (j < m)) {
#line 186
          goto while_break___20;
        }
#line 187
        *(*(a + j) + i) *= gg___2;
#line 186
        j ++;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
#line 189
    *(*(a + i) + i) += 1.;
#line 165
    __cil_tmp63 = i;
#line 165
    i --;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 192
  eps *= anm;
#line 196
  k = n - 1;
  {
#line 196
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 196
    if (! (k >= 0)) {
#line 196
      goto while_break___21;
    }
#line 197
    its = 0;
    {
#line 197
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 197
      if (! 1) {
#line 197
        goto while_break___22;
      }
#line 199
      lm1 = 0;
#line 204
      ll = k;
#line 204
      flag = 1;
      {
#line 204
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 204
        if (! (ll >= 0)) {
#line 204
          goto while_break___23;
        }
        {
#line 205
        lm1 = ll - 1;
#line 206
        __cil_tmp68 = fabs(*(rv1 + ll));
        }
#line 206
        if (__cil_tmp68 <= eps) {
#line 207
          flag = 0;
#line 208
          goto while_break___23;
        }
        {
#line 210
        __cil_tmp69 = fabs(*(w + lm1));
        }
#line 210
        if (__cil_tmp69 <= eps) {
#line 211
          goto while_break___23;
        }
#line 204
        __cil_tmp70 = ll;
#line 204
        ll --;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 213
      if (flag != 0) {
#line 214
        cc = 0.;
#line 215
        ss___3 = 1.;
#line 216
        i = ll;
        {
#line 216
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 216
          if (! (i <= k)) {
#line 216
            goto while_break___24;
          }
          {
#line 218
          gg___3 = *(rv1 + i);
#line 219
          *(rv1 + i) = cc * gg___3;
#line 220
          ff___2 = ss___3 * gg___3;
#line 221
          __cil_tmp76 = fabs(ff___2);
          }
#line 221
          if (__cil_tmp76 <= eps) {
#line 222
            goto while_break___24;
          }
          {
#line 223
          gg___3 = *(w + i);
#line 224
          *(w + i) = pythag(ff___2, gg___3);
#line 225
          hh___1 = 1. / hh___1;
#line 226
          cc = gg___3 * hh___1;
#line 227
          ss___3 = - ff___2 * hh___1;
#line 230
          j = 0;
          }
          {
#line 230
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 230
            if (! (j < m)) {
#line 230
              goto while_break___25;
            }
#line 232
            y1___7 = *(*(a + j) + lm1);
#line 233
            z1 = *(*(a + j) + i);
#line 234
            *(*(a + j) + lm1) = y1___7 * cc + z1 * ss___3;
#line 235
            *(*(a + j) + i) = z1 * cc - y1___7 * ss___3;
#line 230
            j ++;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 216
          i ++;
        }
        while_break___24: /* CIL Label */ ;
        }
      }
#line 239
      zz = *(w + k);
#line 240
      if (k == ll) {
#line 241
        if (zz < 0.) {
#line 242
          *(w + k) = - zz;
#line 243
          j = 0;
          {
#line 243
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 243
            if (! (j < n)) {
#line 243
              goto while_break___26;
            }
#line 244
            *(*(v + j) + k) = - *(*(v + j) + k);
#line 243
            j ++;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
#line 246
        goto while_break___22;
      }
#line 248
      if (its == 30) {
#line 250
        if (rv1 != (double *)RV1) {
          {
#line 251
          free_dvector(rv1, 0, n - 1);
          }
        }
#line 252
        return (1);
      }
      {
#line 258
      km1 = k - 1;
#line 259
      xx = *(w + ll);
#line 260
      yy = *(w + km1);
#line 261
      gg___4 = *(rv1 + km1);
#line 262
      hh___2 = *(rv1 + k);
#line 263
      ff___3 = ((yy - zz) * (yy + zz) + (gg___4 - hh___2) * (gg___4 + hh___2)) / ((2. * hh___2) * yy);
#line 264
      gg___4 = pythag(ff___3, 1.);
      }
#line 265
      if (ff___3 < 0.) {
#line 265
        tmp___2 = - gg___4;
      } else {
#line 265
        tmp___2 = gg___4;
      }
#line 265
      gg___4 = tmp___2;
#line 266
      ff___3 = ((xx - zz) * (xx + zz) + hh___2 * (yy / (ff___3 + gg___4) - hh___2)) / xx;
#line 267
      ss___4 = 1.;
#line 267
      cc___0 = ss___4;
#line 269
      j = ll;
      {
#line 269
      while (1) {
        while_continue___27: /* CIL Label */ ;
#line 269
        if (! (j <= km1)) {
#line 269
          goto while_break___27;
        }
        {
#line 271
        jp1 = j + 1;
#line 272
        g2 = *(rv1 + jp1);
#line 273
        y2 = *(w + jp1);
#line 274
        h2 = ss___4 * g2;
#line 275
        g2 = cc___0 * g2;
#line 276
        *(rv1 + j) = pythag(ff___3, h2);
#line 277
        cc___0 = ff___3 / z2;
#line 278
        ss___4 = h2 / z2;
#line 279
        f2 = xx * cc___0 + g2 * ss___4;
#line 280
        g2 = g2 * cc___0 - xx * ss___4;
#line 281
        h2 = y2 * ss___4;
#line 282
        y2 *= cc___0;
#line 285
        i = 0;
        }
        {
#line 285
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 285
          if (! (i < n)) {
#line 285
            goto while_break___28;
          }
#line 287
          x1 = *(*(v + i) + j);
#line 288
          z1___0 = *(*(v + i) + jp1);
#line 289
          *(*(v + i) + j) = x1 * cc___0 + z1___0 * ss___4;
#line 290
          *(*(v + i) + jp1) = z1___0 * cc___0 - x1 * ss___4;
#line 285
          i ++;
        }
        while_break___28: /* CIL Label */ ;
        }
        {
#line 292
        *(w + j) = pythag(f2, h2);
        }
#line 293
        if (z2 != 0.) {
#line 294
          z2 = 1. / z2;
#line 295
          cc___0 = f2 * z2;
#line 296
          ss___4 = h2 * z2;
        }
#line 298
        ff___3 = cc___0 * g2 + ss___4 * y2;
#line 299
        xx = cc___0 * y2 - ss___4 * g2;
#line 302
        i = 0;
        {
#line 302
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 302
          if (! (i < m)) {
#line 302
            goto while_break___29;
          }
#line 304
          y1___8 = *(*(a + i) + j);
#line 305
          z1___1 = *(*(a + i) + jp1);
#line 306
          *(*(a + i) + j) = y1___8 * cc___0 + z1___1 * ss___4;
#line 307
          *(*(a + i) + jp1) = z1___1 * cc___0 - y1___8 * ss___4;
#line 302
          i ++;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 269
        j ++;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 310
      *(rv1 + ll) = 0.;
#line 311
      *(rv1 + k) = ff___3;
#line 312
      *(w + k) = xx;
#line 197
      its ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 196
    __cil_tmp109 = k;
#line 196
    k --;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 316
  if (rv1 != (double *)RV1) {
    {
#line 317
    free_dvector(rv1, 0, n - 1);
    }
  }
#line 319
  return (0);
}
}
#line 324 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
void svdthresh(double w[] , int n ) 
{ 
  int i ;
  double maxw ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 332
  i = 0;
#line 332
  maxw = 0.;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (i < n)) {
#line 332
      goto while_break;
    }
#line 333
    if (w[i] > maxw) {
#line 334
      maxw = w[i];
    }
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  maxw *= 1e-12;
#line 337
  i = 0;
  {
#line 337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 337
    if (! (i < n)) {
#line 337
      goto while_break___0;
    }
#line 338
    if (w[i] < maxw) {
#line 339
      w[i] = 0.;
    }
#line 337
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 346 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
void svdsetthresh(double w[] , int n , int dof ) 
{ 
  int i ;
  int j ;
  int k ;
  double minv ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 355
  j = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (j < dof)) {
#line 355
      goto while_break;
    }
#line 357
    minv = 1e+38;
#line 358
    i = 0;
#line 358
    j = i;
#line 358
    k = j;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! (i < n)) {
#line 358
        goto while_break___0;
      }
#line 359
      if (w[i] == 0.) {
#line 360
        j ++;
#line 361
        goto while_continue___0;
      }
#line 363
      if (w[i] < minv) {
#line 364
        minv = w[i];
#line 365
        k = i;
      }
#line 358
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    if (j < dof) {
#line 369
      w[k] = 0.;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 378 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
int svdbacksub(double **u , double *w , double **v , double b[] , double x[] , int m ,
               int n ) 
{ 
  int i ;
  int j ;
  double *tmp ;
  double TMP[100] ;
  double *__cil_tmp12 ;
  double s ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  double s___0 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 390
  if (n <= 100) {
#line 391
    tmp = (double *)TMP;
  } else {
    {
#line 393
    tmp = dvector(0, n - 1);
    }
  }
#line 399
  j = 0;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (j < n)) {
#line 399
      goto while_break;
    }
#line 400
    if (*(w + j)) {
#line 401
      s = 0.;
#line 402
      i = 0;
      {
#line 403
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 403
        if (! (i < m - 7)) {
#line 403
          goto while_break___0;
        }
#line 404
        s += b[i] * *(*(u + i) + j);
#line 405
        s += b[i + 1] * *(*(u + (i + 1)) + j);
#line 406
        s += b[i + 2] * *(*(u + (i + 2)) + j);
#line 407
        s += b[i + 3] * *(*(u + (i + 3)) + j);
#line 408
        s += b[i + 4] * *(*(u + (i + 4)) + j);
#line 409
        s += b[i + 5] * *(*(u + (i + 5)) + j);
#line 410
        s += b[i + 6] * *(*(u + (i + 6)) + j);
#line 411
        s += b[i + 7] * *(*(u + (i + 7)) + j);
#line 403
        i += 8;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 413
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 413
        if (! (i < m)) {
#line 413
          goto while_break___1;
        }
#line 414
        s += b[i] * *(*(u + i) + j);
#line 413
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 415
      s /= *(w + j);
#line 416
      *(tmp + j) = s;
    } else {
#line 418
      *(tmp + j) = 0.;
    }
#line 399
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  j = 0;
  {
#line 422
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 422
    if (! (j < n)) {
#line 422
      goto while_break___2;
    }
#line 423
    s___0 = 0.;
#line 424
    i = 0;
    {
#line 425
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 425
      if (! (i < n - 7)) {
#line 425
        goto while_break___3;
      }
#line 426
      s___0 += *(*(v + j) + i) * *(tmp + i);
#line 427
      s___0 += *(*(v + j) + (i + 1)) * *(tmp + (i + 1));
#line 428
      s___0 += *(*(v + j) + (i + 2)) * *(tmp + (i + 2));
#line 429
      s___0 += *(*(v + j) + (i + 3)) * *(tmp + (i + 3));
#line 430
      s___0 += *(*(v + j) + (i + 4)) * *(tmp + (i + 4));
#line 431
      s___0 += *(*(v + j) + (i + 5)) * *(tmp + (i + 5));
#line 432
      s___0 += *(*(v + j) + (i + 6)) * *(tmp + (i + 6));
#line 433
      s___0 += *(*(v + j) + (i + 7)) * *(tmp + (i + 7));
#line 425
      i += 8;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 435
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 435
      if (! (i < n)) {
#line 435
        goto while_break___4;
      }
#line 436
      s___0 += *(*(v + j) + i) * *(tmp + i);
#line 435
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 437
    x[j] = s___0;
#line 422
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 439
  if (tmp != (double *)TMP) {
    {
#line 440
    free_dvector(tmp, 0, n - 1);
    }
  }
#line 441
  return (0);
}
}
#line 512 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
int svdsolve(double **a , double b[] , int m , int n ) 
{ 
  int i ;
  double *w ;
  double W[8] ;
  double **v ;
  double *VP[8] ;
  double V[8][8] ;
  double maxw ;
  double *__cil_tmp12 ;
  double **__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 523
  if (n <= 8) {
#line 524
    w = (double *)W;
#line 525
    VP[0] = (double *)V[0];
#line 525
    VP[1] = (double *)V[1];
#line 525
    VP[2] = (double *)V[2];
#line 525
    VP[3] = (double *)V[3];
#line 526
    VP[4] = (double *)V[4];
#line 526
    VP[5] = (double *)V[5];
#line 526
    VP[6] = (double *)V[6];
#line 526
    VP[7] = (double *)V[7];
#line 527
    v = (double **)VP;
  } else {
    {
#line 529
    w = dvector(0, n - 1);
#line 530
    v = dmatrix(0, n - 1, 0, n - 1);
    }
  }
  {
#line 534
  __cil_tmp14 = svdecomp(a, w, v, m, n);
  }
#line 534
  if (__cil_tmp14) {
#line 535
    if (w != (double *)W) {
      {
#line 536
      free_dvector(w, 0, n - 1);
#line 537
      free_dmatrix(v, 0, n - 1, 0, n - 1);
      }
    }
#line 539
    return (1);
  }
#line 543
  i = 0;
#line 543
  maxw = 0.;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (i < n)) {
#line 543
      goto while_break;
    }
#line 544
    if (*(w + i) > maxw) {
#line 545
      maxw = *(w + i);
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 547
  maxw *= 1e-12;
#line 548
  i = 0;
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 548
    if (! (i < n)) {
#line 548
      goto while_break___0;
    }
#line 549
    if (*(w + i) < maxw) {
#line 550
      *(w + i) = 0.;
    }
#line 548
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 554
  svdbacksub(a, w, v, b, b, m, n);
  }
#line 556
  if (w != (double *)W) {
    {
#line 557
    free_dvector(w, 0, n - 1);
#line 558
    free_dmatrix(v, 0, n - 1, 0, n - 1);
    }
  }
#line 560
  return (0);
}
}
#line 568 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
int svdsolve_s(double **a , double b[] , int m , int n , int s ) 
{ 
  int i ;
  int j ;
  double *w ;
  double W[8] ;
  int *sw ;
  int SW[8] ;
  double **v ;
  double *VP[8] ;
  double V[8][8] ;
  double maxw ;
  double *__cil_tmp16 ;
  int *__cil_tmp17 ;
  double **__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int tt ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 581
  if (n <= 8) {
#line 582
    w = (double *)W;
#line 583
    sw = (int *)SW;
#line 584
    VP[0] = (double *)V[0];
#line 584
    VP[1] = (double *)V[1];
#line 584
    VP[2] = (double *)V[2];
#line 584
    VP[3] = (double *)V[3];
#line 585
    VP[4] = (double *)V[4];
#line 585
    VP[5] = (double *)V[5];
#line 585
    VP[6] = (double *)V[6];
#line 585
    VP[7] = (double *)V[7];
#line 586
    v = (double **)VP;
  } else {
    {
#line 588
    w = dvector(0, n - 1);
#line 589
    sw = ivector(0, n - 1);
#line 590
    v = dmatrix(0, n - 1, 0, n - 1);
    }
  }
  {
#line 594
  __cil_tmp19 = svdecomp(a, w, v, m, n);
  }
#line 594
  if (__cil_tmp19) {
#line 595
    if (w != (double *)W) {
      {
#line 596
      free_dvector(w, 0, n - 1);
#line 597
      free_dmatrix(v, 0, n - 1, 0, n - 1);
      }
    }
#line 599
    return (1);
  }
#line 603
  i = 0;
#line 603
  maxw = 0.;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i < n)) {
#line 603
      goto while_break;
    }
#line 604
    *(sw + i) = i;
#line 605
    if (*(w + i) > maxw) {
#line 606
      maxw = *(w + i);
    }
#line 603
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  maxw *= 1e-12;
#line 611
  i = 0;
  {
#line 611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 611
    if (! (i < n - 1)) {
#line 611
      goto while_break___0;
    }
#line 612
    j = i + 1;
    {
#line 612
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 612
      if (! (j < n)) {
#line 612
        goto while_break___1;
      }
#line 613
      if (*(w + *(sw + i)) > *(w + *(sw + j))) {
#line 614
        tt = *(sw + i);
#line 615
        *(sw + i) = *(sw + j);
#line 616
        *(sw + j) = tt;
      }
#line 612
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 611
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 622
  s = n - s;
#line 623
  if (s < 0) {
#line 624
    s = 0;
  }
#line 625
  if (s > n) {
#line 626
    s = n;
  }
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 627
    if (! (i < s)) {
#line 627
      goto while_break___2;
    }
#line 628
    *(w + *(sw + i)) = 0.;
#line 627
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 631
  i = 0;
#line 631
  maxw = 0.;
  {
#line 631
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 631
    if (! (i < n)) {
#line 631
      goto while_break___3;
    }
#line 632
    if (*(w + i) < maxw) {
#line 633
      *(w + i) = 0.;
    }
#line 631
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 637
  svdbacksub(a, w, v, b, b, m, n);
  }
#line 639
  if (w != (double *)W) {
    {
#line 640
    free_dvector(w, 0, n - 1);
#line 641
    free_ivector(sw, 0, n - 1);
#line 642
    free_dmatrix(v, 0, n - 1, 0, n - 1);
    }
  }
#line 644
  return (0);
}
}
#line 25 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.h"
int solve_se(double **a , double *b , int n ) ;
#line 34
int polished_solve_se(double **a , double *b , int n ) ;
#line 44
int lu_decomp(double **a , int n , int *pivx , double *rip ) ;
#line 54
void lu_backsub(double **a , int n , int *pivx , double *b ) ;
#line 63
void lu_polish(double **a , double **lua , int n , double *b , double *x , int *pivx ) ;
#line 77
int lu_invert(double **a , int n ) ;
#line 86
int lu_invert_normal(double **a , int n ) ;
#line 96
int lu_polished_invert(double **a , int n ) ;
#line 104
int lu_psinvert(double **out , double **in , int m , int n ) ;
#line 117
int llt_decomp(double **L , double **A , int n ) ;
#line 122
void llt_backsub(double **L , int n , double *b , double *x ) ;
#line 654 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
int gen_solve_se(double **a , double b[] , int m , int n ) 
{ 
  double tt ;
  double __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 660
  if (n == m) {
#line 661
    if (n == 1) {
      {
#line 662
      tt = *(*(a + 0) + 0);
#line 663
      __cil_tmp6 = fabs(tt);
      }
#line 663
      if (__cil_tmp6 <= (double )2.22507385851e-308L) {
#line 664
        return (1);
      }
#line 665
      b[0] /= tt;
#line 666
      return (0);
    } else {
      {
#line 668
      __cil_tmp7 = solve_se(a, b, n);
      }
#line 668
      return (__cil_tmp7);
    }
  } else {
    {
#line 671
    __cil_tmp8 = svdsolve(a, b, m, n);
    }
#line 671
    return (__cil_tmp8);
  }
}
}
#line 679 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/svd.c"
static void svdinverse(double **u , double *w , double **v , double **ia , int m ,
                       int n ) 
{ 
  int i ;
  int j ;
  int k ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 689
  j = 0;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! (j < n)) {
#line 689
      goto while_break;
    }
#line 690
    i = 0;
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! (i < m)) {
#line 690
        goto while_break___0;
      }
#line 691
      *(*(ia + j) + i) = 0.;
#line 692
      k = 0;
      {
#line 692
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 692
        if (! (k < n)) {
#line 692
          goto while_break___1;
        }
#line 693
        if (*(w + k) != 0.) {
#line 694
          *(*(ia + j) + i) += (*(*(v + j) + k) * *(*(u + i) + k)) / *(w + k);
        }
#line 692
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 690
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 689
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.h"
sobol *new_sobol(int dim ) ;
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
static int sobol_poly[40]  = 
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
  {      1,      3,      7,      11, 
        13,      19,      25,      37, 
        59,      47,      61,      55, 
        41,      67,      97,      91, 
        109,      103,      115,      131, 
        193,      137,      145,      143, 
        241,      157,      185,      167, 
        229,      171,      213,      191, 
        253,      203,      211,      239, 
        247,      285,      369,      299};
#line 52 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
static int vinit[8][40]  = 
#line 52
  { {        0,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1, 
            1,        1,        1,        1}, 
   {        0,        0,        1,        3, 
            1,        3,        1,        3, 
            3,        1,        3,        1, 
            3,        1,        3,        1, 
            1,        3,        1,        3, 
            1,        3,        1,        3, 
            3,        1,        3,        1, 
            3,        1,        3,        1, 
            1,        3,        1,        3, 
            1,        3,        1,        3}, 
   {        0,        0,        0,        7, 
            5,        1,        3,        3, 
            7,        5,        5,        7, 
            7,        1,        3,        3, 
            7,        5,        1,        1, 
            5,        3,        3,        1, 
            7,        5,        1,        3, 
            3,        7,        5,        1, 
            1,        5,        7,        7, 
            5,        1,        3,        3}, 
   {        0,        0,        0,        0, 
            0,        1,        7,        9, 
            13,        11,        1,        3, 
            7,        9,        5,        13, 
            13,        11,        3,        15, 
            5,        3,        15,        7, 
            9,        13,        9,        1, 
            11,        7,        5,        15, 
            1,        15,        11,        5, 
            3,        1,        7,        9}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        9, 
            3,        27,        15,        29, 
            21,        23,        19,        11, 
            25,        7,        13,        17, 
            1,        25,        29,        3, 
            31,        11,        5,        23, 
            27,        19,        21,        5, 
            1,        17,        13,        7, 
            15,        9,        31,        9}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        37,        33,        7, 
            5,        11,        39,        63, 
            27,        17,        15,        23, 
            29,        3,        21,        13, 
            31,        25,        9,        49, 
            33,        19,        29,        11, 
            19,        27,        15,        25}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        13, 
            33,        115,        41,        79, 
            17,        29,        119,        75, 
            73,        105,        7,        59, 
            65,        21,        3,        113, 
            61,        89,        45,        107}, 
   {        0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        0,        0,        0, 
            0,        7,        23,        39}};
#line 105 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
static int next_sobol(sobol *s , double *v ) 
{ 
  int i ;
  int p ;
  unsigned int c ;
  unsigned int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 109
  (s->count) ++;
#line 112
  p = 0;
#line 112
  c = s->count;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((c & 1U) == 0U)) {
#line 112
      goto while_break;
    }

#line 112
    c >>= 1;
#line 112
    __cil_tmp7 = p;
#line 112
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (p > 30) {
#line 116
    return (1);
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 118
    if (! (i < s->dim)) {
#line 118
      goto while_break___0;
    }
#line 119
    s->lastq[i] ^= s->dir[p][i];
#line 120
    *(v + i) = (double )s->lastq[i] * s->recipd;
#line 118
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 123
  return (0);
}
}
#line 127 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
static void del_sobol(sobol *s ) 
{ 


  {
#line 128
  if (s != (void *)0) {
    {
#line 129
    free(s);
    }
  }
  return;
}
}
#line 133 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
static void reset_sobol(sobol *s ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 137
  s->count = (unsigned int )0;
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < s->dim)) {
#line 138
      goto while_break;
    }
#line 139
    s->lastq[i] = 0;
#line 138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 143 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/sobol.c"
sobol *new_sobol(int dim ) 
{ 
  sobol *s ;
  int i ;
  int j ;
  int p ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  int m ;
  int pm ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int k ;
  int newv ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 144
  s = (sobol *)((void *)0);
#line 147
  if (dim < 1) {
#line 148
    return ((sobol *)((void *)0));
  } else
#line 147
  if (dim > 40) {
#line 148
    return ((sobol *)((void *)0));
  }
  {
#line 151
  __cil_tmp6 = malloc(sizeof(sobol ));
#line 151
  s = (sobol *)__cil_tmp6;
  }
#line 151
  if (s == (void *)0) {
#line 152
    return ((sobol *)((void *)0));
  }
#line 155
  s->dim = dim;
#line 156
  s->next = & next_sobol;
#line 157
  s->reset = & reset_sobol;
#line 158
  s->del = & del_sobol;
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < dim)) {
#line 161
      goto while_break;
    }
#line 163
    if (i == 0) {
#line 164
      j = 0;
      {
#line 164
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 164
        if (! (j < 30)) {
#line 164
          goto while_break___0;
        }
#line 165
        s->dir[j][i] = 1;
#line 164
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 171
      pm = sobol_poly[i] >> 1;
#line 171
      m = 0;
      {
#line 171
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 171
        if (! (pm != 0)) {
#line 171
          goto while_break___1;
        }

#line 171
        pm >>= 1;
#line 171
        __cil_tmp10 = m;
#line 171
        m ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 175
      j = 0;
      {
#line 175
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 175
        if (! (j < m)) {
#line 175
          goto while_break___2;
        }
#line 176
        s->dir[j][i] = vinit[j][i];
#line 175
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 181
      pm = sobol_poly[i];
#line 182
      j = m;
      {
#line 182
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 182
        if (! (j < 30)) {
#line 182
          goto while_break___3;
        }
#line 184
        newv = s->dir[j - m][i];
#line 185
        k = 0;
        {
#line 185
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 185
          if (! (k < m)) {
#line 185
            goto while_break___4;
          }
#line 186
          if (pm & (1 << ((m - k) - 1))) {
#line 187
            newv ^= s->dir[(j - k) - 1][i] << (k + 1);
          }
#line 185
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 190
        s->dir[j][i] = newv;
#line 182
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 28;
#line 195
  p = 2;
  {
#line 195
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 195
    if (! (j >= 0)) {
#line 195
      goto while_break___5;
    }
#line 196
    i = 0;
    {
#line 196
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 196
      if (! (i < dim)) {
#line 196
        goto while_break___6;
      }
#line 197
      s->dir[j][i] *= p;
#line 196
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 195
    p <<= 1;
#line 195
    __cil_tmp18 = j;
#line 195
    j --;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 201
  s->recipd = 1. / (double )(1 << 30);
#line 204
  s->count = (unsigned int )0;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 205
    if (! (i < dim)) {
#line 205
      goto while_break___7;
    }
#line 206
    s->lastq[i] = 0;
#line 205
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 208
  return (s);
}
}
#line 51 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/roots.c"
int SolveQuadric(double c[3] , double s[2] ) 
{ 
  double p ;
  double q ;
  double D ;
  double sqrt_D ;
  double __cil_tmp7 ;

  {
#line 55
  p = c[1] / ((double )2 * c[2]);
#line 56
  q = c[0] / c[2];
#line 58
  D = p * p - q;
#line 60
  if (D > - 1.00000000001e-09) {
#line 60
    if (D < 1.00000000001e-09) {
#line 61
      s[0] = - p;
#line 62
      return (1);
    } else {
#line 60
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 63
  if (D < (double )0) {
#line 64
    return (0);
  } else {
    {
#line 66
    __cil_tmp7 = sqrt(D);
#line 66
    sqrt_D = __cil_tmp7;
#line 68
    s[0] = sqrt_D - p;
#line 69
    s[1] = - sqrt_D - p;
    }
#line 70
    return (2);
  }
}
}
#line 75 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/roots.c"
int SolveCubic(double c[4] , double s[3] ) 
{ 
  int i ;
  int num ;
  double sub ;
  double A ;
  double B ;
  double C ;
  double sq_A ;
  double p ;
  double q ;
  double cb_p ;
  double D ;
  double u ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double tmp ;
  double tmp___0 ;
  double phi ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double t ;
  double __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double __cil_tmp26 ;
  double sqrt_D ;
  double __cil_tmp28 ;
  double u___0 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  double tmp___1 ;
  double tmp___2 ;
  double v ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  double tmp___3 ;
  double tmp___4 ;
  int __cil_tmp39 ;

  {
#line 83
  A = c[2] / c[3];
#line 84
  B = c[1] / c[3];
#line 85
  C = c[0] / c[3];
#line 89
  sq_A = A * A;
#line 90
  p = (1. / (double )3) * ((- 1. / (double )3) * sq_A + B);
#line 91
  q = (1. / (double )2) * ((((2. / (double )27) * A) * sq_A - ((1. / (double )3) * A) * B) + C);
#line 94
  cb_p = (p * p) * p;
#line 95
  D = q * q + cb_p;
#line 97
  if (D > - 1.00000000001e-09) {
#line 97
    if (D < 1.00000000001e-09) {
#line 98
      if (q > - 1.00000000001e-09) {
#line 98
        if (q < 1.00000000001e-09) {
#line 99
          s[0] = 0.;
#line 100
          num = 1;
        } else {
#line 98
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 102
        if (- q > 0.) {
          {
#line 102
          __cil_tmp15 = pow((double )(- q), 1. / 3.);
#line 102
          tmp___0 = __cil_tmp15;
          }
        } else {
#line 102
          if (- q < 0.) {
            {
#line 102
            __cil_tmp16 = pow((double )(- (- q)), 1. / 3.);
#line 102
            tmp = - __cil_tmp16;
            }
          } else {
#line 102
            tmp = 0.;
          }
#line 102
          tmp___0 = tmp;
        }
#line 102
        u = tmp___0;
#line 103
        s[0] = 2. * u;
#line 104
        s[1] = - u;
#line 105
        num = 2;
      }
    } else {
#line 97
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 107
  if (D < (double )0) {
    {
#line 108
    __cil_tmp20 = sqrt(- cb_p);
#line 108
    __cil_tmp21 = acos(- q / __cil_tmp20);
#line 108
    phi = (1. / (double )3) * __cil_tmp21;
#line 109
    __cil_tmp23 = sqrt(- p);
#line 109
    t = (double )2 * __cil_tmp23;
#line 111
    __cil_tmp24 = cos(phi);
#line 111
    s[0] = t * __cil_tmp24;
#line 112
    __cil_tmp25 = cos(phi + 3.14159265359 / 3.);
#line 112
    s[1] = - t * __cil_tmp25;
#line 113
    __cil_tmp26 = cos(phi - 3.14159265359 / 3.);
#line 113
    s[2] = - t * __cil_tmp26;
#line 114
    num = 3;
    }
  } else {
    {
#line 116
    __cil_tmp28 = sqrt(D);
#line 116
    sqrt_D = __cil_tmp28;
    }
#line 117
    if (sqrt_D - q > 0.) {
      {
#line 117
      __cil_tmp30 = pow((double )(sqrt_D - q), 1. / 3.);
#line 117
      tmp___2 = __cil_tmp30;
      }
    } else {
#line 117
      if (sqrt_D - q < 0.) {
        {
#line 117
        __cil_tmp31 = pow((double )(- (sqrt_D - q)), 1. / 3.);
#line 117
        tmp___1 = - __cil_tmp31;
        }
      } else {
#line 117
        tmp___1 = 0.;
      }
#line 117
      tmp___2 = tmp___1;
    }
#line 117
    u___0 = tmp___2;
#line 118
    if (sqrt_D + q > 0.) {
      {
#line 118
      __cil_tmp35 = pow((double )(sqrt_D + q), 1. / 3.);
#line 118
      tmp___4 = __cil_tmp35;
      }
    } else {
#line 118
      if (sqrt_D + q < 0.) {
        {
#line 118
        __cil_tmp36 = pow((double )(- (sqrt_D + q)), 1. / 3.);
#line 118
        tmp___3 = - __cil_tmp36;
        }
      } else {
#line 118
        tmp___3 = 0.;
      }
#line 118
      tmp___4 = tmp___3;
    }
#line 118
    v = - tmp___4;
#line 120
    s[0] = u___0 + v;
#line 121
    num = 1;
  }
#line 125
  sub = (1. / 3.) * A;
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < num)) {
#line 127
      goto while_break;
    }
#line 128
    s[i] -= sub;
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (num);
}
}
#line 134 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/roots.c"
int SolveQuartic(double c[5] , double s[4] ) 
{ 
  double coeffs[4] ;
  double z ;
  double u ;
  double v ;
  double sub ;
  double A ;
  double B ;
  double C ;
  double D ;
  double sq_A ;
  double p ;
  double q ;
  double r ;
  int i ;
  int num ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double tmp ;
  int __cil_tmp23 ;
  double tmp___0 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;

  {
#line 142
  A = c[3] / c[4];
#line 143
  B = c[2] / c[4];
#line 144
  C = c[1] / c[4];
#line 145
  D = c[0] / c[4];
#line 149
  sq_A = A * A;
#line 150
  p = (- 3. / (double )8) * sq_A + B;
#line 151
  q = (((1. / (double )8) * sq_A) * A - ((1. / (double )2) * A) * B) + C;
#line 152
  r = ((((- 3. / (double )256) * sq_A) * sq_A + ((1. / (double )16) * sq_A) * B) - ((1. / (double )4) * A) * C) + D;
#line 154
  if (r > - 1.00000000001e-09) {
#line 154
    if (r < 1.00000000001e-09) {
      {
#line 157
      coeffs[0] = q;
#line 158
      coeffs[1] = p;
#line 159
      coeffs[2] = (double )0;
#line 160
      coeffs[3] = 1.;
#line 162
      num = SolveCubic((double *)coeffs, s);
#line 164
      __cil_tmp19 = num;
#line 164
      num ++;
#line 164
      s[__cil_tmp19] = (double )0;
      }
    } else {
#line 154
      goto _L___11;
    }
  } else {
    _L___11: /* CIL Label */ 
    {
#line 167
    coeffs[0] = ((1. / 2.) * r) * p - ((1. / 8.) * q) * q;
#line 168
    coeffs[1] = - r;
#line 169
    coeffs[2] = (- 1. / 2.) * p;
#line 170
    coeffs[3] = 1.;
#line 172
    SolveCubic((double *)coeffs, s);
#line 175
    z = s[0];
#line 178
    u = z * z - r;
#line 179
    v = (double )2 * z - p;
    }
#line 181
    if (u > - 1.00000000001e-09) {
#line 181
      if (u < 1.00000000001e-09) {
#line 182
        u = (double )0;
      } else {
#line 181
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 183
    if (u > (double )0) {
      {
#line 184
      u = sqrt(u);
      }
    } else {
#line 186
      return (0);
    }
#line 188
    if (v > - 1.00000000001e-09) {
#line 188
      if (v < 1.00000000001e-09) {
#line 189
        v = (double )0;
      } else {
#line 188
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 190
    if (v > (double )0) {
      {
#line 191
      v = sqrt(v);
      }
    } else {
#line 193
      return (0);
    }
#line 195
    coeffs[0] = z - u;
#line 196
    if (q < (double )0) {
#line 196
      tmp = - v;
    } else {
#line 196
      tmp = v;
    }
    {
#line 196
    coeffs[1] = tmp;
#line 197
    coeffs[2] = 1.;
#line 199
    num = SolveQuadric((double *)coeffs, s);
#line 201
    coeffs[0] = z + u;
    }
#line 202
    if (q < (double )0) {
#line 202
      tmp___0 = v;
    } else {
#line 202
      tmp___0 = - v;
    }
    {
#line 202
    coeffs[1] = tmp___0;
#line 203
    coeffs[2] = 1.;
#line 205
    __cil_tmp25 = SolveQuadric((double *)coeffs, s + num);
    }
#line 205
    num += __cil_tmp25;
  }
#line 209
  sub = (1. / 4.) * A;
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < num)) {
#line 211
      goto while_break;
    }
#line 212
    s[i] -= sub;
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return (num);
}
}
#line 21 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.h"
unsigned int rand32(unsigned int seed ) ;
#line 25
int i_rand(int min , int max ) ;
#line 28
double d_rand(double min , double max ) ;
#line 31
double d2_rand(double min , double max ) ;
#line 37
double norm_rand(void) ;
#line 65
double NORM_RAND_ABS_SCALE[20] ;
#line 86
void rand_init(rand_state *p ) ;
#line 90
unsigned int rand32_th(rand_state *p , unsigned int seed ) ;
#line 94
int i_rand_th(rand_state *p , int min , int max ) ;
#line 97
double d_rand_th(rand_state *p , double min , double max ) ;
#line 100
double d2_rand_th(rand_state *p , double min , double max ) ;
#line 105
double norm_rand_th(rand_state *p ) ;
#line 108
void vect_rand(double *d , double min , double max , int len ) ;
#line 25 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
static rand_state g_rand  =    {0, 0U, 0U, {(unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0, (unsigned int )0,
                (unsigned int )0, (unsigned int )0, (unsigned int )0}, 0, 0.};
#line 30 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
unsigned int rand32(unsigned int seed ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 33
  __cil_tmp2 = rand32_th((rand_state *)((void *)0), seed);
  }
#line 33
  return (__cil_tmp2);
}
}
#line 38 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double ranno(void) 
{ 
  unsigned int __cil_tmp1 ;

  {
  {
#line 39
  __cil_tmp1 = rand32_th((rand_state *)((void *)0), (unsigned int )0);
  }
#line 39
  return ((double )__cil_tmp1 / 4294967295.);
}
}
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double d_rand(double min , double max ) 
{ 
  double __cil_tmp3 ;

  {
  {
#line 45
  __cil_tmp3 = d_rand_th((rand_state *)((void *)0), min, max);
  }
#line 45
  return (__cil_tmp3);
}
}
#line 50 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double d2_rand(double min , double max ) 
{ 
  double __cil_tmp3 ;

  {
  {
#line 51
  __cil_tmp3 = d2_rand_th((rand_state *)((void *)0), min, max);
  }
#line 51
  return (__cil_tmp3);
}
}
#line 56 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
int i_rand(int min , int max ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 57
  __cil_tmp3 = i_rand_th((rand_state *)((void *)0), min, max);
  }
#line 57
  return (__cil_tmp3);
}
}
#line 63 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double norm_rand(void) 
{ 
  double __cil_tmp1 ;

  {
  {
#line 64
  __cil_tmp1 = norm_rand_th((rand_state *)((void *)0));
  }
#line 64
  return (__cil_tmp1);
}
}
#line 71 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
void rand_init(rand_state *p ) 
{ 


  {
#line 72
  if (p == (void *)0) {
#line 73
    p = & g_rand;
  }
  {
#line 74
  memset((void *)p, 0, sizeof(rand_state ));
  }
  return;
}
}
#line 80 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
unsigned int rand32_th(rand_state *p , unsigned int seed ) 
{ 
  int i ;
  unsigned int tmp ;
  int __cil_tmp5 ;
  unsigned int tmp___0 ;

  {
#line 85
  if (p == (void *)0) {
#line 86
    p = & g_rand;
  }
#line 88
  if (seed != 0U) {
    {
#line 90
    rand_init(p);
#line 91
    p->ran = seed;
    }
  }
#line 95
  if (p->pvs_inited == 0) {
#line 96
    if (p->ran == 0U) {
#line 97
      p->ran = (unsigned int )305419896;
    }
#line 98
    i = 0;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! (i < 2843)) {
#line 98
        goto while_break;
      }
#line 99
      if (p->ran & 2147483648U) {
#line 99
        tmp = (p->ran << 1) ^ 2744673629U;
      } else {
#line 99
        tmp = p->ran << 1;
      }
#line 99
      p->ran = tmp;
#line 99
      p->pvs[i] = p->ran;
#line 98
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 100
    p->last = p->ran;
#line 101
    p->pvs_inited = 1;
  }
#line 103
  i = (int )(p->last % 2843U);
#line 104
  p->last = p->pvs[i];
#line 105
  if (p->ran & 2147483648U) {
#line 105
    tmp___0 = (p->ran << 1) ^ 2744673629U;
  } else {
#line 105
    tmp___0 = p->ran << 1;
  }
#line 105
  p->ran = tmp___0;
#line 105
  p->pvs[i] = p->ran;
#line 108
  return (p->last - 1U);
}
}
#line 113 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double ranno_th(rand_state *p ) 
{ 
  unsigned int __cil_tmp2 ;

  {
  {
#line 114
  __cil_tmp2 = rand32_th(p, (unsigned int )0);
  }
#line 114
  return ((double )__cil_tmp2 / 4294967295.);
}
}
#line 119 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double d_rand_th(rand_state *p , double min , double max ) 
{ 
  double __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = ranno_th(p);
  }
#line 120
  return (min + (max - min) * __cil_tmp4);
}
}
#line 125 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double d2_rand_th(rand_state *p , double min , double max ) 
{ 
  double val ;
  double __cil_tmp5 ;

  {
  {
#line 126
  __cil_tmp5 = ranno_th(p);
#line 126
  val = __cil_tmp5;
  }
#line 127
  return (min + ((max - min) * val) * val);
}
}
#line 132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
int i_rand_th(rand_state *p , int min , int max ) 
{ 
  double __cil_tmp4 ;
  double __cil_tmp5 ;

  {
  {
#line 133
  __cil_tmp4 = ranno_th(p);
#line 133
  __cil_tmp5 = floor(0.5 + (double )(max - min) * __cil_tmp4);
  }
#line 133
  return (min + (int )__cil_tmp5);
}
}
#line 139 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double norm_rand_th(rand_state *p ) 
{ 
  double v1 ;
  double v2 ;
  double t1 ;
  double t2 ;
  double r1 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 140
  if (p == (void *)0) {
#line 141
    p = & g_rand;
  }
#line 143
  if (p->r2 == 0) {
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 146
      v1 = d_rand_th(p, - 1., 1.);
#line 147
      v2 = d_rand_th(p, - 1., 1.);
#line 148
      t1 = v1 * v1 + v2 * v2;
      }
#line 145
      if (! (t1 == 0. || t1 >= 1.)) {
#line 145
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 150
    __cil_tmp9 = log(t1);
#line 150
    __cil_tmp10 = sqrt((- 2. * __cil_tmp9) / t1);
#line 150
    t2 = __cil_tmp10;
#line 151
    p->nr2 = v2 * t2;
#line 152
    p->r2 = 1;
#line 153
    r1 = v1 * t2;
    }
#line 154
    return (r1);
  } else {
#line 156
    p->r2 = 0;
#line 157
    return (p->nr2);
  }
}
}
#line 162 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
void vect_rand(double *d , double min , double max , int len ) 
{ 
  int i ;
  double __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < len)) {
#line 164
      goto while_break;
    }
    {
#line 165
    *(d + i) = d_rand(min, max);
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 173 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/rand.c"
double NORM_RAND_ABS_SCALE[20]  = 
#line 173
  {      0.,      1.25331413732,      0.797884560803,      0.626657068658, 
        0.531923040536,      0.469992801494,      0.425538432429,      0.391660667912, 
        0.364747227796,      0.342703084423,      0.324219758041,      0.30843277598, 
        0.294745234583,      0.282730044649,      0.27207252423,      0.26253504146, 
        0.253934355948,      0.246126601368,      0.238997040893,      0.232452901292};
#line 56 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.h"
double quadprog(double *x , double **G , double *g0 , double **CE , double *ce0 ,
                double **CI , double *ci0 , int n , int p , int m ) ;
#line 70 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void compute_d(double *d , double **J , double *np , int n ) ;
#line 71
__inline static void update_z(double *z , double **J , double *d , int iq , int n ) ;
#line 72
__inline static void update_r(double **R , double *r , double *d , int iq , int n ) ;
#line 73
static int add_constraint(double **R , double **J , double *d , int *piq , double *prnorm ,
                          int n ) ;
#line 74
static void delete_constraint(double **R , double **J , int *A , double *u , int n ,
                              int p , int *piq , int l ) ;
#line 79
static void cholesky_decomposition(double **A , int n ) ;
#line 80
static void cholesky_solve(double **L , double *x , double *b , int n ) ;
#line 81
__inline static void forward_elimination(double **L , double *y , double *b , int n ) ;
#line 82
__inline static void backward_elimination(double **U , double *x , double *y , int n ) ;
#line 86
__inline static double scalar_product(double *x , double *y , int n ) ;
#line 87
__inline static double distance(double a , double b ) ;
#line 90
static void print_matrix(char *name , double **A , int n , int m ) ;
#line 92
static void print_vector(char *name , double *v , int n ) ;
#line 93
static void print_ivector(char *name , int *v , int n ) ;
#line 102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
double quadprog(double *x , double **G , double *g0 , double **CE , double *ce0 ,
                double **CI , double *ci0 , int n , int p , int m ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int ip ;
  double f_value ;
  double psi ;
  double c1 ;
  double c2 ;
  double sum ;
  double ss ;
  double R_norm ;
  double inf ;
  double t ;
  double t1 ;
  double t2 ;
  int q ;
  int iq ;
  int iter ;
  double **R ;
  double **J ;
  double *s ;
  double *z ;
  double *r ;
  double *d ;
  double *np ;
  double *u ;
  double *x_old ;
  double *u_old ;
  int *A ;
  int *A_old ;
  int *iai ;
  short *iaexcl ;
  double *_R[10] ;
  double __R[10][10] ;
  double *_J[10] ;
  double __J[10][10] ;
  double _s[20] ;
  double _z[20] ;
  double _r[20] ;
  double _d[20] ;
  double _np[20] ;
  double _u[20] ;
  double _x_old[20] ;
  double _u_old[20] ;
  int _A[20] ;
  int _A_old[20] ;
  int _iai[20] ;
  short _iaexcl[20] ;
  int __cil_tmp60 ;
  double **__cil_tmp61 ;
  double **__cil_tmp62 ;
  double *__cil_tmp63 ;
  double *__cil_tmp64 ;
  double *__cil_tmp65 ;
  double *__cil_tmp66 ;
  double *__cil_tmp67 ;
  double *__cil_tmp68 ;
  double *__cil_tmp69 ;
  double *__cil_tmp70 ;
  int *__cil_tmp71 ;
  int *__cil_tmp72 ;
  int *__cil_tmp73 ;
  short *__cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;
  int __cil_tmp80 ;
  double __cil_tmp81 ;
  int __cil_tmp82 ;
  double __cil_tmp83 ;
  double __cil_tmp84 ;
  double __cil_tmp85 ;
  double __cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  double __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  double tmp ;
  int __cil_tmp97 ;
  double __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int __cil_tmp103 ;
  double __cil_tmp104 ;
  double __cil_tmp105 ;
  double __cil_tmp106 ;
  double tmp___0 ;
  int __cil_tmp108 ;
  int __cil_tmp109 ;
  double __cil_tmp110 ;
  int __cil_tmp111 ;
  double __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  int __cil_tmp116 ;
  int __cil_tmp117 ;

  {
#line 116
  f_value = 1.00000000001e+300;
#line 120
  iter = 0;
#line 133
  if (n <= 10) {
#line 134
    R = (double **)_R;
#line 135
    J = (double **)_J;
#line 136
    i = 0;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! (i < n)) {
#line 136
        goto while_break;
      }
#line 137
      _R[i] = (double *)__R[i];
#line 138
      _J[i] = (double *)__J[i];
#line 136
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 141
    R = dmatrix(0, n - 1, 0, n - 1);
#line 142
    J = dmatrix(0, n - 1, 0, n - 1);
    }
  }
#line 145
  if (n <= 20) {
#line 146
    x_old = (double *)_x_old;
#line 147
    z = (double *)_z;
#line 148
    d = (double *)_d;
#line 149
    np = (double *)_np;
  } else {
    {
#line 151
    x_old = dvector(0, n - 1);
#line 152
    z = dvector(0, n - 1);
#line 153
    d = dvector(0, n - 1);
#line 154
    np = dvector(0, n - 1);
    }
  }
#line 157
  if (m + p <= 20) {
#line 158
    s = (double *)_s;
#line 159
    r = (double *)_r;
#line 160
    u = (double *)_u;
#line 161
    u_old = (double *)_u_old;
#line 162
    A = (int *)_A;
#line 163
    A_old = (int *)_A_old;
#line 164
    iai = (int *)_iai;
#line 165
    iaexcl = (short *)_iaexcl;
  } else {
    {
#line 167
    s = dvector(0, (m + p) - 1);
#line 168
    r = dvector(0, (m + p) - 1);
#line 169
    u = dvector(0, (m + p) - 1);
#line 170
    u_old = dvector(0, (m + p) - 1);
#line 171
    A = ivector(0, (m + p) - 1);
#line 172
    A_old = ivector(0, (m + p) - 1);
#line 173
    iai = ivector(0, (m + p) - 1);
#line 174
    iaexcl = svector(0, (m + p) - 1);
    }
  }
#line 177
  q = 0;
#line 194
  c1 = 0.;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < n)) {
#line 195
      goto while_break___0;
    }
#line 196
    c1 += *(*(G + i) + i);
#line 195
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 198
  cholesky_decomposition(G, n);
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 204
    if (! (i < n)) {
#line 204
      goto while_break___1;
    }
#line 205
    *(d + i) = 0.;
#line 206
    j = 0;
    {
#line 206
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 206
      if (! (j < n)) {
#line 206
        goto while_break___2;
      }
#line 207
      *(*(R + i) + j) = 0.;
#line 206
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 204
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 209
  R_norm = 1.;
#line 212
  c2 = 0.;
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 213
    if (! (i < n)) {
#line 213
      goto while_break___3;
    }
    {
#line 214
    *(d + i) = 1.;
#line 215
    forward_elimination(G, z, d, n);
#line 216
    j = 0;
    }
    {
#line 216
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 216
      if (! (j < n)) {
#line 216
        goto while_break___4;
      }
#line 217
      *(*(J + i) + j) = *(z + j);
#line 216
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 218
    c2 += *(z + i);
#line 219
    *(d + i) = 0.;
#line 213
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 230
  cholesky_solve(G, x, g0, n);
#line 231
  i = 0;
  }
  {
#line 231
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 231
    if (! (i < n)) {
#line 231
      goto while_break___5;
    }
#line 232
    *(x + i) = - *(x + i);
#line 231
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 234
  __cil_tmp81 = scalar_product(g0, x, n);
#line 234
  f_value = 0.5 * __cil_tmp81;
#line 241
  iq = 0;
#line 242
  i = 0;
  }
  {
#line 242
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 242
    if (! (i < p)) {
#line 242
      goto while_break___6;
    }
#line 243
    j = 0;
    {
#line 243
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 243
      if (! (j < n)) {
#line 243
        goto while_break___7;
      }
#line 244
      *(np + j) = *(*(CE + j) + i);
#line 243
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 245
    compute_d(d, J, np, n);
#line 246
    update_z(z, J, d, iq, n);
#line 247
    update_r(R, r, d, iq, n);
#line 257
    t2 = 0.;
#line 258
    __cil_tmp83 = scalar_product(z, z, n);
#line 258
    __cil_tmp84 = fabs(__cil_tmp83);
    }
#line 258
    if (__cil_tmp84 > (double )2.22044604926e-16L) {
      {
#line 259
      __cil_tmp86 = scalar_product(z, np, n);
      }
      {
#line 259
      __cil_tmp85 = scalar_product(np, x, n);
#line 259
      t2 = (- __cil_tmp85 - *(ce0 + i)) / __cil_tmp86;
      }
    }
#line 262
    k = 0;
    {
#line 262
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 262
      if (! (k < n)) {
#line 262
        goto while_break___8;
      }
#line 263
      *(x + k) += t2 * *(z + k);
#line 262
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 266
    *(u + iq) = t2;
#line 267
    k = 0;
    {
#line 267
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 267
      if (! (k < iq)) {
#line 267
        goto while_break___9;
      }
#line 268
      *(u + k) -= t2 * *(r + k);
#line 267
      k ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 271
    __cil_tmp89 = scalar_product(z, np, n);
    }
    {
#line 271
    f_value += (0.5 * (t2 * t2)) * __cil_tmp89;
#line 272
    *(A + i) = - i - 1;
#line 274
    __cil_tmp90 = add_constraint(R, J, d, & iq, & R_norm, n);
    }
#line 274
    if (! __cil_tmp90) {
#line 279
      goto done;
    }
#line 242
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 284
  i = 0;
  {
#line 284
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 284
    if (! (i < m)) {
#line 284
      goto while_break___10;
    }
#line 285
    *(iai + i) = i;
#line 284
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  l1: 
#line 289
  iter ++;
#line 294
  i = p;
  {
#line 294
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 294
    if (! (i < iq)) {
#line 294
      goto while_break___11;
    }
#line 295
    ip = *(A + i);
#line 296
    *(iai + ip) = - 1;
#line 294
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 300
  ss = 0.;
#line 301
  psi = 0.;
#line 302
  ip = 0;
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 303
    if (! (i < m)) {
#line 303
      goto while_break___12;
    }
#line 304
    *(iaexcl + i) = (short )1;
#line 305
    sum = 0.;
#line 306
    j = 0;
    {
#line 306
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 306
      if (! (j < n)) {
#line 306
        goto while_break___13;
      }
#line 307
      sum += *(*(CI + j) + i) * *(x + j);
#line 306
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 308
    sum += *(ci0 + i);
#line 309
    *(s + i) = sum;
#line 310
    if (0. < sum) {
#line 310
      tmp = 0.;
    } else {
#line 310
      tmp = sum;
    }
#line 310
    psi += tmp;
#line 303
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 316
  __cil_tmp98 = fabs(psi);
  }
#line 316
  if (__cil_tmp98 <= ((((double )m * (double )2.22044604926e-16L) * c1) * c2) * 100.) {
#line 321
    q = iq;
#line 322
    goto done;
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 326
    if (! (i < iq)) {
#line 326
      goto while_break___14;
    }
#line 327
    *(u_old + i) = *(u + i);
#line 328
    *(A_old + i) = *(A + i);
#line 326
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 332
    if (! (i < n)) {
#line 332
      goto while_break___15;
    }
#line 333
    *(x_old + i) = *(x + i);
#line 332
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  l2: 
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 336
    if (! (i < m)) {
#line 336
      goto while_break___16;
    }
#line 337
    if (*(s + i) < ss) {
#line 337
      if (*(iai + i) != -1) {
#line 337
        if ((int )*(iaexcl + i)) {
#line 338
          ss = *(s + i);
#line 339
          ip = i;
        }
      }
    }
#line 336
    i ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 342
  if (ss >= 0.) {
#line 346
    q = iq;
#line 347
    goto done;
  }
#line 351
  i = 0;
  {
#line 351
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 351
    if (! (i < n)) {
#line 351
      goto while_break___17;
    }
#line 352
    *(np + i) = *(*(CI + i) + ip);
#line 351
    i ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 354
  *(u + iq) = 0.;
#line 356
  *(A + iq) = ip;
  l2a: 
  {
#line 366
  compute_d(d, J, np, n);
  }
  {
#line 367
  update_z(z, J, d, iq, n);
#line 369
  update_r(R, r, d, iq, n);
#line 380
  l = 0;
#line 383
  t1 = 1.00000000001e+300;
#line 385
  k = p;
  }
  {
#line 385
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 385
    if (! (k < iq)) {
#line 385
      goto while_break___18;
    }
#line 386
    if (*(r + k) > 0.) {
#line 387
      if (*(u + k) / *(r + k) < t1) {
#line 388
        t1 = *(u + k) / *(r + k);
#line 389
        l = *(A + k);
      }
    }
#line 385
    k ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 395
  __cil_tmp104 = scalar_product(z, z, n);
#line 395
  __cil_tmp105 = fabs(__cil_tmp104);
  }
#line 395
  if (__cil_tmp105 > (double )2.22044604926e-16L) {
    {
#line 396
    __cil_tmp106 = scalar_product(z, np, n);
#line 396
    t2 = - *(s + ip) / __cil_tmp106;
    }
#line 397
    if (t2 < (double )0) {
#line 398
      t2 = 1.00000000001e+300;
    }
  } else {
#line 400
    t2 = 1.00000000001e+300;
  }
#line 403
  if (t1 < t2) {
#line 403
    tmp___0 = t1;
  } else {
#line 403
    tmp___0 = t2;
  }
#line 403
  t = tmp___0;
#line 411
  if (t >= 1.00000000001e+300) {
#line 417
    q = iq;
#line 418
    f_value = 1.00000000001e+300;
#line 419
    goto done;
  }
#line 422
  if (t2 >= 1.00000000001e+300) {
#line 424
    k = 0;
    {
#line 424
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 424
      if (! (k < iq)) {
#line 424
        goto while_break___19;
      }
#line 425
      *(u + k) -= t * *(r + k);
#line 424
      k ++;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 426
    *(u + iq) += t;
#line 427
    *(iai + l) = l;
#line 428
    delete_constraint(R, J, A, u, n, p, & iq, l);
    }
#line 435
    goto l2a;
  }
#line 441
  k = 0;
  {
#line 441
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 441
    if (! (k < n)) {
#line 441
      goto while_break___20;
    }
#line 442
    *(x + k) += t * *(z + k);
#line 441
    k ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 444
  __cil_tmp110 = scalar_product(z, np, n);
  }
#line 444
  f_value += (t * __cil_tmp110) * (0.5 * t + *(u + iq));
#line 446
  k = 0;
  {
#line 446
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 446
    if (! (k < iq)) {
#line 446
      goto while_break___21;
    }
#line 447
    *(u + k) -= t * *(r + k);
#line 446
    k ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 448
  *(u + iq) += t;
#line 457
  __cil_tmp112 = fabs(t - t2);
  }
#line 457
  if (__cil_tmp112 < (double )2.22044604926e-16L) {
    {
#line 464
    __cil_tmp113 = add_constraint(R, J, d, & iq, & R_norm, n);
    }
#line 464
    if (! __cil_tmp113) {
      {
#line 468
      *(iaexcl + ip) = (short )0;
#line 469
      delete_constraint(R, J, A, u, n, p, & iq, ip);
#line 475
      i = 0;
      }
      {
#line 475
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 475
        if (! (i < m)) {
#line 475
          goto while_break___22;
        }
#line 476
        *(iai + i) = i;
#line 475
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 477
      i = p;
      {
#line 477
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 477
        if (! (i < iq)) {
#line 477
          goto while_break___23;
        }
#line 478
        *(A + i) = *(A_old + i);
#line 479
        *(u + i) = *(u_old + i);
#line 480
        *(iai + *(A + i)) = - 1;
#line 477
        i ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 482
      i = 0;
      {
#line 482
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 482
        if (! (i < n)) {
#line 482
          goto while_break___24;
        }
#line 483
        *(x + i) = *(x_old + i);
#line 482
        i ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 484
      goto l2;
    } else {
#line 486
      *(iai + ip) = - 1;
    }
#line 492
    goto l1;
  }
  {
#line 501
  *(iai + l) = l;
#line 502
  delete_constraint(R, J, A, u, n, p, & iq, l);
#line 509
  sum = 0.;
#line 510
  k = 0;
  }
  {
#line 510
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 510
    if (! (k < n)) {
#line 510
      goto while_break___25;
    }
#line 511
    sum += *(*(CI + k) + ip) * *(x + k);
#line 510
    k ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 512
  *(s + ip) = sum + *(ci0 + ip);
#line 517
  goto l2a;
  done: ;
#line 522
  if (n > 10) {
    {
#line 523
    free_dmatrix(R, 0, n - 1, 0, n - 1);
#line 524
    free_dmatrix(J, 0, n - 1, 0, n - 1);
    }
  }
#line 527
  if (n > 20) {
    {
#line 528
    free_dvector(x_old, 0, n - 1);
#line 529
    free_dvector(z, 0, n - 1);
#line 530
    free_dvector(d, 0, n - 1);
#line 531
    free_dvector(np, 0, n - 1);
    }
  }
#line 534
  if (m + p > 20) {
    {
#line 535
    free_dvector(s, 0, (m + p) - 1);
#line 536
    free_dvector(r, 0, (m + p) - 1);
#line 537
    free_dvector(u, 0, (m + p) - 1);
#line 538
    free_dvector(u_old, 0, (m + p) - 1);
#line 539
    free_ivector(A, 0, (m + p) - 1);
#line 540
    free_ivector(A_old, 0, (m + p) - 1);
#line 541
    free_ivector(iai, 0, (m + p) - 1);
#line 542
    free_svector(iaexcl, 0, (m + p) - 1);
    }
  }
#line 550
  return (f_value);
}
}
#line 553 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void compute_d(double *d , double **J , double *np , int n ) 
{ 
  int i ;
  int j ;
  double sum ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 558
  i = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i < n)) {
#line 558
      goto while_break;
    }
#line 559
    sum = 0.;
#line 560
    j = 0;
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 560
      if (! (j < n)) {
#line 560
        goto while_break___0;
      }
#line 561
      sum += *(*(J + j) + i) * *(np + j);
#line 560
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    *(d + i) = sum;
#line 558
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 566 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void update_z(double *z , double **J , double *d , int iq , int n ) 
{ 
  int i ;
  int j ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 570
  i = 0;
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < n)) {
#line 570
      goto while_break;
    }
#line 571
    *(z + i) = 0.;
#line 572
    j = iq;
    {
#line 572
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 572
      if (! (j < n)) {
#line 572
        goto while_break___0;
      }
#line 573
      *(z + i) += *(*(J + i) + j) * *(d + j);
#line 572
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 577 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void update_r(double **R , double *r , double *d , int iq , int n ) 
{ 
  int i ;
  int j ;
  double sum ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 582
  i = iq - 1;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! (i >= 0)) {
#line 582
      goto while_break;
    }
#line 583
    sum = 0.;
#line 584
    j = i + 1;
    {
#line 584
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 584
      if (! (j < iq)) {
#line 584
        goto while_break___0;
      }
#line 585
      sum += *(*(R + i) + j) * *(r + j);
#line 584
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 586
    *(r + i) = (*(d + i) - sum) / *(*(R + i) + i);
#line 582
    __cil_tmp10 = i;
#line 582
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 590 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static int add_constraint(double **R , double **J , double *d , int *piq , double *prnorm ,
                          int n ) 
{ 
  int iq ;
  int i ;
  int j ;
  int k ;
  double cc ;
  double ss ;
  double h ;
  double t1 ;
  double t2 ;
  double xny ;
  double __cil_tmp17 ;
  double __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;
  double __cil_tmp24 ;
  double tmp ;

  {
#line 591
  iq = *piq;
#line 602
  j = n - 1;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (! (j >= iq + 1)) {
#line 602
      goto while_break;
    }
    {
#line 611
    cc = *(d + (j - 1));
#line 612
    ss = *(d + j);
#line 613
    h = distance(cc, ss);
#line 614
    __cil_tmp18 = fabs(h);
    }
#line 614
    if (__cil_tmp18 < (double )2.22044604926e-16L) {
#line 615
      goto while_continue;
    }
#line 616
    *(d + j) = 0.;
#line 617
    ss /= h;
#line 618
    cc /= h;
#line 619
    if (cc < 0.) {
#line 620
      cc = - cc;
#line 621
      ss = - ss;
#line 622
      *(d + (j - 1)) = - h;
    } else {
#line 624
      *(d + (j - 1)) = h;
    }
#line 625
    xny = ss / (1. + cc);
#line 626
    k = 0;
    {
#line 626
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 626
      if (! (k < n)) {
#line 626
        goto while_break___0;
      }
#line 627
      t1 = *(*(J + k) + (j - 1));
#line 628
      t2 = *(*(J + k) + j);
#line 629
      *(*(J + k) + (j - 1)) = t1 * cc + t2 * ss;
#line 630
      *(*(J + k) + j) = xny * (t1 + *(*(J + k) + (j - 1))) - t2;
#line 626
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 602
    __cil_tmp20 = j;
#line 602
    j --;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  iq ++;
#line 634
  *piq = iq;
#line 636
  i = 0;
  {
#line 636
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 636
    if (! (i < iq)) {
#line 636
      goto while_break___1;
    }
#line 637
    *(*(R + i) + (iq - 1)) = *(d + i);
#line 636
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 645
  __cil_tmp22 = fabs(*(d + (iq - 1)));
  }
#line 645
  if (__cil_tmp22 <= (double )2.22044604926e-16L * *prnorm) {
#line 647
    return (0);
  }
  {
#line 649
  __cil_tmp23 = fabs(*(d + (iq - 1)));
  }
#line 649
  if (*prnorm > __cil_tmp23) {
#line 649
    tmp = *prnorm;
  } else {
    {
#line 649
    __cil_tmp24 = fabs(*(d + (iq - 1)));
#line 649
    tmp = __cil_tmp24;
    }
  }
#line 649
  *prnorm = (double )tmp;
#line 651
  return (1);
}
}
#line 654 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void delete_constraint(double **R , double **J , int *A , double *u , int n ,
                              int p , int *piq , int l ) 
{ 
  int iq ;
  int i ;
  int j ;
  int k ;
  int qq ;
  double cc ;
  double ss ;
  double h ;
  double xny ;
  double t1 ;
  double t2 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 656
  iq = *piq;
#line 657
  qq = - 1;
#line 665
  i = p;
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! (i < iq)) {
#line 665
      goto while_break;
    }
#line 666
    if (*(A + i) == l) {
#line 667
      qq = i;
#line 668
      goto while_break;
    }
#line 665
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 673
  i = qq;
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! (i < iq - 1)) {
#line 673
      goto while_break___0;
    }
#line 674
    *(A + i) = *(A + (i + 1));
#line 675
    *(u + i) = *(u + (i + 1));
#line 676
    j = 0;
    {
#line 676
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 676
      if (! (j < n)) {
#line 676
        goto while_break___1;
      }
#line 677
      *(*(R + j) + i) = *(*(R + j) + (i + 1));
#line 676
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 673
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 680
  *(A + (iq - 1)) = *(A + iq);
#line 681
  *(u + (iq - 1)) = *(u + iq);
#line 682
  *(A + iq) = 0;
#line 683
  *(u + iq) = 0.;
#line 684
  j = 0;
  {
#line 684
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 684
    if (! (j < iq)) {
#line 684
      goto while_break___2;
    }
#line 685
    *(*(R + j) + (iq - 1)) = 0.;
#line 684
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 688
  iq --;
#line 688
  *piq = iq;
#line 694
  if (iq == 0) {
#line 695
    return;
  }
#line 697
  j = qq;
  {
#line 697
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 697
    if (! (j < iq)) {
#line 697
      goto while_break___3;
    }
    {
#line 698
    cc = *(*(R + j) + j);
#line 699
    ss = *(*(R + (j + 1)) + j);
#line 700
    h = distance(cc, ss);
#line 701
    __cil_tmp25 = fabs(h);
    }
#line 701
    if (__cil_tmp25 < (double )2.22044604926e-16L) {
#line 702
      goto while_continue___3;
    }
#line 703
    cc /= h;
#line 704
    ss /= h;
#line 705
    *(*(R + (j + 1)) + j) = 0.;
#line 706
    if (cc < 0.) {
#line 707
      *(*(R + j) + j) = - h;
#line 708
      cc = - cc;
#line 709
      ss = - ss;
    } else {
#line 711
      *(*(R + j) + j) = h;
    }
#line 713
    xny = ss / (1. + cc);
#line 714
    k = j + 1;
    {
#line 714
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 714
      if (! (k < iq)) {
#line 714
        goto while_break___4;
      }
#line 715
      t1 = *(*(R + j) + k);
#line 716
      t2 = *(*(R + (j + 1)) + k);
#line 717
      *(*(R + j) + k) = t1 * cc + t2 * ss;
#line 718
      *(*(R + (j + 1)) + k) = xny * (t1 + *(*(R + j) + k)) - t2;
#line 714
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 720
    k = 0;
    {
#line 720
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 720
      if (! (k < n)) {
#line 720
        goto while_break___5;
      }
#line 721
      t1 = *(*(J + k) + j);
#line 722
      t2 = *(*(J + k) + (j + 1));
#line 723
      *(*(J + k) + j) = t1 * cc + t2 * ss;
#line 724
      *(*(J + k) + (j + 1)) = xny * (*(*(J + k) + j) + t1) - t2;
#line 720
      k ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 697
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  return;
}
}
#line 729 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static double distance(double a , double b ) 
{ 
  double a1 ;
  double b1 ;
  double t ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 731
  a1 = fabs(a);
#line 732
  b1 = fabs(b);
  }
#line 733
  if (a1 > b1) {
    {
#line 734
    t = b1 / a1;
#line 735
    __cil_tmp8 = sqrt(1. + t * t);
    }
#line 735
    return (a1 * __cil_tmp8);
  } else
#line 736
  if (b1 > a1) {
    {
#line 737
    t = a1 / b1;
#line 738
    __cil_tmp9 = sqrt(1. + t * t);
    }
#line 738
    return (b1 * __cil_tmp9);
  }
  {
#line 740
  __cil_tmp10 = sqrt(2.);
  }
#line 740
  return (a1 * __cil_tmp10);
}
}
#line 744 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static double scalar_product(double *x , double *y , int n ) 
{ 
  int i ;
  double sum ;
  int __cil_tmp6 ;

  {
#line 748
  sum = 0.;
#line 749
  i = 0;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (i < n)) {
#line 749
      goto while_break;
    }
#line 750
    sum += *(x + i) * *(y + i);
#line 749
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  return (sum);
}
}
#line 756 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void cholesky_decomposition(double **A , int n ) 
{ 
  int i ;
  int j ;
  int k ;
  double sum ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < n)) {
#line 760
      goto while_break;
    }
#line 761
    j = i;
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 761
      if (! (j < n)) {
#line 761
        goto while_break___0;
      }
#line 762
      sum = *(*(A + i) + j);
#line 763
      k = i - 1;
      {
#line 763
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 763
        if (! (k >= 0)) {
#line 763
          goto while_break___1;
        }
#line 764
        sum -= *(*(A + i) + k) * *(*(A + j) + k);
#line 763
        __cil_tmp7 = k;
#line 763
        k --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 768
      if (i == j) {
#line 769
        if (sum <= 0.) {
          {
#line 772
          print_matrix("A\260s\027\313U", A, n, n);
#line 773
          error("QuadProg:cholesky decomposition, matrix is not postive definite, sum: %e\230\001",
                sum);
          }
        }
        {
#line 775
        *(*(A + i) + i) = sqrt(sum);
        }
      } else {
#line 777
        *(*(A + j) + i) = sum / *(*(A + i) + i);
      }
#line 761
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 779
    k = i + 1;
    {
#line 779
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 779
      if (! (k < n)) {
#line 779
        goto while_break___2;
      }
#line 780
      *(*(A + i) + k) = *(*(A + k) + i);
#line 779
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 760
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 784 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void cholesky_solve(double **L , double *x , double *b , int n ) 
{ 
  double *y ;
  double _y[20] ;
  double *__cil_tmp7 ;

  {
#line 787
  if (n <= 20) {
#line 788
    y = (double *)_y;
  } else {
    {
#line 790
    y = dvector(0, n - 1);
    }
  }
  {
#line 793
  forward_elimination(L, y, b, n);
#line 796
  backward_elimination(L, x, y, n);
  }
#line 798
  if (n > 20) {
    {
#line 799
    free_dvector(y, 0, n - 1);
    }
  }
  return;
}
}
#line 802 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void forward_elimination(double **L , double *y , double *b , int n ) 
{ 
  int i ;
  int j ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 805
  *(y + 0) = *(b + 0) / *(*(L + 0) + 0);
#line 806
  i = 1;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! (i < n)) {
#line 806
      goto while_break;
    }
#line 807
    *(y + i) = *(b + i);
#line 808
    j = 0;
    {
#line 808
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 808
      if (! (j < i)) {
#line 808
        goto while_break___0;
      }
#line 809
      *(y + i) -= *(*(L + i) + j) * *(y + j);
#line 808
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 810
    *(y + i) /= *(*(L + i) + i);
#line 806
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 814 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
__inline static void backward_elimination(double **U , double *x , double *y , int n ) 
{ 
  int i ;
  int j ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 817
  *(x + (n - 1)) = *(y + (n - 1)) / *(*(U + (n - 1)) + (n - 1));
#line 818
  i = n - 2;
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (i >= 0)) {
#line 818
      goto while_break;
    }
#line 819
    *(x + i) = *(y + i);
#line 820
    j = i + 1;
    {
#line 820
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 820
      if (! (j < n)) {
#line 820
        goto while_break___0;
      }
#line 821
      *(x + i) -= *(*(U + i) + j) * *(x + j);
#line 820
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 822
    *(x + i) /= *(*(U + i) + i);
#line 818
    __cil_tmp8 = i;
#line 818
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 828 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void print_matrix(char *name , double **A , int n , int m ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 831
  printf("%s: \n", name);
#line 832
  i = 0;
  }
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (! (i < n)) {
#line 832
      goto while_break;
    }
    {
#line 833
    printf(" \361s\027\313U");
#line 834
    j = 0;
    }
    {
#line 834
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 834
      if (! (j < m)) {
#line 834
        goto while_break___0;
      }
#line 835
      if (j < m - 1) {
#line 835
        tmp = ", r\027\313U";
      } else {
#line 835
        tmp = "\220";
      }
      {
#line 835
      printf("%f%s\313U", *(*(A + i) + j), tmp);
      }
#line 834
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 836
    printf("\nyr\027\313U");
    }
#line 832
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 838
  printf("\n");
  }
  return;
}
}
#line 841 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void print_vector(char *name , double *v , int n ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp6 ;

  {
  {
#line 844
  printf("%s: \n", name);
#line 845
  printf(" ");
#line 846
  i = 0;
  }
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (! (i < n)) {
#line 846
      goto while_break;
    }
#line 847
    if (i < n - 1) {
#line 847
      tmp = ", t\027\313U";
    } else {
#line 847
      tmp = "\220";
    }
    {
#line 847
    printf("%f%s", *(v + i), tmp);
    }
#line 846
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 848
  printf("\n\n");
  }
  return;
}
}
#line 851 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/quadprog.c"
static void print_ivector(char *name , int *v , int n ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp6 ;

  {
  {
#line 854
  printf("%s: \nU", name);
#line 855
  printf(" or\027\313U");
#line 856
  i = 0;
  }
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (i < n)) {
#line 856
      goto while_break;
    }
#line 857
    if (i < n - 1) {
#line 857
      tmp = ", ";
    } else {
#line 857
      tmp = "\220";
    }
    {
#line 857
    printf("%d%s\313U", *(v + i), tmp);
    }
#line 856
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 858
  printf("\n\n");
  }
  return;
}
}
#line 80 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/powell.c"
int powell(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
           double (*func)(void * , double [] ) , void *fdata , void (*prog)(void * ,
                                                                            int  ) ,
           void *pdata ) 
{ 
  int i ;
  double **dmtx ;
  double *_dmtx[10] ;
  double __dmtx[100] ;
  unsigned int tmp ;
  double *spt ;
  double _spt[10] ;
  double *xpt ;
  double _xpt[10] ;
  double *svec ;
  double _svec[10] ;
  int iter ;
  double retv ;
  double stopth ;
  double startdel ;
  double curdel ;
  int pc ;
  int j ;
  int __cil_tmp29 ;
  double **__cil_tmp30 ;
  double *__cil_tmp31 ;
  double *__cil_tmp32 ;
  double *__cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  double __cil_tmp36 ;
  int j___0 ;
  double lretv ;
  int ibig ;
  double del ;
  double pretv ;
  int __cil_tmp42 ;
  double __cil_tmp43 ;
  double __cil_tmp44 ;
  double __cil_tmp45 ;
  int __cil_tmp46 ;
  double __cil_tmp47 ;
  double __cil_tmp48 ;
  double __cil_tmp49 ;
  int tt ;
  double __cil_tmp51 ;
  double __cil_tmp52 ;
  double __cil_tmp53 ;
  double __cil_tmp54 ;
  double __cil_tmp55 ;
  int __cil_tmp56 ;
  double __cil_tmp57 ;
  double t ;
  double t1 ;
  double t2 ;
  double __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;

  {
#line 97
  __dmtx[0] = 0.;
#line 97
  tmp = (unsigned int )1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (tmp >= 100) {
#line 97
      goto while_break;
    }
#line 97
    __dmtx[tmp] = 0;
#line 97
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  startdel = - 1.;
#line 106
  pc = 0;
#line 108
  if (di <= 10) {
#line 110
    i = 0;
#line 110
    j = i;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 110
      if (! (i < di)) {
#line 110
        goto while_break___0;
      }
#line 111
      _dmtx[i] = (double *)__dmtx + j;
#line 110
      j += di;
#line 110
      __cil_tmp29 = i;
#line 110
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    dmtx = (double **)_dmtx;
#line 113
    spt = (double *)_spt;
#line 114
    xpt = (double *)_xpt;
#line 115
    svec = (double *)_svec;
  } else {
    {
#line 117
    dmtx = dmatrixz(0, di - 1, 0, di - 1);
#line 118
    spt = dvector(0, di - 1);
#line 119
    xpt = dvector(0, di - 1);
#line 120
    svec = dvector(0, di - 1);
    }
  }
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 125
    if (! (i < di)) {
#line 125
      goto while_break___1;
    }
#line 126
    *(*(dmtx + i) + i) = s[i];
#line 125
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  i = 0;
  {
#line 129
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 129
    if (! (i < di)) {
#line 129
      goto while_break___2;
    }
#line 130
    *(spt + i) = cp[i];
#line 129
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 132
  if (prog != (void *)0) {
    {
#line 133
    (*prog)(pdata, pc);
    }
  }
  {
#line 136
  retv = (*func)(fdata, cp);
#line 140
  iter = 1;
  }
  {
#line 140
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 140
    if (! (iter < maxit)) {
#line 140
      goto while_break___3;
    }
#line 143
    ibig = 0;
#line 144
    del = 0.;
#line 147
    pretv = retv;
#line 150
    i = 0;
    {
#line 150
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 150
      if (! (i < di)) {
#line 150
        goto while_break___4;
      }
#line 154
      j___0 = 0;
      {
#line 154
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 154
        if (! (j___0 < di)) {
#line 154
          goto while_break___5;
        }
#line 155
        *(svec + j___0) = *(*(dmtx + j___0) + i);
#line 154
        j___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 159
      lretv = retv;
#line 160
      retv = linmin(cp, svec, di, ftol, func, fdata);
#line 163
      __cil_tmp44 = fabs(lretv - retv);
      }
#line 163
      if (__cil_tmp44 > del) {
        {
#line 164
        del = fabs(lretv - retv);
#line 165
        ibig = i;
        }
      }
#line 150
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 174
    __cil_tmp48 = fabs(retv);
    }
    {
#line 174
    __cil_tmp47 = fabs(pretv);
#line 174
    stopth = (ftol * 0.5) * ((__cil_tmp47 + __cil_tmp48) + (double )2.22044604926e-16L);
#line 176
    curdel = fabs(pretv - retv);
    }
#line 177
    if (startdel < 0.) {
#line 178
      startdel = curdel;
    } else {
      {
#line 181
      __cil_tmp54 = log(startdel);
      }
      {
#line 181
      __cil_tmp53 = log(stopth);
      }
      {
#line 181
      __cil_tmp52 = log(startdel);
      }
      {
#line 181
      __cil_tmp51 = log(curdel);
#line 181
      __cil_tmp55 = pow((__cil_tmp51 - __cil_tmp52) / (__cil_tmp53 - __cil_tmp54),
                        4.);
#line 181
      tt = (int )(100. * __cil_tmp55 + 0.5);
      }
#line 182
      if (tt > pc) {
#line 182
        if (tt < 100) {
#line 183
          pc = tt;
#line 184
          if (prog != (void *)0) {
            {
#line 185
            (*prog)(pdata, pc);
            }
          }
        }
      }
    }
#line 192
    if (iter > 1) {
#line 192
      if (curdel <= stopth) {
#line 195
        goto while_break___3;
      }
    }
#line 201
    i = 0;
    {
#line 201
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 201
      if (! (i < di)) {
#line 201
        goto while_break___6;
      }
#line 202
      *(svec + i) = cp[i] - *(spt + i);
#line 203
      *(xpt + i) = cp[i] + *(svec + i);
#line 204
      *(spt + i) = cp[i];
#line 201
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 209
    lretv = (*func)(fdata, xpt);
    }
#line 211
    if (lretv < pretv) {
#line 215
      t1 = (pretv - retv) - del;
#line 216
      t2 = pretv - lretv;
#line 217
      t = ((2. * ((pretv - 2. * retv) + lretv)) * t1) * t1 - (del * t2) * t2;
#line 218
      if (t < 0.) {
        {
#line 221
        retv = linmin(cp, svec, di, ftol, func, fdata);
#line 223
        i = 0;
        }
        {
#line 223
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 223
          if (! (i < di)) {
#line 223
            goto while_break___7;
          }
#line 224
          *(*(dmtx + i) + ibig) = *(svec + i);
#line 223
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 140
    iter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 233
  if (di > 10) {
    {
#line 234
    free_dvector(svec, 0, di - 1);
#line 235
    free_dvector(xpt, 0, di - 1);
#line 236
    free_dvector(spt, 0, di - 1);
#line 237
    free_dmatrix(dmtx, 0, di - 1, 0, di - 1);
    }
  }
#line 240
  if (prog != (void *)0) {
    {
#line 241
    (*prog)(pdata, 100);
    }
  }
#line 243
  if (rv != (void *)0) {
#line 244
    *rv = retv;
  }
#line 246
  if (iter < maxit) {
#line 247
    return (0);
  }
#line 250
  return (1);
}
}
#line 261 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/powell.c"
double linmin(double cp[] , double xi[] , int di , double ftol , double (*func)(void * ,
                                                                                double [] ) ,
              void *fdata ) 
{ 
  int i ;
  double ax ;
  double xx ;
  double bx ;
  double af ;
  double xf ;
  double bf ;
  double *xt ;
  double _xt[10] ;
  double *__cil_tmp16 ;
  int __cil_tmp17 ;
  double __cil_tmp18 ;
  int __cil_tmp19 ;
  double __cil_tmp20 ;
  double tt ;
  int __cil_tmp22 ;
  double __cil_tmp23 ;
  double ulim ;
  double ux ;
  double uf ;
  double tt___0 ;
  double r ;
  double q ;
  int __cil_tmp30 ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  double __cil_tmp33 ;
  int __cil_tmp34 ;
  double __cil_tmp35 ;
  double wx ;
  double vx ;
  double ux___0 ;
  double wf ;
  double vf ;
  double uf___0 ;
  int iter ;
  double de ;
  double e ;
  double tt___1 ;
  double mx ;
  double tol1 ;
  double __cil_tmp48 ;
  double tol2 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;
  double te ;
  double p ;
  double q___0 ;
  double r___0 ;
  double __cil_tmp56 ;
  double __cil_tmp57 ;
  double tmp ;
  double tmp___0 ;
  double __cil_tmp60 ;
  int __cil_tmp61 ;
  double __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
#line 278
  if (di <= 10) {
#line 279
    xt = (double *)_xt;
  } else {
    {
#line 281
    xt = dvector(0, di - 1);
    }
  }
#line 291
  ax = 0.;
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < di)) {
#line 292
      goto while_break;
    }
#line 293
    *(xt + i) = cp[i] + ax * xi[i];
#line 292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  af = (*func)(fdata, xt);
#line 297
  xx = 1. / 1.618034;
#line 298
  i = 0;
  }
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    if (! (i < di)) {
#line 298
      goto while_break___0;
    }
#line 299
    *(xt + i) = cp[i] + xx * xi[i];
#line 298
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 300
  xf = (*func)(fdata, xt);
  }
#line 305
  if (xf > af) {
#line 307
    tt = ax;
#line 307
    ax = xx;
#line 307
    xx = tt;
#line 308
    tt = af;
#line 308
    af = xf;
#line 308
    xf = tt;
  }
#line 312
  bx = xx + 1.618034 * (xx - ax);
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 313
    if (! (i < di)) {
#line 313
      goto while_break___1;
    }
#line 314
    *(xt + i) = cp[i] + bx * xi[i];
#line 313
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 315
  bf = (*func)(fdata, xt);
  }
  {
#line 337
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 337
    if (! (xf > bf)) {
#line 337
      goto while_break___2;
    }
#line 345
    q = (xx - bx) * (xf - af);
#line 346
    r = (xx - ax) * (xf - bf);
#line 347
    tt___0 = q - r;
#line 348
    if (tt___0 >= 0.) {
#line 348
      if (tt___0 < 1e-20) {
#line 349
        tt___0 = 1e-20;
      } else {
#line 348
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 350
    if (tt___0 <= 0.) {
#line 350
      if (tt___0 > - 1e-20) {
#line 351
        tt___0 = - 1e-20;
      }
    }
#line 352
    ux = xx - ((xx - bx) * q - (xx - ax) * r) / (2. * tt___0);
#line 353
    ulim = xx + 100. * (bx - xx);
#line 356
    if ((xx - ux) * (ux - bx) > 0.) {
#line 358
      i = 0;
      {
#line 358
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 358
        if (! (i < di)) {
#line 358
          goto while_break___3;
        }
#line 359
        *(xt + i) = cp[i] + ux * xi[i];
#line 358
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 360
      uf = (*func)(fdata, xt);
      }
#line 364
      if (uf < bf) {
#line 366
        ax = xx;
#line 366
        af = xf;
#line 367
        xx = ux;
#line 367
        xf = uf;
#line 368
        goto while_break___2;
      } else
#line 369
      if (uf > xf) {
#line 371
        bx = ux;
#line 371
        bf = uf;
#line 372
        goto while_break___2;
      }
#line 376
      ux = bx + 1.618034 * (bx - xx);
    } else
#line 379
    if ((bx - ux) * (ux - ulim) > 0.) {
#line 380
      i = 0;
      {
#line 380
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 380
        if (! (i < di)) {
#line 380
          goto while_break___4;
        }
#line 381
        *(xt + i) = cp[i] + ux * xi[i];
#line 380
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 382
      uf = (*func)(fdata, xt);
      }
#line 385
      if (uf > bf) {
#line 387
        ax = xx;
#line 387
        af = xf;
#line 388
        xx = bx;
#line 388
        xf = bf;
#line 389
        bx = ux;
#line 389
        bf = uf;
#line 390
        goto while_break___2;
      }
#line 392
      xx = bx;
#line 392
      xf = bf;
#line 393
      bx = ux;
#line 393
      bf = uf;
#line 394
      ux = bx + 1.618034 * (bx - xx);
    } else
#line 397
    if ((ux - ulim) * (ulim - bx) >= 0.) {
#line 398
      ux = ulim;
    } else {
#line 401
      ux = bx + 1.618034 * (bx - xx);
    }
#line 405
    i = 0;
    {
#line 405
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 405
      if (! (i < di)) {
#line 405
        goto while_break___5;
      }
#line 406
      *(xt + i) = cp[i] + ux * xi[i];
#line 405
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 407
    uf = (*func)(fdata, xt);
#line 409
    ax = xx;
#line 409
    af = xf;
#line 410
    xx = bx;
#line 410
    xf = bf;
#line 411
    bx = ux;
#line 411
    bf = uf;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 427
  vf = 0.;
#line 429
  de = 0.;
#line 430
  e = 0.;
#line 433
  if (ax > bx) {
#line 435
    tt___1 = ax;
#line 435
    ax = bx;
#line 435
    bx = tt___1;
#line 436
    tt___1 = af;
#line 436
    af = bf;
#line 436
    bf = tt___1;
  }
#line 439
  vx = xx;
#line 439
  wx = vx;
#line 440
  xf = xf;
#line 440
  wf = xf;
#line 442
  iter = 1;
  {
#line 442
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 442
    if (! (iter <= 100)) {
#line 442
      goto while_break___6;
    }
    {
#line 443
    mx = 0.5 * (ax + bx);
#line 447
    __cil_tmp48 = fabs(xx);
#line 447
    tol1 = ftol * __cil_tmp48 + 1.00000000001e-10;
#line 449
    tol2 = 2. * tol1;
#line 455
    __cil_tmp50 = fabs(xx - mx);
    }
#line 455
    if (__cil_tmp50 <= tol2 - 0.5 * (bx - ax)) {
#line 457
      goto while_break___6;
    }
    {
#line 462
    __cil_tmp51 = fabs(e);
    }
#line 462
    if (__cil_tmp51 > tol1) {
#line 464
      r___0 = (xx - wx) * (xf - vf);
#line 465
      q___0 = (xx - vx) * (xf - wf);
#line 466
      p = (xx - vx) * q___0 - (xx - wx) * r___0;
#line 467
      q___0 = 2. * (q___0 - r___0);
#line 468
      if (q___0 > 0.) {
#line 469
        p = - p;
      } else {
#line 471
        q___0 = - q___0;
      }
      {
#line 472
      te = e;
#line 473
      e = de;
#line 477
      __cil_tmp57 = fabs((0.5 * q___0) * te);
      }
      {
#line 477
      __cil_tmp56 = fabs(p);
      }
#line 477
      if (__cil_tmp56 >= __cil_tmp57) {
        _L___13: /* CIL Label */ 
        _L___14: /* CIL Label */ 
#line 479
        if (xx >= mx) {
#line 479
          tmp = ax - xx;
        } else {
#line 479
          tmp = bx - xx;
        }
#line 479
        e = tmp;
#line 480
        de = 0.381966000001 * e;
      } else
#line 477
      if (p <= q___0 * (ax - xx)) {
#line 477
        goto _L___13;
      } else
#line 477
      if (p >= q___0 * (bx - xx)) {
#line 477
        goto _L___13;
      } else {
#line 483
        de = p / q___0;
#line 484
        ux___0 = xx + de;
#line 485
        if (ux___0 - ax < tol2) {
          _L___12: /* CIL Label */ 
#line 486
          if (mx - xx > 0.) {
#line 487
            de = tol1;
          } else {
#line 489
            de = - tol1;
          }
        } else
#line 485
        if (bx - ux___0 < tol2) {
#line 485
          goto _L___12;
        }
      }
    } else {
#line 494
      if (xx >= mx) {
#line 494
        tmp___0 = ax - xx;
      } else {
#line 494
        tmp___0 = bx - xx;
      }
#line 494
      e = tmp___0;
#line 495
      de = 0.381966000001 * e;
    }
    {
#line 499
    __cil_tmp60 = fabs(de);
    }
#line 499
    if (__cil_tmp60 >= tol1) {
#line 500
      ux___0 = xx + de;
    } else
#line 503
    if (de > 0.) {
#line 504
      ux___0 = xx + tol1;
    } else {
#line 507
      ux___0 = xx - tol1;
    }
#line 513
    i = 0;
    {
#line 513
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 513
      if (! (i < di)) {
#line 513
        goto while_break___7;
      }
#line 514
      *(xt + i) = cp[i] + ux___0 * xi[i];
#line 513
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 515
    uf___0 = (*func)(fdata, xt);
    }
#line 517
    if (uf___0 <= xf) {
#line 519
      if (ux___0 >= xx) {
#line 520
        ax = xx;
#line 520
        af = xf;
      } else {
#line 522
        bx = xx;
#line 522
        bf = xf;
      }
#line 524
      vx = wx;
#line 524
      vf = wf;
#line 525
      wx = xx;
#line 525
      wf = xf;
#line 526
      xx = ux___0;
#line 526
      xf = uf___0;
    } else {
#line 530
      if (ux___0 < xx) {
#line 531
        ax = ux___0;
#line 531
        af = uf___0;
      } else {
#line 533
        bx = ux___0;
#line 533
        bf = uf___0;
      }
#line 535
      if (uf___0 <= wf) {
#line 536
        vx = wx;
#line 536
        vf = wf;
#line 537
        wx = ux___0;
#line 537
        wf = uf___0;
      } else
#line 535
      if (wx == xx) {
#line 536
        vx = wx;
#line 536
        vf = wf;
#line 537
        wx = ux___0;
#line 537
        wf = uf___0;
      } else
#line 538
      if (uf___0 <= vf) {
#line 539
        vx = ux___0;
#line 539
        vf = uf___0;
      } else
#line 538
      if (vx == xx) {
#line 539
        vx = ux___0;
#line 539
        vf = uf___0;
      } else
#line 538
      if (vx == wx) {
#line 539
        vx = ux___0;
#line 539
        vf = uf___0;
      }
    }
#line 442
    iter ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  done: ;
#line 551
  i = 0;
  {
#line 551
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 551
    if (! (i < di)) {
#line 551
      goto while_break___8;
    }
#line 552
    cp[i] += xx * xi[i];
#line 551
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 554
  if (xt != (double *)_xt) {
    {
#line 555
    free_dvector(xt, 0, di - 1);
    }
  }
#line 557
  return (xf);
}
}
#line 570 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/powell.c"
int conjgrad(double *rv , int di , double cp[] , double s[] , double ftol , int maxit ,
             double (*func)(void * , double [] ) , double (*dfunc)(void * , double [] ,
                                                                   double [] ) , void *fdata ,
             void (*prog)(void * , int  ) , void *pdata ) 
{ 
  int i ;
  int iter ;
  double *svec ;
  double _svec[10] ;
  double *ssvec ;
  double _ssvec[10] ;
  double *gvec ;
  double _gvec[10] ;
  double *hvec ;
  double _hvec[10] ;
  double retv ;
  double stopth ;
  double startdel ;
  double curdel ;
  double brat ;
  double svec_sca ;
  int pc ;
  double *__cil_tmp29 ;
  double *__cil_tmp30 ;
  double *__cil_tmp31 ;
  double *__cil_tmp32 ;
  double __cil_tmp33 ;
  double __cil_tmp34 ;
  double rat ;
  double __cil_tmp36 ;
  double __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  double gamden ;
  double gamnum ;
  double gam ;
  double pretv ;
  double __cil_tmp44 ;
  double __cil_tmp45 ;
  double __cil_tmp46 ;
  double __cil_tmp47 ;
  int tt ;
  double __cil_tmp49 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;
  double __cil_tmp52 ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  double __cil_tmp55 ;
  int __cil_tmp56 ;
  double rat___0 ;
  double __cil_tmp58 ;
  double __cil_tmp59 ;
  int __cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;

  {
#line 595
  startdel = - 1.;
#line 599
  pc = 0;
#line 601
  if (di <= 10) {
#line 602
    svec = (double *)_svec;
#line 603
    ssvec = (double *)_ssvec;
#line 604
    gvec = (double *)_gvec;
#line 605
    hvec = (double *)_hvec;
  } else {
    {
#line 607
    svec = dvector(0, di - 1);
#line 608
    ssvec = dvector(0, di - 1);
#line 609
    gvec = dvector(0, di - 1);
#line 610
    hvec = dvector(0, di - 1);
    }
  }
#line 617
  if (prog != (void *)0) {
    {
#line 618
    (*prog)(pdata, pc);
    }
  }
  {
#line 622
  retv = (*dfunc)(fdata, svec, cp);
  }
#line 626
  if (retv == 1.00000000001e+100) {
    {
#line 628
    retv = (*func)(fdata, cp);
    }
  }
#line 635
  i = 0;
#line 635
  brat = 0.;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (i < di)) {
#line 635
      goto while_break;
    }
    {
#line 636
    __cil_tmp37 = fabs(s[i]);
    }
    {
#line 636
    __cil_tmp36 = fabs(*(svec + i));
#line 636
    rat = __cil_tmp36 / __cil_tmp37;
    }
#line 637
    if (rat > brat) {
#line 638
      brat = rat;
    }
#line 635
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  svec_sca = 1.;
#line 642
  if (brat > (double )2.22044604926e-16L) {
#line 643
    svec_sca /= brat;
  }
#line 648
  i = 0;
  {
#line 648
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 648
    if (! (i < di)) {
#line 648
      goto while_break___0;
    }
#line 649
    *(gvec + i) = - *(svec + i);
#line 650
    *(hvec + i) = *(gvec + i);
#line 650
    *(svec + i) = *(hvec + i);
#line 651
    *(ssvec + i) = *(svec + i) * svec_sca;
#line 648
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 658
  iter = 1;
  {
#line 658
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 658
    if (! (iter < maxit)) {
#line 658
      goto while_break___1;
    }
    {
#line 663
    pretv = retv;
#line 667
    retv = linmin(cp, ssvec, di, ftol, func, fdata);
#line 673
    __cil_tmp46 = fabs(retv);
    }
    {
#line 673
    __cil_tmp45 = fabs(pretv);
#line 673
    stopth = (ftol * 0.5) * ((__cil_tmp45 + __cil_tmp46) + (double )2.22044604926e-16L);
#line 675
    curdel = fabs(pretv - retv);
    }
#line 677
    if (startdel < 0.) {
#line 678
      startdel = curdel;
    } else
#line 679
    if (prog != (void *)0) {
      {
#line 681
      __cil_tmp52 = log(startdel);
      }
      {
#line 681
      __cil_tmp51 = log(stopth);
      }
      {
#line 681
      __cil_tmp50 = log(startdel);
      }
      {
#line 681
      __cil_tmp49 = log(curdel);
#line 681
      __cil_tmp53 = pow((__cil_tmp49 - __cil_tmp50) / (__cil_tmp51 - __cil_tmp52),
                        4.);
#line 681
      tt = (int )(100. * __cil_tmp53 + 0.5);
      }
#line 682
      if (tt > pc) {
#line 682
        if (tt < 100) {
          {
#line 683
          pc = tt;
#line 684
          (*prog)(pdata, pc);
          }
        }
      }
    }
#line 690
    if (iter > 1) {
#line 690
      if (curdel <= stopth) {

#line 692
        goto while_break___1;
      }
    }
    {
#line 697
    (*dfunc)(fdata, svec, cp);
#line 701
    i = 0;
    }
#line 701
    gamden = 0.;
#line 701
    gamnum = gamden;
    {
#line 701
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 701
      if (! (i < di)) {
#line 701
        goto while_break___2;
      }
#line 702
      gamden += *(gvec + i) * *(gvec + i);
#line 704
      gamnum += *(svec + i) * (*(gvec + i) + *(svec + i));
#line 701
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 708
    __cil_tmp55 = fabs(gamden);
    }
#line 708
    if (__cil_tmp55 < (double )2.22044604926e-16L) {
#line 710
      goto while_break___1;
    }
#line 713
    gam = gamnum / gamden;
#line 718
    i = 0;
    {
#line 718
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 718
      if (! (i < di)) {
#line 718
        goto while_break___3;
      }
#line 719
      *(gvec + i) = - *(svec + i);
#line 720
      *(hvec + i) = *(gvec + i) + gam * *(hvec + i);
#line 720
      *(svec + i) = *(hvec + i);
#line 718
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 725
    i = 0;
#line 725
    brat = 0.;
    {
#line 725
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 725
      if (! (i < di)) {
#line 725
        goto while_break___4;
      }
      {
#line 726
      __cil_tmp59 = fabs(s[i]);
      }
      {
#line 726
      __cil_tmp58 = fabs(*(svec + i));
#line 726
      rat___0 = __cil_tmp58 / __cil_tmp59;
      }
#line 727
      if (rat___0 > brat) {
#line 728
        brat = rat___0;
      }
#line 725
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 730
    svec_sca = 1. / brat;
#line 731
    i = 0;
    {
#line 731
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 731
      if (! (i < di)) {
#line 731
        goto while_break___5;
      }
#line 732
      *(ssvec + i) = *(svec + i) * svec_sca;
#line 731
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }

#line 658
    iter ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 737
  if (di > 10) {
    {
#line 738
    free_dvector(hvec, 0, di - 1);
#line 739
    free_dvector(gvec, 0, di - 1);
#line 740
    free_dvector(ssvec, 0, di - 1);
#line 741
    free_dvector(svec, 0, di - 1);
    }
  }
#line 744
  if (prog != (void *)0) {
    {
#line 745
    (*prog)(pdata, 100);
    }
  }
#line 747
  if (rv != (void *)0) {
#line 748
    *rv = retv;
  }

#line 752
  if (iter < maxit) {
#line 753
    return (0);
  }
#line 755
  return (1);
}
}
#line 766 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/powell.c"
double linmind(double cp[] , double xi[] , int di , double ftol , double (*func)(void * ,
                                                                                 double [] ) ,
               double (*dfunc)(void * , double [] , double [] ) , void *fdata ) 
{ 
  int i ;
  double ax ;
  double xx ;
  double bx ;
  double af ;
  double xf ;
  double bf ;
  double *xt ;
  double _xt[10] ;
  double *df ;
  double _df[10] ;
  double *__cil_tmp19 ;
  double *__cil_tmp20 ;
  int __cil_tmp21 ;
  double __cil_tmp22 ;
  int __cil_tmp23 ;
  double __cil_tmp24 ;
  double tt ;
  int __cil_tmp26 ;
  double __cil_tmp27 ;
  double ulim ;
  double ux ;
  double uf ;
  double tt___0 ;
  double r ;
  double q ;
  int __cil_tmp34 ;
  double __cil_tmp35 ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int __cil_tmp38 ;
  double __cil_tmp39 ;
  double wx ;
  double vx ;
  double ux___0 ;
  double wf ;
  double vf ;
  double uf___0 ;
  double xd ;
  double wd ;
  double vd ;
  double ud ;
  int iter ;
  double de ;
  double e ;
  double tt___1 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  double mx ;
  double tol1 ;
  double __cil_tmp58 ;
  double tol2 ;
  double __cil_tmp60 ;
  double __cil_tmp61 ;
  double te ;
  double dx1 ;
  double dx2 ;
  double ux1 ;
  double ux2 ;
  int ch1 ;
  int ch2 ;
  double __cil_tmp69 ;
  double __cil_tmp70 ;
  double tmp ;
  double __cil_tmp72 ;
  double __cil_tmp73 ;
  double __cil_tmp74 ;
  double __cil_tmp75 ;
  double tmp___0 ;
  double __cil_tmp77 ;
  int __cil_tmp78 ;
  double __cil_tmp79 ;
  int __cil_tmp80 ;
  double __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;

  {
#line 786
  if (di <= 10) {
#line 787
    xt = (double *)_xt;
#line 788
    df = (double *)_df;
  } else {
    {
#line 790
    xt = dvector(0, di - 1);
#line 791
    df = dvector(0, di - 1);
    }
  }
#line 802
  ax = 0.;
#line 803
  i = 0;
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! (i < di)) {
#line 803
      goto while_break;
    }
#line 804
    *(xt + i) = cp[i] + ax * xi[i];
#line 803
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 805
  af = (*func)(fdata, xt);
#line 808
  xx = 1. / 1.618034;
#line 809
  i = 0;
  }
  {
#line 809
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 809
    if (! (i < di)) {
#line 809
      goto while_break___0;
    }
#line 810
    *(xt + i) = cp[i] + xx * xi[i];
#line 809
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 811
  xf = (*func)(fdata, xt);
  }
#line 816
  if (xf > af) {
#line 818
    tt = ax;
#line 818
    ax = xx;
#line 818
    xx = tt;
#line 819
    tt = af;
#line 819
    af = xf;
#line 819
    xf = tt;
  }
#line 823
  bx = xx + 1.618034 * (xx - ax);
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 824
    if (! (i < di)) {
#line 824
      goto while_break___1;
    }
#line 825
    *(xt + i) = cp[i] + bx * xi[i];
#line 824
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 826
  bf = (*func)(fdata, xt);
  }
  {
#line 850
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 850
    if (! (xf > bf)) {
#line 850
      goto while_break___2;
    }
#line 858
    q = (xx - bx) * (xf - af);
#line 859
    r = (xx - ax) * (xf - bf);
#line 860
    tt___0 = q - r;
#line 861
    if (tt___0 >= 0.) {
#line 861
      if (tt___0 < 1e-20) {
#line 862
        tt___0 = 1e-20;
      } else {
#line 861
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 863
    if (tt___0 <= 0.) {
#line 863
      if (tt___0 > - 1e-20) {
#line 864
        tt___0 = - 1e-20;
      }
    }
#line 865
    ux = xx - ((xx - bx) * q - (xx - ax) * r) / (2. * tt___0);
#line 866
    ulim = xx + 100. * (bx - xx);
#line 869
    if ((xx - ux) * (ux - bx) > 0.) {
#line 871
      i = 0;
      {
#line 871
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 871
        if (! (i < di)) {
#line 871
          goto while_break___3;
        }
#line 872
        *(xt + i) = cp[i] + ux * xi[i];
#line 871
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 873
      uf = (*func)(fdata, xt);
      }
#line 877
      if (uf < bf) {
#line 879
        ax = xx;
#line 879
        af = xf;
#line 880
        xx = ux;
#line 880
        xf = uf;
#line 881
        goto while_break___2;
      } else
#line 882
      if (uf > xf) {
#line 884
        bx = ux;
#line 884
        bf = uf;
#line 885
        goto while_break___2;
      }
#line 889
      ux = bx + 1.618034 * (bx - xx);
    } else
#line 892
    if ((bx - ux) * (ux - ulim) > 0.) {
#line 893
      i = 0;
      {
#line 893
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 893
        if (! (i < di)) {
#line 893
          goto while_break___4;
        }
#line 894
        *(xt + i) = cp[i] + ux * xi[i];
#line 893
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 895
      uf = (*func)(fdata, xt);
      }
#line 898
      if (uf > bf) {
#line 900
        ax = xx;
#line 900
        af = xf;
#line 901
        xx = bx;
#line 901
        xf = bf;
#line 902
        bx = ux;
#line 902
        bf = uf;
#line 903
        goto while_break___2;
      }
#line 905
      xx = bx;
#line 905
      xf = bf;
#line 906
      bx = ux;
#line 906
      bf = uf;
#line 907
      ux = bx + 1.618034 * (bx - xx);
    } else
#line 910
    if ((ux - ulim) * (ulim - bx) >= 0.) {
#line 911
      ux = ulim;
    } else {
#line 914
      ux = bx + 1.618034 * (bx - xx);
    }
#line 918
    i = 0;
    {
#line 918
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 918
      if (! (i < di)) {
#line 918
        goto while_break___5;
      }
#line 919
      *(xt + i) = cp[i] + ux * xi[i];
#line 918
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 920
    uf = (*func)(fdata, xt);
#line 922
    ax = xx;
#line 922
    af = xf;
#line 923
    xx = bx;
#line 923
    xf = bf;
#line 924
    bx = ux;
#line 924
    bf = uf;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 941
  vf = 0.;
#line 944
  de = 0.;
#line 945
  e = 0.;
#line 948
  if (ax > bx) {
#line 950
    tt___1 = ax;
#line 950
    ax = bx;
#line 950
    bx = tt___1;
#line 951
    tt___1 = af;
#line 951
    af = bf;
#line 951
    bf = tt___1;
  }
#line 954
  vx = xx;
#line 954
  wx = vx;
#line 955
  xf = xf;
#line 955
  wf = xf;
#line 958
  i = 0;
  {
#line 958
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 958
    if (! (i < di)) {
#line 958
      goto while_break___6;
    }
#line 959
    *(xt + i) = cp[i] + xx * xi[i];
#line 958
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 960
  (*dfunc)(fdata, df, xt);
#line 961
  i = 0;
  }
#line 961
  xd = 0.;
  {
#line 961
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 961
    if (! (i < di)) {
#line 961
      goto while_break___7;
    }
#line 962
    xd += xi[i] * *(df + i);
#line 961
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 963
  ud = xd;
#line 963
  wd = ud;
#line 967
  iter = 1;
  {
#line 967
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 967
    if (! (iter <= 100)) {
#line 967
      goto while_break___8;
    }
    {
#line 968
    mx = 0.5 * (ax + bx);
#line 972
    __cil_tmp58 = fabs(xx);
#line 972
    tol1 = ftol * __cil_tmp58 + 1.00000000001e-10;
#line 974
    tol2 = 2. * tol1;
#line 979
    __cil_tmp60 = fabs(xx - mx);
    }
#line 979
    if (__cil_tmp60 <= tol2 - 0.5 * (bx - ax)) {
#line 981
      goto while_break___8;
    }
    {
#line 986
    __cil_tmp61 = fabs(e);
    }
#line 986
    if (__cil_tmp61 > tol1) {
#line 994
      dx1 = 2. * (bx - ax);
#line 994
      dx2 = dx1;
#line 997
      if (wd != xd) {
#line 998
        dx1 = ((wx - xx) * xd) / (xd - wd);
      }
#line 999
      if (vd != xd) {
#line 1000
        dx2 = ((vx - xx) * xd) / (xd - vd);
      }
#line 1002
      ux1 = xx + dx1;
#line 1003
      ux2 = xx + dx2;
#line 1006
      ch1 = (ax - ux1) * (ux1 - bx) > 0. && xd * dx1 < 0.;
#line 1007
      ch2 = (ax - ux2) * (ux2 - bx) > 0. && xd * dx2 < 0.;
#line 1011
      te = e;
#line 1012
      e = de;
#line 1014
      if (! ch1) {
#line 1014
        if (! ch2) {
#line 1015
          goto bisect;
        }
      }
#line 1018
      if (ch1) {
#line 1018
        if (ch2) {
          {
#line 1019
          __cil_tmp70 = fabs(dx2);
          }
          {
#line 1019
          __cil_tmp69 = fabs(dx1);
          }
#line 1019
          if (__cil_tmp69 < __cil_tmp70) {
#line 1019
            tmp = dx1;
          } else {
#line 1019
            tmp = dx2;
          }
#line 1019
          de = tmp;
        }
      }
#line 1020
      if (ch1) {
#line 1021
        de = dx1;
      } else
#line 1022
      if (ch2) {
#line 1023
        de = dx2;
      }
      {
#line 1027
      __cil_tmp73 = fabs(0.5 * te);
      }
      {
#line 1027
      __cil_tmp72 = fabs(de);
      }
#line 1027
      if (__cil_tmp72 > __cil_tmp73) {
#line 1029
        goto bisect;
      }
#line 1032
      ux___0 = xx + de;
#line 1034
      if (ux___0 - ax < tol2) {
        _L___15: /* CIL Label */ 
#line 1035
        if (mx - xx < 0.) {
          {
#line 1036
          __cil_tmp74 = fabs(tol1);
#line 1036
          de = - __cil_tmp74;
          }
        } else {
          {
#line 1038
          de = fabs(tol1);
          }
        }
      } else
#line 1034
      if (bx - ux___0 < tol2) {
#line 1034
        goto _L___15;
      }
    } else {
      bisect: 
#line 1050
      if (xd >= 0.) {
#line 1050
        tmp___0 = ax - xx;
      } else {
#line 1050
        tmp___0 = bx - xx;
      }
#line 1050
      e = tmp___0;
#line 1051
      de = 0.5 * e;
    }
    {
#line 1055
    __cil_tmp77 = fabs(de);
    }
#line 1055
    if (__cil_tmp77 >= tol1) {
#line 1056
      ux___0 = xx + de;
#line 1059
      i = 0;
      {
#line 1059
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1059
        if (! (i < di)) {
#line 1059
          goto while_break___9;
        }
#line 1060
        *(xt + i) = cp[i] + ux___0 * xi[i];
#line 1059
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1061
      uf___0 = (*func)(fdata, xt);
      }
    } else {
#line 1066
      if (de > 0.) {
#line 1067
        ux___0 = xx + tol1;
      } else {
#line 1070
        ux___0 = xx - tol1;
      }
#line 1074
      i = 0;
      {
#line 1074
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1074
        if (! (i < di)) {
#line 1074
          goto while_break___10;
        }
#line 1075
        *(xt + i) = cp[i] + ux___0 * xi[i];
#line 1074
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1076
      uf___0 = (*func)(fdata, xt);
      }
#line 1080
      if (uf___0 > xf) {
#line 1081
        goto done;
      }
    }
    {
#line 1086
    (*dfunc)(fdata, df, xt);
#line 1087
    i = 0;
    }
#line 1087
    ud = 0.;
    {
#line 1087
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1087
      if (! (i < di)) {
#line 1087
        goto while_break___11;
      }
#line 1088
      ud += xi[i] * *(df + i);
#line 1087
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1093
    if (uf___0 <= xf) {
#line 1095
      if (ux___0 >= xx) {
#line 1096
        ax = xx;
#line 1096
        af = xf;
      } else {
#line 1098
        bx = xx;
#line 1098
        bf = xf;
      }
#line 1100
      vx = wx;
#line 1100
      vf = wf;
#line 1100
      vd = wd;
#line 1101
      wx = xx;
#line 1101
      wf = xf;
#line 1101
      wd = xd;
#line 1102
      xx = ux___0;
#line 1102
      xf = uf___0;
#line 1102
      xd = ud;
    } else {
#line 1107
      if (ux___0 < xx) {
#line 1108
        ax = ux___0;
#line 1108
        af = uf___0;
      } else {
#line 1110
        bx = ux___0;
#line 1110
        bf = uf___0;
      }
#line 1112
      if (uf___0 <= wf) {
        _L___16: /* CIL Label */ 
#line 1113
        vx = wx;
#line 1113
        vf = wf;
#line 1113
        vd = wd;
#line 1114
        wx = ux___0;
#line 1114
        wf = uf___0;
#line 1114
        wd = ud;
      } else
#line 1112
      if (wx == xx) {
#line 1112
        goto _L___16;
      } else
#line 1115
      if (uf___0 <= vf) {
#line 1116
        vx = ux___0;
#line 1116
        vf = uf___0;
#line 1116
        vd = ud;
      } else
#line 1115
      if (vx == xx) {
#line 1116
        vx = ux___0;
#line 1116
        vf = uf___0;
#line 1116
        vd = ud;
      } else
#line 1115
      if (vx == wx) {
#line 1116
        vx = ux___0;
#line 1116
        vf = uf___0;
#line 1116
        vd = ud;
      }
    }
#line 967
    iter ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  done: ;
#line 1125
  if (di > 10) {
    {
#line 1126
    free_dvector(df, 0, di - 1);
#line 1127
    free_dvector(xt, 0, di - 1);
    }
  }
#line 1131
  i = 0;
  {
#line 1131
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1131
    if (! (i < di)) {
#line 1131
      goto while_break___12;
    }
#line 1132
    cp[i] += xx * xi[i];
#line 1131
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1136
  return (xf);
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 54 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *exe_path  =    "";
#line 57 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static int g_log_init  =    0;
#line 58 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static int g_deb_init  =    0;
#line 59
a1log default_log ;
#line 64 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int ret_null_on_malloc_fail  =    0;
#line 72 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void set_exe_path(char *argv0 ) 
{ 
  int i ;
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;
  char *p ;
  char *cp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int found ;
  char *__cil_tmp10 ;
  char b1[4096] ;
  char b2[4096] ;
  int ll ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  unsigned long __cil_tmp21 ;
  char *tpath ;
  unsigned long __cil_tmp23 ;
  void *__cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;

  {
  {
#line 75
  g_log->tag = argv0;
#line 76
  __cil_tmp3 = strlen((char const   *)argv0);
#line 76
  i = (int )__cil_tmp3;
#line 77
  exe_path = (char *)malloc((unsigned long )(i + 5));
  }
#line 77
  if (exe_path == (void *)0) {
    {
#line 78
    a1loge(g_log, 1, "set_exe_path: malloc %d bytes failed\n", i + 5);
    }
#line 79
    return;
  }
  {
#line 81
  strcpy(exe_path, (char const   *)argv0);
  }
#line 132
  if ((int )*exe_path != 47) {
    {
#line 134
    __cil_tmp7 = strchr((char const   *)exe_path, '/');
    }
#line 134
    if (__cil_tmp7 != (char *)0) {
#line 135
      cp = ".:";
    } else {
      {
#line 137
      cp = getenv("PATH");
      }
    }
#line 139
    if (cp != (void *)0) {
#line 140
      found = 0;
      {
#line 141
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 141
        p = strchr((char const   *)cp, ':');
        }
#line 141
        if (! (p != (void *)0 || (int )*cp != 0)) {
#line 141
          goto while_break;
        }
#line 145
        if (p == (void *)0) {
          {
#line 146
          __cil_tmp14 = strlen((char const   *)cp);
#line 146
          ll = (int )__cil_tmp14;
          }
        } else {
#line 148
          ll = (int )(p - cp);
        }
        {
#line 149
        __cil_tmp15 = strlen((char const   *)exe_path);
        }
#line 149
        if (((unsigned long )(ll + 1) + __cil_tmp15) + 1UL > 4096UL) {
          {
#line 150
          a1loge(g_log, 1, "set_exe_path: Search path exceeds PATH_MAX\n");
#line 151
          *(exe_path + 0) = (char )'\000';
          }
#line 152
          return;
        }
        {
#line 154
        strncpy((char *)b1, (char const   *)cp, (unsigned long )ll);
#line 155
        b1[ll] = (char )'\000';
#line 156
        strcat((char *)b1, "/");
#line 157
        strcat((char *)b1, (char const   *)exe_path);
#line 158
        __cil_tmp16 = realpath((char const   *)((char *)b1), (char *)b2);
        }
#line 158
        if (__cil_tmp16) {
          {
#line 159
          __cil_tmp17 = access((char const   *)((char *)b2), 0);
          }
#line 159
          if (__cil_tmp17 == 0) {
            {
#line 160
            found = 1;
#line 161
            free(exe_path);
#line 162
            __cil_tmp18 = strlen((char const   *)((char *)b2));
#line 162
            __cil_tmp19 = malloc(__cil_tmp18 + 1UL);
#line 162
            exe_path = __cil_tmp19;
            }
#line 162
            if (exe_path == (void *)0) {
              {
#line 163
              __cil_tmp20 = strlen((char const   *)((char *)b2));
#line 163
              a1loge(g_log, 1, "set_exe_path: malloc %d bytes failed\n", __cil_tmp20 + 1UL);
#line 164
              *(exe_path + 0) = (char )'\000';
              }
#line 165
              return;
            }
            {
#line 167
            strcpy(exe_path, (char const   *)((char *)b2));
            }
#line 168
            goto while_break;
          }
        }
#line 171
        if (p == (void *)0) {
#line 172
          goto while_break;
        }
#line 173
        cp = p + 1;
      }
      while_break: /* CIL Label */ ;
      }
#line 175
      if (found == 0) {
#line 176
        *(exe_path + 0) = (char )'\000';
      }
    }
  }
  {
#line 181
  __cil_tmp21 = strlen((char const   *)exe_path);
#line 181
  i = (int )(__cil_tmp21 - 1UL);
  }
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (i >= 0)) {
#line 181
      goto while_break___0;
    }
#line 182
    if ((int )*(exe_path + i) == 47) {
      {
#line 184
      __cil_tmp23 = strlen((char const   *)(exe_path + i));
#line 184
      __cil_tmp24 = malloc(__cil_tmp23);
#line 184
      tpath = __cil_tmp24;
      }
#line 184
      if (tpath == (void *)0) {
        {
#line 185
        __cil_tmp25 = strlen((char const   *)(exe_path + i));
#line 185
        a1loge(g_log, 1, "set_exe_path: malloc %d bytes failed\n", __cil_tmp25);
#line 186
        *(exe_path + 0) = (char )'\000';
        }
#line 187
        return;
      }
      {
#line 189
      strcpy(tpath, (char const   *)((exe_path + i) + 1));
#line 190
      g_log->tag = tpath;
#line 191
      *(exe_path + (i + 1)) = (char )'\000';
      }
#line 192
      goto while_break___0;
    }
#line 181
    __cil_tmp26 = i;
#line 181
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 196
  __cil_tmp27 = strlen((char const   *)g_log->tag);
#line 196
  i = (int )__cil_tmp27;
  }
#line 197
  if (i >= 4) {
#line 197
    if ((int )*(g_log->tag + (i - 4)) == 46) {
#line 197
      if ((int )*(g_log->tag + (i - 3)) == 101) {
        _L___17: /* CIL Label */ 
#line 197
        if ((int )*(g_log->tag + (i - 2)) == 120) {
          _L: /* CIL Label */ 
#line 197
          if ((int )*(g_log->tag + (i - 1)) == 101) {
#line 202
            *(g_log->tag + (i - 4)) = (char )'\000';
          } else
#line 197
          if ((int )*(g_log->tag + (i - 1)) == 69) {
#line 202
            *(g_log->tag + (i - 4)) = (char )'\000';
          }
        } else
#line 197
        if ((int )*(g_log->tag + (i - 2)) == 88) {
#line 197
          goto _L;
        }
      } else
#line 197
      if ((int )*(g_log->tag + (i - 3)) == 69) {
#line 197
        goto _L___17;
      }
    }
  }
  return;
}
}
#line 215 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int not_interactive  =    0;
#line 216 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char cr_char  =    (char )'\r';
#line 218 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void check_if_not_interactive(void) 
{ 
  char *ev ;
  char *__cil_tmp2 ;

  {
  {
#line 221
  ev = getenv("ARGYLL_NOT_INTERACTIVE");
  }
#line 221
  if (ev != (void *)0) {
#line 222
    not_interactive = 1;
#line 223
    cr_char = (char )'\n';
  } else {
#line 225
    not_interactive = 0;
#line 226
    cr_char = (char )'\r';
  }
  return;
}
}
#line 235
static void va_loge(a1log *p , char *fmt  , ...) ;
#line 356 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static char *get_sys_info(void) 
{ 
  static char sysinfo[300] ;
  unsigned int tmp ;
  struct utsname ver ;
  int __cil_tmp4 ;

  {
#line 357
  sysinfo[0] = "Unknown";
#line 357
  tmp = (unsigned int )1;
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (tmp >= 300) {
#line 357
      goto while_break;
    }
#line 357
    sysinfo[tmp] = 0;
#line 357
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  __cil_tmp4 = uname(& ver);
  }
#line 360
  if (__cil_tmp4 == 0) {
    {
#line 361
    sprintf((char *)sysinfo, "%s %s %s %s", (char *)ver.sysname, (char *)ver.version,
            (char *)ver.release, (char *)ver.machine);
    }
  }
#line 362
  return ((char *)sysinfo);
}
}
#line 384 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static void a1_default_v_log(void *cntx , a1log *p , char *fmt , va_list args ) 
{ 


  {
  {
#line 385
  vfprintf(stdout, (char const   *)fmt, args);
#line 386
  fflush(stdout);
  }
  return;
}
}
#line 390 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static void a1_default_de_log(void *cntx , a1log *p , char *fmt , va_list args ) 
{ 


  {
  {
#line 391
  vfprintf(stderr, (char const   *)fmt, args);
#line 392
  fflush(stderr);
  }
  return;
}
}
#line 400 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static void va_loge(a1log *p , char *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 402
  __builtin_va_start((void *)args, fmt);
#line 403
  (*(p->loge))(p->cntx, p, fmt, (void *)args);
#line 404
  __builtin_va_end((void *)args);
  }
  return;
}
}
#line 408 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
a1log default_log  = 
#line 408
     {1, "argyll", 0, 0, (void *)0, & a1_default_v_log, & a1_default_de_log, & a1_default_de_log,
    0, {(char )'\000'}, {0}};
#line 420 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
a1log *g_log  =    & default_log;
#line 425 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
a1log *new_a1log(a1log *log___0 , int verb , int debug , void *cntx , void (*logv)(void * ,
                                                                                   a1log * ,
                                                                                   char * ,
                                                                                   va_list  ) ,
                 void (*logd)(void * , a1log * , char * , va_list  ) , void (*loge)(void * ,
                                                                                    a1log * ,
                                                                                    char * ,
                                                                                    va_list  ) ) 
{ 
  int __cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 437
  if (log___0 != (void *)0) {
#line 438
    (log___0->refc) ++;
#line 439
    return (log___0);
  }
  {
#line 441
  __cil_tmp9 = calloc(sizeof(a1log ), (unsigned long )1);
#line 441
  log___0 = (a1log *)__cil_tmp9;
  }
#line 441
  if (log___0 == (void *)0) {
    {
#line 442
    a1loge(g_log, 1, "new_a1log: malloc of a1log failed, calling exit(1)\n");
#line 443
    exit(1);
    }
  }
#line 445
  log___0->refc = 1;
#line 446
  log___0->verb = verb;
#line 447
  log___0->debug = debug;
#line 449
  log___0->cntx = cntx;
#line 450
  if (logv != (void *)0) {
#line 451
    log___0->logv = logv;
  } else {
#line 453
    log___0->logv = & a1_default_v_log;
  }
#line 455
  if (logd != (void *)0) {
#line 456
    log___0->logd = logd;
  } else {
#line 458
    log___0->logd = & a1_default_de_log;
  }
#line 460
  if (loge != (void *)0) {
#line 461
    log___0->loge = loge;
  } else {
#line 463
    log___0->loge = & a1_default_de_log;
  }
#line 465
  log___0->errc = 0;
#line 466
  log___0->errm[0] = (char )'\000';
#line 468
  return (log___0);
}
}
#line 472 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
a1log *new_a1log_d(a1log *log___0 ) 
{ 
  a1log *__cil_tmp2 ;

  {
  {
#line 473
  __cil_tmp2 = new_a1log(log___0, 0, 0, (void *)0, (void (*)(void * , a1log * , char * ,
                                                             va_list  ))((void *)0),
                         (void (*)(void * , a1log * , char * , va_list  ))((void *)0),
                         (void (*)(void * , a1log * , char * , va_list  ))((void *)0));
  }
#line 473
  return (__cil_tmp2);
}
}
#line 478 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
a1log *del_a1log(a1log *log___0 ) 
{ 


  {
#line 479
  if (log___0 != (void *)0) {
#line 480
    (log___0->refc) --;
#line 480
    if (log___0->refc <= 0) {
      {
#line 485
      pthread_mutex_destroy(& log___0->lock);
#line 487
      free(log___0);
      }
    }
  }
#line 490
  return ((a1log *)((void *)0));
}
}
#line 494 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1log_debug(a1log *log___0 , int level ) 
{ 


  {
#line 495
  if (log___0 != (void *)0) {
#line 496
    log___0->debug = level;
  }
  return;
}
}
#line 501 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1log_verb(a1log *log___0 , int level ) 
{ 


  {
#line 502
  if (log___0 != (void *)0) {
#line 503
    log___0->verb = level;
  }
  return;
}
}
#line 508 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1log_tag(a1log *log___0 , char *tag ) 
{ 


  {
#line 509
  if (log___0 != (void *)0) {
#line 510
    log___0->tag = tag;
  }
  return;
}
}
#line 515 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1logv(a1log *log___0 , int level , char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp5 ;

  {
#line 517
  if (log___0 != (void *)0) {
#line 518
    if (log___0->verb >= level) {
#line 521
      if (g_log_init == 0) {
        {
#line 521
        pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 521
        pthread_mutex_lock(& log___0->lock);
#line 521
        g_log_init = 1;
        }
      } else {
        {
#line 521
        pthread_mutex_lock(& log___0->lock);
        }
      }
#line 521
      if (0) {
        {
#line 521
        va_loge(log___0, "\n#######################################################################\n");
#line 521
        __cil_tmp5 = get_sys_info();
#line 521
        va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n\313U", "2.2.0U",
                "Linux 64 bit", __cil_tmp5);
#line 521
        g_deb_init = 1;
        }
      }
      {
#line 522
      __builtin_va_start((void *)args, fmt);
#line 523
      (*(log___0->logv))(log___0->cntx, log___0, fmt, (void *)args);
#line 524
      __builtin_va_end((void *)args);
#line 525
      pthread_mutex_unlock(& log___0->lock);
      }
    }
  }
  return;
}
}
#line 531 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1logd(a1log *log___0 , int level , char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp5 ;

  {
#line 532
  if (log___0 != (void *)0) {
#line 533
    if (log___0->debug >= level) {
#line 536
      if (g_log_init == 0) {
        {
#line 536
        pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 536
        pthread_mutex_lock(& log___0->lock);
#line 536
        g_log_init = 1;
        }
      } else {
        {
#line 536
        pthread_mutex_lock(& log___0->lock);
        }
      }
#line 536
      if (! g_deb_init) {
        {
#line 536
        va_loge(log___0, "\n#######################################################################\n");
#line 536
        __cil_tmp5 = get_sys_info();
#line 536
        va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
                __cil_tmp5);
#line 536
        g_deb_init = 1;
        }
      }
      {
#line 537
      __builtin_va_start((void *)args, fmt);
#line 538
      (*(log___0->logd))(log___0->cntx, log___0, fmt, (void *)args);
#line 539
      __builtin_va_end((void *)args);
#line 540
      pthread_mutex_unlock(& log___0->lock);
      }
    }
  }
  return;
}
}
#line 546 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1logw(a1log *log___0 , char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 547
  if (log___0 != (void *)0) {
#line 551
    if (g_log_init == 0) {
      {
#line 551
      pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 551
      pthread_mutex_lock(& log___0->lock);
#line 551
      g_log_init = 1;
      }
    } else {
      {
#line 551
      pthread_mutex_lock(& log___0->lock);
      }
    }
#line 551
    if (0) {
      {
#line 551
      va_loge(log___0, "\n#######################################################################\n");
#line 551
      __cil_tmp4 = get_sys_info();
#line 551
      va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
              __cil_tmp4);
#line 551
      g_deb_init = 1;
      }
    }
    {
#line 552
    __builtin_va_start((void *)args, fmt);
#line 553
    (*(log___0->loge))(log___0->cntx, log___0, fmt, (void *)args);
#line 554
    __builtin_va_end((void *)args);
#line 555
    pthread_mutex_unlock(& log___0->lock);
    }
#line 556
    if (log___0->logd != log___0->loge) {
#line 557
      if (g_log_init == 0) {
        {
#line 557
        pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 557
        pthread_mutex_lock(& log___0->lock);
#line 557
        g_log_init = 1;
        }
      } else {
        {
#line 557
        pthread_mutex_lock(& log___0->lock);
        }
      }
#line 557
      if (! g_deb_init) {
        {
#line 557
        va_loge(log___0, "\n#######################################################################\n");
#line 557
        __cil_tmp5 = get_sys_info();
#line 557
        va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
                __cil_tmp5);
#line 557
        g_deb_init = 1;
        }
      }
      {
#line 558
      __builtin_va_start((void *)args, fmt);
#line 559
      (*(log___0->logd))(log___0->cntx, log___0, fmt, (void *)args);
#line 560
      __builtin_va_end((void *)args);
#line 561
      pthread_mutex_unlock(& log___0->lock);
      }
    }
#line 563
    if (log___0->logv != log___0->loge) {
#line 563
      if (log___0->logv != log___0->logd) {
#line 564
        if (g_log_init == 0) {
          {
#line 564
          pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 564
          pthread_mutex_lock(& log___0->lock);
#line 564
          g_log_init = 1;
          }
        } else {
          {
#line 564
          pthread_mutex_lock(& log___0->lock);
          }
        }
#line 564
        if (0) {
          {
#line 564
          va_loge(log___0, "\n#######################################################################\n");
#line 564
          __cil_tmp6 = get_sys_info();
#line 564
          va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0",
                  "Linux 64 bit", __cil_tmp6);
#line 564
          g_deb_init = 1;
          }
        }
        {
#line 565
        __builtin_va_start((void *)args, fmt);
#line 566
        (*(log___0->logv))(log___0->cntx, log___0, fmt, (void *)args);
#line 567
        __builtin_va_end((void *)args);
#line 568
        pthread_mutex_unlock(& log___0->lock);
        }
      }
    }
  }
  return;
}
}
#line 576 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1loge(a1log *log___0 , int ecode , char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 577
  if (log___0 != (void *)0) {
#line 580
    if (log___0->errc == 0) {
#line 581
      if (g_log_init == 0) {
        {
#line 581
        pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 581
        pthread_mutex_lock(& log___0->lock);
#line 581
        g_log_init = 1;
        }
      } else {
        {
#line 581
        pthread_mutex_lock(& log___0->lock);
        }
      }
#line 581
      if (0) {
        {
#line 581
        va_loge(log___0, "\n#######################################################################\n");
#line 581
        __cil_tmp5 = get_sys_info();
#line 581
        va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
                __cil_tmp5);
#line 581
        g_deb_init = 1;
        }
      }
      {
#line 582
      log___0->errc = ecode;
#line 583
      __builtin_va_start((void *)args, fmt);
#line 584
      vsnprintf((char *)log___0->errm, (unsigned long )500, (char const   *)fmt, (void *)args);
#line 585
      __builtin_va_end((void *)args);
#line 586
      pthread_mutex_unlock(& log___0->lock);
      }
    }
    {
#line 588
    __builtin_va_start((void *)args, fmt);
    }
#line 590
    if (g_log_init == 0) {
      {
#line 590
      pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 590
      pthread_mutex_lock(& log___0->lock);
#line 590
      g_log_init = 1;
      }
    } else {
      {
#line 590
      pthread_mutex_lock(& log___0->lock);
      }
    }
#line 590
    if (0) {
      {
#line 590
      va_loge(log___0, "\n#######################################################################\n");
#line 590
      __cil_tmp6 = get_sys_info();
#line 590
      va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
              __cil_tmp6);
#line 590
      g_deb_init = 1;
      }
    }
    {
#line 591
    __builtin_va_start((void *)args, fmt);
#line 592
    (*(log___0->loge))(log___0->cntx, log___0, fmt, (void *)args);
#line 593
    __builtin_va_end((void *)args);
#line 594
    pthread_mutex_unlock(& log___0->lock);
    }
#line 595
    if (log___0->logd != log___0->loge) {
#line 596
      if (g_log_init == 0) {
        {
#line 596
        pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 596
        pthread_mutex_lock(& log___0->lock);
#line 596
        g_log_init = 1;
        }
      } else {
        {
#line 596
        pthread_mutex_lock(& log___0->lock);
        }
      }
#line 596
      if (! g_deb_init) {
        {
#line 596
        va_loge(log___0, "\n#######################################################################\n");
#line 596
        __cil_tmp7 = get_sys_info();
#line 596
        va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
                __cil_tmp7);
#line 596
        g_deb_init = 1;
        }
      }
      {
#line 597
      __builtin_va_start((void *)args, fmt);
#line 598
      (*(log___0->logd))(log___0->cntx, log___0, fmt, (void *)args);
#line 599
      __builtin_va_end((void *)args);
#line 600
      pthread_mutex_unlock(& log___0->lock);
      }
    }
#line 602
    if (log___0->logv != log___0->loge) {
#line 602
      if (log___0->logv != log___0->logd) {
#line 603
        if (g_log_init == 0) {
          {
#line 603
          pthread_mutex_init(& log___0->lock, (pthread_mutexattr_t *)((void *)0));
#line 603
          pthread_mutex_lock(& log___0->lock);
#line 603
          g_log_init = 1;
          }
        } else {
          {
#line 603
          pthread_mutex_lock(& log___0->lock);
          }
        }
#line 603
        if (0) {
          {
#line 603
          va_loge(log___0, "\n#######################################################################\n");
#line 603
          __cil_tmp8 = get_sys_info();
#line 603
          va_loge(log___0, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0",
                  "Linux 64 bit", __cil_tmp8);
#line 603
          g_deb_init = 1;
          }
        }
        {
#line 604
        __builtin_va_start((void *)args, fmt);
#line 605
        (*(log___0->logv))(log___0->cntx, log___0, fmt, (void *)args);
#line 606
        __builtin_va_end((void *)args);
#line 607
        pthread_mutex_unlock(& log___0->lock);
        }
      }
    }
  }
  return;
}
}
#line 614 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void a1logue(a1log *log___0 ) 
{ 


  {
#line 615
  if (log___0 != (void *)0) {
#line 616
    log___0->errc = 0;
#line 617
    log___0->errm[0] = (char )'\000';
  }
  return;
}
}
#line 625 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_bytes(FILE *fp , char *pfx , unsigned char *buf , int base , int len ) 
{ 
  int i ;
  int j ;
  int ii ;
  char oline[200] ;
  unsigned int tmp ;
  char *bp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned short const   **__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 627
  oline[0] = (char )'\000';
#line 627
  tmp = (unsigned int )1;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (tmp >= 200) {
#line 627
      goto while_break;
    }
#line 627
    oline[tmp] = 0;
#line 627
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 627
  bp = (char *)oline;
#line 628
  if (pfx == (void *)0) {
#line 629
    pfx = "\220";
  }
#line 630
  j = 0;
#line 630
  i = j;
  {
#line 630
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 630
    if (! (i < len)) {
#line 630
      goto while_break___0;
    }
#line 631
    if (i % 16 == 0) {
      {
#line 632
      __cil_tmp12 = sprintf(bp, "%s%04x:", pfx, base + i);
      }
#line 632
      bp += __cil_tmp12;
    }
    {
#line 633
    __cil_tmp13 = sprintf(bp, " %02x", (int )*(buf + i));
    }
#line 633
    bp += __cil_tmp13;
#line 634
    if (i + 1 >= len) {
      _L: /* CIL Label */ 
#line 635
      ii = i;
      {
#line 635
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 635
        if (! ((ii + 1) % 16 != 0)) {
#line 635
          goto while_break___1;
        }
        {
#line 636
        __cil_tmp14 = sprintf(bp, "   ");
        }
#line 636
        bp += __cil_tmp14;
#line 635
        ii ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 637
      __cil_tmp16 = sprintf(bp, "  ");
      }
#line 637
      bp += __cil_tmp16;
      {
#line 638
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 638
        if (! (j <= i)) {
#line 638
          goto while_break___2;
        }
        {
#line 639
        __cil_tmp17 = __ctype_b_loc();
        }
#line 639
        if (! ((int )*(buf + j) & 128)) {
#line 639
          if ((int )*(*__cil_tmp17 + (int )*(buf + j)) & 16384) {
            {
#line 640
            __cil_tmp18 = sprintf(bp, "%c", (int )*(buf + j));
            }
#line 640
            bp += __cil_tmp18;
          } else {
            {
            {
#line 642
            __cil_tmp19 = sprintf(bp, ".");
            }
            }
#line 642
            bp += __cil_tmp19;
          }
        } else {
          {
          {
#line 642
          __cil_tmp19 = sprintf(bp, ".");
          }
          }
#line 642
          bp += __cil_tmp19;
        }
#line 638
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 644
      __cil_tmp21 = sprintf(bp, "\n");
      }
      {
#line 644
      bp += __cil_tmp21;
#line 645
      fprintf(fp, "%s", (char *)oline);
#line 646
      bp = (char *)oline;
      }
    } else
#line 634
    if ((i + 1) % 16 == 0) {
#line 634
      goto _L;
    }
#line 630
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 654 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_bytes(a1log *log___0 , char *pfx , unsigned char *buf , int base , int len ) 
{ 
  int i ;
  int j ;
  int ii ;
  char oline[200] ;
  unsigned int tmp ;
  char *bp ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned short const   **__cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
#line 656
  oline[0] = (char )'\000';
#line 656
  tmp = (unsigned int )1;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (tmp >= 200) {
#line 656
      goto while_break;
    }
#line 656
    oline[tmp] = 0;
#line 656
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  bp = (char *)oline;
#line 657
  if (pfx == (void *)0) {
#line 658
    pfx = "\220";
  }
#line 659
  j = 0;
#line 659
  i = j;
  {
#line 659
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 659
    if (! (i < len)) {
#line 659
      goto while_break___0;
    }
#line 660
    if (i % 16 == 0) {
      {
#line 661
      __cil_tmp12 = sprintf(bp, "%s%04x:", pfx, base + i);
      }
#line 661
      bp += __cil_tmp12;
    }
    {
#line 662
    __cil_tmp13 = sprintf(bp, " %02x", (int )*(buf + i));
    }
#line 662
    bp += __cil_tmp13;
#line 663
    if (i + 1 >= len) {
      _L: /* CIL Label */ 
#line 664
      ii = i;
      {
#line 664
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 664
        if (! ((ii + 1) % 16 != 0)) {
#line 664
          goto while_break___1;
        }
        {
#line 665
        __cil_tmp14 = sprintf(bp, "   ");
        }
#line 665
        bp += __cil_tmp14;
#line 664
        ii ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 666
      __cil_tmp16 = sprintf(bp, "  ");
      }
#line 666
      bp += __cil_tmp16;
      {
#line 667
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 667
        if (! (j <= i)) {
#line 667
          goto while_break___2;
        }
        {
#line 668
        __cil_tmp17 = __ctype_b_loc();
        }
#line 668
        if (! ((int )*(buf + j) & 128)) {
#line 668
          if ((int )*(*__cil_tmp17 + (int )*(buf + j)) & 16384) {
            {
#line 669
            __cil_tmp18 = sprintf(bp, "%c", (int )*(buf + j));
            }
#line 669
            bp += __cil_tmp18;
          } else {
            {
            {
#line 671
            __cil_tmp19 = sprintf(bp, ".");
            }
            }
#line 671
            bp += __cil_tmp19;
          }
        } else {
          {
          {
#line 671
          __cil_tmp19 = sprintf(bp, ".");
          }
          }
#line 671
          bp += __cil_tmp19;
        }
#line 667
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 673
      __cil_tmp21 = sprintf(bp, "\n");
      }
      {
#line 673
      bp += __cil_tmp21;
#line 674
      a1logd(log___0, 0, "%s", (char *)oline);
#line 675
      bp = (char *)oline;
      }
    } else
#line 663
    if ((i + 1) % 16 == 0) {
#line 663
      goto _L;
    }
#line 659
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 688 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static void g_logv(char *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 690
  __builtin_va_start((void *)args, fmt);
#line 691
  (*(g_log->logv))(g_log->cntx, g_log, fmt, (void *)args);
#line 692
  __builtin_va_end((void *)args);
  }
  return;
}
}
#line 695 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static void g_loge(char *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 697
  __builtin_va_start((void *)args, fmt);
#line 698
  (*(g_log->loge))(g_log->cntx, g_log, fmt, (void *)args);
#line 699
  __builtin_va_end((void *)args);
  }
  return;
}
}
#line 703 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void verbose(int level , char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp4 ;

  {
#line 704
  if (g_log->verb >= level) {
#line 707
    if (g_log_init == 0) {
      {
#line 707
      pthread_mutex_init(& g_log->lock, (pthread_mutexattr_t *)((void *)0));
#line 707
      pthread_mutex_lock(& g_log->lock);
#line 707
      g_log_init = 1;
      }
    } else {
      {
#line 707
      pthread_mutex_lock(& g_log->lock);
      }
    }
#line 707
    if (0) {
      {
#line 707
      va_loge(g_log, "\n#######################################################################\n");
#line 707
      __cil_tmp4 = get_sys_info();
#line 707
      va_loge(g_log, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
              __cil_tmp4);
#line 707
      g_deb_init = 1;
      }
    }
    {
#line 708
    g_logv("%s: ", g_log->tag);
#line 709
    __builtin_va_start((void *)args, fmt);
#line 710
    (*(g_log->logv))(g_log->cntx, g_log, fmt, (void *)args);
#line 711
    __builtin_va_end((void *)args);
#line 712
    g_logv("\n");
#line 713
    pthread_mutex_unlock(& g_log->lock);
    }
  }
  return;
}
}
#line 718 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void warning(char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp3 ;

  {
#line 721
  if (g_log_init == 0) {
    {
#line 721
    pthread_mutex_init(& g_log->lock, (pthread_mutexattr_t *)((void *)0));
#line 721
    pthread_mutex_lock(& g_log->lock);
#line 721
    g_log_init = 1;
    }
  } else {
    {
#line 721
    pthread_mutex_lock(& g_log->lock);
    }
  }
#line 721
  if (0) {
    {
#line 721
    va_loge(g_log, "\n#######################################################################\n");
#line 721
    __cil_tmp3 = get_sys_info();
#line 721
    va_loge(g_log, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
            __cil_tmp3);
#line 721
    g_deb_init = 1;
    }
  }
  {
#line 722
  g_loge("%s: Warning - ", g_log->tag);
#line 723
  __builtin_va_start((void *)args, fmt);
#line 724
  (*(g_log->loge))(g_log->cntx, g_log, fmt, (void *)args);
#line 725
  __builtin_va_end((void *)args);
#line 726
  g_loge("\n");
#line 727
  pthread_mutex_unlock(& g_log->lock);
  }
  return;
}
}
#line 731 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void error(char *fmt  , ...) 
{ 
  va_list args ;
  char *__cil_tmp3 ;

  {
#line 734
  if (g_log_init == 0) {
    {
#line 734
    pthread_mutex_init(& g_log->lock, (pthread_mutexattr_t *)((void *)0));
#line 734
    pthread_mutex_lock(& g_log->lock);
#line 734
    g_log_init = 1;
    }
  } else {
    {
#line 734
    pthread_mutex_lock(& g_log->lock);
    }
  }
#line 734
  if (0) {
    {
#line 734
    va_loge(g_log, "\n#######################################################################\n");
#line 734
    __cil_tmp3 = get_sys_info();
#line 734
    va_loge(g_log, "Argyll \'V%s\' Build \'%s\' System \'%s\'\n", "2.2.0", "Linux 64 bit",
            __cil_tmp3);
#line 734
    g_deb_init = 1;
    }
  }
  {
#line 735
  g_loge("%s: Error - ", g_log->tag);
#line 736
  __builtin_va_start((void *)args, fmt);
#line 737
  (*(g_log->loge))(g_log->cntx, g_log, fmt, (void *)args);
#line 738
  __builtin_va_end((void *)args);
#line 739
  g_loge("\n");
#line 740
  pthread_mutex_unlock(& g_log->lock);
#line 742
  exit(1);
  }
}
}
#line 755 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
static size_t ssat_mul(size_t a , size_t b ) 
{ 
  size_t c ;

  {
#line 758
  if (a == 0UL) {
#line 759
    return ((size_t )0);
  } else
#line 758
  if (b == 0UL) {
#line 759
    return ((size_t )0);
  }
#line 761
  if (a > 0xffffffffffffffffUL / b) {
#line 762
    return (0xffffffffffffffffUL);
  } else {
#line 764
    return (a * b);
  }
}
}
#line 768 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void *recalloc(void *ptr , size_t cnum , size_t csize , size_t nnum , size_t nsize ) 
{ 
  int ind ;
  size_t ctot ;
  size_t ntot ;
  void *__cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  void *__cil_tmp12 ;

  {
#line 775
  ind = 0;
#line 778
  if (ptr == (void *)0) {
    {
#line 779
    __cil_tmp9 = calloc(nnum, nsize);
    }
#line 779
    return (__cil_tmp9);
  }
  {
#line 781
  ntot = ssat_mul(nnum, nsize);
  }
#line 781
  if (ntot == 0xffffffffffffffffUL) {
#line 782
    return ((void *)0);
  }
  {
#line 784
  ctot = ssat_mul(cnum, csize);
  }
#line 784
  if (ctot == 0xffffffffffffffffUL) {
#line 785
    return ((void *)0);
  }
  {
#line 787
  ptr = realloc(ptr, ntot);
  }
#line 789
  if (ptr != (void *)0) {
#line 789
    if (ntot > ctot) {
      {
#line 790
      memset((char *)ptr + ctot, 0, ntot - ctot);
      }
    }
  }
#line 792
  return (ptr);
}
}
#line 1048 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double *dvector(int nl , int nh ) 
{ 
  double *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1054
  __cil_tmp4 = malloc((unsigned long )((nh - nl) + 1) * sizeof(double ));
#line 1054
  v = (double *)__cil_tmp4;
  }
#line 1054
  if (v == (void *)0) {
#line 1055
    if (ret_null_on_malloc_fail) {
#line 1056
      return ((double *)((void *)0));
    } else {
      {
#line 1058
      error("Malloc failure in dvector()");
      }
    }
  }
#line 1060
  return (v - nl);
}
}
#line 1063 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double *dvectorz(int nl , int nh ) 
{ 
  double *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1069
  __cil_tmp4 = calloc((unsigned long )((nh - nl) + 1), sizeof(double ));
#line 1069
  v = (double *)__cil_tmp4;
  }
#line 1069
  if (v == (void *)0) {
#line 1070
    if (ret_null_on_malloc_fail) {
#line 1071
      return ((double *)((void *)0));
    } else {
      {
#line 1073
      error("Malloc failure in dvector()\027\313U");
      }
    }
  }
#line 1075
  return (v - nl);
}
}
#line 1078 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_dvector(double *v , int nl , int nh ) 
{ 


  {
#line 1083
  if (v == (void *)0) {
#line 1084
    return;
  }
  {
#line 1086
  free((char *)(v + nl));
  }
  return;
}
}
#line 1091 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double **dmatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  double **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1101
  if (nrh < nrl) {
#line 1102
    nrh = nrl;
  }
#line 1103
  if (nch < ncl) {
#line 1104
    nch = ncl;
  }
  {
#line 1106
  rows = (nrh - nrl) + 1;
#line 1107
  cols = (nch - ncl) + 1;
#line 1110
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(double *));
#line 1110
  m = (double **)__cil_tmp9;
  }
#line 1110
  if (m == (void *)0) {
#line 1111
    if (ret_null_on_malloc_fail) {
#line 1112
      return ((double **)((void *)0));
    } else {
      {
#line 1114
      error("Malloc failure in dmatrix(), pointers");
      }
    }
  }
  {
#line 1116
  m -= nrl;
#line 1117
  m ++;
#line 1119
  __cil_tmp10 = malloc((unsigned long )(rows * cols) * sizeof(double ));
#line 1119
  *(m + (nrl - 1)) = (double *)__cil_tmp10;
  }
#line 1119
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1120
    if (ret_null_on_malloc_fail) {
#line 1121
      return ((double **)((void *)0));
    } else {
      {
#line 1123
      error("Malloc failure in dmatrix(), array\266\027\313U");
      }
    }
  }
#line 1126
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1127
  i = nrl + 1;
  {
#line 1127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1127
    if (! (i <= nrh)) {
#line 1127
      goto while_break;
    }
#line 1128
    *(m + i) = *(m + (i - 1)) + cols;
#line 1127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1130
  return (m);
}
}
#line 1133 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double **dmatrixz(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  double **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1143
  if (nrh < nrl) {
#line 1144
    nrh = nrl;
  }
#line 1145
  if (nch < ncl) {
#line 1146
    nch = ncl;
  }
  {
#line 1148
  rows = (nrh - nrl) + 1;
#line 1149
  cols = (nch - ncl) + 1;
#line 1151
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(double *));
#line 1151
  m = (double **)__cil_tmp9;
  }
#line 1151
  if (m == (void *)0) {
#line 1152
    if (ret_null_on_malloc_fail) {
#line 1153
      return ((double **)((void *)0));
    } else {
      {
#line 1155
      error("Malloc failure in dmatrix(), pointers");
      }
    }
  }
  {
#line 1157
  m -= nrl;
#line 1158
  m ++;
#line 1160
  __cil_tmp10 = calloc((unsigned long )(rows * cols), sizeof(double ));
#line 1160
  *(m + (nrl - 1)) = (double *)__cil_tmp10;
  }
#line 1160
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1161
    if (ret_null_on_malloc_fail) {
#line 1162
      return ((double **)((void *)0));
    } else {
      {
#line 1164
      error("Malloc failure in dmatrix(), array");
      }
    }
  }
#line 1167
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1168
  i = nrl + 1;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! (i <= nrh)) {
#line 1168
      goto while_break;
    }
#line 1169
    *(m + i) = *(m + (i - 1)) + cols;
#line 1168
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1171
  return (m);
}
}
#line 1174 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1181
  if (m == (void *)0) {
#line 1182
    return;
  }
#line 1184
  if (nrh < nrl) {
#line 1185
    nrh = nrl;
  }
#line 1186
  if (nch < ncl) {
#line 1187
    nch = ncl;
  }
  {
#line 1189
  free((char *)*(m + (nrl - 1)));
#line 1190
  free((char *)((m + nrl) - 1));
  }
  return;
}
}
#line 1194 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dmatrix_reset(double **m , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int cols ;
  int __cil_tmp8 ;

  {
#line 1204
  if (nrh < nrl) {
#line 1205
    nrh = nrl;
  }
#line 1206
  if (nch < ncl) {
#line 1207
    nch = ncl;
  }
#line 1209
  cols = (nch - ncl) + 1;
#line 1211
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1212
  i = nrl + 1;
  {
#line 1212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1212
    if (! (i <= nrh)) {
#line 1212
      goto while_break;
    }
#line 1213
    *(m + i) = *(m + (i - 1)) + cols;
#line 1212
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1220 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double **dhmatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int rows ;
  int cols ;
  double **m ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1230
  if (nrh < nrl) {
#line 1231
    nrh = nrl;
  }
#line 1232
  if (nch < ncl) {
#line 1233
    nch = ncl;
  }
#line 1235
  rows = (nrh - nrl) + 1;
#line 1236
  cols = (nch - ncl) + 1;
#line 1238
  if (rows != cols) {
#line 1239
    if (ret_null_on_malloc_fail) {
#line 1240
      return ((double **)((void *)0));
    } else {
      {
#line 1242
      error("dhmatrix() given unequal rows and columns\333\266\027\313U");
      }
    }
  }
  {
#line 1245
  __cil_tmp10 = malloc((unsigned long )(rows + 1) * sizeof(double *));
#line 1245
  m = (double **)__cil_tmp10;
  }
#line 1245
  if (m == (void *)0) {
#line 1246
    if (ret_null_on_malloc_fail) {
#line 1247
      return ((double **)((void *)0));
    } else {
      {
#line 1249
      error("Malloc failure in dhmatrix(), pointers");
      }
    }
  }
  {
#line 1251
  m -= nrl;
#line 1252
  m ++;
#line 1254
  __cil_tmp11 = malloc((unsigned long )((rows * rows + rows) / 2) * sizeof(double ));
#line 1254
  *(m + (nrl - 1)) = (double *)__cil_tmp11;
  }
#line 1254
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1255
    if (ret_null_on_malloc_fail) {
#line 1256
      return ((double **)((void *)0));
    } else {
      {
#line 1258
      error("Malloc failure in dhmatrix(), array");
      }
    }
  }
#line 1261
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1262
  j = 1;
#line 1262
  i = nrl + 1;
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! (i <= nrh)) {
#line 1262
      goto while_break;
    }
#line 1263
    *(m + i) = *(m + (i - 1)) + j;
#line 1262
    __cil_tmp13 = j;
#line 1262
    j ++;
#line 1262
    __cil_tmp12 = i;
#line 1262
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1265
  return (m);
}
}
#line 1268 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double **dhmatrixz(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int rows ;
  int cols ;
  double **m ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1278
  if (nrh < nrl) {
#line 1279
    nrh = nrl;
  }
#line 1280
  if (nch < ncl) {
#line 1281
    nch = ncl;
  }
#line 1283
  rows = (nrh - nrl) + 1;
#line 1284
  cols = (nch - ncl) + 1;
#line 1286
  if (rows != cols) {
#line 1287
    if (ret_null_on_malloc_fail) {
#line 1288
      return ((double **)((void *)0));
    } else {
      {
#line 1290
      error("dhmatrix() given unequal rows and columns");
      }
    }
  }
  {
#line 1293
  __cil_tmp10 = malloc((unsigned long )(rows + 1) * sizeof(double *));
#line 1293
  m = (double **)__cil_tmp10;
  }
#line 1293
  if (m == (void *)0) {
#line 1294
    if (ret_null_on_malloc_fail) {
#line 1295
      return ((double **)((void *)0));
    } else {
      {
#line 1297
      error("Malloc failure in dhmatrix(), pointers");
      }
    }
  }
  {
#line 1299
  m -= nrl;
#line 1300
  m ++;
#line 1302
  __cil_tmp11 = calloc((unsigned long )((rows * rows + rows) / 2), sizeof(double ));
#line 1302
  *(m + (nrl - 1)) = (double *)__cil_tmp11;
  }
#line 1302
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1303
    if (ret_null_on_malloc_fail) {
#line 1304
      return ((double **)((void *)0));
    } else {
      {
#line 1306
      error("Malloc failure in dhmatrix(), array");
      }
    }
  }
#line 1309
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1310
  j = 1;
#line 1310
  i = nrl + 1;
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! (i <= nrh)) {
#line 1310
      goto while_break;
    }
#line 1311
    *(m + i) = *(m + (i - 1)) + j;
#line 1310
    __cil_tmp13 = j;
#line 1310
    j ++;
#line 1310
    __cil_tmp12 = i;
#line 1310
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1313
  return (m);
}
}
#line 1316 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_dhmatrix(double **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1323
  if (m == (void *)0) {
#line 1324
    return;
  }
#line 1326
  if (nrh < nrl) {
#line 1327
    nrh = nrl;
  }
#line 1328
  if (nch < ncl) {
#line 1329
    nch = ncl;
  }
  {
#line 1331
  free((char *)*(m + (nrl - 1)));
#line 1332
  free((char *)((m + nrl) - 1));
  }
  return;
}
}
#line 1337 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void copy_dmatrix(double **dst , double **src , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1346
  j = nrl;
  {
#line 1346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1346
    if (! (j <= nrh)) {
#line 1346
      goto while_break;
    }
#line 1347
    i = ncl;
    {
#line 1347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1347
      if (! (i <= nch)) {
#line 1347
        goto while_break___0;
      }
#line 1348
      *(*(dst + j) + i) = *(*(src + j) + i);
#line 1347
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1346
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1352 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void copy_dmatrix_to3x3(double dst[3][3] , double **src , int nrl , int nrh , int ncl ,
                        int nch ) 
{ 
  int i ;
  int j ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1361
  if (nrh - nrl > 2) {
#line 1362
    nrh = nrl + 2;
  }
#line 1363
  if (nch - ncl > 2) {
#line 1364
    nch = ncl + 2;
  }
#line 1365
  j = nrl;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if (! (j <= nrh)) {
#line 1365
      goto while_break;
    }
#line 1366
    i = ncl;
    {
#line 1366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1366
      if (! (i <= nch)) {
#line 1366
        goto while_break___0;
      }
#line 1367
      dst[j][i] = *(*(src + j) + i);
#line 1366
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1365
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1372 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double **convert_dmatrix(double *a , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int nrow ;
  int ncol ;
  double **m ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 1379
  nrow = (nrh - nrl) + 1;
  {
#line 1379
  ncol = (nch - ncl) + 1;
#line 1383
  __cil_tmp11 = malloc((unsigned long )nrow * sizeof(double *));
#line 1383
  m = (double **)__cil_tmp11;
  }
#line 1383
  if (m == (void *)0) {
#line 1384
    if (ret_null_on_malloc_fail) {
#line 1385
      return ((double **)((void *)0));
    } else {
      {
#line 1387
      error("Malloc failure in convert_dmatrix()");
      }
    }
  }
#line 1390
  m -= nrl;
#line 1392
  *(m + nrl) = a - ncl;
#line 1393
  j = nrl + 1;
#line 1393
  i = 1;
  {
#line 1393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1393
    if (! (i < nrow)) {
#line 1393
      goto while_break;
    }
#line 1394
    *(m + j) = *(m + (j - 1)) + ncol;
#line 1393
    __cil_tmp13 = j;
#line 1393
    j ++;
#line 1393
    __cil_tmp12 = i;
#line 1393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  return (m);
}
}
#line 1400 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_convert_dmatrix(double **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1407
  if (m == (void *)0) {
#line 1408
    return;
  }
  {
#line 1410
  free((char *)(m + nrl));
  }
  return;
}
}
#line 1415 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
float *fvector(int nl , int nh ) 
{ 
  float *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1421
  __cil_tmp4 = malloc((unsigned long )((nh - nl) + 1) * sizeof(float ));
#line 1421
  v = (float *)__cil_tmp4;
  }
#line 1421
  if (v == (void *)0) {
#line 1422
    if (ret_null_on_malloc_fail) {
#line 1423
      return ((float *)((void *)0));
    } else {
      {
#line 1425
      error("Malloc failure in fvector()");
      }
    }
  }
#line 1427
  return (v - nl);
}
}
#line 1430 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
float *fvectorz(int nl , int nh ) 
{ 
  float *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1436
  __cil_tmp4 = calloc((unsigned long )((nh - nl) + 1), sizeof(float ));
#line 1436
  v = (float *)__cil_tmp4;
  }
#line 1436
  if (v == (void *)0) {
#line 1437
    if (ret_null_on_malloc_fail) {
#line 1438
      return ((float *)((void *)0));
    } else {
      {
#line 1440
      error("Malloc failure in fvector()");
      }
    }
  }
#line 1442
  return (v - nl);
}
}
#line 1445 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_fvector(float *v , int nl , int nh ) 
{ 


  {
#line 1450
  if (v == (void *)0) {
#line 1451
    return;
  }
  {
#line 1453
  free((char *)(v + nl));
  }
  return;
}
}
#line 1458 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
float **fmatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  float **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1468
  if (nrh < nrl) {
#line 1469
    nrh = nrl;
  }
#line 1470
  if (nch < ncl) {
#line 1471
    nch = ncl;
  }
  {
#line 1473
  rows = (nrh - nrl) + 1;
#line 1474
  cols = (nch - ncl) + 1;
#line 1476
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(float *));
#line 1476
  m = (float **)__cil_tmp9;
  }
#line 1476
  if (m == (void *)0) {
#line 1477
    if (ret_null_on_malloc_fail) {
#line 1478
      return ((float **)((void *)0));
    } else {
      {
#line 1480
      error("Malloc failure in dmatrix(), pointers");
      }
    }
  }
  {
#line 1482
  m -= nrl;
#line 1483
  m ++;
#line 1485
  __cil_tmp10 = malloc((unsigned long )(rows * cols) * sizeof(float ));
#line 1485
  *(m + (nrl - 1)) = (float *)__cil_tmp10;
  }
#line 1485
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1486
    if (ret_null_on_malloc_fail) {
#line 1487
      return ((float **)((void *)0));
    } else {
      {
#line 1489
      error("Malloc failure in dmatrix(), array");
      }
    }
  }
#line 1492
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1493
  i = nrl + 1;
  {
#line 1493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1493
    if (! (i <= nrh)) {
#line 1493
      goto while_break;
    }
#line 1494
    *(m + i) = *(m + (i - 1)) + cols;
#line 1493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1496
  return (m);
}
}
#line 1499 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
float **fmatrixz(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  float **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1509
  if (nrh < nrl) {
#line 1510
    nrh = nrl;
  }
#line 1511
  if (nch < ncl) {
#line 1512
    nch = ncl;
  }
  {
#line 1514
  rows = (nrh - nrl) + 1;
#line 1515
  cols = (nch - ncl) + 1;
#line 1517
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(float *));
#line 1517
  m = (float **)__cil_tmp9;
  }
#line 1517
  if (m == (void *)0) {
#line 1518
    if (ret_null_on_malloc_fail) {
#line 1519
      return ((float **)((void *)0));
    } else {
      {
#line 1521
      error("Malloc failure in dmatrix(), pointers");
      }
    }
  }
  {
#line 1523
  m -= nrl;
#line 1524
  m ++;
#line 1526
  __cil_tmp10 = calloc((unsigned long )(rows * cols), sizeof(float ));
#line 1526
  *(m + (nrl - 1)) = (float *)__cil_tmp10;
  }
#line 1526
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1527
    if (ret_null_on_malloc_fail) {
#line 1528
      return ((float **)((void *)0));
    } else {
      {
#line 1530
      error("Malloc failure in dmatrix(), array");
      }
    }
  }
#line 1533
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1534
  i = nrl + 1;
  {
#line 1534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1534
    if (! (i <= nrh)) {
#line 1534
      goto while_break;
    }
#line 1535
    *(m + i) = *(m + (i - 1)) + cols;
#line 1534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1537
  return (m);
}
}
#line 1540 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_fmatrix(float **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1547
  if (m == (void *)0) {
#line 1548
    return;
  }
#line 1550
  if (nrh < nrl) {
#line 1551
    nrh = nrl;
  }
#line 1552
  if (nch < ncl) {
#line 1553
    nch = ncl;
  }
  {
#line 1555
  free((char *)*(m + (nrl - 1)));
#line 1556
  free((char *)((m + nrl) - 1));
  }
  return;
}
}
#line 1561 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int *ivector(int nl , int nh ) 
{ 
  int *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1567
  __cil_tmp4 = malloc((unsigned long )((nh - nl) + 1) * sizeof(int ));
#line 1567
  v = (int *)__cil_tmp4;
  }
#line 1567
  if (v == (void *)0) {
#line 1568
    if (ret_null_on_malloc_fail) {
#line 1569
      return ((int *)((void *)0));
    } else {
      {
#line 1571
      error("Malloc failure in ivector()");
      }
    }
  }
#line 1573
  return (v - nl);
}
}
#line 1576 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int *ivectorz(int nl , int nh ) 
{ 
  int *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1582
  __cil_tmp4 = calloc((unsigned long )((nh - nl) + 1), sizeof(int ));
#line 1582
  v = (int *)__cil_tmp4;
  }
#line 1582
  if (v == (void *)0) {
#line 1583
    if (ret_null_on_malloc_fail) {
#line 1584
      return ((int *)((void *)0));
    } else {
      {
#line 1586
      error("Malloc failure in ivector()");
      }
    }
  }
#line 1588
  return (v - nl);
}
}
#line 1591 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_ivector(int *v , int nl , int nh ) 
{ 


  {
#line 1596
  if (v == (void *)0) {
#line 1597
    return;
  }
  {
#line 1599
  free((char *)(v + nl));
  }
  return;
}
}
#line 1606 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int **imatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  int **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1616
  if (nrh < nrl) {
#line 1617
    nrh = nrl;
  }
#line 1618
  if (nch < ncl) {
#line 1619
    nch = ncl;
  }
  {
#line 1621
  rows = (nrh - nrl) + 1;
#line 1622
  cols = (nch - ncl) + 1;
#line 1624
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(int *));
#line 1624
  m = (int **)__cil_tmp9;
  }
#line 1624
  if (m == (void *)0) {
#line 1625
    if (ret_null_on_malloc_fail) {
#line 1626
      return ((int **)((void *)0));
    } else {
      {
#line 1628
      error("Malloc failure in imatrix(), pointers");
      }
    }
  }
  {
#line 1630
  m -= nrl;
#line 1631
  m ++;
#line 1633
  __cil_tmp10 = malloc((unsigned long )(rows * cols) * sizeof(int ));
#line 1633
  *(m + (nrl - 1)) = (int *)__cil_tmp10;
  }
#line 1633
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1634
    if (ret_null_on_malloc_fail) {
#line 1635
      return ((int **)((void *)0));
    } else {
      {
#line 1637
      error("Malloc failure in imatrix(), array\270\027\313U");
      }
    }
  }
#line 1640
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1641
  i = nrl + 1;
  {
#line 1641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (! (i <= nrh)) {
#line 1641
      goto while_break;
    }
#line 1642
    *(m + i) = *(m + (i - 1)) + cols;
#line 1641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1644
  return (m);
}
}
#line 1647 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int **imatrixz(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  int **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1657
  if (nrh < nrl) {
#line 1658
    nrh = nrl;
  }
#line 1659
  if (nch < ncl) {
#line 1660
    nch = ncl;
  }
  {
#line 1662
  rows = (nrh - nrl) + 1;
#line 1663
  cols = (nch - ncl) + 1;
#line 1665
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(int *));
#line 1665
  m = (int **)__cil_tmp9;
  }
#line 1665
  if (m == (void *)0) {
#line 1666
    if (ret_null_on_malloc_fail) {
#line 1667
      return ((int **)((void *)0));
    } else {
      {
#line 1669
      error("Malloc failure in imatrix(), pointers");
      }
    }
  }
  {
#line 1671
  m -= nrl;
#line 1672
  m ++;
#line 1674
  __cil_tmp10 = calloc((unsigned long )(rows * cols), sizeof(int ));
#line 1674
  *(m + (nrl - 1)) = (int *)__cil_tmp10;
  }
#line 1674
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1675
    if (ret_null_on_malloc_fail) {
#line 1676
      return ((int **)((void *)0));
    } else {
      {
#line 1678
      error("Malloc failure in imatrix(), array");
      }
    }
  }
#line 1681
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1682
  i = nrl + 1;
  {
#line 1682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1682
    if (! (i <= nrh)) {
#line 1682
      goto while_break;
    }
#line 1683
    *(m + i) = *(m + (i - 1)) + cols;
#line 1682
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1685
  return (m);
}
}
#line 1688 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_imatrix(int **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1695
  if (m == (void *)0) {
#line 1696
    return;
  }
#line 1698
  if (nrh < nrl) {
#line 1699
    nrh = nrl;
  }
#line 1700
  if (nch < ncl) {
#line 1701
    nch = ncl;
  }
  {
#line 1703
  free((char *)*(m + (nrl - 1)));
#line 1704
  free((char *)((m + nrl) - 1));
  }
  return;
}
}
#line 1709 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
short *svector(int nl , int nh ) 
{ 
  short *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1715
  __cil_tmp4 = malloc((unsigned long )((nh - nl) + 1) * sizeof(short ));
#line 1715
  v = (short *)__cil_tmp4;
  }
#line 1715
  if (v == (void *)0) {
#line 1716
    if (ret_null_on_malloc_fail) {
#line 1717
      return ((short *)((void *)0));
    } else {
      {
#line 1719
      error("Malloc failure in svector()");
      }
    }
  }
#line 1721
  return (v - nl);
}
}
#line 1724 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
short *svectorz(int nl , int nh ) 
{ 
  short *v ;
  void *__cil_tmp4 ;

  {
  {
#line 1730
  __cil_tmp4 = calloc((unsigned long )((nh - nl) + 1), sizeof(short ));
#line 1730
  v = (short *)__cil_tmp4;
  }
#line 1730
  if (v == (void *)0) {
#line 1731
    if (ret_null_on_malloc_fail) {
#line 1732
      return ((short *)((void *)0));
    } else {
      {
#line 1734
      error("Malloc failure in svector()");
      }
    }
  }
#line 1736
  return (v - nl);
}
}
#line 1739 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_svector(short *v , int nl , int nh ) 
{ 


  {
#line 1744
  if (v == (void *)0) {
#line 1745
    return;
  }
  {
#line 1747
  free((char *)(v + nl));
  }
  return;
}
}
#line 1754 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
short **smatrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  short **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1764
  if (nrh < nrl) {
#line 1765
    nrh = nrl;
  }
#line 1766
  if (nch < ncl) {
#line 1767
    nch = ncl;
  }
  {
#line 1769
  rows = (nrh - nrl) + 1;
#line 1770
  cols = (nch - ncl) + 1;
#line 1772
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(short *));
#line 1772
  m = (short **)__cil_tmp9;
  }
#line 1772
  if (m == (void *)0) {
#line 1773
    if (ret_null_on_malloc_fail) {
#line 1774
      return ((short **)((void *)0));
    } else {
      {
#line 1776
      error("Malloc failure in smatrix(), pointers");
      }
    }
  }
  {
#line 1778
  m -= nrl;
#line 1779
  m ++;
#line 1781
  __cil_tmp10 = malloc((unsigned long )(rows * cols) * sizeof(short ));
#line 1781
  *(m + (nrl - 1)) = (short *)__cil_tmp10;
  }
#line 1781
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1782
    if (ret_null_on_malloc_fail) {
#line 1783
      return ((short **)((void *)0));
    } else {
      {
#line 1785
      error("Malloc failure in smatrix(), array\270\027\313U");
      }
    }
  }
#line 1788
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1789
  i = nrl + 1;
  {
#line 1789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1789
    if (! (i <= nrh)) {
#line 1789
      goto while_break;
    }
#line 1790
    *(m + i) = *(m + (i - 1)) + cols;
#line 1789
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1792
  return (m);
}
}
#line 1795 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
short **smatrixz(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int rows ;
  int cols ;
  short **m ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 1805
  if (nrh < nrl) {
#line 1806
    nrh = nrl;
  }
#line 1807
  if (nch < ncl) {
#line 1808
    nch = ncl;
  }
  {
#line 1810
  rows = (nrh - nrl) + 1;
#line 1811
  cols = (nch - ncl) + 1;
#line 1813
  __cil_tmp9 = malloc((unsigned long )(rows + 1) * sizeof(short *));
#line 1813
  m = (short **)__cil_tmp9;
  }
#line 1813
  if (m == (void *)0) {
#line 1814
    if (ret_null_on_malloc_fail) {
#line 1815
      return ((short **)((void *)0));
    } else {
      {
#line 1817
      error("Malloc failure in smatrix(), pointers");
      }
    }
  }
  {
#line 1819
  m -= nrl;
#line 1820
  m ++;
#line 1822
  __cil_tmp10 = calloc((unsigned long )(rows * cols), sizeof(short ));
#line 1822
  *(m + (nrl - 1)) = (short *)__cil_tmp10;
  }
#line 1822
  if (*(m + (nrl - 1)) == (void *)0) {
#line 1823
    if (ret_null_on_malloc_fail) {
#line 1824
      return ((short **)((void *)0));
    } else {
      {
#line 1826
      error("Malloc failure in smatrix(), array");
      }
    }
  }
#line 1829
  *(m + nrl) = *(m + (nrl - 1)) - ncl;
#line 1830
  i = nrl + 1;
  {
#line 1830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1830
    if (! (i <= nrh)) {
#line 1830
      goto while_break;
    }
#line 1831
    *(m + i) = *(m + (i - 1)) + cols;
#line 1830
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1833
  return (m);
}
}
#line 1836 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void free_smatrix(short **m , int nrl , int nrh , int ncl , int nch ) 
{ 


  {
#line 1843
  if (m == (void *)0) {
#line 1844
    return;
  }
#line 1846
  if (nrh < nrl) {
#line 1847
    nrh = nrl;
  }
#line 1848
  if (nch < ncl) {
#line 1849
    nch = ncl;
  }
  {
#line 1851
  free((char *)*(m + (nrl - 1)));
#line 1852
  free((char *)((m + nrl) - 1));
  }
  return;
}
}
#line 1860 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_trans(double **d , double **s , int nr , int nc ) 
{ 
  int i ;
  int j ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 1863
  i = 0;
  {
#line 1863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1863
    if (! (i < nr)) {
#line 1863
      goto while_break;
    }
#line 1864
    j = 0;
    {
#line 1864
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1864
      if (! (j < nc)) {
#line 1864
        goto while_break___0;
      }
#line 1865
      *(*(d + j) + i) = *(*(s + i) + j);
#line 1864
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1863
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1871 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void sym_matrix_trans(double **m , int n ) 
{ 
  int i ;
  int j ;
  double tt ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1874
  i = 0;
  {
#line 1874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1874
    if (! (i < n)) {
#line 1874
      goto while_break;
    }
#line 1875
    j = i + 1;
    {
#line 1875
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1875
      if (! (j < n)) {
#line 1875
        goto while_break___0;
      }
#line 1876
      tt = *(*(m + j) + i);
#line 1877
      *(*(m + j) + i) = *(*(m + i) + j);
#line 1878
      *(*(m + i) + j) = tt;
#line 1875
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1874
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1885 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int matrix_mult(double **d , int nr , int nc , double **s1 , int nr1 , int nc1 , double **s2 ,
                int nr2 , int nc2 ) 
{ 
  int i ;
  int j ;
  int k ;
  double **_d ;
  double **__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 1891
  _d = d;
#line 1894
  if (nc1 != nr2) {
#line 1895
    return (1);
  }
#line 1898
  if (nr != nr1) {
#line 1899
    return (2);
  }
#line 1902
  if (nc != nc2) {
#line 1903
    return (3);
  }
#line 1905
  if (d == s1) {
    {
    {
#line 1906
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  } else
#line 1905
  if (d == s2) {
    {
    {
#line 1906
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  }
#line 1908
  i = 0;
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1908
    if (! (i < nr1)) {
#line 1908
      goto while_break;
    }
#line 1909
    j = 0;
    {
#line 1909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1909
      if (! (j < nc2)) {
#line 1909
        goto while_break___0;
      }
#line 1910
      *(*(_d + i) + j) = 0.;
#line 1911
      k = 0;
      {
#line 1911
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1911
        if (! (k < nc1)) {
#line 1911
          goto while_break___1;
        }
#line 1912
        *(*(_d + i) + j) += *(*(s1 + i) + k) * *(*(s2 + k) + j);
#line 1911
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1909
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1908
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1917
  if (_d != d) {
    {
#line 1918
    copy_dmatrix(d, _d, 0, nr - 1, 0, nc - 1);
#line 1919
    free_dmatrix(_d, 0, nr - 1, 0, nc - 1);
    }
  }
#line 1922
  return (0);
}
}
#line 1928 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int matrix_trans_mult(double **d , int nr , int nc , double **ts1 , int nr1 , int nc1 ,
                      double **s2 , int nr2 , int nc2 ) 
{ 
  int i ;
  int j ;
  int k ;
  double **_d ;
  double **__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 1934
  _d = d;
#line 1937
  if (nr1 != nr2) {
#line 1938
    return (1);
  }
#line 1941
  if (nr != nc1) {
#line 1942
    return (2);
  }
#line 1945
  if (nc != nc2) {
#line 1946
    return (3);
  }
#line 1948
  if (d == ts1) {
    {
    {
#line 1949
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  } else
#line 1948
  if (d == s2) {
    {
    {
#line 1949
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  }
#line 1951
  i = 0;
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! (i < nc1)) {
#line 1951
      goto while_break;
    }
#line 1952
    j = 0;
    {
#line 1952
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1952
      if (! (j < nc2)) {
#line 1952
        goto while_break___0;
      }
#line 1953
      *(*(_d + i) + j) = 0.;
#line 1954
      k = 0;
      {
#line 1954
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1954
        if (! (k < nr1)) {
#line 1954
          goto while_break___1;
        }
#line 1955
        *(*(_d + i) + j) += *(*(ts1 + k) + i) * *(*(s2 + k) + j);
#line 1954
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1952
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1960
  if (_d != d) {
    {
#line 1961
    copy_dmatrix(d, _d, 0, nr - 1, 0, nc - 1);
#line 1962
    free_dmatrix(_d, 0, nr - 1, 0, nc - 1);
    }
  }
#line 1965
  return (0);
}
}
#line 1970 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int matrix_mult_trans(double **d , int nr , int nc , double **s1 , int nr1 , int nc1 ,
                      double **ts2 , int nr2 , int nc2 ) 
{ 
  int i ;
  int j ;
  int k ;
  double **_d ;
  double **__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
#line 1976
  _d = d;
#line 1979
  if (nc1 != nc2) {
#line 1980
    return (1);
  }
#line 1983
  if (nr != nr1) {
#line 1984
    return (2);
  }
#line 1987
  if (nc != nr2) {
#line 1988
    return (3);
  }
#line 1990
  if (d == s1) {
    {
    {
#line 1991
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  } else
#line 1990
  if (d == ts2) {
    {
    {
#line 1991
    _d = dmatrix(0, nr - 1, 0, nc - 1);
    }
    }
  }
#line 1993
  i = 0;
  {
#line 1993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1993
    if (! (i < nr1)) {
#line 1993
      goto while_break;
    }
#line 1994
    j = 0;
    {
#line 1994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1994
      if (! (j < nr2)) {
#line 1994
        goto while_break___0;
      }
#line 1995
      *(*(_d + i) + j) = 0.;
#line 1996
      k = 0;
      {
#line 1996
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1996
        if (! (k < nc1)) {
#line 1996
          goto while_break___1;
        }
#line 1997
        *(*(_d + i) + j) += *(*(s1 + i) + k) * *(*(ts2 + j) + k);
#line 1996
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1994
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1993
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2002
  if (_d != d) {
    {
#line 2003
    copy_dmatrix(d, _d, 0, nr - 1, 0, nc - 1);
#line 2004
    free_dmatrix(_d, 0, nr - 1, 0, nc - 1);
    }
  }
#line 2007
  return (0);
}
}
#line 2012 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int matrix_vect_mult(double *d , int nd , double **m , int nr , int nc , double *v ,
                     int nv ) 
{ 
  int i ;
  int j ;
  double *_v ;
  double vv___0[20] ;
  double *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 2018
  _v = v;
#line 2020
  if (d == v) {
#line 2021
    if (nv <= 20) {
#line 2022
      _v = (double *)vv___0;
    } else {
      {
#line 2024
      _v = dvector(0, nv - 1);
      }
    }
#line 2026
    j = 0;
    {
#line 2026
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2026
      if (! (j < nv)) {
#line 2026
        goto while_break;
      }
#line 2027
      *(_v + j) = *(v + j);
#line 2026
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2031
  if (nv != nc) {
#line 2032
    return (1);
  }
#line 2035
  if (nd != nr) {
#line 2036
    return (2);
  }
#line 2038
  i = 0;
  {
#line 2038
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2038
    if (! (i < nd)) {
#line 2038
      goto while_break___0;
    }
#line 2039
    *(d + i) = 0.;
#line 2040
    j = 0;
    {
#line 2040
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2040
      if (! (j < nv)) {
#line 2040
        goto while_break___1;
      }
#line 2041
      *(d + i) += *(*(m + i) + j) * *(_v + j);
#line 2040
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2038
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2045
  if (_v != v) {
#line 2045
    if (_v != (double *)vv___0) {
      {
#line 2046
      free_dvector(_v, 0, nv - 1);
      }
    }
  }
#line 2048
  return (0);
}
}
#line 2053 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int matrix_trans_vect_mult(double *d , int nd , double **m , int nr , int nc , double *v ,
                           int nv ) 
{ 
  int i ;
  int j ;
  double *_v ;
  double vv___0[20] ;
  double *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 2059
  _v = v;
#line 2061
  if (d == v) {
#line 2062
    if (nv <= 20) {
#line 2063
      _v = (double *)vv___0;
    } else {
      {
#line 2065
      _v = dvector(0, nv - 1);
      }
    }
#line 2067
    j = 0;
    {
#line 2067
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2067
      if (! (j < nv)) {
#line 2067
        goto while_break;
      }
#line 2068
      *(_v + j) = *(v + j);
#line 2067
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2072
  if (nv != nr) {
#line 2073
    return (1);
  }
#line 2076
  if (nd != nc) {
#line 2077
    return (2);
  }
#line 2079
  i = 0;
  {
#line 2079
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2079
    if (! (i < nd)) {
#line 2079
      goto while_break___0;
    }
#line 2080
    *(d + i) = 0.;
#line 2081
    j = 0;
    {
#line 2081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2081
      if (! (j < nv)) {
#line 2081
        goto while_break___1;
      }
#line 2082
      *(d + i) += *(*(m + j) + i) * *(_v + j);
#line 2081
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2079
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2085
  if (_v != v) {
#line 2085
    if (_v != (double *)vv___0) {
      {
#line 2086
      free_dvector(_v, 0, nv - 1);
      }
    }
  }
#line 2088
  return (0);
}
}
#line 2092 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_add(double **d , double **s1 , double **s2 , int nr , int nc ) 
{ 
  int i ;
  int j ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 2094
  i = 0;
  {
#line 2094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2094
    if (! (i < nr)) {
#line 2094
      goto while_break;
    }
#line 2095
    j = 0;
    {
#line 2095
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2095
      if (! (j < nc)) {
#line 2095
        goto while_break___0;
      }
#line 2096
      *(*(d + i) + j) = *(*(s1 + i) + j) + *(*(s2 + i) + j);
#line 2095
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2094
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2101 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_scaled_add(double **d , double **s1 , double scale , double **s2 , int nr ,
                       int nc ) 
{ 
  int i ;
  int j ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 2103
  i = 0;
  {
#line 2103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2103
    if (! (i < nr)) {
#line 2103
      goto while_break;
    }
#line 2104
    j = 0;
    {
#line 2104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2104
      if (! (j < nc)) {
#line 2104
        goto while_break___0;
      }
#line 2105
      *(*(d + i) + j) = *(*(s1 + i) + j) + scale * *(*(s2 + i) + j);
#line 2104
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2103
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2110 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_cpy(double **d , double **s , int nr , int nc ) 
{ 
  int i ;
  int j ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2112
  i = 0;
  {
#line 2112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2112
    if (! (i < nr)) {
#line 2112
      goto while_break;
    }
#line 2113
    j = 0;
    {
#line 2113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2113
      if (! (j < nc)) {
#line 2113
        goto while_break___0;
      }
#line 2114
      *(*(d + i) + j) = *(*(s + i) + j);
#line 2113
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2112
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2119 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_set(double **d , double v , int nr , int nc ) 
{ 
  int i ;
  int j ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2121
  i = 0;
  {
#line 2121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2121
    if (! (i < nr)) {
#line 2121
      goto while_break;
    }
#line 2122
    j = 0;
    {
#line 2122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2122
      if (! (j < nc)) {
#line 2122
        goto while_break___0;
      }
#line 2123
      *(*(d + i) + j) = v;
#line 2122
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2128 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double matrix_max_diff(double **d , double **s , int nr , int nc ) 
{ 
  int i ;
  int j ;
  double md ;
  double tt ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 2130
  md = 0.;
#line 2132
  i = 0;
  {
#line 2132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2132
    if (! (i < nr)) {
#line 2132
      goto while_break;
    }
#line 2133
    j = 0;
    {
#line 2133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2133
      if (! (j < nc)) {
#line 2133
        goto while_break___0;
      }
      {
#line 2134
      tt = *(*(d + i) + j) - *(*(s + i) + j);
#line 2135
      tt = fabs(tt);
      }
#line 2136
      if (tt > md) {
#line 2137
        md = tt;
      }
#line 2133
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2132
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2140
  return (md);
}
}
#line 2145 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_set(double *d , double v , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2146
  if (v == 0.) {
    {
#line 2147
    memset((char *)d, 0, (unsigned long )len * sizeof(double ));
    }
  } else {
#line 2150
    i = 0;
    {
#line 2150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2150
      if (! (i < len)) {
#line 2150
        goto while_break;
      }
#line 2151
      *(d + i) = v;
#line 2150
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 2157 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_neg(double *d , double *s , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2159
  i = 0;
  {
#line 2159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2159
    if (! (i < len)) {
#line 2159
      goto while_break;
    }
#line 2160
    *(d + i) = - *(s + i);
#line 2159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2165 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_add(double *d , double *v , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2171
  i = 0;
  {
#line 2171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2171
    if (! (i < len)) {
#line 2171
      goto while_break;
    }
#line 2172
    *(d + i) += *(v + i);
#line 2171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2176 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_add3(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2180
  i = 0;
  {
#line 2180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2180
    if (! (i < len)) {
#line 2180
      goto while_break;
    }
#line 2181
    *(d + i) = *(s1 + i) + *(s2 + i);
#line 2180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2186 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_sub(double *d , double *v , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2190
  i = 0;
  {
#line 2190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2190
    if (! (i < len)) {
#line 2190
      goto while_break;
    }
#line 2191
    *(d + i) -= *(v + i);
#line 2190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2195 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_sub3(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2199
  i = 0;
  {
#line 2199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2199
    if (! (i < len)) {
#line 2199
      goto while_break;
    }
#line 2200
    *(d + i) = *(s1 + i) - *(s2 + i);
#line 2199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2204 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_invert(double *d , double *s , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2206
  i = 0;
  {
#line 2206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2206
    if (! (i < len)) {
#line 2206
      goto while_break;
    }
#line 2207
    *(d + i) = 1. / *(s + i);
#line 2206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2211 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_mul(double *d , double *s , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2215
  i = 0;
  {
#line 2215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2215
    if (! (i < len)) {
#line 2215
      goto while_break;
    }
#line 2216
    *(d + i) *= *(s + i);
#line 2215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2220 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_mul3(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2224
  i = 0;
  {
#line 2224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2224
    if (! (i < len)) {
#line 2224
      goto while_break;
    }
#line 2225
    *(d + i) = *(s1 + i) * *(s2 + i);
#line 2224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2229 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_div(double *d , double *s , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2233
  i = 0;
  {
#line 2233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2233
    if (! (i < len)) {
#line 2233
      goto while_break;
    }
#line 2234
    *(d + i) /= *(s + i);
#line 2233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2238 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_div3(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2240
  i = 0;
  {
#line 2240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2240
    if (! (i < len)) {
#line 2240
      goto while_break;
    }
#line 2241
    *(d + i) = *(s1 + i) / *(s2 + i);
#line 2240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2246 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_div3_safe(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  double __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 2248
  i = 0;
  {
#line 2248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2248
    if (! (i < len)) {
#line 2248
      goto while_break;
    }
    {
#line 2249
    __cil_tmp6 = fabs(*(s2 + i));
    }
#line 2249
    if (__cil_tmp6 >= 1e-06) {
#line 2250
      *(d + i) = *(s1 + i) / *(s2 + i);
    } else {
#line 2252
      *(d + i) = 1.;
    }
#line 2248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2256 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_muldiv(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2258
  i = 0;
  {
#line 2258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2258
    if (! (i < len)) {
#line 2258
      goto while_break;
    }
#line 2259
    *(d + i) *= *(s1 + i) / *(s2 + i);
#line 2258
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2264 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_muldiv_safe(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  double __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 2266
  i = 0;
  {
#line 2266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2266
    if (! (i < len)) {
#line 2266
      goto while_break;
    }
    {
#line 2267
    __cil_tmp6 = fabs(*(s2 + i));
    }
#line 2267
    if (__cil_tmp6 >= 1e-06) {
#line 2268
      *(d + i) *= *(s1 + i) / *(s2 + i);
    }
#line 2266
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2273 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_muldiv3(double *d , double *s1 , double *s2 , double *s3 , int len ) 
{ 
  int i ;
  int __cil_tmp7 ;

  {
#line 2275
  i = 0;
  {
#line 2275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2275
    if (! (i < len)) {
#line 2275
      goto while_break;
    }
#line 2276
    *(d + i) = (*(s1 + i) * *(s2 + i)) / *(s3 + i);
#line 2275
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2280 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_max_elem(double *d , double *s , int len ) 
{ 
  int i ;
  double tmp ;
  int __cil_tmp6 ;

  {
#line 2282
  i = 0;
  {
#line 2282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2282
    if (! (i < len)) {
#line 2282
      goto while_break;
    }
#line 2283
    if (*(d + i) > *(s + i)) {
#line 2283
      tmp = *(d + i);
    } else {
#line 2283
      tmp = *(s + i);
    }
#line 2283
    *(d + i) = tmp;
#line 2282
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2287 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_max_elem3(double *d , double *s1 , double *s2 , int len ) 
{ 
  int i ;
  double tmp ;
  int __cil_tmp7 ;

  {
#line 2289
  i = 0;
  {
#line 2289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2289
    if (! (i < len)) {
#line 2289
      goto while_break;
    }
#line 2290
    if (*(s1 + i) > *(s2 + i)) {
#line 2290
      tmp = *(s1 + i);
    } else {
#line 2290
      tmp = *(s2 + i);
    }
#line 2290
    *(d + i) = tmp;
#line 2289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2295 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_scale(double *d , double *s , double scale , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2298
  i = 0;
  {
#line 2298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2298
    if (! (i < len)) {
#line 2298
      goto while_break;
    }
#line 2299
    *(d + i) = *(s + i) * scale;
#line 2298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2303 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_scale1(double *d , double scale , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2306
  i = 0;
  {
#line 2306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2306
    if (! (i < len)) {
#line 2306
      goto while_break;
    }
#line 2307
    *(d + i) *= scale;
#line 2306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2312 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_blend(double *d , double *s0 , double *s1 , double bl , int len ) 
{ 
  int i ;
  int __cil_tmp7 ;

  {
#line 2315
  i = 0;
  {
#line 2315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2315
    if (! (i < len)) {
#line 2315
      goto while_break;
    }
#line 2316
    *(d + i) = (1. - bl) * *(s0 + i) + bl * *(s1 + i);
#line 2315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2320 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_scaleadd(double *d , double *s , double scale , int len ) 
{ 
  int i ;
  int __cil_tmp6 ;

  {
#line 2323
  i = 0;
  {
#line 2323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2323
    if (! (i < len)) {
#line 2323
      goto while_break;
    }
#line 2324
    *(d + i) += *(s + i) * scale;
#line 2323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2328 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_dot(double *s1 , double *s2 , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp6 ;

  {
#line 2330
  rv = 0.;
#line 2331
  i = 0;
  {
#line 2331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2331
    if (! (i < len)) {
#line 2331
      goto while_break;
    }
#line 2332
    rv += *(s1 + i) * *(s2 + i);
#line 2331
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2333
  return (rv);
}
}
#line 2337 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_mag(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;
  double __cil_tmp6 ;

  {
#line 2339
  rv = 0.;
#line 2341
  i = 0;
  {
#line 2341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2341
    if (! (i < len)) {
#line 2341
      goto while_break;
    }
#line 2342
    rv += *(s + i) * *(s + i);
#line 2341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2344
  __cil_tmp6 = sqrt(rv);
  }
#line 2344
  return (__cil_tmp6);
}
}
#line 2348 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_magsq(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;

  {
#line 2350
  rv = 0.;
#line 2352
  i = 0;
  {
#line 2352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2352
    if (! (i < len)) {
#line 2352
      goto while_break;
    }
#line 2353
    rv += *(s + i) * *(s + i);
#line 2352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2355
  return (rv);
}
}
#line 2359 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_diffmag(double *s1 , double *s2 , int len ) 
{ 
  int i ;
  double rv ;
  double tt ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;

  {
#line 2361
  rv = 0.;
#line 2363
  i = 0;
  {
#line 2363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2363
    if (! (i < len)) {
#line 2363
      goto while_break;
    }
#line 2364
    tt = *(s1 + i) - *(s2 + i);
#line 2365
    rv += tt * tt;
#line 2363
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2368
  __cil_tmp8 = sqrt(rv);
  }
#line 2368
  return (__cil_tmp8);
}
}
#line 2372 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_sum(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;

  {
#line 2374
  rv = 0.;
#line 2376
  i = 0;
  {
#line 2376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2376
    if (! (i < len)) {
#line 2376
      goto while_break;
    }
#line 2377
    rv += *(s + i);
#line 2376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2379
  return (rv);
}
}
#line 2383 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_avg(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;

  {
#line 2385
  rv = 0.;
#line 2387
  if (len <= 0) {
#line 2388
    return (rv);
  }
#line 2390
  i = 0;
  {
#line 2390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2390
    if (! (i < len)) {
#line 2390
      goto while_break;
    }
#line 2391
    rv += *(s + i);
#line 2390
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2393
  return (rv / (double )len);
}
}
#line 2398 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int vect_normalize(double *d , double *s , int len ) 
{ 
  int i ;
  double nv ;
  int rv ;
  int __cil_tmp7 ;
  double __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 2400
  nv = 0.;
#line 2401
  rv = 0;
#line 2403
  i = 0;
  {
#line 2403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2403
    if (! (i < len)) {
#line 2403
      goto while_break;
    }
#line 2404
    nv += *(s + i) * *(s + i);
#line 2403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2405
  nv = sqrt(nv);
  }
#line 2407
  if (nv < 1.00000000001e-09) {
#line 2408
    nv = 1.;
#line 2409
    rv = 1;
  } else {
#line 2411
    nv = 1. / nv;
  }
#line 2414
  i = 0;
  {
#line 2414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2414
    if (! (i < len)) {
#line 2414
      goto while_break___0;
    }
#line 2415
    *(d + i) = *(s + i) * nv;
#line 2414
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2417
  return (rv);
}
}
#line 2421 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_max_mag(double *s , int len ) 
{ 
  int i ;
  double rv ;
  double tt ;
  double __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 2423
  rv = 0.;
#line 2425
  i = 0;
  {
#line 2425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2425
    if (! (i < len)) {
#line 2425
      goto while_break;
    }
    {
#line 2426
    __cil_tmp6 = fabs(*(s + i));
#line 2426
    tt = __cil_tmp6;
    }
#line 2427
    if (tt > rv) {
#line 2428
      rv = tt;
    }
#line 2425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2430
  return (rv);
}
}
#line 2434 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_max(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;

  {
#line 2436
  rv = - ((double )1.79769313487e+308L);
#line 2438
  i = 0;
  {
#line 2438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2438
    if (! (i < len)) {
#line 2438
      goto while_break;
    }
#line 2439
    if (*(s + i) > rv) {
#line 2440
      rv = *(s + i);
    }
#line 2438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2442
  return (rv);
}
}
#line 2446 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_max2(double *s1 , int len1 , double *s2 , int len2 ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 2448
  rv = - ((double )1.79769313487e+308L);
#line 2450
  i = 0;
  {
#line 2450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2450
    if (! (i < len1)) {
#line 2450
      goto while_break;
    }
#line 2451
    if (*(s1 + i) > rv) {
#line 2452
      rv = *(s1 + i);
    }
#line 2450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2455
  i = 0;
  {
#line 2455
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2455
    if (! (i < len2)) {
#line 2455
      goto while_break___0;
    }
#line 2456
    if (*(s2 + i) > rv) {
#line 2457
      rv = *(s2 + i);
    }
#line 2455
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2459
  return (rv);
}
}
#line 2463 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_min(double *s , int len ) 
{ 
  int i ;
  double rv ;
  int __cil_tmp5 ;

  {
#line 2465
  rv = (double )1.79769313487e+308L;
#line 2467
  i = 0;
  {
#line 2467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2467
    if (! (i < len)) {
#line 2467
      goto while_break;
    }
#line 2468
    if (*(s + i) < rv) {
#line 2469
      rv = *(s + i);
    }
#line 2467
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2471
  return (rv);
}
}
#line 2475 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_abs(double *d , double *s , int len ) 
{ 
  int i ;
  double __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2478
  i = 0;
  {
#line 2478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2478
    if (! (i < len)) {
#line 2478
      goto while_break;
    }
    {
#line 2479
    *(d + i) = fabs(*(s + i));
    }
#line 2478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2483 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_spow(double *d , double *s , double pv , int len ) 
{ 
  int i ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 2486
  i = 0;
  {
#line 2486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2486
    if (! (i < len)) {
#line 2486
      goto while_break;
    }
#line 2488
    if (pv != 0.) {
#line 2489
      if (pv < 0.) {
#line 2490
        if (*(s + i) < 0.) {
          {
#line 2491
          __cil_tmp6 = pow(- *(s + i), - pv);
#line 2491
          *(d + i) = 1. / - __cil_tmp6;
          }
        } else {
          {
#line 2493
          __cil_tmp7 = pow(*(s + i), - pv);
#line 2493
          *(d + i) = 1. / __cil_tmp7;
          }
        }
      } else
#line 2495
      if (*(s + i) < 0.) {
        {
#line 2496
        __cil_tmp8 = pow(- *(s + i), pv);
#line 2496
        *(d + i) = - __cil_tmp8;
        }
      } else {
        {
#line 2498
        *(d + i) = pow(*(s + i), pv);
        }
      }
    }
#line 2486
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2507 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int vect_clip(double *d , double *s , double min , double max , int len ) 
{ 
  int i ;
  int clip ;
  int __cil_tmp8 ;

  {
#line 2508
  clip = 0;
#line 2510
  i = 0;
  {
#line 2510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2510
    if (! (i < len)) {
#line 2510
      goto while_break;
    }
#line 2511
    if (*(s + i) < min) {
#line 2512
      clip = 1;
#line 2513
      if (d != (void *)0) {
#line 2514
        *(d + i) = min;
      }
    } else
#line 2515
    if (*(s + i) > max) {
#line 2516
      clip = 1;
#line 2517
      if (d != (void *)0) {
#line 2518
        *(d + i) = max;
      }
    } else
#line 2519
    if (d != (void *)0) {
#line 2520
      *(d + i) = *(s + i);
    }
#line 2510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2524
  return (clip);
}
}
#line 2528 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int vect_cmp(double *s1 , double *s2 , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2531
  i = 0;
  {
#line 2531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2531
    if (! (i < len)) {
#line 2531
      goto while_break;
    }
#line 2532
    if (*(s1 + i) != *(s2 + i)) {
#line 2533
      return (0);
    }
#line 2531
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2535
  return (1);
}
}
#line 2544 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int vect_lsearch(double *p , double in , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2547
  if (in < *(p + 0)) {
#line 2548
    in = *(p + 0);
  } else
#line 2549
  if (in > *(p + (len - 1))) {
#line 2550
    in = *(p + (len - 1));
  }
#line 2553
  i = 0;
  {
#line 2553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2553
    if (! (i < len - 1)) {
#line 2553
      goto while_break;
    }
#line 2554
    if (in >= *(p + i)) {
#line 2554
      if (in < *(p + (i + 1))) {
#line 2555
        goto while_break;
      }
    }
#line 2553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2557
  return (i);
}
}
#line 2564 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int vect_bsearch(double *p , double in , int len ) 
{ 
  int i0 ;
  int i1 ;
  int i2 ;
  double v0 ;
  double v1 ;
  double v2 ;

  {
#line 2569
  i0 = 0;
#line 2570
  i2 = len - 1;
#line 2571
  v0 = *(p + i0);
#line 2572
  v2 = *(p + i2);
#line 2576
  if (in <= v0) {
#line 2578
    i0 = i0;
  } else
#line 2579
  if (in >= v2) {
#line 2581
    i0 = i2;
  } else {
    {
#line 2583
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2584
      i1 = (i2 + i0) / 2;
#line 2585
      v1 = *(p + i1);
#line 2587
      if (v1 < in) {
#line 2588
        i0 = i1;
#line 2589
        v0 = v1;
      } else {
#line 2591
        i2 = i1;
#line 2592
        v2 = v1;
      }
#line 2583
      if (! (i2 - i0 > 1)) {
#line 2583
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2598
  return (i0);
}
}
#line 2603 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_lerp(double *s , double in , int len ) 
{ 
  int i ;
  double out ;
  double __cil_tmp6 ;

  {
#line 2607
  if (in < 0.) {
#line 2608
    in = 0.;
  } else
#line 2609
  if (in > 1.) {
#line 2610
    in = 1.;
  }
  {
#line 2612
  in *= (double )len - 1.;
#line 2613
  __cil_tmp6 = floor(in);
#line 2613
  i = (int )__cil_tmp6;
  }
#line 2615
  if (i >= len - 2) {
#line 2616
    i = len - 2;
  }
#line 2618
  in -= (double )i;
#line 2620
  out = (1. - in) * *(s + i) + in * *(s + (i + 1));
#line 2622
  return (out);
}
}
#line 2631 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_rev_lerp(double *s , double in , int len ) 
{ 
  int i ;
  double out ;
  double minv ;
  double maxv ;
  double minx ;
  double maxx ;
  int __cil_tmp10 ;

  {
#line 2634
  minv = 1e+38;
#line 2634
  maxv = - 1e+38;
#line 2638
  i = 0;
  {
#line 2638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2638
    if (! (i < len - 1)) {
#line 2638
      goto while_break;
    }
#line 2639
    if (in >= *(s + i)) {
#line 2639
      if (in < *(s + (i + 1))) {
#line 2640
        goto while_break;
      }
    }
#line 2642
    if (*(s + i) < minv) {
#line 2643
      minv = *(s + i);
#line 2644
      minx = (double )i;
    }
#line 2646
    if (*(s + i) > maxv) {
#line 2647
      maxv = *(s + i);
#line 2648
      maxx = (double )i;
    }
#line 2638
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2653
  if (i >= len - 1) {
#line 2654
    if (in < minv) {
#line 2655
      out = minx / ((double )len - 1.);
    } else {
#line 2657
      out = maxx / ((double )len - 1.);
    }
  } else {
#line 2660
    out = (double )i + (in - *(s + i)) / (*(s + (i + 1)) - *(s + i));
#line 2661
    out /= (double )len - 1.;
  }
#line 2664
  return (out);
}
}
#line 2672 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_lerp2x(double *p , double *v , double in , int len ) 
{ 
  int i ;
  double out ;
  int __cil_tmp7 ;

  {
  {
#line 2677
  i = vect_bsearch(p, in, len);
  }
#line 2679
  if (i > len - 1) {
#line 2680
    i = len - 1;
  }
#line 2683
  in = (in - *(p + i)) / (*(p + (i + 1)) - *(p + i));
#line 2686
  out = (1. - in) * *(v + i) + in * *(v + (i + 1));
#line 2689
  return (out);
}
}
#line 2693 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_lerp2(double *p , double *v , double in , int len ) 
{ 
  double ret ;
  double __cil_tmp6 ;

  {
#line 2696
  if (in < *(p + 0)) {
#line 2698
    return (*(v + 0));
  } else
#line 2699
  if (in > *(p + (len - 1))) {
#line 2701
    return (*(v + (len - 1)));
  }
  {
#line 2704
  ret = vect_lerp2x(p, v, in, len);
  }
#line 2707
  return (ret);
}
}
#line 2713 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void ivect_set(int *d , int v , int len ) 
{ 
  int i ;
  int __cil_tmp5 ;

  {
#line 2714
  if (v == 0) {
    {
#line 2715
    memset((char *)d, 0, (unsigned long )len * sizeof(int ));
    }
  } else {
#line 2718
    i = 0;
    {
#line 2718
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2718
      if (! (i < len)) {
#line 2718
        goto while_break;
      }
#line 2719
      *(d + i) = v;
#line 2718
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 2730 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_dmatrix(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2732
  fprintf(fp, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2734
  j = 0;
  }
  {
#line 2734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2734
    if (! (j < nr)) {
#line 2734
      goto while_break;
    }
    {
#line 2735
    fprintf(fp, "%s ", pfx);
#line 2736
    i = 0;
    }
    {
#line 2736
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2736
      if (! (i < nc)) {
#line 2736
        goto while_break___0;
      }
#line 2737
      if (i < nc - 1) {
#line 2737
        tmp = ", ";
      } else {
#line 2737
        tmp = "\220";
      }
      {
#line 2737
      fprintf(fp, "%f%s", *(*(a + j) + i), tmp);
      }
#line 2736
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2738
    fprintf(fp, "\n");
    }
#line 2734
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2746 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_dmatrix_fmt(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ,
                      char *fmt ) 
{ 
  int i ;
  int j ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2748
  fprintf(fp, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2750
  j = 0;
  }
  {
#line 2750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2750
    if (! (j < nr)) {
#line 2750
      goto while_break;
    }
    {
#line 2751
    fprintf(fp, "%s \027\313U", pfx);
#line 2752
    i = 0;
    }
    {
#line 2752
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2752
      if (! (i < nc)) {
#line 2752
        goto while_break___0;
      }
      {
#line 2753
      fprintf(fp, (char const   *)fmt, *(*(a + j) + i));
      }
#line 2754
      if (i < nc - 1) {
        {
#line 2755
        fprintf(fp, "%s", ", ");
        }
      }
#line 2752
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2757
    fprintf(fp, "\n\005\273\027\313U");
    }
#line 2750
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2765 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_fmatrix(FILE *fp , char *id , char *pfx , float **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2767
  fprintf(fp, "%s%s[%d][%d]\nU", pfx, id, nr, nc);
#line 2769
  j = 0;
  }
  {
#line 2769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2769
    if (! (j < nr)) {
#line 2769
      goto while_break;
    }
    {
#line 2770
    fprintf(fp, "%s ", pfx);
#line 2771
    i = 0;
    }
    {
#line 2771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2771
      if (! (i < nc)) {
#line 2771
        goto while_break___0;
      }
#line 2772
      if (i < nc - 1) {
#line 2772
        tmp = ", \273\027\313U";
      } else {
#line 2772
        tmp = "\220";
      }
      {
#line 2772
      fprintf(fp, "%f%s\313U", (double )*(*(a + j) + i), tmp);
      }
#line 2771
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2773
    fprintf(fp, "\n");
    }
#line 2769
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2781 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_imatrix(FILE *fp , char *id , char *pfx , int **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2783
  fprintf(fp, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2785
  j = 0;
  }
  {
#line 2785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2785
    if (! (j < nr)) {
#line 2785
      goto while_break;
    }
    {
#line 2786
    fprintf(fp, "%s ", pfx);
#line 2787
    i = 0;
    }
    {
#line 2787
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2787
      if (! (i < nc)) {
#line 2787
        goto while_break___0;
      }
#line 2788
      if (i < nc - 1) {
#line 2788
        tmp = ", ";
      } else {
#line 2788
        tmp = "\220";
      }
      {
#line 2788
      fprintf(fp, "%d%s", *(*(a + j) + i), tmp);
      }
#line 2787
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2789
    fprintf(fp, "\n");
    }
#line 2785
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2797 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_smatrix(FILE *fp , char *id , char *pfx , short **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2799
  fprintf(fp, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2801
  j = 0;
  }
  {
#line 2801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2801
    if (! (j < nr)) {
#line 2801
      goto while_break;
    }
    {
#line 2802
    fprintf(fp, "%s ", pfx);
#line 2803
    i = 0;
    }
    {
#line 2803
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2803
      if (! (i < nc)) {
#line 2803
        goto while_break___0;
      }
#line 2804
      if (i < nc - 1) {
#line 2804
        tmp = ", ";
      } else {
#line 2804
        tmp = "\220";
      }
      {
#line 2804
      fprintf(fp, "%d%s", (int )*(*(a + j) + i), tmp);
      }
#line 2803
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2805
    fprintf(fp, "\n");
    }
#line 2801
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2813 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_dvector(FILE *fp , char *id , char *pfx , double *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 2815
  fprintf(fp, "%s%s[%d]\n", pfx, id, nc);
#line 2816
  fprintf(fp, "%s ", pfx);
#line 2817
  i = 0;
  }
  {
#line 2817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2817
    if (! (i < nc)) {
#line 2817
      goto while_break;
    }
#line 2818
    if (i < nc - 1) {
#line 2818
      tmp = ", ";
    } else {
#line 2818
      tmp = "\220";
    }
    {
#line 2818
    fprintf(fp, "%f%s", *(a + i), tmp);
    }
#line 2817
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2819
  fprintf(fp, "\n");
  }
  return;
}
}
#line 2826 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_dvector_fmt(FILE *fp , char *id , char *pfx , double *a , int nc , char *fmt ) 
{ 
  int i ;
  int __cil_tmp8 ;

  {
  {
#line 2828
  fprintf(fp, "%s%s[%d]\n", pfx, id, nc);
#line 2829
  fprintf(fp, "%s ", pfx);
#line 2830
  i = 0;
  }
  {
#line 2830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2830
    if (! (i < nc)) {
#line 2830
      goto while_break;
    }
    {
#line 2831
    fprintf(fp, (char const   *)fmt, *(a + i));
    }
#line 2832
    if (i < nc - 1) {
      {
#line 2833
      fprintf(fp, "%s", ", ");
      }
    }
#line 2830
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2835
  fprintf(fp, "\n");
  }
  return;
}
}
#line 2842 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_fvector(FILE *fp , char *id , char *pfx , float *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 2844
  fprintf(fp, "%s%s[%d]\n", pfx, id, nc);
#line 2845
  fprintf(fp, "%s ", pfx);
#line 2846
  i = 0;
  }
  {
#line 2846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2846
    if (! (i < nc)) {
#line 2846
      goto while_break;
    }
#line 2847
    if (i < nc - 1) {
#line 2847
      tmp = ", ";
    } else {
#line 2847
      tmp = "\220";
    }
    {
#line 2847
    fprintf(fp, "%f%s", (double )*(a + i), tmp);
    }
#line 2846
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2848
  fprintf(fp, "\n");
  }
  return;
}
}
#line 2855 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_ivector(FILE *fp , char *id , char *pfx , int *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 2857
  fprintf(fp, "%s%s[%d]\n", pfx, id, nc);
#line 2858
  fprintf(fp, "%s ", pfx);
#line 2859
  i = 0;
  }
  {
#line 2859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2859
    if (! (i < nc)) {
#line 2859
      goto while_break;
    }
#line 2860
    if (i < nc - 1) {
#line 2860
      tmp = ", ";
    } else {
#line 2860
      tmp = "\220";
    }
    {
#line 2860
    fprintf(fp, "%d%s", *(a + i), tmp);
    }
#line 2859
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2861
  fprintf(fp, "\n");
  }
  return;
}
}
#line 2868 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void dump_svector(FILE *fp , char *id , char *pfx , short *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 2870
  fprintf(fp, "%s%s[%d]\n", pfx, id, nc);
#line 2871
  fprintf(fp, "%s ", pfx);
#line 2872
  i = 0;
  }
  {
#line 2872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2872
    if (! (i < nc)) {
#line 2872
      goto while_break;
    }
#line 2873
    if (i < nc - 1) {
#line 2873
      tmp = ", ";
    } else {
#line 2873
      tmp = "\220";
    }
    {
#line 2873
    fprintf(fp, "%d%s", (int )*(a + i), tmp);
    }
#line 2872
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2874
  fprintf(fp, "\n");
  }
  return;
}
}
#line 2882 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void acode_dmatrix(FILE *fp , char *id , char *pfx , double **a , int nr , int nc ,
                   int hb ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp11 ;
  char const   *tmp___0 ;
  int __cil_tmp13 ;

  {
  {
#line 2884
  fprintf(fp, "%sdouble %s[%d][%d] = {\n\230\001", pfx, id, nr, nc);
#line 2886
  j = 0;
  }
  {
#line 2886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2886
    if (! (j < nr)) {
#line 2886
      goto while_break;
    }
    {
#line 2887
    fprintf(fp, "%s\t{ ", pfx);
#line 2888
    i = 0;
    }
    {
#line 2888
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2888
      if (! (i < nc)) {
#line 2888
        goto while_break___0;
      }
#line 2889
      if (i < nc - 1) {
#line 2889
        tmp = ", ";
      } else {
#line 2889
        tmp = "\220";
      }
      {
#line 2889
      fprintf(fp, "%f%s", *(*(a + j) + i), tmp);
      }
#line 2890
      if (i % hb == hb - 1) {
        {
#line 2891
        fprintf(fp, "\n%s\t  ", pfx);
        }
      }
#line 2888
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2893
    if (j < nr - 1) {
#line 2893
      tmp___0 = ",";
    } else {
#line 2893
      tmp___0 = "\220";
    }
    {
#line 2893
    fprintf(fp, " }%s\n", tmp___0);
    }
#line 2886
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2895
  fprintf(fp, "%s};\n", pfx);
  }
  return;
}
}
#line 2903 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void acode_dvector(FILE *fp , char *id , char *pfx , double *v , int nc , int hb ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp9 ;

  {
  {
#line 2905
  fprintf(fp, "%sdouble %s[%d] = { ", pfx, id, nc);
#line 2907
  i = 0;
  }
  {
#line 2907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2907
    if (! (i < nc)) {
#line 2907
      goto while_break;
    }
#line 2908
    if (i < nc - 1) {
#line 2908
      tmp = ", ";
    } else {
#line 2908
      tmp = "\220";
    }
    {
#line 2908
    fprintf(fp, "%f%s", *(v + i), tmp);
    }
#line 2909
    if (i % hb == hb - 1) {
      {
#line 2910
      fprintf(fp, "\n%s\t  ", pfx);
      }
    }
#line 2907
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2912
  fprintf(fp, "%s};\n", pfx);
  }
  return;
}
}
#line 2921 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_dmatrix(a1log *log___0 , char *id , char *pfx , double **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2923
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2925
  j = 0;
  }
  {
#line 2925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2925
    if (! (j < nr)) {
#line 2925
      goto while_break;
    }
    {
#line 2926
    a1logd(g_log, 0, "%s ", pfx);
#line 2927
    i = 0;
    }
    {
#line 2927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2927
      if (! (i < nc)) {
#line 2927
        goto while_break___0;
      }
#line 2928
      if (i < nc - 1) {
#line 2928
        tmp = ", ";
      } else {
#line 2928
        tmp = "\220";
      }
      {
#line 2928
      a1logd(g_log, 0, "%f%s", *(*(a + j) + i), tmp);
      }
#line 2927
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2929
    a1logd(g_log, 0, "\n");
    }
#line 2925
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2937 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_dmatrix_fmt(a1log *log___0 , char *id , char *pfx , double **a , int nr ,
                       int nc , char *fmt ) 
{ 
  int i ;
  int j ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2939
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2941
  j = 0;
  }
  {
#line 2941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2941
    if (! (j < nr)) {
#line 2941
      goto while_break;
    }
    {
#line 2942
    a1logd(g_log, 0, "%s ", pfx);
#line 2943
    i = 0;
    }
    {
#line 2943
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2943
      if (! (i < nc)) {
#line 2943
        goto while_break___0;
      }
      {
#line 2944
      a1logd(g_log, 0, fmt, *(*(a + j) + i));
      }
#line 2945
      if (i < nc - 1) {
        {
#line 2946
        a1logd(g_log, 0, "%s", ", ");
        }
      }
#line 2943
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2948
    a1logd(g_log, 0, "\n");
    }
#line 2941
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2956 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_fmatrix(a1log *log___0 , char *id , char *pfx , float **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2958
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2960
  j = 0;
  }
  {
#line 2960
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2960
    if (! (j < nr)) {
#line 2960
      goto while_break;
    }
    {
#line 2961
    a1logd(g_log, 0, "%s ", pfx);
#line 2962
    i = 0;
    }
    {
#line 2962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2962
      if (! (i < nc)) {
#line 2962
        goto while_break___0;
      }
#line 2963
      if (i < nc - 1) {
#line 2963
        tmp = ", ";
      } else {
#line 2963
        tmp = "\220";
      }
      {
#line 2963
      a1logd(g_log, 0, "%f%s", (double )*(*(a + j) + i), tmp);
      }
#line 2962
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2964
    a1logd(g_log, 0, "\n");
    }
#line 2960
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2972 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_imatrix(a1log *log___0 , char *id , char *pfx , int **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2974
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2976
  j = 0;
  }
  {
#line 2976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2976
    if (! (j < nr)) {
#line 2976
      goto while_break;
    }
    {
#line 2977
    a1logd(g_log, 0, "%s ", pfx);
#line 2978
    i = 0;
    }
    {
#line 2978
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2978
      if (! (i < nc)) {
#line 2978
        goto while_break___0;
      }
#line 2979
      if (i < nc - 1) {
#line 2979
        tmp = ", ";
      } else {
#line 2979
        tmp = "\220";
      }
      {
#line 2979
      a1logd(g_log, 0, "%d%s", *(*(a + j) + i), tmp);
      }
#line 2978
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2980
    a1logd(g_log, 0, "\n");
    }
#line 2976
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2988 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_smatrix(a1log *log___0 , char *id , char *pfx , short **a , int nr , int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 2990
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 2992
  j = 0;
  }
  {
#line 2992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2992
    if (! (j < nr)) {
#line 2992
      goto while_break;
    }
    {
#line 2993
    a1logd(g_log, 0, "%s ", pfx);
#line 2994
    i = 0;
    }
    {
#line 2994
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2994
      if (! (i < nc)) {
#line 2994
        goto while_break___0;
      }
#line 2995
      if (i < nc - 1) {
#line 2995
        tmp = ", ";
      } else {
#line 2995
        tmp = "\220";
      }
      {
#line 2995
      a1logd(g_log, 0, "%d%s", (int )*(*(a + j) + i), tmp);
      }
#line 2994
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2996
    a1logd(g_log, 0, "\n");
    }
#line 2992
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3004 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_dvector(a1log *log___0 , char *id , char *pfx , double *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 3006
  a1logd(g_log, 0, "%s%s[%d]\n", pfx, id, nc);
#line 3007
  a1logd(g_log, 0, "%s ", pfx);
#line 3008
  i = 0;
  }
  {
#line 3008
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3008
    if (! (i < nc)) {
#line 3008
      goto while_break;
    }
#line 3009
    if (i < nc - 1) {
#line 3009
      tmp = ", ";
    } else {
#line 3009
      tmp = "\220";
    }
    {
#line 3009
    a1logd(g_log, 0, "%f%s", *(a + i), tmp);
    }
#line 3008
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3010
  a1logd(g_log, 0, "\n");
  }
  return;
}
}
#line 3017 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_dvector_fmt(a1log *log___0 , char *id , char *pfx , double *a , int nc ,
                       char *fmt ) 
{ 
  int i ;
  int __cil_tmp8 ;

  {
  {
#line 3019
  a1logd(g_log, 0, "%s%s[%d]\n", pfx, id, nc);
#line 3020
  a1logd(g_log, 0, "%s ", pfx);
#line 3021
  i = 0;
  }
  {
#line 3021
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3021
    if (! (i < nc)) {
#line 3021
      goto while_break;
    }
    {
#line 3022
    a1logd(g_log, 0, fmt, *(a + i));
    }
#line 3023
    if (i < nc - 1) {
      {
#line 3024
      a1logd(g_log, 0, "%s", ", ");
      }
    }
#line 3021
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3026
  a1logd(g_log, 0, "\n");
  }
  return;
}
}
#line 3033 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_fvector(a1log *log___0 , char *id , char *pfx , float *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 3035
  a1logd(g_log, 0, "%s%s[%d]\n", pfx, id, nc);
#line 3036
  a1logd(g_log, 0, "%s ", pfx);
#line 3037
  i = 0;
  }
  {
#line 3037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3037
    if (! (i < nc)) {
#line 3037
      goto while_break;
    }
#line 3038
    if (i < nc - 1) {
#line 3038
      tmp = ", ";
    } else {
#line 3038
      tmp = "\220";
    }
    {
#line 3038
    a1logd(g_log, 0, "%f%s", (double )*(a + i), tmp);
    }
#line 3037
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3039
  a1logd(g_log, 0, "\n");
  }
  return;
}
}
#line 3046 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_ivector(a1log *log___0 , char *id , char *pfx , int *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 3048
  a1logd(g_log, 0, "%s%s[%d]\n", pfx, id, nc);
#line 3049
  a1logd(g_log, 0, "%s ", pfx);
#line 3050
  i = 0;
  }
  {
#line 3050
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3050
    if (! (i < nc)) {
#line 3050
      goto while_break;
    }
#line 3051
    if (i < nc - 1) {
#line 3051
      tmp = ", ";
    } else {
#line 3051
      tmp = "\220";
    }
    {
#line 3051
    a1logd(g_log, 0, "%d%s", *(a + i), tmp);
    }
#line 3050
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3052
  a1logd(g_log, 0, "\n");
  }
  return;
}
}
#line 3059 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_svector(a1log *log___0 , char *id , char *pfx , short *a , int nc ) 
{ 
  int i ;
  char const   *tmp ;
  int __cil_tmp8 ;

  {
  {
#line 3061
  a1logd(g_log, 0, "%s%s[%d]\n", pfx, id, nc);
#line 3062
  a1logd(g_log, 0, "%s ", pfx);
#line 3063
  i = 0;
  }
  {
#line 3063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3063
    if (! (i < nc)) {
#line 3063
      goto while_break;
    }
#line 3064
    if (i < nc - 1) {
#line 3064
      tmp = ", ";
    } else {
#line 3064
      tmp = "\220";
    }
    {
#line 3064
    a1logd(g_log, 0, "%d%s", (int )*(a + i), tmp);
    }
#line 3063
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3065
  a1logd(g_log, 0, "\n");
  }
  return;
}
}
#line 3072 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void adump_C_dmatrix(a1log *log___0 , char *id , char *pfx , double *a , int nr ,
                     int nc ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 3074
  a1logd(g_log, 0, "%s%s[%d][%d]\n", pfx, id, nr, nc);
#line 3076
  j = 0;
  }
  {
#line 3076
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3076
    if (! (j < nr)) {
#line 3076
      goto while_break;
    }
    {
#line 3077
    a1logd(g_log, 0, "%s ", pfx);
#line 3078
    i = 0;
    }
    {
#line 3078
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3078
      if (! (i < nc)) {
#line 3078
        goto while_break___0;
      }
#line 3079
      if (i < nc - 1) {
#line 3079
        tmp = ", ";
      } else {
#line 3079
        tmp = "\220";
      }
      {
#line 3079
      a1logd(g_log, 0, "%f%s", *(a + i), tmp);
      }
#line 3078
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3080
    a1logd(g_log, 0, "\n");
    }
#line 3076
    a += nc;
#line 3076
    __cil_tmp11 = j;
#line 3076
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 3089 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double vect_ClipNmarg(int n , double *out , double *in ) 
{ 
  int j ;
  double tt ;
  double marg ;
  int __cil_tmp7 ;

  {
#line 3091
  marg = 0.;
#line 3092
  j = 0;
  {
#line 3092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3092
    if (! (j < n)) {
#line 3092
      goto while_break;
    }
#line 3093
    *(out + j) = *(in + j);
#line 3094
    if (*(out + j) < 0.) {
#line 3095
      tt = 0. - *(out + j);
#line 3096
      *(out + j) = 0.;
#line 3097
      if (tt > marg) {
#line 3098
        marg = tt;
      }
    } else
#line 3099
    if (*(out + j) > 1.) {
#line 3100
      tt = *(out + j) - 1.;
#line 3101
      *(out + j) = 1.;
#line 3102
      if (tt > marg) {
#line 3103
        marg = tt;
      }
    }
#line 3092
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3106
  return (marg);
}
}
#line 3123 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_MulByNxN(int n , double *out , double *mat , double *in ) 
{ 
  int i ;
  int j ;
  double _tt[20] ;
  double *tt ;
  double *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 3125
  tt = (double *)_tt;
#line 3127
  if (n > 20) {
    {
#line 3128
    tt = dvector(0, n - 1);
    }
  }
#line 3130
  i = 0;
  {
#line 3130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3130
    if (! (i < n)) {
#line 3130
      goto while_break;
    }
#line 3131
    *(tt + i) = 0.;
#line 3132
    j = 0;
    {
#line 3132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3132
      if (! (j < n)) {
#line 3132
        goto while_break___0;
      }
#line 3133
      *(tt + i) += *(mat + (i * n + j)) * *(in + j);
#line 3132
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3136
  i = 0;
  {
#line 3136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3136
    if (! (i < n)) {
#line 3136
      goto while_break___1;
    }
#line 3137
    *(out + i) = *(tt + i);
#line 3136
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3139
  if (n > 20) {
    {
#line 3140
    free_dvector(tt, 0, n - 1);
    }
  }
  return;
}
}
#line 3157 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_MulByMxN(int n , int m , double *out , double *mat , double *in ) 
{ 
  int i ;
  int j ;
  double _tt[20] ;
  double *tt ;
  double *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 3159
  tt = (double *)_tt;
#line 3161
  if (m > 20) {
    {
#line 3162
    tt = dvector(0, m - 1);
    }
  }
#line 3164
  i = 0;
  {
#line 3164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3164
    if (! (i < m)) {
#line 3164
      goto while_break;
    }
#line 3165
    *(tt + i) = 0.;
#line 3166
    j = 0;
    {
#line 3166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3166
      if (! (j < n)) {
#line 3166
        goto while_break___0;
      }
#line 3167
      *(tt + i) += *(mat + (i * n + j)) * *(in + j);
#line 3166
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3170
  i = 0;
  {
#line 3170
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3170
    if (! (i < m)) {
#line 3170
      goto while_break___1;
    }
#line 3171
    *(out + i) = *(tt + i);
#line 3170
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3173
  if (m > 20) {
    {
#line 3174
    free_dvector(tt, 0, m - 1);
    }
  }
  return;
}
}
#line 3190 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void vect_MulByNxM(int n , int m , double *out , double *mat , double *in ) 
{ 
  int i ;
  int j ;
  double _tt[20] ;
  double *tt ;
  double *__cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 3192
  tt = (double *)_tt;
#line 3194
  if (m > 20) {
    {
#line 3195
    tt = dvector(0, m - 1);
    }
  }
#line 3197
  i = 0;
  {
#line 3197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3197
    if (! (i < m)) {
#line 3197
      goto while_break;
    }
#line 3198
    *(tt + i) = 0.;
#line 3199
    j = 0;
    {
#line 3199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3199
      if (! (j < n)) {
#line 3199
        goto while_break___0;
      }
#line 3200
      *(tt + i) += *(mat + (j * m + i)) * *(in + j);
#line 3199
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3203
  i = 0;
  {
#line 3203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3203
    if (! (i < m)) {
#line 3203
      goto while_break___1;
    }
#line 3204
    *(out + i) = *(tt + i);
#line 3203
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3206
  if (m > 20) {
    {
#line 3207
    free_dvector(tt, 0, m - 1);
    }
  }
  return;
}
}
#line 3212 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void matrix_TransposeNxN(int n , double *out , double *in ) 
{ 
  int i ;
  int j ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  double tt ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 3215
  if (in != out) {
#line 3216
    i = 0;
    {
#line 3216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3216
      if (! (i < n)) {
#line 3216
        goto while_break;
      }
#line 3217
      j = 0;
      {
#line 3217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3217
        if (! (j < n)) {
#line 3217
          goto while_break___0;
        }
#line 3218
        *(out + (i * n + j)) = *(in + (j * n + i));
#line 3217
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3216
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 3220
    i = 0;
    {
#line 3220
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3220
      if (! (i < n)) {
#line 3220
        goto while_break___1;
      }
#line 3221
      j = i + 1;
      {
#line 3221
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3221
        if (! (j < n)) {
#line 3221
          goto while_break___2;
        }
#line 3223
        tt = *(out + (i * n + j));
#line 3224
        *(out + (i * n + j)) = *(out + (j * n + i));
#line 3225
        *(out + (j * n + i)) = tt;
#line 3221
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3220
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 3239 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
uint32_t doubletoIEEE754(double d ) 
{ 
  uint32_t sn ;
  uint32_t ep ;
  uint32_t ma ;
  uint32_t id ;
  int ee ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 3240
  sn = (uint32_t )0;
#line 3240
  ep = (uint32_t )0;
#line 3247
  if (d < 0.) {
#line 3248
    sn = (uint32_t )1;
#line 3249
    d = - d;
  }
#line 3251
  if (d != 0.) {
    {
#line 3253
    __cil_tmp8 = log(2.);
    }
    {
#line 3253
    __cil_tmp7 = log(d);
#line 3253
    __cil_tmp9 = floor(__cil_tmp7 / __cil_tmp8);
#line 3253
    ee = (int )__cil_tmp9;
    }
#line 3254
    if (ee < -126) {
#line 3255
      ee = - 126;
    }
    {
#line 3256
    __cil_tmp10 = pow(0.5, (double )(ee - 23));
    }
#line 3256
    d *= __cil_tmp10;
#line 3257
    ee += 127;
#line 3258
    if (ee < 1) {
#line 3259
      ee = 0;
    } else
#line 3260
    if (ee > 254) {
#line 3261
      ee = 255;
#line 3262
      d = 0.;
    }
#line 3264
    ep = (uint32_t )ee;
  } else {
#line 3266
    ep = (uint32_t )0;
  }
#line 3268
  ma = (uint32_t )d & (unsigned int )((1 << 23) - 1);
#line 3269
  id = ((sn << 31) | (ep << 23)) | ma;
#line 3271
  return (id);
}
}
#line 3278 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double IEEE754todouble(uint32_t ip ) 
{ 
  double op ;
  uint32_t sn ;
  uint32_t ep ;
  uint32_t ma ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
#line 3280
  sn = (uint32_t )0;
#line 3280
  ep = (uint32_t )0;
#line 3282
  sn = (ip >> 31) & 1U;
#line 3283
  ep = (ip >> 23) & 255U;
#line 3284
  ma = ip & 8388607U;
#line 3286
  if (ep == 0U) {
    {
#line 3287
    op = (double )ma / (double )(1 << 23);
#line 3288
    __cil_tmp6 = pow(2., - 126.);
    }
#line 3288
    op *= __cil_tmp6;
  } else {
    {
#line 3290
    op = (double )(ma | (unsigned int )(1 << 23)) / (double )(1 << 23);
#line 3291
    __cil_tmp7 = pow(2., (double )((int )ep) - 127.);
    }
#line 3291
    op *= __cil_tmp7;
  }
#line 3293
  if (sn) {
#line 3294
    op = - op;
  }
#line 3295
  return (op);
}
}
#line 3303 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
uint64_t doubletoIEEE754_64(double d ) 
{ 
  uint32_t sn ;
  uint32_t ep ;
  uint64_t ma ;
  uint64_t id ;
  int ee ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
#line 3304
  sn = (uint32_t )0;
#line 3304
  ep = (uint32_t )0;
#line 3311
  if (d < 0.) {
#line 3312
    sn = (uint32_t )1;
#line 3313
    d = - d;
  }
#line 3315
  if (d != 0.) {
    {
#line 3317
    __cil_tmp8 = log(2.);
    }
    {
#line 3317
    __cil_tmp7 = log(d);
#line 3317
    __cil_tmp9 = floor(__cil_tmp7 / __cil_tmp8);
#line 3317
    ee = (int )__cil_tmp9;
    }
#line 3318
    if (ee < -1022) {
#line 3319
      ee = - 1022;
    }
    {
#line 3320
    __cil_tmp10 = pow(0.5, (double )(ee - 52));
    }
#line 3320
    d *= __cil_tmp10;
#line 3321
    ee += 1023;
#line 3322
    if (ee < 1) {
#line 3323
      ee = 0;
    } else
#line 3324
    if (ee > 2046) {
#line 3325
      ee = 2047;
#line 3326
      d = 0.;
    }
#line 3328
    ep = (uint32_t )ee;
  } else {
#line 3330
    ep = (uint32_t )0;
  }
#line 3332
  ma = (uint64_t )d & ((1UL << 52) - 1UL);
#line 3333
  id = (((uint64_t )sn << 63) | ((uint64_t )ep << 52)) | ma;
#line 3335
  return (id);
}
}
#line 3342 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double IEEE754_64todouble(uint64_t ip ) 
{ 
  double op ;
  uint32_t sn ;
  uint32_t ep ;
  int64_t ma ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
#line 3344
  sn = (uint32_t )0;
#line 3344
  ep = (uint32_t )0;
#line 3347
  sn = (uint32_t )((ip >> 63) & 1UL);
#line 3348
  ep = (uint32_t )((ip >> 52) & 2047UL);
#line 3349
  ma = (int64_t )(ip & (unsigned long )((1L << 52) - 1L));
#line 3351
  if (ep == 0U) {
    {
#line 3352
    op = (double )ma / (double )(1L << 52);
#line 3353
    __cil_tmp6 = pow(2., - 1022.);
    }
#line 3353
    op *= __cil_tmp6;
  } else {
    {
#line 3355
    op = (double )(ma | (1L << 52)) / (double )(1L << 52);
#line 3356
    __cil_tmp7 = pow(2., (double )((int )ep) - 1023.);
    }
#line 3356
    op *= __cil_tmp7;
  }
#line 3358
  if (sn) {
#line 3359
    op = - op;
  }
#line 3360
  return (op);
}
}
#line 3365 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *ctime_32(int32_t *timer ) 
{ 
  char *rv ;
  time_t timerv ;
  char *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 3370
  timerv = (time_t )*timer;
#line 3371
  rv = ctime(& timerv);
  }
#line 3374
  if (rv != (void *)0) {
    {
#line 3375
    __cil_tmp5 = strlen((char const   *)rv);
#line 3375
    *(rv + (__cil_tmp5 - 1UL)) = (char )'\000';
    }
  }
#line 3377
  return (rv);
}
}
#line 3382 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *ctime_64(int64_t *timer ) 
{ 
  char *rv ;
  time_t timerv ;
  char *__cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 3389
  if (sizeof(time_t ) == 4UL) {
#line 3389
    if (*timer > 2147483647L) {
#line 3390
      return ((char *)((void *)0));
    }
  }
  {
#line 3391
  timerv = (time_t )*timer;
#line 3392
  rv = ctime(& timerv);
  }
#line 3395
  if (rv != (void *)0) {
    {
#line 3396
    __cil_tmp5 = strlen((char const   *)rv);
#line 3396
    *(rv + (__cil_tmp5 - 1UL)) = (char )'\000';
    }
  }
#line 3398
  return (rv);
}
}
#line 3414 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int read_ORD8(uint8_t *p ) 
{ 
  unsigned int rv ;

  {
#line 3416
  rv = (unsigned int )*(p + 0);
#line 3417
  return (rv);
}
}
#line 3420 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD8(uint8_t *p , unsigned int d ) 
{ 


  {
#line 3421
  if (d > 255U) {
#line 3422
    d = (unsigned int )255;
  }
#line 3423
  *(p + 0) = (uint8_t )d;
  return;
}
}
#line 3429 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int read_INR8(uint8_t *p ) 
{ 
  int rv ;

  {
#line 3431
  rv = (int )((int8_t )*(p + 0));
#line 3432
  return (rv);
}
}
#line 3435 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR8(uint8_t *p , int d ) 
{ 


  {
#line 3436
  if (d > 127) {
#line 3437
    d = 127;
  } else
#line 3438
  if (d < -128) {
#line 3439
    d = - 128;
  }
#line 3440
  *(p + 0) = (uint8_t )d;
  return;
}
}
#line 3446 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int read_ORD16_be(uint8_t *p ) 
{ 
  unsigned int rv ;

  {
#line 3448
  rv = ((unsigned int )*(p + 0) << 8) + (unsigned int )*(p + 1);
#line 3450
  return (rv);
}
}
#line 3453 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int read_ORD16_le(uint8_t *p ) 
{ 
  unsigned int rv ;

  {
#line 3455
  rv = (unsigned int )*(p + 0) + ((unsigned int )*(p + 1) << 8);
#line 3457
  return (rv);
}
}
#line 3460 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD16_be(uint8_t *p , unsigned int d ) 
{ 


  {
#line 3461
  if (d > 65535U) {
#line 3462
    d = (unsigned int )65535;
  }
#line 3463
  *(p + 0) = (uint8_t )(d >> 8);
#line 3464
  *(p + 1) = (uint8_t )d;
  return;
}
}
#line 3467 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD16_le(uint8_t *p , unsigned int d ) 
{ 


  {
#line 3468
  if (d > 65535U) {
#line 3469
    d = (unsigned int )65535;
  }
#line 3470
  *(p + 0) = (uint8_t )d;
#line 3471
  *(p + 1) = (uint8_t )(d >> 8);
  return;
}
}
#line 3477 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int read_INR16_be(uint8_t *p ) 
{ 
  int rv ;

  {
#line 3479
  rv = ((int )((int8_t )*(p + 0)) << 8) + (int )*(p + 1);
#line 3481
  return (rv);
}
}
#line 3484 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int read_INR16_le(uint8_t *p ) 
{ 
  int rv ;

  {
#line 3486
  rv = (int )*(p + 0) + ((int )((int8_t )*(p + 1)) << 8);
#line 3488
  return (rv);
}
}
#line 3491 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR16_be(uint8_t *p , int d ) 
{ 


  {
#line 3492
  if (d > 32767) {
#line 3493
    d = 32767;
  } else
#line 3494
  if (d < -32768) {
#line 3495
    d = - 32768;
  }
#line 3496
  *(p + 0) = (uint8_t )(d >> 8);
#line 3497
  *(p + 1) = (uint8_t )d;
  return;
}
}
#line 3500 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR16_le(uint8_t *p , int d ) 
{ 


  {
#line 3501
  if (d > 32767) {
#line 3502
    d = 32767;
  } else
#line 3503
  if (d < -32768) {
#line 3504
    d = - 32768;
  }
#line 3505
  *(p + 0) = (uint8_t )d;
#line 3506
  *(p + 1) = (uint8_t )(d >> 8);
  return;
}
}
#line 3512 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int read_ORD32_be(uint8_t *p ) 
{ 
  unsigned int rv ;

  {
#line 3514
  rv = ((((unsigned int )*(p + 0) << 24) + ((unsigned int )*(p + 1) << 16)) + ((unsigned int )*(p + 2) << 8)) + (unsigned int )*(p + 3);
#line 3518
  return (rv);
}
}
#line 3521 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int read_ORD32_le(uint8_t *p ) 
{ 
  unsigned int rv ;

  {
#line 3523
  rv = (((unsigned int )*(p + 0) + ((unsigned int )*(p + 1) << 8)) + ((unsigned int )*(p + 2) << 16)) + ((unsigned int )*(p + 3) << 24);
#line 3527
  return (rv);
}
}
#line 3530 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD32_be(uint8_t *p , unsigned int d ) 
{ 


  {
#line 3531
  *(p + 0) = (uint8_t )(d >> 24);
#line 3532
  *(p + 1) = (uint8_t )(d >> 16);
#line 3533
  *(p + 2) = (uint8_t )(d >> 8);
#line 3534
  *(p + 3) = (uint8_t )d;
  return;
}
}
#line 3537 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD32_le(uint8_t *p , unsigned int d ) 
{ 


  {
#line 3538
  *(p + 0) = (uint8_t )d;
#line 3539
  *(p + 1) = (uint8_t )(d >> 8);
#line 3540
  *(p + 2) = (uint8_t )(d >> 16);
#line 3541
  *(p + 3) = (uint8_t )(d >> 24);
  return;
}
}
#line 3547 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int read_INR32_be(uint8_t *p ) 
{ 
  int rv ;

  {
#line 3549
  rv = ((((int )((int8_t )*(p + 0)) << 24) + ((int )*(p + 1) << 16)) + ((int )*(p + 2) << 8)) + (int )*(p + 3);
#line 3553
  return (rv);
}
}
#line 3556 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int read_INR32_le(uint8_t *p ) 
{ 
  int rv ;

  {
#line 3558
  rv = (((int )*(p + 0) + ((int )*(p + 1) << 8)) + ((int )*(p + 2) << 16)) + ((int )((int8_t )*(p + 3)) << 24);
#line 3562
  return (rv);
}
}
#line 3565 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR32_be(uint8_t *p , int d ) 
{ 


  {
#line 3566
  *(p + 0) = (uint8_t )(d >> 24);
#line 3567
  *(p + 1) = (uint8_t )(d >> 16);
#line 3568
  *(p + 2) = (uint8_t )(d >> 8);
#line 3569
  *(p + 3) = (uint8_t )d;
  return;
}
}
#line 3572 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR32_le(uint8_t *p , int d ) 
{ 


  {
#line 3573
  *(p + 0) = (uint8_t )d;
#line 3574
  *(p + 1) = (uint8_t )(d >> 8);
#line 3575
  *(p + 2) = (uint8_t )(d >> 16);
#line 3576
  *(p + 3) = (uint8_t )(d >> 24);
  return;
}
}
#line 3582 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
uint64_t read_ORD64_be(uint8_t *p ) 
{ 
  uint64_t rv ;

  {
#line 3584
  rv = ((((((((uint64_t )*(p + 0) << 56) + ((uint64_t )*(p + 1) << 48)) + ((uint64_t )*(p + 2) << 40)) + ((uint64_t )*(p + 3) << 32)) + ((uint64_t )*(p + 4) << 24)) + ((uint64_t )*(p + 5) << 16)) + ((uint64_t )*(p + 6) << 8)) + (uint64_t )*(p + 7);
#line 3592
  return (rv);
}
}
#line 3595 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
uint64_t read_ORD64_le(uint8_t *p ) 
{ 
  uint64_t rv ;

  {
#line 3597
  rv = (((((((uint64_t )*(p + 0) + ((uint64_t )*(p + 1) << 8)) + ((uint64_t )*(p + 2) << 16)) + ((uint64_t )*(p + 3) << 24)) + ((uint64_t )*(p + 4) << 32)) + ((uint64_t )*(p + 5) << 40)) + ((uint64_t )*(p + 6) << 48)) + ((uint64_t )*(p + 7) << 56);
#line 3605
  return (rv);
}
}
#line 3608 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD64_be(uint8_t *p , uint64_t d ) 
{ 


  {
#line 3609
  *(p + 0) = (uint8_t )(d >> 56);
#line 3610
  *(p + 1) = (uint8_t )(d >> 48);
#line 3611
  *(p + 2) = (uint8_t )(d >> 40);
#line 3612
  *(p + 3) = (uint8_t )(d >> 32);
#line 3613
  *(p + 4) = (uint8_t )(d >> 24);
#line 3614
  *(p + 5) = (uint8_t )(d >> 16);
#line 3615
  *(p + 6) = (uint8_t )(d >> 8);
#line 3616
  *(p + 7) = (uint8_t )d;
  return;
}
}
#line 3619 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_ORD64_le(uint8_t *p , uint64_t d ) 
{ 


  {
#line 3620
  *(p + 0) = (uint8_t )d;
#line 3621
  *(p + 1) = (uint8_t )(d >> 8);
#line 3622
  *(p + 2) = (uint8_t )(d >> 16);
#line 3623
  *(p + 3) = (uint8_t )(d >> 24);
#line 3624
  *(p + 4) = (uint8_t )(d >> 32);
#line 3625
  *(p + 5) = (uint8_t )(d >> 40);
#line 3626
  *(p + 6) = (uint8_t )(d >> 48);
#line 3627
  *(p + 7) = (uint8_t )(d >> 56);
  return;
}
}
#line 3633 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int64_t read_INR64_be(uint8_t *p ) 
{ 
  int64_t rv ;

  {
#line 3635
  rv = ((((((((int64_t )((int8_t )*(p + 0)) << 56) + ((int64_t )*(p + 1) << 48)) + ((int64_t )*(p + 2) << 40)) + ((int64_t )*(p + 3) << 32)) + ((int64_t )*(p + 4) << 24)) + ((int64_t )*(p + 5) << 16)) + ((int64_t )*(p + 6) << 8)) + (int64_t )*(p + 7);
#line 3643
  return (rv);
}
}
#line 3646 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
int64_t read_INR64_le(uint8_t *p ) 
{ 
  int64_t rv ;

  {
#line 3648
  rv = (((((((int64_t )*(p + 0) + ((int64_t )*(p + 1) << 8)) + ((int64_t )*(p + 2) << 16)) + ((int64_t )*(p + 3) << 24)) + ((int64_t )*(p + 4) << 32)) + ((int64_t )*(p + 5) << 40)) + ((int64_t )*(p + 6) << 48)) + ((int64_t )((int8_t )*(p + 7)) << 56);
#line 3656
  return (rv);
}
}
#line 3659 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR64_be(uint8_t *p , int64_t d ) 
{ 


  {
#line 3660
  *(p + 0) = (uint8_t )(d >> 56);
#line 3661
  *(p + 1) = (uint8_t )(d >> 48);
#line 3662
  *(p + 2) = (uint8_t )(d >> 40);
#line 3663
  *(p + 3) = (uint8_t )(d >> 32);
#line 3664
  *(p + 4) = (uint8_t )(d >> 24);
#line 3665
  *(p + 5) = (uint8_t )(d >> 16);
#line 3666
  *(p + 6) = (uint8_t )(d >> 8);
#line 3667
  *(p + 7) = (uint8_t )d;
  return;
}
}
#line 3670 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_INR64_le(uint8_t *p , int64_t d ) 
{ 


  {
#line 3671
  *(p + 0) = (uint8_t )d;
#line 3672
  *(p + 1) = (uint8_t )(d >> 8);
#line 3673
  *(p + 2) = (uint8_t )(d >> 16);
#line 3674
  *(p + 3) = (uint8_t )(d >> 24);
#line 3675
  *(p + 4) = (uint8_t )(d >> 32);
#line 3676
  *(p + 5) = (uint8_t )(d >> 40);
#line 3677
  *(p + 6) = (uint8_t )(d >> 48);
#line 3678
  *(p + 7) = (uint8_t )(d >> 56);
  return;
}
}
#line 3696 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double read_FLT32_be(uint8_t *p ) 
{ 
  uint32_t val ;
  double __cil_tmp3 ;

  {
  {
#line 3698
  val = ((((uint32_t )*(p + 0) << 24) + ((uint32_t )*(p + 1) << 16)) + ((uint32_t )*(p + 2) << 8)) + (uint32_t )*(p + 3);
#line 3702
  __cil_tmp3 = IEEE754todouble(val);
  }
#line 3702
  return (__cil_tmp3);
}
}
#line 3705 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double read_FLT32_le(uint8_t *p ) 
{ 
  uint32_t val ;
  double __cil_tmp3 ;

  {
  {
#line 3707
  val = (((uint32_t )*(p + 0) + ((uint32_t )*(p + 1) << 8)) + ((uint32_t )*(p + 2) << 16)) + ((uint32_t )*(p + 3) << 24);
#line 3711
  __cil_tmp3 = IEEE754todouble(val);
  }
#line 3711
  return (__cil_tmp3);
}
}
#line 3714 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_FLT32_be(uint8_t *p , double d ) 
{ 
  uint32_t val ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 3715
  __cil_tmp4 = doubletoIEEE754(d);
#line 3715
  val = __cil_tmp4;
#line 3716
  *(p + 0) = (uint8_t )(val >> 24);
#line 3717
  *(p + 1) = (uint8_t )(val >> 16);
#line 3718
  *(p + 2) = (uint8_t )(val >> 8);
#line 3719
  *(p + 3) = (uint8_t )val;
  }
  return;
}
}
#line 3722 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_FLT32_le(uint8_t *p , double d ) 
{ 
  uint32_t val ;
  uint32_t __cil_tmp4 ;

  {
  {
#line 3723
  __cil_tmp4 = doubletoIEEE754(d);
#line 3723
  val = __cil_tmp4;
#line 3724
  *(p + 0) = (uint8_t )val;
#line 3725
  *(p + 1) = (uint8_t )(val >> 8);
#line 3726
  *(p + 2) = (uint8_t )(val >> 16);
#line 3727
  *(p + 3) = (uint8_t )(val >> 24);
  }
  return;
}
}
#line 3733 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double read_FLT64_be(uint8_t *p ) 
{ 
  uint64_t val ;
  double __cil_tmp3 ;

  {
  {
#line 3735
  val = ((((((((uint64_t )*(p + 0) << 56) + ((uint64_t )*(p + 1) << 48)) + ((uint64_t )*(p + 2) << 40)) + ((uint64_t )*(p + 3) << 32)) + ((uint64_t )*(p + 4) << 24)) + ((uint64_t )*(p + 5) << 16)) + ((uint64_t )*(p + 6) << 8)) + (uint64_t )*(p + 7);
#line 3743
  __cil_tmp3 = IEEE754_64todouble(val);
  }
#line 3743
  return (__cil_tmp3);
}
}
#line 3746 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double read_FLT64_le(uint8_t *p ) 
{ 
  uint64_t val ;
  double __cil_tmp3 ;

  {
  {
#line 3748
  val = (((((((uint64_t )*(p + 0) + ((uint64_t )*(p + 1) << 8)) + ((uint64_t )*(p + 2) << 16)) + ((uint64_t )*(p + 3) << 24)) + ((uint64_t )*(p + 4) << 32)) + ((uint64_t )*(p + 5) << 40)) + ((uint64_t )*(p + 6) << 48)) + ((uint64_t )*(p + 7) << 56);
#line 3756
  __cil_tmp3 = IEEE754_64todouble(val);
  }
#line 3756
  return (__cil_tmp3);
}
}
#line 3759 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_FLT64_be(uint8_t *p , double d ) 
{ 
  uint64_t val ;
  uint64_t __cil_tmp4 ;

  {
  {
#line 3760
  __cil_tmp4 = doubletoIEEE754_64(d);
#line 3760
  val = __cil_tmp4;
#line 3761
  *(p + 0) = (uint8_t )(val >> 56);
#line 3762
  *(p + 1) = (uint8_t )(val >> 48);
#line 3763
  *(p + 2) = (uint8_t )(val >> 40);
#line 3764
  *(p + 3) = (uint8_t )(val >> 32);
#line 3765
  *(p + 4) = (uint8_t )(val >> 24);
#line 3766
  *(p + 5) = (uint8_t )(val >> 16);
#line 3767
  *(p + 6) = (uint8_t )(val >> 8);
#line 3768
  *(p + 7) = (uint8_t )val;
  }
  return;
}
}
#line 3771 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void write_FLT64_le(uint8_t *p , double d ) 
{ 
  uint64_t val ;
  uint64_t __cil_tmp4 ;

  {
  {
#line 3772
  __cil_tmp4 = doubletoIEEE754_64(d);
#line 3772
  val = __cil_tmp4;
#line 3773
  *(p + 0) = (uint8_t )val;
#line 3774
  *(p + 1) = (uint8_t )(val >> 8);
#line 3775
  *(p + 2) = (uint8_t )(val >> 16);
#line 3776
  *(p + 3) = (uint8_t )(val >> 24);
#line 3777
  *(p + 4) = (uint8_t )(val >> 32);
#line 3778
  *(p + 5) = (uint8_t )(val >> 40);
#line 3779
  *(p + 6) = (uint8_t )(val >> 48);
#line 3780
  *(p + 7) = (uint8_t )(val >> 56);
  }
  return;
}
}
#line 3841 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
void msec_sleep(unsigned int msec ) 
{ 
  struct timespec ts ;

  {
  {
#line 3853
  ts.tv_sec = (__time_t )(msec / 1000U);
#line 3854
  ts.tv_nsec = (__syscall_slong_t )((msec % 1000U) * 1000000U);
#line 3855
  nanosleep(& ts, (struct timespec *)((void *)0));
  }
  return;
}
}
#line 3906 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
unsigned int msec_time(void) 
{ 
  unsigned int rv ;
  static struct timespec startup ;
  struct timespec cv ;
  __time_t __cil_tmp4 ;

  {
#line 3908
  startup.tv_sec = (__time_t )0;
  {
#line 3908
  startup.tv_nsec = (__syscall_slong_t )0;
#line 3911
  clock_gettime(1, & cv);
  }
#line 3914
  if (startup.tv_sec == 0L) {
#line 3914
    if (startup.tv_nsec == 0L) {
#line 3915
      startup = cv;
    }
  }
#line 3918
  cv.tv_sec -= startup.tv_sec;
#line 3919
  if (startup.tv_nsec > cv.tv_nsec) {
#line 3920
    __cil_tmp4 = cv.tv_sec;
#line 3920
    (cv.tv_sec) --;
#line 3921
    cv.tv_nsec += (long )1000000000;
  }
#line 3923
  cv.tv_nsec -= startup.tv_nsec;
#line 3926
  rv = (unsigned int )(cv.tv_sec * 1000L + cv.tv_nsec / 1000000L);
#line 3928
  return (rv);
}
}
#line 3933 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double usec_time(void) 
{ 
  double rv ;
  static struct timespec startup ;
  struct timespec cv ;
  __time_t __cil_tmp4 ;

  {
#line 3935
  startup.tv_sec = (__time_t )0;
  {
#line 3935
  startup.tv_nsec = (__syscall_slong_t )0;
#line 3938
  clock_gettime(1, & cv);
  }
#line 3941
  if (startup.tv_sec == 0L) {
#line 3941
    if (startup.tv_nsec == 0L) {
#line 3942
      startup = cv;
    }
  }
#line 3945
  cv.tv_sec -= startup.tv_sec;
#line 3946
  if (startup.tv_nsec > cv.tv_nsec) {
#line 3947
    __cil_tmp4 = cv.tv_sec;
#line 3947
    (cv.tv_sec) --;
#line 3948
    cv.tv_nsec += (long )1000000000;
  }
#line 3950
  cv.tv_nsec -= startup.tv_nsec;
#line 3953
  rv = (double )cv.tv_sec * 1000000. + (double )(cv.tv_nsec / 1000L);
#line 3955
  return (rv);
}
}
#line 3974 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *debPiv(int di , int *p ) 
{ 
  static char buf[10][384] ;
  static int ix ;
  int e ;
  char *bp ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 3976
  ix = 0;
#line 3980
  if (p == (void *)0) {
#line 3981
    return ("(null)");
  }
#line 3983
  ix ++;
#line 3983
  if (ix >= 10) {
#line 3984
    ix = 0;
  }
#line 3985
  bp = (char *)buf[ix];
#line 3987
  if (di > 24) {
#line 3988
    di = 24;
  }
#line 3990
  e = 0;
  {
#line 3990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3990
    if (! (e < di)) {
#line 3990
      goto while_break;
    }
#line 3991
    if (e > 0) {
#line 3992
      __cil_tmp7 = bp;
#line 3992
      bp ++;
#line 3992
      *__cil_tmp7 = (char )' ';
    }
    {
#line 3993
    sprintf(bp, "%d", *(p + e));
#line 3993
    __cil_tmp8 = strlen((char const   *)bp);
    }
#line 3993
    bp += __cil_tmp8;
#line 3990
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3995
  return ((char *)buf[ix]);
}
}
#line 4000 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *debPdvf(int di , char *fmt , double *p ) 
{ 
  static char buf[10][1200] ;
  static int ix ;
  int e ;
  char *bp ;
  char *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 4002
  ix = 0;
#line 4006
  if (p == (void *)0) {
#line 4007
    return ("(null)");
  }
#line 4009
  if (fmt == (void *)0) {
#line 4010
    fmt = "%.8f";
  }
#line 4012
  ix ++;
#line 4012
  if (ix >= 10) {
#line 4013
    ix = 0;
  }
#line 4014
  bp = (char *)buf[ix];
#line 4016
  if (di > 24) {
#line 4017
    di = 24;
  }
#line 4019
  e = 0;
  {
#line 4019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4019
    if (! (e < di)) {
#line 4019
      goto while_break;
    }
#line 4020
    if (e > 0) {
#line 4021
      __cil_tmp8 = bp;
#line 4021
      bp ++;
#line 4021
      *__cil_tmp8 = (char )' ';
    }
    {
#line 4022
    sprintf(bp, (char const   *)fmt, *(p + e));
#line 4022
    __cil_tmp9 = strlen((char const   *)bp);
    }
#line 4022
    bp += __cil_tmp9;
#line 4019
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4024
  return ((char *)buf[ix]);
}
}
#line 4029 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *debPdv(int di , double *p ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 4030
  __cil_tmp3 = debPdvf(di, (char *)((void *)0), p);
  }
#line 4030
  return (__cil_tmp3);
}
}
#line 4035 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
char *debPfv(int di , float *p ) 
{ 
  static char buf[10][1200] ;
  static int ix ;
  int e ;
  char *bp ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 4037
  ix = 0;
#line 4041
  if (p == (void *)0) {
#line 4042
    return ("(null)");
  }
#line 4044
  ix ++;
#line 4044
  if (ix >= 10) {
#line 4045
    ix = 0;
  }
#line 4046
  bp = (char *)buf[ix];
#line 4048
  if (di > 24) {
#line 4049
    di = 24;
  }
#line 4051
  e = 0;
  {
#line 4051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4051
    if (! (e < di)) {
#line 4051
      goto while_break;
    }
#line 4052
    if (e > 0) {
#line 4053
      __cil_tmp7 = bp;
#line 4053
      bp ++;
#line 4053
      *__cil_tmp7 = (char )' ';
    }
    {
#line 4054
    sprintf(bp, "%.8f\313U", (double )*(p + e));
#line 4054
    __cil_tmp8 = strlen((char const   *)bp);
    }
#line 4054
    bp += __cil_tmp8;
#line 4051
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4056
  return ((char *)buf[ix]);
}
}
#line 4062 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/numsup.c"
double gamma_func(double x ) 
{ 
  static double cvals[12] ;
  double rv ;
  int i ;
  int __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;

  {
#line 4063
  cvals[0] = 2.50662827464;
#line 4063
  cvals[1] = 198580.062714;
#line 4063
  cvals[2] = - 696538.007154;
#line 4063
  cvals[3] = 984524.697201;
#line 4063
  cvals[4] = - 719481.380547;
#line 4063
  cvals[5] = 290262.75411;
#line 4063
  cvals[6] = - 64035.016016;
#line 4063
  cvals[7] = 7201.86442077;
#line 4063
  cvals[8] = - 354.974638946;
#line 4063
  cvals[9] = 5.66100563768;
#line 4063
  cvals[10] = - 0.0147438495214;
#line 4063
  cvals[11] = 7.49085600877e-07;
#line 4070
  rv = cvals[0];
#line 4071
  i = 1;
  {
#line 4071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4071
    if (! (i < 12)) {
#line 4071
      goto while_break;
    }
#line 4072
    rv += cvals[i] / (x + (double )i);
#line 4071
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4073
  __cil_tmp7 = pow(x + (double )12, x + 0.5);
  }
  {
#line 4073
  __cil_tmp6 = exp(- (x + (double )12));
  }
#line 4073
  rv *= __cil_tmp6 * __cil_tmp7;
#line 4075
  return (rv / x);
}
}
#line 27 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int solve_se(double **a , double *b , int n ) 
{ 
  double rip ;
  int *pivx ;
  int PIVX[10] ;
  int *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 40
  if (n <= 10) {
#line 41
    pivx = (int *)PIVX;
  } else {
    {
#line 43
    pivx = ivector(0, n - 1);
    }
  }
  {
#line 57
  __cil_tmp8 = lu_decomp(a, n, pivx, & rip);
  }
#line 57
  if (__cil_tmp8) {
#line 62
    if (pivx != (int *)PIVX) {
      {
#line 63
      free_ivector(pivx, 0, n - 1);
      }
    }
#line 64
    return (1);
  }
  {
#line 67
  lu_backsub(a, n, pivx, b);
  }
#line 94
  if (pivx != (int *)PIVX) {
    {
#line 95
    free_ivector(pivx, 0, n - 1);
    }
  }
#line 96
  return (0);
}
}
#line 102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int polished_solve_se(double **a , double *b , int n ) 
{ 
  double rip ;
  int *pivx ;
  int PIVX[10] ;
  double **sa ;
  double *sb ;
  int i ;
  int j ;
  int *__cil_tmp11 ;
  double **__cil_tmp12 ;
  double *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 113
  if (n <= 10) {
#line 114
    pivx = (int *)PIVX;
  } else {
    {
#line 116
    pivx = ivector(0, n - 1);
    }
  }
  {
#line 118
  sa = dmatrix(0, n - 1, 0, n - 1);
#line 119
  sb = dvector(0, n - 1);
#line 122
  i = 0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < n)) {
#line 122
      goto while_break;
    }
#line 123
    *(sb + i) = *(b + i);
#line 124
    j = 0;
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! (j < n)) {
#line 124
        goto while_break___0;
      }
#line 125
      *(*(sa + i) + j) = *(*(a + i) + j);
#line 124
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  __cil_tmp16 = lu_decomp(a, n, pivx, & rip);
  }
#line 128
  if (__cil_tmp16) {
    {
#line 129
    free_dvector(sb, 0, n - 1);
#line 130
    free_dmatrix(sa, 0, n - 1, 0, n - 1);
    }
#line 131
    if (pivx != (int *)PIVX) {
      {
#line 132
      free_ivector(pivx, 0, n - 1);
      }
    }
#line 133
    return (1);
  }
  {
#line 136
  lu_backsub(a, n, pivx, b);
#line 138
  lu_polish(sa, a, n, sb, b, pivx);
#line 157
  free_dvector(sb, 0, n - 1);
#line 158
  free_dmatrix(sa, 0, n - 1, 0, n - 1);
  }
#line 159
  if (pivx != (int *)PIVX) {
    {
#line 160
    free_ivector(pivx, 0, n - 1);
    }
  }
#line 161
  return (0);
}
}
#line 170 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int lu_decomp(double **a , int n , int *pivx , double *rip ) 
{ 
  int i ;
  int j ;
  double *rscale ;
  double RSCALE[10] ;
  double *__cil_tmp9 ;
  double big ;
  double temp ;
  double __cil_tmp12 ;
  int __cil_tmp13 ;
  double __cil_tmp14 ;
  int __cil_tmp15 ;
  double big___0 ;
  int k ;
  int bigi ;
  double sum ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  double sum___0 ;
  double temp___0 ;
  int __cil_tmp24 ;
  double __cil_tmp25 ;
  int __cil_tmp26 ;
  double *temp___1 ;
  double __cil_tmp28 ;
  double temp___2 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;

  {
#line 179
  if (n <= 10) {
#line 180
    rscale = (double *)RSCALE;
  } else {
    {
#line 182
    rscale = dvector(0, n - 1);
    }
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < n)) {
#line 185
      goto while_break;
    }
#line 188
    j = 0;
#line 188
    big = 0.;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! (j < n)) {
#line 188
        goto while_break___0;
      }
      {
#line 190
      temp = fabs(*(*(a + i) + j));
      }
#line 191
      if (temp > big) {
#line 192
        big = temp;
      }
#line 188
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 194
    __cil_tmp14 = fabs(big);
    }
#line 194
    if (__cil_tmp14 <= (double )2.22507385851e-308L) {
#line 195
      if (rscale != (double *)RSCALE) {
        {
#line 196
        free_dvector(rscale, 0, n - 1);
        }
      }
#line 197
      return (1);
    }
#line 199
    *(rscale + i) = 1. / big;
#line 185
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  j = 0;
#line 203
  *rip = 1.;
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if (! (j < n)) {
#line 203
      goto while_break___1;
    }
#line 205
    bigi = 0;
#line 208
    i = 0;
    {
#line 208
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 208
      if (! (i < j)) {
#line 208
        goto while_break___2;
      }
#line 210
      sum = *(*(a + i) + j);
#line 211
      k = 0;
      {
#line 211
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 211
        if (! (k < i)) {
#line 211
          goto while_break___3;
        }
#line 212
        sum -= *(*(a + i) + k) * *(*(a + k) + j);
#line 211
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 213
      *(*(a + i) + j) = sum;
#line 208
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    i = j;
#line 217
    big___0 = 0.;
    {
#line 217
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 217
      if (! (i < n)) {
#line 217
        goto while_break___4;
      }
#line 220
      sum___0 = *(*(a + i) + j);
#line 221
      k = 0;
      {
#line 221
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 221
        if (! (k < j)) {
#line 221
          goto while_break___5;
        }
#line 222
        sum___0 -= *(*(a + i) + k) * *(*(a + k) + j);
#line 221
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 223
      *(*(a + i) + j) = sum___0;
#line 225
      __cil_tmp25 = fabs(sum___0);
#line 225
      temp___0 = *(rscale + i) * __cil_tmp25;
      }
#line 226
      if (temp___0 >= big___0) {
#line 227
        big___0 = temp___0;
#line 228
        bigi = i;
      }
#line 217
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 233
    if (j != bigi) {
#line 236
      temp___1 = *(a + bigi);
#line 237
      *(a + bigi) = *(a + j);
#line 238
      *(a + j) = temp___1;
#line 240
      *rip = - *rip;
#line 241
      *(rscale + bigi) = *(rscale + j);
    }
    {
#line 244
    *(pivx + j) = bigi;
#line 245
    __cil_tmp28 = fabs(*(*(a + j) + j));
    }
#line 245
    if (__cil_tmp28 <= (double )2.22507385851e-308L) {
#line 246
      if (rscale != (double *)RSCALE) {
        {
#line 247
        free_dvector(rscale, 0, n - 1);
        }
      }
#line 248
      return (1);
    }
#line 252
    if (j != n - 1) {
#line 254
      temp___2 = 1. / *(*(a + j) + j);
#line 255
      i = j + 1;
      {
#line 255
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 255
        if (! (i < n)) {
#line 255
          goto while_break___6;
        }
#line 256
        *(*(a + i) + j) *= temp___2;
#line 255
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 203
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 259
  if (rscale != (double *)RSCALE) {
    {
#line 260
    free_dvector(rscale, 0, n - 1);
    }
  }
#line 261
  return (0);
}
}
#line 267 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
void lu_backsub(double **a , int n , int *pivx , double *b ) 
{ 
  int i ;
  int j ;
  int nvi ;
  int px ;
  double sum ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  double sum___0 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 277
  i = 0;
#line 277
  nvi = - 1;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i < n)) {
#line 277
      goto while_break;
    }
#line 281
    px = *(pivx + i);
#line 282
    sum = *(b + px);
#line 283
    *(b + px) = *(b + i);
#line 284
    if (nvi >= 0) {
#line 285
      j = nvi;
      {
#line 285
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 285
        if (! (j < i)) {
#line 285
          goto while_break___0;
        }
#line 286
        sum -= *(*(a + i) + j) * *(b + j);
#line 285
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 288
    if (sum != 0.) {
#line 289
      nvi = i;
    }
#line 291
    *(b + i) = sum;
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  i = n - 1;
  {
#line 295
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 295
    if (! (i >= 0)) {
#line 295
      goto while_break___1;
    }
#line 297
    sum___0 = *(b + i);
#line 298
    j = i + 1;
    {
#line 298
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 298
      if (! (j < n)) {
#line 298
        goto while_break___2;
      }
#line 299
      sum___0 -= *(*(a + i) + j) * *(b + j);
#line 298
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 300
    *(b + i) = sum___0 / *(*(a + i) + i);
#line 295
    __cil_tmp14 = i;
#line 295
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 307 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
void lu_polish(double **a , double **lua , int n , double *b , double *x , int *pivx ) 
{ 
  int i ;
  int j ;
  double *r ;
  double R[10] ;
  double *__cil_tmp11 ;
  double sum ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 318
  if (n <= 10) {
#line 319
    r = (double *)R;
  } else {
    {
#line 321
    r = dvector(0, n - 1);
    }
  }
#line 324
  i = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < n)) {
#line 324
      goto while_break;
    }
#line 326
    sum = - *(b + i);
#line 327
    j = 0;
    {
#line 327
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 327
      if (! (j < n)) {
#line 327
        goto while_break___0;
      }
#line 328
      sum += *(*(a + i) + j) * *(x + j);
#line 327
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 329
    *(r + i) = sum;
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  lu_backsub(lua, n, pivx, r);
#line 336
  i = 0;
  }
  {
#line 336
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 336
    if (! (i < n)) {
#line 336
      goto while_break___1;
    }
#line 337
    *(x + i) -= *(r + i);
#line 336
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 339
  if (r != (double *)R) {
    {
#line 340
    free_dvector(r, 0, n - 1);
    }
  }
  return;
}
}
#line 349 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int lu_invert(double **a , int n ) 
{ 
  int i ;
  int j ;
  double rip ;
  int *pivx ;
  int PIVX[10] ;
  double **y ;
  int *__cil_tmp9 ;
  int __cil_tmp10 ;
  double **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 358
  if (n <= 10) {
#line 359
    pivx = (int *)PIVX;
  } else {
    {
#line 361
    pivx = ivector(0, n - 1);
    }
  }
  {
#line 363
  __cil_tmp10 = lu_decomp(a, n, pivx, & rip);
  }
#line 363
  if (__cil_tmp10) {
#line 364
    if (pivx != (int *)PIVX) {
      {
#line 365
      free_ivector(pivx, 0, n - 1);
      }
    }
#line 366
    return (1);
  }
  {
#line 370
  y = dmatrix(0, n - 1, 0, n - 1);
#line 371
  i = 0;
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (i < n)) {
#line 371
      goto while_break;
    }
#line 372
    j = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (j < n)) {
#line 372
        goto while_break___0;
      }
#line 373
      *(*(y + i) + j) = *(*(a + i) + j);
#line 372
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 378
    if (! (i < n)) {
#line 378
      goto while_break___1;
    }
#line 379
    j = 0;
    {
#line 379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 379
      if (! (j < n)) {
#line 379
        goto while_break___2;
      }
#line 380
      *(*(a + i) + j) = 0.;
#line 379
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 381
    *(*(a + i) + i) = 1.;
#line 382
    lu_backsub(y, n, pivx, *(a + i));
    }
#line 378
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 386
  free_dmatrix(y, 0, n - 1, 0, n - 1);
  }
#line 387
  if (pivx != (int *)PIVX) {
    {
#line 388
    free_ivector(pivx, 0, n - 1);
    }
  }
#line 390
  return (0);
}
}
#line 397 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int lu_invert_normal(double **a , int n ) 
{ 
  int rv ;
  int __cil_tmp4 ;

  {
  {
#line 403
  rv = lu_invert(a, n);
  }
#line 403
  if (rv != 0) {
#line 404
    return (rv);
  }
  {
#line 405
  sym_matrix_trans(a, n);
  }
#line 407
  return (rv);
}
}
#line 415 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int lu_polished_invert(double **a , int n ) 
{ 
  int i ;
  int j ;
  int k ;
  double **aa ;
  double **t1 ;
  double **t2 ;
  double **__cil_tmp9 ;
  double **__cil_tmp10 ;
  double **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 423
  aa = dmatrix(0, n - 1, 0, n - 1);
#line 424
  t1 = dmatrix(0, n - 1, 0, n - 1);
#line 425
  t2 = dmatrix(0, n - 1, 0, n - 1);
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < n)) {
#line 428
      goto while_break;
    }
#line 429
    j = 0;
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! (j < n)) {
#line 429
        goto while_break___0;
      }
#line 430
      *(*(aa + i) + j) = *(*(a + i) + j);
#line 429
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  i = lu_invert(a, n);
  }
#line 434
  if (i != 0) {
    {
#line 435
    free_dmatrix(aa, 0, n - 1, 0, n - 1);
#line 436
    free_dmatrix(t1, 0, n - 1, 0, n - 1);
#line 437
    free_dmatrix(t2, 0, n - 1, 0, n - 1);
    }
#line 438
    return (i);
  }
#line 441
  k = 0;
  {
#line 441
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 441
    if (! (k < 20)) {
#line 441
      goto while_break___1;
    }
    {
#line 442
    matrix_trans_mult(t1, n, n, aa, n, n, a, n, n);
#line 443
    i = 0;
    }
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 443
      if (! (i < n)) {
#line 443
        goto while_break___2;
      }
#line 444
      j = 0;
      {
#line 444
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 444
        if (! (j < n)) {
#line 444
          goto while_break___3;
        }
#line 445
        *(*(t2 + i) + j) = *(*(a + i) + j);
#line 446
        if (i == j) {
#line 447
          *(*(t1 + i) + j) = 2. - *(*(t1 + i) + j);
        } else {
#line 449
          *(*(t1 + i) + j) = 0. - *(*(t1 + i) + j);
        }
#line 444
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 443
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 452
    matrix_mult(a, n, n, t2, n, n, t1, n, n);
    }
#line 441
    k ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 455
  free_dmatrix(aa, 0, n - 1, 0, n - 1);
#line 456
  free_dmatrix(t1, 0, n - 1, 0, n - 1);
#line 457
  free_dmatrix(t2, 0, n - 1, 0, n - 1);
  }
#line 458
  return (0);
}
}
#line 464 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int lu_psinvert(double **out , double **in , int m , int n ) 
{ 
  int rv ;
  double **tr ;
  double **sq ;
  double **__cil_tmp8 ;
  double **__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double **__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 470
  rv = 0;
#line 474
  tr = dmatrix(0, n - 1, 0, m - 1);
#line 475
  matrix_trans(tr, in, m, n);
  }
#line 478
  if (m > n) {
    {
#line 479
    sq = dmatrix(0, n - 1, 0, n - 1);
#line 482
    rv = matrix_mult(sq, n, n, tr, n, m, in, m, n);
    }
#line 482
    if (rv == 0) {
      {
#line 485
      rv = lu_invert(sq, n);
      }
#line 485
      if (rv == 0) {
        {
#line 488
        rv = matrix_mult(out, n, m, sq, n, n, tr, n, m);
        }
      }
    }
    {
#line 491
    free_dmatrix(sq, 0, n - 1, 0, n - 1);
    }
  } else {
    {
#line 495
    sq = dmatrix(0, m - 1, 0, m - 1);
#line 498
    rv = matrix_mult(sq, m, m, in, m, n, tr, n, m);
    }
#line 498
    if (rv == 0) {
      {
#line 501
      rv = lu_invert(sq, m);
      }
#line 501
      if (rv == 0) {
        {
#line 504
        rv = matrix_mult(out, n, m, tr, n, m, sq, m, m);
        }
      }
    }
    {
#line 507
    free_dmatrix(sq, 0, m - 1, 0, m - 1);
    }
  }
  {
#line 509
  free_dmatrix(tr, 0, n - 1, 0, m - 1);
  }
#line 511
  return (rv);
}
}
#line 523 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
int llt_decomp(double **L , double **A , int n ) 
{ 
  int i ;
  int j ;
  int k ;
  double sum ;
  int __cil_tmp8 ;
  double __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 528
  i = 0;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < n)) {
#line 528
      goto while_break;
    }
#line 530
    j = i;
    {
#line 530
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 530
      if (! (j < n)) {
#line 530
        goto while_break___0;
      }
#line 532
      sum = *(*(A + i) + j);
#line 533
      k = i - 1;
      {
#line 533
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 533
        if (! (k >= 0)) {
#line 533
          goto while_break___1;
        }
#line 534
        sum -= *(*(A + i) + k) * *(*(A + j) + k);
#line 533
        __cil_tmp8 = k;
#line 533
        k --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 537
      if (i != j) {
#line 538
        *(*(L + j) + i) = sum / *(*(L + i) + i);
      } else {
#line 540
        if (sum <= 0.) {
#line 541
          return (1);
        }
        {
#line 542
        *(*(L + i) + i) = sqrt(sum);
        }
      }
#line 530
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  return (0);
}
}
#line 551 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/ludecomp.c"
void llt_backsub(double **L , int n , double *b , double *x ) 
{ 
  int i ;
  int k ;
  double sum ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 561
  i = 0;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (i < n)) {
#line 561
      goto while_break;
    }
#line 562
    sum = *(b + i);
#line 563
    k = i - 1;
    {
#line 563
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 563
      if (! (k >= 0)) {
#line 563
        goto while_break___0;
      }
#line 564
      sum -= *(*(L + i) + k) * *(x + k);
#line 563
      __cil_tmp8 = k;
#line 563
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 565
    *(x + i) = sum / *(*(L + i) + i);
#line 561
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  i = n;
  {
#line 569
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 569
    if (! (i >= 0)) {
#line 569
      goto while_break___1;
    }
#line 570
    sum = *(x + i);
#line 571
    k = i + 1;
    {
#line 571
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 571
      if (! (k < n)) {
#line 571
        goto while_break___2;
      }
#line 572
      sum -= *(*(L + k) + i) * *(x + k);
#line 571
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 573
    *(x + i) = sum / *(*(L + i) + i);
#line 569
    __cil_tmp11 = i;
#line 569
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
  return;
}
}
#line 30 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/gnewt.h"
int gnewt(void *fdata , void (*fcn)(void * , int  , double * , double * ) , void (*jac)(void * ,
                                                                                        int  ,
                                                                                        double * ,
                                                                                        double ** ) ,
          int n , double x[] , double rfvec[] , double xtol , double ftol , int maxfcn ,
          int maxjac ) ;
#line 26 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/gnewt.c"
static void apxjac(int n , double *x , double *fvec , double **df , void *fdata ,
                   void (*fcn)(void * , int  , double * , double * ) ) ;
#line 29
static int linesearch___0(int n , double *xold , double fold , double *delf , double *delx ,
                          double *x , double *fvec , double *fp , double maxstep ,
                          void *fdata , void (*fcn)(void * , int  , double * , double * ) ,
                          int *pfit , int maxfcn , int it ) ;
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/gnewt.c"
int gnewt(void *fdata , void (*fcn)(void * , int  , double * , double * ) , void (*jac)(void * ,
                                                                                        int  ,
                                                                                        double * ,
                                                                                        double ** ) ,
          int n , double x[] , double rfvec[] , double xtol , double ftol , int maxfcn ,
          int maxjac ) 
{ 
  int i ;
  int j ;
  int it ;
  int fit ;
  int jit ;
  int *pivx ;
  int _pivx[10] ;
  double f ;
  double fold ;
  double *delf ;
  double _delf[10] ;
  double *fvec ;
  double _fvec[10] ;
  double **fjac ;
  double *_fjac[11] ;
  double __fjac[100] ;
  double *xold ;
  double _xold[10] ;
  double bigfx ;
  double bigx ;
  double maxstep ;
  double *delx ;
  double _delx[10] ;
  double sum ;
  int rv ;
  int *__cil_tmp36 ;
  double *__cil_tmp37 ;
  double **__cil_tmp38 ;
  double *__cil_tmp39 ;
  double *__cil_tmp40 ;
  double *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  double tt ;
  double __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  double __cil_tmp48 ;
  double __cil_tmp49 ;
  double tmp ;
  double rip ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  double __cil_tmp59 ;
  double __cil_tmp60 ;
  int __cil_tmp61 ;
  double tt___0 ;
  double __cil_tmp63 ;
  double __cil_tmp64 ;
  double __cil_tmp65 ;
  double tmp___0 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;

  {
#line 58
  rv = 0;
#line 67
  jit = 0;
#line 67
  fit = jit;
#line 70
  if (n <= 10) {
#line 71
    pivx = (int *)_pivx;
#line 72
    if (rfvec == (void *)0) {
#line 73
      fvec = (double *)_fvec;
    } else {
#line 75
      fvec = rfvec;
    }
#line 76
    _fjac[0] = (double *)__fjac;
#line 77
    fjac = (double **)_fjac + 1;
#line 78
    xold = (double *)_xold;
#line 79
    delf = (double *)_delf;
#line 80
    delx = (double *)_delx;
  } else {
    {
#line 82
    pivx = ivector(0, n - 1);
    }
#line 83
    if (rfvec == (void *)0) {
      {
#line 84
      fvec = dvector(0, n - 1);
      }
    } else {
#line 86
      fvec = rfvec;
    }
    {
#line 87
    fjac = dmatrix(0, n - 1, 0, n - 1);
#line 88
    xold = dvector(0, n - 1);
#line 89
    delf = dvector(0, n - 1);
#line 90
    delx = dvector(0, n - 1);
    }
  }
  {
#line 98
  (*fcn)(fdata, n, x, fvec);
#line 99
  fit ++;
#line 105
  i = 0;
  }
#line 105
  sum = 0.;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < n)) {
#line 105
      goto while_break;
    }
#line 106
    sum += *(fvec + i) * *(fvec + i);
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  f = 0.5 * sum;
#line 111
  i = 0;
#line 111
  bigfx = 0.;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (i < n)) {
#line 111
      goto while_break___0;
    }
    {
#line 112
    __cil_tmp45 = fabs(*(fvec + i));
#line 112
    tt = __cil_tmp45;
    }
#line 113
    if (tt > bigfx) {
#line 114
      bigfx = tt;
    }
#line 111
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  if (bigfx < 0.0100000000001 * ftol) {
#line 117
    goto done;
  }
#line 121
  i = 0;
#line 121
  sum = 0.;
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 121
    if (! (i < n)) {
#line 121
      goto while_break___1;
    }
#line 122
    sum += x[i] * x[i];
#line 121
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 123
  __cil_tmp48 = sqrt(sum);
  }
#line 123
  if (__cil_tmp48 > (double )n) {
    {
#line 123
    __cil_tmp49 = sqrt(sum);
#line 123
    tmp = __cil_tmp49;
    }
  } else {
#line 123
    tmp = (double )n;
  }
#line 123
  maxstep = 100. * tmp;
#line 127
  it = 0;
  {
#line 127
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 127
    if (! (fit < maxfcn && jit < maxjac)) {
#line 127
      goto while_break___2;
    }
#line 133
    if (jac != (void *)0) {
      {
#line 135
      dmatrix_reset(fjac, 0, n - 1, 0, n - 1);
#line 136
      (*jac)(fdata, n, x, fjac);
      }
    } else {
      {
#line 138
      apxjac(n, x, fvec, fjac, fdata, fcn);
      }
    }
#line 140
    jit ++;
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 152
      if (! (i < n)) {
#line 152
        goto while_break___3;
      }
#line 153
      j = 0;
#line 153
      sum = 0.;
      {
#line 153
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 153
        if (! (j < n)) {
#line 153
          goto while_break___4;
        }
#line 154
        sum += *(*(fjac + j) + i) * *(fvec + j);
#line 153
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 155
      *(delf + i) = sum;
#line 152
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 159
    i = 0;
    {
#line 159
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 159
      if (! (i < n)) {
#line 159
        goto while_break___5;
      }
#line 160
      *(xold + i) = x[i];
#line 159
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 161
    fold = f;
#line 164
    i = 0;
    {
#line 164
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 164
      if (! (i < n)) {
#line 164
        goto while_break___6;
      }
#line 165
      *(delx + i) = - *(fvec + i);
#line 164
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 169
    __cil_tmp57 = lu_decomp(fjac, n, pivx, & rip);
    }
#line 169
    if (__cil_tmp57) {
#line 170
      rv = 2;
#line 171
      goto done;
    }
    {
#line 173
    lu_backsub(fjac, n, pivx, delx);
#line 181
    rv = linesearch___0(n, xold, fold, delf, delx, x, fvec, & f, maxstep, fdata, fcn,
                        & fit, maxfcn, it);
    }
#line 181
    if (rv != 0) {
#line 183
      if (rv != 1) {
#line 185
        goto done;
      }
    }
#line 194
    i = 0;
#line 194
    bigfx = 0.;
    {
#line 194
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 194
      if (! (i < n)) {
#line 194
        goto while_break___7;
      }
      {
#line 195
      __cil_tmp59 = fabs(*(fvec + i));
      }
#line 195
      if (__cil_tmp59 > bigfx) {
        {
#line 196
        bigfx = fabs(*(fvec + i));
        }
      }
#line 194
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 199
    if (bigfx < ftol) {
#line 200
      goto done;
    }
#line 206
    i = 0;
#line 206
    bigx = 0.;
    {
#line 206
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 206
      if (! (i < n)) {
#line 206
        goto while_break___8;
      }
      {
#line 207
      __cil_tmp64 = fabs(x[i]);
      }
#line 207
      if (__cil_tmp64 > 1.) {
        {
#line 207
        __cil_tmp65 = fabs(x[i]);
#line 207
        tmp___0 = __cil_tmp65;
        }
      } else {
#line 207
        tmp___0 = 1.;
      }
      {
#line 207
      __cil_tmp63 = fabs(x[i] - *(xold + i));
#line 207
      tt___0 = __cil_tmp63 / tmp___0;
      }
#line 208
      if (tt___0 > bigx) {
#line 209
        bigx = tt___0;
      }
#line 206
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 212
    if (bigx < xtol) {
#line 213
      goto done;
    }
#line 127
    it ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 216
  rv = 1;
  done: ;
#line 220
  if (n > 10) {
#line 221
    if (fvec != rfvec) {
      {
#line 222
      free_dvector(fvec, 0, n - 1);
      }
    }
    {
#line 223
    free_dvector(xold, 0, n - 1);
#line 224
    free_dvector(delx, 0, n - 1);
#line 225
    free_dvector(delf, 0, n - 1);
#line 226
    free_dmatrix(fjac, 0, n - 1, 0, n - 1);
#line 227
    free_ivector(pivx, 0, n - 1);
    }
  }
#line 234
  return (rv);
}
}
#line 243 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/gnewt.c"
static int linesearch___0(int n , double *xold , double fold , double *delf , double *delx ,
                          double *x , double *fvec , double *fp , double maxstep ,
                          void *fdata , void (*fcn)(void * , int  , double * , double * ) ,
                          int *pfit , int maxfcn , int it ) 
{ 
  int i ;
  double f ;
  double f2 ;
  double lmda1 ;
  double lmda2 ;
  double min_lmda ;
  double sum ;
  double slope ;
  double bigx ;
  int __cil_tmp24 ;
  double __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  double tt ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  double tmp ;
  int __cil_tmp33 ;
  double tmp_lmda ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  double c ;
  double d ;
  double e ;
  double a ;
  double b ;
  double rhs1 ;
  double rhs2 ;
  double disc ;
  double __cil_tmp47 ;
  double __cil_tmp48 ;
  double tmp___0 ;
  int __cil_tmp50 ;

  {
#line 260
  f = *fp;
#line 267
  i = 0;
#line 267
  sum = 0.;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (i < n)) {
#line 267
      goto while_break;
    }
#line 268
    sum += *(delx + i) * *(delx + i);
#line 267
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 269
  sum = sqrt(sum);
  }
#line 272
  if (sum > maxstep) {
#line 273
    i = 0;
    {
#line 273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 273
      if (! (i < n)) {
#line 273
        goto while_break___0;
      }
#line 274
      *(delx + i) *= maxstep / sum;
#line 273
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 277
  i = 0;
#line 277
  slope = 0.;
  {
#line 277
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 277
    if (! (i < n)) {
#line 277
      goto while_break___1;
    }
#line 278
    slope += *(delf + i) * *(delx + i);
#line 277
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 279
  if (slope >= 0.) {
#line 281
    return (3);
  }
#line 284
  bigx = 0.;
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 285
    if (! (i < n)) {
#line 285
      goto while_break___2;
    }
    {
#line 286
    __cil_tmp30 = fabs(*(xold + i));
    }
#line 286
    if (__cil_tmp30 > 1.) {
      {
#line 286
      __cil_tmp31 = fabs(*(xold + i));
#line 286
      tmp = __cil_tmp31;
      }
    } else {
#line 286
      tmp = 1.;
    }
    {
#line 286
    __cil_tmp29 = fabs(*(delx + i));
#line 286
    tt = __cil_tmp29 / tmp;
    }
#line 287
    if (tt > bigx) {
#line 288
      bigx = tt;
    }
#line 285
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 290
  min_lmda = 1e-07 / bigx;
#line 293
  lmda1 = 1.;
  {
#line 298
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 298
    if (! (*pfit < maxfcn)) {
#line 298
      goto while_break___3;
    }
#line 304
    i = 0;
    {
#line 304
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 304
      if (! (i < n)) {
#line 304
        goto while_break___4;
      }
#line 305
      *(x + i) = *(xold + i) + lmda1 * *(delx + i);
#line 304
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 308
    (*fcn)(fdata, n, x, fvec);
#line 309
    (*pfit) ++;
#line 312
    i = 0;
    }
#line 312
    sum = 0.;
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 312
      if (! (i < n)) {
#line 312
        goto while_break___5;
      }
#line 313
      sum += *(fvec + i) * *(fvec + i);
#line 312
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 314
    f = 0.5 * sum;
#line 319
    if (lmda1 < min_lmda) {
#line 321
      i = 0;
      {
#line 321
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 321
        if (! (i < n)) {
#line 321
          goto while_break___6;
        }
#line 322
        *(x + i) = *(xold + i);
#line 321
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 323
      return (0);
    } else
#line 325
    if (f <= fold + (0.000100000000001 * lmda1) * slope) {
#line 326
      *fp = f;
#line 327
      return (0);
    } else
#line 330
    if (lmda1 == 1.) {
#line 331
      tmp_lmda = - slope / (2. * ((f - fold) - slope));
    } else {
#line 337
      rhs1 = (f - fold) - slope * lmda1;
#line 338
      rhs2 = (f2 - fold) - slope * lmda2;
#line 339
      c = rhs1 / (lmda1 * lmda1);
#line 340
      d = rhs2 / (lmda2 * lmda2);
#line 341
      e = lmda1 - lmda2;
#line 342
      a = (c - d) / e;
#line 343
      b = (- lmda2 * c + lmda1 * d) / e;
#line 344
      if (a == 0.) {
#line 345
        tmp_lmda = - slope / (2. * b);
      } else {
#line 347
        disc = b * b - (3. * a) * slope;
#line 349
        if (disc < 0.) {
#line 350
          tmp_lmda = 0.5 * lmda1;
        } else
#line 351
        if (b <= 0.) {
          {
#line 352
          __cil_tmp47 = sqrt(disc);
#line 352
          tmp_lmda = (- b + __cil_tmp47) / (3. * a);
          }
        } else {
          {
#line 354
          __cil_tmp48 = sqrt(disc);
#line 354
          tmp_lmda = - slope / (b + __cil_tmp48);
          }
        }
      }
#line 356
      if (tmp_lmda > 0.5 * lmda1) {
#line 357
        tmp_lmda = 0.5 * lmda1;
      }
    }
#line 360
    lmda2 = lmda1;
#line 361
    if (tmp_lmda > lmda1 * 0.100000000001) {
#line 361
      tmp___0 = tmp_lmda;
    } else {
#line 361
      tmp___0 = lmda1 * 0.100000000001;
    }
#line 361
    lmda1 = tmp___0;
#line 362
    f2 = f;
#line 298
    it ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 365
  *fp = f;
#line 367
  return (1);
}
}
#line 376 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/gnewt.c"
static void apxjac(int n , double *x , double *fvec , double **df , void *fdata ,
                   void (*fcn)(void * , int  , double * , double * ) ) 
{ 
  int i ;
  int j ;
  double h ;
  double temp ;
  double *f ;
  double _f[10] ;
  double *__cil_tmp13 ;
  double __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 387
  if (n <= 10) {
#line 388
    f = (double *)_f;
  } else {
    {
#line 390
    f = dvector(0, n);
    }
  }
#line 392
  j = 0;
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 392
    if (! (j < n)) {
#line 392
      goto while_break;
    }
    {
#line 393
    temp = *(x + j);
#line 395
    __cil_tmp14 = fabs(temp);
#line 395
    h = 1.00000000001e-08 * __cil_tmp14;
    }
#line 396
    if (h == 0.) {
#line 397
      h = 1.00000000001e-08;
    }
    {
#line 398
    *(x + j) = temp + h;
#line 399
    h = *(x + j) - temp;
#line 401
    (*fcn)(fdata, n, x, f);
#line 403
    *(x + j) = temp;
#line 405
    i = 0;
    }
    {
#line 405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 405
      if (! (i < n)) {
#line 405
        goto while_break___0;
      }
#line 406
      *(*(df + i) + j) = (*(f + i) - *(fvec + i)) / h;
#line 405
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 392
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (f != (double *)_f) {
    {
#line 410
    free_dvector(f, 0, n - 1);
    }
  }
  return;
}
}
#line 41 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.h"
int dnsq(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) , int (*jac)(void * ,
                                                                                            int  ,
                                                                                            double * ,
                                                                                            double * ,
                                                                                            double ** ) ,
         double **sjac , int startsjac , int n , double x[] , double fvec[] , double dtol ,
         double atol___0 , int maxfev , int ml , int mu , double epsfcn , double diag[] ,
         double factor , double maxstep , int nprint , int *nfev , int *njev ) ;
#line 69
int dnsq_fcn(void *fdata , int n , double *x , double *fvec , int iflag ) ;
#line 78
int dnsq_jac(void *fdata , int n , double *x , double *fvec , double **fjac ) ;
#line 91
int dnsqe(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) ,
          int (*jac)(void * , int  , double * , double * , double ** ) , int n , double x[] ,
          double ss , double fvec[] , double dtol , double atol___0 , int maxfev ,
          int nprint ) ;
#line 35 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int dfdjc1(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) ,
                  int n , double x[] , double fvec[] , double fjac[] , int ldfjac ,
                  int ml , int mu , double epsfcn , double *wa1 , double *wa2 ) ;
#line 43
static int dqrfac(int m , int n , double *a , int lda , bool pivot , int *ipvt , double *sigma ,
                  double *acnorm , double *wa ) ;
#line 48
static int dqform(int m , int n , double *q , int ldq , double *wa ) ;
#line 51
static int d1updt(int m , int n , double *s , double *u , double *v , double *w ) ;
#line 55
static int d1mpyq(int m , int n , double *a , int lda , double *v , double *w ) ;
#line 59
static double denorm(int n , double x[] ) ;
#line 62
static int ddoglg(int n , double r[] , double diag[] , double qtb[] , double delta ,
                  double x[] , double wa1[] , double wa2[] ) ;
#line 71 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
int dnsqe(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) ,
          int (*jac)(void * , int  , double * , double * , double ** ) , int n , double x[] ,
          double ss , double fvec[] , double dtol , double atol___0 , int maxfev ,
          int nprint ) 
{ 
  int info ;
  int nfev ;
  int njev ;
  int i ;
  int j ;
  int index___18 ;
  int ml ;
  int lr ;
  int mu ;
  double epsfcn ;
  double factor ;
  double maxstep ;
  int __cil_tmp24 ;

  {
#line 86
  info = 0;
#line 90
  epsfcn = ss * ss;
#line 91
  factor = ss;
#line 92
  maxstep = 0.;
#line 94
  if (maxfev <= 0) {
#line 95
    maxfev = (n + 1) * 100;
#line 96
    if (jac == (void *)0) {
#line 97
      maxfev <<= 1;
    }
  }
  {
#line 99
  ml = n - 1;
#line 100
  mu = n - 1;
#line 102
  lr = (n * (n + 1)) / 2;
#line 103
  index___18 = n * 6 + lr;
#line 106
  info = dnsq(fdata, fcn, jac, (double **)((void *)0), 0, n, & x[0], & fvec[0], dtol,
              atol___0, maxfev, ml, mu, epsfcn, (double [])((void *)0), factor, maxstep,
              nprint, & nfev, & njev);
  }
#line 111
  if (info == 5) {
#line 112
    info = 4;
  }
#line 113
  if (info == 0) {
    {
#line 114
    warning("dnsqe: invalid input parameter.");
    }
  }
#line 116
  return (info);
}
}
#line 447 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
int dnsq(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) , int (*jac)(void * ,
                                                                                            int  ,
                                                                                            double * ,
                                                                                            double * ,
                                                                                            double ** ) ,
         double **sjac , int startsjac , int n , double x[] , double fvec[] , double dtol ,
         double atol___0 , int maxfev , int ml , int mu , double epsfcn , double diag[] ,
         double factor , double maxstep , int nprint , int *nfev , int *njev ) 
{ 
  int info ;
  int smode ;
  double *fjac ;
  int ldfjac ;
  double **jjac ;
  double *r ;
  double *qtf ;
  double *wa1 ;
  double *wa2 ;
  double *wa3 ;
  double *wa4 ;
  int iwa[1] ;
  bool jeval ;
  int iter ;
  int i ;
  int j ;
  int k ;
  int l ;
  int iflag ;
  int qrflag ;
  int ncsuc ;
  int nslow1 ;
  int nslow2 ;
  int ncfail ;
  double temp ;
  double delta ;
  double ratio ;
  double fnorm ;
  double pnorm ;
  double xnorm ;
  double fnorm1 ;
  double actred ;
  double prered ;
  double sum ;
  double *__cil_tmp55 ;
  double *__cil_tmp56 ;
  double **__cil_tmp57 ;
  double *__cil_tmp58 ;
  double *__cil_tmp59 ;
  double *__cil_tmp60 ;
  double *__cil_tmp61 ;
  double *__cil_tmp62 ;
  double *__cil_tmp63 ;
  int __cil_tmp64 ;
  double __cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int ti ;
  int __cil_tmp69 ;
  int tmp ;
  int __cil_tmp71 ;
  double __cil_tmp72 ;
  double tmp___0 ;
  int __cil_tmp74 ;
  double __cil_tmp75 ;
  double tmp___1 ;
  int __cil_tmp77 ;
  double __cil_tmp78 ;
  double td ;
  double __cil_tmp80 ;
  double td___0 ;
  double tmp___2 ;
  double tmp___3 ;
  double __cil_tmp84 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double temp___22 ;

  {
#line 472
  info = 0;
#line 473
  smode = 0;
#line 476
  fjac = (double *)((void *)0);
#line 478
  ldfjac = n;
#line 479
  jjac = (double **)((void *)0);
#line 481
  r = (double *)((void *)0);
#line 484
  qtf = (double *)((void *)0);
#line 486
  wa1 = (double *)((void *)0);
#line 487
  wa2 = (double *)((void *)0);
#line 488
  wa3 = (double *)((void *)0);
#line 489
  wa4 = (double *)((void *)0);
#line 501
  delta = 0.;
#line 503
  xnorm = 0.;
#line 509
  if (diag == (void *)0) {
    {
#line 510
    smode = 1;
#line 511
    diag = (double [])dvector(0, n - 1);
    }
  }
  {
#line 513
  fjac = dvector(0, n * n - 1);
#line 514
  jjac = convert_dmatrix(fjac, 0, n - 1, 0, ldfjac - 1);
#line 515
  r = dvector(0, (n * (n + 1)) / 2 - 1);
#line 516
  qtf = dvector(0, n - 1);
#line 517
  wa1 = dvector(0, n - 1);
#line 518
  wa2 = dvector(0, n - 1);
#line 519
  wa3 = dvector(0, n - 1);
#line 520
  wa4 = dvector(0, n - 1);
#line 522
  qrflag = 0;
#line 523
  iflag = 0;
#line 524
  *nfev = 0;
#line 525
  *njev = 0;
  }
#line 528
  if (sjac == (void *)0) {
#line 528
    if (startsjac != 0) {
#line 531
      goto func_exit;
    } else {
#line 528
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 528
  if (n <= 0) {
#line 531
    goto func_exit;
  } else
#line 528
  if (dtol < 0.) {
#line 531
    goto func_exit;
  } else
#line 528
  if (maxfev <= 0) {
#line 531
    goto func_exit;
  } else
#line 528
  if (ml < 0) {
#line 531
    goto func_exit;
  } else
#line 528
  if (mu < 0) {
#line 531
    goto func_exit;
  } else
#line 528
  if (factor <= 0.) {
#line 531
    goto func_exit;
  } else
#line 528
  if (maxstep < 0.) {
#line 531
    goto func_exit;
  }
#line 533
  if (! smode) {
#line 534
    j = 0;
    {
#line 534
    while (1) {
      while_continue: /* CIL Label */ ;
#line 534
      if (! (j < n)) {
#line 534
        goto while_break;
      }
#line 535
      if (diag[j] <= 0.) {
#line 536
        goto func_exit;
      }
#line 534
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 543
  *nfev = 1;
#line 544
  iflag = (*fcn)(fdata, n, & x[0], & fvec[0], 1);
  }
#line 544
  if (iflag < 0) {
#line 545
    goto func_exit;
  }
  {
#line 546
  fnorm = denorm(n, & fvec[0]);
#line 550
  iter = 1;
#line 551
  ncsuc = 0;
#line 552
  ncfail = 0;
#line 553
  nslow1 = 0;
#line 554
  nslow2 = 0;
  }
  {
#line 557
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 557
    if (! 1) {
#line 557
      goto while_break___0;
    }
#line 558
    jeval = (bool )(! 0);
#line 561
    if (startsjac) {
#line 562
      j = 0;
      {
#line 562
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 562
        if (! (j < n)) {
#line 562
          goto while_break___1;
        }
#line 563
        i = 0;
        {
#line 563
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 563
          if (! (i < n)) {
#line 563
            goto while_break___2;
          }
#line 564
          *(fjac + (j * ldfjac + i)) = *(*(sjac + j) + i);
#line 563
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 562
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 566
    if (jac == (void *)0) {
      {
#line 568
      iflag = dfdjc1(fdata, fcn, n, & x[0], & fvec[0], fjac + 0, ldfjac, ml, mu, epsfcn,
                     wa1 + 0, wa2 + 0);
#line 570
      ti = (ml + mu) + 1;
      }
#line 571
      if (ti <= n) {
#line 571
        tmp = ti;
      } else {
#line 571
        tmp = n;
      }
#line 571
      *nfev += tmp;
    } else {
      {
#line 573
      iflag = (*jac)(fdata, n, & x[0], & fvec[0], jjac);
#line 574
      (*njev) ++;
      }
    }
#line 580
    if (iflag < 0) {
#line 581
      goto func_exit;
    }
    {
#line 584
    dqrfac(n, n, fjac + 0, ldfjac, (bool )0, (int *)iwa, wa1 + 0, wa2 + 0, wa3 + 0);
    }
#line 590
    if (iter == 1) {
      _L___19: /* CIL Label */ 
#line 591
      if (smode) {
#line 592
        j = 0;
        {
#line 592
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 592
          if (! (j < n)) {
#line 592
            goto while_break___3;
          }
#line 593
          diag[j] = *(wa2 + j);
#line 594
          if (*(wa2 + j) == 0.) {
#line 595
            diag[j] = 1.;
          }
#line 592
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 602
      j = 0;
      {
#line 602
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 602
        if (! (j < n)) {
#line 602
          goto while_break___4;
        }
#line 603
        *(wa3 + j) = diag[j] * x[j];
#line 602
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 605
      xnorm = denorm(n, wa3 + 0);
      }
#line 606
      if (iter == 1) {
#line 607
        delta = factor * xnorm;
#line 608
        if (delta == 0.) {
#line 609
          delta = factor;
        }
      } else {
#line 614
        delta = maxstep * xnorm;
#line 615
        if (delta == 0.) {
#line 616
          delta = maxstep;
        }
      }
    } else
#line 590
    if (maxstep > 0.) {
#line 590
      goto _L___19;
    }
#line 624
    i = 0;
    {
#line 624
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 624
      if (! (i < n)) {
#line 624
        goto while_break___5;
      }
#line 625
      *(qtf + i) = fvec[i];
#line 624
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 627
    j = 0;
    {
#line 627
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 627
      if (! (j < n)) {
#line 627
        goto while_break___6;
      }
#line 628
      if (*(fjac + (j + j * ldfjac)) != 0.) {
#line 629
        sum = 0.;
#line 630
        i = j;
        {
#line 630
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 630
          if (! (i < n)) {
#line 630
            goto while_break___7;
          }
#line 631
          sum += *(fjac + (i + j * ldfjac)) * *(qtf + i);
#line 630
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 632
        temp = - sum / *(fjac + (j + j * ldfjac));
#line 634
        i = j;
        {
#line 634
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 634
          if (! (i < n)) {
#line 634
            goto while_break___8;
          }
#line 635
          *(qtf + i) += *(fjac + (i + j * ldfjac)) * temp;
#line 634
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 627
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 640
    j = 0;
    {
#line 640
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 640
      if (! (j < n)) {
#line 640
        goto while_break___9;
      }
#line 641
      l = j;
#line 642
      if (j >= 1) {
#line 643
        i = 0;
        {
#line 643
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 643
          if (! (i < j)) {
#line 643
            goto while_break___10;
          }
#line 644
          *(r + l) = *(fjac + (i + j * ldfjac));
#line 645
          l += (n - 1) - i;
#line 643
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 648
      *(r + l) = *(wa1 + j);
#line 640
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 652
    dqform(n, n, fjac + 0, ldfjac, wa1 + 0);
#line 654
    qrflag = 1;
    }
#line 657
    if (smode) {
#line 658
      j = 0;
      {
#line 658
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 658
        if (! (j < n)) {
#line 658
          goto while_break___11;
        }
#line 659
        if (diag[j] >= *(wa2 + j)) {
#line 659
          tmp___0 = diag[j];
        } else {
#line 659
          tmp___0 = *(wa2 + j);
        }
#line 659
        diag[j] = tmp___0;
#line 658
        j ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    {
#line 664
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 664
      if (! 1) {
#line 664
        goto while_break___12;
      }
#line 666
      if (nprint > 0) {
#line 667
        if ((iter - 1) % nprint == 0) {
          {
#line 668
          iflag = (*fcn)(fdata, n, & x[0], & fvec[0], 0);
          }
#line 668
          if (iflag < 0) {
#line 669
            goto func_exit;
          }
        }
      }
      {
#line 699
      ddoglg(n, r + 0, & diag[0], qtf + 0, delta, wa1 + 0, wa2 + 0, wa3 + 0);
#line 703
      j = 0;
      }
      {
#line 703
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 703
        if (! (j < n)) {
#line 703
          goto while_break___13;
        }
#line 704
        *(wa1 + j) = - *(wa1 + j);
#line 705
        *(wa2 + j) = x[j] + *(wa1 + j);
#line 706
        *(wa3 + j) = diag[j] * *(wa1 + j);
#line 703
        j ++;
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 708
      pnorm = denorm(n, wa3 + 0);
      }
#line 712
      if (iter == 1) {
        _L___20: /* CIL Label */ 
#line 713
        if (delta <= pnorm) {
#line 713
          tmp___1 = delta;
        } else {
#line 713
          tmp___1 = pnorm;
        }
#line 713
        delta = tmp___1;
      } else
#line 712
      if (maxstep > 0.) {
#line 712
        goto _L___20;
      }
      {
#line 723
      (*nfev) ++;
#line 724
      iflag = (*fcn)(fdata, n, wa2 + 0, wa4 + 0, 1);
      }
#line 724
      if (iflag < 0) {
#line 725
        goto func_exit;
      }
      {
#line 726
      fnorm1 = denorm(n, wa4 + 0);
#line 729
      actred = - 1.;
      }
#line 730
      if (fnorm1 < fnorm) {
#line 732
        td = fnorm1 / fnorm;
#line 733
        actred = 1. - td * td;
      }
#line 737
      l = 0;
#line 738
      i = 0;
      {
#line 738
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 738
        if (! (i < n)) {
#line 738
          goto while_break___14;
        }
#line 739
        sum = 0.;
#line 740
        j = i;
        {
#line 740
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 740
          if (! (j < n)) {
#line 740
            goto while_break___15;
          }
#line 741
          sum += *(r + l) * *(wa1 + j);
#line 742
          l ++;
#line 740
          j ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 744
        *(wa3 + i) = *(qtf + i) + sum;
#line 738
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 747
      temp = denorm(n, wa3 + 0);
#line 748
      prered = 0.;
      }
#line 749
      if (temp < fnorm) {
#line 751
        td___0 = temp / fnorm;
#line 752
        prered = 1. - td___0 * td___0;
      }
#line 756
      ratio = 0.;
#line 757
      if (prered > 0.) {
#line 758
        ratio = actred / prered;
      }
#line 764
      if (ratio < 0.100000000001) {
#line 765
        ncsuc = 0;
#line 766
        ncfail ++;
#line 767
        delta = 0.5 * delta;
      } else {
#line 772
        ncfail = 0;
#line 773
        ncsuc ++;
#line 774
        if (ratio >= 0.5) {
          _L___21: /* CIL Label */ 
#line 775
          if (delta >= pnorm / 0.5) {
#line 775
            tmp___2 = delta;
          } else {
#line 775
            tmp___2 = pnorm / 0.5;
          }
#line 775
          delta = tmp___2;
        } else
#line 774
        if (ncsuc > 1) {
#line 774
          goto _L___21;
        }
#line 780
        if (ratio - 1. >= 0.) {
#line 780
          tmp___3 = ratio - 1.;
        } else {
#line 780
          tmp___3 = - (ratio - 1.);
        }
#line 780
        if (tmp___3 <= 0.100000000001) {
#line 781
          delta = 2. * pnorm;
        }
      }
#line 789
      if (ratio > 0.000100000000001) {
#line 794
        j = 0;
        {
#line 794
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 794
          if (! (j < n)) {
#line 794
            goto while_break___16;
          }
#line 795
          x[j] = *(wa2 + j);
#line 796
          *(wa2 + j) = diag[j] * x[j];
#line 797
          fvec[j] = *(wa4 + j);
#line 794
          j ++;
        }
        while_break___16: /* CIL Label */ ;
        }
        {
#line 799
        xnorm = denorm(n, wa2 + 0);
#line 800
        fnorm = fnorm1;
#line 801
        iter ++;
        }
      }
#line 808
      nslow1 ++;
#line 809
      if (actred >= 0.) {
#line 809
        tmp___4 = actred;
      } else {
#line 809
        tmp___4 = - actred;
      }
#line 809
      if (tmp___4 >= 0.00100000000001) {
#line 810
        nslow1 = 0;
      }
#line 811
      if (jeval) {
#line 812
        nslow2 ++;
      }
#line 813
      if (actred >= 0.) {
#line 813
        tmp___5 = actred;
      } else {
#line 813
        tmp___5 = - actred;
      }
#line 813
      if (tmp___5 >= 0.100000000001) {
#line 814
        nslow2 = 0;
      }
#line 817
      if (delta <= dtol * xnorm) {
#line 821
        info = 1;
#line 822
        goto func_exit;
      } else
#line 817
      if (fnorm == 0.) {
#line 821
        info = 1;
#line 822
        goto func_exit;
      }
#line 825
      j = 0;
      {
#line 825
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 825
        if (! (j < n)) {
#line 825
          goto while_break___17;
        }
#line 826
        if (fvec[j] >= 0.) {
#line 826
          tmp___6 = fvec[j];
        } else {
#line 826
          tmp___6 = - fvec[j];
        }
#line 826
        if (tmp___6 > atol___0) {
#line 827
          goto while_break___17;
        }
#line 825
        j ++;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 829
      if (j >= n) {
#line 833
        info = 1;
#line 834
        goto func_exit;
      }
#line 838
      if (*nfev >= maxfev) {
#line 839
        info = 2;
      }
#line 840
      if (0.100000000001 * delta >= pnorm) {
#line 840
        tmp___7 = 0.100000000001 * delta;
      } else {
#line 840
        tmp___7 = pnorm;
      }
#line 840
      if (0.100000000001 * tmp___7 <= 2.22000000001e-15 * xnorm) {
#line 841
        info = 3;
      }
#line 842
      if (nslow2 == 5) {
#line 843
        info = 4;
      }
#line 844
      if (nslow1 == 10) {
#line 845
        info = 5;
      }
#line 846
      if (info != 0) {
#line 847
        goto func_exit;
      }
#line 850
      if (ncfail == 2) {
#line 851
        goto while_break___12;
      }
#line 856
      j = 0;
      {
#line 856
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 856
        if (! (j < n)) {
#line 856
          goto while_break___18;
        }
#line 857
        sum = 0.;
#line 858
        i = 0;
        {
#line 858
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 858
          if (! (i < n)) {
#line 858
            goto while_break___19;
          }
#line 859
          sum += *(fjac + (i + j * ldfjac)) * *(wa4 + i);
#line 858
          i ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 861
        *(wa2 + j) = (sum - *(wa3 + j)) / pnorm;
#line 862
        *(wa1 + j) = diag[j] * ((diag[j] * *(wa1 + j)) / pnorm);
#line 863
        if (ratio >= 0.000100000000001) {
#line 864
          *(qtf + j) = sum;
        }
#line 856
        j ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 869
      d1updt(n, n, r + 0, wa1 + 0, wa2 + 0, wa3 + 0);
#line 870
      d1mpyq(n, n, fjac + 0, ldfjac, wa2 + 0, wa3 + 0);
#line 871
      d1mpyq(1, n, qtf + 0, 1, wa2 + 0, wa3 + 0);
#line 873
      jeval = (bool )0;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  func_exit: 
#line 884
  if (sjac) {
#line 884
    if (qrflag) {
#line 885
      i = 0;
      {
#line 885
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 885
        if (! (i < n)) {
#line 885
          goto while_break___20;
        }
#line 886
        j = 0;
        {
#line 886
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 886
          if (! (j < n)) {
#line 886
            goto while_break___21;
          }
#line 887
          temp___22 = 0.;
#line 888
          l = j;
#line 889
          k = 0;
          {
#line 889
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 889
            if (! (k <= j)) {
#line 889
              goto while_break___22;
            }
#line 890
            temp___22 += *(fjac + (k * ldfjac + i)) * *(r + l);
#line 891
            l += (n - 1) - k;
#line 889
            k ++;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 893
          *(*(sjac + j) + i) = temp___22;
#line 886
          j ++;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 885
        i ++;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
  }
#line 899
  if (smode) {
    {
#line 900
    free_dvector(diag, 0, n - 1);
    }
  }
  {
#line 901
  free_dvector(fjac, 0, n * n - 1);
#line 902
  free_convert_dmatrix(jjac, 0, n - 1, 0, ldfjac - 1);
#line 903
  free_dvector(r, 0, (n * (n + 1)) / 2 - 1);
#line 904
  free_dvector(qtf, 0, n - 1);
#line 905
  free_dvector(wa1, 0, n - 1);
#line 906
  free_dvector(wa2, 0, n - 1);
#line 907
  free_dvector(wa3, 0, n - 1);
#line 908
  free_dvector(wa4, 0, n - 1);
  }
#line 911
  if (iflag < 0) {
#line 912
    info = iflag;
  }
#line 913
  if (nprint > 0) {
    {
#line 914
    (*fcn)(fdata, n, & x[0], & fvec[0], 0);
    }
  }
#line 927
  return (info);
}
}
#line 946 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int d1mpyq(int m , int n , double *a , int lda , double *v , double *w ) 
{ 
  int i ;
  int j ;
  int nm1 ;
  double temp ;
  double cos_ ;
  double sin_ ;
  double tmp ;
  double tmp___0 ;
  double __cil_tmp15 ;
  double tmp___1 ;
  double tmp___2 ;
  double __cil_tmp18 ;
  double tmp___3 ;
  double tmp___4 ;
  double __cil_tmp21 ;
  double tmp___5 ;
  double tmp___6 ;
  double __cil_tmp24 ;

  {
#line 956
  nm1 = n - 1;
#line 958
  cos_ = 0.;
#line 958
  sin_ = 0.;
#line 961
  if (nm1 >= 1) {
#line 962
    j = n - 2;
    {
#line 962
    while (1) {
      while_continue: /* CIL Label */ ;
#line 962
      if (! (j >= 0)) {
#line 962
        goto while_break;
      }
#line 963
      if (*(v + j) >= 0.) {
#line 963
        tmp = *(v + j);
      } else {
#line 963
        tmp = - *(v + j);
      }
#line 963
      if (tmp > 1.) {
#line 964
        cos_ = 1. / *(v + j);
      }
#line 965
      if (*(v + j) >= 0.) {
#line 965
        tmp___0 = *(v + j);
      } else {
#line 965
        tmp___0 = - *(v + j);
      }
#line 965
      if (tmp___0 > 1.) {
        {
#line 966
        sin_ = sqrt(1. - cos_ * cos_);
        }
      }
#line 968
      if (*(v + j) >= 0.) {
#line 968
        tmp___1 = *(v + j);
      } else {
#line 968
        tmp___1 = - *(v + j);
      }
#line 968
      if (tmp___1 <= 1.) {
#line 969
        sin_ = *(v + j);
      }
#line 971
      if (*(v + j) >= 0.) {
#line 971
        tmp___2 = *(v + j);
      } else {
#line 971
        tmp___2 = - *(v + j);
      }
#line 971
      if (tmp___2 <= 1.) {
        {
#line 972
        cos_ = sqrt(1. - sin_ * sin_);
        }
      }
#line 974
      i = 0;
      {
#line 974
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 974
        if (! (i < m)) {
#line 974
          goto while_break___0;
        }
#line 975
        temp = cos_ * *(a + (i + j * lda)) - sin_ * *(a + (i + nm1 * lda));
#line 976
        *(a + (i + nm1 * lda)) = sin_ * *(a + (i + j * lda)) + cos_ * *(a + (i + nm1 * lda));
#line 977
        *(a + (i + j * lda)) = temp;
#line 974
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 962
      j --;
    }
    while_break: /* CIL Label */ ;
    }
#line 982
    j = 0;
    {
#line 982
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 982
      if (! (j < nm1)) {
#line 982
        goto while_break___1;
      }
#line 983
      if (*(w + j) >= 0.) {
#line 983
        tmp___3 = *(w + j);
      } else {
#line 983
        tmp___3 = - *(w + j);
      }
#line 983
      if (tmp___3 > 1.) {
#line 984
        cos_ = 1. / *(w + j);
      }
#line 985
      if (*(w + j) >= 0.) {
#line 985
        tmp___4 = *(w + j);
      } else {
#line 985
        tmp___4 = - *(w + j);
      }
#line 985
      if (tmp___4 > 1.) {
        {
#line 986
        sin_ = sqrt(1. - cos_ * cos_);
        }
      }
#line 988
      if (*(w + j) >= 0.) {
#line 988
        tmp___5 = *(w + j);
      } else {
#line 988
        tmp___5 = - *(w + j);
      }
#line 988
      if (tmp___5 <= 1.) {
#line 989
        sin_ = *(w + j);
      }
#line 990
      if (*(w + j) >= 0.) {
#line 990
        tmp___6 = *(w + j);
      } else {
#line 990
        tmp___6 = - *(w + j);
      }
#line 990
      if (tmp___6 <= 1.) {
        {
#line 991
        cos_ = sqrt(1. - sin_ * sin_);
        }
      }
#line 993
      i = 0;
      {
#line 993
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 993
        if (! (i < m)) {
#line 993
          goto while_break___2;
        }
#line 994
        temp = cos_ * *(a + (i + j * lda)) + sin_ * *(a + (i + nm1 * lda));
#line 995
        *(a + (i + nm1 * lda)) = - sin_ * *(a + (i + j * lda)) + cos_ * *(a + (i + nm1 * lda));
#line 996
        *(a + (i + j * lda)) = temp;
#line 993
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 982
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1000
  return (0);
}
}
#line 1028 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int d1updt(int m , int n , double *s , double *u , double *v , double *w ) 
{ 
  int i ;
  int j ;
  int l ;
  int jj ;
  int nm1 ;
  int nmj ;
  double temp ;
  double giant ;
  double cotan ;
  double tan_ ;
  double cos_ ;
  double sin_ ;
  double tau ;
  double tmp ;
  double tmp___0 ;
  double __cil_tmp22 ;
  double tmp___1 ;
  double __cil_tmp24 ;
  double tmp___2 ;
  double tmp___3 ;
  double __cil_tmp27 ;
  double tmp___4 ;
  double __cil_tmp29 ;

  {
#line 1038
  nm1 = n - 1;
#line 1046
  giant = 1.79e+308;
#line 1049
  jj = ((n * (((m << 1) - n) + 1)) / 2 - (m - n)) - 1;
#line 1052
  l = jj;
#line 1053
  i = nm1;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! (i < m)) {
#line 1053
      goto while_break;
    }
#line 1054
    *(w + i) = *(s + l);
#line 1055
    l ++;
#line 1053
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  if (nm1 >= 1) {
#line 1061
    nmj = 1;
    {
#line 1061
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1061
      if (! (nmj <= nm1)) {
#line 1061
        goto while_break___0;
      }
#line 1062
      j = (n - nmj) - 1;
#line 1063
      jj -= m - j;
#line 1064
      *(w + j) = 0.;
#line 1065
      if (*(v + j) == 0.) {
#line 1066
        goto while_continue___0;
      }
#line 1070
      if (*(v + j) >= 0.) {
#line 1070
        tmp___0 = *(v + j);
      } else {
#line 1070
        tmp___0 = - *(v + j);
      }
#line 1070
      if (*(v + nm1) >= 0.) {
#line 1070
        tmp = *(v + nm1);
      } else {
#line 1070
        tmp = - *(v + nm1);
      }
#line 1070
      if (tmp < tmp___0) {
        {
#line 1071
        cotan = *(v + nm1) / *(v + j);
#line 1072
        __cil_tmp22 = sqrt(0.25 + 0.25 * (cotan * cotan));
#line 1072
        sin_ = 0.5 / __cil_tmp22;
#line 1073
        cos_ = sin_ * cotan;
#line 1074
        tau = 1.;
        }
#line 1075
        if (cos_ >= 0.) {
#line 1075
          tmp___1 = cos_;
        } else {
#line 1075
          tmp___1 = - cos_;
        }
#line 1075
        if (tmp___1 * giant > 1.) {
#line 1076
          tau = 1. / cos_;
        }
      } else {
        {
#line 1079
        tan_ = *(v + j) / *(v + nm1);
#line 1080
        __cil_tmp24 = sqrt(0.25 + 0.25 * (tan_ * tan_));
#line 1080
        cos_ = 0.5 / __cil_tmp24;
#line 1081
        sin_ = cos_ * tan_;
#line 1082
        tau = sin_;
        }
      }
#line 1087
      *(v + nm1) = sin_ * *(v + j) + cos_ * *(v + nm1);
#line 1088
      *(v + j) = tau;
#line 1091
      l = jj;
#line 1092
      i = j;
      {
#line 1092
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1092
        if (! (i < m)) {
#line 1092
          goto while_break___1;
        }
#line 1093
        temp = cos_ * *(s + l) - sin_ * *(w + i);
#line 1094
        *(w + i) = sin_ * *(s + l) + cos_ * *(w + i);
#line 1095
        *(s + l) = temp;
#line 1096
        l ++;
#line 1092
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1061
      nmj ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1102
  i = 0;
  {
#line 1102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1102
    if (! (i < m)) {
#line 1102
      goto while_break___2;
    }
#line 1103
    *(w + i) += *(v + nm1) * *(u + i);
#line 1102
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1106
  if (nm1 >= 1) {
#line 1107
    j = 0;
    {
#line 1107
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1107
      if (! (j < nm1)) {
#line 1107
        goto while_break___3;
      }
#line 1108
      if (*(w + j) != 0.) {
#line 1111
        if (*(w + j) >= 0.) {
#line 1111
          tmp___3 = *(w + j);
        } else {
#line 1111
          tmp___3 = - *(w + j);
        }
#line 1111
        if (*(s + jj) >= 0.) {
#line 1111
          tmp___2 = *(s + jj);
        } else {
#line 1111
          tmp___2 = - *(s + jj);
        }
#line 1111
        if (tmp___2 < tmp___3) {
          {
#line 1112
          cotan = *(s + jj) / *(w + j);
#line 1113
          __cil_tmp27 = sqrt(0.25 + 0.25 * (cotan * cotan));
#line 1113
          sin_ = 0.5 / __cil_tmp27;
#line 1114
          cos_ = sin_ * cotan;
#line 1115
          tau = 1.;
          }
#line 1116
          if (cos_ >= 0.) {
#line 1116
            tmp___4 = cos_;
          } else {
#line 1116
            tmp___4 = - cos_;
          }
#line 1116
          if (tmp___4 * giant > 1.) {
#line 1117
            tau = 1. / cos_;
          }
        } else {
          {
#line 1120
          tan_ = *(w + j) / *(s + jj);
#line 1121
          __cil_tmp29 = sqrt(0.25 + 0.25 * (tan_ * tan_));
#line 1121
          cos_ = 0.5 / __cil_tmp29;
#line 1122
          sin_ = cos_ * tan_;
#line 1123
          tau = sin_;
          }
        }
#line 1127
        l = jj;
#line 1128
        i = j;
        {
#line 1128
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1128
          if (! (i < m)) {
#line 1128
            goto while_break___4;
          }
#line 1129
          temp = cos_ * *(s + l) + sin_ * *(w + i);
#line 1130
          *(w + i) = - sin_ * *(s + l) + cos_ * *(w + i);
#line 1131
          *(s + l) = temp;
#line 1132
          l ++;
#line 1128
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1136
        *(w + j) = tau;
      }
#line 1138
      jj += m - j;
#line 1107
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1143
  l = jj;
#line 1144
  i = nm1;
  {
#line 1144
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1144
    if (! (i < m)) {
#line 1144
      goto while_break___5;
    }
#line 1145
    *(s + l) = *(w + i);
#line 1146
    l ++;
#line 1144
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1148
  return (0);
}
}
#line 1171 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int ddoglg(int n , double r[] , double diag[] , double qtb[] , double delta ,
                  double x[] , double wa1[] , double wa2[] ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int jj ;
  int jp1 ;
  int nm1 ;
  double temp ;
  double alpha ;
  double gnorm ;
  double qnorm ;
  double epsmch ;
  double sgnorm ;
  double sum ;
  double dt ;
  double tmp ;
  double tmp___0 ;
  double __cil_tmp26 ;
  double __cil_tmp27 ;
  double __cil_tmp28 ;
  double d0 ;
  double d1 ;
  double d2 ;
  double d3 ;
  double d4 ;
  double bnorm ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  double tmp___1 ;

  {
#line 1184
  nm1 = n - 1;
#line 1192
  epsmch = 2.22000000001e-15;
#line 1195
  jj = (n * (n + 1)) / 2;
#line 1196
  k = 0;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! (k < n)) {
#line 1196
      goto while_break;
    }
#line 1197
    j = nm1 - k;
#line 1198
    jp1 = j + 1;
#line 1199
    jj -= k + 1;
#line 1200
    l = jj + 1;
#line 1201
    sum = 0.;
#line 1202
    if (n >= jp1 + 1) {
#line 1203
      i = jp1;
      {
#line 1203
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1203
        if (! (i < n)) {
#line 1203
          goto while_break___0;
        }
#line 1204
        sum += r[l] * x[i];
#line 1205
        l ++;
#line 1203
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1209
    temp = r[jj];
#line 1210
    if (temp == 0.) {
#line 1211
      l = j;
#line 1212
      i = 0;
      {
#line 1212
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1212
        if (! (i <= j)) {
#line 1212
          goto while_break___1;
        }
#line 1214
        if (r[l] >= 0.) {
#line 1214
          tmp = r[l];
        } else {
#line 1214
          tmp = - r[l];
        }
#line 1214
        dt = tmp;
#line 1215
        if (temp >= dt) {
#line 1215
          tmp___0 = temp;
        } else {
#line 1215
          tmp___0 = dt;
        }
#line 1215
        temp = tmp___0;
#line 1216
        l += nm1 - i;
#line 1212
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1218
      temp = epsmch * temp;
#line 1219
      if (temp == 0.) {
#line 1220
        temp = epsmch;
      }
    }
#line 1223
    x[j] = (qtb[j] - sum) / temp;
#line 1196
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1228
  j = 0;
  {
#line 1228
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1228
    if (! (j < n)) {
#line 1228
      goto while_break___2;
    }
#line 1229
    wa1[j] = 0.;
#line 1230
    wa2[j] = diag[j] * x[j];
#line 1228
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1232
  qnorm = denorm(n, & wa2[0]);
  }
#line 1233
  if (qnorm <= delta) {
#line 1234
    return (0);
  }
#line 1239
  l = 0;
#line 1240
  j = 0;
  {
#line 1240
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1240
    if (! (j < n)) {
#line 1240
      goto while_break___3;
    }
#line 1241
    temp = qtb[j];
#line 1242
    i = j;
    {
#line 1242
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1242
      if (! (i < n)) {
#line 1242
        goto while_break___4;
      }
#line 1243
      wa1[i] += r[l] * temp;
#line 1244
      l ++;
#line 1242
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1246
    wa1[j] /= diag[j];
#line 1240
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1251
  gnorm = denorm(n, & wa1[0]);
#line 1252
  sgnorm = 0.;
#line 1253
  alpha = delta / qnorm;
  }
#line 1254
  if (gnorm != 0.) {
#line 1257
    j = 0;
    {
#line 1257
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1257
      if (! (j < n)) {
#line 1257
        goto while_break___5;
      }
#line 1258
      wa1[j] = (wa1[j] / gnorm) / diag[j];
#line 1257
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1259
    l = 0;
#line 1260
    j = 0;
    {
#line 1260
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1260
      if (! (j < n)) {
#line 1260
        goto while_break___6;
      }
#line 1261
      sum = 0.;
#line 1262
      i = j;
      {
#line 1262
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1262
        if (! (i < n)) {
#line 1262
          goto while_break___7;
        }
#line 1263
        sum += r[l] * wa1[i];
#line 1264
        l ++;
#line 1262
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1266
      wa2[j] = sum;
#line 1260
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1268
    temp = denorm(n, & wa2[0]);
#line 1269
    sgnorm = (gnorm / temp) / temp;
#line 1272
    alpha = 0.;
    }
#line 1273
    if (sgnorm < delta) {
      {
#line 1274
      __cil_tmp35 = denorm(n, & qtb[0]);
#line 1274
      bnorm = __cil_tmp35;
#line 1279
      d0 = ((bnorm / gnorm) * (bnorm / qnorm)) * (sgnorm / delta);
#line 1280
      d1 = sgnorm / delta;
#line 1281
      d2 = d0 - delta / qnorm;
#line 1282
      d3 = delta / qnorm;
#line 1283
      d4 = sgnorm / delta;
#line 1284
      __cil_tmp36 = sqrt(d2 * d2 + (1. - d3 * d3) * (1. - d4 * d4));
#line 1284
      d0 = (d0 - (delta / qnorm) * (d1 * d1)) + __cil_tmp36;
#line 1286
      d1 = sgnorm / delta;
#line 1287
      alpha = ((delta / qnorm) * (1. - d1 * d1)) / d0;
      }
    }
  }
#line 1293
  if (sgnorm <= delta) {
#line 1293
    tmp___1 = sgnorm;
  } else {
#line 1293
    tmp___1 = delta;
  }
#line 1293
  temp = (1. - alpha) * tmp___1;
#line 1294
  j = 0;
  {
#line 1294
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1294
    if (! (j < n)) {
#line 1294
      goto while_break___8;
    }
#line 1295
    x[j] = temp * wa1[j] + alpha * x[j];
#line 1294
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1297
  return (0);
}
}
#line 1322 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static double denorm(int n , double x[] ) 
{ 
  double ss ;
  double __cil_tmp4 ;
  static double rdwarf ;
  static double rgiant ;
  static double xabs ;
  static double x1max ;
  static double x3max ;
  static int i ;
  static double s1 ;
  static double s2 ;
  static double s3 ;
  static double agiant ;
  static double floatn ;
  double ret_val ;
  double td ;
  double tmp ;
  int __cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;

  {
#line 1326
  if (n < 8) {
#line 1327
    ss = 0.;
    {
#line 1329
    if (n == 8) {
#line 1329
      goto case_8;
    }
#line 1331
    if (n == 7) {
#line 1331
      goto case_7;
    }
#line 1333
    if (n == 6) {
#line 1333
      goto case_6;
    }
#line 1335
    if (n == 5) {
#line 1335
      goto case_5;
    }
#line 1337
    if (n == 4) {
#line 1337
      goto case_4;
    }
#line 1339
    if (n == 3) {
#line 1339
      goto case_3;
    }
#line 1341
    if (n == 2) {
#line 1341
      goto case_2;
    }
#line 1343
    if (n == 1) {
#line 1343
      goto case_1;
    }
#line 1328
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1330
    ss += x[7] * x[7];
    case_7: /* CIL Label */ 
#line 1332
    ss += x[6] * x[6];
    case_6: /* CIL Label */ 
#line 1334
    ss += x[5] * x[5];
    case_5: /* CIL Label */ 
#line 1336
    ss += x[4] * x[4];
    case_4: /* CIL Label */ 
#line 1338
    ss += x[3] * x[3];
    case_3: /* CIL Label */ 
#line 1340
    ss += x[2] * x[2];
    case_2: /* CIL Label */ 
#line 1342
    ss += x[1] * x[1];
    case_1: /* CIL Label */ 
#line 1344
    ss += x[0] * x[0];
    switch_break: /* CIL Label */ ;
    }
    {
#line 1346
    __cil_tmp4 = sqrt(ss);
    }
#line 1346
    return (__cil_tmp4);
  } else {
#line 1349
    rdwarf = 3.834e-20;
#line 1350
    rgiant = 1.304e+19;
#line 1358
    s1 = 0.;
#line 1359
    s2 = 0.;
#line 1360
    s3 = 0.;
#line 1361
    x1max = 0.;
#line 1362
    x3max = 0.;
#line 1363
    floatn = (double )(n + 1);
#line 1364
    agiant = rgiant / floatn;
#line 1365
    i = 0;
    {
#line 1365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1365
      if (! (i < n)) {
#line 1365
        goto while_break;
      }
#line 1366
      if (td >= 0.) {
#line 1366
        tmp = td;
      } else {
#line 1366
        tmp = - td;
      }
#line 1366
      td = x[i];
#line 1366
      xabs = tmp;
#line 1369
      if (xabs > rdwarf) {
#line 1369
        if (xabs < agiant) {
#line 1370
          td = xabs;
#line 1371
          s2 += td * td;
        } else {
#line 1369
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1374
      if (xabs <= rdwarf) {
#line 1375
        if (xabs <= x3max) {
#line 1376
          if (xabs != 0.) {
#line 1377
            td = xabs / x3max;
#line 1378
            s3 += td * td;
          }
        } else {
#line 1381
          td = x3max / xabs;
#line 1382
          s3 = 1. + s3 * (td * td);
#line 1383
          x3max = xabs;
        }
      } else
#line 1388
      if (xabs <= x1max) {
#line 1389
        td = xabs / x1max;
#line 1390
        s1 += td * td;
      } else {
#line 1392
        td = x1max / xabs;
#line 1393
        s1 = 1. + s1 * (td * td);
#line 1394
        x1max = xabs;
      }
#line 1365
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1400
    if (s1 != 0.) {
      {
#line 1401
      __cil_tmp20 = sqrt(s1 + (s2 / x1max) / x1max);
#line 1401
      ret_val = x1max * __cil_tmp20;
      }
    } else
#line 1403
    if (s2 == 0.) {
      {
#line 1404
      __cil_tmp21 = sqrt(s3);
#line 1404
      ret_val = x3max * __cil_tmp21;
      }
    } else
#line 1406
    if (s2 >= x3max) {
      {
#line 1407
      ret_val = sqrt(s2 * (1. + (x3max / s2) * (x3max * s3)));
      }
    } else {
      {
#line 1409
      ret_val = sqrt(x3max * (s2 / x3max + x3max * s3));
      }
    }
#line 1413
    return (ret_val);
  }
}
}
#line 1429 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int dfdjc1(void *fdata , int (*fcn)(void * , int  , double * , double * , int  ) ,
                  int n , double x[] , double fvec[] , double fjac[] , int ldfjac ,
                  int ml , int mu , double epsfcn , double *wa1 , double *wa2 ) 
{ 
  int iflag ;
  double temp ;
  int msum ;
  double h ;
  int i ;
  int j ;
  int k ;
  double eps ;
  int nm1 ;
  double tmp ;
  double __cil_tmp23 ;
  double tmp___0 ;
  int __cil_tmp25 ;
  int tmp___1 ;
  double tmp___2 ;
  int __cil_tmp28 ;
  int tmp___3 ;
  double tmp___4 ;

  {
#line 1445
  iflag = 0;
#line 1451
  nm1 = n - 1;
#line 1454
  if (epsfcn >= 2.22000000001e-15) {
#line 1454
    tmp = epsfcn;
  } else {
#line 1454
    tmp = 2.22000000001e-15;
  }
  {
#line 1454
  __cil_tmp23 = sqrt(tmp);
#line 1454
  eps = __cil_tmp23;
#line 1455
  msum = (ml + mu) + 1;
  }
#line 1456
  if (msum >= n) {
#line 1458
    j = 0;
    {
#line 1458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1458
      if (! (j < n)) {
#line 1458
        goto while_break;
      }
#line 1459
      temp = x[j];
#line 1460
      if (temp >= 0.) {
#line 1460
        tmp___0 = temp;
      } else {
#line 1460
        tmp___0 = - temp;
      }
#line 1460
      h = eps * tmp___0;
#line 1461
      if (h == 0.) {
#line 1462
        h = eps;
      }
      {
#line 1463
      x[j] = temp + h;
#line 1464
      iflag = (*fcn)(fdata, n, & x[0], wa1 + 0, 1);
      }
#line 1464
      if (iflag < 0) {
#line 1465
        goto while_break;
      }
#line 1466
      x[j] = temp;
#line 1467
      i = 0;
      {
#line 1467
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1467
        if (! (i < n)) {
#line 1467
          goto while_break___0;
        }
#line 1468
        fjac[i + j * ldfjac] = (*(wa1 + i) - fvec[i]) / h;
#line 1467
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1458
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1472
    k = 0;
    {
#line 1472
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1472
      if (! (k < msum)) {
#line 1472
        goto while_break___1;
      }
#line 1473
      j = k;
      {
#line 1473
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1473
        if (! tmp___1) {
#line 1473
          goto while_break___2;
        }
#line 1474
        *(wa2 + j) = x[j];
#line 1475
        if (*(wa2 + j) >= 0.) {
#line 1475
          tmp___2 = *(wa2 + j);
        } else {
#line 1475
          tmp___2 = - *(wa2 + j);
        }
#line 1475
        h = eps * tmp___2;
#line 1476
        if (h == 0.) {
#line 1477
          h = eps;
        }
#line 1478
        x[j] = *(wa2 + j) + h;
#line 1473
        j += msum;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1480
      iflag = (*fcn)(fdata, n, & x[0], wa1 + 0, 1);
      }
#line 1480
      if (iflag < 0) {
#line 1481
        goto while_break___1;
      }
#line 1482
      j = k;
      {
#line 1482
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1482
        if (! tmp___3) {
#line 1482
          goto while_break___3;
        }
#line 1483
        x[j] = *(wa2 + j);
#line 1484
        if (*(wa2 + j) >= 0.) {
#line 1484
          tmp___4 = *(wa2 + j);
        } else {
#line 1484
          tmp___4 = - *(wa2 + j);
        }
#line 1484
        h = eps * tmp___4;
#line 1485
        if (h == 0.) {
#line 1486
          h = eps;
        }
#line 1487
        i = 0;
        {
#line 1487
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1487
          if (! (i < n)) {
#line 1487
            goto while_break___4;
          }
#line 1488
          fjac[i + j * ldfjac] = 0.;
#line 1489
          if (i >= j - mu) {
#line 1489
            if (i <= j + ml) {
#line 1490
              fjac[i + j * ldfjac] = (*(wa1 + i) - fvec[i]) / h;
            }
          }
#line 1487
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1482
        j += msum;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1472
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1495
  return (iflag);
}
}
#line 1508 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int dqform(int m , int n , double *q , int ldq , double *wa ) 
{ 
  int i ;
  int j ;
  int k ;
  int l ;
  int minmn ;
  double sum ;
  int tmp ;
  double temp ;

  {
#line 1519
  if (m <= n) {
#line 1519
    tmp = m;
  } else {
#line 1519
    tmp = n;
  }
#line 1519
  minmn = tmp;
#line 1520
  if (minmn >= 2) {
#line 1521
    j = 1;
    {
#line 1521
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1521
      if (! (j < minmn)) {
#line 1521
        goto while_break;
      }
#line 1522
      i = 0;
      {
#line 1522
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1522
        if (! (i < j)) {
#line 1522
          goto while_break___0;
        }
#line 1523
        *(q + (i + j * ldq)) = 0.;
#line 1522
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1521
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1528
  if (m > n) {
#line 1529
    j = n;
    {
#line 1529
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1529
      if (! (j < m)) {
#line 1529
        goto while_break___1;
      }
#line 1530
      i = 0;
      {
#line 1530
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1530
        if (! (i < m)) {
#line 1530
          goto while_break___2;
        }
#line 1531
        *(q + (i + j * ldq)) = 0.;
#line 1530
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1533
      *(q + (j + j * ldq)) = 1.;
#line 1529
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1538
  l = 0;
  {
#line 1538
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1538
    if (! (l < minmn)) {
#line 1538
      goto while_break___3;
    }
#line 1539
    k = (minmn - l) - 1;
#line 1540
    i = k;
    {
#line 1540
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1540
      if (! (i < m)) {
#line 1540
        goto while_break___4;
      }
#line 1541
      *(wa + i) = *(q + (i + k * ldq));
#line 1542
      *(q + (i + k * ldq)) = 0.;
#line 1540
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1544
    *(q + (k + k * ldq)) = 1.;
#line 1545
    if (*(wa + k) != 0.) {
#line 1546
      j = k;
      {
#line 1546
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1546
        if (! (j < m)) {
#line 1546
          goto while_break___5;
        }
#line 1548
        sum = 0.;
#line 1549
        i = k;
        {
#line 1549
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1549
          if (! (i < m)) {
#line 1549
            goto while_break___6;
          }
#line 1550
          sum += *(q + (i + j * ldq)) * *(wa + i);
#line 1549
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1551
        temp = sum / *(wa + k);
#line 1552
        i = k;
        {
#line 1552
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1552
          if (! (i < m)) {
#line 1552
            goto while_break___7;
          }
#line 1553
          *(q + (i + j * ldq)) -= temp * *(wa + i);
#line 1552
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1546
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1538
    l ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1557
  return (0);
}
}
#line 1581 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dnsq.c"
static int dqrfac(int m , int n , double *a , int lda , bool pivot , int *ipvt , double *sigma ,
                  double *acnorm , double *wa ) 
{ 
  int kmax ;
  int i ;
  int j ;
  int k ;
  int minmn ;
  double ajnorm ;
  int jp1 ;
  double sum ;
  double __cil_tmp18 ;
  int tmp ;
  double temp ;
  double __cil_tmp21 ;
  double temp___0 ;
  double tmp___0 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;

  {
#line 1600
  j = 0;
  {
#line 1600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1600
    if (! (j < n)) {
#line 1600
      goto while_break;
    }
    {
#line 1601
    *(acnorm + j) = denorm(m, a + j * lda);
#line 1602
    *(sigma + j) = *(acnorm + j);
#line 1603
    *(wa + j) = *(sigma + j);
    }
#line 1604
    if (pivot) {
#line 1605
      *(ipvt + j) = j;
    }
#line 1600
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1609
  if (m <= n) {
#line 1609
    tmp = m;
  } else {
#line 1609
    tmp = n;
  }
#line 1609
  minmn = tmp;
#line 1610
  j = 0;
  {
#line 1610
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1610
    if (! (j < minmn)) {
#line 1610
      goto while_break___0;
    }
#line 1611
    if (pivot) {
#line 1613
      kmax = j;
#line 1614
      k = j;
      {
#line 1614
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1614
        if (! (k < n)) {
#line 1614
          goto while_break___1;
        }
#line 1615
        if (*(sigma + k) > *(sigma + kmax)) {
#line 1616
          kmax = k;
        }
#line 1614
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1619
      if (kmax != j) {
#line 1620
        i = 0;
        {
#line 1620
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1620
          if (! (i < m)) {
#line 1620
            goto while_break___2;
          }
#line 1622
          temp = *(a + (i + j * lda));
#line 1623
          *(a + (i + j * lda)) = *(a + (i + kmax * lda));
#line 1624
          *(a + (i + kmax * lda)) = temp;
#line 1620
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1626
        *(sigma + kmax) = *(sigma + j);
#line 1627
        *(wa + kmax) = *(wa + j);
#line 1628
        k = *(ipvt + j);
#line 1629
        *(ipvt + j) = *(ipvt + kmax);
#line 1630
        *(ipvt + kmax) = k;
      }
    }
    {
#line 1636
    ajnorm = denorm(m - j, a + (j + j * lda));
    }
#line 1637
    if (ajnorm != 0.) {
#line 1638
      if (*(a + (j + j * lda)) < 0.) {
#line 1639
        ajnorm = - ajnorm;
      }
#line 1640
      i = j;
      {
#line 1640
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1640
        if (! (i < m)) {
#line 1640
          goto while_break___3;
        }
#line 1641
        *(a + (i + j * lda)) /= ajnorm;
#line 1640
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1642
      *(a + (j + j * lda)) += 1.;
#line 1646
      jp1 = j + 1;
#line 1647
      if (n > jp1) {
#line 1648
        k = jp1;
        {
#line 1648
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1648
          if (! (k < n)) {
#line 1648
            goto while_break___4;
          }
#line 1650
          sum = 0.;
#line 1651
          i = j;
          {
#line 1651
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1651
            if (! (i < m)) {
#line 1651
              goto while_break___5;
            }
#line 1652
            sum += *(a + (i + j * lda)) * *(a + (i + k * lda));
#line 1651
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1653
          temp___0 = sum / *(a + (j + j * lda));
#line 1654
          i = j;
          {
#line 1654
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1654
            if (! (i < m)) {
#line 1654
              goto while_break___6;
            }
#line 1655
            *(a + (i + k * lda)) -= temp___0 * *(a + (i + j * lda));
#line 1654
            i ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1656
          if (pivot) {
#line 1656
            if (*(sigma + k) != 0.) {
#line 1657
              temp___0 = *(a + (j + k * lda)) / *(sigma + k);
#line 1658
              temp___0 = 1. - temp___0 * temp___0;
#line 1659
              if (0. >= temp___0) {
#line 1659
                tmp___0 = 0.;
              } else {
#line 1659
                tmp___0 = temp___0;
              }
              {
#line 1659
              __cil_tmp24 = sqrt(tmp___0);
              }
#line 1659
              *(sigma + k) *= __cil_tmp24;
#line 1660
              temp___0 = *(sigma + k) / *(wa + k);
#line 1661
              if (0.0500000000001 * (temp___0 * temp___0) <= 2.22000000001e-15) {
                {
#line 1662
                *(sigma + k) = denorm(m - jp1, a + (jp1 + k * lda));
#line 1663
                *(wa + k) = *(sigma + k);
                }
              }
            }
          }
#line 1648
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 1669
    *(sigma + j) = - ajnorm;
#line 1610
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1671
  return (0);
}
}
#line 23 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dhsx.c"
int dhsx_debug  =    0;
#line 25
static void simplexinit(int di , double *cp , double **p , double *s , double sv ,
                        int ii ) ;
#line 26
static double trypoint(int di , double *cp , double **p , double *y , int hix , double hpfac ,
                       double (*funk)(void * , double [] ) , void *fdata , double *tryp ) ;
#line 50 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dhsx.c"
int dhsx(double *rv , int di , double *cp , double *s , double ftol , double athr ,
         int maxit , double (*funk)(void * , double * ) , void *fdata ) 
{ 
  int ii ;
  int i ;
  int j ;
  int nit ;
  int nsp ;
  double tryy ;
  double ysave ;
  double tol ;
  double **p ;
  double *y ;
  double **p2 ;
  double *y2 ;
  int lox ;
  int hix ;
  int nhix ;
  double *tryp ;
  double *__cil_tmp26 ;
  double **__cil_tmp27 ;
  double *__cil_tmp28 ;
  double **__cil_tmp29 ;
  double *__cil_tmp30 ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  double __cil_tmp34 ;
  char *__cil_tmp35 ;
  int __cil_tmp36 ;
  double __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  double sum ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  char *__cil_tmp46 ;
  double scale ;
  int lox2 ;
  int __cil_tmp49 ;
  double dist ;
  double tt ;
  int __cil_tmp52 ;
  double __cil_tmp53 ;
  int __cil_tmp54 ;
  double __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  double sum___0 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  char *__cil_tmp65 ;
  double __cil_tmp66 ;
  int __cil_tmp67 ;
  double __cil_tmp68 ;
  double __cil_tmp69 ;
  double __cil_tmp70 ;
  int __cil_tmp71 ;
  double __cil_tmp72 ;
  int __cil_tmp73 ;
  double sum___1 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  int __cil_tmp77 ;

  {
  {
#line 61
  ii = 0;
#line 64
  nsp = di + 1;
#line 75
  tryp = dvector(0, di - 1);
#line 76
  p = dmatrix(0, nsp - 1, 0, di - 1);
#line 77
  y = dvector(0, nsp - 1);
#line 78
  p2 = dmatrix(0, nsp - 1, 0, di - 1);
#line 79
  y2 = dvector(0, nsp - 1);
#line 82
  simplexinit(di, cp, p, s, 1., ii);
#line 85
  i = 0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < nsp)) {
#line 85
      goto while_break;
    }
    {
#line 86
    *(y + i) = (*funk)(fdata, *(p + i));
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  lox = 0;
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < nsp)) {
#line 90
      goto while_break___0;
    }
#line 91
    if (*(y + i) < *(y + lox)) {
#line 92
      lox = i;
    }
#line 90
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 94
  tryy = (*funk)(fdata, cp);
  }
#line 96
  if (dhsx_debug) {
    {
#line 96
    __cil_tmp35 = debPdv(di, cp);
#line 96
    printf(" initial point %s = %e\n", __cil_tmp35, tryy);
    }
  }
#line 100
  if (*(y + lox) > tryy) {
#line 102
    if (dhsx_debug) {
      {
#line 102
      printf(" initial point is better than surrounding simplex\n");
      }
    }
#line 105
    i = 0;
    {
#line 105
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 105
      if (! (i < nsp)) {
#line 105
        goto while_break___1;
      }
#line 106
      if (i == lox) {
#line 107
        goto while_continue___1;
      }
#line 108
      j = 0;
      {
#line 108
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 108
        if (! (j < di)) {
#line 108
          goto while_break___2;
        }
#line 109
        *(*(p + i) + j) += *(cp + j) - *(*(p + lox) + j);
#line 108
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 110
      *(y + i) = (*funk)(fdata, *(p + i));
      }
#line 105
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 113
    j = 0;
    {
#line 113
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 113
      if (! (j < di)) {
#line 113
        goto while_break___3;
      }
#line 114
      *(*(p + lox) + j) = *(cp + j);
#line 113
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 115
    *(y + lox) = tryy;
  }
#line 120
  j = 0;
  {
#line 120
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 120
    if (! (j < di)) {
#line 120
      goto while_break___4;
    }
#line 122
    sum = 0.;
#line 122
    i = 0;
    {
#line 122
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 122
      if (! (i < nsp)) {
#line 122
        goto while_break___5;
      }
#line 123
      sum += *(*(p + i) + j);
#line 122
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 124
    *(cp + j) = sum;
#line 120
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 128
  nit = 0;
  {
#line 128
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 128
    if (! 1) {
#line 128
      goto while_break___6;
    }
#line 131
    hix = 0;
#line 131
    nhix = hix;
#line 131
    lox = nhix;
#line 132
    i = 0;
    {
#line 132
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 132
      if (! (i < nsp)) {
#line 132
        goto while_break___7;
      }
#line 133
      if (*(y + i) < *(y + lox)) {
#line 134
        lox = i;
      }
#line 135
      if (*(y + i) > *(y + hix)) {
#line 136
        nhix = hix;
#line 137
        hix = i;
      } else
#line 138
      if (*(y + i) > *(y + nhix)) {
#line 139
        nhix = i;
      }
#line 132
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 143
    tol = *(y + hix) - *(y + lox);
#line 146
    if (dhsx_debug) {
      {
#line 147
      printf("Current vs =\n");
#line 148
      i = 0;
      }
      {
#line 148
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 148
        if (! (i < nsp)) {
#line 148
          goto while_break___8;
        }
        {
#line 149
        __cil_tmp44 = debPdv(di, *(p + i));
#line 149
        printf(" %d: %s\n\230\001", i, __cil_tmp44);
        }
#line 148
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 150
      __cil_tmp46 = debPdv(nsp, y);
#line 150
      printf("Current errs = %s\n", __cil_tmp46);
#line 151
      printf("Current y[lox] = %e, y[hix] = %e\n", *(y + lox), *(y + hix));
      }
    }
#line 157
    if (tol < ftol) {
#line 157
      if (*(y + lox) < athr) {
#line 157
        if (nit < maxit) {
#line 159
          scale = 0.;
#line 163
          if (dhsx_debug) {
            {
#line 163
            printf(" nit %d, tol %e\n\230\001", nit, tol);
            }
          }
#line 167
          tryy = 1. / (double )nsp;
#line 168
          j = 0;
          {
#line 168
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 168
            if (! (j < di)) {
#line 168
              goto while_break___9;
            }
#line 169
            *(cp + j) *= tryy;
#line 168
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 172
          i = 0;
          {
#line 172
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 172
            if (! (i < nsp)) {
#line 172
              goto while_break___10;
            }
#line 173
            dist = 0.;
#line 174
            j = 0;
            {
#line 174
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 174
              if (! (j < di)) {
#line 174
                goto while_break___11;
              }
#line 175
              tt = (*(cp + j) - *(*(p + i) + j)) / *(s + j);
#line 176
              dist += tt * tt;
#line 174
              j ++;
            }
            while_break___11: /* CIL Label */ ;
            }
            {
#line 178
            __cil_tmp53 = sqrt(dist);
            }
#line 178
            scale += __cil_tmp53;
#line 172
            i ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 180
          scale /= (double )nsp;
#line 182
          if (dhsx_debug) {
            {
#line 182
            printf(" ave scale = %f\n\230\001", scale);
            }
          }
#line 186
          scale *= 10.;
#line 187
          if (scale > 1.) {
#line 188
            scale = 1.;
          }
#line 191
          ii ++;
#line 191
          if (ii >= di + 1) {
#line 192
            ii = 0;
          }
          {
#line 195
          simplexinit(di, cp, p2, s, scale, ii);
#line 198
          i = 0;
          }
          {
#line 198
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 198
            if (! (i < nsp)) {
#line 198
              goto while_break___12;
            }
            {
#line 199
            *(y2 + i) = (*funk)(fdata, *(p2 + i));
            }
#line 198
            i ++;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 202
          lox2 = 0;
#line 203
          i = 0;
          {
#line 203
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 203
            if (! (i < nsp)) {
#line 203
              goto while_break___13;
            }
#line 204
            if (*(y2 + i) < *(y2 + lox2)) {
#line 205
              lox2 = i;
            }
#line 203
            i ++;
          }
          while_break___13: /* CIL Label */ ;
          }
#line 208
          if (dhsx_debug) {
            {
#line 208
            printf(" y2lox %f ylox %f\n", *(y2 + lox2), *(y + lox));
            }
          }
#line 213
          if (*(y2 + lox2) < *(y + lox)) {
#line 216
            if (dhsx_debug) {
              {
#line 216
              printf(" restarting\n");
              }
            }
#line 219
            i = 0;
            {
#line 219
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 219
              if (! (i < nsp)) {
#line 219
                goto while_break___14;
              }
#line 220
              j = 0;
              {
#line 220
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 220
                if (! (j < di)) {
#line 220
                  goto while_break___15;
                }
#line 221
                *(*(p + i) + j) = *(*(p2 + i) + j);
#line 220
                j ++;
              }
              while_break___15: /* CIL Label */ ;
              }
#line 222
              *(y + i) = *(y2 + i);
#line 219
              i ++;
            }
            while_break___14: /* CIL Label */ ;
            }
#line 227
            j = 0;
            {
#line 227
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 227
              if (! (j < di)) {
#line 227
                goto while_break___16;
              }
#line 229
              sum___0 = 0.;
#line 229
              i = 0;
              {
#line 229
              while (1) {
                while_continue___17: /* CIL Label */ ;
#line 229
                if (! (i < nsp)) {
#line 229
                  goto while_break___17;
                }
#line 230
                sum___0 += *(*(p + i) + j);
#line 229
                i ++;
              }
              while_break___17: /* CIL Label */ ;
              }
#line 231
              *(cp + j) = sum___0;
#line 227
              j ++;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 235
            hix = 0;
#line 235
            nhix = hix;
#line 235
            lox = nhix;
#line 236
            i = 0;
            {
#line 236
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 236
              if (! (i < nsp)) {
#line 236
                goto while_break___18;
              }
#line 237
              if (*(y + i) < *(y + lox)) {
#line 238
                lox = i;
              }
#line 239
              if (*(y + i) > *(y + hix)) {
#line 240
                nhix = hix;
#line 241
                hix = i;
              } else
#line 242
              if (*(y + i) > *(y + nhix)) {
#line 243
                nhix = i;
              }
#line 236
              i ++;
            }
            while_break___18: /* CIL Label */ ;
            }
#line 247
            tol = *(y + hix) - *(y + lox);
          }
        }
      }
    }
#line 251
    if (tol < ftol) {
#line 251
      if (*(y + lox) < athr) {
        _L: /* CIL Label */ 
#line 256
        tryy = 1. / (double )nsp;
#line 257
        j = 0;
        {
#line 257
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 257
          if (! (j < di)) {
#line 257
            goto while_break___19;
          }
#line 258
          *(cp + j) *= tryy;
#line 257
          j ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 260
        if (dhsx_debug) {
          {
#line 260
          __cil_tmp65 = debPdv(di, cp);
#line 260
          printf("C point = %s\n", __cil_tmp65);
          }
        }
        {
#line 262
        tryy = (*funk)(fdata, cp);
        }
#line 264
        if (tryy > *(y + lox)) {
#line 266
          if (dhsx_debug) {
            {
#line 266
            printf("C point val %f is not best, using sx %d val %f instead\n", tryy,
                   lox, *(y + lox));
            }
          }
#line 268
          tryy = *(y + lox);
#line 269
          j = 0;
          {
#line 269
          while (1) {
            while_continue___20: /* CIL Label */ ;
#line 269
            if (! (j < di)) {
#line 269
              goto while_break___20;
            }
#line 270
            *(cp + j) = *(*(p + lox) + j);
#line 269
            j ++;
          }
          while_break___20: /* CIL Label */ ;
          }
        } else
#line 273
        if (dhsx_debug) {
          {
#line 273
          printf("C point val %f is best\n", tryy);
          }
        }
        {
#line 275
        free_dvector(y2, 0, nsp - 1);
#line 276
        free_dmatrix(p2, 0, nsp - 1, 0, di - 1);
#line 277
        free_dvector(y, 0, nsp - 1);
#line 278
        free_dmatrix(p, 0, nsp - 1, 0, di - 1);
#line 279
        free_dvector(tryp, 0, di - 1);
        }
#line 281
        if (dhsx_debug) {
          {
#line 281
          printf("Total itterations = %d\n", nit);
          }
        }
#line 283
        if (rv != (void *)0) {
#line 284
          *rv = tryy;
        }
#line 285
        if (nit + 1 >= maxit) {
#line 286
          return (1);
        }
#line 287
        return (0);
      } else {
#line 251
        goto _L___23;
      }
    } else
    _L___23: /* CIL Label */ 
#line 251
    if (nit + 1 >= maxit) {
#line 251
      goto _L;
    }
#line 291
    if (nit > 3) {
#line 294
      if (dhsx_debug) {
        {
#line 294
        printf("dhsx: try moving high point %d through oposite face", hix);
        }
      }
      {
#line 296
      tryy = trypoint(di, cp, p, y, hix, - 1., funk, fdata, tryp);
      }
    }
#line 300
    if (nit > 3) {
#line 300
      if (tryy <= *(y + lox)) {
#line 302
        if (dhsx_debug) {
          {
#line 302
          printf("dhsx: moving high through oposite face worked");
          }
        }
        {
#line 304
        tryy = trypoint(di, cp, p, y, hix, 2., funk, fdata, tryp);
        }
      } else {
#line 300
        goto _L___25;
      }
    } else
    _L___25: /* CIL Label */ 
#line 309
    if (nit <= 3) {
      _L___24: /* CIL Label */ 
#line 312
      if (dhsx_debug) {
        {
#line 312
        printf("dhsx: else try moving contracting point %d, y[ini] = %f", hix, *(y + hix));
        }
      }
      {
#line 314
      ysave = *(y + hix);
#line 315
      tryy = trypoint(di, cp, p, y, hix, 0.400000000001, funk, fdata, tryp);
      }
#line 317
      if (tryy >= ysave) {
#line 319
        if (dhsx_debug) {
          {
#line 319
          printf("dhsx: contracting didn\'t work, try contracting other points to low");
          }
        }
#line 323
        i = 0;
        {
#line 323
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 323
          if (! (i < nsp)) {
#line 323
            goto while_break___21;
          }
#line 324
          if (i != lox) {
#line 325
            j = 0;
            {
#line 325
            while (1) {
              while_continue___22: /* CIL Label */ ;
#line 325
              if (! (j < di)) {
#line 325
                goto while_break___22;
              }
#line 326
              *(*(p + i) + j) = 0.400000000001 * *(*(p + i) + j) + (1. - 0.400000000001) * *(*(p + lox) + j);
#line 325
              j ++;
            }
            while_break___22: /* CIL Label */ ;
            }
            {
#line 327
            *(y + i) = (*funk)(fdata, *(p + i));
            }
          }
#line 323
          i ++;
        }
        while_break___21: /* CIL Label */ ;
        }
#line 331
        j = 0;
        {
#line 331
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 331
          if (! (j < di)) {
#line 331
            goto while_break___23;
          }
#line 333
          sum___1 = 0.;
#line 333
          i = 0;
          {
#line 333
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 333
            if (! (i < nsp)) {
#line 333
              goto while_break___24;
            }
#line 334
            sum___1 += *(*(p + i) + j);
#line 333
            i ++;
          }
          while_break___24: /* CIL Label */ ;
          }
#line 335
          *(cp + j) = sum___1;
#line 331
          j ++;
        }
        while_break___23: /* CIL Label */ ;
        }
      } else
#line 339
      if (dhsx_debug) {
        {
#line 339
        printf("dhsx: contracting point %d worked, tryy = %e, ysave = %e\230\001",
               hix, tryy, ysave);
        }
      }
    } else
#line 309
    if (tryy >= *(y + nhix)) {
#line 309
      goto _L___24;
    }
#line 128
    nit ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  return (0);
}
}
#line 350 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dhsx.c"
static double trypoint(int di , double *cp , double **p , double *y , int hix , double hpfac ,
                       double (*funk)(void * , double [] ) , void *fdata , double *tryp ) 
{ 
  int j ;
  double tt ;
  double tryy ;
  int __cil_tmp13 ;
  double __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 365
  tt = (1. - hpfac) / (double )di;
#line 366
  j = 0;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (j < di)) {
#line 366
      goto while_break;
    }
#line 367
    *(tryp + j) = *(cp + j) * tt - *(*(p + hix) + j) * (tt - hpfac);
#line 366
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  tryy = (*funk)(fdata, tryp);
  }
#line 373
  if (tryy < *(y + hix)) {
#line 375
    if (dhsx_debug) {
      {
#line 375
      printf("Try gave improved %e from sx %d", tryy, hix);
      }
    }
#line 377
    *(y + hix) = tryy;
#line 379
    j = 0;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (j < di)) {
#line 379
        goto while_break___0;
      }
#line 380
      *(cp + j) += *(tryp + j) - *(*(p + hix) + j);
#line 381
      *(*(p + hix) + j) = *(tryp + j);
#line 379
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 385
  if (dhsx_debug) {
    {
#line 385
    printf("Try gave worse %e from sx %d", tryy, hix);
    }
  }
#line 388
  return (tryy);
}
}
#line 394 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/dhsx.c"
static void simplexinit(int di , double *cp , double **p , double *s , double sv ,
                        int ii ) 
{ 
  double bb ;
  double hh ;
  double rr ;
  double __cil_tmp10 ;
  int i ;
  int j ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;

  {
  {
#line 403
  hh = 0.5;
#line 404
  __cil_tmp10 = sqrt(3.);
#line 404
  rr = __cil_tmp10 / 2.;
#line 406
  i = 0;
  }
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! (i < di + 1)) {
#line 406
      goto while_break;
    }
#line 432
    bb = 1.;
#line 433
    j = 0;
    {
#line 433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 433
      if (! (j < di)) {
#line 433
        goto while_break___0;
      }
#line 434
      if (j > ii) {
#line 435
        *(*(p + i) + j) = *(cp + j) + (sv * *(s + j)) * 0.;
      } else
#line 436
      if (j == ii) {
#line 437
        *(*(p + i) + j) = *(cp + j) + (sv * *(s + j)) * bb;
      } else
#line 438
      if (ii == di) {
#line 438
        if (j == di - 1) {
#line 439
          *(*(p + i) + j) = *(cp + j) + ((sv * *(s + j)) * - 1.) * bb;
        } else {
#line 441
          *(*(p + i) + j) = *(cp + j) + ((sv * *(s + j)) * - hh) * bb;
        }
      } else {
#line 441
        *(*(p + i) + j) = *(cp + j) + ((sv * *(s + j)) * - hh) * bb;
      }
#line 442
      bb *= rr;
#line 433
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 445
    ii ++;
#line 445
    if (ii >= di + 1) {
#line 446
      ii = 0;
    }
#line 406
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if (dhsx_debug) {
#line 450
    i = 0;
    {
#line 450
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 450
      if (! (i < di + 1)) {
#line 450
        goto while_break___1;
      }
      {
#line 451
      __cil_tmp15 = debPdv(di, *(p + i));
#line 451
      printf(" p[%d] = %s\n\313U", i, __cil_tmp15);
      }
#line 450
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 45 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.h"
aat_atree_t *aat_anew(cmp_f cmp ) ;
#line 46
void aat_adelete(aat_atree_t *tree ) ;
#line 47
void *aat_afind(aat_atree_t *tree , void *data ) ;
#line 48
int aat_ainsert(aat_atree_t *tree , void *data ) ;
#line 49
int aat_aerase(aat_atree_t *tree , void *data ) ;
#line 50
size_t aat_asize(aat_atree_t *tree ) ;
#line 53
aat_atrav_t *aat_atnew(void) ;
#line 54
void aat_atdelete(aat_atrav_t *trav ) ;
#line 55
void *aat_atfirst(aat_atrav_t *trav , aat_atree_t *tree ) ;
#line 56
void *aat_atlast(aat_atrav_t *trav , aat_atree_t *tree ) ;
#line 57
void *aat_atnext(aat_atrav_t *trav ) ;
#line 58
void *aat_atprev(aat_atrav_t *trav ) ;
#line 90 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
static aat_anode_t *new_node(aat_atree_t *tree , void *data ) 
{ 
  aat_anode_t *rn ;
  void *__cil_tmp4 ;

  {
  {
#line 92
  __cil_tmp4 = malloc(sizeof(*rn));
#line 92
  rn = (aat_anode_t *)__cil_tmp4;
  }
#line 94
  if (rn == (void *)0) {
#line 95
    return (tree->nil);
  }
#line 97
  rn->level = 1;
#line 98
  rn->data = data;
#line 99
  rn->link[1] = tree->nil;
#line 99
  rn->link[0] = rn->link[1];
#line 101
  return (rn);
}
}
#line 105 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
aat_atree_t *aat_anew(cmp_f cmp ) 
{ 
  aat_atree_t *rt ;
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 107
  __cil_tmp3 = malloc(sizeof(*rt));
#line 107
  rt = (aat_atree_t *)__cil_tmp3;
  }
#line 109
  if (rt == (void *)0) {
#line 110
    return ((aat_atree_t *)((void *)0));
  }
  {
#line 113
  __cil_tmp4 = malloc(sizeof(*(rt->nil)));
#line 113
  rt->nil = (aat_anode_t *)__cil_tmp4;
  }
#line 114
  if (rt->nil == (void *)0) {
    {
#line 115
    free(rt);
    }
#line 116
    return ((aat_atree_t *)((void *)0));
  }
#line 119
  (rt->nil)->data = (void *)0;
#line 120
  (rt->nil)->level = 0;
#line 121
  (rt->nil)->link[1] = rt->nil;
#line 121
  (rt->nil)->link[0] = (rt->nil)->link[1];
#line 124
  rt->root = rt->nil;
#line 125
  rt->cmp = cmp;
#line 126
  rt->size = (size_t )0;
#line 128
  return (rt);
}
}
#line 132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void aat_adelete(aat_atree_t *tree ) 
{ 
  aat_anode_t *it ;
  aat_anode_t *save ;

  {
#line 134
  it = tree->root;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (it != tree->nil)) {
#line 138
      goto while_break;
    }
#line 139
    if (it->link[0] == tree->nil) {
      {
#line 141
      save = it->link[1];
#line 142
      free(it);
      }
    } else {
#line 146
      save = it->link[0];
#line 147
      it->link[0] = save->link[1];
#line 148
      save->link[1] = it;
    }
#line 151
    it = save;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  free(tree->nil);
#line 156
  free(tree);
  }
  return;
}
}
#line 160 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void *aat_afind(aat_atree_t *tree , void *data ) 
{ 
  aat_anode_t *it ;
  int cmp ;
  int __cil_tmp5 ;

  {
#line 162
  it = tree->root;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (it != tree->nil)) {
#line 164
      goto while_break;
    }
    {
#line 165
    __cil_tmp5 = (*(tree->cmp))(it->data, data);
#line 165
    cmp = __cil_tmp5;
    }
#line 167
    if (cmp == 0) {
#line 168
      goto while_break;
    }
#line 170
    it = it->link[cmp < 0];
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return (it->data);
}
}
#line 180 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
int aat_ainsert(aat_atree_t *tree , void *data ) 
{ 
  aat_anode_t *__cil_tmp3 ;
  aat_anode_t *it ;
  aat_anode_t *path[64] ;
  int top ;
  int dir ;
  int cmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  aat_anode_t *__cil_tmp11 ;
  aat_anode_t *save ;
  aat_anode_t *save___0 ;

  {
#line 182
  if (tree->root == tree->nil) {
    {
#line 184
    tree->root = new_node(tree, data);
    }
#line 185
    if (tree->root == tree->nil) {
#line 186
      return (0);
    }
  } else {
#line 189
    it = tree->root;
#line 191
    top = 0;
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 194
      if (! 1) {
#line 194
        goto while_break;
      }
      {
#line 197
      __cil_tmp9 = top;
#line 197
      top ++;
#line 197
      path[__cil_tmp9] = it;
#line 198
      cmp = (*(tree->cmp))(it->data, data);
      }
#line 198
      if (cmp == 0) {
#line 198
        if (it->data < data) {
#line 198
          cmp = - 1;
        } else
#line 198
        if (it->data > data) {
#line 198
          cmp = 1;
        }
      }
#line 199
      dir = cmp < 0;
#line 201
      if (it->link[dir] == tree->nil) {
#line 202
        goto while_break;
      }
#line 204
      it = it->link[dir];
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 208
    it->link[dir] = new_node(tree, data);
    }
#line 209
    if (it->link[dir] == tree->nil) {
#line 210
      return (0);
    }
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 213
      top --;
#line 213
      if (! (top >= 0)) {
#line 213
        goto while_break___0;
      }
#line 215
      if (top != 0) {
#line 216
        dir = (path[top - 1])->link[1] == path[top];
      }
      {
#line 218
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 218
        if (((path[top])->link[0])->level == (path[top])->level) {
#line 218
          if ((path[top])->level != 0) {
#line 218
            save = (path[top])->link[0];
#line 218
            (path[top])->link[0] = save->link[1];
#line 218
            save->link[1] = path[top];
#line 218
            path[top] = save;
          }
        }
#line 218
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 219
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 219
        if ((((path[top])->link[1])->link[1])->level == (path[top])->level) {
#line 219
          if ((path[top])->level != 0) {
#line 219
            save___0 = (path[top])->link[1];
#line 219
            (path[top])->link[1] = save___0->link[0];
#line 219
            save___0->link[0] = path[top];
#line 219
            path[top] = save___0;
#line 219
            ((path[top])->level) ++;
          }
        }
#line 219
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 222
      if (top != 0) {
#line 223
        (path[top - 1])->link[dir] = path[top];
      } else {
#line 225
        tree->root = path[top];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 229
  (tree->size) ++;
#line 231
  return (1);
}
}
#line 238 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
int aat_aerase(aat_atree_t *tree , void *data ) 
{ 
  aat_anode_t *it ;
  aat_anode_t *path[64] ;
  int top ;
  int dir ;
  int cmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int dir2 ;
  aat_anode_t *heir ;
  aat_anode_t *prev ;
  int __cil_tmp13 ;
  aat_anode_t *up ;
  aat_anode_t *save ;
  aat_anode_t *save___0 ;
  aat_anode_t *save___1 ;
  aat_anode_t *save___2 ;
  aat_anode_t *save___3 ;

  {
#line 240
  if (tree->root == tree->nil) {
#line 241
    return (0);
  } else {
#line 243
    it = tree->root;
#line 245
    top = 0;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! 1) {
#line 248
        goto while_break;
      }
#line 249
      __cil_tmp8 = top;
#line 249
      top ++;
#line 249
      path[__cil_tmp8] = it;
#line 251
      if (it == tree->nil) {
#line 252
        return (0);
      }
      {
#line 254
      cmp = (*(tree->cmp))(it->data, data);
      }
#line 254
      if (cmp == 0) {
#line 254
        if (it->data < data) {
#line 254
          cmp = - 1;
        } else
#line 254
        if (it->data > data) {
#line 254
          cmp = 1;
        }
      }

#line 255
      if (cmp == 0) {
#line 256
        goto while_break;
      }
#line 258
      dir = cmp < 0;
#line 259
      it = it->link[dir];
    }
    while_break: /* CIL Label */ ;
    }
#line 263
    if (it->link[0] == tree->nil) {
      _L: /* CIL Label */ 
#line 267
      dir2 = it->link[0] == tree->nil;
#line 270
      top --;
#line 270
      if (top != 0) {
#line 271
        (path[top - 1])->link[dir] = it->link[dir2];
      } else {
#line 273
        tree->root = it->link[1];
      }
      {
#line 275
      free(it);
      }
    } else
#line 263
    if (it->link[1] == tree->nil) {
#line 263
      goto _L;
    } else {
#line 279
      heir = it->link[1];
#line 280
      prev = it;
      {
#line 282
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 282
        if (! (heir->link[0] != tree->nil)) {
#line 282
          goto while_break___0;
        }
#line 283
        prev = heir;
#line 283
        __cil_tmp13 = top;
#line 283
        top ++;
#line 283
        path[__cil_tmp13] = prev;
#line 284
        heir = heir->link[0];
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 291
      it->data = heir->data;
#line 292
      prev->link[prev == it] = heir->link[1];
#line 293
      free(heir);
      }
    }
    {
#line 297
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 297
      top --;
#line 297
      if (! (top >= 0)) {
#line 297
        goto while_break___1;
      }
#line 298
      up = path[top];
#line 300
      if (top != 0) {
#line 301
        dir = (path[top - 1])->link[1] == up;
      }
#line 304
      if ((up->link[0])->level < up->level - 1) {
        _L___26: /* CIL Label */ 
#line 307
        (up->level) --;
#line 307
        if ((up->link[1])->level > up->level) {
#line 308
          (up->link[1])->level = up->level;
        }
        {
#line 311
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 311
          if ((up->link[0])->level == up->level) {
#line 311
            if (up->level != 0) {
#line 311
              save = up->link[0];
#line 311
              up->link[0] = save->link[1];
#line 311
              save->link[1] = up;
#line 311
              up = save;
            }
          }
#line 311
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 312
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 312
          if (((up->link[1])->link[0])->level == (up->link[1])->level) {
#line 312
            if ((up->link[1])->level != 0) {
#line 312
              save___0 = (up->link[1])->link[0];
#line 312
              (up->link[1])->link[0] = save___0->link[1];
#line 312
              save___0->link[1] = up->link[1];
#line 312
              up->link[1] = save___0;
            }
          }
#line 312
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 313
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 313
          if ((((up->link[1])->link[1])->link[0])->level == ((up->link[1])->link[1])->level) {
#line 313
            if (((up->link[1])->link[1])->level != 0) {
#line 313
              save___1 = ((up->link[1])->link[1])->link[0];
#line 313
              ((up->link[1])->link[1])->link[0] = save___1->link[1];
#line 313
              save___1->link[1] = (up->link[1])->link[1];
#line 313
              (up->link[1])->link[1] = save___1;
            }
          }
#line 313
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 314
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 314
          if (((up->link[1])->link[1])->level == up->level) {
#line 314
            if (up->level != 0) {
#line 314
              save___2 = up->link[1];
#line 314
              up->link[1] = save___2->link[0];
#line 314
              save___2->link[0] = up;
#line 314
              up = save___2;
#line 314
              (up->level) ++;
            }
          }
#line 314
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 315
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 315
          if ((((up->link[1])->link[1])->link[1])->level == (up->link[1])->level) {
#line 315
            if ((up->link[1])->level != 0) {
#line 315
              save___3 = (up->link[1])->link[1];
#line 315
              (up->link[1])->link[1] = save___3->link[0];
#line 315
              save___3->link[0] = up->link[1];
#line 315
              up->link[1] = save___3;
#line 315
              ((up->link[1])->level) ++;
            }
          }
#line 315
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 304
      if ((up->link[1])->level < up->level - 1) {
#line 304
        goto _L___26;
      }
#line 319
      if (top != 0) {
#line 320
        (path[top - 1])->link[dir] = up;
      } else {
#line 322
        tree->root = up;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 326
  (tree->size) --;
#line 328
  return (1);
}
}
#line 332 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
size_t aat_asize(aat_atree_t *tree ) 
{ 


  {
#line 334
  return (tree->size);
}
}
#line 338 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
aat_atrav_t *aat_atnew(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 340
  __cil_tmp1 = malloc(sizeof(aat_atrav_t ));
  }
#line 340
  return (__cil_tmp1);
}
}
#line 344 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void aat_atdelete(aat_atrav_t *trav ) 
{ 


  {
  {
#line 346
  free(trav);
  }
  return;
}
}
#line 353 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
static void *start(aat_atrav_t *trav , aat_atree_t *tree , int dir ) 
{ 
  size_t __cil_tmp4 ;

  {
#line 356
  trav->tree = tree;
#line 357
  trav->it = tree->root;
#line 358
  trav->top = (size_t )0;
#line 361
  if (trav->it != tree->nil) {
    {
#line 362
    while (1) {
      while_continue: /* CIL Label */ ;
#line 362
      if (! ((trav->it)->link[dir] != tree->nil)) {
#line 362
        goto while_break;
      }
#line 363
      __cil_tmp4 = trav->top;
#line 363
      (trav->top) ++;
#line 363
      trav->path[__cil_tmp4] = trav->it;
#line 364
      trav->it = (trav->it)->link[dir];
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 369
  return ((trav->it)->data);
}
}
#line 376 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
static void *move(aat_atrav_t *trav , int dir ) 
{ 
  aat_anode_t *nil ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  aat_anode_t *last ;

  {
#line 378
  nil = (trav->tree)->nil;
#line 380
  if ((trav->it)->link[dir] != nil) {
#line 382
    __cil_tmp4 = trav->top;
#line 382
    (trav->top) ++;
#line 382
    trav->path[__cil_tmp4] = trav->it;
#line 383
    trav->it = (trav->it)->link[dir];
    {
#line 385
    while (1) {
      while_continue: /* CIL Label */ ;
#line 385
      if (! ((trav->it)->link[! dir] != nil)) {
#line 385
        goto while_break;
      }
#line 386
      __cil_tmp5 = trav->top;
#line 386
      (trav->top) ++;
#line 386
      trav->path[__cil_tmp5] = trav->it;
#line 387
      trav->it = (trav->it)->link[! dir];
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 395
      if (trav->top == 0UL) {
#line 396
        trav->it = nil;
#line 397
        goto while_break___0;
      }
#line 400
      last = trav->it;
#line 401
      (trav->top) --;
#line 401
      trav->it = trav->path[trav->top];
#line 394
      if (! (last == (trav->it)->link[dir])) {
#line 394
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 406
  return ((trav->it)->data);
}
}
#line 410 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void *aat_atfirst(aat_atrav_t *trav , aat_atree_t *tree ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 412
  __cil_tmp3 = start(trav, tree, 0);
  }
#line 412
  return (__cil_tmp3);
}
}
#line 416 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void *aat_atlast(aat_atrav_t *trav , aat_atree_t *tree ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 418
  __cil_tmp3 = start(trav, tree, 1);
  }
#line 418
  return (__cil_tmp3);
}
}
#line 422 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void *aat_atnext(aat_atrav_t *trav ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 424
  __cil_tmp2 = move(trav, 1);
  }
#line 424
  return (__cil_tmp2);
}
}
#line 428 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/numlib/aatree.c"
void *aat_atprev(aat_atrav_t *trav ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 430
  __cil_tmp2 = move(trav, 0);
  }
#line 430
  return (__cil_tmp2);
}
}
#line 16 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_version.h"
int yajl_version(void) ;
#line 3 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_version.c"
int yajl_version(void) 
{ 


  {
#line 5
  return (20100);
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__)) void __assert_fail(char const   *__assertion ,
                                                        char const   *__file , unsigned int __line ,
                                                        char const   *__function ) ;
#line 74
extern  __attribute__((__nothrow__)) void __assert_perror_fail(int __errnum , char const   *__file ,
                                                               unsigned int __line ,
                                                               char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__)) void __assert(char const   *__assertion , char const   *__file ,
                                                   int __line ) ;
#line 121 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.h"
yajl_val yajl_tree_parse(char const   *input , char *error_buffer , size_t error_buffer_size ) ;
#line 131
void yajl_tree_free(yajl_val v ) ;
#line 147
yajl_val yajl_tree_get(yajl_val n , char const   **path , yajl_type type ) ;
#line 151
yajl_val yajl_tree_get_first(yajl_val n , char const   *key , yajl_type type ) ;
#line 44 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parse.h"
char const   *yajl_status_to_string(yajl_status stat___0 ) ;
#line 113
yajl_handle yajl_alloc(yajl_callbacks *callbacks , yajl_alloc_funcs *afs , void *ctx ) ;
#line 172
int yajl_config(yajl_handle h , yajl_option opt  , ...) ;
#line 175
void yajl_free(yajl_handle handle ) ;
#line 182
yajl_status yajl_parse(yajl_handle hand , unsigned char const   *jsonText , size_t jsonTextLen ) ;
#line 195
yajl_status yajl_complete_parse(yajl_handle hand ) ;
#line 207
unsigned char *yajl_get_error(yajl_handle hand , int verbose___0 , unsigned char const   *jsonText ,
                              size_t jsonTextLen ) ;
#line 223
size_t yajl_get_bytes_consumed(yajl_handle hand ) ;
#line 226
void yajl_free_error(yajl_handle hand , unsigned char *str ) ;
#line 32 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_alloc.h"
void yajl_set_default_alloc_funcs(yajl_alloc_funcs *yaf ) ;
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.h"
yajl_buf yajl_buf_alloc(yajl_alloc_funcs *alloc ) ;
#line 40
void yajl_buf_free(yajl_buf buf ) ;
#line 43
void yajl_buf_append(yajl_buf buf , void const   *data , size_t len ) ;
#line 46
void yajl_buf_clear(yajl_buf buf ) ;
#line 49
unsigned char const   *yajl_buf_data(yajl_buf buf ) ;
#line 52
size_t yajl_buf_len(yajl_buf buf ) ;
#line 55
void yajl_buf_truncate(yajl_buf buf , size_t len ) ;
#line 52 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.h"
yajl_lexer yajl_lex_alloc(yajl_alloc_funcs *alloc , unsigned int allowComments , unsigned int validateUTF8 ) ;
#line 56
void yajl_lex_free(yajl_lexer lxr ) ;
#line 80
yajl_tok yajl_lex_lex(yajl_lexer lexer , unsigned char const   *jsonText , size_t jsonTextLen ,
                      size_t *offset , unsigned char const   **outBuf , size_t *outLen ) ;
#line 85
yajl_tok yajl_lex_peek(yajl_lexer lexer , unsigned char const   *jsonText , size_t jsonTextLen ,
                       size_t offset ) ;
#line 103
char const   *yajl_lex_error_to_string(yajl_lex_error error___0 ) ;
#line 107
yajl_lex_error yajl_lex_get_error(yajl_lexer lexer ) ;
#line 110
size_t yajl_lex_current_offset(yajl_lexer lexer ) ;
#line 113
size_t yajl_lex_current_line(yajl_lexer lexer ) ;
#line 117
size_t yajl_lex_current_char(yajl_lexer lexer ) ;
#line 62 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.h"
yajl_status yajl_do_parse(yajl_handle hand , unsigned char const   *jsonText , size_t jsonTextLen ) ;
#line 66
yajl_status yajl_do_finish(yajl_handle hand ) ;
#line 69
unsigned char *yajl_render_error_string(yajl_handle hand , unsigned char const   *jsonText ,
                                        size_t jsonTextLen , int verbose___0 ) ;
#line 75
longlong yajl_parse_integer(unsigned char const   *number , unsigned int length ) ;
#line 65 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static yajl_val value_alloc(yajl_type type ) 
{ 
  yajl_val v ;
  void *__cil_tmp3 ;

  {
  {
#line 69
  v = (yajl_val )malloc(sizeof(*v));
  }
#line 70
  if (v == (void *)0) {
#line 70
    return ((yajl_val )((void *)0));
  }
  {
#line 71
  memset(v, 0, sizeof(*v));
#line 72
  v->type = type;
  }
#line 74
  return (v);
}
}
#line 77 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static void yajl_object_free(yajl_val v ) 
{ 
  size_t i ;
  size_t __cil_tmp3 ;

  {
#line 81
  if (! (v != (void *)0 && (unsigned int )v->type == 3U)) {
#line 81
    return;
  }
#line 83
  i = (size_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < v->u.object.len)) {
#line 83
      goto while_break;
    }
    {
#line 85
    free((char *)*(v->u.object.keys + i));
#line 86
    *(v->u.object.keys + i) = (char const   *)((void *)0);
#line 87
    yajl_tree_free(*(v->u.object.values + i));
#line 88
    *(v->u.object.values + i) = (yajl_val )((void *)0);
    }
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  free((void *)v->u.object.keys);
#line 92
  free(v->u.object.values);
#line 93
  free(v);
  }
  return;
}
}
#line 96 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static void yajl_array_free(yajl_val v ) 
{ 
  size_t i ;
  size_t __cil_tmp3 ;

  {
#line 100
  if (! (v != (void *)0 && (unsigned int )v->type == 4U)) {
#line 100
    return;
  }
#line 102
  i = (size_t )0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < v->u.array.len)) {
#line 102
      goto while_break;
    }
    {
#line 104
    yajl_tree_free(*(v->u.array.values + i));
#line 105
    *(v->u.array.values + i) = (yajl_val )((void *)0);
    }
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  free(v->u.array.values);
#line 109
  free(v);
  }
  return;
}
}
#line 119 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int context_push(context_t *ctx , yajl_val v ) 
{ 
  stack_elem_t *stack ;
  void *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 123
  stack = (stack_elem_t *)malloc(sizeof(*stack));
  }
#line 124
  if (stack == (void *)0) {
#line 125
    if (ctx->errbuf != (void *)0) {
      {
#line 125
      snprintf(ctx->errbuf, ctx->errbuf_size, "Out of memory");
      }
    }
#line 125
    return (12);
  }
  {
#line 126
  memset(stack, 0, sizeof(*stack));
#line 132
  stack->value = v;
#line 133
  stack->next = ctx->stack;
#line 134
  ctx->stack = stack;
  }
#line 136
  return (0);
}
}
#line 139 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static yajl_val context_pop(context_t *ctx ) 
{ 
  stack_elem_t *stack ;
  yajl_val v ;

  {
#line 144
  if (ctx->stack == (void *)0) {
#line 145
    if (ctx->errbuf != (void *)0) {
      {
#line 145
      snprintf(ctx->errbuf, ctx->errbuf_size, "context_pop: Bottom of stack reached prematurely\220");
      }
    }
#line 145
    return ((yajl_val )((void *)0));
  }
  {
#line 147
  stack = ctx->stack;
#line 148
  ctx->stack = stack->next;
#line 150
  v = stack->value;
#line 152
  free(stack);
  }
#line 154
  return (v);
}
}
#line 157 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int object_add_keyval(context_t *ctx , yajl_val obj , char *key , yajl_val value ) 
{ 
  char const   **tmpk ;
  yajl_val *tmpv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  size_t __cil_tmp14 ;

  {
  {
#line 172
  tmpk = (char const   **)realloc((void *)obj->u.object.keys, sizeof(*(obj->u.object.keys)) * (obj->u.object.len + 1UL));
  }
#line 173
  if (tmpk == (void *)0) {
#line 174
    if (ctx->errbuf != (void *)0) {
      {
#line 174
      snprintf(ctx->errbuf, ctx->errbuf_size, "Out of memory");
      }
    }
#line 174
    return (12);
  }
  {
#line 175
  obj->u.object.keys = tmpk;
#line 177
  tmpv = (yajl_val *)realloc(obj->u.object.values, sizeof(*(obj->u.object.values)) * (obj->u.object.len + 1UL));
  }
#line 178
  if (tmpv == (void *)0) {
#line 179
    if (ctx->errbuf != (void *)0) {
      {
#line 179
      snprintf(ctx->errbuf, ctx->errbuf_size, "Out of memory");
      }
    }
#line 179
    return (12);
  }
#line 180
  obj->u.object.values = tmpv;
#line 182
  *(obj->u.object.keys + obj->u.object.len) = (char const   *)key;
#line 183
  *(obj->u.object.values + obj->u.object.len) = value;
#line 184
  (obj->u.object.len) ++;
#line 186
  return (0);
}
}
#line 189 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int array_add_value(context_t *ctx , yajl_val array , yajl_val value ) 
{ 
  yajl_val *tmp ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *__cil_tmp9 ;
  size_t __cil_tmp10 ;

  {
  {
#line 203
  tmp = (yajl_val *)realloc(array->u.array.values, sizeof(*(array->u.array.values)) * (array->u.array.len + 1UL));
  }
#line 205
  if (tmp == (void *)0) {
#line 206
    if (ctx->errbuf != (void *)0) {
      {
#line 206
      snprintf(ctx->errbuf, ctx->errbuf_size, "Out of memory");
      }
    }
#line 206
    return (12);
  }
#line 207
  array->u.array.values = tmp;
#line 208
  *(array->u.array.values + array->u.array.len) = value;
#line 209
  (array->u.array.len) ++;
#line 211
  return (0);
}
}
#line 218 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int context_add_value(context_t *ctx , yajl_val v ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *key ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 235
  if (ctx->stack == (void *)0) {
#line 238
    ctx->root = v;
#line 239
    return (0);
  } else
#line 241
  if ((ctx->stack)->value != (void *)0) {
#line 241
    if ((unsigned int )((ctx->stack)->value)->type == 3U) {
#line 243
      if ((ctx->stack)->key == (void *)0) {
#line 245
        if (! (v != (void *)0 && (unsigned int )v->type == 1U)) {
#line 246
          if (ctx->errbuf != (void *)0) {
            {
#line 246
            snprintf(ctx->errbuf, ctx->errbuf_size, "context_add_value: Object key is not a string (%#04x)U",
                     (unsigned int )v->type);
            }
          }
#line 246
          return (22);
        }
        {
#line 249
        (ctx->stack)->key = v->u.string;
#line 250
        v->u.string = (char *)((void *)0);
#line 251
        free(v);
        }
#line 252
        return (0);
      } else {
        {
#line 258
        key = (ctx->stack)->key;
#line 259
        (ctx->stack)->key = (char *)((void *)0);
#line 260
        __cil_tmp7 = object_add_keyval(ctx, (ctx->stack)->value, key, v);
        }
#line 260
        return (__cil_tmp7);
      }
    } else {
#line 241
      goto _L___31;
    }
  } else
  _L___31: /* CIL Label */ 
#line 263
  if ((ctx->stack)->value != (void *)0) {
#line 263
    if ((unsigned int )((ctx->stack)->value)->type == 4U) {
      {
#line 265
      __cil_tmp8 = array_add_value(ctx, (ctx->stack)->value, v);
      }
#line 265
      return (__cil_tmp8);
    } else {
#line 263
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 269
    if (ctx->errbuf != (void *)0) {
      {
#line 269
      snprintf(ctx->errbuf, ctx->errbuf_size, "context_add_value: Cannot add value to a value of type %#04x (not a composite type)",
               (unsigned int )((ctx->stack)->value)->type);
      }
    }
#line 269
    return (22);

  }
}
}
#line 275 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_string(void *ctx , unsigned char const   *string , size_t string_length ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp5 ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp ;

  {
  {
#line 280
  v = value_alloc((yajl_type )1);
  }
#line 281
  if (v == (void *)0) {
#line 282
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 282
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memoryU");
      }
    }
#line 282
    return (0);
  }
  {
#line 284
  v->u.string = (char *)malloc(string_length + 1UL);
  }
#line 285
  if (v->u.string == (void *)0) {
    {
#line 287
    free(v);
    }
#line 288
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 288
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 288
    return (0);

  }
  {
#line 290
  memcpy(v->u.string, string, string_length);
#line 291
  *(v->u.string + string_length) = (char )0;
#line 293
  __cil_tmp7 = context_add_value(ctx, v);
  }
#line 293
  if (__cil_tmp7 == 0) {
#line 293
    tmp = 1;
  } else {
#line 293
    tmp = 0;
  }
#line 293
  return (tmp);
}
}
#line 296 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_number(void *ctx , char const   *string , size_t string_length ) 
{ 
  yajl_val v ;
  char *endptr ;
  yajl_val __cil_tmp6 ;
  void *__cil_tmp7 ;
  int *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  longlong __cil_tmp10 ;
  int *__cil_tmp11 ;
  int *__cil_tmp12 ;
  double __cil_tmp13 ;
  int *__cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;

  {
  {
#line 301
  v = value_alloc((yajl_type )2);
  }
#line 302
  if (v == (void *)0) {
#line 303
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 303
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 303
    return (0);
  }
  {
#line 305
  v->u.number.r = (char *)malloc(string_length + 1UL);
  }
#line 306
  if (v->u.number.r == (void *)0) {
    {
#line 308
    free(v);
    }
#line 309
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 309
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memoryU");
      }
    }
#line 309
    return (0);

  }
  {
#line 311
  memcpy(v->u.number.r, string, string_length);
#line 312
  *(v->u.number.r + string_length) = (char )0;
#line 314
  v->u.number.flags = (unsigned int )0;
#line 316
  __cil_tmp8 = __errno_location();
#line 316
  *__cil_tmp8 = 0;
#line 317
  __cil_tmp9 = strlen((char const   *)v->u.number.r);
#line 317
  __cil_tmp10 = yajl_parse_integer((unsigned char const   *)v->u.number.r, (unsigned int )__cil_tmp9);
#line 317
  v->u.number.i = __cil_tmp10;
#line 319
  __cil_tmp11 = __errno_location();
  }
#line 319
  if (*__cil_tmp11 == 0) {
#line 320
    v->u.number.flags |= (unsigned int )1;
  }
  {
#line 322
  endptr = (char *)((void *)0);
#line 323
  __cil_tmp12 = __errno_location();
#line 323
  *__cil_tmp12 = 0;
#line 324
  v->u.number.d = strtod((char const   *)v->u.number.r, & endptr);
#line 325
  __cil_tmp14 = __errno_location();
  }
#line 325
  if (endptr != (void *)0) {
#line 325
    if (*__cil_tmp14 == 0) {
#line 325
      if ((int )*endptr == 0) {
#line 326
        v->u.number.flags |= (unsigned int )2;
      }
    }
  }
  {
#line 328
  __cil_tmp15 = context_add_value(ctx, v);
  }
#line 328
  if (__cil_tmp15 == 0) {
#line 328
    tmp = 1;
  } else {
#line 328
    tmp = 0;
  }
#line 328
  return (tmp);
}
}
#line 331 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_start_map(void *ctx ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 335
  v = value_alloc((yajl_type )3);
  }
#line 336
  if (v == (void *)0) {
#line 337
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 337
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 337
    return (0);
  }
  {
#line 339
  v->u.object.keys = (char const   **)((void *)0);
#line 340
  v->u.object.values = (yajl_val *)((void *)0);
#line 341
  v->u.object.len = (size_t )0;
#line 343
  __cil_tmp4 = context_push(ctx, v);
  }
#line 343
  if (__cil_tmp4 == 0) {
#line 343
    tmp = 1;
  } else {
#line 343
    tmp = 0;
  }
#line 343
  return (tmp);
}
}
#line 346 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_end_map(void *ctx ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 350
  v = context_pop(ctx);
  }
#line 351
  if (v == (void *)0) {
#line 352
    return (0);
  }
  {
#line 354
  __cil_tmp4 = context_add_value(ctx, v);
  }
#line 354
  if (__cil_tmp4 == 0) {
#line 354
    tmp = 1;
  } else {
#line 354
    tmp = 0;
  }
#line 354
  return (tmp);
}
}
#line 357 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_start_array(void *ctx ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 361
  v = value_alloc((yajl_type )4);
  }
#line 362
  if (v == (void *)0) {
#line 363
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 363
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 363
    return (0);
  }
  {
#line 365
  v->u.array.values = (yajl_val *)((void *)0);
#line 366
  v->u.array.len = (size_t )0;
#line 368
  __cil_tmp4 = context_push(ctx, v);
  }
#line 368
  if (__cil_tmp4 == 0) {
#line 368
    tmp = 1;
  } else {
#line 368
    tmp = 0;
  }
#line 368
  return (tmp);
}
}
#line 371 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_end_array(void *ctx ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 375
  v = context_pop(ctx);
  }
#line 376
  if (v == (void *)0) {
#line 377
    return (0);
  }
  {
#line 379
  __cil_tmp4 = context_add_value(ctx, v);
  }
#line 379
  if (__cil_tmp4 == 0) {
#line 379
    tmp = 1;
  } else {
#line 379
    tmp = 0;
  }
#line 379
  return (tmp);
}
}
#line 382 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_boolean(void *ctx , int boolean_value ) 
{ 
  yajl_val v ;
  int tmp ;
  yajl_val __cil_tmp5 ;
  int __cil_tmp6 ;
  int tmp___0 ;

  {
#line 386
  if (boolean_value) {
#line 386
    tmp = 5;
  } else {
#line 386
    tmp = 6;
  }
  {
#line 386
  __cil_tmp5 = value_alloc((yajl_type )tmp);
#line 386
  v = __cil_tmp5;
  }
#line 387
  if (v == (void *)0) {
#line 388
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 388
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 388
    return (0);
  }
  {
#line 390
  __cil_tmp6 = context_add_value(ctx, v);
  }
#line 390
  if (__cil_tmp6 == 0) {
#line 390
    tmp___0 = 1;
  } else {
#line 390
    tmp___0 = 0;
  }
#line 390
  return (tmp___0);
}
}
#line 393 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
static int handle_null(void *ctx ) 
{ 
  yajl_val v ;
  yajl_val __cil_tmp3 ;
  int __cil_tmp4 ;
  int tmp ;

  {
  {
#line 397
  v = value_alloc((yajl_type )7);
  }
#line 398
  if (v == (void *)0) {
#line 399
    if (((context_t *)ctx)->errbuf != (void *)0) {
      {
#line 399
      snprintf(((context_t *)ctx)->errbuf, ((context_t *)ctx)->errbuf_size, "Out of memory");
      }
    }
#line 399
    return (0);
  }
  {
#line 401
  __cil_tmp4 = context_add_value(ctx, v);
  }
#line 401
  if (__cil_tmp4 == 0) {
#line 401
    tmp = 1;
  } else {
#line 401
    tmp = 0;
  }
#line 401
  return (tmp);
}
}
#line 407 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
yajl_val yajl_tree_parse(char const   *input , char *error_buffer , size_t error_buffer_size ) 
{ 
  static yajl_callbacks callbacks ;
  yajl_handle handle ;
  yajl_status status ;
  char *internal_err_str ;
  context_t ctx ;
  yajl_handle __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  yajl_status __cil_tmp11 ;
  yajl_status __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned char *__cil_tmp14 ;

  {
#line 410
  callbacks.yajl_null = (int (*)(void * ))(& handle_null);
#line 410
  callbacks.yajl_boolean = (int (*)(void * , int  ))(& handle_boolean);
#line 410
  callbacks.yajl_integer = (int (*)(void * , long  ))((int (*)(void * , longlong  ))((void *)0));
#line 410
  callbacks.yajl_double = (int (*)(void * , double  ))((int (*)(void * , double  ))((void *)0));
#line 410
  callbacks.yajl_number = (int (*)(void * , char const   * , unsigned long  ))(& handle_number);
#line 410
  callbacks.yajl_string = (int (*)(void * , unsigned char const   * , unsigned long  ))(& handle_string);
#line 410
  callbacks.yajl_c_comment = (int (*)(void * , unsigned char const   * , unsigned int  ))((int (*)(void * ,
                                                                                                   unsigned char const   * ,
                                                                                                   unsigned int  ))((void *)0));
#line 410
  callbacks.yajl_cpp_comment = (int (*)(void * , unsigned char const   * , unsigned int  ))((int (*)(void * ,
                                                                                                     unsigned char const   * ,
                                                                                                     unsigned int  ))((void *)0));
#line 410
  callbacks.yajl_start_map = (int (*)(void * ))(& handle_start_map);
#line 410
  callbacks.yajl_map_key = (int (*)(void * , unsigned char const   * , unsigned long  ))(& handle_string);
#line 410
  callbacks.yajl_end_map = (int (*)(void * ))(& handle_end_map);
#line 410
  callbacks.yajl_start_array = (int (*)(void * ))(& handle_start_array);
#line 410
  callbacks.yajl_end_array = (int (*)(void * ))(& handle_end_array);
#line 430
  ctx.stack = (stack_elem_t *)((void *)0);
#line 430
  ctx.root = (yajl_val )((void *)0);
#line 430
  ctx.errbuf = (char *)((void *)0);
#line 430
  ctx.errbuf_size = (size_t )0;
#line 432
  ctx.errbuf = error_buffer;
#line 433
  ctx.errbuf_size = error_buffer_size;
#line 435
  if (error_buffer != (void *)0) {
    {
#line 436
    memset(error_buffer, 0, error_buffer_size);
    }
  }
  {
#line 438
  handle = yajl_alloc(& callbacks, (yajl_alloc_funcs *)((void *)0), & ctx);
#line 439
  yajl_config(handle, (yajl_option )1, 1);
#line 441
  __cil_tmp10 = strlen(input);
#line 441
  __cil_tmp11 = yajl_parse(handle, (unsigned char const   *)((unsigned char *)input),
                           __cil_tmp10);
#line 441
  status = __cil_tmp11;
#line 444
  status = yajl_complete_parse(handle);
  }
#line 445
  if ((unsigned int )status != 0U) {
#line 446
    if (error_buffer != (void *)0) {
#line 446
      if (error_buffer_size > 0UL) {
        {
#line 447
        __cil_tmp13 = strlen(input);
#line 447
        __cil_tmp14 = yajl_get_error(handle, 1, (unsigned char const   *)input, __cil_tmp13);
#line 447
        internal_err_str = (char *)__cil_tmp14;
#line 450
        snprintf(error_buffer, error_buffer_size, "%s", internal_err_str);
#line 451
        (*(handle->alloc.free))(handle->alloc.ctx, internal_err_str);
        }
      }
    }
    {
#line 453
    yajl_free(handle);
    }
#line 454
    return ((yajl_val )((void *)0));
  }
  {
#line 457
  yajl_free(handle);
  }
#line 458
  return (ctx.root);
}
}
#line 462 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
yajl_val yajl_tree_get(yajl_val n , char const   **path , yajl_type type ) 
{ 
  size_t i ;
  size_t len ;
  int __cil_tmp6 ;
  size_t __cil_tmp7 ;
  char const   **__cil_tmp8 ;

  {
#line 464
  if (! path) {
#line 464
    return ((yajl_val )((void *)0));
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (n && *path)) {
#line 465
      goto while_break;
    }
#line 469
    if ((unsigned int )n->type != 3U) {
#line 470
      return ((yajl_val )((void *)0));
    }
#line 471
    len = n->u.object.len;
#line 472
    i = (size_t )0;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 472
      if (! (i < len)) {
#line 472
        goto while_break___0;
      }
      {
#line 473
      __cil_tmp6 = strcmp(*path, *(n->u.object.keys + i));
      }
#line 473
      if (! __cil_tmp6) {
#line 474
        n = *(n->u.object.values + i);
#line 475
        goto while_break___0;
      }
#line 472
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    if (i == len) {
#line 479
      return ((yajl_val )((void *)0));
    }
#line 480
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  if (n) {
#line 482
    if ((unsigned int )type != 8U) {
#line 482
      if ((unsigned int )type != (unsigned int )n->type) {
#line 483
        n = (yajl_val )((void *)0);
      }
    }
  }
#line 484
  return (n);
}
}
#line 491 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
yajl_val yajl_tree_get_first(yajl_val n , char const   *key , yajl_type type ) 
{ 
  size_t i ;
  size_t len ;
  yajl_val x ;
  int __cil_tmp7 ;
  yajl_val __cil_tmp8 ;
  size_t __cil_tmp9 ;
  yajl_val __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
#line 497
  if ((unsigned int )n->type == 3U) {
#line 498
    len = n->u.object.len;
#line 499
    i = (size_t )0;
    {
#line 499
    while (1) {
      while_continue: /* CIL Label */ ;
#line 499
      if (! (i < len)) {
#line 499
        goto while_break;
      }
      {
#line 500
      x = *(n->u.object.values + i);
#line 502
      __cil_tmp7 = strcmp(key, *(n->u.object.keys + i));
      }
#line 502
      if (! __cil_tmp7) {
#line 502
        if ((unsigned int )type == 8U) {
#line 504
          return (x);
        } else
#line 502
        if ((unsigned int )type == (unsigned int )x->type) {
#line 504
          return (x);
        }
      }
#line 506
      if (3U == (unsigned int )x->type) {
        _L: /* CIL Label */ 
        {
#line 508
        x = yajl_tree_get_first(x, key, type);
        }
#line 508
        if (x != (void *)0) {
#line 509
          return (x);
        }
      } else
#line 506
      if (4U == (unsigned int )x->type) {
#line 506
        goto _L;
      }
#line 499
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 512
    return ((yajl_val )((void *)0));
  } else
#line 514
  if ((unsigned int )n->type == 4U) {
#line 515
    len = n->u.array.len;
#line 516
    i = (size_t )0;
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 516
      if (! (i < len)) {
#line 516
        goto while_break___0;
      }
#line 517
      x = *(n->u.array.values + i);
#line 518
      if (3U == (unsigned int )x->type) {
        _L___32: /* CIL Label */ 
        {
#line 520
        x = yajl_tree_get_first(x, key, type);
        }
#line 520
        if (x != (void *)0) {
#line 521
          return (x);
        }
      } else
#line 518
      if (4U == (unsigned int )x->type) {
#line 518
        goto _L___32;
      }
#line 516
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 524
    return ((yajl_val )((void *)0));
  } else {
#line 527
    return ((yajl_val )((void *)0));
  }
#line 529
  return (n);
}
}
#line 532 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_tree.c"
void yajl_tree_free(yajl_val v ) 
{ 
  struct __anonstruct_320 *tmp ;
  struct __anonstruct_321 *tmp___0 ;

  {
#line 534
  if (v == (void *)0) {
#line 534
    return;
  }
#line 536
  if (v != (void *)0) {
#line 536
    if ((unsigned int )v->type == 1U) {
      {
#line 538
      free(v->u.string);
#line 539
      free(v);
      }
    } else {
#line 536
      goto _L___33;
    }
  } else
  _L___33: /* CIL Label */ 
#line 541
  if (v != (void *)0) {
#line 541
    if ((unsigned int )v->type == 2U) {
      {
#line 543
      free(v->u.number.r);
#line 544
      free(v);
      }
    } else {
#line 541
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 546
    if (v != (void *)0 && (unsigned int )v->type == 3U) {
#line 546
      tmp = & v->u.object;
    } else {
#line 546
      tmp = (struct __anonstruct_320 *)((void *)0);
    }
#line 546
    if (tmp) {
      {
#line 548
      yajl_object_free(v);
      }
    } else {
#line 550
      if (v != (void *)0 && (unsigned int )v->type == 4U) {
#line 550
        tmp___0 = & v->u.array;
      } else {
#line 550
        tmp___0 = (struct __anonstruct_321 *)((void *)0);
      }
#line 550
      if (tmp___0) {
        {
#line 552
        yajl_array_free(v);
        }
      } else {
        {
#line 556
        free(v);
        }
      }
    }
  }
  return;
}
}
#line 108 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.h"
int yajl_gen_config(yajl_gen g , yajl_gen_option opt  , ...) ;
#line 118
yajl_gen yajl_gen_alloc(yajl_alloc_funcs *afs ) ;
#line 121
void yajl_gen_free(yajl_gen g ) ;
#line 123
yajl_gen_status yajl_gen_integer(yajl_gen g , longlong number ) ;
#line 127
yajl_gen_status yajl_gen_double(yajl_gen g , double number ) ;
#line 128
yajl_gen_status yajl_gen_number(yajl_gen g , char const   *s , size_t l ) ;
#line 131
yajl_gen_status yajl_gen_string(yajl_gen g , unsigned char const   *str , size_t len ) ;
#line 134
yajl_gen_status yajl_gen_null(yajl_gen g ) ;
#line 135
yajl_gen_status yajl_gen_bool(yajl_gen g , int boolean ) ;
#line 136
yajl_gen_status yajl_gen_map_open(yajl_gen g ) ;
#line 137
yajl_gen_status yajl_gen_map_close(yajl_gen g ) ;
#line 138
yajl_gen_status yajl_gen_array_open(yajl_gen g ) ;
#line 139
yajl_gen_status yajl_gen_array_close(yajl_gen g ) ;
#line 140
yajl_gen_status yajl_gen_c_comment(yajl_gen g , unsigned char const   *str , unsigned int len ,
                                   int dlytoeol ) ;
#line 142
yajl_gen_status yajl_gen_cpp_comment(yajl_gen g , unsigned char const   *str , unsigned int len ) ;
#line 148
yajl_gen_status yajl_gen_get_buf(yajl_gen g , unsigned char const   **buf , size_t *len ) ;
#line 155
void yajl_gen_clear(yajl_gen g ) ;
#line 163
void yajl_gen_reset(yajl_gen g , char const   *sep ) ;
#line 23 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.h"
void yajl_string_encode(yajl_print_t print , void *ctx , unsigned char const   *str ,
                        size_t len , int escape_solidus ) ;
#line 29
void yajl_string_decode(yajl_buf buf , unsigned char const   *str , size_t len ) ;
#line 32
int yajl_string_validate_utf8(unsigned char const   *s , size_t len ) ;
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.c"
longlong yajl_parse_integer(unsigned char const   *number , unsigned int length ) 
{ 
  longlong ret ;
  long sign ;
  unsigned char const   *pos ;
  unsigned char const   *__cil_tmp6 ;
  unsigned char const   *__cil_tmp7 ;
  int *__cil_tmp8 ;
  long long tmp ;
  int *__cil_tmp10 ;
  long long tmp___0 ;
  int *__cil_tmp12 ;
  long long tmp___1 ;
  unsigned char const   *__cil_tmp14 ;

  {
#line 38
  ret = (longlong )0;
#line 39
  sign = (long )1;
#line 40
  pos = number;
#line 41
  if ((int )*pos == 45) {
#line 41
    pos ++;
#line 41
    sign = (long )(- 1);
  }
#line 42
  if ((int )*pos == 43) {
#line 42
    pos ++;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (pos < number + length)) {
#line 44
      goto while_break;
    }
#line 45
    if ((long long )ret > -1LL) {
      {
#line 46
      __cil_tmp8 = __errno_location();
#line 46
      *__cil_tmp8 = 34;
      }
#line 47
      if (sign == 1L) {
#line 47
        tmp = -1LL;
      } else {
#line 47
        tmp = 0LL;
      }
#line 47
      return ((longlong )tmp);
    }
#line 49
    ret *= (long )10;
#line 50
    if (-1LL - (long long )ret < (long long )((int )*pos - 48)) {
      {
#line 51
      __cil_tmp10 = __errno_location();
#line 51
      *__cil_tmp10 = 34;
      }
#line 52
      if (sign == 1L) {
#line 52
        tmp___0 = -1LL;
      } else {
#line 52
        tmp___0 = 0LL;
      }
#line 52
      return ((longlong )tmp___0);
    }
#line 54
    if ((int )*pos < 48) {
      _L: /* CIL Label */ 
      {
#line 55
      __cil_tmp12 = __errno_location();
#line 55
      *__cil_tmp12 = 34;
      }
#line 56
      if (sign == 1L) {
#line 56
        tmp___1 = -1LL;
      } else {
#line 56
        tmp___1 = 0LL;
      }
#line 56
      return ((longlong )tmp___1);
    } else
#line 54
    if ((int )*pos > 57) {
#line 54
      goto _L;
    }
#line 58
    __cil_tmp14 = pos;
#line 58
    pos ++;
#line 58
    ret += (long )((int )*__cil_tmp14 - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (sign * ret);
}
}
#line 65 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.c"
unsigned char *yajl_render_error_string(yajl_handle hand , unsigned char const   *jsonText ,
                                        size_t jsonTextLen , int verbose___0 ) 
{ 
  size_t offset ;
  unsigned char *str ;
  char const   *errorType ;
  char const   *errorText ;
  char text[72] ;
  char const   *arrow ;
  int tmp ;
  int tmp___0 ;
  yajl_lex_error __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  size_t memneeded ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  size_t start___0 ;
  size_t end ;
  size_t i ;
  size_t spacesNeeded ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t __cil_tmp28 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  int tmp___4 ;
  size_t __cil_tmp32 ;
  char *newStr ;
  unsigned long __cil_tmp34 ;
  unsigned long __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  void *__cil_tmp37 ;

  {
#line 68
  offset = hand->bytesConsumed;
#line 70
  errorType = (char const   *)((void *)0);
#line 71
  errorText = (char const   *)((void *)0);
#line 73
  arrow = "                     (right here) ------^\n";
#line 75
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 2) {
#line 76
    errorType = "parseU";
#line 77
    errorText = hand->parseError;
  } else
#line 78
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 3) {
    {
#line 79
    errorType = "lexical";
#line 80
    __cil_tmp13 = yajl_lex_get_error(hand->lexer);
#line 80
    __cil_tmp14 = yajl_lex_error_to_string(__cil_tmp13);
#line 80
    errorText = __cil_tmp14;
    }
  } else {
#line 82
    errorType = "unknown";
  }
  {
#line 86
  memneeded = (size_t )0;
#line 87
  __cil_tmp16 = strlen(errorType);
  }
  {
#line 87
  memneeded += __cil_tmp16;
#line 88
  __cil_tmp17 = strlen(" error");
  }
#line 88
  memneeded += __cil_tmp17;
#line 89
  if (errorText != (void *)0) {
    {
#line 90
    __cil_tmp18 = strlen(": ");
    }
    {
#line 90
    memneeded += __cil_tmp18;
#line 91
    __cil_tmp19 = strlen(errorText);
    }
#line 91
    memneeded += __cil_tmp19;
  }
  {
#line 93
  __cil_tmp20 = (*(hand->alloc.malloc))(hand->alloc.ctx, memneeded + 2UL);
#line 93
  str = (unsigned char *)__cil_tmp20;
  }
#line 94
  if (! str) {
#line 94
    return ((unsigned char *)((void *)0));
  }
  {
#line 95
  *(str + 0) = (unsigned char )0;
#line 96
  strcat((char *)str, errorType);
#line 97
  strcat((char *)str, " error");
  }
#line 98
  if (errorText != (void *)0) {
    {
#line 99
    strcat((char *)str, ": }\030\313U");
#line 100
    strcat((char *)str, errorText);
    }
  }
  {
#line 102
  strcat((char *)str, "\n\v}\030\313U");
  }
#line 107
  if (verbose___0) {
#line 111
    if (offset < 30UL) {
#line 111
      tmp___1 = 40UL - offset;
    } else {
#line 111
      tmp___1 = (unsigned long )10;
    }
#line 111
    spacesNeeded = tmp___1;
#line 112
    if (offset >= 30UL) {
#line 112
      tmp___2 = offset - 30UL;
    } else {
#line 112
      tmp___2 = (unsigned long )0;
    }
#line 112
    start___0 = tmp___2;
#line 113
    if (offset + 30UL > jsonTextLen) {
#line 113
      tmp___3 = jsonTextLen;
    } else {
#line 113
      tmp___3 = offset + 30UL;
    }
#line 113
    end = tmp___3;
#line 115
    i = (size_t )0;
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (! (i < spacesNeeded)) {
#line 115
        goto while_break;
      }
#line 115
      text[i] = (char )' ';
#line 115
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (start___0 < end)) {
#line 117
        goto while_break___0;
      }
#line 118
      if ((int )*(jsonText + start___0) != 10) {
#line 118
        if ((int )*(jsonText + start___0) != 13) {
#line 120
          text[i] = (char )*(jsonText + start___0);
        } else {
#line 124
          text[i] = (char )' ';
        }
      } else {
#line 124
        text[i] = (char )' ';
      }
#line 117
      __cil_tmp30 = i;
#line 117
      i ++;
#line 117
      __cil_tmp29 = start___0;
#line 117
      start___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    __cil_tmp32 = i;
#line 128
    i ++;
#line 128
    text[__cil_tmp32] = (char )'\n';
#line 129
    text[i] = (char )0;
#line 131
    __cil_tmp36 = strlen(arrow);
    }
    {
#line 131
    __cil_tmp35 = strlen((char const   *)((char *)((char *)text)));
    }
    {
#line 131
    __cil_tmp34 = strlen((char const   *)((char *)str));
#line 131
    __cil_tmp37 = (*(hand->alloc.malloc))(hand->alloc.ctx, (size_t )((unsigned int )(((__cil_tmp34 + __cil_tmp35) + __cil_tmp36) + 1UL)));
#line 131
    newStr = (char *)__cil_tmp37;
    }
#line 135
    if (newStr) {
      {
#line 136
      *(newStr + 0) = (char )0;
#line 137
      strcat((char *)newStr, (char const   *)((char *)str));
#line 138
      strcat((char *)newStr, (char const   *)((char *)text));
#line 139
      strcat((char *)newStr, arrow);
      }
    }
    {
#line 141
    (*(hand->alloc.free))(hand->alloc.ctx, str);
#line 142
    str = (unsigned char *)newStr;
    }
  }
#line 145
  return (str);
}
}
#line 159 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.c"
yajl_status yajl_do_finish(yajl_handle hand ) 
{ 
  yajl_status stat___0 ;
  yajl_status __cil_tmp3 ;
  int tmp ;

  {
  {
#line 162
  stat___0 = yajl_do_parse(hand, (unsigned char const   *)" ", (size_t )1);
  }
#line 164
  if ((unsigned int )stat___0 != 0U) {
#line 164
    return (stat___0);
  }
  {
#line 169
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 3) {
#line 169
    goto case_3;
  }
#line 169
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 2) {
#line 169
    goto case_3;
  }
#line 172
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 1) {
#line 172
    goto case_1;
  }
#line 172
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 12) {
#line 172
    goto case_1;
  }
#line 174
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 170
  return ((yajl_status )2);
  case_1: /* CIL Label */ 
  case_12: /* CIL Label */ 
#line 173
  return ((yajl_status )0);
  switch_default: /* CIL Label */ 
#line 175
  if (! (hand->flags & 16U)) {
#line 177
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 178
    hand->parseError = "premature EOF";
#line 179
    return ((yajl_status )2);
  }
#line 181
  return ((yajl_status )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 186 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_parser.c"
yajl_status yajl_do_parse(yajl_handle hand , unsigned char const   *jsonText , size_t jsonTextLen ) 
{ 
  yajl_tok tok ;
  unsigned char const   *buf ;
  size_t bufLen ;
  size_t *offset ;
  int tmp ;
  yajl_tok __cil_tmp9 ;
  yajl_state stateToPush ;
  yajl_tok __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned char const   *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  longlong i ;
  int *__cil_tmp24 ;
  longlong __cil_tmp25 ;
  int *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  double d ;
  unsigned char const   *__cil_tmp30 ;
  int *__cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  double __cil_tmp34 ;
  int *__cil_tmp35 ;
  int __cil_tmp36 ;
  int tmp___0 ;
  int __cil_tmp38 ;
  size_t __cil_tmp39 ;
  yajl_state s ;
  int tmp___1 ;
  void *__cil_tmp42 ;
  size_t __cil_tmp43 ;
  yajl_tok __cil_tmp44 ;
  unsigned char const   *__cil_tmp45 ;
  size_t __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int tmp___2 ;
  int __cil_tmp51 ;
  size_t __cil_tmp52 ;
  yajl_tok __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  yajl_tok __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  size_t __cil_tmp60 ;
  yajl_tok __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  size_t __cil_tmp65 ;

  {
#line 192
  offset = & hand->bytesConsumed;
#line 194
  *offset = (size_t )0;
  around_again: 
  {
#line 198
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 1) {
#line 198
    goto case_1;
  }
#line 216
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 2) {
#line 216
    goto case_2;
  }
#line 216
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 3) {
#line 216
    goto case_2;
  }
#line 222
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 9) {
#line 222
    goto case_9;
  }
#line 222
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 11) {
#line 222
    goto case_9;
  }
#line 222
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 6) {
#line 222
    goto case_9;
  }
#line 222
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 12) {
#line 222
    goto case_9;
  }
#line 222
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 0) {
#line 222
    goto case_9;
  }
#line 236
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )3) {
#line 236
    goto case_3___0;
  }
#line 238
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )4) {
#line 238
    goto case_4;
  }
#line 241
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )14) {
#line 241
    goto case_14;
  }
#line 247
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )15) {
#line 247
    goto case_15;
  }
#line 253
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )12) {
#line 253
    goto case_12___0;
  }
#line 259
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )13) {
#line 259
    goto case_13;
  }
#line 268
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )0) {
#line 268
    goto case_0___0;
  }
#line 274
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )7) {
#line 274
    goto case_7;
  }
#line 279
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )6) {
#line 279
    goto case_6___0;
  }
#line 285
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )5) {
#line 285
    goto case_5;
  }
#line 291
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )10) {
#line 291
    goto case_10;
  }
#line 316
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )11) {
#line 316
    goto case_11___0;
  }
#line 345
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )8) {
#line 345
    goto case_8;
  }
#line 361
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )9) {
#line 361
    goto case_9___0;
  }
#line 361
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )2) {
#line 361
    goto case_9___0;
  }
#line 361
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )1) {
#line 361
    goto case_9___0;
  }
#line 389
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 8) {
#line 389
    goto case_8___0;
  }
#line 389
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 4) {
#line 389
    goto case_8___0;
  }
#line 396
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )3) {
#line 396
    goto case_3___1;
  }
#line 398
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )4) {
#line 398
    goto case_4___1;
  }
#line 401
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )13) {
#line 401
    goto case_13___0;
  }
#line 409
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )12) {
#line 409
    goto case_12___1;
  }
#line 416
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )14) {
#line 416
    goto case_14___0;
  }
#line 422
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )15) {
#line 422
    goto case_15___0;
  }
#line 428
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )9) {
#line 428
    goto case_9___1;
  }
#line 445
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 5) {
#line 445
    goto case_5___0;
  }
#line 449
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )14) {
#line 449
    goto case_14___1;
  }
#line 455
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )15) {
#line 455
    goto case_15___1;
  }
#line 461
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )1) {
#line 461
    goto case_1___1;
  }
#line 464
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )3) {
#line 464
    goto case_3___2;
  }
#line 466
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )4) {
#line 466
    goto case_4___2;
  }
#line 476
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 7) {
#line 476
    goto case_7___0;
  }
#line 480
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )14) {
#line 480
    goto case_14___2;
  }
#line 486
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )15) {
#line 486
    goto case_15___2;
  }
#line 492
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )9) {
#line 492
    goto case_9___2;
  }
#line 498
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )2) {
#line 498
    goto case_2___1;
  }
#line 501
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )3) {
#line 501
    goto case_3___3;
  }
#line 503
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )4) {
#line 503
    goto case_4___3;
  }
#line 516
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 10) {
#line 516
    goto case_10___0;
  }
#line 520
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )14) {
#line 520
    goto case_14___3;
  }
#line 526
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )15) {
#line 526
    goto case_15___3;
  }
#line 532
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )8) {
#line 532
    goto case_8___1;
  }
#line 538
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )2) {
#line 538
    goto case_2___2;
  }
#line 541
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )3) {
#line 541
    goto case_3___4;
  }
#line 543
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == (unsigned int )4) {
#line 543
    goto case_4___4;
  }
#line 546
  goto switch_default___3;
  case_1: /* CIL Label */ 
#line 199
  if (hand->flags & 8U) {
#line 200
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )12;
#line 201
    goto around_again;
  }
#line 203
  if (! (hand->flags & 4U)) {
#line 204
    if (*offset != jsonTextLen) {
      {
#line 205
      tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
      }
#line 207
      if ((unsigned int )tok != 3U) {
#line 208
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 209
        hand->parseError = "trailing garbage\220";
      }
#line 211
      goto around_again;
    }
  }
#line 214
  return ((yajl_status )0);
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 217
  return ((yajl_status )2);
  case_9: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 230
  stateToPush = (yajl_state )0;
#line 232
  tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
  }
  {
#line 236
  if ((unsigned int )tok == (unsigned int )3) {
#line 236
    goto case_3___0;
  }
#line 238
  if ((unsigned int )tok == (unsigned int )4) {
#line 238
    goto case_4;
  }
#line 241
  if ((unsigned int )tok == (unsigned int )14) {
#line 241
    goto case_14;
  }
#line 247
  if ((unsigned int )tok == (unsigned int )15) {
#line 247
    goto case_15;
  }
#line 253
  if ((unsigned int )tok == (unsigned int )12) {
#line 253
    goto case_12___0;
  }
#line 259
  if ((unsigned int )tok == (unsigned int )13) {
#line 259
    goto case_13;
  }
#line 268
  if ((unsigned int )tok == (unsigned int )0) {
#line 268
    goto case_0___0;
  }
#line 274
  if ((unsigned int )tok == (unsigned int )7) {
#line 274
    goto case_7;
  }
#line 279
  if ((unsigned int )tok == (unsigned int )6) {
#line 279
    goto case_6___0;
  }
#line 285
  if ((unsigned int )tok == (unsigned int )5) {
#line 285
    goto case_5;
  }
#line 291
  if ((unsigned int )tok == (unsigned int )10) {
#line 291
    goto case_10;
  }
#line 316
  if ((unsigned int )tok == (unsigned int )11) {
#line 316
    goto case_11___0;
  }
#line 345
  if ((unsigned int )tok == (unsigned int )8) {
#line 345
    goto case_8;
  }
#line 361
  if ((unsigned int )tok == (unsigned int )9) {
#line 361
    goto case_9___0;
  }
#line 361
  if ((unsigned int )tok == (unsigned int )2) {
#line 361
    goto case_9___0;
  }
#line 361
  if ((unsigned int )tok == (unsigned int )1) {
#line 361
    goto case_9___0;
  }
#line 366
  goto switch_default;
  case_3___0: /* CIL Label */ 
#line 237
  return ((yajl_status )0);
  case_4: /* CIL Label */ 
#line 239
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )3;

#line 240
  goto around_again;
  case_14: /* CIL Label */ 
#line 242
  if (hand->callbacks) {
#line 242
    if ((hand->callbacks)->yajl_c_comment) {
      {
#line 243
      __cil_tmp12 = (*((hand->callbacks)->yajl_c_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 243
      if (! __cil_tmp12) {
#line 243
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 243
        hand->parseError = "client cancelled parse via callback return value\220";
#line 243
        return ((yajl_status )1);
      }

    }
  }
#line 246
  goto around_again;
  case_15: /* CIL Label */ 
#line 248
  if (hand->callbacks) {
#line 248
    if ((hand->callbacks)->yajl_cpp_comment) {
      {
#line 249
      __cil_tmp13 = (*((hand->callbacks)->yajl_cpp_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 249
      if (! __cil_tmp13) {
#line 249
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 249
        hand->parseError = "client cancelled parse via callback return value\220";
#line 249
        return ((yajl_status )1);
      }

    }
  }
#line 252
  goto around_again;
  case_12___0: /* CIL Label */ 
#line 254
  if (hand->callbacks) {
#line 254
    if ((hand->callbacks)->yajl_string) {
      {
#line 255
      __cil_tmp14 = (*((hand->callbacks)->yajl_string))(hand->ctx, buf, bufLen);
      }
#line 255
      if (! __cil_tmp14) {
#line 255
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 255
        hand->parseError = "client cancelled parse via callback return value\220";
#line 255
        return ((yajl_status )1);
      }

    }
  }
#line 258
  goto switch_break___0;
  case_13: /* CIL Label */ 
#line 260
  if (hand->callbacks) {
#line 260
    if ((hand->callbacks)->yajl_string) {
      {
#line 261
      yajl_buf_clear(hand->decodeBuf);
#line 262
      yajl_string_decode(hand->decodeBuf, buf, bufLen);
#line 263
      __cil_tmp15 = yajl_buf_data(hand->decodeBuf);
      }
      {
#line 263
      __cil_tmp16 = yajl_buf_len(hand->decodeBuf);
#line 263
      __cil_tmp17 = (*((hand->callbacks)->yajl_string))(hand->ctx, __cil_tmp15, __cil_tmp16);
      }
#line 263
      if (! __cil_tmp17) {
#line 263
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 263
        hand->parseError = "client cancelled parse via callback return value\220";
#line 263
        return ((yajl_status )1);
      }

    }
  }
#line 267
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 269
  if (hand->callbacks) {
#line 269
    if ((hand->callbacks)->yajl_boolean) {
      {
#line 270
      __cil_tmp18 = (*((hand->callbacks)->yajl_boolean))(hand->ctx, (int )*buf == 116);
      }
#line 270
      if (! __cil_tmp18) {
#line 270
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 270
        hand->parseError = "client cancelled parse via callback return value\220";
#line 270
        return ((yajl_status )1);
      }

    }
  }
#line 273
  goto switch_break___0;
  case_7: /* CIL Label */ 
#line 275
  if (hand->callbacks) {
#line 275
    if ((hand->callbacks)->yajl_null) {
      {
#line 276
      __cil_tmp19 = (*((hand->callbacks)->yajl_null))(hand->ctx);
      }
#line 276
      if (! __cil_tmp19) {
#line 276
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 276
        hand->parseError = "client cancelled parse via callback return value\220";
#line 276
        return ((yajl_status )1);
      }

    }
  }
#line 278
  goto switch_break___0;
  case_6___0: /* CIL Label */ 
#line 280
  if (hand->callbacks) {
#line 280
    if ((hand->callbacks)->yajl_start_map) {
      {
#line 281
      __cil_tmp20 = (*((hand->callbacks)->yajl_start_map))(hand->ctx);
      }
#line 281
      if (! __cil_tmp20) {
#line 281
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 281
        hand->parseError = "client cancelled parse via callback return value\220";
#line 281
        return ((yajl_status )1);
      }

    }
  }
#line 283
  stateToPush = (yajl_state )4;
#line 284
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 286
  if (hand->callbacks) {
#line 286
    if ((hand->callbacks)->yajl_start_array) {
      {
#line 287
      __cil_tmp21 = (*((hand->callbacks)->yajl_start_array))(hand->ctx);
      }
#line 287
      if (! __cil_tmp21) {
#line 287
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 287
        hand->parseError = "client cancelled parse via callback return value\220";
#line 287
        return ((yajl_status )1);
      }

    }
  }
#line 289
  stateToPush = (yajl_state )9;
#line 290
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 292
  if (hand->callbacks) {
#line 293
    if ((hand->callbacks)->yajl_number) {
      {
#line 294
      __cil_tmp22 = (*((hand->callbacks)->yajl_number))(hand->ctx, (char const   *)buf,
                                                        bufLen);
      }
#line 294
      if (! __cil_tmp22) {
#line 294
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 294
        hand->parseError = "client cancelled parse via callback return value\220";
#line 294
        return ((yajl_status )1);
      }

    } else
#line 296
    if ((hand->callbacks)->yajl_integer) {
      {
#line 297
      i = (longlong )0;
#line 298
      __cil_tmp24 = __errno_location();
#line 298
      *__cil_tmp24 = 0;
#line 299
      i = yajl_parse_integer(buf, (unsigned int )bufLen);
#line 300
      __cil_tmp26 = __errno_location();
      }
#line 300
      if ((long long )i == 0LL) {
        _L: /* CIL Label */ 
#line 300
        if (*__cil_tmp26 == 34) {
#line 303
          *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 305
          hand->parseError = "integer overflow\220";
#line 307
          if (*offset >= bufLen) {
#line 307
            *offset -= bufLen;
          } else {
#line 308
            *offset = (size_t )0;
          }
#line 309
          goto around_again;
        }
      } else
#line 300
      if ((long long )i == -1LL) {
#line 300
        goto _L;
      }
      {
#line 311
      __cil_tmp27 = (*((hand->callbacks)->yajl_integer))(hand->ctx, i);
      }
#line 311
      if (! __cil_tmp27) {
#line 311
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 311
        hand->parseError = "client cancelled parse via callback return value\220";
#line 311
        return ((yajl_status )1);
      }

    }
  }
#line 315
  goto switch_break___0;
  case_11___0: /* CIL Label */ 
#line 317
  if (hand->callbacks) {
#line 318
    if ((hand->callbacks)->yajl_number) {
      {
#line 319
      __cil_tmp28 = (*((hand->callbacks)->yajl_number))(hand->ctx, (char const   *)buf,
                                                        bufLen);
      }
#line 319
      if (! __cil_tmp28) {
#line 319
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 319
        hand->parseError = "client cancelled parse via callback return value\220";
#line 319
        return ((yajl_status )1);
      }

    } else
#line 321
    if ((hand->callbacks)->yajl_double) {
      {
#line 322
      d = 0.;
#line 323
      yajl_buf_clear(hand->decodeBuf);
#line 324
      yajl_buf_append(hand->decodeBuf, buf, bufLen);
#line 325
      buf = yajl_buf_data(hand->decodeBuf);
#line 326
      __cil_tmp31 = __errno_location();
#line 326
      *__cil_tmp31 = 0;
#line 327
      d = strtod((char const   *)((char *)buf), (char **)((void *)0));
#line 328
      __cil_tmp35 = __errno_location();
      }
      {
#line 328
      __cil_tmp34 = __builtin_huge_val();
      }
      {
#line 328
      __cil_tmp33 = __builtin_huge_val();
      }
#line 328
      if (d == __cil_tmp33) {
        _L___34: /* CIL Label */ 
#line 328
        if (*__cil_tmp35 == 34) {
#line 331
          *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 333
          hand->parseError = "numeric (floating point) overflow";
#line 336
          if (*offset >= bufLen) {
#line 336
            *offset -= bufLen;
          } else {
#line 337
            *offset = (size_t )0;
          }
#line 338
          goto around_again;
        }
      } else
#line 328
      if (d == - __cil_tmp34) {
#line 328
        goto _L___34;
      }
      {
#line 340
      __cil_tmp36 = (*((hand->callbacks)->yajl_double))(hand->ctx, d);
      }
#line 340
      if (! __cil_tmp36) {
#line 340
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 340
        hand->parseError = "client cancelled parse via callback return value\220";
#line 340
        return ((yajl_status )1);
      }

    }
  }
#line 344
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 346
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 9) {
#line 349
    if (hand->callbacks) {
#line 349
      if ((hand->callbacks)->yajl_end_array) {
        {
#line 352
        __cil_tmp38 = (*((hand->callbacks)->yajl_end_array))(hand->ctx);
        }
#line 352
        if (! __cil_tmp38) {
#line 352
          *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 352
          hand->parseError = "client cancelled parse via callback return value\220";
#line 352
          return ((yajl_status )1);
        }

      }
    }
#line 354
    __cil_tmp39 = hand->stateStack.used;
#line 354
    (hand->stateStack.used) --;
#line 355
    goto around_again;
  }
  case_9___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 362
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 363
  hand->parseError = "unallowed token at this point in JSON text";
#line 365
  goto around_again;
  switch_default: /* CIL Label */ 
#line 367
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 368
  hand->parseError = "invalid token, internal error";
#line 369
  goto around_again;
  switch_break___0: /* CIL Label */ ;
  }
#line 373
  s = (yajl_state )*(hand->stateStack.stack + (hand->stateStack.used - 1UL));
#line 374
  if ((unsigned int )s == 0U) {
#line 375
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )1;
  } else
#line 374
  if ((unsigned int )s == 12U) {
#line 375
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )1;
  } else
#line 376
  if ((unsigned int )s == 6U) {
#line 377
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )7;
  } else {
#line 379
    *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )10;
  }
#line 382
  if ((unsigned int )stateToPush != 0U) {
#line 383
    if (hand->stateStack.size - hand->stateStack.used == 0UL) {
      {
#line 383
      hand->stateStack.size += (unsigned long )128;
#line 383
      hand->stateStack.stack = (unsigned char *)(*((hand->stateStack.yaf)->realloc))((hand->stateStack.yaf)->ctx,
                                                                                     (void *)hand->stateStack.stack,
                                                                                     hand->stateStack.size);
      }
    }
#line 383
    __cil_tmp43 = hand->stateStack.used;
#line 383
    (hand->stateStack.used) ++;
#line 383
    *(hand->stateStack.stack + __cil_tmp43) = (unsigned char )stateToPush;
  }
#line 386
  goto around_again;
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 393
  tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
  }
  {
#line 396
  if ((unsigned int )tok == (unsigned int )3) {
#line 396
    goto case_3___1;
  }
#line 398
  if ((unsigned int )tok == (unsigned int )4) {
#line 398
    goto case_4___1;
  }
#line 401
  if ((unsigned int )tok == (unsigned int )13) {
#line 401
    goto case_13___0;
  }
#line 409
  if ((unsigned int )tok == (unsigned int )12) {
#line 409
    goto case_12___1;
  }
#line 416
  if ((unsigned int )tok == (unsigned int )14) {
#line 416
    goto case_14___0;
  }
#line 422
  if ((unsigned int )tok == (unsigned int )15) {
#line 422
    goto case_15___0;
  }
#line 428
  if ((unsigned int )tok == (unsigned int )9) {
#line 428
    goto case_9___1;
  }
#line 438
  goto switch_default___0;
  case_3___1: /* CIL Label */ 
#line 397
  return ((yajl_status )0);
  case_4___1: /* CIL Label */ 
#line 399
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )3;

#line 400
  goto around_again;
  case_13___0: /* CIL Label */ 
#line 402
  if (hand->callbacks) {
#line 402
    if ((hand->callbacks)->yajl_map_key) {
      {
#line 403
      yajl_buf_clear(hand->decodeBuf);
#line 404
      yajl_string_decode(hand->decodeBuf, buf, bufLen);
#line 405
      buf = yajl_buf_data(hand->decodeBuf);
#line 406
      bufLen = yajl_buf_len(hand->decodeBuf);
      }
    }
  }
  case_12___1: /* CIL Label */ 
#line 410
  if (hand->callbacks) {
#line 410
    if ((hand->callbacks)->yajl_map_key) {
      {
#line 411
      __cil_tmp47 = (*((hand->callbacks)->yajl_map_key))(hand->ctx, buf, bufLen);
      }
#line 411
      if (! __cil_tmp47) {
#line 411
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 411
        hand->parseError = "client cancelled parse via callback return value\220";
#line 411
        return ((yajl_status )1);
      }

    }
  }
#line 414
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )5;
#line 415
  goto around_again;
  case_14___0: /* CIL Label */ 
#line 417
  if (hand->callbacks) {
#line 417
    if ((hand->callbacks)->yajl_c_comment) {
      {
#line 418
      __cil_tmp48 = (*((hand->callbacks)->yajl_c_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 418
      if (! __cil_tmp48) {
#line 418
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 418
        hand->parseError = "client cancelled parse via callback return value\220";
#line 418
        return ((yajl_status )1);
      }

    }
  }
#line 421
  goto around_again;
  case_15___0: /* CIL Label */ 
#line 423
  if (hand->callbacks) {
#line 423
    if ((hand->callbacks)->yajl_cpp_comment) {
      {
#line 424
      __cil_tmp49 = (*((hand->callbacks)->yajl_cpp_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 424
      if (! __cil_tmp49) {
#line 424
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 424
        hand->parseError = "client cancelled parse via callback return value\220";
#line 424
        return ((yajl_status )1);
      }

    }
  }
#line 427
  goto around_again;
  case_9___1: /* CIL Label */ 
#line 429
  if ((int )*(hand->stateStack.stack + (hand->stateStack.used - 1UL)) == 4) {
#line 432
    if (hand->callbacks) {
#line 432
      if ((hand->callbacks)->yajl_end_map) {
        {
#line 433
        __cil_tmp51 = (*((hand->callbacks)->yajl_end_map))(hand->ctx);
        }
#line 433
        if (! __cil_tmp51) {
#line 433
          *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 433
          hand->parseError = "client cancelled parse via callback return value\220";
#line 433
          return ((yajl_status )1);
        }

      }
    }
#line 435
    __cil_tmp52 = hand->stateStack.used;
#line 435
    (hand->stateStack.used) --;
#line 436
    goto around_again;
  }
  switch_default___0: /* CIL Label */ 
#line 439
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 440
  hand->parseError = "invalid object key (must be a string)";
#line 442
  goto around_again;
  switch_break___1: /* CIL Label */ ;
  }
  case_5___0: /* CIL Label */ 
  {
#line 446
  tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
  }
  {
#line 449
  if ((unsigned int )tok == (unsigned int )14) {
#line 449
    goto case_14___1;
  }
#line 455
  if ((unsigned int )tok == (unsigned int )15) {
#line 455
    goto case_15___1;
  }
#line 461
  if ((unsigned int )tok == (unsigned int )1) {
#line 461
    goto case_1___1;
  }
#line 464
  if ((unsigned int )tok == (unsigned int )3) {
#line 464
    goto case_3___2;
  }
#line 466
  if ((unsigned int )tok == (unsigned int )4) {
#line 466
    goto case_4___2;
  }
#line 469
  goto switch_default___1;
  case_14___1: /* CIL Label */ 
#line 450
  if (hand->callbacks) {
#line 450
    if ((hand->callbacks)->yajl_c_comment) {
      {
#line 451
      __cil_tmp54 = (*((hand->callbacks)->yajl_c_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 451
      if (! __cil_tmp54) {
#line 451
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 451
        hand->parseError = "client cancelled parse via callback return value\220";
#line 451
        return ((yajl_status )1);
      }

    }
  }
#line 454
  goto around_again;
  case_15___1: /* CIL Label */ 
#line 456
  if (hand->callbacks) {
#line 456
    if ((hand->callbacks)->yajl_cpp_comment) {
      {
#line 457
      __cil_tmp55 = (*((hand->callbacks)->yajl_cpp_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 457
      if (! __cil_tmp55) {
#line 457
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 457
        hand->parseError = "client cancelled parse via callback return value\220";
#line 457
        return ((yajl_status )1);
      }

    }
  }
#line 460
  goto around_again;
  case_1___1: /* CIL Label */ 
#line 462
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )6;

#line 463
  goto around_again;
  case_3___2: /* CIL Label */ 
#line 465
  return ((yajl_status )0);
  case_4___2: /* CIL Label */ 
#line 467
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )3;

#line 468
  goto around_again;
  switch_default___1: /* CIL Label */ 
#line 470
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 471
  hand->parseError = "object key and value must be separated by a colon (\':\')";
#line 473
  goto around_again;
  switch_break___2: /* CIL Label */ ;
  }
  case_7___0: /* CIL Label */ 
  {
#line 477
  tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
  }
  {
#line 480
  if ((unsigned int )tok == (unsigned int )14) {
#line 480
    goto case_14___2;
  }
#line 486
  if ((unsigned int )tok == (unsigned int )15) {
#line 486
    goto case_15___2;
  }
#line 492
  if ((unsigned int )tok == (unsigned int )9) {
#line 492
    goto case_9___2;
  }
#line 498
  if ((unsigned int )tok == (unsigned int )2) {
#line 498
    goto case_2___1;
  }
#line 501
  if ((unsigned int )tok == (unsigned int )3) {
#line 501
    goto case_3___3;
  }
#line 503
  if ((unsigned int )tok == (unsigned int )4) {
#line 503
    goto case_4___3;
  }
#line 506
  goto switch_default___2;
  case_14___2: /* CIL Label */ 
#line 481
  if (hand->callbacks) {
#line 481
    if ((hand->callbacks)->yajl_c_comment) {
      {
#line 482
      __cil_tmp57 = (*((hand->callbacks)->yajl_c_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 482
      if (! __cil_tmp57) {
#line 482
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 482
        hand->parseError = "client cancelled parse via callback return value\220";
#line 482
        return ((yajl_status )1);
      }

    }
  }
#line 485
  goto around_again;
  case_15___2: /* CIL Label */ 
#line 487
  if (hand->callbacks) {
#line 487
    if ((hand->callbacks)->yajl_cpp_comment) {
      {
#line 488
      __cil_tmp58 = (*((hand->callbacks)->yajl_cpp_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 488
      if (! __cil_tmp58) {
#line 488
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 488
        hand->parseError = "client cancelled parse via callback return value\220";
#line 488
        return ((yajl_status )1);
      }

    }
  }
#line 491
  goto around_again;
  case_9___2: /* CIL Label */ 
#line 493
  if (hand->callbacks) {
#line 493
    if ((hand->callbacks)->yajl_end_map) {
      {
#line 494
      __cil_tmp59 = (*((hand->callbacks)->yajl_end_map))(hand->ctx);
      }
#line 494
      if (! __cil_tmp59) {
#line 494
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 494
        hand->parseError = "client cancelled parse via callback return value\220";
#line 494
        return ((yajl_status )1);
      }

    }
  }
#line 496
  __cil_tmp60 = hand->stateStack.used;
#line 496
  (hand->stateStack.used) --;
#line 497
  goto around_again;
  case_2___1: /* CIL Label */ 
#line 499
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )8;

#line 500
  goto around_again;
  case_3___3: /* CIL Label */ 
#line 502
  return ((yajl_status )0);
  case_4___3: /* CIL Label */ 
#line 504
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )3;

#line 505
  goto around_again;
  switch_default___2: /* CIL Label */ 
#line 507
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 508
  hand->parseError = "after key and value, inside map, I expect \',\' or \'}\'\220";
#line 511
  if (*offset >= bufLen) {
#line 511
    *offset -= bufLen;
  } else {
#line 512
    *offset = (size_t )0;
  }
#line 513
  goto around_again;
  switch_break___3: /* CIL Label */ ;
  }
  case_10___0: /* CIL Label */ 
  {
#line 517
  tok = yajl_lex_lex(hand->lexer, jsonText, jsonTextLen, offset, & buf, & bufLen);
  }
  {
#line 520
  if ((unsigned int )tok == (unsigned int )14) {
#line 520
    goto case_14___3;
  }
#line 526
  if ((unsigned int )tok == (unsigned int )15) {
#line 526
    goto case_15___3;
  }
#line 532
  if ((unsigned int )tok == (unsigned int )8) {
#line 532
    goto case_8___1;
  }
#line 538
  if ((unsigned int )tok == (unsigned int )2) {
#line 538
    goto case_2___2;
  }
#line 541
  if ((unsigned int )tok == (unsigned int )3) {
#line 541
    goto case_3___4;
  }
#line 543
  if ((unsigned int )tok == (unsigned int )4) {
#line 543
    goto case_4___4;
  }
#line 546
  goto switch_default___3;
  case_14___3: /* CIL Label */ 
#line 521
  if (hand->callbacks) {
#line 521
    if ((hand->callbacks)->yajl_c_comment) {
      {
#line 522
      __cil_tmp62 = (*((hand->callbacks)->yajl_c_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 522
      if (! __cil_tmp62) {
#line 522
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 522
        hand->parseError = "client cancelled parse via callback return value\220";
#line 522
        return ((yajl_status )1);
      }

    }
  }
#line 525
  goto around_again;
  case_15___3: /* CIL Label */ 
#line 527
  if (hand->callbacks) {
#line 527
    if ((hand->callbacks)->yajl_cpp_comment) {
      {
#line 528
      __cil_tmp63 = (*((hand->callbacks)->yajl_cpp_comment))(hand->ctx, buf, (unsigned int )bufLen);
      }
#line 528
      if (! __cil_tmp63) {
#line 528
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 528
        hand->parseError = "client cancelled parse via callback return value\220";
#line 528
        return ((yajl_status )1);
      }

    }
  }
#line 531
  goto around_again;
  case_8___1: /* CIL Label */ 
#line 533
  if (hand->callbacks) {
#line 533
    if ((hand->callbacks)->yajl_end_array) {
      {
#line 534
      __cil_tmp64 = (*((hand->callbacks)->yajl_end_array))(hand->ctx);
      }
#line 534
      if (! __cil_tmp64) {
#line 534
        *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 534
        hand->parseError = "client cancelled parse via callback return value\220";
#line 534
        return ((yajl_status )1);
      }

    }
  }
#line 536
  __cil_tmp65 = hand->stateStack.used;
#line 536
  (hand->stateStack.used) --;
#line 537
  goto around_again;
  case_2___2: /* CIL Label */ 
#line 539
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )11;

#line 540
  goto around_again;
  case_3___4: /* CIL Label */ 
#line 542
  return ((yajl_status )0);
  case_4___4: /* CIL Label */ 
#line 544
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )3;

#line 545
  goto around_again;
  switch_default___3: /* CIL Label */ 
#line 547
  *(hand->stateStack.stack + (hand->stateStack.used - 1UL)) = (unsigned char )2;
#line 548
  hand->parseError = "after array element, I expect \',\' or \']\'\220";
#line 550
  goto around_again;
  switch_break___4: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 555
  abort();
  }
#line 556
  return ((yajl_status )2);
}
}
#line 106 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
yajl_lexer yajl_lex_alloc(yajl_alloc_funcs *alloc , unsigned int allowComments , unsigned int validateUTF8 ) 
{ 
  yajl_lexer lxr ;
  void *__cil_tmp5 ;
  yajl_buf __cil_tmp6 ;

  {
  {
#line 109
  __cil_tmp5 = (*(alloc->malloc))(alloc->ctx, sizeof(struct yajl_lexer_t ));
#line 109
  lxr = (yajl_lexer )__cil_tmp5;
#line 110
  memset((void *)lxr, 0, sizeof(struct yajl_lexer_t ));
#line 111
  lxr->buf = yajl_buf_alloc(alloc);
#line 112
  lxr->allowComments = allowComments;
#line 113
  lxr->validateUTF8 = validateUTF8;
#line 114
  lxr->alloc = alloc;
  }
#line 115
  return (lxr);
}
}
#line 119 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
void yajl_lex_free(yajl_lexer lxr ) 
{ 


  {
  {
#line 121
  yajl_buf_free(lxr->buf);
#line 122
  (*((lxr->alloc)->free))((lxr->alloc)->ctx, lxr);
  }
#line 123
  return;
}
}
#line 140 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static char const   charLookupTable[256]  = 
#line 140
  {      (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )2,      (char )2,      (char )2,      (char )2, 
        (char )0,      (char )0,      (char )11,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )1, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )4,      (char )4,      (char )4, 
        (char )4,      (char )4,      (char )4,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )11,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )4,      (char )5,      (char )4, 
        (char )4,      (char )4,      (char )5,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )0,      (char )0,      (char )1,      (char )0, 
        (char )1,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )0,      (char )0,      (char )0,      (char )0, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16, 
        (char )16,      (char )16,      (char )16,      (char )16};
#line 197 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static yajl_tok yajl_lex_utf8_char(yajl_lexer lexer , unsigned char const   *jsonText ,
                                   size_t jsonTextLen , size_t *offset , unsigned char curChar ) 
{ 
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned char const   *__cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  int tmp ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  unsigned char const   *__cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  int tmp___0 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  unsigned char const   *__cil_tmp20 ;
  size_t __cil_tmp21 ;
  size_t __cil_tmp22 ;
  int tmp___1 ;
  size_t __cil_tmp24 ;
  size_t __cil_tmp25 ;
  unsigned char const   *__cil_tmp26 ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  int tmp___2 ;
  size_t __cil_tmp30 ;
  size_t __cil_tmp31 ;
  unsigned char const   *__cil_tmp32 ;
  size_t __cil_tmp33 ;
  size_t __cil_tmp34 ;
  int tmp___3 ;
  size_t __cil_tmp36 ;
  size_t __cil_tmp37 ;
  unsigned char const   *__cil_tmp38 ;
  size_t __cil_tmp39 ;
  size_t __cil_tmp40 ;
  int tmp___4 ;

  {
#line 201
  if ((int )curChar <= 127) {
#line 203
    return ((yajl_tok )12);
  } else
#line 204
  if ((int )curChar >> 5 == 6) {
#line 206
    if (*offset >= jsonTextLen) {
#line 206
      return ((yajl_tok )3);
    }
    {
#line 207
    __cil_tmp7 = yajl_buf_len(lexer->buf);
    }
    {
#line 207
    __cil_tmp6 = yajl_buf_len(lexer->buf);
    }
#line 207
    if ((lexer->bufInUse && __cil_tmp6) && lexer->bufOff < __cil_tmp7) {
#line 207
      __cil_tmp9 = lexer->bufOff;
#line 207
      (lexer->bufOff) ++;
      {
#line 207
      __cil_tmp8 = yajl_buf_data(lexer->buf);
#line 207
      tmp = (int )*((unsigned char const   *)__cil_tmp8 + __cil_tmp9);
      }
    } else {
#line 207
      (*offset) ++;
#line 207
      tmp = (int )*(jsonText + *offset);
    }
#line 207
    curChar = (unsigned char )tmp;
#line 208
    if ((int )curChar >> 6 == 2) {
#line 208
      return ((yajl_tok )12);
    }
  } else
#line 209
  if ((int )curChar >> 4 == 14) {
#line 211
    if (*offset >= jsonTextLen) {
#line 211
      return ((yajl_tok )3);
    }
    {
#line 212
    __cil_tmp13 = yajl_buf_len(lexer->buf);
    }
    {
#line 212
    __cil_tmp12 = yajl_buf_len(lexer->buf);
    }
#line 212
    if ((lexer->bufInUse && __cil_tmp12) && lexer->bufOff < __cil_tmp13) {
#line 212
      __cil_tmp15 = lexer->bufOff;
#line 212
      (lexer->bufOff) ++;
      {
#line 212
      __cil_tmp14 = yajl_buf_data(lexer->buf);
#line 212
      tmp___0 = (int )*((unsigned char const   *)__cil_tmp14 + __cil_tmp15);
      }
    } else {
#line 212
      (*offset) ++;
#line 212
      tmp___0 = (int )*(jsonText + *offset);
    }
#line 212
    curChar = (unsigned char )tmp___0;
#line 213
    if ((int )curChar >> 6 == 2) {
#line 214
      if (*offset >= jsonTextLen) {
#line 214
        return ((yajl_tok )3);
      }
      {
#line 215
      __cil_tmp19 = yajl_buf_len(lexer->buf);
      }
      {
#line 215
      __cil_tmp18 = yajl_buf_len(lexer->buf);
      }
#line 215
      if ((lexer->bufInUse && __cil_tmp18) && lexer->bufOff < __cil_tmp19) {
#line 215
        __cil_tmp21 = lexer->bufOff;
#line 215
        (lexer->bufOff) ++;
        {
#line 215
        __cil_tmp20 = yajl_buf_data(lexer->buf);
#line 215
        tmp___1 = (int )*((unsigned char const   *)__cil_tmp20 + __cil_tmp21);
        }
      } else {
#line 215
        (*offset) ++;
#line 215
        tmp___1 = (int )*(jsonText + *offset);
      }
#line 215
      curChar = (unsigned char )tmp___1;
#line 216
      if ((int )curChar >> 6 == 2) {
#line 216
        return ((yajl_tok )12);
      }
    }
  } else
#line 218
  if ((int )curChar >> 3 == 30) {
#line 220
    if (*offset >= jsonTextLen) {
#line 220
      return ((yajl_tok )3);
    }
    {
#line 221
    __cil_tmp25 = yajl_buf_len(lexer->buf);
    }
    {
#line 221
    __cil_tmp24 = yajl_buf_len(lexer->buf);
    }
#line 221
    if ((lexer->bufInUse && __cil_tmp24) && lexer->bufOff < __cil_tmp25) {
#line 221
      __cil_tmp27 = lexer->bufOff;
#line 221
      (lexer->bufOff) ++;
      {
#line 221
      __cil_tmp26 = yajl_buf_data(lexer->buf);
#line 221
      tmp___2 = (int )*((unsigned char const   *)__cil_tmp26 + __cil_tmp27);
      }
    } else {
#line 221
      (*offset) ++;
#line 221
      tmp___2 = (int )*(jsonText + *offset);
    }
#line 221
    curChar = (unsigned char )tmp___2;
#line 222
    if ((int )curChar >> 6 == 2) {
#line 223
      if (*offset >= jsonTextLen) {
#line 223
        return ((yajl_tok )3);
      }
      {
#line 224
      __cil_tmp31 = yajl_buf_len(lexer->buf);
      }
      {
#line 224
      __cil_tmp30 = yajl_buf_len(lexer->buf);
      }
#line 224
      if ((lexer->bufInUse && __cil_tmp30) && lexer->bufOff < __cil_tmp31) {
#line 224
        __cil_tmp33 = lexer->bufOff;
#line 224
        (lexer->bufOff) ++;
        {
#line 224
        __cil_tmp32 = yajl_buf_data(lexer->buf);
#line 224
        tmp___3 = (int )*((unsigned char const   *)__cil_tmp32 + __cil_tmp33);
        }
      } else {
#line 224
        (*offset) ++;
#line 224
        tmp___3 = (int )*(jsonText + *offset);
      }
#line 224
      curChar = (unsigned char )tmp___3;
#line 225
      if ((int )curChar >> 6 == 2) {
#line 226
        if (*offset >= jsonTextLen) {
#line 226
          return ((yajl_tok )3);
        }
        {
#line 227
        __cil_tmp37 = yajl_buf_len(lexer->buf);
        }
        {
#line 227
        __cil_tmp36 = yajl_buf_len(lexer->buf);
        }
#line 227
        if ((lexer->bufInUse && __cil_tmp36) && lexer->bufOff < __cil_tmp37) {
#line 227
          __cil_tmp39 = lexer->bufOff;
#line 227
          (lexer->bufOff) ++;
          {
#line 227
          __cil_tmp38 = yajl_buf_data(lexer->buf);
#line 227
          tmp___4 = (int )*((unsigned char const   *)__cil_tmp38 + __cil_tmp39);
          }
        } else {
#line 227
          (*offset) ++;
#line 227
          tmp___4 = (int )*(jsonText + *offset);
        }
#line 227
        curChar = (unsigned char )tmp___4;
#line 228
        if ((int )curChar >> 6 == 2) {
#line 228
          return ((yajl_tok )12);
        }
      }
    }
  }
#line 233
  return ((yajl_tok )4);
}
}
#line 257 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static size_t yajl_string_scan(unsigned char const   *buf , size_t len , int utf8check ) 
{ 
  unsigned char mask ;
  int tmp ;
  size_t skip ;
  size_t __cil_tmp7 ;
  unsigned char const   *__cil_tmp8 ;

  {
#line 259
  if (utf8check) {
#line 259
    tmp = 16;
  } else {
#line 259
    tmp = 0;
  }
#line 259
  mask = (unsigned char )(10 | tmp);
#line 260
  skip = (size_t )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (skip < len && ! ((int )charLookupTable[*buf] & (int )mask))) {
#line 261
      goto while_break;
    }
#line 263
    skip ++;
#line 264
    buf ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (skip);
}
}
#line 270 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static yajl_tok yajl_lex_string(yajl_lexer lexer , unsigned char const   *jsonText ,
                                size_t jsonTextLen , size_t *offset ) 
{ 
  yajl_tok tok ;
  int hasEscapes ;
  unsigned char curChar ;
  unsigned char const   *p ;
  size_t len ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  unsigned char const   *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp17 ;
  unsigned char const   *__cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  int tmp ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  unsigned char const   *__cil_tmp24 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  int tmp___0 ;
  unsigned int i ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  unsigned char const   *__cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp33 ;
  int tmp___1 ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  size_t tmp___2 ;
  unsigned int __cil_tmp38 ;
  size_t __cil_tmp39 ;
  size_t __cil_tmp40 ;
  size_t tmp___3 ;
  size_t __cil_tmp42 ;
  size_t __cil_tmp43 ;
  size_t tmp___4 ;
  yajl_tok t ;
  yajl_tok __cil_tmp46 ;

  {
#line 273
  tok = (yajl_tok )4;
#line 274
  hasEscapes = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! 1) {
#line 276
      goto while_break;
    }
    {
#line 285
    __cil_tmp11 = yajl_buf_len(lexer->buf);
    }
    {
#line 285
    __cil_tmp10 = yajl_buf_len(lexer->buf);
    }
#line 285
    if (lexer->bufInUse) {
#line 285
      if (__cil_tmp10) {
#line 285
        if (lexer->bufOff < __cil_tmp11) {
          {
#line 288
          __cil_tmp12 = yajl_buf_data(lexer->buf);
#line 288
          p = (unsigned char const   *)__cil_tmp12 + lexer->bufOff;
#line 290
          __cil_tmp13 = yajl_buf_len(lexer->buf);
#line 290
          len = __cil_tmp13 - lexer->bufOff;
#line 291
          __cil_tmp14 = yajl_string_scan(p, len, (int )lexer->validateUTF8);
          }
#line 291
          lexer->bufOff += __cil_tmp14;
        } else {
#line 285
          goto _L;
        }
      } else {
#line 285
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___35: /* CIL Label */ 
#line 293
    if (*offset < jsonTextLen) {
      {
#line 295
      p = jsonText + *offset;
#line 296
      len = jsonTextLen - *offset;
#line 297
      __cil_tmp15 = yajl_string_scan(p, len, (int )lexer->validateUTF8);
      }
#line 297
      *offset += __cil_tmp15;
    }
#line 301
    if (*offset >= jsonTextLen) {
#line 301
      tok = (yajl_tok )3;
#line 301
      goto finish_string_lex;
    }
    {
#line 303
    __cil_tmp17 = yajl_buf_len(lexer->buf);
    }
    {
#line 303
    __cil_tmp16 = yajl_buf_len(lexer->buf);
    }
#line 303
    if ((lexer->bufInUse && __cil_tmp16) && lexer->bufOff < __cil_tmp17) {
#line 303
      __cil_tmp19 = lexer->bufOff;
#line 303
      (lexer->bufOff) ++;
      {
#line 303
      __cil_tmp18 = yajl_buf_data(lexer->buf);
#line 303
      tmp = (int )*((unsigned char const   *)__cil_tmp18 + __cil_tmp19);
      }
    } else {
#line 303
      (*offset) ++;
#line 303
      tmp = (int )*(jsonText + *offset);
    }
#line 303
    curChar = (unsigned char )tmp;
#line 306
    if ((int )curChar == 34) {
#line 307
      tok = (yajl_tok )12;
#line 308
      goto while_break;
    } else
#line 311
    if ((int )curChar == 92) {
#line 312
      hasEscapes = 1;
#line 313
      if (*offset >= jsonTextLen) {
#line 313
        tok = (yajl_tok )3;
#line 313
        goto finish_string_lex;
      }
      {
#line 316
      __cil_tmp23 = yajl_buf_len(lexer->buf);
      }
      {
#line 316
      __cil_tmp22 = yajl_buf_len(lexer->buf);
      }
#line 316
      if ((lexer->bufInUse && __cil_tmp22) && lexer->bufOff < __cil_tmp23) {
#line 316
        __cil_tmp25 = lexer->bufOff;
#line 316
        (lexer->bufOff) ++;
        {
#line 316
        __cil_tmp24 = yajl_buf_data(lexer->buf);
#line 316
        tmp___0 = (int )*((unsigned char const   *)__cil_tmp24 + __cil_tmp25);
        }
      } else {
#line 316
        (*offset) ++;
#line 316
        tmp___0 = (int )*(jsonText + *offset);
      }
#line 316
      curChar = (unsigned char )tmp___0;
#line 317
      if ((int )curChar == 117) {
#line 318
        i = (unsigned int )0;
#line 320
        i = (unsigned int )0;
        {
#line 320
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 320
          if (! (i < 4U)) {
#line 320
            goto while_break___0;
          }
#line 321
          if (*offset >= jsonTextLen) {
#line 321
            tok = (yajl_tok )3;
#line 321
            goto finish_string_lex;
          }
          {
#line 322
          __cil_tmp30 = yajl_buf_len(lexer->buf);
          }
          {
#line 322
          __cil_tmp29 = yajl_buf_len(lexer->buf);
          }
#line 322
          if ((lexer->bufInUse && __cil_tmp29) && lexer->bufOff < __cil_tmp30) {
#line 322
            __cil_tmp32 = lexer->bufOff;
#line 322
            (lexer->bufOff) ++;
            {
#line 322
            __cil_tmp31 = yajl_buf_data(lexer->buf);
#line 322
            tmp___1 = (int )*((unsigned char const   *)__cil_tmp31 + __cil_tmp32);
            }
          } else {
#line 322
            (*offset) ++;
#line 322
            tmp___1 = (int )*(jsonText + *offset);
          }
#line 322
          curChar = (unsigned char )tmp___1;
#line 323
          if (! ((int )charLookupTable[curChar] & 4)) {
#line 325
            if (*offset > 0UL) {
#line 325
              __cil_tmp35 = *offset;
#line 325
              (*offset) --;
#line 325
              tmp___2 = __cil_tmp35;
            } else {
#line 325
              __cil_tmp36 = lexer->bufOff;
#line 325
              (lexer->bufOff) --;
#line 325
              tmp___2 = __cil_tmp36;
            }
#line 326
            lexer->error = (yajl_lex_error )4;
#line 327
            goto finish_string_lex;
          }
#line 320
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 330
      if (! ((int )charLookupTable[curChar] & 1)) {
#line 332
        if (*offset > 0UL) {
#line 332
          __cil_tmp39 = *offset;
#line 332
          (*offset) --;
#line 332
          tmp___3 = __cil_tmp39;
        } else {
#line 332
          __cil_tmp40 = lexer->bufOff;
#line 332
          (lexer->bufOff) --;
#line 332
          tmp___3 = __cil_tmp40;
        }
#line 333
        lexer->error = (yajl_lex_error )2;
#line 334
        goto finish_string_lex;
      }
    } else
#line 339
    if ((int )charLookupTable[curChar] & 2) {
#line 341
      if (*offset > 0UL) {
#line 341
        __cil_tmp42 = *offset;
#line 341
        (*offset) --;
#line 341
        tmp___4 = __cil_tmp42;
      } else {
#line 341
        __cil_tmp43 = lexer->bufOff;
#line 341
        (lexer->bufOff) --;
#line 341
        tmp___4 = __cil_tmp43;
      }
#line 342
      lexer->error = (yajl_lex_error )3;
#line 343
      goto finish_string_lex;
    } else
#line 346
    if (lexer->validateUTF8) {
      {
#line 347
      __cil_tmp46 = yajl_lex_utf8_char(lexer, jsonText, jsonTextLen, offset, curChar);
#line 347
      t = __cil_tmp46;
      }
#line 350
      if ((unsigned int )t == 3U) {
#line 351
        tok = (yajl_tok )3;
#line 352
        goto finish_string_lex;
      } else
#line 353
      if ((unsigned int )t == 4U) {
#line 354
        lexer->error = (yajl_lex_error )1;
#line 355
        goto finish_string_lex;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  finish_string_lex: 
#line 363
  if (hasEscapes) {
#line 363
    if ((unsigned int )tok == 12U) {
#line 364
      tok = (yajl_tok )13;
    }
  }
#line 367
  return (tok);
}
}
#line 373 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static yajl_tok yajl_lex_number(yajl_lexer lexer , unsigned char const   *jsonText ,
                                size_t jsonTextLen , size_t *offset ) 
{ 
  unsigned char c ;
  yajl_tok tok ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned char const   *__cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int tmp ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned char const   *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp17 ;
  int tmp___0 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  unsigned char const   *__cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  int tmp___1 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  unsigned char const   *__cil_tmp27 ;
  size_t __cil_tmp28 ;
  size_t __cil_tmp29 ;
  int tmp___2 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t tmp___3 ;
  int numRd ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  unsigned char const   *__cil_tmp37 ;
  size_t __cil_tmp38 ;
  size_t __cil_tmp39 ;
  int tmp___4 ;
  int __cil_tmp41 ;
  size_t __cil_tmp42 ;
  size_t __cil_tmp43 ;
  unsigned char const   *__cil_tmp44 ;
  size_t __cil_tmp45 ;
  size_t __cil_tmp46 ;
  int tmp___5 ;
  size_t __cil_tmp48 ;
  size_t __cil_tmp49 ;
  size_t tmp___6 ;
  size_t __cil_tmp51 ;
  size_t __cil_tmp52 ;
  unsigned char const   *__cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t __cil_tmp55 ;
  int tmp___7 ;
  size_t __cil_tmp57 ;
  size_t __cil_tmp58 ;
  unsigned char const   *__cil_tmp59 ;
  size_t __cil_tmp60 ;
  size_t __cil_tmp61 ;
  int tmp___8 ;
  size_t __cil_tmp63 ;
  size_t __cil_tmp64 ;
  unsigned char const   *__cil_tmp65 ;
  size_t __cil_tmp66 ;
  size_t __cil_tmp67 ;
  int tmp___9 ;
  size_t __cil_tmp69 ;
  size_t __cil_tmp70 ;
  size_t tmp___10 ;
  size_t __cil_tmp72 ;
  size_t __cil_tmp73 ;
  size_t tmp___11 ;

  {
#line 382
  tok = (yajl_tok )10;
#line 384
  if (*offset >= jsonTextLen) {
#line 384
    return ((yajl_tok )3);
  }
  {
#line 385
  __cil_tmp8 = yajl_buf_len(lexer->buf);
  }
  {
#line 385
  __cil_tmp7 = yajl_buf_len(lexer->buf);
  }
#line 385
  if ((lexer->bufInUse && __cil_tmp7) && lexer->bufOff < __cil_tmp8) {
#line 385
    __cil_tmp10 = lexer->bufOff;
#line 385
    (lexer->bufOff) ++;
    {
#line 385
    __cil_tmp9 = yajl_buf_data(lexer->buf);
#line 385
    tmp = (int )*((unsigned char const   *)__cil_tmp9 + __cil_tmp10);
    }
  } else {
#line 385
    (*offset) ++;
#line 385
    tmp = (int )*(jsonText + *offset);
  }
#line 385
  c = (unsigned char )tmp;
#line 388
  if ((int )c == 45) {
#line 389
    if (*offset >= jsonTextLen) {
#line 389
      return ((yajl_tok )3);
    }
    {
#line 390
    __cil_tmp14 = yajl_buf_len(lexer->buf);
    }
    {
#line 390
    __cil_tmp13 = yajl_buf_len(lexer->buf);
    }
#line 390
    if ((lexer->bufInUse && __cil_tmp13) && lexer->bufOff < __cil_tmp14) {
#line 390
      __cil_tmp16 = lexer->bufOff;
#line 390
      (lexer->bufOff) ++;
      {
#line 390
      __cil_tmp15 = yajl_buf_data(lexer->buf);
#line 390
      tmp___0 = (int )*((unsigned char const   *)__cil_tmp15 + __cil_tmp16);
      }
    } else {
#line 390
      (*offset) ++;
#line 390
      tmp___0 = (int )*(jsonText + *offset);
    }
#line 390
    c = (unsigned char )tmp___0;
  }
#line 394
  if ((int )c == 48) {
#line 395
    if (*offset >= jsonTextLen) {
#line 395
      return ((yajl_tok )3);
    }
    {
#line 396
    __cil_tmp20 = yajl_buf_len(lexer->buf);
    }
    {
#line 396
    __cil_tmp19 = yajl_buf_len(lexer->buf);
    }
#line 396
    if ((lexer->bufInUse && __cil_tmp19) && lexer->bufOff < __cil_tmp20) {
#line 396
      __cil_tmp22 = lexer->bufOff;
#line 396
      (lexer->bufOff) ++;
      {
#line 396
      __cil_tmp21 = yajl_buf_data(lexer->buf);
#line 396
      tmp___1 = (int )*((unsigned char const   *)__cil_tmp21 + __cil_tmp22);
      }
    } else {
#line 396
      (*offset) ++;
#line 396
      tmp___1 = (int )*(jsonText + *offset);
    }
#line 396
    c = (unsigned char )tmp___1;
  } else
#line 397
  if ((int )c >= 49) {
#line 397
    if ((int )c <= 57) {
      {
#line 398
      while (1) {
        while_continue: /* CIL Label */ ;
#line 399
        if (*offset >= jsonTextLen) {
#line 399
          return ((yajl_tok )3);
        }
        {
#line 400
        __cil_tmp26 = yajl_buf_len(lexer->buf);
        }
        {
#line 400
        __cil_tmp25 = yajl_buf_len(lexer->buf);
        }
#line 400
        if ((lexer->bufInUse && __cil_tmp25) && lexer->bufOff < __cil_tmp26) {
#line 400
          __cil_tmp28 = lexer->bufOff;
#line 400
          (lexer->bufOff) ++;
          {
#line 400
          __cil_tmp27 = yajl_buf_data(lexer->buf);
#line 400
          tmp___2 = (int )*((unsigned char const   *)__cil_tmp27 + __cil_tmp28);
          }
        } else {
#line 400
          (*offset) ++;
#line 400
          tmp___2 = (int )*(jsonText + *offset);
        }
#line 400
        c = (unsigned char )tmp___2;
#line 398
        if (! ((int )c >= 48 && (int )c <= 57)) {
#line 398
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 397
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 403
    if (*offset > 0UL) {
#line 403
      __cil_tmp31 = *offset;
#line 403
      (*offset) --;
#line 403
      tmp___3 = __cil_tmp31;
    } else {
#line 403
      __cil_tmp32 = lexer->bufOff;
#line 403
      (lexer->bufOff) --;
#line 403
      tmp___3 = __cil_tmp32;
    }
#line 404
    lexer->error = (yajl_lex_error )9;
#line 405
    return ((yajl_tok )4);
  }
#line 409
  if ((int )c == 46) {
#line 410
    numRd = 0;
#line 412
    if (*offset >= jsonTextLen) {
#line 412
      return ((yajl_tok )3);
    }
    {
#line 413
    __cil_tmp36 = yajl_buf_len(lexer->buf);
    }
    {
#line 413
    __cil_tmp35 = yajl_buf_len(lexer->buf);
    }
#line 413
    if ((lexer->bufInUse && __cil_tmp35) && lexer->bufOff < __cil_tmp36) {
#line 413
      __cil_tmp38 = lexer->bufOff;
#line 413
      (lexer->bufOff) ++;
      {
#line 413
      __cil_tmp37 = yajl_buf_data(lexer->buf);
#line 413
      tmp___4 = (int )*((unsigned char const   *)__cil_tmp37 + __cil_tmp38);
      }
    } else {
#line 413
      (*offset) ++;
#line 413
      tmp___4 = (int )*(jsonText + *offset);
    }
#line 413
    c = (unsigned char )tmp___4;
    {
#line 415
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 415
      if (! ((int )c >= 48 && (int )c <= 57)) {
#line 415
        goto while_break___0;
      }
#line 416
      numRd ++;
#line 417
      if (*offset >= jsonTextLen) {
#line 417
        return ((yajl_tok )3);
      }
      {
#line 418
      __cil_tmp43 = yajl_buf_len(lexer->buf);
      }
      {
#line 418
      __cil_tmp42 = yajl_buf_len(lexer->buf);
      }
#line 418
      if ((lexer->bufInUse && __cil_tmp42) && lexer->bufOff < __cil_tmp43) {
#line 418
        __cil_tmp45 = lexer->bufOff;
#line 418
        (lexer->bufOff) ++;
        {
#line 418
        __cil_tmp44 = yajl_buf_data(lexer->buf);
#line 418
        tmp___5 = (int )*((unsigned char const   *)__cil_tmp44 + __cil_tmp45);
        }
      } else {
#line 418
        (*offset) ++;
#line 418
        tmp___5 = (int )*(jsonText + *offset);
      }
#line 418
      c = (unsigned char )tmp___5;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 421
    if (! numRd) {
#line 422
      if (*offset > 0UL) {
#line 422
        __cil_tmp48 = *offset;
#line 422
        (*offset) --;
#line 422
        tmp___6 = __cil_tmp48;
      } else {
#line 422
        __cil_tmp49 = lexer->bufOff;
#line 422
        (lexer->bufOff) --;
#line 422
        tmp___6 = __cil_tmp49;
      }
#line 423
      lexer->error = (yajl_lex_error )7;
#line 424
      return ((yajl_tok )4);
    }
#line 426
    tok = (yajl_tok )11;
  }
#line 430
  if ((int )c == 101) {
    _L___38: /* CIL Label */ 
#line 431
    if (*offset >= jsonTextLen) {
#line 431
      return ((yajl_tok )3);
    }
    {
#line 432
    __cil_tmp52 = yajl_buf_len(lexer->buf);
    }
    {
#line 432
    __cil_tmp51 = yajl_buf_len(lexer->buf);
    }
#line 432
    if ((lexer->bufInUse && __cil_tmp51) && lexer->bufOff < __cil_tmp52) {
#line 432
      __cil_tmp54 = lexer->bufOff;
#line 432
      (lexer->bufOff) ++;
      {
#line 432
      __cil_tmp53 = yajl_buf_data(lexer->buf);
#line 432
      tmp___7 = (int )*((unsigned char const   *)__cil_tmp53 + __cil_tmp54);
      }
    } else {
#line 432
      (*offset) ++;
#line 432
      tmp___7 = (int )*(jsonText + *offset);
    }
#line 432
    c = (unsigned char )tmp___7;
#line 435
    if ((int )c == 43) {
      _L___36: /* CIL Label */ 
#line 436
      if (*offset >= jsonTextLen) {
#line 436
        return ((yajl_tok )3);
      }
      {
#line 437
      __cil_tmp58 = yajl_buf_len(lexer->buf);
      }
      {
#line 437
      __cil_tmp57 = yajl_buf_len(lexer->buf);
      }
#line 437
      if ((lexer->bufInUse && __cil_tmp57) && lexer->bufOff < __cil_tmp58) {
#line 437
        __cil_tmp60 = lexer->bufOff;
#line 437
        (lexer->bufOff) ++;
        {
#line 437
        __cil_tmp59 = yajl_buf_data(lexer->buf);
#line 437
        tmp___8 = (int )*((unsigned char const   *)__cil_tmp59 + __cil_tmp60);
        }
      } else {
#line 437
        (*offset) ++;
#line 437
        tmp___8 = (int )*(jsonText + *offset);
      }
#line 437
      c = (unsigned char )tmp___8;
    } else
#line 435
    if ((int )c == 45) {
#line 435
      goto _L___36;
    }
#line 440
    if ((int )c >= 48) {
#line 440
      if ((int )c <= 57) {
        {
#line 441
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 442
          if (*offset >= jsonTextLen) {
#line 442
            return ((yajl_tok )3);
          }
          {
#line 443
          __cil_tmp64 = yajl_buf_len(lexer->buf);
          }
          {
#line 443
          __cil_tmp63 = yajl_buf_len(lexer->buf);
          }
#line 443
          if ((lexer->bufInUse && __cil_tmp63) && lexer->bufOff < __cil_tmp64) {
#line 443
            __cil_tmp66 = lexer->bufOff;
#line 443
            (lexer->bufOff) ++;
            {
#line 443
            __cil_tmp65 = yajl_buf_data(lexer->buf);
#line 443
            tmp___9 = (int )*((unsigned char const   *)__cil_tmp65 + __cil_tmp66);
            }
          } else {
#line 443
            (*offset) ++;
#line 443
            tmp___9 = (int )*(jsonText + *offset);
          }
#line 443
          c = (unsigned char )tmp___9;
#line 441
          if (! ((int )c >= 48 && (int )c <= 57)) {
#line 441
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 440
        goto _L___37;
      }
    } else {
      _L___37: /* CIL Label */ 
#line 446
      if (*offset > 0UL) {
#line 446
        __cil_tmp69 = *offset;
#line 446
        (*offset) --;
#line 446
        tmp___10 = __cil_tmp69;
      } else {
#line 446
        __cil_tmp70 = lexer->bufOff;
#line 446
        (lexer->bufOff) --;
#line 446
        tmp___10 = __cil_tmp70;
      }
#line 447
      lexer->error = (yajl_lex_error )8;
#line 448
      return ((yajl_tok )4);
    }
#line 450
    tok = (yajl_tok )11;
  } else
#line 430
  if ((int )c == 69) {
#line 430
    goto _L___38;
  }
#line 454
  if (*offset > 0UL) {
#line 454
    __cil_tmp72 = *offset;
#line 454
    (*offset) --;
#line 454
    tmp___11 = __cil_tmp72;
  } else {
#line 454
    __cil_tmp73 = lexer->bufOff;
#line 454
    (lexer->bufOff) --;
#line 454
    tmp___11 = __cil_tmp73;
  }
#line 456
  return (tok);
}
}
#line 460 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
static yajl_tok yajl_lex_comment(yajl_lexer lexer , unsigned char const   *jsonText ,
                                 size_t jsonTextLen , size_t *offset ) 
{ 
  unsigned char c ;
  yajl_tok tok ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned char const   *__cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  int tmp ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned char const   *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t __cil_tmp17 ;
  int tmp___0 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  unsigned char const   *__cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  int tmp___1 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  unsigned char const   *__cil_tmp27 ;
  size_t __cil_tmp28 ;
  size_t __cil_tmp29 ;
  int tmp___2 ;
  size_t __cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t tmp___3 ;

  {
#line 467
  if (*offset >= jsonTextLen) {
#line 467
    return ((yajl_tok )3);
  }
  {
#line 468
  __cil_tmp8 = yajl_buf_len(lexer->buf);
  }
  {
#line 468
  __cil_tmp7 = yajl_buf_len(lexer->buf);
  }
#line 468
  if ((lexer->bufInUse && __cil_tmp7) && lexer->bufOff < __cil_tmp8) {
#line 468
    __cil_tmp10 = lexer->bufOff;
#line 468
    (lexer->bufOff) ++;
    {
#line 468
    __cil_tmp9 = yajl_buf_data(lexer->buf);
#line 468
    tmp = (int )*((unsigned char const   *)__cil_tmp9 + __cil_tmp10);
    }
  } else {
#line 468
    (*offset) ++;
#line 468
    tmp = (int )*(jsonText + *offset);
  }
#line 468
  c = (unsigned char )tmp;
#line 471
  if ((int )c == 47) {
#line 472
    tok = (yajl_tok )15;
    {
#line 474
    while (1) {
      while_continue: /* CIL Label */ ;
#line 475
      if (*offset >= jsonTextLen) {
#line 475
        return ((yajl_tok )3);
      }
      {
#line 476
      __cil_tmp14 = yajl_buf_len(lexer->buf);
      }
      {
#line 476
      __cil_tmp13 = yajl_buf_len(lexer->buf);
      }
#line 476
      if ((lexer->bufInUse && __cil_tmp13) && lexer->bufOff < __cil_tmp14) {
#line 476
        __cil_tmp16 = lexer->bufOff;
#line 476
        (lexer->bufOff) ++;
        {
#line 476
        __cil_tmp15 = yajl_buf_data(lexer->buf);
#line 476
        tmp___0 = (int )*((unsigned char const   *)__cil_tmp15 + __cil_tmp16);
        }
      } else {
#line 476
        (*offset) ++;
#line 476
        tmp___0 = (int )*(jsonText + *offset);
      }
#line 476
      c = (unsigned char )tmp___0;
#line 474
      if (! ((int )c != 10)) {
#line 474
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 478
  if ((int )c == 42) {
#line 479
    tok = (yajl_tok )14;
    {
#line 481
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 481
      if (! 1) {
#line 481
        goto while_break___0;
      }
#line 482
      if (*offset >= jsonTextLen) {
#line 482
        return ((yajl_tok )3);
      }
      {
#line 483
      __cil_tmp20 = yajl_buf_len(lexer->buf);
      }
      {
#line 483
      __cil_tmp19 = yajl_buf_len(lexer->buf);
      }
#line 483
      if ((lexer->bufInUse && __cil_tmp19) && lexer->bufOff < __cil_tmp20) {
#line 483
        __cil_tmp22 = lexer->bufOff;
#line 483
        (lexer->bufOff) ++;
        {
#line 483
        __cil_tmp21 = yajl_buf_data(lexer->buf);
#line 483
        tmp___1 = (int )*((unsigned char const   *)__cil_tmp21 + __cil_tmp22);
        }
      } else {
#line 483
        (*offset) ++;
#line 483
        tmp___1 = (int )*(jsonText + *offset);
      }
#line 483
      c = (unsigned char )tmp___1;
#line 484
      if ((int )c == 42) {
#line 485
        if (*offset >= jsonTextLen) {
#line 485
          return ((yajl_tok )3);
        }
        {
#line 486
        __cil_tmp26 = yajl_buf_len(lexer->buf);
        }
        {
#line 486
        __cil_tmp25 = yajl_buf_len(lexer->buf);
        }
#line 486
        if ((lexer->bufInUse && __cil_tmp25) && lexer->bufOff < __cil_tmp26) {
#line 486
          __cil_tmp28 = lexer->bufOff;
#line 486
          (lexer->bufOff) ++;
          {
#line 486
          __cil_tmp27 = yajl_buf_data(lexer->buf);
#line 486
          tmp___2 = (int )*((unsigned char const   *)__cil_tmp27 + __cil_tmp28);
          }
        } else {
#line 486
          (*offset) ++;
#line 486
          tmp___2 = (int )*(jsonText + *offset);
        }
#line 486
        c = (unsigned char )tmp___2;
#line 487
        if ((int )c == 47) {
#line 488
          goto while_break___0;
        } else
#line 490
        if (*offset > 0UL) {
#line 490
          __cil_tmp31 = *offset;
#line 490
          (*offset) --;
#line 490
          tmp___3 = __cil_tmp31;
        } else {
#line 490
          __cil_tmp32 = lexer->bufOff;
#line 490
          (lexer->bufOff) --;
#line 490
          tmp___3 = __cil_tmp32;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 495
    lexer->error = (yajl_lex_error )5;
#line 496
    tok = (yajl_tok )4;
  }
#line 499
  return (tok);
}
}
#line 503 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
yajl_tok yajl_lex_lex(yajl_lexer lexer , unsigned char const   *jsonText , size_t jsonTextLen ,
                      size_t *offset , unsigned char const   **outBuf , size_t *outLen ) 
{ 
  yajl_tok tok ;
  unsigned char c ;
  size_t startOffset ;
  int tmp ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;
  unsigned char const   *__cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  int tmp___0 ;
  size_t __cil_tmp17 ;
  char const   *want ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;
  unsigned char const   *__cil_tmp21 ;
  size_t __cil_tmp22 ;
  size_t __cil_tmp23 ;
  int tmp___1 ;
  size_t __cil_tmp25 ;
  size_t __cil_tmp26 ;
  size_t tmp___2 ;
  char const   *want___0 ;
  size_t __cil_tmp29 ;
  size_t __cil_tmp30 ;
  unsigned char const   *__cil_tmp31 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp33 ;
  int tmp___3 ;
  size_t __cil_tmp35 ;
  size_t __cil_tmp36 ;
  size_t tmp___4 ;
  char const   *want___1 ;
  size_t __cil_tmp39 ;
  size_t __cil_tmp40 ;
  unsigned char const   *__cil_tmp41 ;
  size_t __cil_tmp42 ;
  size_t __cil_tmp43 ;
  int tmp___5 ;
  size_t __cil_tmp45 ;
  size_t __cil_tmp46 ;
  size_t tmp___6 ;
  yajl_tok __cil_tmp48 ;
  size_t __cil_tmp49 ;
  size_t __cil_tmp50 ;
  size_t tmp___7 ;
  yajl_tok __cil_tmp52 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp54 ;
  size_t tmp___8 ;
  yajl_tok __cil_tmp56 ;
  unsigned char const   *__cil_tmp57 ;
  size_t __cil_tmp58 ;
  int tmp___9 ;
  unsigned char const   *__cil_tmp60 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 507
  tok = (yajl_tok )4;
#line 509
  startOffset = *offset;
#line 511
  *outBuf = (unsigned char const   *)((void *)0);
#line 512
  *outLen = (size_t )0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! 1) {
#line 514
      goto while_break;
    }
#line 517
    if (*offset >= jsonTextLen) {
#line 518
      tok = (yajl_tok )3;
#line 519
      goto lexed;
    }
    {
#line 522
    __cil_tmp12 = yajl_buf_len(lexer->buf);
    }
    {
#line 522
    __cil_tmp11 = yajl_buf_len(lexer->buf);
    }
#line 522
    if ((lexer->bufInUse && __cil_tmp11) && lexer->bufOff < __cil_tmp12) {
#line 522
      __cil_tmp14 = lexer->bufOff;
#line 522
      (lexer->bufOff) ++;
      {
#line 522
      __cil_tmp13 = yajl_buf_data(lexer->buf);
#line 522
      tmp___0 = (int )*((unsigned char const   *)__cil_tmp13 + __cil_tmp14);
      }
    } else {
#line 522
      (*offset) ++;
#line 522
      tmp___0 = (int )*(jsonText + *offset);
    }
#line 522
    c = (unsigned char )tmp___0;
    {
#line 525
    if ((int )c == '{') {
#line 525
      goto case_123;
    }
#line 528
    if ((int )c == '}') {
#line 528
      goto case_125;
    }
#line 531
    if ((int )c == '[') {
#line 531
      goto case_91;
    }
#line 534
    if ((int )c == ']') {
#line 534
      goto case_93;
    }
#line 537
    if ((int )c == ',') {
#line 537
      goto case_44;
    }
#line 540
    if ((int )c == ':') {
#line 540
      goto case_58;
    }
#line 543
    if ((int )c == ' ') {
#line 543
      goto case_32;
    }
#line 543
    if ((int )c == '\r') {
#line 543
      goto case_32;
    }
#line 543
    if ((int )c == '\f') {
#line 543
      goto case_32;
    }
#line 543
    if ((int )c == '\v') {
#line 543
      goto case_32;
    }
#line 543
    if ((int )c == '\n') {
#line 543
      goto case_32;
    }
#line 543
    if ((int )c == '\t') {
#line 543
      goto case_32;
    }
#line 546
    if ((int )c == 't') {
#line 546
      goto case_116;
    }
#line 564
    if ((int )c == 'f') {
#line 564
      goto case_102;
    }
#line 582
    if ((int )c == 'n') {
#line 582
      goto case_110;
    }
#line 600
    if ((int )c == '\"') {
#line 600
      goto case_34;
    }
#line 607
    if ((int )c == '9') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '8') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '7') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '6') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '5') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '4') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '3') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '2') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '1') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '0') {
#line 607
      goto case_57;
    }
#line 607
    if ((int )c == '-') {
#line 607
      goto case_57;
    }
#line 614
    if ((int )c == '/') {
#line 614
      goto case_47;
    }
#line 637
    goto switch_default;
    case_123: /* CIL Label */ 
#line 526
    tok = (yajl_tok )6;
#line 527
    goto lexed;
    case_125: /* CIL Label */ 
#line 529
    tok = (yajl_tok )9;
#line 530
    goto lexed;
    case_91: /* CIL Label */ 
#line 532
    tok = (yajl_tok )5;
#line 533
    goto lexed;
    case_93: /* CIL Label */ 
#line 535
    tok = (yajl_tok )8;
#line 536
    goto lexed;
    case_44: /* CIL Label */ 
#line 538
    tok = (yajl_tok )2;
#line 539
    goto lexed;
    case_58: /* CIL Label */ 
#line 541
    tok = (yajl_tok )1;
#line 542
    goto lexed;
    case_32: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 544
    startOffset ++;
#line 545
    goto switch_break;
    case_116: /* CIL Label */ 
#line 547
    want = "rue";
    {
#line 548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 549
      if (*offset >= jsonTextLen) {
#line 550
        tok = (yajl_tok )3;
#line 551
        goto lexed;
      }
      {
#line 553
      __cil_tmp20 = yajl_buf_len(lexer->buf);
      }
      {
#line 553
      __cil_tmp19 = yajl_buf_len(lexer->buf);
      }
#line 553
      if ((lexer->bufInUse && __cil_tmp19) && lexer->bufOff < __cil_tmp20) {
#line 553
        __cil_tmp22 = lexer->bufOff;
#line 553
        (lexer->bufOff) ++;
        {
#line 553
        __cil_tmp21 = yajl_buf_data(lexer->buf);
#line 553
        tmp___1 = (int )*((unsigned char const   *)__cil_tmp21 + __cil_tmp22);
        }
      } else {
#line 553
        (*offset) ++;
#line 553
        tmp___1 = (int )*(jsonText + *offset);
      }
#line 553
      c = (unsigned char )tmp___1;
#line 554
      if ((int )c != (int )*want) {
#line 555
        if (*offset > 0UL) {
#line 555
          __cil_tmp25 = *offset;
#line 555
          (*offset) --;
#line 555
          tmp___2 = __cil_tmp25;
        } else {
#line 555
          __cil_tmp26 = lexer->bufOff;
#line 555
          (lexer->bufOff) --;
#line 555
          tmp___2 = __cil_tmp26;
        }
#line 556
        lexer->error = (yajl_lex_error )6;
#line 557
        tok = (yajl_tok )4;
#line 558
        goto lexed;
      }
#line 548
      if (! *want) {
#line 548
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 561
    tok = (yajl_tok )0;
#line 562
    goto lexed;
    case_102: /* CIL Label */ 
#line 565
    want___0 = "alse\313U";
    {
#line 566
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 567
      if (*offset >= jsonTextLen) {
#line 568
        tok = (yajl_tok )3;
#line 569
        goto lexed;
      }
      {
#line 571
      __cil_tmp30 = yajl_buf_len(lexer->buf);
      }
      {
#line 571
      __cil_tmp29 = yajl_buf_len(lexer->buf);
      }
#line 571
      if ((lexer->bufInUse && __cil_tmp29) && lexer->bufOff < __cil_tmp30) {
#line 571
        __cil_tmp32 = lexer->bufOff;
#line 571
        (lexer->bufOff) ++;
        {
#line 571
        __cil_tmp31 = yajl_buf_data(lexer->buf);
#line 571
        tmp___3 = (int )*((unsigned char const   *)__cil_tmp31 + __cil_tmp32);
        }
      } else {
#line 571
        (*offset) ++;
#line 571
        tmp___3 = (int )*(jsonText + *offset);
      }
#line 571
      c = (unsigned char )tmp___3;
#line 572
      if ((int )c != (int )*want___0) {
#line 573
        if (*offset > 0UL) {
#line 573
          __cil_tmp35 = *offset;
#line 573
          (*offset) --;
#line 573
          tmp___4 = __cil_tmp35;
        } else {
#line 573
          __cil_tmp36 = lexer->bufOff;
#line 573
          (lexer->bufOff) --;
#line 573
          tmp___4 = __cil_tmp36;
        }
#line 574
        lexer->error = (yajl_lex_error )6;
#line 575
        tok = (yajl_tok )4;
#line 576
        goto lexed;
      }
#line 566
      if (! *want___0) {
#line 566
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 579
    tok = (yajl_tok )0;
#line 580
    goto lexed;
    case_110: /* CIL Label */ 
#line 583
    want___1 = "ull\030\313U";
    {
#line 584
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 585
      if (*offset >= jsonTextLen) {
#line 586
        tok = (yajl_tok )3;
#line 587
        goto lexed;
      }
      {
#line 589
      __cil_tmp40 = yajl_buf_len(lexer->buf);
      }
      {
#line 589
      __cil_tmp39 = yajl_buf_len(lexer->buf);
      }
#line 589
      if ((lexer->bufInUse && __cil_tmp39) && lexer->bufOff < __cil_tmp40) {
#line 589
        __cil_tmp42 = lexer->bufOff;
#line 589
        (lexer->bufOff) ++;
        {
#line 589
        __cil_tmp41 = yajl_buf_data(lexer->buf);
#line 589
        tmp___5 = (int )*((unsigned char const   *)__cil_tmp41 + __cil_tmp42);
        }
      } else {
#line 589
        (*offset) ++;
#line 589
        tmp___5 = (int )*(jsonText + *offset);
      }
#line 589
      c = (unsigned char )tmp___5;
#line 590
      if ((int )c != (int )*want___1) {
#line 591
        if (*offset > 0UL) {
#line 591
          __cil_tmp45 = *offset;
#line 591
          (*offset) --;
#line 591
          tmp___6 = __cil_tmp45;
        } else {
#line 591
          __cil_tmp46 = lexer->bufOff;
#line 591
          (lexer->bufOff) --;
#line 591
          tmp___6 = __cil_tmp46;
        }
#line 592
        lexer->error = (yajl_lex_error )6;
#line 593
        tok = (yajl_tok )4;
#line 594
        goto lexed;
      }
#line 584
      if (! *want___1) {
#line 584
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 597
    tok = (yajl_tok )7;
#line 598
    goto lexed;
    case_34: /* CIL Label */ 
    {
#line 601
    tok = yajl_lex_string(lexer, (unsigned char const   *)jsonText, jsonTextLen, offset);
    }
#line 603
    goto lexed;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 609
    if (*offset > 0UL) {
#line 609
      __cil_tmp49 = *offset;
#line 609
      (*offset) --;
#line 609
      tmp___7 = __cil_tmp49;
    } else {
#line 609
      __cil_tmp50 = lexer->bufOff;
#line 609
      (lexer->bufOff) --;
#line 609
      tmp___7 = __cil_tmp50;
    }
    {
#line 610
    tok = yajl_lex_number(lexer, (unsigned char const   *)jsonText, jsonTextLen, offset);
    }
#line 612
    goto lexed;
    case_47: /* CIL Label */ 
#line 617
    if (! lexer->allowComments) {
#line 618
      if (*offset > 0UL) {
#line 618
        __cil_tmp53 = *offset;
#line 618
        (*offset) --;
#line 618
        tmp___8 = __cil_tmp53;
      } else {
#line 618
        __cil_tmp54 = lexer->bufOff;
#line 618
        (lexer->bufOff) --;
#line 618
        tmp___8 = __cil_tmp54;
      }
#line 619
      lexer->error = (yajl_lex_error )10;
#line 620
      tok = (yajl_tok )4;
#line 621
      goto lexed;
    }
    {
#line 629
    tok = yajl_lex_comment(lexer, (unsigned char const   *)jsonText, jsonTextLen,
                           offset);
    }
#line 631
    if ((unsigned int )tok == 14U) {
#line 633
      goto lexed;
    } else
#line 631
    if ((unsigned int )tok == 15U) {
#line 633
      goto lexed;
    }
#line 636
    goto lexed;
    switch_default: /* CIL Label */ 
#line 638
    lexer->error = (yajl_lex_error )5;
#line 639
    tok = (yajl_tok )4;
#line 640
    goto lexed;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  lexed: 
#line 648
  if ((unsigned int )tok == 3U) {
    _L: /* CIL Label */ 
#line 649
    if (! lexer->bufInUse) {
      {
#line 649
      yajl_buf_clear(lexer->buf);
      }
    }
    {
#line 650
    lexer->bufInUse = (unsigned int )1;
#line 651
    yajl_buf_append(lexer->buf, jsonText + startOffset, *offset - startOffset);
#line 652
    lexer->bufOff = (size_t )0;
    }
#line 654
    if ((unsigned int )tok != 3U) {
      {
#line 655
      *outBuf = yajl_buf_data(lexer->buf);
#line 656
      *outLen = yajl_buf_len(lexer->buf);
#line 657
      lexer->bufInUse = (unsigned int )0;
      }
    }
  } else
#line 648
  if (lexer->bufInUse) {
#line 648
    goto _L;
  } else
#line 659
  if ((unsigned int )tok != 4U) {
#line 660
    *outBuf = jsonText + startOffset;
#line 661
    *outLen = *offset - startOffset;
  }
#line 665
  if ((unsigned int )tok == 12U) {
#line 668
    (*outBuf) ++;
#line 669
    *outLen -= (unsigned long )2;
  } else
#line 665
  if ((unsigned int )tok == 13U) {
#line 668
    (*outBuf) ++;
#line 669
    *outLen -= (unsigned long )2;
  }
#line 673
  if ((unsigned int )tok == 14U) {
#line 676
    *outBuf += 2;
#line 677
    *outLen -= (unsigned long )4;
  }
#line 679
  if ((unsigned int )tok == 15U) {
#line 682
    *outBuf += 2;
#line 683
    *outLen -= (unsigned long )2;
#line 685
    if (*outLen >= 1UL) {
#line 685
      if ((int )*(*outBuf + (*outLen - 1UL)) == 10) {
#line 686
        *outLen -= (unsigned long )1;
      }
    }
  }
#line 702
  return (tok);
}
}
#line 706 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
char const   *yajl_lex_error_to_string(yajl_lex_error error___0 ) 
{ 


  {
  {
#line 709
  if ((unsigned int )error___0 == (unsigned int )0) {
#line 709
    goto case_0;
  }
#line 711
  if ((unsigned int )error___0 == (unsigned int )1) {
#line 711
    goto case_1;
  }
#line 713
  if ((unsigned int )error___0 == (unsigned int )2) {
#line 713
    goto case_2;
  }
#line 716
  if ((unsigned int )error___0 == (unsigned int )3) {
#line 716
    goto case_3;
  }
#line 718
  if ((unsigned int )error___0 == (unsigned int )4) {
#line 718
    goto case_4;
  }
#line 721
  if ((unsigned int )error___0 == (unsigned int )5) {
#line 721
    goto case_5;
  }
#line 723
  if ((unsigned int )error___0 == (unsigned int )6) {
#line 723
    goto case_6;
  }
#line 725
  if ((unsigned int )error___0 == (unsigned int )8) {
#line 725
    goto case_8;
  }
#line 727
  if ((unsigned int )error___0 == (unsigned int )7) {
#line 727
    goto case_7;
  }
#line 730
  if ((unsigned int )error___0 == (unsigned int )9) {
#line 730
    goto case_9;
  }
#line 733
  if ((unsigned int )error___0 == (unsigned int )10) {
#line 733
    goto case_10;
  }
#line 708
  goto switch_break;
  case_0: /* CIL Label */ 
#line 710
  return ("ok, no error");
  case_1: /* CIL Label */ 
#line 712
  return ("invalid bytes in UTF8 string.");
  case_2: /* CIL Label */ 
#line 714
  return ("inside a string, \'\\\' occurs before a character which it may not.");
  case_3: /* CIL Label */ 
#line 717
  return ("invalid character inside string.\220");
  case_4: /* CIL Label */ 
#line 719
  return ("invalid (non-hex) character occurs after \'\\u\' inside string.\220");
  case_5: /* CIL Label */ 
#line 722
  return ("invalid char in json text.");
  case_6: /* CIL Label */ 
#line 724
  return ("invalid string in json text.");
  case_8: /* CIL Label */ 
#line 726
  return ("malformed number, a digit is required after the exponent.");
  case_7: /* CIL Label */ 
#line 728
  return ("malformed number, a digit is required after the decimal point.");
  case_9: /* CIL Label */ 
#line 731
  return ("malformed number, a digit is required after the minus sign.");
  case_10: /* CIL Label */ 
#line 734
  return ("probable comment found in input text, comments are not enabled.");
  switch_break: /* CIL Label */ ;
  }
#line 737
  return ("unknown error code");
}
}
#line 744 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
yajl_lex_error yajl_lex_get_error(yajl_lexer lexer ) 
{ 


  {
#line 746
  if (lexer == (void *)0) {
#line 746
    return ((yajl_lex_error )(- 1));
  }
#line 747
  return (lexer->error);
}
}
#line 750 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
size_t yajl_lex_current_line(yajl_lexer lexer ) 
{ 


  {
#line 752
  return (lexer->lineOff);
}
}
#line 755 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
size_t yajl_lex_current_char(yajl_lexer lexer ) 
{ 


  {
#line 757
  return (lexer->charOff);
}
}
#line 760 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_lex.c"
yajl_tok yajl_lex_peek(yajl_lexer lexer , unsigned char const   *jsonText , size_t jsonTextLen ,
                       size_t offset ) 
{ 
  unsigned char const   *outBuf ;
  size_t outLen ;
  size_t bufLen ;
  size_t __cil_tmp8 ;
  size_t bufOff ;
  unsigned int bufInUse ;
  yajl_tok tok ;
  yajl_tok __cil_tmp12 ;

  {
  {
#line 765
  __cil_tmp8 = yajl_buf_len(lexer->buf);
#line 765
  bufLen = __cil_tmp8;
#line 766
  bufOff = lexer->bufOff;
#line 767
  bufInUse = lexer->bufInUse;
#line 770
  tok = yajl_lex_lex(lexer, jsonText, jsonTextLen, & offset, & outBuf, & outLen);
#line 773
  lexer->bufOff = bufOff;
#line 774
  lexer->bufInUse = bufInUse;
#line 775
  yajl_buf_truncate(lexer->buf, bufLen);
  }
#line 777
  return (tok);
}
}
#line 54 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
int yajl_gen_config(yajl_gen g , yajl_gen_option opt  , ...) 
{ 
  int rv ;
  va_list ap ;
  char const   *indent ;
  char const   *__cil_tmp6 ;

  {
  {
#line 56
  rv = 1;
#line 58
  __builtin_va_start((void *)ap, opt);
  }
  {
#line 63
  if ((unsigned int )opt == (unsigned int )16) {
#line 63
    goto case_16;
  }
#line 63
  if ((unsigned int )opt == (unsigned int )8) {
#line 63
    goto case_16;
  }
#line 63
  if ((unsigned int )opt == (unsigned int )1) {
#line 63
    goto case_16;
  }
#line 67
  if ((unsigned int )opt == (unsigned int )2) {
#line 67
    goto case_2;
  }
#line 84
  if ((unsigned int )opt == (unsigned int )4) {
#line 84
    goto case_4;
  }
#line 89
  goto switch_default;
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 64
  if (0) {
#line 64
    g->flags |= (unsigned int )opt;
  } else {
#line 65
    g->flags &= ~ ((unsigned int )opt);
  }
#line 66
  goto switch_break;
  case_2: /* CIL Label */ 
#line 68
  indent = 0;
#line 69
  g->indentString = indent;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *indent) {
#line 70
      goto while_break;
    }
#line 71
    if ((int )*indent != 10) {
#line 71
      if ((int )*indent != 11) {
#line 71
        if ((int )*indent != 12) {
#line 71
          if ((int )*indent != 9) {
#line 71
            if ((int )*indent != 13) {
#line 71
              if ((int )*indent != 32) {
#line 78
                g->indentString = (char const   *)((void *)0);
#line 79
                rv = 0;
              }
            }
          }
        }
      }
    }
#line 70
    indent ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 85
  yajl_buf_free(g->ctx);
  }
#line 86
  g->print = 0;
#line 87
  g->ctx = 0;
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 90
  rv = 0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 93
  __builtin_va_end((void *)ap);
  }
#line 95
  return (rv);
}
}
#line 101 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen yajl_gen_alloc(yajl_alloc_funcs *afs ) 
{ 
  yajl_gen g ;
  yajl_alloc_funcs afsBuffer ;
  void *__cil_tmp4 ;
  yajl_buf __cil_tmp5 ;

  {
#line 103
  g = (yajl_gen )((void *)0);
#line 107
  if (afs != (void *)0) {
#line 108
    if (afs->malloc == (void *)0) {
#line 110
      return ((yajl_gen )((void *)0));
    } else
#line 108
    if (afs->realloc == (void *)0) {
#line 110
      return ((yajl_gen )((void *)0));
    } else
#line 108
    if (afs->free == (void *)0) {
#line 110
      return ((yajl_gen )((void *)0));
    }
  } else {
    {
#line 113
    yajl_set_default_alloc_funcs(& afsBuffer);
#line 114
    afs = & afsBuffer;
    }
  }
  {
#line 117
  __cil_tmp4 = (*(afs->malloc))(afs->ctx, sizeof(struct yajl_gen_t ));
#line 117
  g = (yajl_gen )__cil_tmp4;
  }
#line 118
  if (! g) {
#line 118
    return ((yajl_gen )((void *)0));
  }
  {
#line 120
  memset((void *)g, 0, sizeof(struct yajl_gen_t ));
#line 122
  memcpy((void *)(& g->alloc), (void *)afs, sizeof(yajl_alloc_funcs ));
#line 124
  g->print = (yajl_print_t )(& yajl_buf_append);
#line 125
  g->ctx = (void *)yajl_buf_alloc(& g->alloc);
#line 126
  g->indentString = "    ";
  }
#line 128
  return (g);
}
}
#line 132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
void yajl_gen_reset(yajl_gen g , char const   *sep ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 134
  g->depth = (unsigned int )0;
#line 135
  memset((void *)(& g->state), 0, sizeof(g->state));
  }
#line 136
  if (sep != (void *)0) {
    {
#line 136
    __cil_tmp3 = strlen(sep);
#line 136
    (*(g->print))(g->ctx, sep, __cil_tmp3);
    }
  }
  return;
}
}
#line 140 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
void yajl_gen_free(yajl_gen g ) 
{ 


  {
#line 142
  if (g->print == (yajl_print_t )(& yajl_buf_append)) {
    {
#line 142
    yajl_buf_free((yajl_buf )g->ctx);
    }
  }
  {
#line 143
  (*(g->alloc.free))(g->alloc.ctx, g);
  }
  return;
}
}
#line 226 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
static void yajl_insert_eol(yajl_gen g ) 
{ 
  unsigned long __cil_tmp2 ;

  {
#line 227
  if (g->pendingComment != (void *)0) {
#line 228
    if (g->flags & 1U) {
#line 228
      if ((unsigned int )g->state[g->depth] != 3U) {
        {
#line 228
        __cil_tmp2 = strlen(g->indentString);
#line 228
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp2));
        }
      }
    }

#line 229
    if (g->pendingCpp) {
      {
#line 230
      (*(g->print))(g->ctx, "//", (size_t )2);
      }
    } else {
      {
#line 232
      (*(g->print))(g->ctx, "/*", (size_t )2);
      }
    }
    {
#line 233
    yajl_string_encode(g->print, g->ctx, (unsigned char const   *)g->pendingComment,
                       (size_t )g->pendingLen, (int )(g->flags & 16U));
    }
#line 235
    if (! g->pendingCpp) {
      {
#line 236
      (*(g->print))(g->ctx, "*/", (size_t )2);
      }
    }
    {
#line 237
    free(g->pendingComment);
#line 238
    g->pendingComment = (unsigned char *)((void *)0);
#line 239
    g->pendingLen = (unsigned int )0;
#line 240
    g->pendingCpp = 0;
    }
  }
  {
#line 242
  (*(g->print))(g->ctx, "\n", (size_t )1);
  }
  return;
}
}
#line 247 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
static void yajl_insert_pending_comment(yajl_gen g , unsigned char const   *str ,
                                        unsigned int len , int cpp ) 
{ 
  unsigned int tlen ;
  unsigned char *pendingComment ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 249
  if (g->pendingComment != (void *)0) {
    {
#line 250
    tlen = g->pendingLen + len;
#line 252
    __cil_tmp7 = realloc(g->pendingComment, sizeof(char ) * (unsigned long )tlen);
#line 252
    pendingComment = (unsigned char *)__cil_tmp7;
#line 253
    memcpy((pendingComment + g->pendingLen) + 0, str, (unsigned long )len);
#line 254
    g->pendingComment = pendingComment;
#line 255
    g->pendingLen = tlen;
    }
  } else {
    {
#line 257
    __cil_tmp8 = malloc(sizeof(char ) * (unsigned long )len);
#line 257
    g->pendingComment = (unsigned char *)__cil_tmp8;
#line 258
    memcpy(g->pendingComment, str, (unsigned long )len);
#line 259
    g->pendingLen = len;
    }
  }
#line 261
  g->pendingCpp = cpp;
  return;
}
}
#line 265 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_integer(yajl_gen g , longlong number ) 
{ 
  char i[32] ;
  unsigned int _i ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;

  {
#line 268
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 268
    return ((yajl_gen_status )3);
  } else
#line 268
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 268
    return ((yajl_gen_status )4);
  }

#line 268
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 268
    return ((yajl_gen_status )1);
  } else
#line 268
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 268
    return ((yajl_gen_status )1);
  }

#line 268
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 268
    (*(g->print))(g->ctx, ",", (size_t )1);
    }
#line 268
    if (g->pendingComment != (void *)0) {
      {
      {
#line 268
      yajl_insert_eol(g);
      }
      }
    } else
#line 268
    if (g->flags & 1U) {
      {
      {
#line 268
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 268
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 268
    goto _L;
  } else
#line 268
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 268
    (*(g->print))(g->ctx, ":", (size_t )1);
    }
#line 268
    if (g->flags & 1U) {
      {
#line 268
      (*(g->print))(g->ctx, " ", (size_t )1);
      }
    }
  }

#line 268
  if (g->flags & 1U) {
#line 268
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 268
      _i = (unsigned int )0;
      {
#line 268
      while (1) {
        while_continue: /* CIL Label */ ;
#line 268
        if (! (_i < g->depth)) {
#line 268
          goto while_break;
        }
        {
#line 268
        __cil_tmp5 = strlen(g->indentString);
#line 268
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp5));
        }
#line 268
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 269
  sprintf((char *)i, "%lld", number);
#line 270
  __cil_tmp7 = strlen((char const   *)((char *)i));
#line 270
  (*(g->print))(g->ctx, (char const   *)((char *)i), (size_t )((unsigned int )__cil_tmp7));
  }
  {
#line 271
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 271
    goto case_0;
  }
#line 271
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 271
    goto case_2;
  }
#line 271
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 271
    goto case_2;
  }
#line 271
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 271
    goto case_4;
  }
#line 271
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 271
    goto case_3;
  }
#line 271
  goto switch_default;
  case_0: /* CIL Label */ 
#line 271
  g->state[g->depth] = (yajl_gen_state )6;
#line 271
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 271
  g->state[g->depth] = (yajl_gen_state )3;
#line 271
  goto switch_break;
  case_4: /* CIL Label */ 
#line 271
  g->state[g->depth] = (yajl_gen_state )5;
#line 271
  goto switch_break;
  case_3: /* CIL Label */ 
#line 271
  g->state[g->depth] = (yajl_gen_state )2;
#line 271
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 272
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 272
    if (g->pendingComment != (void *)0) {
      {
      {
#line 272
      yajl_insert_eol(g);
      }
      }
    } else
#line 272
    if (g->flags & 1U) {
      {
      {
#line 272
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 273
  return ((yajl_gen_status )0);
}
}
#line 283 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_double(yajl_gen g , double number ) 
{ 
  char i[32] ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned int _i ;
  unsigned long __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;

  {
#line 286
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 286
    return ((yajl_gen_status )3);
  } else
#line 286
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 286
    return ((yajl_gen_status )4);
  }

#line 286
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 286
    return ((yajl_gen_status )1);
  } else
#line 286
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 286
    return ((yajl_gen_status )1);
  }
  {
#line 287
  __cil_tmp5 = __builtin_isinf_sign(number);
  }
  {
#line 287
  __cil_tmp4 = __builtin_isnan(number);
  }
#line 287
  if (__cil_tmp4) {
#line 287
    return ((yajl_gen_status )5);
  } else
#line 287
  if (__cil_tmp5) {
#line 287
    return ((yajl_gen_status )5);
  }
#line 288
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 288
    (*(g->print))(g->ctx, ",", (size_t )1);
    }
#line 288
    if (g->pendingComment != (void *)0) {
      {
      {
#line 288
      yajl_insert_eol(g);
      }
      }
    } else
#line 288
    if (g->flags & 1U) {
      {
      {
#line 288
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 288
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 288
    goto _L;
  } else
#line 288
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 288
    (*(g->print))(g->ctx, ":Q\254\030\313U", (size_t )1);
    }
#line 288
    if (g->flags & 1U) {
      {
#line 288
      (*(g->print))(g->ctx, " ", (size_t )1);
      }
    }
  }

#line 288
  if (g->flags & 1U) {
#line 288
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 288
      _i = (unsigned int )0;
      {
#line 288
      while (1) {
        while_continue: /* CIL Label */ ;
#line 288
        if (! (_i < g->depth)) {
#line 288
          goto while_break;
        }
        {
#line 288
        __cil_tmp7 = strlen(g->indentString);
#line 288
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp7));
        }
#line 288
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 289
  sprintf((char *)i, "%.20gU", number);
#line 290
  __cil_tmp10 = strlen((char const   *)((char *)i));
  }
  {
#line 290
  __cil_tmp9 = strspn((char const   *)((char *)i), "0123456789-\030\313U");
  }
#line 290
  if (__cil_tmp9 == __cil_tmp10) {
    {
#line 291
    strcat((char *)i, ".0\254\030\313U");
    }
  }
  {
#line 293
  __cil_tmp11 = strlen((char const   *)((char *)i));
#line 293
  (*(g->print))(g->ctx, (char const   *)((char *)i), (size_t )((unsigned int )__cil_tmp11));
  }
  {
#line 294
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 294
    goto case_0;
  }
#line 294
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 294
    goto case_2;
  }
#line 294
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 294
    goto case_2;
  }
#line 294
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 294
    goto case_4;
  }
#line 294
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 294
    goto case_3;
  }
#line 294
  goto switch_default;
  case_0: /* CIL Label */ 
#line 294
  g->state[g->depth] = (yajl_gen_state )6;
#line 294
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 294
  g->state[g->depth] = (yajl_gen_state )3;
#line 294
  goto switch_break;
  case_4: /* CIL Label */ 
#line 294
  g->state[g->depth] = (yajl_gen_state )5;
#line 294
  goto switch_break;
  case_3: /* CIL Label */ 
#line 294
  g->state[g->depth] = (yajl_gen_state )2;
#line 294
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 295
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 295
    if (g->pendingComment != (void *)0) {
      {
      {
#line 295
      yajl_insert_eol(g);
      }
      }
    } else
#line 295
    if (g->flags & 1U) {
      {
      {
#line 295
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 296
  return ((yajl_gen_status )0);
}
}
#line 300 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_number(yajl_gen g , char const   *s , size_t l ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp5 ;
  unsigned int __cil_tmp6 ;

  {
#line 302
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 302
    return ((yajl_gen_status )3);
  } else
#line 302
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 302
    return ((yajl_gen_status )4);
  }

#line 302
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 302
    return ((yajl_gen_status )1);
  } else
#line 302
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 302
    return ((yajl_gen_status )1);
  }

#line 302
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 302
    (*(g->print))(g->ctx, ",\244\254\030\313U", (size_t )1);
    }
#line 302
    if (g->pendingComment != (void *)0) {
      {
      {
#line 302
      yajl_insert_eol(g);
      }
      }
    } else
#line 302
    if (g->flags & 1U) {
      {
      {
#line 302
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 302
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 302
    goto _L;
  } else
#line 302
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 302
    (*(g->print))(g->ctx, ":+\254\030\313U", (size_t )1);
    }
#line 302
    if (g->flags & 1U) {
      {
#line 302
      (*(g->print))(g->ctx, " \270\254\030\313U", (size_t )1);
      }
    }
  }

#line 302
  if (g->flags & 1U) {
#line 302
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 302
      _i = (unsigned int )0;
      {
#line 302
      while (1) {
        while_continue: /* CIL Label */ ;
#line 302
        if (! (_i < g->depth)) {
#line 302
          goto while_break;
        }
        {
#line 302
        __cil_tmp5 = strlen(g->indentString);
#line 302
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp5));
        }
#line 302
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 303
  (*(g->print))(g->ctx, s, l);
  }
  {
#line 304
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 304
    goto case_0;
  }
#line 304
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 304
    goto case_2;
  }
#line 304
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 304
    goto case_2;
  }
#line 304
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 304
    goto case_4;
  }
#line 304
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 304
    goto case_3;
  }
#line 304
  goto switch_default;
  case_0: /* CIL Label */ 
#line 304
  g->state[g->depth] = (yajl_gen_state )6;
#line 304
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 304
  g->state[g->depth] = (yajl_gen_state )3;
#line 304
  goto switch_break;
  case_4: /* CIL Label */ 
#line 304
  g->state[g->depth] = (yajl_gen_state )5;
#line 304
  goto switch_break;
  case_3: /* CIL Label */ 
#line 304
  g->state[g->depth] = (yajl_gen_state )2;
#line 304
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 304
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 305
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 305
    if (g->pendingComment != (void *)0) {
      {
      {
#line 305
      yajl_insert_eol(g);
      }
      }
    } else
#line 305
    if (g->flags & 1U) {
      {
      {
#line 305
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 306
  return ((yajl_gen_status )0);
}
}
#line 310 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_string(yajl_gen g , unsigned char const   *str , size_t len ) 
{ 
  int __cil_tmp4 ;
  unsigned int _i ;
  unsigned long __cil_tmp6 ;
  unsigned int __cil_tmp7 ;

  {
#line 316
  if (g->flags & 8U) {
    {
#line 317
    __cil_tmp4 = yajl_string_validate_utf8(str, len);
    }
#line 317
    if (! __cil_tmp4) {
#line 318
      return ((yajl_gen_status )7);
    }
  }
#line 321
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 321
    return ((yajl_gen_status )3);
  } else
#line 321
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 321
    return ((yajl_gen_status )4);
  }

#line 321
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 321
    (*(g->print))(g->ctx, ",\267\254\030\313U", (size_t )1);
    }
#line 321
    if (g->pendingComment != (void *)0) {
      {
      {
#line 321
      yajl_insert_eol(g);
      }
      }
    } else
#line 321
    if (g->flags & 1U) {
      {
      {
#line 321
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 321
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 321
    goto _L;
  } else
#line 321
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 321
    (*(g->print))(g->ctx, ":\275\254\030\313U", (size_t )1);
    }
#line 321
    if (g->flags & 1U) {
      {
#line 321
      (*(g->print))(g->ctx, " \336\254\030\313U", (size_t )1);
      }
    }
  }

#line 321
  if (g->flags & 1U) {
#line 321
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 321
      _i = (unsigned int )0;
      {
#line 321
      while (1) {
        while_continue: /* CIL Label */ ;
#line 321
        if (! (_i < g->depth)) {
#line 321
          goto while_break;
        }
        {
#line 321
        __cil_tmp6 = strlen(g->indentString);
#line 321
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp6));
        }
#line 321
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 322
  (*(g->print))(g->ctx, "\"", (size_t )1);
#line 323
  yajl_string_encode(g->print, g->ctx, str, len, (int )(g->flags & 16U));
#line 324
  (*(g->print))(g->ctx, "\"\347\254\030\313U", (size_t )1);
  }
  {
#line 325
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 325
    goto case_0;
  }
#line 325
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 325
    goto case_2;
  }
#line 325
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 325
    goto case_2;
  }
#line 325
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 325
    goto case_4;
  }
#line 325
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 325
    goto case_3;
  }
#line 325
  goto switch_default;
  case_0: /* CIL Label */ 
#line 325
  g->state[g->depth] = (yajl_gen_state )6;
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 325
  g->state[g->depth] = (yajl_gen_state )3;
#line 325
  goto switch_break;
  case_4: /* CIL Label */ 
#line 325
  g->state[g->depth] = (yajl_gen_state )5;
#line 325
  goto switch_break;
  case_3: /* CIL Label */ 
#line 325
  g->state[g->depth] = (yajl_gen_state )2;
#line 325
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 325
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 326
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 326
    if (g->pendingComment != (void *)0) {
      {
      {
#line 326
      yajl_insert_eol(g);
      }
      }
    } else
#line 326
    if (g->flags & 1U) {
      {
      {
#line 326
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 327
  return ((yajl_gen_status )0);
}
}
#line 331 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_null(yajl_gen g ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;

  {
#line 333
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 333
    return ((yajl_gen_status )3);
  } else
#line 333
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 333
    return ((yajl_gen_status )4);
  }

#line 333
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 333
    return ((yajl_gen_status )1);
  } else
#line 333
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 333
    return ((yajl_gen_status )1);
  }

#line 333
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 333
    (*(g->print))(g->ctx, ",\375\254\030\313U", (size_t )1);
    }
#line 333
    if (g->pendingComment != (void *)0) {
      {
      {
#line 333
      yajl_insert_eol(g);
      }
      }
    } else
#line 333
    if (g->flags & 1U) {
      {
      {
#line 333
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 333
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 333
    goto _L;
  } else
#line 333
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 333
    (*(g->print))(g->ctx, ":", (size_t )1);
    }
#line 333
    if (g->flags & 1U) {
      {
#line 333
      (*(g->print))(g->ctx, " \027\255\030\313U", (size_t )1);
      }
    }
  }

#line 333
  if (g->flags & 1U) {
#line 333
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 333
      _i = (unsigned int )0;
      {
#line 333
      while (1) {
        while_continue: /* CIL Label */ ;
#line 333
        if (! (_i < g->depth)) {
#line 333
          goto while_break;
        }
        {
#line 333
        __cil_tmp3 = strlen(g->indentString);
#line 333
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp3));
        }
#line 333
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 334
  __cil_tmp5 = strlen("null");
#line 334
  (*(g->print))(g->ctx, "null", __cil_tmp5);
  }
  {
#line 335
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 335
    goto case_0;
  }
#line 335
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 335
    goto case_2;
  }
#line 335
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 335
    goto case_2;
  }
#line 335
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 335
    goto case_4;
  }
#line 335
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 335
    goto case_3;
  }
#line 335
  goto switch_default;
  case_0: /* CIL Label */ 
#line 335
  g->state[g->depth] = (yajl_gen_state )6;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 335
  g->state[g->depth] = (yajl_gen_state )3;
#line 335
  goto switch_break;
  case_4: /* CIL Label */ 
#line 335
  g->state[g->depth] = (yajl_gen_state )5;
#line 335
  goto switch_break;
  case_3: /* CIL Label */ 
#line 335
  g->state[g->depth] = (yajl_gen_state )2;
#line 335
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 335
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 336
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 336
    if (g->pendingComment != (void *)0) {
      {
      {
#line 336
      yajl_insert_eol(g);
      }
      }
    } else
#line 336
    if (g->flags & 1U) {
      {
      {
#line 336
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 337
  return ((yajl_gen_status )0);
}
}
#line 341 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_bool(yajl_gen g , int boolean ) 
{ 
  char const   *val ;
  char const   *tmp ;
  unsigned int _i ;
  unsigned long __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;

  {
#line 343
  if (boolean) {
#line 343
    tmp = "true";
  } else {
#line 343
    tmp = "false";
  }
#line 343
  val = tmp;
#line 345
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 345
    return ((yajl_gen_status )3);
  } else
#line 345
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 345
    return ((yajl_gen_status )4);
  }

#line 345
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 345
    return ((yajl_gen_status )1);
  } else
#line 345
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 345
    return ((yajl_gen_status )1);
  }

#line 345
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 345
    (*(g->print))(g->ctx, ",\332\254\030\313U", (size_t )1);
    }
#line 345
    if (g->pendingComment != (void *)0) {
      {
      {
#line 345
      yajl_insert_eol(g);
      }
      }
    } else
#line 345
    if (g->flags & 1U) {
      {
      {
#line 345
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 345
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 345
    goto _L;
  } else
#line 345
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 345
    (*(g->print))(g->ctx, ":", (size_t )1);
    }
#line 345
    if (g->flags & 1U) {
      {
#line 345
      (*(g->print))(g->ctx, " L\255\030\313U", (size_t )1);
      }
    }
  }

#line 345
  if (g->flags & 1U) {
#line 345
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 345
      _i = (unsigned int )0;
      {
#line 345
      while (1) {
        while_continue: /* CIL Label */ ;
#line 345
        if (! (_i < g->depth)) {
#line 345
          goto while_break;
        }
        {
#line 345
        __cil_tmp6 = strlen(g->indentString);
#line 345
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp6));
        }
#line 345
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 346
  __cil_tmp8 = strlen(val);
#line 346
  (*(g->print))(g->ctx, val, (size_t )((unsigned int )__cil_tmp8));
  }
  {
#line 347
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 347
    goto case_0;
  }
#line 347
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 347
    goto case_2;
  }
#line 347
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 347
    goto case_2;
  }
#line 347
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 347
    goto case_4;
  }
#line 347
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 347
    goto case_3;
  }
#line 347
  goto switch_default;
  case_0: /* CIL Label */ 
#line 347
  g->state[g->depth] = (yajl_gen_state )6;
#line 347
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 347
  g->state[g->depth] = (yajl_gen_state )3;
#line 347
  goto switch_break;
  case_4: /* CIL Label */ 
#line 347
  g->state[g->depth] = (yajl_gen_state )5;
#line 347
  goto switch_break;
  case_3: /* CIL Label */ 
#line 347
  g->state[g->depth] = (yajl_gen_state )2;
#line 347
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 347
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 348
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 348
    if (g->pendingComment != (void *)0) {
      {
      {
#line 348
      yajl_insert_eol(g);
      }
      }
    } else
#line 348
    if (g->flags & 1U) {
      {
      {
#line 348
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 349
  return ((yajl_gen_status )0);
}
}
#line 353 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_map_open(yajl_gen g ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 355
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 355
    return ((yajl_gen_status )3);
  } else
#line 355
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 355
    return ((yajl_gen_status )4);
  }

#line 355
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 355
    return ((yajl_gen_status )1);
  } else
#line 355
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 355
    return ((yajl_gen_status )1);
  }

#line 355
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 355
    (*(g->print))(g->ctx, ",", (size_t )1);
    }
#line 355
    if (g->pendingComment != (void *)0) {
      {
      {
#line 355
      yajl_insert_eol(g);
      }
      }
    } else
#line 355
    if (g->flags & 1U) {
      {
      {
#line 355
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 355
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 355
    goto _L;
  } else
#line 355
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 355
    (*(g->print))(g->ctx, ":\216\255\030\313U", (size_t )1);
    }
#line 355
    if (g->flags & 1U) {
      {
#line 355
      (*(g->print))(g->ctx, " t\255\030\313U", (size_t )1);
      }
    }
  }

#line 355
  if (g->flags & 1U) {
#line 355
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 355
      _i = (unsigned int )0;
      {
#line 355
      while (1) {
        while_continue: /* CIL Label */ ;
#line 355
        if (! (_i < g->depth)) {
#line 355
          goto while_break;
        }
        {
#line 355
        __cil_tmp3 = strlen(g->indentString);
#line 355
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp3));
        }
#line 355
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 356
  (g->depth) ++;
#line 356
  if (g->depth >= 128U) {
#line 356
    return ((yajl_gen_status )2);
  }
  {
#line 358
  g->state[g->depth] = (yajl_gen_state )1;
#line 359
  (*(g->print))(g->ctx, "{Q\255\030\313U", (size_t )1);
  }
#line 360
  if (g->pendingComment != (void *)0) {
    {
    {
#line 360
    yajl_insert_eol(g);
    }
    }
  } else
#line 360
  if (g->flags & 1U) {
    {
    {
#line 360
    yajl_insert_eol(g);
    }
    }
  }

#line 361
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 361
    if (g->pendingComment != (void *)0) {
      {
      {
#line 361
      yajl_insert_eol(g);
      }
      }
    } else
#line 361
    if (g->flags & 1U) {
      {
      {
#line 361
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 362
  return ((yajl_gen_status )0);
}
}
#line 366 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_map_close(yajl_gen g ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 368
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 368
    return ((yajl_gen_status )3);
  } else
#line 368
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 368
    return ((yajl_gen_status )4);
  }
#line 369
  (g->depth) --;
#line 369
  if (g->depth >= 128U) {
#line 369
    return ((yajl_gen_status )4);
  }

#line 371
  if (g->pendingComment != (void *)0) {
    {
    {
#line 371
    yajl_insert_eol(g);
    }
    }
  } else
#line 371
  if (g->flags & 1U) {
    {
    {
#line 371
    yajl_insert_eol(g);
    }
    }
  }

  {
#line 372
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 372
    goto case_0;
  }
#line 372
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 372
    goto case_2;
  }
#line 372
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 372
    goto case_2;
  }
#line 372
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 372
    goto case_4;
  }
#line 372
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 372
    goto case_3;
  }
#line 372
  goto switch_default;
  case_0: /* CIL Label */ 
#line 372
  g->state[g->depth] = (yajl_gen_state )6;
#line 372
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 372
  g->state[g->depth] = (yajl_gen_state )3;
#line 372
  goto switch_break;
  case_4: /* CIL Label */ 
#line 372
  g->state[g->depth] = (yajl_gen_state )5;
#line 372
  goto switch_break;
  case_3: /* CIL Label */ 
#line 372
  g->state[g->depth] = (yajl_gen_state )2;
#line 372
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 372
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 373
  if (g->flags & 1U) {
#line 373
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 373
      _i = (unsigned int )0;
      {
#line 373
      while (1) {
        while_continue: /* CIL Label */ ;
#line 373
        if (! (_i < g->depth)) {
#line 373
          goto while_break;
        }
        {
#line 373
        __cil_tmp3 = strlen(g->indentString);
#line 373
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp3));
        }
#line 373
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 374
  (*(g->print))(g->ctx, "}>", (size_t )1);
  }
#line 375
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 375
    if (g->pendingComment != (void *)0) {
      {
      {
#line 375
      yajl_insert_eol(g);
      }
      }
    } else
#line 375
    if (g->flags & 1U) {
      {
      {
#line 375
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 376
  return ((yajl_gen_status )0);
}
}
#line 380 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_array_open(yajl_gen g ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 382
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 382
    return ((yajl_gen_status )3);
  } else
#line 382
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 382
    return ((yajl_gen_status )4);
  }

#line 382
  if ((unsigned int )g->state[g->depth] == 2U) {
#line 382
    return ((yajl_gen_status )1);
  } else
#line 382
  if ((unsigned int )g->state[g->depth] == 1U) {
#line 382
    return ((yajl_gen_status )1);
  }

#line 382
  if ((unsigned int )g->state[g->depth] == 2U) {
    _L: /* CIL Label */ 
    {
#line 382
    (*(g->print))(g->ctx, ",\b\002", (size_t )1);
    }
#line 382
    if (g->pendingComment != (void *)0) {
      {
      {
#line 382
      yajl_insert_eol(g);
      }
      }
    } else
#line 382
    if (g->flags & 1U) {
      {
      {
#line 382
      yajl_insert_eol(g);
      }
      }
    }

  } else
#line 382
  if ((unsigned int )g->state[g->depth] == 5U) {
#line 382
    goto _L;
  } else
#line 382
  if ((unsigned int )g->state[g->depth] == 3U) {
    {
#line 382
    (*(g->print))(g->ctx, ":", (size_t )1);
    }
#line 382
    if (g->flags & 1U) {
      {
#line 382
      (*(g->print))(g->ctx, " ", (size_t )1);
      }
    }
  }

#line 382
  if (g->flags & 1U) {
#line 382
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 382
      _i = (unsigned int )0;
      {
#line 382
      while (1) {
        while_continue: /* CIL Label */ ;
#line 382
        if (! (_i < g->depth)) {
#line 382
          goto while_break;
        }
        {
#line 382
        __cil_tmp3 = strlen(g->indentString);
#line 382
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp3));
        }
#line 382
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 383
  (g->depth) ++;
#line 383
  if (g->depth >= 128U) {
#line 383
    return ((yajl_gen_status )2);
  }
  {
#line 384
  g->state[g->depth] = (yajl_gen_state )4;
#line 385
  (*(g->print))(g->ctx, "[", (size_t )1);
  }
#line 386
  if (g->pendingComment != (void *)0) {
    {
    {
#line 386
    yajl_insert_eol(g);
    }
    }
  } else
#line 386
  if (g->flags & 1U) {
    {
    {
#line 386
    yajl_insert_eol(g);
    }
    }
  }

#line 387
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 387
    if (g->pendingComment != (void *)0) {
      {
      {
#line 387
      yajl_insert_eol(g);
      }
      }
    } else
#line 387
    if (g->flags & 1U) {
      {
      {
#line 387
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 388
  return ((yajl_gen_status )0);
}
}
#line 392 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_array_close(yajl_gen g ) 
{ 
  unsigned int _i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
#line 394
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 394
    return ((yajl_gen_status )3);
  } else
#line 394
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 394
    return ((yajl_gen_status )4);
  }
#line 395
  (g->depth) --;
#line 395
  if (g->depth >= 128U) {
#line 395
    return ((yajl_gen_status )4);
  }

#line 396
  if (g->pendingComment != (void *)0) {
    {
    {
#line 396
    yajl_insert_eol(g);
    }
    }
  } else
#line 396
  if (g->flags & 1U) {
    {
    {
#line 396
    yajl_insert_eol(g);
    }
    }
  }

  {
#line 397
  if ((unsigned int )g->state[g->depth] == (unsigned int )0) {
#line 397
    goto case_0;
  }
#line 397
  if ((unsigned int )g->state[g->depth] == (unsigned int )2) {
#line 397
    goto case_2;
  }
#line 397
  if ((unsigned int )g->state[g->depth] == (unsigned int )1) {
#line 397
    goto case_2;
  }
#line 397
  if ((unsigned int )g->state[g->depth] == (unsigned int )4) {
#line 397
    goto case_4;
  }
#line 397
  if ((unsigned int )g->state[g->depth] == (unsigned int )3) {
#line 397
    goto case_3;
  }
#line 397
  goto switch_default;
  case_0: /* CIL Label */ 
#line 397
  g->state[g->depth] = (yajl_gen_state )6;
#line 397
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 397
  g->state[g->depth] = (yajl_gen_state )3;
#line 397
  goto switch_break;
  case_4: /* CIL Label */ 
#line 397
  g->state[g->depth] = (yajl_gen_state )5;
#line 397
  goto switch_break;
  case_3: /* CIL Label */ 
#line 397
  g->state[g->depth] = (yajl_gen_state )2;
#line 397
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 397
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }

#line 398
  if (g->flags & 1U) {
#line 398
    if ((unsigned int )g->state[g->depth] != 3U) {
#line 398
      _i = (unsigned int )0;
      {
#line 398
      while (1) {
        while_continue: /* CIL Label */ ;
#line 398
        if (! (_i < g->depth)) {
#line 398
          goto while_break;
        }
        {
#line 398
        __cil_tmp3 = strlen(g->indentString);
#line 398
        (*(g->print))(g->ctx, g->indentString, (size_t )((unsigned int )__cil_tmp3));
        }
#line 398
        _i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 399
  (*(g->print))(g->ctx, "]8\256\030\313U", (size_t )1);
  }
#line 400
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 400
    if (g->pendingComment != (void *)0) {
      {
      {
#line 400
      yajl_insert_eol(g);
      }
      }
    } else
#line 400
    if (g->flags & 1U) {
      {
      {
#line 400
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 401
  return ((yajl_gen_status )0);
}
}
#line 405 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_c_comment(yajl_gen g , unsigned char const   *str , unsigned int len ,
                                   int dlytoeol ) 
{ 


  {
#line 408
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 408
    return ((yajl_gen_status )3);
  } else
#line 408
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 408
    return ((yajl_gen_status )4);
  }

#line 409
  if (dlytoeol) {
    {
#line 410
    yajl_insert_pending_comment(g, str, len, 0);
    }
  } else {
#line 412
    if (g->flags & 1U) {
      {
#line 413
      (*(g->print))(g->ctx, " /*", (size_t )3);
      }
    } else {
      {
#line 415
      (*(g->print))(g->ctx, "/*", (size_t )2);
      }
    }
    {
#line 416
    yajl_string_encode(g->print, g->ctx, str, (size_t )len, (int )(g->flags & 16U));
    }
#line 417
    if (g->flags & 1U) {
      {
#line 418
      (*(g->print))(g->ctx, "*/ \030\313U", (size_t )3);
      }
    } else {
      {
#line 420
      (*(g->print))(g->ctx, "*/", (size_t )2);
      }
    }
  }
#line 422
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 422
    if (g->pendingComment != (void *)0) {
      {
      {
#line 422
      yajl_insert_eol(g);
      }
      }
    } else
#line 422
    if (g->flags & 1U) {
      {
      {
#line 422
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 423
  return ((yajl_gen_status )0);
}
}
#line 427 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_cpp_comment(yajl_gen g , unsigned char const   *str , unsigned int len ) 
{ 


  {
#line 430
  if ((unsigned int )g->state[g->depth] == 7U) {
#line 430
    return ((yajl_gen_status )3);
  } else
#line 430
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 430
    return ((yajl_gen_status )4);
  }
  {
#line 431
  yajl_insert_pending_comment(g, str, len, 1);
  }
#line 432
  if ((unsigned int )g->state[g->depth] == 6U) {
#line 432
    if (g->pendingComment != (void *)0) {
      {
      {
#line 432
      yajl_insert_eol(g);
      }
      }
    } else
#line 432
    if (g->flags & 1U) {
      {
      {
#line 432
      yajl_insert_eol(g);
      }
      }
    }
  }

#line 433
  return ((yajl_gen_status )0);
}
}
#line 437 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
yajl_gen_status yajl_gen_get_buf(yajl_gen g , unsigned char const   **buf , size_t *len ) 
{ 
  unsigned char const   *__cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
#line 440
  if (g->print != (yajl_print_t )(& yajl_buf_append)) {
#line 440
    return ((yajl_gen_status )6);
  }
  {
#line 441
  *buf = yajl_buf_data((yajl_buf )g->ctx);
#line 442
  *len = yajl_buf_len((yajl_buf )g->ctx);
  }
#line 443
  return ((yajl_gen_status )0);
}
}
#line 447 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_gen.c"
void yajl_gen_clear(yajl_gen g ) 
{ 


  {
#line 449
  if (g->print == (yajl_print_t )(& yajl_buf_append)) {
    {
#line 449
    yajl_buf_clear((yajl_buf )g->ctx);
    }
  }
  return;
}
}
#line 24 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
static void CharToHex(unsigned char c , char *hexBuf ) 
{ 
  char const   *hexchar ;

  {
#line 26
  hexchar = "0123456789ABCDEF\220";
#line 27
  *(hexBuf + 0) = *(hexchar + ((int )c >> 4));
#line 28
  *(hexBuf + 1) = *(hexchar + ((int )c & 15));
  return;
}
}
#line 32 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
void yajl_string_encode(yajl_print_t print , void *ctx , unsigned char const   *str ,
                        size_t len , int escape_solidus ) 
{ 
  size_t beg ;
  size_t end ;
  char hexBuf[7] ;
  char const   *escaped ;
  unsigned long __cil_tmp10 ;

  {
#line 38
  beg = (size_t )0;
#line 39
  end = (size_t )0;
#line 41
  hexBuf[0] = (char )'\\';
#line 41
  hexBuf[1] = (char )'u';
#line 41
  hexBuf[2] = (char )'0';
#line 41
  hexBuf[3] = (char )'0';
#line 42
  hexBuf[6] = (char )0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (end < len)) {
#line 44
      goto while_break;
    }
#line 45
    escaped = (char const   *)((void *)0);
    {
#line 47
    if ((int )*(str + end) == '\r') {
#line 47
      goto case_13;
    }
#line 48
    if ((int )*(str + end) == '\n') {
#line 48
      goto case_10;
    }
#line 49
    if ((int )*(str + end) == '\\') {
#line 49
      goto case_92;
    }
#line 55
    if ((int )*(str + end) == '/') {
#line 55
      goto case_47;
    }
#line 56
    if ((int )*(str + end) == '\"') {
#line 56
      goto case_34;
    }
#line 57
    if ((int )*(str + end) == '\f') {
#line 57
      goto case_12;
    }
#line 58
    if ((int )*(str + end) == '\b') {
#line 58
      goto case_8;
    }
#line 59
    if ((int )*(str + end) == '\t') {
#line 59
      goto case_9;
    }
#line 60
    goto switch_default;
    case_13: /* CIL Label */ 
#line 47
    escaped = "\\r";
#line 47
    goto switch_break;
    case_10: /* CIL Label */ 
#line 48
    escaped = "\\n";
#line 48
    goto switch_break;
    case_92: /* CIL Label */ 
#line 49
    escaped = "\\\\";
#line 49
    goto switch_break;
    case_47: /* CIL Label */ 
#line 55
    if (escape_solidus) {
#line 55
      escaped = "\\/";
    }
#line 55
    goto switch_break;
    case_34: /* CIL Label */ 
#line 56
    escaped = "\\\"";
#line 56
    goto switch_break;
    case_12: /* CIL Label */ 
#line 57
    escaped = "\\f";
#line 57
    goto switch_break;
    case_8: /* CIL Label */ 
#line 58
    escaped = "\\b";
#line 58
    goto switch_break;
    case_9: /* CIL Label */ 
#line 59
    escaped = "\\t";
#line 59
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 61
    if ((int )((unsigned char )*(str + end)) < 32) {
      {
#line 62
      CharToHex(*(str + end), (char *)hexBuf + 4);
#line 63
      escaped = (char const   *)((char *)hexBuf);
      }
    }
#line 65
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 67
    if (escaped != (void *)0) {
      {
#line 68
      (*print)(ctx, (char const   *)(str + beg), end - beg);
#line 69
      __cil_tmp10 = strlen(escaped);
#line 69
      (*print)(ctx, escaped, (size_t )((unsigned int )__cil_tmp10));
#line 70
      end ++;
#line 70
      beg = end;
      }
    } else {
#line 72
      end ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  (*print)(ctx, (char const   *)(str + beg), end - beg);
  }
  return;
}
}
#line 78 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
static void hexToDigit(unsigned int *val , unsigned char const   *hex ) 
{ 
  unsigned int i ;
  unsigned char c ;
  int tmp ;
  unsigned int __cil_tmp6 ;

  {
#line 81
  i = (unsigned int )0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 4U)) {
#line 81
      goto while_break;
    }
#line 82
    c = *(hex + i);
#line 83
    if ((int )c >= 65) {
#line 83
      c = (unsigned char )(((int )c & -33) - 7);
    }
#line 84
    c -= '0';
#line 86
    *val = (*val << 4) | (unsigned int )c;
#line 81
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 90 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
static void Utf32toUtf8(unsigned int codepoint , char *utf8Buf ) 
{ 


  {
#line 92
  if (codepoint < 128U) {
#line 93
    *(utf8Buf + 0) = (char )codepoint;
#line 94
    *(utf8Buf + 1) = (char )0;
  } else
#line 95
  if (codepoint < 2048U) {
#line 96
    *(utf8Buf + 0) = (char )((codepoint >> 6) | 192U);
#line 97
    *(utf8Buf + 1) = (char )((codepoint & 63U) | 128U);
#line 98
    *(utf8Buf + 2) = (char )0;
  } else
#line 99
  if (codepoint < 65536U) {
#line 100
    *(utf8Buf + 0) = (char )((codepoint >> 12) | 224U);
#line 101
    *(utf8Buf + 1) = (char )(((codepoint >> 6) & 63U) | 128U);
#line 102
    *(utf8Buf + 2) = (char )((codepoint & 63U) | 128U);
#line 103
    *(utf8Buf + 3) = (char )0;
  } else
#line 104
  if (codepoint < 2097152U) {
#line 105
    *(utf8Buf + 0) = (char )((codepoint >> 18) | 240U);
#line 106
    *(utf8Buf + 1) = (char )(((codepoint >> 12) & 63U) | 128U);
#line 107
    *(utf8Buf + 2) = (char )(((codepoint >> 6) & 63U) | 128U);
#line 108
    *(utf8Buf + 3) = (char )((codepoint & 63U) | 128U);
#line 109
    *(utf8Buf + 4) = (char )0;
  } else {
#line 111
    *(utf8Buf + 0) = (char )'?';
#line 112
    *(utf8Buf + 1) = (char )0;
  }
  return;
}
}
#line 116 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
void yajl_string_decode(yajl_buf buf , unsigned char const   *str , size_t len ) 
{ 
  size_t beg ;
  size_t end ;
  char utf8Buf[5] ;
  char const   *unescaped ;
  unsigned int codepoint ;
  size_t __cil_tmp9 ;
  unsigned int surrogate ;
  int tmp ;
  unsigned long __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
#line 119
  beg = (size_t )0;
#line 120
  end = (size_t )0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (end < len)) {
#line 122
      goto while_break;
    }
#line 123
    if ((int )*(str + end) == 92) {
      {
#line 125
      unescaped = "?";
#line 126
      yajl_buf_append(buf, str + beg, end - beg);
#line 127
      end ++;
      }
      {
#line 128
      if ((int )*(str + end) == 'r') {
#line 128
        goto case_114;
      }
#line 129
      if ((int )*(str + end) == 'n') {
#line 129
        goto case_110;
      }
#line 130
      if ((int )*(str + end) == '\\') {
#line 130
        goto case_92;
      }
#line 131
      if ((int )*(str + end) == '/') {
#line 131
        goto case_47;
      }
#line 132
      if ((int )*(str + end) == '\"') {
#line 132
        goto case_34;
      }
#line 133
      if ((int )*(str + end) == 'f') {
#line 133
        goto case_102;
      }
#line 134
      if ((int )*(str + end) == 'b') {
#line 134
        goto case_98;
      }
#line 135
      if ((int )*(str + end) == 't') {
#line 135
        goto case_116;
      }
#line 136
      if ((int )*(str + end) == 'u') {
#line 136
        goto case_117;
      }
#line 127
      goto switch_break;
      case_114: /* CIL Label */ 
#line 128
      unescaped = "\r";
#line 128
      goto switch_break;
      case_110: /* CIL Label */ 
#line 129
      unescaped = "\n";
#line 129
      goto switch_break;
      case_92: /* CIL Label */ 
#line 130
      unescaped = "\\";
#line 130
      goto switch_break;
      case_47: /* CIL Label */ 
#line 131
      unescaped = "/";
#line 131
      goto switch_break;
      case_34: /* CIL Label */ 
#line 132
      unescaped = "\"";
#line 132
      goto switch_break;
      case_102: /* CIL Label */ 
#line 133
      unescaped = "\f";
#line 133
      goto switch_break;
      case_98: /* CIL Label */ 
#line 134
      unescaped = "\b";
#line 134
      goto switch_break;
      case_116: /* CIL Label */ 
#line 135
      unescaped = "\t";
#line 135
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 137
      codepoint = (unsigned int )0;
#line 138
      end ++;
#line 138
      hexToDigit(& codepoint, str + end);
#line 139
      end += (unsigned long )3;
      }
#line 141
      if ((codepoint & 64512U) == 55296U) {
#line 142
        end ++;
#line 143
        if ((int )*(str + end) == 92) {
#line 143
          if ((int )*(str + (end + 1UL)) == 117) {
            {
#line 144
            surrogate = (unsigned int )0;
#line 145
            hexToDigit(& surrogate, (str + end) + 2);
#line 146
            codepoint = (((codepoint & 63U) << 10) | ((((codepoint >> 6) & 15U) + 1U) << 16)) | (surrogate & 1023U);
#line 150
            end += (unsigned long )5;
            }
          } else {
#line 152
            unescaped = "?";
#line 153
            goto switch_break;
          }
        } else {
#line 152
          unescaped = "?";
#line 153
          goto switch_break;
        }
      }
      {
#line 157
      Utf32toUtf8(codepoint, (char *)utf8Buf);
#line 158
      unescaped = (char const   *)((char *)utf8Buf);
      }
#line 160
      if (codepoint == 0U) {
        {
#line 161
        yajl_buf_append(buf, unescaped, (size_t )1);
#line 162
        end ++;
#line 162
        beg = end;
        }
#line 163
        goto while_continue;
      }
#line 166
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 171
      __cil_tmp12 = strlen(unescaped);
#line 171
      yajl_buf_append(buf, unescaped, (size_t )((unsigned int )__cil_tmp12));
#line 172
      end ++;
#line 172
      beg = end;
      }
    } else {
#line 174
      end ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  yajl_buf_append(buf, str + beg, end - beg);
  }
  return;
}
}
#line 182 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_encode.c"
int yajl_string_validate_utf8(unsigned char const   *s , size_t len ) 
{ 
  size_t __cil_tmp3 ;
  unsigned char const   *__cil_tmp4 ;
  size_t __cil_tmp5 ;
  unsigned char const   *__cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned char const   *__cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned char const   *__cil_tmp10 ;
  size_t __cil_tmp11 ;
  unsigned char const   *__cil_tmp12 ;
  size_t __cil_tmp13 ;
  unsigned char const   *__cil_tmp14 ;
  size_t __cil_tmp15 ;
  unsigned char const   *__cil_tmp16 ;

  {
#line 184
  if (! len) {
#line 184
    return (1);
  }
#line 185
  if (! s) {
#line 185
    return (0);
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    __cil_tmp3 = len;
#line 187
    len --;
#line 187
    if (! __cil_tmp3) {
#line 187
      goto while_break;
    }
#line 189
    if (! ((int )*s <= 127)) {
#line 193
      if ((int )*s >> 5 == 6) {
#line 194
        s ++;
#line 194
        __cil_tmp5 = len;
#line 194
        len --;
#line 194
        if (! __cil_tmp5) {
#line 194
          return (0);
        }

#line 195
        if (! ((int )*s >> 6 == 2)) {
#line 195
          return (0);
        }
      } else
#line 198
      if ((int )*s >> 4 == 14) {
#line 199
        s ++;
#line 199
        __cil_tmp7 = len;
#line 199
        len --;
#line 199
        if (! __cil_tmp7) {
#line 199
          return (0);
        }

#line 200
        if (! ((int )*s >> 6 == 2)) {
#line 200
          return (0);
        }
#line 201
        s ++;
#line 201
        __cil_tmp9 = len;
#line 201
        len --;
#line 201
        if (! __cil_tmp9) {
#line 201
          return (0);
        }

#line 202
        if (! ((int )*s >> 6 == 2)) {
#line 202
          return (0);
        }
      } else
#line 205
      if ((int )*s >> 3 == 30) {
#line 206
        s ++;
#line 206
        __cil_tmp11 = len;
#line 206
        len --;
#line 206
        if (! __cil_tmp11) {
#line 206
          return (0);
        }

#line 207
        if (! ((int )*s >> 6 == 2)) {
#line 207
          return (0);
        }
#line 208
        s ++;
#line 208
        __cil_tmp13 = len;
#line 208
        len --;
#line 208
        if (! __cil_tmp13) {
#line 208
          return (0);
        }

#line 209
        if (! ((int )*s >> 6 == 2)) {
#line 209
          return (0);
        }
#line 210
        s ++;
#line 210
        __cil_tmp15 = len;
#line 210
        len --;
#line 210
        if (! __cil_tmp15) {
#line 210
          return (0);
        }

#line 211
        if (! ((int )*s >> 6 == 2)) {
#line 211
          return (0);
        }
      } else {
#line 213
        return (0);
      }
    }
#line 216
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return (1);
}
}
#line 33 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
static void yajl_buf_ensure_available(yajl_buf buf , size_t want ) 
{ 
  size_t need ;
  int tmp ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
#line 40
  if (buf->data == (void *)0) {
    {
#line 41
    buf->len = (size_t )2048;
#line 42
    __cil_tmp5 = (*((buf->alloc)->malloc))((buf->alloc)->ctx, buf->len);
#line 42
    buf->data = (unsigned char *)__cil_tmp5;
#line 43
    *(buf->data + 0) = (unsigned char )0;
    }
  }
#line 46
  need = buf->len;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (want >= need - buf->used)) {
#line 48
      goto while_break;
    }
#line 48
    need <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  if (need != buf->len) {
    {
#line 51
    __cil_tmp6 = (*((buf->alloc)->realloc))((buf->alloc)->ctx, buf->data, need);
#line 51
    buf->data = (unsigned char *)__cil_tmp6;
#line 52
    buf->len = need;
    }
  }
  return;
}
}
#line 56 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
yajl_buf yajl_buf_alloc(yajl_alloc_funcs *alloc ) 
{ 
  yajl_buf b ;
  void *__cil_tmp3 ;

  {
  {
#line 58
  __cil_tmp3 = (*(alloc->malloc))(alloc->ctx, sizeof(struct yajl_buf_t ));
#line 58
  b = __cil_tmp3;
#line 59
  memset((void *)b, 0, sizeof(struct yajl_buf_t ));
#line 60
  b->alloc = alloc;
  }
#line 61
  return (b);
}
}
#line 64 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
void yajl_buf_free(yajl_buf buf ) 
{ 
  int tmp ;

  {
#line 67
  if (buf->data) {
    {
#line 67
    (*((buf->alloc)->free))((buf->alloc)->ctx, buf->data);
    }
  }
  {
#line 68
  (*((buf->alloc)->free))((buf->alloc)->ctx, buf);
  }
  return;
}
}
#line 71 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
void yajl_buf_append(yajl_buf buf , void const   *data , size_t len ) 
{ 
  int tmp ;

  {
  {
#line 73
  yajl_buf_ensure_available(buf, len);
  }
#line 74
  if (len > 0UL) {
    {
#line 76
    memcpy(buf->data + buf->used, data, len);
#line 77
    buf->used += len;
#line 78
    *(buf->data + buf->used) = (unsigned char )0;
    }
  }
  return;
}
}
#line 82 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
void yajl_buf_clear(yajl_buf buf ) 
{ 


  {
#line 84
  buf->used = (size_t )0;
#line 85
  if (buf->data) {
#line 85
    *(buf->data + buf->used) = (unsigned char )0;
  }
  return;
}
}
#line 88 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
unsigned char const   *yajl_buf_data(yajl_buf buf ) 
{ 


  {
#line 90
  return ((unsigned char const   *)buf->data);
}
}
#line 93 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
size_t yajl_buf_len(yajl_buf buf ) 
{ 


  {
#line 95
  return (buf->used);
}
}
#line 99 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_buf.c"
void yajl_buf_truncate(yajl_buf buf , size_t len ) 
{ 
  int tmp ;

  {
#line 102
  buf->used = len;
  return;
}
}
#line 26 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_alloc.c"
static void *yajl_internal_malloc(void *ctx , size_t sz ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 29
  __cil_tmp3 = malloc(sz);
  }
#line 29
  return (__cil_tmp3);
}
}
#line 32 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_alloc.c"
static void *yajl_internal_realloc(void *ctx , void *previous , size_t sz ) 
{ 
  void *__cil_tmp4 ;

  {
  {
#line 36
  __cil_tmp4 = realloc(previous, sz);
  }
#line 36
  return (__cil_tmp4);
}
}
#line 39 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_alloc.c"
static void yajl_internal_free(void *ctx , void *ptr ) 
{ 


  {
  {
#line 42
  free(ptr);
  }
  return;
}
}
#line 45 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl_alloc.c"
void yajl_set_default_alloc_funcs(yajl_alloc_funcs *yaf ) 
{ 


  {
#line 47
  yaf->malloc = & yajl_internal_malloc;
#line 48
  yaf->free = & yajl_internal_free;
#line 49
  yaf->realloc = & yajl_internal_realloc;
#line 50
  yaf->ctx = (void *)0;
  return;
}
}
#line 28 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
char const   *yajl_status_to_string(yajl_status stat___0 ) 
{ 
  char const   *statStr ;

  {
#line 30
  statStr = "unknown";
  {
#line 32
  if ((unsigned int )stat___0 == (unsigned int )0) {
#line 32
    goto case_0;
  }
#line 35
  if ((unsigned int )stat___0 == (unsigned int )1) {
#line 35
    goto case_1;
  }
#line 38
  if ((unsigned int )stat___0 == (unsigned int )2) {
#line 38
    goto case_2;
  }
#line 31
  goto switch_break;
  case_0: /* CIL Label */ 
#line 33
  statStr = "ok, no error";
#line 34
  goto switch_break;
  case_1: /* CIL Label */ 
#line 36
  statStr = "client canceled parse";
#line 37
  goto switch_break;
  case_2: /* CIL Label */ 
#line 39
  statStr = "parse error";
#line 40
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 42
  return (statStr);
}
}
#line 46 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
yajl_handle yajl_alloc(yajl_callbacks *callbacks , yajl_alloc_funcs *afs , void *ctx ) 
{ 
  yajl_handle hand ;
  yajl_alloc_funcs afsBuffer ;
  void *__cil_tmp6 ;
  yajl_buf __cil_tmp7 ;
  void *__cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
#line 50
  hand = (yajl_handle )((void *)0);
#line 54
  if (afs != (void *)0) {
#line 55
    if (afs->malloc == (void *)0) {
#line 57
      return ((yajl_handle )((void *)0));
    } else
#line 55
    if (afs->realloc == (void *)0) {
#line 57
      return ((yajl_handle )((void *)0));
    } else
#line 55
    if (afs->free == (void *)0) {
#line 57
      return ((yajl_handle )((void *)0));
    }
  } else {
    {
#line 60
    yajl_set_default_alloc_funcs(& afsBuffer);
#line 61
    afs = & afsBuffer;
    }
  }
  {
#line 64
  __cil_tmp6 = (*(afs->malloc))(afs->ctx, sizeof(struct yajl_handle_t ));
#line 64
  hand = (yajl_handle )__cil_tmp6;
#line 67
  memcpy((void *)(& hand->alloc), (void *)afs, sizeof(yajl_alloc_funcs ));
#line 69
  hand->callbacks = callbacks;
#line 70
  hand->ctx = ctx;
#line 71
  hand->lexer = (yajl_lexer )((void *)0);
#line 72
  hand->bytesConsumed = (size_t )0;
#line 73
  hand->decodeBuf = yajl_buf_alloc(& hand->alloc);
#line 74
  hand->flags = (unsigned int )0;
#line 75
  hand->stateStack.stack = (unsigned char *)((void *)0);
#line 75
  hand->stateStack.size = (size_t )0;
#line 75
  hand->stateStack.used = (size_t )0;
#line 75
  hand->stateStack.yaf = & hand->alloc;
  }
#line 76
  if (hand->stateStack.size - hand->stateStack.used == 0UL) {
    {
#line 76
    hand->stateStack.size += (unsigned long )128;
#line 76
    hand->stateStack.stack = (unsigned char *)(*((hand->stateStack.yaf)->realloc))((hand->stateStack.yaf)->ctx,
                                                                                   (void *)hand->stateStack.stack,
                                                                                   hand->stateStack.size);
    }
  }
#line 76
  __cil_tmp9 = hand->stateStack.used;
#line 76
  (hand->stateStack.used) ++;
#line 76
  *(hand->stateStack.stack + __cil_tmp9) = (unsigned char )0;
#line 78
  return (hand);
}
}
#line 82 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
int yajl_config(yajl_handle h , yajl_option opt  , ...) 
{ 
  int rv ;
  va_list ap ;

  {
  {
#line 84
  rv = 1;
#line 86
  __builtin_va_start((void *)ap, opt);
  }
  {
#line 93
  if ((unsigned int )opt == (unsigned int )16) {
#line 93
    goto case_16;
  }
#line 93
  if ((unsigned int )opt == (unsigned int )8) {
#line 93
    goto case_16;
  }
#line 93
  if ((unsigned int )opt == (unsigned int )4) {
#line 93
    goto case_16;
  }
#line 93
  if ((unsigned int )opt == (unsigned int )2) {
#line 93
    goto case_16;
  }
#line 93
  if ((unsigned int )opt == (unsigned int )1) {
#line 93
    goto case_16;
  }
#line 97
  goto switch_default;
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 94
  if (0) {
#line 94
    h->flags |= (unsigned int )opt;
  } else {
#line 95
    h->flags &= ~ ((unsigned int )opt);
  }
#line 96
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 98
  rv = 0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 100
  __builtin_va_end((void *)ap);
  }
#line 102
  return (rv);
}
}
#line 106 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
void yajl_free(yajl_handle handle ) 
{ 


  {
#line 108
  if (handle->stateStack.stack) {
    {
#line 108
    (*((handle->stateStack.yaf)->free))((handle->stateStack.yaf)->ctx, handle->stateStack.stack);
    }
  }
  {
#line 109
  yajl_buf_free(handle->decodeBuf);
  }
#line 110
  if (handle->lexer) {
    {
#line 111
    yajl_lex_free(handle->lexer);
#line 112
    handle->lexer = (yajl_lexer )((void *)0);
    }
  }
  {
#line 114
  (*(handle->alloc.free))(handle->alloc.ctx, handle);
  }
  return;
}
}
#line 118 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
yajl_status yajl_parse(yajl_handle hand , unsigned char const   *jsonText , size_t jsonTextLen ) 
{ 
  yajl_status status ;
  yajl_lexer __cil_tmp5 ;
  yajl_status __cil_tmp6 ;

  {
#line 124
  if (hand->lexer == (void *)0) {
    {
#line 125
    hand->lexer = yajl_lex_alloc(& hand->alloc, hand->flags & 1U, ! (hand->flags & 2U));
    }
  }
  {
#line 130
  status = yajl_do_parse(hand, jsonText, jsonTextLen);
  }
#line 131
  return (status);
}
}
#line 136 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
yajl_status yajl_complete_parse(yajl_handle hand ) 
{ 
  yajl_lexer __cil_tmp2 ;
  yajl_status __cil_tmp3 ;

  {
#line 144
  if (hand->lexer == (void *)0) {
    {
#line 145
    hand->lexer = yajl_lex_alloc(& hand->alloc, hand->flags & 1U, ! (hand->flags & 2U));
    }
  }
  {
#line 150
  __cil_tmp3 = yajl_do_finish(hand);
  }
#line 150
  return (__cil_tmp3);
}
}
#line 154 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
unsigned char *yajl_get_error(yajl_handle hand , int verbose___0 , unsigned char const   *jsonText ,
                              size_t jsonTextLen ) 
{ 
  unsigned char *__cil_tmp5 ;

  {
  {
#line 157
  __cil_tmp5 = yajl_render_error_string(hand, jsonText, jsonTextLen, verbose___0);
  }
#line 157
  return (__cil_tmp5);
}
}
#line 161 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
size_t yajl_get_bytes_consumed(yajl_handle hand ) 
{ 


  {
#line 163
  if (! hand) {
#line 163
    return ((size_t )0);
  } else {
#line 164
    return (hand->bytesConsumed);
  }
}
}
#line 169 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/yajl/yajl.c"
void yajl_free_error(yajl_handle hand , unsigned char *str ) 
{ 


  {
  {
#line 172
  (*(hand->alloc.free))(hand->alloc.ctx, str);
  }
  return;
}
}
#line 749 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.h"
char const   *protobuf_c_version(void) ;
#line 760
uint32_t protobuf_c_version_number(void) ;
#line 795
ProtobufCEnumValue *protobuf_c_enum_descriptor_get_value_by_name(ProtobufCEnumDescriptor *desc ,
                                                                 char const   *name ) ;
#line 816
ProtobufCEnumValue *protobuf_c_enum_descriptor_get_value(ProtobufCEnumDescriptor *desc ,
                                                         int value ) ;
#line 835
ProtobufCFieldDescriptor *protobuf_c_message_descriptor_get_field_by_name(ProtobufCMessageDescriptor *desc ,
                                                                          char const   *name ) ;
#line 854
ProtobufCFieldDescriptor *protobuf_c_message_descriptor_get_field(ProtobufCMessageDescriptor *desc ,
                                                                  unsigned int value ) ;
#line 868
size_t protobuf_c_message_get_packed_size(ProtobufCMessage *message ) ;
#line 888
size_t protobuf_c_message_pack(ProtobufCMessage *message , uint8_t *out ) ;
#line 905
size_t protobuf_c_message_pack_to_buffer(ProtobufCMessage *message , ProtobufCBuffer *buffer ) ;
#line 928
ProtobufCMessage *protobuf_c_message_unpack(ProtobufCMessageDescriptor *desc , ProtobufCAllocator *allocator ,
                                            size_t len , uint8_t *data ) ;
#line 948
void protobuf_c_message_free_unpacked(ProtobufCMessage *message , ProtobufCAllocator *allocator ) ;
#line 965
protobuf_c_boolean protobuf_c_message_check(ProtobufCMessage *message ) ;
#line 980
void protobuf_c_message_init(ProtobufCMessageDescriptor *descriptor , void *message ) ;
#line 992
void protobuf_c_service_destroy(ProtobufCService *service ) ;
#line 1009
ProtobufCMethodDescriptor *protobuf_c_service_descriptor_get_method_by_name(ProtobufCServiceDescriptor *desc ,
                                                                            char const   *name ) ;
#line 1054
void protobuf_c_buffer_simple_append(ProtobufCBuffer *buffer , size_t len , uint8_t *data ) ;
#line 1061
void protobuf_c_service_generated_init(ProtobufCService *service , ProtobufCServiceDescriptor *descriptor ,
                                       ProtobufCServiceDestroy destroy ) ;
#line 1068
void protobuf_c_service_invoke_internal(ProtobufCService *service , unsigned int method_index ,
                                        ProtobufCMessage *input , ProtobufCClosure closure ,
                                        void *closure_data ) ;
#line 131 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
char const   *protobuf_c_version(void) 
{ 


  {
#line 133
  return ("1.0.1");
}
}
#line 137 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
uint32_t protobuf_c_version_number(void) 
{ 


  {
#line 139
  return ((uint32_t )1000001);
}
}
#line 145 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void *system_alloc(void *allocator_data , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 147
  __cil_tmp3 = malloc(size);
  }
#line 147
  return (__cil_tmp3);
}
}
#line 151 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void system_free(void *allocator_data , void *data ) 
{ 


  {
  {
#line 153
  free(data);
  }
  return;
}
}
#line 157 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void *do_alloc(ProtobufCAllocator *allocator , size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 159
  __cil_tmp3 = (*(allocator->alloc))(allocator->allocator_data, size);
  }
#line 159
  return (__cil_tmp3);
}
}
#line 163 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void do_free(ProtobufCAllocator *allocator , void *data ) 
{ 


  {
#line 165
  if (data != (void *)0) {
    {
#line 166
    (*(allocator->free))(allocator->allocator_data, data);
    }
  }
  return;
}
}
#line 174 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static ProtobufCAllocator protobuf_c__allocator  =    {& system_alloc, & system_free, (void *)0};
#line 189 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_buffer_simple_append(ProtobufCBuffer *buffer , size_t len , uint8_t *data ) 
{ 
  ProtobufCBufferSimple *simp ;
  size_t new_len ;
  ProtobufCAllocator *allocator ;
  size_t new_alloced ;
  uint8_t *new_data ;
  void *__cil_tmp9 ;

  {
#line 192
  simp = (ProtobufCBufferSimple *)buffer;
#line 193
  new_len = simp->len + len;
#line 195
  if (new_len > simp->alloced) {
#line 196
    allocator = simp->allocator;
#line 197
    new_alloced = simp->alloced * 2UL;
#line 200
    if (allocator == (void *)0) {
#line 201
      allocator = & protobuf_c__allocator;
    }
    {
#line 202
    while (1) {
      while_continue: /* CIL Label */ ;
#line 202
      if (! (new_alloced < new_len)) {
#line 202
        goto while_break;
      }
#line 203
      new_alloced += new_alloced;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 204
    new_data = (uint8_t *)do_alloc(allocator, new_alloced);
    }
#line 205
    if (! new_data) {
#line 206
      return;
    }
    {
#line 207
    memcpy(new_data, simp->data, simp->len);
    }
#line 208
    if (simp->must_free_data) {
      {
#line 209
      do_free(allocator, simp->data);
      }
    } else {
#line 211
      simp->must_free_data = 1;
    }
#line 212
    simp->data = new_data;
#line 213
    simp->alloced = new_alloced;
  }
  {
#line 215
  memcpy(simp->data + simp->len, data, len);
#line 216
  simp->len = new_len;
  }
  return;
}
}
#line 238 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t get_tag_size(unsigned int number ) 
{ 


  {
#line 240
  if (number < (unsigned int )(1 << 4)) {
#line 241
    return ((size_t )1);
  } else
#line 242
  if (number < (unsigned int )(1 << 11)) {
#line 243
    return ((size_t )2);
  } else
#line 244
  if (number < (unsigned int )(1 << 18)) {
#line 245
    return ((size_t )3);
  } else
#line 246
  if (number < (unsigned int )(1 << 25)) {
#line 247
    return ((size_t )4);
  } else {
#line 249
    return ((size_t )5);
  }
}
}
#line 263 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t uint32_size(uint32_t v ) 
{ 


  {
#line 265
  if (v < (unsigned int )(1 << 7)) {
#line 266
    return ((size_t )1);
  } else
#line 267
  if (v < (unsigned int )(1 << 14)) {
#line 268
    return ((size_t )2);
  } else
#line 269
  if (v < (unsigned int )(1 << 21)) {
#line 270
    return ((size_t )3);
  } else
#line 271
  if (v < (unsigned int )(1 << 28)) {
#line 272
    return ((size_t )4);
  } else {
#line 274
    return ((size_t )5);
  }
}
}
#line 288 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t int32_size(int32_t v ) 
{ 


  {
#line 290
  if (v < 0) {
#line 291
    return ((size_t )10);
  } else
#line 292
  if (v < 1 << 7) {
#line 293
    return ((size_t )1);
  } else
#line 294
  if (v < 1 << 14) {
#line 295
    return ((size_t )2);
  } else
#line 296
  if (v < 1 << 21) {
#line 297
    return ((size_t )3);
  } else
#line 298
  if (v < 1 << 28) {
#line 299
    return ((size_t )4);
  } else {
#line 301
    return ((size_t )5);
  }
}
}
#line 315 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint32_t zigzag32(int32_t v ) 
{ 


  {
#line 317
  if (v < 0) {
#line 318
    return ((uint32_t )(- v) * 2U - 1U);
  } else {
#line 320
    return ((uint32_t )(v * 2));
  }
}
}
#line 334 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t sint32_size(int32_t v ) 
{ 
  uint32_t __cil_tmp2 ;
  size_t __cil_tmp3 ;

  {
  {
#line 336
  __cil_tmp2 = zigzag32(v);
#line 336
  __cil_tmp3 = uint32_size(__cil_tmp2);
  }
#line 336
  return (__cil_tmp3);
}
}
#line 349 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t uint64_size(uint64_t v ) 
{ 
  uint32_t upper_v ;
  size_t __cil_tmp3 ;

  {
#line 351
  upper_v = (uint32_t )(v >> 32);
#line 353
  if (upper_v == 0U) {
    {
#line 354
    __cil_tmp3 = uint32_size((uint32_t )v);
    }
#line 354
    return (__cil_tmp3);
  } else
#line 355
  if (upper_v < (unsigned int )(1 << 3)) {
#line 356
    return ((size_t )5);
  } else
#line 357
  if (upper_v < (unsigned int )(1 << 10)) {
#line 358
    return ((size_t )6);
  } else
#line 359
  if (upper_v < (unsigned int )(1 << 17)) {
#line 360
    return ((size_t )7);
  } else
#line 361
  if (upper_v < (unsigned int )(1 << 24)) {
#line 362
    return ((size_t )8);
  } else
#line 363
  if (upper_v < 1U << 31) {
#line 364
    return ((size_t )9);
  } else {
#line 366
    return ((size_t )10);
  }
}
}
#line 380 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint64_t zigzag64(int64_t v ) 
{ 


  {
#line 382
  if (v < 0L) {
#line 383
    return ((uint64_t )(- v) * 2UL - 1UL);
  } else {
#line 385
    return ((uint64_t )(v * 2L));
  }
}
}
#line 399 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t sint64_size(int64_t v ) 
{ 
  uint64_t __cil_tmp2 ;
  size_t __cil_tmp3 ;

  {
  {
#line 401
  __cil_tmp2 = zigzag64(v);
#line 401
  __cil_tmp3 = uint64_size(__cil_tmp2);
  }
#line 401
  return (__cil_tmp3);
}
}
#line 416 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t required_field_get_packed_size(ProtobufCFieldDescriptor *field , void const   *member ) 
{ 
  size_t rv ;
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  char const   *str ;
  size_t len ;
  unsigned long __cil_tmp13 ;
  unsigned long tmp ;
  size_t __cil_tmp15 ;
  size_t len___0 ;
  size_t __cil_tmp17 ;
  ProtobufCMessage *msg ;
  size_t subrv ;
  size_t __cil_tmp20 ;
  size_t tmp___0 ;
  size_t __cil_tmp22 ;
  int tmp___1 ;

  {
  {
#line 419
  __cil_tmp4 = get_tag_size(field->id);
#line 419
  rv = __cil_tmp4;
  }
  {
#line 422
  if ((unsigned int )field->type == (unsigned int )1) {
#line 422
    goto case_1;
  }
#line 424
  if ((unsigned int )field->type == (unsigned int )0) {
#line 424
    goto case_0;
  }
#line 426
  if ((unsigned int )field->type == (unsigned int )6) {
#line 426
    goto case_6;
  }
#line 428
  if ((unsigned int )field->type == (unsigned int )4) {
#line 428
    goto case_4;
  }
#line 431
  if ((unsigned int )field->type == (unsigned int )8) {
#line 431
    goto case_8;
  }
#line 431
  if ((unsigned int )field->type == (unsigned int )3) {
#line 431
    goto case_8;
  }
#line 434
  if ((unsigned int )field->type == (unsigned int )7) {
#line 434
    goto case_7;
  }
#line 434
  if ((unsigned int )field->type == (unsigned int )2) {
#line 434
    goto case_7;
  }
#line 437
  if ((unsigned int )field->type == (unsigned int )9) {
#line 437
    goto case_9;
  }
#line 437
  if ((unsigned int )field->type == (unsigned int )5) {
#line 437
    goto case_9;
  }
#line 439
  if ((unsigned int )field->type == (unsigned int )12) {
#line 439
    goto case_12;
  }
#line 441
  if ((unsigned int )field->type == (unsigned int )10) {
#line 441
    goto case_10;
  }
#line 443
  if ((unsigned int )field->type == (unsigned int )11) {
#line 443
    goto case_11;
  }
#line 445
  if ((unsigned int )field->type == (unsigned int )13) {
#line 445
    goto case_13;
  }
#line 448
  if ((unsigned int )field->type == (unsigned int )14) {
#line 448
    goto case_14;
  }
#line 453
  if ((unsigned int )field->type == (unsigned int )15) {
#line 453
    goto case_15;
  }
#line 457
  if ((unsigned int )field->type == (unsigned int )16) {
#line 457
    goto case_16;
  }
#line 421
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 423
  __cil_tmp5 = sint32_size(*((int32_t *)member));
  }
#line 423
  return (rv + __cil_tmp5);
  case_0: /* CIL Label */ 
  {
#line 425
  __cil_tmp6 = int32_size((int32_t )*((uint32_t *)member));
  }
#line 425
  return (rv + __cil_tmp6);
  case_6: /* CIL Label */ 
  {
#line 427
  __cil_tmp7 = uint32_size(*((uint32_t *)member));
  }
#line 427
  return (rv + __cil_tmp7);
  case_4: /* CIL Label */ 
  {
#line 429
  __cil_tmp8 = sint64_size(*((int64_t *)member));
  }
#line 429
  return (rv + __cil_tmp8);
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 432
  __cil_tmp9 = uint64_size(*((uint64_t *)member));
  }
#line 432
  return (rv + __cil_tmp9);
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 435
  return (rv + 4UL);
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 438
  return (rv + 8UL);
  case_12: /* CIL Label */ 
#line 440
  return (rv + 1UL);
  case_10: /* CIL Label */ 
#line 442
  return (rv + 4UL);
  case_11: /* CIL Label */ 
#line 444
  return (rv + 8UL);
  case_13: /* CIL Label */ 
  {
#line 447
  __cil_tmp10 = uint32_size(*((uint32_t *)member));
  }
#line 447
  return (rv + __cil_tmp10);
  case_14: /* CIL Label */ 
#line 449
  str = (char const   *)*((char * const  *)member);
#line 450
  if (str) {
    {
#line 450
    __cil_tmp13 = strlen(str);
#line 450
    tmp = __cil_tmp13;
    }
  } else {
#line 450
    tmp = (unsigned long )0;
  }
  {
#line 450
  len = tmp;
#line 451
  __cil_tmp15 = uint32_size((uint32_t )len);
  }
#line 451
  return ((rv + __cil_tmp15) + len);
  case_15: /* CIL Label */ 
  {
#line 454
  len___0 = ((ProtobufCBinaryData *)member)->len;
#line 455
  __cil_tmp17 = uint32_size((uint32_t )len___0);
  }
#line 455
  return ((rv + __cil_tmp17) + len___0);
  case_16: /* CIL Label */ 
#line 458
  msg = (ProtobufCMessage *)*((ProtobufCMessage * const  *)member);
#line 459
  if (msg) {
    {
#line 459
    __cil_tmp20 = protobuf_c_message_get_packed_size(msg);
#line 459
    tmp___0 = __cil_tmp20;
    }
  } else {
#line 459
    tmp___0 = (unsigned long )0;
  }
  {
#line 459
  subrv = tmp___0;
#line 460
  __cil_tmp22 = uint32_size((uint32_t )subrv);
  }
#line 460
  return ((rv + __cil_tmp22) + subrv);
  switch_break: /* CIL Label */ ;
  }
#line 464
  return ((size_t )0);
}
}
#line 482 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t optional_field_get_packed_size(ProtobufCFieldDescriptor *field , protobuf_c_boolean *has ,
                                             void const   *member ) 
{ 
  void const   *ptr ;
  size_t __cil_tmp5 ;

  {
#line 486
  if ((unsigned int )field->type == 16U) {
    _L: /* CIL Label */ 
#line 489
    ptr = *((void const   * const  *)member);
#line 490
    if (ptr == (void *)0) {
#line 491
      return ((size_t )0);
    } else
#line 490
    if (ptr == field->default_value) {
#line 491
      return ((size_t )0);
    }
  } else
#line 486
  if ((unsigned int )field->type == 14U) {
#line 486
    goto _L;
  } else
#line 493
  if (! *has) {
#line 494
    return ((size_t )0);
  }
  {
#line 496
  __cil_tmp5 = required_field_get_packed_size(field, member);
  }
#line 496
  return (__cil_tmp5);
}
}
#line 514 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t repeated_field_get_packed_size(ProtobufCFieldDescriptor *field , size_t count ,
                                             void const   *member ) 
{ 
  size_t header_size ;
  size_t rv ;
  unsigned int i ;
  void *array ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  size_t __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  size_t __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  size_t __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  size_t __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  size_t len ;
  unsigned long __cil_tmp20 ;
  size_t __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  size_t len___0 ;
  size_t __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  size_t len___1 ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  unsigned int __cil_tmp29 ;
  size_t __cil_tmp30 ;

  {
#line 518
  rv = (size_t )0;
#line 520
  array = *((void * const  *)member);
#line 522
  if (count == 0UL) {
#line 523
    return ((size_t )0);
  }
  {
#line 524
  header_size = get_tag_size(field->id);
  }
#line 525
  if (0U == (field->flags & 1U)) {
#line 526
    header_size *= count;
  }
  {
#line 529
  if ((unsigned int )field->type == (unsigned int )1) {
#line 529
    goto case_1;
  }
#line 533
  if ((unsigned int )field->type == (unsigned int )0) {
#line 533
    goto case_0;
  }
#line 538
  if ((unsigned int )field->type == (unsigned int )13) {
#line 538
    goto case_13;
  }
#line 538
  if ((unsigned int )field->type == (unsigned int )6) {
#line 538
    goto case_13;
  }
#line 542
  if ((unsigned int )field->type == (unsigned int )4) {
#line 542
    goto case_4;
  }
#line 547
  if ((unsigned int )field->type == (unsigned int )8) {
#line 547
    goto case_8;
  }
#line 547
  if ((unsigned int )field->type == (unsigned int )3) {
#line 547
    goto case_8;
  }
#line 553
  if ((unsigned int )field->type == (unsigned int )10) {
#line 553
    goto case_10;
  }
#line 553
  if ((unsigned int )field->type == (unsigned int )7) {
#line 553
    goto case_10;
  }
#line 553
  if ((unsigned int )field->type == (unsigned int )2) {
#line 553
    goto case_10;
  }
#line 558
  if ((unsigned int )field->type == (unsigned int )11) {
#line 558
    goto case_11;
  }
#line 558
  if ((unsigned int )field->type == (unsigned int )9) {
#line 558
    goto case_11;
  }
#line 558
  if ((unsigned int )field->type == (unsigned int )5) {
#line 558
    goto case_11;
  }
#line 561
  if ((unsigned int )field->type == (unsigned int )12) {
#line 561
    goto case_12;
  }
#line 564
  if ((unsigned int )field->type == (unsigned int )14) {
#line 564
    goto case_14;
  }
#line 570
  if ((unsigned int )field->type == (unsigned int )15) {
#line 570
    goto case_15;
  }
#line 576
  if ((unsigned int )field->type == (unsigned int )16) {
#line 576
    goto case_16;
  }
#line 528
  goto switch_break;
  case_1: /* CIL Label */ 
#line 530
  i = (unsigned int )0;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((unsigned long )i < count)) {
#line 530
      goto while_break;
    }
    {
#line 531
    __cil_tmp9 = sint32_size(*((int32_t *)array + i));
    }
#line 531
    rv += __cil_tmp9;
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  goto switch_break;
  case_0: /* CIL Label */ 
#line 534
  i = (unsigned int )0;
  {
#line 534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 534
    if (! ((unsigned long )i < count)) {
#line 534
      goto while_break___0;
    }
    {
#line 535
    __cil_tmp11 = int32_size((int32_t )*((uint32_t *)array + i));
    }
#line 535
    rv += __cil_tmp11;
#line 534
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 536
  goto switch_break;
  case_13: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 539
  i = (unsigned int )0;
  {
#line 539
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 539
    if (! ((unsigned long )i < count)) {
#line 539
      goto while_break___1;
    }
    {
#line 540
    __cil_tmp13 = uint32_size(*((uint32_t *)array + i));
    }
#line 540
    rv += __cil_tmp13;
#line 539
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 541
  goto switch_break;
  case_4: /* CIL Label */ 
#line 543
  i = (unsigned int )0;
  {
#line 543
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 543
    if (! ((unsigned long )i < count)) {
#line 543
      goto while_break___2;
    }
    {
#line 544
    __cil_tmp15 = sint64_size(*((int64_t *)array + i));
    }
#line 544
    rv += __cil_tmp15;
#line 543
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 545
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 548
  i = (unsigned int )0;
  {
#line 548
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 548
    if (! ((unsigned long )i < count)) {
#line 548
      goto while_break___3;
    }
    {
#line 549
    __cil_tmp17 = uint64_size(*((uint64_t *)array + i));
    }
#line 549
    rv += __cil_tmp17;
#line 548
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 550
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 554
  rv += 4UL * count;
#line 555
  goto switch_break;
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 559
  rv += 8UL * count;
#line 560
  goto switch_break;
  case_12: /* CIL Label */ 
#line 562
  rv += count;
#line 563
  goto switch_break;
  case_14: /* CIL Label */ 
#line 565
  i = (unsigned int )0;
  {
#line 565
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 565
    if (! ((unsigned long )i < count)) {
#line 565
      goto while_break___4;
    }
    {
#line 566
    __cil_tmp20 = strlen((char const   *)*((char **)array + i));
#line 566
    len = __cil_tmp20;
#line 567
    __cil_tmp21 = uint32_size((uint32_t )len);
    }
#line 567
    rv += __cil_tmp21 + len;
#line 565
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 569
  goto switch_break;
  case_15: /* CIL Label */ 
#line 571
  i = (unsigned int )0;
  {
#line 571
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 571
    if (! ((unsigned long )i < count)) {
#line 571
      goto while_break___5;
    }
    {
#line 572
    len___0 = ((ProtobufCBinaryData *)array + i)->len;
#line 573
    __cil_tmp24 = uint32_size((uint32_t )len___0);
    }
#line 573
    rv += __cil_tmp24 + len___0;
#line 571
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 575
  goto switch_break;
  case_16: /* CIL Label */ 
#line 577
  i = (unsigned int )0;
  {
#line 577
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 577
    if (! ((unsigned long )i < count)) {
#line 577
      goto while_break___6;
    }
    {
#line 578
    __cil_tmp27 = protobuf_c_message_get_packed_size(*((ProtobufCMessage **)array + i));
#line 578
    len___1 = __cil_tmp27;
#line 580
    __cil_tmp28 = uint32_size((uint32_t )len___1);
    }
#line 580
    rv += __cil_tmp28 + len___1;
#line 577
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 582
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 585
  if (0U != (field->flags & 1U)) {
    {
#line 586
    __cil_tmp30 = uint32_size((uint32_t )rv);
    }
#line 586
    header_size += __cil_tmp30;
  }
#line 587
  return (header_size + rv);
}
}
#line 601 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t unknown_field_get_packed_size(ProtobufCMessageUnknownField *field ) 
{ 
  size_t __cil_tmp2 ;

  {
  {
#line 603
  __cil_tmp2 = get_tag_size(field->tag);
  }
#line 603
  return (__cil_tmp2 + field->len);
}
}
#line 611 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
size_t protobuf_c_message_get_packed_size(ProtobufCMessage *message ) 
{ 
  unsigned int i ;
  size_t rv ;
  int tmp ;
  ProtobufCFieldDescriptor *field ;
  void const   *member ;
  void const   *qmember ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 614
  rv = (size_t )0;
#line 617
  i = (unsigned int )0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i < (message->descriptor)->n_fields)) {
#line 617
      goto while_break;
    }
#line 618
    field = (message->descriptor)->fields + i;
#line 620
    member = (char const   *)message + field->offset;
#line 622
    qmember = (char const   *)message + field->quantifier_offset;
#line 625
    if ((unsigned int )field->label == 0U) {
      {
#line 626
      __cil_tmp8 = required_field_get_packed_size(field, member);
      }
#line 626
      rv += __cil_tmp8;
    } else
#line 627
    if ((unsigned int )field->label == 1U) {
      {
#line 628
      __cil_tmp9 = optional_field_get_packed_size(field, qmember, member);
      }
#line 628
      rv += __cil_tmp9;
    } else {
      {
#line 630
      __cil_tmp10 = repeated_field_get_packed_size(field, *((size_t *)qmember), member);
      }
#line 630
      rv += __cil_tmp10;
    }
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  i = (unsigned int )0;
  {
#line 637
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 637
    if (! (i < message->n_unknown_fields)) {
#line 637
      goto while_break___0;
    }
    {
#line 638
    __cil_tmp12 = unknown_field_get_packed_size(message->unknown_fields + i);
    }
#line 638
    rv += __cil_tmp12;
#line 637
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 639
  return (rv);
}
}
#line 663 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t uint32_pack(uint32_t value , uint8_t *out ) 
{ 
  unsigned int rv ;
  unsigned int __cil_tmp4 ;
  unsigned int __cil_tmp5 ;
  unsigned int __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;

  {
#line 665
  rv = (unsigned int )0;
#line 667
  if (value >= 128U) {
#line 668
    __cil_tmp4 = rv;
#line 668
    rv ++;
#line 668
    *(out + __cil_tmp4) = (uint8_t )(value | 128U);
#line 669
    value >>= 7;
#line 670
    if (value >= 128U) {
#line 671
      __cil_tmp5 = rv;
#line 671
      rv ++;
#line 671
      *(out + __cil_tmp5) = (uint8_t )(value | 128U);
#line 672
      value >>= 7;
#line 673
      if (value >= 128U) {
#line 674
        __cil_tmp6 = rv;
#line 674
        rv ++;
#line 674
        *(out + __cil_tmp6) = (uint8_t )(value | 128U);
#line 675
        value >>= 7;
#line 676
        if (value >= 128U) {
#line 677
          __cil_tmp7 = rv;
#line 677
          rv ++;
#line 677
          *(out + __cil_tmp7) = (uint8_t )(value | 128U);
#line 678
          value >>= 7;
        }
      }
    }
  }
#line 684
  __cil_tmp8 = rv;
#line 684
  rv ++;
#line 684
  *(out + __cil_tmp8) = (uint8_t )value;
#line 685
  return ((size_t )rv);
}
}
#line 700 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t int32_pack(int32_t value , uint8_t *out ) 
{ 
  size_t __cil_tmp3 ;

  {
#line 702
  if (value < 0) {
#line 703
    *(out + 0) = (uint8_t )(value | 128);
#line 704
    *(out + 1) = (uint8_t )((value >> 7) | 128);
#line 705
    *(out + 2) = (uint8_t )((value >> 14) | 128);
#line 706
    *(out + 3) = (uint8_t )((value >> 21) | 128);
#line 707
    *(out + 4) = (uint8_t )((value >> 28) | 128);
#line 708
    *(out + 8) = (uint8_t )255;
#line 708
    *(out + 7) = *(out + 8);
#line 708
    *(out + 6) = *(out + 7);
#line 708
    *(out + 5) = *(out + 6);
#line 709
    *(out + 9) = (uint8_t )1;
#line 710
    return ((size_t )10);
  } else {
    {
#line 712
    __cil_tmp3 = uint32_pack((uint32_t )value, out);
    }
#line 712
    return (__cil_tmp3);
  }
}
}
#line 728 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t sint32_pack(int32_t value , uint8_t *out ) 
{ 
  uint32_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
  {
#line 730
  __cil_tmp3 = zigzag32(value);
#line 730
  __cil_tmp4 = uint32_pack(__cil_tmp3, out);
  }
#line 730
  return (__cil_tmp4);
}
}
#line 745 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t uint64_pack(uint64_t value , uint8_t *out ) 
{ 
  uint32_t hi ;
  uint32_t lo ;
  unsigned int rv ;
  size_t __cil_tmp6 ;
  unsigned int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;

  {
#line 747
  hi = (uint32_t )(value >> 32);
#line 748
  lo = (uint32_t )value;
#line 751
  if (hi == 0U) {
    {
#line 752
    __cil_tmp6 = uint32_pack((uint32_t )lo, out);
    }
#line 752
    return (__cil_tmp6);
  }
#line 753
  *(out + 0) = (uint8_t )(lo | 128U);
#line 754
  *(out + 1) = (uint8_t )((lo >> 7) | 128U);
#line 755
  *(out + 2) = (uint8_t )((lo >> 14) | 128U);
#line 756
  *(out + 3) = (uint8_t )((lo >> 21) | 128U);
#line 757
  if (hi < 8U) {
#line 758
    *(out + 4) = (uint8_t )((hi << 4) | (lo >> 28));
#line 759
    return ((size_t )5);
  } else {
#line 761
    *(out + 4) = (uint8_t )((((hi & 7U) << 4) | (lo >> 28)) | 128U);
#line 762
    hi >>= 3;
  }
#line 764
  rv = (unsigned int )5;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (hi >= 128U)) {
#line 765
      goto while_break;
    }
#line 766
    __cil_tmp7 = rv;
#line 766
    rv ++;
#line 766
    *(out + __cil_tmp7) = (uint8_t )(hi | 128U);
#line 767
    hi >>= 7;
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  __cil_tmp8 = rv;
#line 769
  rv ++;
#line 769
  *(out + __cil_tmp8) = (uint8_t )hi;
#line 770
  return ((size_t )rv);
}
}
#line 785 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t sint64_pack(int64_t value , uint8_t *out ) 
{ 
  uint64_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
  {
#line 787
  __cil_tmp3 = zigzag64(value);
#line 787
  __cil_tmp4 = uint64_pack(__cil_tmp3, out);
  }
#line 787
  return (__cil_tmp4);
}
}
#line 802 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t fixed32_pack(uint32_t value , void *out ) 
{ 


  {
  {
#line 805
  memcpy(out, & value, (unsigned long )4);
  }
#line 814
  return ((size_t )4);
}
}
#line 833 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t fixed64_pack(uint64_t value , void *out ) 
{ 


  {
  {
#line 836
  memcpy(out, & value, (unsigned long )8);
  }
#line 841
  return ((size_t )8);
}
}
#line 858 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t boolean_pack(protobuf_c_boolean value , uint8_t *out ) 
{ 
  int tmp ;

  {
#line 860
  if (value) {
#line 860
    tmp = 1;
  } else {
#line 860
    tmp = 0;
  }
#line 860
  *out = (uint8_t )tmp;
#line 861
  return ((size_t )1);
}
}
#line 880 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t string_pack(char const   *str , uint8_t *out ) 
{ 
  size_t len ;
  unsigned long __cil_tmp4 ;
  size_t rv ;
  size_t __cil_tmp6 ;

  {
#line 882
  if (str == (void *)0) {
#line 883
    *(out + 0) = (uint8_t )0;
#line 884
    return ((size_t )1);
  } else {
    {
#line 886
    __cil_tmp4 = strlen(str);
#line 886
    len = __cil_tmp4;
#line 887
    __cil_tmp6 = uint32_pack((uint32_t )len, out);
#line 887
    rv = __cil_tmp6;
#line 888
    memcpy(out + rv, str, len);
    }
#line 889
    return (rv + len);
  }
}
}
#line 905 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t binary_data_pack(ProtobufCBinaryData *bd , uint8_t *out ) 
{ 
  size_t len ;
  size_t rv ;
  size_t __cil_tmp5 ;

  {
  {
#line 907
  len = bd->len;
#line 908
  __cil_tmp5 = uint32_pack((uint32_t )len, out);
#line 908
  rv = __cil_tmp5;
#line 909
  memcpy(out + rv, bd->data, len);
  }
#line 910
  return (rv + len);
}
}
#line 925 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t prefixed_message_pack(ProtobufCMessage *message , uint8_t *out ) 
{ 
  size_t rv ;
  size_t __cil_tmp4 ;
  uint32_t rv_packed_size ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
#line 927
  if (message == (void *)0) {
#line 928
    *(out + 0) = (uint8_t )0;
#line 929
    return ((size_t )1);
  } else {
    {
#line 931
    __cil_tmp4 = protobuf_c_message_pack(message, out + 1);
#line 931
    rv = __cil_tmp4;
#line 932
    __cil_tmp6 = uint32_size((uint32_t )rv);
#line 932
    rv_packed_size = (uint32_t )__cil_tmp6;
    }
#line 933
    if (rv_packed_size != 1U) {
      {
#line 934
      memmove(out + rv_packed_size, out + 1, rv);
      }
    }
    {
#line 935
    __cil_tmp7 = uint32_pack((uint32_t )rv, out);
    }
#line 935
    return (__cil_tmp7 + rv);
  }
}
}
#line 954 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t tag_pack(uint32_t id , uint8_t *out ) 
{ 
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;

  {
#line 956
  if (id < (unsigned int )(1 << 29)) {
    {
#line 957
    __cil_tmp3 = uint32_pack(id << 3, out);
    }
#line 957
    return (__cil_tmp3);
  } else {
    {
#line 959
    __cil_tmp4 = uint64_pack((uint64_t )id << 3, out);
    }
#line 959
    return (__cil_tmp4);
  }
}
}
#line 975 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t required_field_pack(ProtobufCFieldDescriptor *field , void const   *member ,
                                  uint8_t *out ) 
{ 
  size_t rv ;
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  size_t __cil_tmp15 ;
  size_t __cil_tmp16 ;
  int tmp ;

  {
  {
#line 978
  __cil_tmp5 = tag_pack(field->id, out);
#line 978
  rv = __cil_tmp5;
  }
  {
#line 981
  if ((unsigned int )field->type == (unsigned int )1) {
#line 981
    goto case_1;
  }
#line 984
  if ((unsigned int )field->type == (unsigned int )0) {
#line 984
    goto case_0;
  }
#line 988
  if ((unsigned int )field->type == (unsigned int )13) {
#line 988
    goto case_13;
  }
#line 988
  if ((unsigned int )field->type == (unsigned int )6) {
#line 988
    goto case_13;
  }
#line 991
  if ((unsigned int )field->type == (unsigned int )4) {
#line 991
    goto case_4;
  }
#line 995
  if ((unsigned int )field->type == (unsigned int )8) {
#line 995
    goto case_8;
  }
#line 995
  if ((unsigned int )field->type == (unsigned int )3) {
#line 995
    goto case_8;
  }
#line 1000
  if ((unsigned int )field->type == (unsigned int )10) {
#line 1000
    goto case_10;
  }
#line 1000
  if ((unsigned int )field->type == (unsigned int )7) {
#line 1000
    goto case_10;
  }
#line 1000
  if ((unsigned int )field->type == (unsigned int )2) {
#line 1000
    goto case_10;
  }
#line 1005
  if ((unsigned int )field->type == (unsigned int )11) {
#line 1005
    goto case_11;
  }
#line 1005
  if ((unsigned int )field->type == (unsigned int )9) {
#line 1005
    goto case_11;
  }
#line 1005
  if ((unsigned int )field->type == (unsigned int )5) {
#line 1005
    goto case_11;
  }
#line 1008
  if ((unsigned int )field->type == (unsigned int )12) {
#line 1008
    goto case_12;
  }
#line 1011
  if ((unsigned int )field->type == (unsigned int )14) {
#line 1011
    goto case_14;
  }
#line 1014
  if ((unsigned int )field->type == (unsigned int )15) {
#line 1014
    goto case_15;
  }
#line 1017
  if ((unsigned int )field->type == (unsigned int )16) {
#line 1017
    goto case_16;
  }
#line 980
  goto switch_break;
  case_1: /* CIL Label */ 
#line 982
  *(out + 0) |= 0;
  {
#line 983
  __cil_tmp6 = sint32_pack(*((int32_t *)member), out + rv);
  }
#line 983
  return (rv + __cil_tmp6);
  case_0: /* CIL Label */ 
#line 985
  *(out + 0) |= 0;
  {
#line 986
  __cil_tmp7 = int32_pack((int32_t )*((uint32_t *)member), out + rv);
  }
#line 986
  return (rv + __cil_tmp7);
  case_13: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 989
  *(out + 0) |= 0;
  {
#line 990
  __cil_tmp8 = uint32_pack(*((uint32_t *)member), out + rv);
  }
#line 990
  return (rv + __cil_tmp8);
  case_4: /* CIL Label */ 
#line 992
  *(out + 0) |= 0;
  {
#line 993
  __cil_tmp9 = sint64_pack(*((int64_t *)member), out + rv);
  }
#line 993
  return (rv + __cil_tmp9);
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 996
  *(out + 0) |= 0;
  {
#line 997
  __cil_tmp10 = uint64_pack(*((uint64_t *)member), out + rv);
  }
#line 997
  return (rv + __cil_tmp10);
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1001
  *(out + 0) |= 5;
  {
#line 1002
  __cil_tmp11 = fixed32_pack(*((uint32_t *)member), out + rv);
  }
#line 1002
  return (rv + __cil_tmp11);
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1006
  *(out + 0) |= 1;
  {
#line 1007
  __cil_tmp12 = fixed64_pack(*((uint64_t *)member), out + rv);
  }
#line 1007
  return (rv + __cil_tmp12);
  case_12: /* CIL Label */ 
#line 1009
  *(out + 0) |= 0;
  {
#line 1010
  __cil_tmp13 = boolean_pack(*((protobuf_c_boolean *)member), out + rv);
  }
#line 1010
  return (rv + __cil_tmp13);
  case_14: /* CIL Label */ 
#line 1012
  *(out + 0) |= 2;
  {
#line 1013
  __cil_tmp14 = string_pack((char const   *)*((char * const  *)member), out + rv);
  }
#line 1013
  return (rv + __cil_tmp14);
  case_15: /* CIL Label */ 
#line 1015
  *(out + 0) |= 2;
  {
#line 1016
  __cil_tmp15 = binary_data_pack((ProtobufCBinaryData *)member, out + rv);
  }
#line 1016
  return (rv + __cil_tmp15);
  case_16: /* CIL Label */ 
#line 1018
  *(out + 0) |= 2;
  {
#line 1019
  __cil_tmp16 = prefixed_message_pack((ProtobufCMessage *)*((ProtobufCMessage * const  *)member),
                                      out + rv);
  }
#line 1019
  return (rv + __cil_tmp16);
  switch_break: /* CIL Label */ ;
  }
#line 1022
  return ((size_t )0);
}
}
#line 1040 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t optional_field_pack(ProtobufCFieldDescriptor *field , protobuf_c_boolean *has ,
                                  void const   *member , uint8_t *out ) 
{ 
  void const   *ptr ;
  size_t __cil_tmp6 ;

  {
#line 1044
  if ((unsigned int )field->type == 16U) {
    _L: /* CIL Label */ 
#line 1047
    ptr = *((void const   * const  *)member);
#line 1048
    if (ptr == (void *)0) {
#line 1049
      return ((size_t )0);
    } else
#line 1048
    if (ptr == field->default_value) {
#line 1049
      return ((size_t )0);
    }
  } else
#line 1044
  if ((unsigned int )field->type == 14U) {
#line 1044
    goto _L;
  } else
#line 1051
  if (! *has) {
#line 1052
    return ((size_t )0);
  }
  {
#line 1054
  __cil_tmp6 = required_field_pack(field, member, out);
  }
#line 1054
  return (__cil_tmp6);
}
}
#line 1068 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t sizeof_elt_in_repeated_array(ProtobufCType type ) 
{ 
  int tmp ;

  {
  {
#line 1077
  if ((unsigned int )type == (unsigned int )13) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )10) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )7) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )2) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )6) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )0) {
#line 1077
    goto case_13;
  }
#line 1077
  if ((unsigned int )type == (unsigned int )1) {
#line 1077
    goto case_13;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )11) {
#line 1084
    goto case_11;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )9) {
#line 1084
    goto case_11;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )5) {
#line 1084
    goto case_11;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )8) {
#line 1084
    goto case_11;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )3) {
#line 1084
    goto case_11;
  }
#line 1084
  if ((unsigned int )type == (unsigned int )4) {
#line 1084
    goto case_11;
  }
#line 1086
  if ((unsigned int )type == (unsigned int )12) {
#line 1086
    goto case_12;
  }
#line 1089
  if ((unsigned int )type == (unsigned int )16) {
#line 1089
    goto case_16;
  }
#line 1089
  if ((unsigned int )type == (unsigned int )14) {
#line 1089
    goto case_16;
  }
#line 1091
  if ((unsigned int )type == (unsigned int )15) {
#line 1091
    goto case_15;
  }
#line 1070
  goto switch_break;
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1078
  return ((size_t )4);
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 1085
  return ((size_t )8);
  case_12: /* CIL Label */ 
#line 1087
  return (sizeof(protobuf_c_boolean ));
  case_16: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 1090
  return (sizeof(void *));
  case_15: /* CIL Label */ 
#line 1092
  return (sizeof(ProtobufCBinaryData ));
  switch_break: /* CIL Label */ ;
  }
#line 1095
  return ((size_t )0);
}
}
#line 1109 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void copy_to_little_endian_32(void *out , void const   *in , unsigned int n ) 
{ 


  {
  {
#line 1112
  memcpy(out, in, (unsigned long )(n * 4U));
  }
  return;
}
}
#line 1132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void copy_to_little_endian_64(void *out , void const   *in , unsigned int n ) 
{ 


  {
  {
#line 1135
  memcpy(out, in, (unsigned long )(n * 8U));
  }
  return;
}
}
#line 1154 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static unsigned int get_type_min_size(ProtobufCType type ) 
{ 


  {
#line 1156
  if ((unsigned int )type == 2U) {
#line 1160
    return ((unsigned int )4);
  } else
#line 1156
  if ((unsigned int )type == 7U) {
#line 1160
    return ((unsigned int )4);
  } else
#line 1156
  if ((unsigned int )type == 10U) {
#line 1160
    return ((unsigned int )4);
  }
#line 1162
  if ((unsigned int )type == 5U) {
#line 1166
    return ((unsigned int )8);
  } else
#line 1162
  if ((unsigned int )type == 9U) {
#line 1166
    return ((unsigned int )8);
  } else
#line 1162
  if ((unsigned int )type == 11U) {
#line 1166
    return ((unsigned int )8);
  }
#line 1168
  return ((unsigned int )1);
}
}
#line 1187 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t repeated_field_pack(ProtobufCFieldDescriptor *field , size_t count ,
                                  void const   *member , uint8_t *out ) 
{ 
  void *array ;
  unsigned int i ;
  unsigned int header_len ;
  unsigned int len_start ;
  unsigned int min_length ;
  unsigned int payload_len ;
  unsigned int length_size_min ;
  unsigned int actual_length_size ;
  uint8_t *payload_at ;
  size_t __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  size_t __cil_tmp16 ;
  int32_t *arr ;
  size_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  int32_t *arr___0 ;
  size_t __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  int64_t *arr___1 ;
  size_t __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  uint32_t *arr___2 ;
  size_t __cil_tmp27 ;
  unsigned int __cil_tmp28 ;
  uint64_t *arr___3 ;
  size_t __cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  protobuf_c_boolean *arr___4 ;
  size_t __cil_tmp33 ;
  unsigned int __cil_tmp34 ;
  int tmp ;
  size_t __cil_tmp36 ;
  int tmp___0 ;
  unsigned int __cil_tmp38 ;
  size_t rv ;
  unsigned int siz ;
  size_t __cil_tmp41 ;
  size_t __cil_tmp42 ;
  unsigned int __cil_tmp43 ;

  {
#line 1190
  array = *((void * const  *)member);
#line 1193
  if (0U != (field->flags & 1U)) {
#line 1202
    if (count == 0UL) {
#line 1203
      return ((size_t )0);
    }
    {
#line 1204
    __cil_tmp14 = tag_pack(field->id, out);
#line 1204
    header_len = (unsigned int )__cil_tmp14;
#line 1205
    *(out + 0) |= 2;
#line 1206
    len_start = header_len;
#line 1207
    __cil_tmp15 = get_type_min_size(field->type);
#line 1207
    min_length = (unsigned int )((unsigned long )__cil_tmp15 * count);
#line 1208
    __cil_tmp16 = uint32_size(min_length);
#line 1208
    length_size_min = (unsigned int )__cil_tmp16;
#line 1209
    header_len += length_size_min;
#line 1210
    payload_at = out + header_len;
    }
    {
#line 1215
    if ((unsigned int )field->type == (unsigned int )10) {
#line 1215
      goto case_10;
    }
#line 1215
    if ((unsigned int )field->type == (unsigned int )7) {
#line 1215
      goto case_10;
    }
#line 1215
    if ((unsigned int )field->type == (unsigned int )2) {
#line 1215
      goto case_10;
    }
#line 1221
    if ((unsigned int )field->type == (unsigned int )11) {
#line 1221
      goto case_11;
    }
#line 1221
    if ((unsigned int )field->type == (unsigned int )9) {
#line 1221
      goto case_11;
    }
#line 1221
    if ((unsigned int )field->type == (unsigned int )5) {
#line 1221
      goto case_11;
    }
#line 1225
    if ((unsigned int )field->type == (unsigned int )0) {
#line 1225
      goto case_0;
    }
#line 1231
    if ((unsigned int )field->type == (unsigned int )1) {
#line 1231
      goto case_1;
    }
#line 1237
    if ((unsigned int )field->type == (unsigned int )4) {
#line 1237
      goto case_4;
    }
#line 1244
    if ((unsigned int )field->type == (unsigned int )6) {
#line 1244
      goto case_6;
    }
#line 1244
    if ((unsigned int )field->type == (unsigned int )13) {
#line 1244
      goto case_6;
    }
#line 1251
    if ((unsigned int )field->type == (unsigned int )8) {
#line 1251
      goto case_8;
    }
#line 1251
    if ((unsigned int )field->type == (unsigned int )3) {
#line 1251
      goto case_8;
    }
#line 1257
    if ((unsigned int )field->type == (unsigned int )12) {
#line 1257
      goto case_12;
    }
#line 1212
    goto switch_break;
    case_10: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1216
    copy_to_little_endian_32(payload_at, array, (unsigned int )count);
    }
#line 1217
    payload_at += count * 4UL;
#line 1218
    goto switch_break;
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 1222
    copy_to_little_endian_64(payload_at, array, (unsigned int )count);
    }
#line 1223
    payload_at += count * 8UL;
#line 1224
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1226
    arr = (int32_t *)array;
#line 1227
    i = (unsigned int )0;
    {
#line 1227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1227
      if (! ((unsigned long )i < count)) {
#line 1227
        goto while_break;
      }
      {
#line 1228
      __cil_tmp18 = int32_pack(*(arr + i), payload_at);
      }
#line 1228
      payload_at += __cil_tmp18;
#line 1227
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1229
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1232
    arr___0 = (int32_t *)array;
#line 1233
    i = (unsigned int )0;
    {
#line 1233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1233
      if (! ((unsigned long )i < count)) {
#line 1233
        goto while_break___0;
      }
      {
#line 1234
      __cil_tmp21 = sint32_pack(*(arr___0 + i), payload_at);
      }
#line 1234
      payload_at += __cil_tmp21;
#line 1233
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1235
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1238
    arr___1 = (int64_t *)array;
#line 1239
    i = (unsigned int )0;
    {
#line 1239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1239
      if (! ((unsigned long )i < count)) {
#line 1239
        goto while_break___1;
      }
      {
#line 1240
      __cil_tmp24 = sint64_pack(*(arr___1 + i), payload_at);
      }
#line 1240
      payload_at += __cil_tmp24;
#line 1239
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1241
    goto switch_break;
    case_6: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 1245
    arr___2 = (uint32_t *)array;
#line 1246
    i = (unsigned int )0;
    {
#line 1246
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1246
      if (! ((unsigned long )i < count)) {
#line 1246
        goto while_break___2;
      }
      {
#line 1247
      __cil_tmp27 = uint32_pack(*(arr___2 + i), payload_at);
      }
#line 1247
      payload_at += __cil_tmp27;
#line 1246
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1248
    goto switch_break;
    case_8: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 1252
    arr___3 = (uint64_t *)array;
#line 1253
    i = (unsigned int )0;
    {
#line 1253
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1253
      if (! ((unsigned long )i < count)) {
#line 1253
        goto while_break___3;
      }
      {
#line 1254
      __cil_tmp30 = uint64_pack(*(arr___3 + i), payload_at);
      }
#line 1254
      payload_at += __cil_tmp30;
#line 1253
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1255
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1258
    arr___4 = (protobuf_c_boolean *)array;
#line 1259
    i = (unsigned int )0;
    {
#line 1259
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1259
      if (! ((unsigned long )i < count)) {
#line 1259
        goto while_break___4;
      }
      {
#line 1260
      __cil_tmp33 = boolean_pack(*(arr___4 + i), payload_at);
      }
#line 1260
      payload_at += __cil_tmp33;
#line 1259
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1261
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1267
    payload_len = (unsigned int )(payload_at - (out + header_len));
#line 1268
    __cil_tmp36 = uint32_size(payload_len);
#line 1268
    actual_length_size = (unsigned int )__cil_tmp36;
    }
#line 1269
    if (length_size_min != actual_length_size) {
      {
#line 1271
      memmove((out + header_len) + 1, out + header_len, (unsigned long )payload_len);
#line 1273
      header_len ++;
      }
    }
    {
#line 1275
    uint32_pack(payload_len, out + len_start);
    }
#line 1276
    return ((size_t )(header_len + payload_len));
  } else {
    {
#line 1280
    rv = (size_t )0;
#line 1281
    __cil_tmp41 = sizeof_elt_in_repeated_array(field->type);
#line 1281
    siz = (unsigned int )__cil_tmp41;
#line 1283
    i = (unsigned int )0;
    }
    {
#line 1283
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1283
      if (! ((unsigned long )i < count)) {
#line 1283
        goto while_break___5;
      }
      {
#line 1284
      __cil_tmp42 = required_field_pack(field, array, out + rv);
      }
#line 1284
      rv += __cil_tmp42;
#line 1285
      array = (char *)array + siz;
#line 1283
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1287
    return (rv);
  }
}
}
#line 1292 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t unknown_field_pack(ProtobufCMessageUnknownField *field , uint8_t *out ) 
{ 
  size_t rv ;
  size_t __cil_tmp4 ;

  {
  {
#line 1294
  __cil_tmp4 = tag_pack(field->tag, out);
#line 1294
  rv = __cil_tmp4;
#line 1295
  *(out + 0) |= (unsigned int )field->wire_type;
#line 1296
  memcpy(out + rv, field->data, field->len);
  }
#line 1297
  return (rv + field->len);
}
}
#line 1303 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
size_t protobuf_c_message_pack(ProtobufCMessage *message , uint8_t *out ) 
{ 
  unsigned int i ;
  size_t rv ;
  int tmp ;
  ProtobufCFieldDescriptor *field ;
  void const   *member ;
  void const   *qmember ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  size_t __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1306
  rv = (size_t )0;
#line 1309
  i = (unsigned int )0;
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! (i < (message->descriptor)->n_fields)) {
#line 1309
      goto while_break;
    }
#line 1310
    field = (message->descriptor)->fields + i;
#line 1312
    member = (char const   *)message + field->offset;
#line 1322
    qmember = (char const   *)message + field->quantifier_offset;
#line 1325
    if ((unsigned int )field->label == 0U) {
      {
#line 1326
      __cil_tmp9 = required_field_pack(field, member, out + rv);
      }
#line 1326
      rv += __cil_tmp9;
    } else
#line 1327
    if ((unsigned int )field->label == 1U) {
      {
#line 1332
      __cil_tmp10 = optional_field_pack(field, qmember, member, out + rv);
      }
#line 1332
      rv += __cil_tmp10;
    } else {
      {
#line 1334
      __cil_tmp11 = repeated_field_pack(field, *((size_t *)qmember), member, out + rv);
      }
#line 1334
      rv += __cil_tmp11;
    }
#line 1309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1338
  i = (unsigned int )0;
  {
#line 1338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1338
    if (! (i < message->n_unknown_fields)) {
#line 1338
      goto while_break___0;
    }
    {
#line 1339
    __cil_tmp13 = unknown_field_pack(message->unknown_fields + i, out + rv);
    }
#line 1339
    rv += __cil_tmp13;
#line 1338
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1340
  return (rv);
}
}
#line 1365 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t required_field_pack_to_buffer(ProtobufCFieldDescriptor *field , void const   *member ,
                                            ProtobufCBuffer *buffer ) 
{ 
  size_t rv ;
  uint8_t scratch[20] ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  size_t __cil_tmp14 ;
  char const   *str ;
  size_t sublen ;
  unsigned long __cil_tmp17 ;
  unsigned long tmp ;
  size_t __cil_tmp19 ;
  ProtobufCBinaryData *bd ;
  size_t sublen___0 ;
  size_t __cil_tmp22 ;
  uint8_t simple_buffer_scratch[256] ;
  size_t sublen___1 ;
  ProtobufCMessage *msg ;
  ProtobufCBufferSimple simple_buffer ;
  size_t __cil_tmp27 ;
  size_t __cil_tmp28 ;
  int tmp___0 ;

  {
  {
#line 1371
  rv = tag_pack(field->id, (uint8_t *)scratch);
  }
  {
#line 1373
  if ((unsigned int )field->type == (unsigned int )1) {
#line 1373
    goto case_1;
  }
#line 1378
  if ((unsigned int )field->type == (unsigned int )0) {
#line 1378
    goto case_0;
  }
#line 1384
  if ((unsigned int )field->type == (unsigned int )13) {
#line 1384
    goto case_13;
  }
#line 1384
  if ((unsigned int )field->type == (unsigned int )6) {
#line 1384
    goto case_13;
  }
#line 1389
  if ((unsigned int )field->type == (unsigned int )4) {
#line 1389
    goto case_4;
  }
#line 1395
  if ((unsigned int )field->type == (unsigned int )8) {
#line 1395
    goto case_8;
  }
#line 1395
  if ((unsigned int )field->type == (unsigned int )3) {
#line 1395
    goto case_8;
  }
#line 1402
  if ((unsigned int )field->type == (unsigned int )10) {
#line 1402
    goto case_10;
  }
#line 1402
  if ((unsigned int )field->type == (unsigned int )7) {
#line 1402
    goto case_10;
  }
#line 1402
  if ((unsigned int )field->type == (unsigned int )2) {
#line 1402
    goto case_10;
  }
#line 1409
  if ((unsigned int )field->type == (unsigned int )11) {
#line 1409
    goto case_11;
  }
#line 1409
  if ((unsigned int )field->type == (unsigned int )9) {
#line 1409
    goto case_11;
  }
#line 1409
  if ((unsigned int )field->type == (unsigned int )5) {
#line 1409
    goto case_11;
  }
#line 1414
  if ((unsigned int )field->type == (unsigned int )12) {
#line 1414
    goto case_12;
  }
#line 1419
  if ((unsigned int )field->type == (unsigned int )14) {
#line 1419
    goto case_14;
  }
#line 1430
  if ((unsigned int )field->type == (unsigned int )15) {
#line 1430
    goto case_15;
  }
#line 1441
  if ((unsigned int )field->type == (unsigned int )16) {
#line 1441
    goto case_16;
  }
#line 1372
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1374
  scratch[0] |= 0;
  {
#line 1375
  __cil_tmp7 = sint32_pack(*((int32_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1375
  rv += __cil_tmp7;
#line 1376
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1377
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1379
  scratch[0] |= 0;
  {
#line 1380
  __cil_tmp8 = int32_pack((int32_t )*((uint32_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1380
  rv += __cil_tmp8;
#line 1381
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1382
  goto switch_break;
  case_13: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 1385
  scratch[0] |= 0;
  {
#line 1386
  __cil_tmp9 = uint32_pack(*((uint32_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1386
  rv += __cil_tmp9;
#line 1387
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1388
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1390
  scratch[0] |= 0;
  {
#line 1391
  __cil_tmp10 = sint64_pack(*((int64_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1391
  rv += __cil_tmp10;
#line 1392
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1393
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1396
  scratch[0] |= 0;
  {
#line 1397
  __cil_tmp11 = uint64_pack(*((uint64_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1397
  rv += __cil_tmp11;
#line 1398
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1399
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1403
  scratch[0] |= 5;
  {
#line 1404
  __cil_tmp12 = fixed32_pack(*((uint32_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1404
  rv += __cil_tmp12;
#line 1405
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1406
  goto switch_break;
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1410
  scratch[0] |= 1;
  {
#line 1411
  __cil_tmp13 = fixed64_pack(*((uint64_t *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1411
  rv += __cil_tmp13;
#line 1412
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1413
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1415
  scratch[0] |= 0;
  {
#line 1416
  __cil_tmp14 = boolean_pack(*((protobuf_c_boolean *)member), (uint8_t *)scratch + rv);
  }
  {
#line 1416
  rv += __cil_tmp14;
#line 1417
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
  }
#line 1418
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1420
  str = (char const   *)*((char * const  *)member);
#line 1421
  if (str) {
    {
#line 1421
    __cil_tmp17 = strlen(str);
#line 1421
    tmp = __cil_tmp17;
    }
  } else {
#line 1421
    tmp = (unsigned long )0;
  }
  {
#line 1421
  sublen = tmp;
#line 1423
  scratch[0] |= 2;
#line 1424
  __cil_tmp19 = uint32_pack((uint32_t )sublen, (uint8_t *)scratch + rv);
  }
  {
#line 1424
  rv += __cil_tmp19;
#line 1425
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
#line 1426
  (*(buffer->append))(buffer, sublen, (uint8_t *)str);
#line 1427
  rv += sublen;
  }
#line 1428
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1431
  bd = (ProtobufCBinaryData *)member;
#line 1432
  sublen___0 = bd->len;
#line 1434
  scratch[0] |= 2;
#line 1435
  __cil_tmp22 = uint32_pack((uint32_t )sublen___0, (uint8_t *)scratch + rv);
  }
  {
#line 1435
  rv += __cil_tmp22;
#line 1436
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
#line 1437
  (*(buffer->append))(buffer, sublen___0, bd->data);
#line 1438
  rv += sublen___0;
  }
#line 1439
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1444
  msg = (ProtobufCMessage *)*((ProtobufCMessage * const  *)member);
#line 1445
  simple_buffer.base.append = (void (*)(struct ProtobufCBuffer * , unsigned long  ,
                                        unsigned char * ))(& protobuf_c_buffer_simple_append);
#line 1445
  simple_buffer.alloced = sizeof(simple_buffer_scratch);
#line 1445
  simple_buffer.len = (size_t )0;
#line 1445
  simple_buffer.data = (uint8_t *)simple_buffer_scratch;
#line 1445
  simple_buffer.must_free_data = 0;
#line 1445
  simple_buffer.allocator = (ProtobufCAllocator *)((void *)0);
#line 1448
  scratch[0] |= 2;
#line 1449
  if (msg == (void *)0) {
#line 1450
    sublen___1 = (size_t )0;
  } else {
    {
#line 1452
    sublen___1 = protobuf_c_message_pack_to_buffer(msg, & simple_buffer.base);
    }
  }
  {
#line 1453
  __cil_tmp28 = uint32_pack((uint32_t )sublen___1, (uint8_t *)scratch + rv);
  }
  {
#line 1453
  rv += __cil_tmp28;
#line 1454
  (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
#line 1455
  (*(buffer->append))(buffer, sublen___1, simple_buffer.data);
#line 1456
  rv += sublen___1;
  }
  {
#line 1457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1457
    if (simple_buffer.must_free_data) {
#line 1457
      if (simple_buffer.allocator != (void *)0) {
        {
#line 1457
        (*((simple_buffer.allocator)->free))(simple_buffer.allocator, simple_buffer.data);
        }
      } else {
        {
#line 1457
        free(simple_buffer.data);
        }
      }
    }
#line 1457
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1458
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1463
  return (rv);
}
}
#line 1481 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t optional_field_pack_to_buffer(ProtobufCFieldDescriptor *field , protobuf_c_boolean *has ,
                                            void const   *member , ProtobufCBuffer *buffer ) 
{ 
  void const   *ptr ;
  size_t __cil_tmp6 ;

  {
#line 1485
  if ((unsigned int )field->type == 16U) {
    _L: /* CIL Label */ 
#line 1488
    ptr = *((void const   * const  *)member);
#line 1489
    if (ptr == (void *)0) {
#line 1490
      return ((size_t )0);
    } else
#line 1489
    if (ptr == field->default_value) {
#line 1490
      return ((size_t )0);
    }
  } else
#line 1485
  if ((unsigned int )field->type == 14U) {
#line 1485
    goto _L;
  } else
#line 1492
  if (! *has) {
#line 1493
    return ((size_t )0);
  }
  {
#line 1495
  __cil_tmp6 = required_field_pack_to_buffer(field, member, buffer);
  }
#line 1495
  return (__cil_tmp6);
}
}
#line 1511 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t get_packed_payload_length(ProtobufCFieldDescriptor *field , unsigned int count ,
                                        void const   *array ) 
{ 
  unsigned int rv ;
  unsigned int i ;
  int32_t *arr ;
  size_t __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  int32_t *arr___0 ;
  size_t __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  uint32_t *arr___1 ;
  size_t __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  int64_t *arr___2 ;
  size_t __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  uint64_t *arr___3 ;
  size_t __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int tmp ;

  {
#line 1514
  rv = (unsigned int )0;
  {
#line 1520
  if ((unsigned int )field->type == (unsigned int )10) {
#line 1520
    goto case_10;
  }
#line 1520
  if ((unsigned int )field->type == (unsigned int )7) {
#line 1520
    goto case_10;
  }
#line 1520
  if ((unsigned int )field->type == (unsigned int )2) {
#line 1520
    goto case_10;
  }
#line 1524
  if ((unsigned int )field->type == (unsigned int )11) {
#line 1524
    goto case_11;
  }
#line 1524
  if ((unsigned int )field->type == (unsigned int )9) {
#line 1524
    goto case_11;
  }
#line 1524
  if ((unsigned int )field->type == (unsigned int )5) {
#line 1524
    goto case_11;
  }
#line 1526
  if ((unsigned int )field->type == (unsigned int )0) {
#line 1526
    goto case_0;
  }
#line 1532
  if ((unsigned int )field->type == (unsigned int )1) {
#line 1532
    goto case_1;
  }
#line 1539
  if ((unsigned int )field->type == (unsigned int )6) {
#line 1539
    goto case_6;
  }
#line 1539
  if ((unsigned int )field->type == (unsigned int )13) {
#line 1539
    goto case_6;
  }
#line 1545
  if ((unsigned int )field->type == (unsigned int )4) {
#line 1545
    goto case_4;
  }
#line 1552
  if ((unsigned int )field->type == (unsigned int )8) {
#line 1552
    goto case_8;
  }
#line 1552
  if ((unsigned int )field->type == (unsigned int )3) {
#line 1552
    goto case_8;
  }
#line 1558
  if ((unsigned int )field->type == (unsigned int )12) {
#line 1558
    goto case_12;
  }
#line 1517
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1521
  return ((size_t )(count * 4U));
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1525
  return ((size_t )(count * 8U));
  case_0: /* CIL Label */ 
#line 1527
  arr = (int32_t *)array;
#line 1528
  i = (unsigned int )0;
  {
#line 1528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1528
    if (! (i < count)) {
#line 1528
      goto while_break;
    }
    {
#line 1529
    __cil_tmp7 = int32_size(*(arr + i));
    }
#line 1529
    rv += __cil_tmp7;
#line 1528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1533
  arr___0 = (int32_t *)array;
#line 1534
  i = (unsigned int )0;
  {
#line 1534
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1534
    if (! (i < count)) {
#line 1534
      goto while_break___0;
    }
    {
#line 1535
    __cil_tmp10 = sint32_size(*(arr___0 + i));
    }
#line 1535
    rv += __cil_tmp10;
#line 1534
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1536
  goto switch_break;
  case_6: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1540
  arr___1 = (uint32_t *)array;
#line 1541
  i = (unsigned int )0;
  {
#line 1541
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1541
    if (! (i < count)) {
#line 1541
      goto while_break___1;
    }
    {
#line 1542
    __cil_tmp13 = uint32_size(*(arr___1 + i));
    }
#line 1542
    rv += __cil_tmp13;
#line 1541
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1543
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1546
  arr___2 = (int64_t *)array;
#line 1547
  i = (unsigned int )0;
  {
#line 1547
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1547
    if (! (i < count)) {
#line 1547
      goto while_break___2;
    }
    {
#line 1548
    __cil_tmp16 = sint64_size(*(arr___2 + i));
    }
#line 1548
    rv += __cil_tmp16;
#line 1547
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1549
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1553
  arr___3 = (uint64_t *)array;
#line 1554
  i = (unsigned int )0;
  {
#line 1554
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1554
    if (! (i < count)) {
#line 1554
      goto while_break___3;
    }
    {
#line 1555
    __cil_tmp19 = uint64_size(*(arr___3 + i));
    }
#line 1555
    rv += __cil_tmp19;
#line 1554
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1556
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1559
  return ((size_t )count);
  switch_break: /* CIL Label */ ;
  }
#line 1563
  return ((size_t )rv);
}
}
#line 1581 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t pack_buffer_packed_payload(ProtobufCFieldDescriptor *field , unsigned int count ,
                                         void const   *array , ProtobufCBuffer *buffer ) 
{ 
  uint8_t scratch[16] ;
  size_t rv ;
  unsigned int i ;
  unsigned int len ;
  size_t __cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  unsigned int len___0 ;
  size_t __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  unsigned int len___1 ;
  size_t __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int len___2 ;
  size_t __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int len___3 ;
  size_t __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int len___4 ;
  size_t __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  int tmp ;

  {
#line 1586
  rv = (size_t )0;
  {
#line 1592
  if ((unsigned int )field->type == (unsigned int )10) {
#line 1592
    goto case_10;
  }
#line 1592
  if ((unsigned int )field->type == (unsigned int )7) {
#line 1592
    goto case_10;
  }
#line 1592
  if ((unsigned int )field->type == (unsigned int )2) {
#line 1592
    goto case_10;
  }
#line 1606
  if ((unsigned int )field->type == (unsigned int )11) {
#line 1606
    goto case_11;
  }
#line 1606
  if ((unsigned int )field->type == (unsigned int )9) {
#line 1606
    goto case_11;
  }
#line 1606
  if ((unsigned int )field->type == (unsigned int )5) {
#line 1606
    goto case_11;
  }
#line 1618
  if ((unsigned int )field->type == (unsigned int )0) {
#line 1618
    goto case_0;
  }
#line 1625
  if ((unsigned int )field->type == (unsigned int )1) {
#line 1625
    goto case_1;
  }
#line 1633
  if ((unsigned int )field->type == (unsigned int )6) {
#line 1633
    goto case_6;
  }
#line 1633
  if ((unsigned int )field->type == (unsigned int )13) {
#line 1633
    goto case_6;
  }
#line 1640
  if ((unsigned int )field->type == (unsigned int )4) {
#line 1640
    goto case_4;
  }
#line 1648
  if ((unsigned int )field->type == (unsigned int )8) {
#line 1648
    goto case_8;
  }
#line 1648
  if ((unsigned int )field->type == (unsigned int )3) {
#line 1648
    goto case_8;
  }
#line 1655
  if ((unsigned int )field->type == (unsigned int )12) {
#line 1655
    goto case_12;
  }
#line 1589
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1594
  rv = (size_t )(count * 4U);
#line 1595
  goto no_packing_needed;
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1608
  rv = (size_t )(count * 8U);
#line 1609
  goto no_packing_needed;
  case_0: /* CIL Label */ 
#line 1619
  i = (unsigned int )0;
  {
#line 1619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1619
    if (! (i < count)) {
#line 1619
      goto while_break;
    }
    {
#line 1620
    __cil_tmp9 = int32_pack(*((int32_t *)array + i), (uint8_t *)scratch);
#line 1620
    len = (unsigned int )__cil_tmp9;
#line 1621
    (*(buffer->append))(buffer, (size_t )len, (uint8_t *)scratch);
#line 1622
    rv += (unsigned long )len;
    }
#line 1619
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1624
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1626
  i = (unsigned int )0;
  {
#line 1626
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1626
    if (! (i < count)) {
#line 1626
      goto while_break___0;
    }
    {
#line 1627
    __cil_tmp12 = sint32_pack(*((int32_t *)array + i), (uint8_t *)scratch);
#line 1627
    len___0 = (unsigned int )__cil_tmp12;
#line 1628
    (*(buffer->append))(buffer, (size_t )len___0, (uint8_t *)scratch);
#line 1629
    rv += (unsigned long )len___0;
    }
#line 1626
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1631
  goto switch_break;
  case_6: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 1634
  i = (unsigned int )0;
  {
#line 1634
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1634
    if (! (i < count)) {
#line 1634
      goto while_break___1;
    }
    {
#line 1635
    __cil_tmp15 = uint32_pack(*((uint32_t *)array + i), (uint8_t *)scratch);
#line 1635
    len___1 = (unsigned int )__cil_tmp15;
#line 1636
    (*(buffer->append))(buffer, (size_t )len___1, (uint8_t *)scratch);
#line 1637
    rv += (unsigned long )len___1;
    }
#line 1634
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1639
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1641
  i = (unsigned int )0;
  {
#line 1641
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1641
    if (! (i < count)) {
#line 1641
      goto while_break___2;
    }
    {
#line 1642
    __cil_tmp18 = sint64_pack(*((int64_t *)array + i), (uint8_t *)scratch);
#line 1642
    len___2 = (unsigned int )__cil_tmp18;
#line 1643
    (*(buffer->append))(buffer, (size_t )len___2, (uint8_t *)scratch);
#line 1644
    rv += (unsigned long )len___2;
    }
#line 1641
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1646
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1649
  i = (unsigned int )0;
  {
#line 1649
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1649
    if (! (i < count)) {
#line 1649
      goto while_break___3;
    }
    {
#line 1650
    __cil_tmp21 = uint64_pack(*((uint64_t *)array + i), (uint8_t *)scratch);
#line 1650
    len___3 = (unsigned int )__cil_tmp21;
#line 1651
    (*(buffer->append))(buffer, (size_t )len___3, (uint8_t *)scratch);
#line 1652
    rv += (unsigned long )len___3;
    }
#line 1649
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1654
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1656
  i = (unsigned int )0;
  {
#line 1656
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1656
    if (! (i < count)) {
#line 1656
      goto while_break___4;
    }
    {
#line 1657
    __cil_tmp24 = boolean_pack(*((protobuf_c_boolean *)array + i), (uint8_t *)scratch);
#line 1657
    len___4 = (unsigned int )__cil_tmp24;
#line 1658
    (*(buffer->append))(buffer, (size_t )len___4, (uint8_t *)scratch);
#line 1659
    rv += (unsigned long )len___4;
    }
#line 1656
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1661
  return ((size_t )count);
  switch_break: /* CIL Label */ ;
  }
#line 1665
  return (rv);
  no_packing_needed: 
  {
#line 1668
  (*(buffer->append))(buffer, rv, array);
  }
#line 1669
  return (rv);
}
}
#line 1673 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t repeated_field_pack_to_buffer(ProtobufCFieldDescriptor *field , unsigned int count ,
                                            void const   *member , ProtobufCBuffer *buffer ) 
{ 
  char *array ;
  uint8_t scratch[20] ;
  size_t rv ;
  size_t __cil_tmp8 ;
  size_t payload_len ;
  size_t __cil_tmp10 ;
  size_t tmp ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;
  int tmp___39 ;
  size_t siz ;
  unsigned int i ;
  unsigned int rv___0 ;
  size_t __cil_tmp18 ;
  size_t __cil_tmp19 ;
  unsigned int __cil_tmp20 ;

  {
#line 1677
  array = *((char * const  *)member);
#line 1679
  if (count == 0U) {
#line 1680
    return ((size_t )0);
  }
#line 1681
  if (0U != (field->flags & 1U)) {
    {
#line 1683
    __cil_tmp8 = tag_pack(field->id, (uint8_t *)scratch);
#line 1683
    rv = __cil_tmp8;
#line 1684
    __cil_tmp10 = get_packed_payload_length(field, count, array);
#line 1684
    payload_len = __cil_tmp10;
#line 1687
    scratch[0] |= 2;
#line 1688
    __cil_tmp12 = uint32_pack((uint32_t )payload_len, (uint8_t *)scratch + rv);
    }
    {
#line 1688
    rv += __cil_tmp12;
#line 1689
    (*(buffer->append))(buffer, rv, (uint8_t *)scratch);
#line 1690
    tmp = pack_buffer_packed_payload(field, count, array, buffer);
    }
#line 1692
    return (rv + payload_len);
  } else {
    {
#line 1697
    rv___0 = (unsigned int )0;
#line 1699
    siz = sizeof_elt_in_repeated_array(field->type);
#line 1700
    i = (unsigned int )0;
    }
    {
#line 1700
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1700
      if (! (i < count)) {
#line 1700
        goto while_break;
      }
      {
#line 1701
      __cil_tmp19 = required_field_pack_to_buffer(field, array, buffer);
      }
#line 1701
      rv___0 += __cil_tmp19;
#line 1702
      array += siz;
#line 1700
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1704
    return ((size_t )rv___0);
  }
}
}
#line 1709 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t unknown_field_pack_to_buffer(ProtobufCMessageUnknownField *field , ProtobufCBuffer *buffer ) 
{ 
  uint8_t header[10] ;
  size_t rv ;
  size_t __cil_tmp5 ;

  {
  {
#line 1713
  __cil_tmp5 = tag_pack(field->tag, (uint8_t *)header);
#line 1713
  rv = __cil_tmp5;
#line 1715
  header[0] |= (unsigned int )field->wire_type;
#line 1716
  (*(buffer->append))(buffer, rv, (uint8_t *)header);
#line 1717
  (*(buffer->append))(buffer, field->len, field->data);
  }
#line 1718
  return (rv + field->len);
}
}
#line 1724 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
size_t protobuf_c_message_pack_to_buffer(ProtobufCMessage *message , ProtobufCBuffer *buffer ) 
{ 
  unsigned int i ;
  size_t rv ;
  int tmp ;
  ProtobufCFieldDescriptor *field ;
  void const   *member ;
  void const   *qmember ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  size_t __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 1728
  rv = (size_t )0;
#line 1731
  i = (unsigned int )0;
  {
#line 1731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1731
    if (! (i < (message->descriptor)->n_fields)) {
#line 1731
      goto while_break;
    }
#line 1732
    field = (message->descriptor)->fields + i;
#line 1734
    member = (char const   *)message + field->offset;
#line 1736
    qmember = (char const   *)message + field->quantifier_offset;
#line 1739
    if ((unsigned int )field->label == 0U) {
      {
#line 1740
      __cil_tmp9 = required_field_pack_to_buffer(field, member, buffer);
      }
#line 1740
      rv += __cil_tmp9;
    } else
#line 1741
    if ((unsigned int )field->label == 1U) {
      {
#line 1742
      __cil_tmp10 = optional_field_pack_to_buffer(field, qmember, member, buffer);
      }
#line 1742
      rv += __cil_tmp10;
    } else {
      {
#line 1749
      __cil_tmp11 = repeated_field_pack_to_buffer(field, (unsigned int )*((size_t *)qmember),
                                                  member, buffer);
      }
#line 1749
      rv += __cil_tmp11;
    }
#line 1731
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1757
  i = (unsigned int )0;
  {
#line 1757
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1757
    if (! (i < message->n_unknown_fields)) {
#line 1757
      goto while_break___0;
    }
    {
#line 1758
    __cil_tmp13 = unknown_field_pack_to_buffer(message->unknown_fields + i, buffer);
    }
#line 1758
    rv += __cil_tmp13;
#line 1757
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1760
  return (rv);
}
}
#line 1773 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static int int_range_lookup(unsigned int n_ranges , ProtobufCIntRange *ranges , int value ) 
{ 
  unsigned int n ;
  unsigned int start___0 ;
  unsigned int mid ;
  unsigned int new_start ;
  unsigned int start_orig_index ;
  unsigned int range_size ;

  {
#line 1778
  if (n_ranges == 0U) {
#line 1779
    return (- 1);
  }
#line 1780
  start___0 = (unsigned int )0;
#line 1781
  n = n_ranges;
  {
#line 1782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1782
    if (! (n > 1U)) {
#line 1782
      goto while_break;
    }
#line 1783
    mid = start___0 + n / 2U;
#line 1785
    if (value < (ranges + mid)->start_value) {
#line 1786
      n = mid - start___0;
    } else
#line 1787
    if (value >= (ranges + mid)->start_value + (int )((ranges + (mid + 1U))->orig_index - (ranges + mid)->orig_index)) {
#line 1791
      new_start = mid + 1U;
#line 1792
      n = (start___0 + n) - new_start;
#line 1793
      start___0 = new_start;
    } else {
#line 1795
      return ((int )((unsigned int )(value - (ranges + mid)->start_value) + (ranges + mid)->orig_index));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1798
  if (n > 0U) {
#line 1799
    start_orig_index = (ranges + start___0)->orig_index;
#line 1800
    range_size = (ranges + (start___0 + 1U))->orig_index - start_orig_index;
#line 1803
    if ((ranges + start___0)->start_value <= value) {
#line 1803
      if (value < (int )((unsigned int )(ranges + start___0)->start_value + range_size)) {
#line 1806
        return ((int )((unsigned int )(value - (ranges + start___0)->start_value) + start_orig_index));
      }
    }
  }
#line 1810
  return (- 1);
}
}
#line 1814 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t parse_tag_and_wiretype(size_t len , uint8_t *data , uint32_t *tag_out ,
                                     ProtobufCWireType *wiretype_out ) 
{ 
  unsigned int max_rv ;
  unsigned long tmp ;
  uint32_t tag ;
  unsigned int shift ;
  unsigned int rv ;
  unsigned int __cil_tmp10 ;

  {
#line 1819
  if (len > 5UL) {
#line 1819
    tmp = (unsigned long )5;
  } else {
#line 1819
    tmp = len;
  }
#line 1819
  max_rv = (unsigned int )tmp;
#line 1820
  tag = (uint32_t )(((int )*(data + 0) & 127) >> 3);
#line 1821
  shift = (unsigned int )4;
#line 1824
  *wiretype_out = (ProtobufCWireType )((int )*(data + 0) & 7);
#line 1825
  if (((int )*(data + 0) & 128) == 0) {
#line 1826
    *tag_out = tag;
#line 1827
    return ((size_t )1);
  }
#line 1829
  rv = (unsigned int )1;
  {
#line 1829
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1829
    if (! (rv < max_rv)) {
#line 1829
      goto while_break;
    }
#line 1830
    if ((int )*(data + rv) & 128) {
#line 1831
      tag |= (unsigned int )(((int )*(data + rv) & 127) << shift);
#line 1832
      shift += (unsigned int )7;
    } else {
#line 1834
      tag |= (unsigned int )((int )*(data + rv) << shift);
#line 1835
      *tag_out = tag;
#line 1836
      return ((size_t )(rv + 1U));
    }
#line 1829
    rv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1839
  return ((size_t )0);
}
}
#line 1856 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint32_t scan_length_prefixed_data(size_t len , uint8_t *data , size_t *prefix_len_out ) 
{ 
  unsigned int hdr_max ;
  size_t tmp ;
  unsigned int hdr_len ;
  uint32_t val ;
  unsigned int i ;
  unsigned int shift ;
  unsigned int __cil_tmp10 ;

  {
#line 1859
  if (len < 5UL) {
#line 1859
    tmp = len;
  } else {
#line 1859
    tmp = (unsigned long )5;
  }
#line 1859
  hdr_max = (unsigned int )tmp;
#line 1861
  val = (uint32_t )0;
#line 1863
  shift = (unsigned int )0;
#line 1865
  i = (unsigned int )0;
  {
#line 1865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1865
    if (! (i < hdr_max)) {
#line 1865
      goto while_break;
    }
#line 1866
    val |= (unsigned int )(((int )*(data + i) & 127) << shift);
#line 1867
    shift += (unsigned int )7;
#line 1868
    if (((int )*(data + i) & 128) == 0) {
#line 1869
      goto while_break;
    }
#line 1865
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1871
  if (i == hdr_max) {
#line 1873
    return ((uint32_t )0);
  }
#line 1875
  hdr_len = i + 1U;
#line 1876
  *prefix_len_out = (size_t )hdr_len;
#line 1877
  if ((unsigned long )(hdr_len + val) > len) {
#line 1879
    return ((uint32_t )0);
  }
#line 1881
  return (hdr_len + val);
}
}
#line 1885 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static size_t max_b128_numbers(size_t len , uint8_t *data ) 
{ 
  size_t rv ;
  size_t __cil_tmp4 ;
  uint8_t *__cil_tmp5 ;

  {
#line 1887
  rv = (size_t )0;
  {
#line 1888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1888
    __cil_tmp4 = len;
#line 1888
    len --;
#line 1888
    if (! __cil_tmp4) {
#line 1888
      goto while_break;
    }
#line 1889
    __cil_tmp5 = data;
#line 1889
    data ++;
#line 1889
    if (((int )*__cil_tmp5 & 128) == 0) {
#line 1890
      rv ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1891
  return (rv);
}
}
#line 1911 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean merge_messages(ProtobufCMessage *earlier_msg , ProtobufCMessage *latter_msg ,
                                         ProtobufCAllocator *allocator ) 
{ 
  unsigned int i ;
  ProtobufCFieldDescriptor *fields ;
  size_t *n_earlier ;
  uint8_t **p_earlier ;
  size_t *n_latter ;
  uint8_t **p_latter ;
  size_t el_size ;
  size_t __cil_tmp11 ;
  uint8_t *new_field ;
  void *__cil_tmp13 ;
  ProtobufCMessage **em ;
  ProtobufCMessage **lm ;
  protobuf_c_boolean __cil_tmp16 ;
  int tmp ;
  size_t el_size___0 ;
  protobuf_c_boolean need_to_merge ;
  void *earlier_elem ;
  void *latter_elem ;
  void const   *def_val ;
  uint8_t *e_data ;
  uint8_t *l_data ;
  ProtobufCBinaryData *d_bd ;
  char *e_str ;
  char *l_str ;
  char const   *d_str ;
  size_t __cil_tmp29 ;
  unsigned int __cil_tmp30 ;

  {
#line 1916
  fields = (earlier_msg->descriptor)->fields;
#line 1918
  i = (unsigned int )0;
  {
#line 1918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1918
    if (! (i < (latter_msg->descriptor)->n_fields)) {
#line 1918
      goto while_break;
    }
#line 1919
    if ((unsigned int )(fields + i)->label == 2U) {
#line 1920
      n_earlier = (size_t *)((void *)((uint8_t *)earlier_msg + (fields + i)->quantifier_offset));
#line 1923
      p_earlier = (uint8_t **)((void *)((uint8_t *)earlier_msg + (fields + i)->offset));
#line 1926
      n_latter = (size_t *)((void *)((uint8_t *)latter_msg + (fields + i)->quantifier_offset));
#line 1929
      p_latter = (uint8_t **)((void *)((uint8_t *)latter_msg + (fields + i)->offset));
#line 1933
      if (*n_earlier > 0UL) {
#line 1934
        if (*n_latter > 0UL) {
          {
#line 1936
          __cil_tmp11 = sizeof_elt_in_repeated_array((fields + i)->type);
#line 1936
          el_size = __cil_tmp11;
#line 1940
          new_field = (uint8_t *)do_alloc(allocator, (*n_earlier + *n_latter) * el_size);
          }
#line 1942
          if (! new_field) {
#line 1943
            return (0);
          }
          {
#line 1945
          memcpy(new_field, *p_earlier, *n_earlier * el_size);
#line 1947
          memcpy(new_field + *n_earlier * el_size, *p_latter, *n_latter * el_size);
#line 1952
          do_free(allocator, *p_latter);
#line 1953
          do_free(allocator, *p_earlier);
#line 1954
          *p_latter = new_field;
#line 1955
          *n_latter = *n_earlier + *n_latter;
          }
        } else {
#line 1958
          *n_latter = *n_earlier;
#line 1959
          *p_latter = *p_earlier;
        }
#line 1962
        *n_earlier = (size_t )0;
#line 1963
        *p_earlier = (uint8_t *)0;
      }
    } else
#line 1965
    if ((unsigned int )(fields + i)->type == 16U) {
#line 1966
      em = (ProtobufCMessage **)((void *)((uint8_t *)earlier_msg + (fields + i)->offset));
#line 1970
      lm = (ProtobufCMessage **)((void *)((uint8_t *)latter_msg + (fields + i)->offset));
#line 1974
      if (*em != (void *)0) {
#line 1975
        if (*lm != (void *)0) {
          {
#line 1976
          __cil_tmp16 = merge_messages(*em, *lm, allocator);
          }
#line 1976
          if (! __cil_tmp16) {
#line 1978
            return (0);
          }
        } else {
#line 1983
          *lm = *em;
#line 1984
          *em = (ProtobufCMessage *)((void *)0);
        }
      }
    } else
#line 1987
    if ((unsigned int )(fields + i)->label == 1U) {
#line 1988
      el_size___0 = (size_t )0;
#line 1989
      need_to_merge = 0;
#line 1990
      earlier_elem = (void *)((uint8_t *)earlier_msg + (fields + i)->offset);
#line 1992
      latter_elem = (void *)((uint8_t *)latter_msg + (fields + i)->offset);
#line 1994
      def_val = (fields + i)->default_value;
      {
#line 1997
      if ((unsigned int )(fields + i)->type == (unsigned int )15) {
#line 1997
        goto case_15;
      }
#line 2014
      if ((unsigned int )(fields + i)->type == (unsigned int )14) {
#line 2014
        goto case_14;
      }
#line 2026
      goto switch_default;
      case_15: /* CIL Label */ 
#line 2001
      e_data = ((ProtobufCBinaryData *)earlier_elem)->data;
#line 2002
      l_data = ((ProtobufCBinaryData *)latter_elem)->data;
#line 2003
      d_bd = (ProtobufCBinaryData *)def_val;
#line 2005
      need_to_merge = (e_data != (void *)0 && (d_bd != (void *)0 && e_data != d_bd->data)) && (l_data == (void *)0 || (d_bd != (void *)0 && l_data == d_bd->data));
#line 2012
      goto switch_break;
      case_14: /* CIL Label */ 
#line 2018
      el_size___0 = sizeof(char *);
#line 2019
      e_str = *((char **)earlier_elem);
#line 2020
      l_str = *((char **)latter_elem);
#line 2021
      d_str = def_val;
#line 2023
      need_to_merge = e_str != d_str && l_str == d_str;
#line 2024
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2027
      el_size___0 = sizeof_elt_in_repeated_array((fields + i)->type);
#line 2029
      need_to_merge = *((protobuf_c_boolean *)((void *)((uint8_t *)earlier_msg + (fields + i)->quantifier_offset))) && ! *((protobuf_c_boolean *)((void *)((uint8_t *)latter_msg + (fields + i)->quantifier_offset)));
      }
#line 2036
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2040
      if (need_to_merge) {
        {
#line 2041
        memcpy(latter_elem, earlier_elem, el_size___0);
#line 2049
        memset(earlier_elem, 0, el_size___0);
        }
#line 2051
        if ((fields + i)->quantifier_offset != 0U) {
#line 2053
          *((protobuf_c_boolean *)((void *)((uint8_t *)latter_msg + (fields + i)->quantifier_offset))) = 1;
#line 2057
          *((protobuf_c_boolean *)((void *)((uint8_t *)earlier_msg + (fields + i)->quantifier_offset))) = 0;
        }
      }
    }
#line 1918
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2065
  return (1);
}
}
#line 2077 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean count_packed_elements(ProtobufCType type , size_t len ,
                                                uint8_t *data , size_t *count_out ) 
{ 
  size_t __cil_tmp5 ;

  {
  {
#line 2083
  if ((unsigned int )type == (unsigned int )10) {
#line 2083
    goto case_10;
  }
#line 2083
  if ((unsigned int )type == (unsigned int )7) {
#line 2083
    goto case_10;
  }
#line 2083
  if ((unsigned int )type == (unsigned int )2) {
#line 2083
    goto case_10;
  }
#line 2092
  if ((unsigned int )type == (unsigned int )11) {
#line 2092
    goto case_11;
  }
#line 2092
  if ((unsigned int )type == (unsigned int )9) {
#line 2092
    goto case_11;
  }
#line 2092
  if ((unsigned int )type == (unsigned int )5) {
#line 2092
    goto case_11;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )8) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )4) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )3) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )6) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )13) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )1) {
#line 2105
    goto case_8;
  }
#line 2105
  if ((unsigned int )type == (unsigned int )0) {
#line 2105
    goto case_8;
  }
#line 2108
  if ((unsigned int )type == (unsigned int )12) {
#line 2108
    goto case_12;
  }
#line 2114
  goto switch_default;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2084
  if (len % 4UL != 0UL) {
#line 2086
    return (0);
  }
#line 2088
  *count_out = len / 4UL;
#line 2089
  return (1);
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 2093
  if (len % 8UL != 0UL) {
#line 2095
    return (0);
  }
#line 2097
  *count_out = len / 8UL;
#line 2098
  return (1);
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 2106
  *count_out = max_b128_numbers(len, data);
  }
#line 2107
  return (1);
  case_12: /* CIL Label */ 
#line 2109
  *count_out = len;
#line 2110
  return (1);
  switch_default: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 2116
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2121 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint32_t parse_uint32(unsigned int len , uint8_t *data ) 
{ 
  uint32_t rv ;

  {
#line 2123
  rv = (uint32_t )((int )*(data + 0) & 127);
#line 2124
  if (len > 1U) {
#line 2125
    rv |= (uint32_t )((int )*(data + 1) & 127) << 7;
#line 2126
    if (len > 2U) {
#line 2127
      rv |= (uint32_t )((int )*(data + 2) & 127) << 14;
#line 2128
      if (len > 3U) {
#line 2129
        rv |= (uint32_t )((int )*(data + 3) & 127) << 21;
#line 2130
        if (len > 4U) {
#line 2131
          rv |= (uint32_t )*(data + 4) << 28;
        }
      }
    }
  }
#line 2135
  return (rv);
}
}
#line 2139 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint32_t parse_int32(unsigned int len , uint8_t *data ) 
{ 
  uint32_t __cil_tmp3 ;

  {
  {
#line 2141
  __cil_tmp3 = parse_uint32(len, data);
  }
#line 2141
  return (__cil_tmp3);
}
}
#line 2145 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static int32_t unzigzag32(uint32_t v ) 
{ 


  {
#line 2147
  if (v & 1U) {
#line 2148
    return ((int32_t )(- (v >> 1) - 1U));
  } else {
#line 2150
    return ((int32_t )(v >> 1));
  }
}
}
#line 2154 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint32_t parse_fixed_uint32(uint8_t *data ) 
{ 
  uint32_t t ;

  {
  {
#line 2158
  memcpy(& t, data, (unsigned long )4);
  }
#line 2159
  return (t);
}
}
#line 2169 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint64_t parse_uint64(unsigned int len , uint8_t *data ) 
{ 
  unsigned int shift ;
  unsigned int i ;
  uint64_t rv ;
  uint32_t __cil_tmp6 ;
  unsigned int __cil_tmp7 ;

  {
#line 2174
  if (len < 5U) {
    {
#line 2175
    __cil_tmp6 = parse_uint32(len, data);
    }
#line 2175
    return ((uint64_t )__cil_tmp6);
  }
#line 2176
  rv = (((uint64_t )((int )*(data + 0) & 127) | ((uint64_t )((int )*(data + 1) & 127) << 7)) | ((uint64_t )((int )*(data + 2) & 127) << 14)) | ((uint64_t )((int )*(data + 3) & 127) << 21);
#line 2180
  shift = (unsigned int )28;
#line 2181
  i = (unsigned int )4;
  {
#line 2181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2181
    if (! (i < len)) {
#line 2181
      goto while_break;
    }
#line 2182
    rv |= (uint64_t )((int )*(data + i) & 127) << shift;
#line 2183
    shift += (unsigned int )7;
#line 2181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2185
  return (rv);
}
}
#line 2189 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static int64_t unzigzag64(uint64_t v ) 
{ 


  {
#line 2191
  if (v & 1UL) {
#line 2192
    return ((int64_t )(- (v >> 1) - 1UL));
  } else {
#line 2194
    return ((int64_t )(v >> 1));
  }
}
}
#line 2198 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static uint64_t parse_fixed_uint64(uint8_t *data ) 
{ 
  uint64_t t ;

  {
  {
#line 2202
  memcpy(& t, data, (unsigned long )8);
  }
#line 2203
  return (t);
}
}
#line 2211 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_boolean(unsigned int len , uint8_t *data ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp4 ;

  {
#line 2214
  i = (unsigned int )0;
  {
#line 2214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2214
    if (! (i < len)) {
#line 2214
      goto while_break;
    }
#line 2215
    if ((int )*(data + i) & 127) {
#line 2216
      return (1);
    }
#line 2214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2217
  return (0);
}
}
#line 2221 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_required_member(ScannedMember *scanned_member , void *member ,
                                                ProtobufCAllocator *allocator , protobuf_c_boolean maybe_clear ) 
{ 
  unsigned int len ;
  uint8_t *data ;
  ProtobufCWireType wire_type ;
  uint32_t __cil_tmp8 ;
  uint32_t __cil_tmp9 ;
  uint32_t __cil_tmp10 ;
  int32_t __cil_tmp11 ;
  uint32_t __cil_tmp12 ;
  uint64_t __cil_tmp13 ;
  uint64_t __cil_tmp14 ;
  int64_t __cil_tmp15 ;
  uint64_t __cil_tmp16 ;
  protobuf_c_boolean __cil_tmp17 ;
  uint32_t __cil_tmp18 ;
  char **pstr ;
  unsigned int pref_len ;
  char const   *def ;
  void *__cil_tmp22 ;
  ProtobufCBinaryData *bd ;
  ProtobufCBinaryData *def_bd ;
  unsigned int pref_len___0 ;
  void *__cil_tmp26 ;
  ProtobufCMessage **pmessage ;
  ProtobufCMessage *subm ;
  ProtobufCMessage *def_mess ;
  protobuf_c_boolean merge_successful ;
  unsigned int pref_len___1 ;
  ProtobufCMessage *__cil_tmp32 ;
  protobuf_c_boolean __cil_tmp33 ;

  {
#line 2226
  len = (unsigned int )scanned_member->len;
#line 2227
  data = scanned_member->data;
#line 2228
  wire_type = (ProtobufCWireType )scanned_member->wire_type;
  {
#line 2231
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )0) {
#line 2231
    goto case_0;
  }
#line 2236
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )6) {
#line 2236
    goto case_6;
  }
#line 2241
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )1) {
#line 2241
    goto case_1;
  }
#line 2248
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )10) {
#line 2248
    goto case_10;
  }
#line 2248
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )7) {
#line 2248
    goto case_10;
  }
#line 2248
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )2) {
#line 2248
    goto case_10;
  }
#line 2254
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )8) {
#line 2254
    goto case_8;
  }
#line 2254
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )3) {
#line 2254
    goto case_8;
  }
#line 2259
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )4) {
#line 2259
    goto case_4;
  }
#line 2266
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )11) {
#line 2266
    goto case_11;
  }
#line 2266
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )9) {
#line 2266
    goto case_11;
  }
#line 2266
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )5) {
#line 2266
    goto case_11;
  }
#line 2271
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )12) {
#line 2271
    goto case_12;
  }
#line 2274
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )13) {
#line 2274
    goto case_13;
  }
#line 2279
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )14) {
#line 2279
    goto case_14;
  }
#line 2298
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )15) {
#line 2298
    goto case_15;
  }
#line 2324
  if ((unsigned int )(scanned_member->field)->type == (unsigned int )16) {
#line 2324
    goto case_16;
  }
#line 2230
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2232
  if ((unsigned int )wire_type != 0U) {
#line 2233
    return (0);
  }
  {
#line 2234
  *((uint32_t *)member) = parse_int32(len, data);
  }
#line 2235
  return (1);
  case_6: /* CIL Label */ 
#line 2237
  if ((unsigned int )wire_type != 0U) {
#line 2238
    return (0);
  }
  {
#line 2239
  *((uint32_t *)member) = parse_uint32(len, data);
  }
#line 2240
  return (1);
  case_1: /* CIL Label */ 
#line 2242
  if ((unsigned int )wire_type != 0U) {
#line 2243
    return (0);
  }
  {
#line 2244
  __cil_tmp10 = parse_uint32(len, data);
#line 2244
  __cil_tmp11 = unzigzag32(__cil_tmp10);
#line 2244
  *((int32_t *)member) = __cil_tmp11;
  }
#line 2245
  return (1);
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2249
  if ((unsigned int )wire_type != 5U) {
#line 2250
    return (0);
  }
  {
#line 2251
  *((uint32_t *)member) = parse_fixed_uint32(data);
  }
#line 2252
  return (1);
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 2255
  if ((unsigned int )wire_type != 0U) {
#line 2256
    return (0);
  }
  {
#line 2257
  *((uint64_t *)member) = parse_uint64(len, data);
  }
#line 2258
  return (1);
  case_4: /* CIL Label */ 
#line 2260
  if ((unsigned int )wire_type != 0U) {
#line 2261
    return (0);
  }
  {
#line 2262
  __cil_tmp14 = parse_uint64(len, data);
#line 2262
  __cil_tmp15 = unzigzag64(__cil_tmp14);
#line 2262
  *((int64_t *)member) = __cil_tmp15;
  }
#line 2263
  return (1);
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 2267
  if ((unsigned int )wire_type != 1U) {
#line 2268
    return (0);
  }
  {
#line 2269
  *((uint64_t *)member) = parse_fixed_uint64(data);
  }
#line 2270
  return (1);
  case_12: /* CIL Label */ 
  {
#line 2272
  *((protobuf_c_boolean *)member) = parse_boolean(len, data);
  }
#line 2273
  return (1);
  case_13: /* CIL Label */ 
#line 2275
  if ((unsigned int )wire_type != 0U) {
#line 2276
    return (0);
  }
  {
#line 2277
  *((uint32_t *)member) = parse_uint32(len, data);
  }
#line 2278
  return (1);
  case_14: /* CIL Label */ 
#line 2280
  pstr = member;
#line 2281
  pref_len = (unsigned int )scanned_member->length_prefix_len;
#line 2283
  if ((unsigned int )wire_type != 2U) {
#line 2284
    return (0);
  }
#line 2286
  if (*pstr != (void *)0) {
#line 2286
    if (maybe_clear) {
#line 2287
      def = (scanned_member->field)->default_value;
#line 2288
      if (*pstr != (void *)0) {
#line 2288
        if (*pstr != def) {
          {
#line 2289
          do_free(allocator, *pstr);
          }
        }
      }
    }
  }
  {
#line 2291
  *pstr = (char *)do_alloc(allocator, (size_t )((len - pref_len) + 1U));
  }
#line 2292
  if (*pstr == (void *)0) {
#line 2293
    return (0);
  }
  {
#line 2294
  memcpy(*pstr, data + pref_len, (unsigned long )(len - pref_len));
#line 2295
  *(*pstr + (len - pref_len)) = (char )0;
  }
#line 2296
  return (1);
  case_15: /* CIL Label */ 
#line 2299
  bd = member;
#line 2301
  pref_len___0 = (unsigned int )scanned_member->length_prefix_len;
#line 2303
  if ((unsigned int )wire_type != 2U) {
#line 2304
    return (0);
  }
#line 2306
  def_bd = (scanned_member->field)->default_value;
#line 2307
  if (bd->data != (void *)0) {
#line 2307
    if (maybe_clear) {
#line 2307
      if (def_bd == (void *)0) {
        {
        {
#line 2311
        do_free(allocator, bd->data);
        }
        }
      } else
#line 2307
      if (bd->data != def_bd->data) {
        {
        {
#line 2311
        do_free(allocator, bd->data);
        }
        }
      }
    }
  }
#line 2313
  if (len - pref_len___0 > 0U) {
    {
#line 2314
    bd->data = (uint8_t *)do_alloc(allocator, (size_t )(len - pref_len___0));
    }
#line 2315
    if (bd->data == (void *)0) {
#line 2316
      return (0);
    }
    {
#line 2317
    memcpy(bd->data, data + pref_len___0, (unsigned long )(len - pref_len___0));
    }
  } else {
#line 2319
    bd->data = (uint8_t *)((void *)0);
  }
#line 2321
  bd->len = (size_t )(len - pref_len___0);
#line 2322
  return (1);
  case_16: /* CIL Label */ 
#line 2325
  pmessage = member;
#line 2328
  merge_successful = 1;
#line 2329
  pref_len___1 = (unsigned int )scanned_member->length_prefix_len;
#line 2331
  if ((unsigned int )wire_type != 2U) {
#line 2332
    return (0);
  }
  {
#line 2334
  def_mess = (scanned_member->field)->default_value;
#line 2335
  subm = protobuf_c_message_unpack((scanned_member->field)->descriptor, allocator,
                                   (size_t )(len - pref_len___1), data + pref_len___1);
  }
#line 2340
  if (*pmessage != (void *)0) {
#line 2340
    if (maybe_clear) {
#line 2340
      if (*pmessage != def_mess) {
#line 2344
        if (subm != (void *)0) {
          {
#line 2345
          merge_successful = merge_messages(*pmessage, subm, allocator);
          }
        }
        {
#line 2347
        protobuf_c_message_free_unpacked(*pmessage, allocator);
        }
      }
    }
  }
#line 2349
  *pmessage = subm;
#line 2350
  if (subm == (void *)0) {
#line 2351
    return (0);
  } else
#line 2350
  if (! merge_successful) {
#line 2351
    return (0);
  }
#line 2352
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 2355
  return (0);
}
}
#line 2359 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_optional_member(ScannedMember *scanned_member , void *member ,
                                                ProtobufCMessage *message , ProtobufCAllocator *allocator ) 
{ 
  protobuf_c_boolean __cil_tmp5 ;

  {
  {
#line 2364
  __cil_tmp5 = parse_required_member(scanned_member, member, allocator, 1);
  }
#line 2364
  if (! __cil_tmp5) {
#line 2365
    return (0);
  }
#line 2366
  if ((scanned_member->field)->quantifier_offset != 0U) {
#line 2367
    *((protobuf_c_boolean *)((void *)((uint8_t *)message + (scanned_member->field)->quantifier_offset))) = 1;
  }
#line 2370
  return (1);
}
}
#line 2374 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_repeated_member(ScannedMember *scanned_member , void *member ,
                                                ProtobufCMessage *message , ProtobufCAllocator *allocator ) 
{ 
  ProtobufCFieldDescriptor *field ;
  size_t *p_n ;
  size_t siz ;
  size_t __cil_tmp8 ;
  char *array ;
  protobuf_c_boolean __cil_tmp10 ;

  {
  {
#line 2379
  field = scanned_member->field;
#line 2380
  p_n = (size_t *)((void *)((uint8_t *)message + field->quantifier_offset));
#line 2381
  __cil_tmp8 = sizeof_elt_in_repeated_array(field->type);
#line 2381
  siz = __cil_tmp8;
#line 2382
  array = *((char **)member);
#line 2384
  __cil_tmp10 = parse_required_member(scanned_member, array + siz * *p_n, allocator,
                                      0);
  }
#line 2384
  if (! __cil_tmp10) {
#line 2387
    return (0);
  }
#line 2389
  *p_n += (unsigned long )1;
#line 2390
  return (1);
}
}
#line 2394 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static unsigned int scan_varint(unsigned int len , uint8_t *data ) 
{ 
  unsigned int i ;
  unsigned int __cil_tmp4 ;

  {
#line 2397
  if (len > 10U) {
#line 2398
    len = (unsigned int )10;
  }
#line 2399
  i = (unsigned int )0;
  {
#line 2399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2399
    if (! (i < len)) {
#line 2399
      goto while_break;
    }
#line 2400
    if (((int )*(data + i) & 128) == 0) {
#line 2401
      goto while_break;
    }
#line 2399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2402
  if (i == len) {
#line 2403
    return ((unsigned int )0);
  }
#line 2404
  return (i + 1U);
}
}
#line 2408 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_packed_repeated_member(ScannedMember *scanned_member ,
                                                       void *member , ProtobufCMessage *message ) 
{ 
  ProtobufCFieldDescriptor *field ;
  size_t *p_n ;
  size_t siz ;
  size_t __cil_tmp7 ;
  void *array ;
  uint8_t *at ;
  size_t rem ;
  size_t count ;
  unsigned int i ;
  unsigned int s ;
  unsigned int __cil_tmp14 ;
  size_t __cil_tmp15 ;
  uint32_t __cil_tmp16 ;
  unsigned int s___0 ;
  unsigned int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  uint32_t __cil_tmp20 ;
  int32_t __cil_tmp21 ;
  unsigned int s___1 ;
  unsigned int __cil_tmp23 ;
  size_t __cil_tmp24 ;
  uint32_t __cil_tmp25 ;
  unsigned int s___2 ;
  unsigned int __cil_tmp27 ;
  size_t __cil_tmp28 ;
  uint64_t __cil_tmp29 ;
  int64_t __cil_tmp30 ;
  unsigned int s___3 ;
  unsigned int __cil_tmp32 ;
  size_t __cil_tmp33 ;
  uint64_t __cil_tmp34 ;
  unsigned int __cil_tmp35 ;
  int tmp ;

  {
  {
#line 2412
  field = scanned_member->field;
#line 2413
  p_n = (size_t *)((void *)((uint8_t *)message + field->quantifier_offset));
#line 2414
  __cil_tmp7 = sizeof_elt_in_repeated_array(field->type);
#line 2414
  siz = __cil_tmp7;
#line 2415
  array = *((uint8_t **)member) + siz * *p_n;
#line 2416
  at = scanned_member->data + (int )scanned_member->length_prefix_len;
#line 2417
  rem = scanned_member->len - (unsigned long )scanned_member->length_prefix_len;
#line 2418
  count = (size_t )0;
  }
  {
#line 2424
  if ((unsigned int )field->type == (unsigned int )10) {
#line 2424
    goto case_10;
  }
#line 2424
  if ((unsigned int )field->type == (unsigned int )7) {
#line 2424
    goto case_10;
  }
#line 2424
  if ((unsigned int )field->type == (unsigned int )2) {
#line 2424
    goto case_10;
  }
#line 2437
  if ((unsigned int )field->type == (unsigned int )11) {
#line 2437
    goto case_11;
  }
#line 2437
  if ((unsigned int )field->type == (unsigned int )9) {
#line 2437
    goto case_11;
  }
#line 2437
  if ((unsigned int )field->type == (unsigned int )5) {
#line 2437
    goto case_11;
  }
#line 2448
  if ((unsigned int )field->type == (unsigned int )0) {
#line 2448
    goto case_0;
  }
#line 2460
  if ((unsigned int )field->type == (unsigned int )1) {
#line 2460
    goto case_1;
  }
#line 2473
  if ((unsigned int )field->type == (unsigned int )6) {
#line 2473
    goto case_6;
  }
#line 2473
  if ((unsigned int )field->type == (unsigned int )13) {
#line 2473
    goto case_6;
  }
#line 2486
  if ((unsigned int )field->type == (unsigned int )4) {
#line 2486
    goto case_4;
  }
#line 2499
  if ((unsigned int )field->type == (unsigned int )8) {
#line 2499
    goto case_8;
  }
#line 2499
  if ((unsigned int )field->type == (unsigned int )3) {
#line 2499
    goto case_8;
  }
#line 2511
  if ((unsigned int )field->type == (unsigned int )12) {
#line 2511
    goto case_12;
  }
#line 2421
  goto switch_break;
  case_10: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2425
  count = (scanned_member->len - (unsigned long )scanned_member->length_prefix_len) / 4UL;
#line 2427
  goto no_unpacking_needed;
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 2438
  count = (scanned_member->len - (unsigned long )scanned_member->length_prefix_len) / 8UL;
#line 2440
  goto no_unpacking_needed;
  case_0: /* CIL Label */ 
  {
#line 2449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2449
    if (! (rem > 0UL)) {
#line 2449
      goto while_break;
    }
    {
#line 2450
    __cil_tmp14 = scan_varint((unsigned int )rem, at);
#line 2450
    s = __cil_tmp14;
    }
#line 2451
    if (s == 0U) {
#line 2453
      return (0);
    }
    {
#line 2455
    __cil_tmp16 = parse_int32(s, at);
    }
#line 2455
    __cil_tmp15 = count;
#line 2455
    count ++;
#line 2455
    *((int32_t *)array + __cil_tmp15) = (int32_t )__cil_tmp16;
#line 2456
    at += s;
#line 2457
    rem -= (unsigned long )s;
  }
  while_break: /* CIL Label */ ;
  }
#line 2459
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2461
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2461
    if (! (rem > 0UL)) {
#line 2461
      goto while_break___0;
    }
    {
#line 2462
    __cil_tmp18 = scan_varint((unsigned int )rem, at);
#line 2462
    s___0 = __cil_tmp18;
    }
#line 2463
    if (s___0 == 0U) {
#line 2465
      return (0);
    }
    {
#line 2467
    __cil_tmp20 = parse_uint32(s___0, at);
#line 2467
    __cil_tmp21 = unzigzag32(__cil_tmp20);
    }
#line 2467
    __cil_tmp19 = count;
#line 2467
    count ++;
#line 2467
    *((int32_t *)array + __cil_tmp19) = __cil_tmp21;
#line 2468
    at += s___0;
#line 2469
    rem -= (unsigned long )s___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2471
  goto switch_break;
  case_6: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 2474
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2474
    if (! (rem > 0UL)) {
#line 2474
      goto while_break___1;
    }
    {
#line 2475
    __cil_tmp23 = scan_varint((unsigned int )rem, at);
#line 2475
    s___1 = __cil_tmp23;
    }
#line 2476
    if (s___1 == 0U) {
#line 2478
      return (0);
    }
    {
#line 2480
    __cil_tmp24 = count;
#line 2480
    count ++;
#line 2480
    *((uint32_t *)array + __cil_tmp24) = parse_uint32(s___1, at);
#line 2481
    at += s___1;
#line 2482
    rem -= (unsigned long )s___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2484
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2487
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2487
    if (! (rem > 0UL)) {
#line 2487
      goto while_break___2;
    }
    {
#line 2488
    __cil_tmp27 = scan_varint((unsigned int )rem, at);
#line 2488
    s___2 = __cil_tmp27;
    }
#line 2489
    if (s___2 == 0U) {
#line 2491
      return (0);
    }
    {
#line 2493
    __cil_tmp29 = parse_uint64(s___2, at);
#line 2493
    __cil_tmp30 = unzigzag64(__cil_tmp29);
    }
#line 2493
    __cil_tmp28 = count;
#line 2493
    count ++;
#line 2493
    *((int64_t *)array + __cil_tmp28) = __cil_tmp30;
#line 2494
    at += s___2;
#line 2495
    rem -= (unsigned long )s___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2497
  goto switch_break;
  case_8: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 2500
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2500
    if (! (rem > 0UL)) {
#line 2500
      goto while_break___3;
    }
    {
#line 2501
    __cil_tmp32 = scan_varint((unsigned int )rem, at);
#line 2501
    s___3 = __cil_tmp32;
    }
#line 2502
    if (s___3 == 0U) {
#line 2504
      return (0);
    }
    {
#line 2506
    __cil_tmp34 = parse_uint64(s___3, at);
    }
#line 2506
    __cil_tmp33 = count;
#line 2506
    count ++;
#line 2506
    *((int64_t *)array + __cil_tmp33) = (int64_t )__cil_tmp34;
#line 2507
    at += s___3;
#line 2508
    rem -= (unsigned long )s___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2510
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2512
  count = rem;
#line 2513
  i = (unsigned int )0;
  {
#line 2513
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2513
    if (! ((unsigned long )i < count)) {
#line 2513
      goto while_break___4;
    }
#line 2514
    if ((int )*(at + i) > 1) {
#line 2516
      return (0);
    }
#line 2518
    *((protobuf_c_boolean *)array + i) = (protobuf_c_boolean )*(at + i);
#line 2513
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2520
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2524
  *p_n += count;
#line 2525
  return (1);
  no_unpacking_needed: 
  {
#line 2529
  memcpy(array, at, count * siz);
  }
#line 2530
  *p_n += count;
#line 2531
  return (1);
}
}
#line 2536 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean is_packable_type(ProtobufCType type ) 
{ 


  {
#line 2538
  return (((unsigned int )type != 14U && (unsigned int )type != 15U) && (unsigned int )type != 16U);
}
}
#line 2545 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static protobuf_c_boolean parse_member(ScannedMember *scanned_member , ProtobufCMessage *message ,
                                       ProtobufCAllocator *allocator ) 
{ 
  ProtobufCFieldDescriptor *field ;
  void *member ;
  ProtobufCMessageUnknownField *ufield ;
  unsigned int __cil_tmp7 ;
  void *__cil_tmp8 ;
  protobuf_c_boolean __cil_tmp9 ;
  protobuf_c_boolean __cil_tmp10 ;
  protobuf_c_boolean __cil_tmp11 ;
  protobuf_c_boolean __cil_tmp12 ;
  protobuf_c_boolean __cil_tmp13 ;
  int tmp ;

  {
#line 2549
  field = scanned_member->field;
#line 2552
  if (field == (void *)0) {
    {
#line 2553
    __cil_tmp7 = message->n_unknown_fields;
#line 2553
    (message->n_unknown_fields) ++;
#line 2553
    ufield = message->unknown_fields + __cil_tmp7;
#line 2556
    ufield->tag = scanned_member->tag;
#line 2557
    ufield->wire_type = (ProtobufCWireType )scanned_member->wire_type;
#line 2558
    ufield->len = scanned_member->len;
#line 2559
    ufield->data = (uint8_t *)do_alloc(allocator, scanned_member->len);
    }
#line 2560
    if (ufield->data == (void *)0) {
#line 2561
      return (0);
    }
    {
#line 2562
    memcpy(ufield->data, scanned_member->data, ufield->len);
    }
#line 2563
    return (1);
  }
#line 2565
  member = (char *)message + field->offset;
  {
#line 2567
  if ((unsigned int )field->label == (unsigned int )0) {
#line 2567
    goto case_0;
  }
#line 2570
  if ((unsigned int )field->label == (unsigned int )1) {
#line 2570
    goto case_1;
  }
#line 2573
  if ((unsigned int )field->label == (unsigned int )2) {
#line 2573
    goto case_2;
  }
#line 2566
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2568
  __cil_tmp9 = parse_required_member(scanned_member, member, allocator, 1);
  }
#line 2568
  return (__cil_tmp9);
  case_1: /* CIL Label */ 
  {
#line 2571
  __cil_tmp10 = parse_optional_member(scanned_member, member, message, allocator);
  }
#line 2571
  return (__cil_tmp10);
  case_2: /* CIL Label */ 
  {
#line 2574
  __cil_tmp11 = is_packable_type(field->type);
  }
#line 2574
  if ((int )scanned_member->wire_type == 2) {
#line 2574
    if (0U != (field->flags & 1U)) {
      {
      {
#line 2579
      __cil_tmp12 = parse_packed_repeated_member(scanned_member, member, message);
      }
      }
#line 2579
      return (__cil_tmp12);
    } else
#line 2574
    if (__cil_tmp11) {
      {
      {
#line 2579
      __cil_tmp12 = parse_packed_repeated_member(scanned_member, member, message);
      }
      }
#line 2579
      return (__cil_tmp12);
    } else {
      {
      {
#line 2582
      __cil_tmp13 = parse_repeated_member(scanned_member, member, message, allocator);
      }
      }
#line 2582
      return (__cil_tmp13);
    }
  } else {
    {
    {
#line 2582
    __cil_tmp13 = parse_repeated_member(scanned_member, member, message, allocator);
    }
    }
#line 2582
    return (__cil_tmp13);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2588
  return (0);
}
}
#line 2599 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
static void message_init_generic(ProtobufCMessageDescriptor *desc , ProtobufCMessage *message ) 
{ 
  unsigned int i ;
  void *field ;
  void const   *dv ;
  unsigned int __cil_tmp6 ;

  {
  {
#line 2604
  memset(message, 0, desc->sizeof_message);
#line 2605
  message->descriptor = desc;
#line 2606
  i = (unsigned int )0;
  }
  {
#line 2606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2606
    if (! (i < desc->n_fields)) {
#line 2606
      goto while_break;
    }
#line 2607
    if ((desc->fields + i)->default_value != (void *)0) {
#line 2607
      if ((unsigned int )(desc->fields + i)->label != 2U) {
#line 2610
        field = (void *)((uint8_t *)message + (desc->fields + i)->offset);
#line 2612
        dv = (desc->fields + i)->default_value;
        {
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )13) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )10) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )7) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )6) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )2) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )1) {
#line 2621
          goto case_13;
        }
#line 2621
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )0) {
#line 2621
          goto case_13;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )11) {
#line 2629
          goto case_11;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )9) {
#line 2629
          goto case_11;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )8) {
#line 2629
          goto case_11;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )5) {
#line 2629
          goto case_11;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )4) {
#line 2629
          goto case_11;
        }
#line 2629
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )3) {
#line 2629
          goto case_11;
        }
#line 2632
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )12) {
#line 2632
          goto case_12;
        }
#line 2635
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )15) {
#line 2635
          goto case_15;
        }
#line 2640
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )16) {
#line 2640
          goto case_16;
        }
#line 2640
        if ((unsigned int )(desc->fields + i)->type == (unsigned int )14) {
#line 2640
          goto case_16;
        }
#line 2614
        goto switch_break;
        case_13: /* CIL Label */ 
        case_10: /* CIL Label */ 
        case_7: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
        {
#line 2622
        memcpy(field, dv, (unsigned long )4);
        }
#line 2623
        goto switch_break;
        case_11: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
        {
#line 2630
        memcpy(field, dv, (unsigned long )8);
        }
#line 2631
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 2633
        memcpy(field, dv, sizeof(protobuf_c_boolean ));
        }
#line 2634
        goto switch_break;
        case_15: /* CIL Label */ 
        {
#line 2636
        memcpy(field, dv, sizeof(ProtobufCBinaryData ));
        }
#line 2637
        goto switch_break;
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
#line 2645
        *((void const   **)field) = dv;
#line 2646
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 2606
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2682 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCMessage *protobuf_c_message_unpack(ProtobufCMessageDescriptor *desc , ProtobufCAllocator *allocator ,
                                            size_t len , uint8_t *data ) 
{ 
  ProtobufCMessage *rv ;
  size_t rem ;
  uint8_t *at ;
  ProtobufCFieldDescriptor *last_field ;
  ScannedMember first_member_slab[16] ;
  ScannedMember *scanned_member_slabs[23] ;
  unsigned int which_slab ;
  unsigned int in_slab_index ;
  size_t n_unknown ;
  unsigned int f ;
  unsigned int j ;
  unsigned int i_slab ;
  unsigned int last_field_index ;
  unsigned int required_fields_bitmap_len ;
  unsigned char required_fields_bitmap_stack[16] ;
  unsigned char *required_fields_bitmap ;
  protobuf_c_boolean required_fields_bitmap_alloced ;
  int tmp ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  uint32_t tag ;
  ProtobufCWireType wire_type ;
  size_t used ;
  size_t __cil_tmp28 ;
  ProtobufCFieldDescriptor *field ;
  ScannedMember tmp___0 ;
  int field_index ;
  int __cil_tmp32 ;
  size_t __cil_tmp33 ;
  unsigned int max_len ;
  size_t tmp___40 ;
  unsigned int i ;
  unsigned int __cil_tmp37 ;
  size_t pref_len ;
  uint32_t __cil_tmp39 ;
  size_t size ;
  unsigned int __cil_tmp41 ;
  void *__cil_tmp42 ;
  unsigned int __cil_tmp43 ;
  size_t *n ;
  protobuf_c_boolean __cil_tmp45 ;
  size_t count ;
  protobuf_c_boolean __cil_tmp47 ;
  ProtobufCFieldDescriptor *field___0 ;
  size_t siz ;
  size_t __cil_tmp50 ;
  size_t *n_ptr ;
  unsigned int n___0 ;
  void *a ;
  int tmp___41 ;
  void *__cil_tmp55 ;
  unsigned int __cil_tmp56 ;
  unsigned int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  unsigned int __cil_tmp59 ;
  unsigned int __cil_tmp60 ;
  void *__cil_tmp61 ;
  unsigned int max ;
  unsigned int tmp___42 ;
  ScannedMember *slab ;
  unsigned int j___42 ;
  protobuf_c_boolean __cil_tmp66 ;
  unsigned int __cil_tmp67 ;
  unsigned int __cil_tmp68 ;
  unsigned int __cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int __cil_tmp71 ;

  {
#line 2687
  rem = len;
#line 2688
  at = data;
#line 2689
  last_field = desc->fields + 0;
#line 2700
  which_slab = (unsigned int )0;
#line 2701
  in_slab_index = (unsigned int )0;
#line 2702
  n_unknown = (size_t )0;
#line 2706
  last_field_index = (unsigned int )0;
#line 2709
  required_fields_bitmap = (unsigned char *)required_fields_bitmap_stack;
#line 2710
  required_fields_bitmap_alloced = 0;
#line 2714
  if (allocator == (void *)0) {
#line 2715
    allocator = & protobuf_c__allocator;
  }
  {
#line 2717
  rv = (ProtobufCMessage *)do_alloc(allocator, desc->sizeof_message);
  }
#line 2718
  if (! rv) {
#line 2719
    return ((ProtobufCMessage *)((void *)0));
  }
#line 2720
  scanned_member_slabs[0] = (ScannedMember *)first_member_slab;
#line 2722
  required_fields_bitmap_len = (desc->n_fields + 7U) / 8U;
#line 2723
  if ((unsigned long )required_fields_bitmap_len > sizeof(required_fields_bitmap_stack)) {
    {
#line 2724
    required_fields_bitmap = (unsigned char *)do_alloc(allocator, (size_t )required_fields_bitmap_len);
    }
#line 2725
    if (! required_fields_bitmap) {
      {
#line 2726
      do_free(allocator, rv);
      }
#line 2727
      return ((ProtobufCMessage *)((void *)0));
    }
#line 2729
    required_fields_bitmap_alloced = 1;
  }
  {
#line 2731
  memset(required_fields_bitmap, 0, (unsigned long )required_fields_bitmap_len);
  }
#line 2739
  if (desc->message_init != (void *)0) {
    {
#line 2740
    protobuf_c_message_init(desc, rv);
    }
  } else {
    {
#line 2742
    message_init_generic(desc, rv);
    }
  }
  {
#line 2744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2744
    if (! (rem > 0UL)) {
#line 2744
      goto while_break;
    }
    {
#line 2747
    __cil_tmp28 = parse_tag_and_wiretype(rem, at, & tag, & wire_type);
#line 2747
    used = __cil_tmp28;
    }
#line 2751
    if (used == 0UL) {
#line 2754
      goto error_cleanup_during_scan;
    }
#line 2760
    if (last_field == (void *)0) {
      _L: /* CIL Label */ 
      {
#line 2762
      __cil_tmp32 = int_range_lookup(desc->n_field_ranges, desc->field_ranges, (int )tag);
#line 2762
      field_index = __cil_tmp32;
      }
#line 2766
      if (field_index < 0) {
#line 2767
        field = (ProtobufCFieldDescriptor *)((void *)0);
#line 2768
        n_unknown ++;
      } else {
#line 2770
        field = desc->fields + field_index;
#line 2771
        last_field = field;
#line 2772
        last_field_index = (unsigned int )field_index;
      }
    } else
#line 2760
    if (last_field->id != tag) {
#line 2760
      goto _L;
    } else {
#line 2775
      field = last_field;
    }
#line 2778
    if (field != (void *)0) {
#line 2778
      if ((unsigned int )field->label == 0U) {
#line 2779
        *(required_fields_bitmap + last_field_index / 8U) |= 1 << last_field_index % 8U;
      }
    }
#line 2781
    at += used;
#line 2782
    rem -= used;
#line 2783
    tmp___0.tag = tag;
#line 2784
    tmp___0.wire_type = (uint8_t )wire_type;
#line 2785
    tmp___0.field = field;
#line 2786
    tmp___0.data = at;
#line 2787
    tmp___0.length_prefix_len = (uint8_t )0;
    {
#line 2790
    if ((unsigned int )wire_type == (unsigned int )0) {
#line 2790
      goto case_0;
    }
#line 2805
    if ((unsigned int )wire_type == (unsigned int )1) {
#line 2805
      goto case_1;
    }
#line 2813
    if ((unsigned int )wire_type == (unsigned int )2) {
#line 2813
      goto case_2;
    }
#line 2824
    if ((unsigned int )wire_type == (unsigned int )5) {
#line 2824
      goto case_5;
    }
#line 2832
    goto switch_default;
    case_0: /* CIL Label */ 
#line 2791
    if (rem < 10UL) {
#line 2791
      tmp___40 = rem;
    } else {
#line 2791
      tmp___40 = (unsigned long )10;
    }
#line 2791
    max_len = (unsigned int )tmp___40;
#line 2794
    i = (unsigned int )0;
    {
#line 2794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2794
      if (! (i < max_len)) {
#line 2794
        goto while_break___0;
      }
#line 2795
      if (((int )*(at + i) & 128) == 0) {
#line 2796
        goto while_break___0;
      }
#line 2794
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2797
    if (i == max_len) {
#line 2800
      goto error_cleanup_during_scan;
    }
#line 2802
    tmp___0.len = (size_t )(i + 1U);
#line 2803
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2806
    if (rem < 8UL) {
#line 2809
      goto error_cleanup_during_scan;
    }
#line 2811
    tmp___0.len = (size_t )8;
#line 2812
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2816
    __cil_tmp39 = scan_length_prefixed_data(rem, at, & pref_len);
#line 2816
    tmp___0.len = (size_t )__cil_tmp39;
    }
#line 2817
    if (tmp___0.len == 0UL) {
#line 2819
      goto error_cleanup_during_scan;
    }
#line 2821
    tmp___0.length_prefix_len = (uint8_t )pref_len;
#line 2822
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2825
    if (rem < 4UL) {
#line 2828
      goto error_cleanup_during_scan;
    }
#line 2830
    tmp___0.len = (size_t )4;
#line 2831
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2835
    goto error_cleanup_during_scan;
    switch_break: /* CIL Label */ ;
    }
#line 2838
    if (in_slab_index == 1U << (which_slab + 4U)) {
#line 2843
      in_slab_index = (unsigned int )0;
#line 2844
      if ((unsigned long )which_slab == ((sizeof(unsigned int ) * 8UL - 1UL) - 5UL) - 4UL) {
#line 2846
        goto error_cleanup_during_scan;
      }
      {
#line 2848
      which_slab ++;
#line 2849
      size = sizeof(ScannedMember ) << (which_slab + 4U);
#line 2851
      scanned_member_slabs[which_slab] = (ScannedMember *)do_alloc(allocator, size);
      }
#line 2852
      if (scanned_member_slabs[which_slab] == (void *)0) {
#line 2853
        goto error_cleanup_during_scan;
      }
    }
#line 2855
    __cil_tmp43 = in_slab_index;
#line 2855
    in_slab_index ++;
#line 2855
    *(scanned_member_slabs[which_slab] + __cil_tmp43) = tmp___0;
#line 2857
    if (field != (void *)0) {
#line 2857
      if ((unsigned int )field->label == 2U) {
        {
#line 2858
        n = (size_t *)((void *)((uint8_t *)rv + field->quantifier_offset));
#line 2860
        __cil_tmp45 = is_packable_type(field->type);
        }
#line 2860
        if ((unsigned int )wire_type == 2U) {
#line 2860
          if (0U != (field->flags & 1U)) {
            _L___41: /* CIL Label */ 
            {
#line 2865
            __cil_tmp47 = count_packed_elements(field->type, tmp___0.len - (unsigned long )tmp___0.length_prefix_len,
                                                tmp___0.data + (int )tmp___0.length_prefix_len,
                                                & count);
            }
#line 2865
            if (! __cil_tmp47) {
#line 2873
              goto error_cleanup_during_scan;
            }
#line 2875
            *n += count;
          } else
#line 2860
          if (__cil_tmp45) {
#line 2860
            goto _L___41;
          } else {
#line 2877
            *n += (unsigned long )1;
          }
        } else {
#line 2877
          *n += (unsigned long )1;
        }
      }
    }
#line 2881
    at += tmp___0.len;
#line 2882
    rem -= tmp___0.len;
  }
  while_break: /* CIL Label */ ;
  }
#line 2886
  f = (unsigned int )0;
  {
#line 2886
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2886
    if (! (f < desc->n_fields)) {
#line 2886
      goto while_break___1;
    }
#line 2887
    field___0 = desc->fields + f;
#line 2888
    if ((unsigned int )field___0->label == 2U) {
      {
#line 2889
      __cil_tmp50 = sizeof_elt_in_repeated_array(field___0->type);
#line 2889
      siz = __cil_tmp50;
#line 2891
      n_ptr = (size_t *)((void *)((uint8_t *)rv + field___0->quantifier_offset));
      }
#line 2894
      if (*n_ptr != 0UL) {
        {
#line 2895
        n___0 = (unsigned int )*n_ptr;
#line 2897
        *n_ptr = (size_t )0;
#line 2906
        a = do_alloc(allocator, siz * (unsigned long )n___0);
        }
#line 2907
        if (! a) {
#line 2908
          f ++;
          {
#line 2908
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2908
            if (! (f < desc->n_fields)) {
#line 2908
              goto while_break___2;
            }
#line 2908
            field___0 = desc->fields + f;
#line 2908
            if ((unsigned int )field___0->label == 2U) {
#line 2908
              *((size_t *)((void *)((uint8_t *)rv + field___0->quantifier_offset))) = (size_t )0;
            }
#line 2908
            f ++;
          }
          while_break___2: /* CIL Label */ ;
          }

#line 2909
          goto error_cleanup;
        }
#line 2911
        *((void **)((void *)((uint8_t *)rv + field___0->offset))) = a;
      }
    } else
#line 2913
    if ((unsigned int )field___0->label == 0U) {
#line 2914
      if (field___0->default_value == (void *)0) {
#line 2914
        if (! ((int )*(required_fields_bitmap + f / 8U) & (1 << f % 8U))) {
#line 2917
          f ++;
          {
#line 2917
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2917
            if (! (f < desc->n_fields)) {
#line 2917
              goto while_break___3;
            }
#line 2917
            field___0 = desc->fields + f;
#line 2917
            if ((unsigned int )field___0->label == 2U) {
#line 2917
              *((size_t *)((void *)((uint8_t *)rv + field___0->quantifier_offset))) = (size_t )0;
            }
#line 2917
            f ++;
          }
          while_break___3: /* CIL Label */ ;
          }

#line 2920
          goto error_cleanup;
        }
      }
    }
#line 2886
    f ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2927
  if (n_unknown) {
    {
#line 2928
    rv->unknown_fields = (ProtobufCMessageUnknownField *)do_alloc(allocator, n_unknown * sizeof(ProtobufCMessageUnknownField ));
    }
#line 2930
    if (rv->unknown_fields == (void *)0) {
#line 2931
      goto error_cleanup;
    }
  }
#line 2935
  i_slab = (unsigned int )0;
  {
#line 2935
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2935
    if (! (i_slab <= which_slab)) {
#line 2935
      goto while_break___4;
    }
#line 2936
    if (i_slab == which_slab) {
#line 2936
      tmp___42 = in_slab_index;
    } else {
#line 2936
      tmp___42 = 1U << (i_slab + 4U);
    }
#line 2936
    max = tmp___42;
#line 2938
    slab = scanned_member_slabs[i_slab];
#line 2941
    j___42 = (unsigned int )0;
    {
#line 2941
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2941
      if (! (j___42 < max)) {
#line 2941
        goto while_break___5;
      }
      {
#line 2942
      __cil_tmp66 = parse_member(slab + j___42, rv, allocator);
      }
#line 2942
      if (! __cil_tmp66) {
#line 2946
        goto error_cleanup;
      }
#line 2941
      j___42 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 2935
    i_slab ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2952
  j = (unsigned int )1;
  {
#line 2952
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2952
    if (! (j <= which_slab)) {
#line 2952
      goto while_break___6;
    }
    {
#line 2953
    do_free(allocator, scanned_member_slabs[j]);
    }
#line 2952
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2954
  if (required_fields_bitmap_alloced) {
    {
#line 2955
    do_free(allocator, required_fields_bitmap);
    }
  }
#line 2956
  return (rv);
  error_cleanup: 
  {
#line 2959
  protobuf_c_message_free_unpacked(rv, allocator);
  }
#line 2960
  j = (unsigned int )1;
  {
#line 2960
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2960
    if (! (j <= which_slab)) {
#line 2960
      goto while_break___7;
    }
    {
#line 2961
    do_free(allocator, scanned_member_slabs[j]);
    }
#line 2960
    j ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 2962
  if (required_fields_bitmap_alloced) {
    {
#line 2963
    do_free(allocator, required_fields_bitmap);
    }
  }
#line 2964
  return ((ProtobufCMessage *)((void *)0));
  error_cleanup_during_scan: 
  {
#line 2967
  do_free(allocator, rv);
  }
#line 2968
  j = (unsigned int )1;
  {
#line 2968
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 2968
    if (! (j <= which_slab)) {
#line 2968
      goto while_break___8;
    }
    {
#line 2969
    do_free(allocator, scanned_member_slabs[j]);
    }
#line 2968
    j ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 2970
  if (required_fields_bitmap_alloced) {
    {
#line 2971
    do_free(allocator, required_fields_bitmap);
    }
  }
#line 2972
  return ((ProtobufCMessage *)((void *)0));
}
}
#line 2976 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_message_free_unpacked(ProtobufCMessage *message , ProtobufCAllocator *allocator ) 
{ 
  ProtobufCMessageDescriptor *desc ;
  unsigned int f ;
  int tmp ;
  size_t n ;
  void *arr ;
  unsigned int i ;
  unsigned int __cil_tmp9 ;
  unsigned int i___0 ;
  unsigned int __cil_tmp11 ;
  unsigned int i___1 ;
  unsigned int __cil_tmp13 ;
  char *str ;
  void *data ;
  ProtobufCBinaryData *default_bd ;
  ProtobufCMessage *sm ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;

  {
#line 2979
  desc = message->descriptor;
#line 2983
  if (allocator == (void *)0) {
#line 2984
    allocator = & protobuf_c__allocator;
  }
#line 2985
  message->descriptor = (ProtobufCMessageDescriptor *)((void *)0);
#line 2986
  f = (unsigned int )0;
  {
#line 2986
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2986
    if (! (f < desc->n_fields)) {
#line 2986
      goto while_break;
    }
#line 2987
    if ((unsigned int )(desc->fields + f)->label == 2U) {
#line 2988
      n = *((size_t *)((void *)((uint8_t *)message + (desc->fields + f)->quantifier_offset)));
#line 2991
      arr = *((void **)((void *)((uint8_t *)message + (desc->fields + f)->offset)));
#line 2995
      if ((unsigned int )(desc->fields + f)->type == 14U) {
#line 2997
        i = (unsigned int )0;
        {
#line 2997
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2997
          if (! ((unsigned long )i < n)) {
#line 2997
            goto while_break___0;
          }
          {
#line 2998
          do_free(allocator, *((char **)arr + i));
          }
#line 2997
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 2999
      if ((unsigned int )(desc->fields + f)->type == 15U) {
#line 3001
        i___0 = (unsigned int )0;
        {
#line 3001
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3001
          if (! ((unsigned long )i___0 < n)) {
#line 3001
            goto while_break___1;
          }
          {
#line 3002
          do_free(allocator, ((ProtobufCBinaryData *)arr + i___0)->data);
          }
#line 3001
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 3003
      if ((unsigned int )(desc->fields + f)->type == 16U) {
#line 3005
        i___1 = (unsigned int )0;
        {
#line 3005
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3005
          if (! ((unsigned long )i___1 < n)) {
#line 3005
            goto while_break___2;
          }
          {
#line 3006
          protobuf_c_message_free_unpacked(*((ProtobufCMessage **)arr + i___1), allocator);
          }
#line 3005
          i___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 3011
      if (arr != (void *)0) {
        {
#line 3012
        do_free(allocator, arr);
        }
      }
    } else
#line 3013
    if ((unsigned int )(desc->fields + f)->type == 14U) {
#line 3014
      str = *((char **)((void *)((uint8_t *)message + (desc->fields + f)->offset)));
#line 3017
      if (str) {
#line 3017
        if (str != (desc->fields + f)->default_value) {
          {
#line 3018
          do_free(allocator, str);
          }
        }
      }
    } else
#line 3019
    if ((unsigned int )(desc->fields + f)->type == 15U) {
#line 3020
      data = ((ProtobufCBinaryData *)((void *)((uint8_t *)message + (desc->fields + f)->offset)))->data;
#line 3024
      default_bd = (desc->fields + f)->default_value;
#line 3025
      if (data != (void *)0) {
#line 3025
        if (default_bd == (void *)0) {
          {
          {
#line 3029
          do_free(allocator, data);
          }
          }
        } else
#line 3025
        if (default_bd->data != data) {
          {
          {
#line 3029
          do_free(allocator, data);
          }
          }
        }
      }
    } else
#line 3031
    if ((unsigned int )(desc->fields + f)->type == 16U) {
#line 3034
      sm = *((ProtobufCMessage **)((void *)((uint8_t *)message + (desc->fields + f)->offset)));
#line 3036
      if (sm) {
#line 3036
        if (sm != (desc->fields + f)->default_value) {
          {
#line 3037
          protobuf_c_message_free_unpacked(sm, allocator);
          }
        }
      }
    }
#line 2986
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3041
  f = (unsigned int )0;
  {
#line 3041
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3041
    if (! (f < message->n_unknown_fields)) {
#line 3041
      goto while_break___3;
    }
    {
#line 3042
    do_free(allocator, (message->unknown_fields + f)->data);
    }
#line 3041
    f ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3043
  if (message->unknown_fields != (void *)0) {
    {
#line 3044
    do_free(allocator, message->unknown_fields);
    }
  }
  {
#line 3046
  do_free(allocator, message);
  }
  return;
}
}
#line 3050 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_message_init(ProtobufCMessageDescriptor *descriptor , void *message ) 
{ 


  {
  {
#line 3053
  (*(descriptor->message_init))((ProtobufCMessage *)message);
  }
  return;
}
}
#line 3057 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
protobuf_c_boolean protobuf_c_message_check(ProtobufCMessage *message ) 
{ 
  unsigned int i ;
  ProtobufCFieldDescriptor *f ;
  ProtobufCType type ;
  ProtobufCLabel label ;
  void *field ;
  size_t *quantity ;
  ProtobufCMessage **submessage ;
  unsigned int j ;
  protobuf_c_boolean __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  char **string ;
  unsigned int j___0 ;
  unsigned int __cil_tmp14 ;
  ProtobufCBinaryData *bd ;
  unsigned int j___1 ;
  unsigned int __cil_tmp17 ;
  ProtobufCMessage *submessage___0 ;
  protobuf_c_boolean __cil_tmp19 ;
  char *string___0 ;
  protobuf_c_boolean *has ;
  ProtobufCBinaryData *bd___0 ;
  unsigned int __cil_tmp23 ;

  {
#line 3061
  if (! message) {
#line 3065
    return (0);
  } else
#line 3061
  if (! message->descriptor) {
#line 3065
    return (0);
  } else
#line 3061
  if ((message->descriptor)->magic != 682290937U) {
#line 3065
    return (0);
  }
#line 3068
  i = (unsigned int )0;
  {
#line 3068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3068
    if (! (i < (message->descriptor)->n_fields)) {
#line 3068
      goto while_break;
    }
#line 3069
    f = (message->descriptor)->fields + i;
#line 3070
    type = f->type;
#line 3071
    label = f->label;
#line 3072
    field = (void *)((uint8_t *)message + f->offset);
#line 3074
    if ((unsigned int )label == 2U) {
#line 3075
      quantity = (void *)((uint8_t *)message + f->quantifier_offset);
#line 3077
      if (*((void **)field) == (void *)0) {
#line 3077
        if (*quantity > 0UL) {
#line 3078
          return (0);
        }
      }
#line 3081
      if ((unsigned int )type == 16U) {
#line 3082
        submessage = *((ProtobufCMessage ***)field);
#line 3084
        j = (unsigned int )0;
        {
#line 3084
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3084
          if (! ((unsigned long )j < *quantity)) {
#line 3084
            goto while_break___0;
          }
          {
#line 3085
          __cil_tmp10 = protobuf_c_message_check(*(submessage + j));
          }
#line 3085
          if (! __cil_tmp10) {
#line 3086
            return (0);
          }
#line 3084
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 3088
      if ((unsigned int )type == 14U) {
#line 3089
        string = *((char ***)field);
#line 3091
        j___0 = (unsigned int )0;
        {
#line 3091
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3091
          if (! ((unsigned long )j___0 < *quantity)) {
#line 3091
            goto while_break___1;
          }
#line 3092
          if (! *(string + j___0)) {
#line 3093
            return (0);
          }
#line 3091
          j___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 3095
      if ((unsigned int )type == 15U) {
#line 3096
        bd = *((ProtobufCBinaryData **)field);
#line 3098
        j___1 = (unsigned int )0;
        {
#line 3098
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3098
          if (! ((unsigned long )j___1 < *quantity)) {
#line 3098
            goto while_break___2;
          }
#line 3099
          if ((bd + j___1)->data == (void *)0) {
#line 3099
            if ((bd + j___1)->len > 0UL) {
#line 3100
              return (0);
            }
          }
#line 3098
          j___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else
#line 3106
    if ((unsigned int )type == 16U) {
#line 3107
      submessage___0 = *((ProtobufCMessage **)field);
#line 3108
      if (submessage___0 != (void *)0) {
        _L: /* CIL Label */ 
        {
#line 3109
        __cil_tmp19 = protobuf_c_message_check(submessage___0);
        }
#line 3109
        if (! __cil_tmp19) {
#line 3110
          return (0);
        }
      } else
#line 3108
      if ((unsigned int )label == 0U) {
#line 3108
        goto _L;
      }
    } else
#line 3112
    if ((unsigned int )type == 14U) {
#line 3113
      string___0 = *((char **)field);
#line 3114
      if (string___0 == (void *)0) {
#line 3114
        if ((unsigned int )label == 0U) {
#line 3115
          return (0);
        }
      }
    } else
#line 3116
    if ((unsigned int )type == 15U) {
#line 3117
      has = (void *)((uint8_t *)message + f->quantifier_offset);
#line 3118
      bd___0 = field;
#line 3119
      if ((unsigned int )label == 0U) {
        _L___43: /* CIL Label */ 
#line 3120
        if (bd___0->data == (void *)0) {
#line 3120
          if (bd___0->len > 0UL) {
#line 3121
            return (0);
          }
        }
      } else
#line 3119
      if (*has == 1) {
#line 3119
        goto _L___43;
      }
    }
#line 3068
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3127
  return (1);
}
}
#line 3137 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_service_invoke_internal(ProtobufCService *service , unsigned int method_index ,
                                        ProtobufCMessage *input , ProtobufCClosure closure ,
                                        void *closure_data ) 
{ 
  GenericHandler *handlers ;
  GenericHandler handler ;
  int tmp ;

  {
  {
#line 3157
  handlers = (GenericHandler *)(service + 1);
#line 3163
  handler = *(handlers + method_index);
#line 3164
  (*handler)(service, input, closure, closure_data);
  }
  return;
}
}
#line 3168 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_service_generated_init(ProtobufCService *service , ProtobufCServiceDescriptor *descriptor ,
                                       ProtobufCServiceDestroy destroy ) 
{ 
  int tmp ;

  {
  {
#line 3173
  service->descriptor = descriptor;
#line 3174
  service->destroy = destroy;
#line 3175
  service->invoke = & protobuf_c_service_invoke_internal;
#line 3176
  memset(service + 1, 0, (unsigned long )descriptor->n_methods * sizeof(GenericHandler ));
  }
  return;
}
}
#line 3179 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
void protobuf_c_service_destroy(ProtobufCService *service ) 
{ 


  {
  {
#line 3181
  (*(service->destroy))(service);
  }
  return;
}
}
#line 3187 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCEnumValue *protobuf_c_enum_descriptor_get_value_by_name(ProtobufCEnumDescriptor *desc ,
                                                                 char const   *name ) 
{ 
  unsigned int start___0 ;
  unsigned int count ;
  unsigned int mid ;
  int rv ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 3190
  start___0 = (unsigned int )0;
#line 3191
  count = desc->n_value_names;
  {
#line 3193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3193
    if (! (count > 1U)) {
#line 3193
      goto while_break;
    }
    {
#line 3194
    mid = start___0 + count / 2U;
#line 3195
    __cil_tmp7 = strcmp((desc->values_by_name + mid)->name, name);
#line 3195
    rv = __cil_tmp7;
    }
#line 3196
    if (rv == 0) {
#line 3197
      return (desc->values + (desc->values_by_name + mid)->index);
    } else
#line 3198
    if (rv < 0) {
#line 3199
      count = (start___0 + count) - (mid + 1U);
#line 3200
      start___0 = mid + 1U;
    } else {
#line 3202
      count = mid - start___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3204
  if (count == 0U) {
#line 3205
    return ((ProtobufCEnumValue *)((void *)0));
  }
  {
#line 3206
  __cil_tmp8 = strcmp((desc->values_by_name + start___0)->name, name);
  }
#line 3206
  if (__cil_tmp8 == 0) {
#line 3207
    return (desc->values + (desc->values_by_name + start___0)->index);
  }
#line 3208
  return ((ProtobufCEnumValue *)((void *)0));
}
}
#line 3212 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCEnumValue *protobuf_c_enum_descriptor_get_value(ProtobufCEnumDescriptor *desc ,
                                                         int value ) 
{ 
  int rv ;
  int __cil_tmp4 ;

  {
  {
#line 3215
  __cil_tmp4 = int_range_lookup(desc->n_value_ranges, desc->value_ranges, value);
#line 3215
  rv = __cil_tmp4;
  }
#line 3216
  if (rv < 0) {
#line 3217
    return ((ProtobufCEnumValue *)((void *)0));
  }
#line 3218
  return (desc->values + rv);
}
}
#line 3222 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCFieldDescriptor *protobuf_c_message_descriptor_get_field_by_name(ProtobufCMessageDescriptor *desc ,
                                                                          char const   *name ) 
{ 
  unsigned int start___0 ;
  unsigned int count ;
  ProtobufCFieldDescriptor *field ;
  unsigned int mid ;
  int rv ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 3225
  start___0 = (unsigned int )0;
#line 3226
  count = desc->n_fields;
  {
#line 3229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3229
    if (! (count > 1U)) {
#line 3229
      goto while_break;
    }
    {
#line 3230
    mid = start___0 + count / 2U;
#line 3232
    field = desc->fields + *(desc->fields_sorted_by_name + mid);
#line 3233
    rv = strcmp(field->name, name);
    }
#line 3234
    if (rv == 0) {
#line 3235
      return (field);
    } else
#line 3236
    if (rv < 0) {
#line 3237
      count = (start___0 + count) - (mid + 1U);
#line 3238
      start___0 = mid + 1U;
    } else {
#line 3240
      count = mid - start___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3242
  if (count == 0U) {
#line 3243
    return ((ProtobufCFieldDescriptor *)((void *)0));
  }
  {
#line 3244
  field = desc->fields + *(desc->fields_sorted_by_name + start___0);
#line 3245
  __cil_tmp9 = strcmp(field->name, name);
  }
#line 3245
  if (__cil_tmp9 == 0) {
#line 3246
    return (field);
  }
#line 3247
  return ((ProtobufCFieldDescriptor *)((void *)0));
}
}
#line 3251 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCFieldDescriptor *protobuf_c_message_descriptor_get_field(ProtobufCMessageDescriptor *desc ,
                                                                  unsigned int value ) 
{ 
  int rv ;
  int __cil_tmp4 ;

  {
  {
#line 3254
  __cil_tmp4 = int_range_lookup(desc->n_field_ranges, desc->field_ranges, (int )value);
#line 3254
  rv = __cil_tmp4;
  }
#line 3255
  if (rv < 0) {
#line 3256
    return ((ProtobufCFieldDescriptor *)((void *)0));
  }
#line 3257
  return (desc->fields + rv);
}
}
#line 3261 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/protobuf-c.c"
ProtobufCMethodDescriptor *protobuf_c_service_descriptor_get_method_by_name(ProtobufCServiceDescriptor *desc ,
                                                                            char const   *name ) 
{ 
  unsigned int start___0 ;
  unsigned int count ;
  unsigned int mid ;
  unsigned int mid_index ;
  char const   *mid_name ;
  int rv ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 3264
  start___0 = (unsigned int )0;
#line 3265
  count = desc->n_methods;
  {
#line 3267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3267
    if (! (count > 1U)) {
#line 3267
      goto while_break;
    }
    {
#line 3268
    mid = start___0 + count / 2U;
#line 3269
    mid_index = *(desc->method_indices_by_name + mid);
#line 3270
    mid_name = (desc->methods + mid_index)->name;
#line 3271
    __cil_tmp9 = strcmp(mid_name, name);
#line 3271
    rv = __cil_tmp9;
    }
#line 3273
    if (rv == 0) {
#line 3274
      return (desc->methods + *(desc->method_indices_by_name + mid));
    }
#line 3275
    if (rv < 0) {
#line 3276
      count = (start___0 + count) - (mid + 1U);
#line 3277
      start___0 = mid + 1U;
    } else {
#line 3279
      count = mid - start___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3282
  if (count == 0U) {
#line 3283
    return ((ProtobufCMethodDescriptor *)((void *)0));
  }
  {
#line 3284
  __cil_tmp10 = strcmp((desc->methods + *(desc->method_indices_by_name + start___0))->name,
                       name);
  }
#line 3284
  if (__cil_tmp10 == 0) {
#line 3285
    return (desc->methods + *(desc->method_indices_by_name + start___0));
  }
#line 3286
  return ((ProtobufCMethodDescriptor *)((void *)0));
}
}
#line 7 "h/copyright.h"
static char __copyright_____1[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 28 "numlib/dhsx.h"
double dhsx_funk(void *fdata , double tp[] ) ;
#line 119 "numlib/svd.h"
static void svdinverse___0(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 45 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.h"
ccast_id **get_ccids(void) ;
#line 48
void free_ccids(ccast_id **ids ) ;
#line 50
void ccast_id_copy(ccast_id *dst , ccast_id *src ) ;
#line 51
ccast_id *ccast_id_clone(ccast_id *src ) ;
#line 52
void ccast_id_del(ccast_id *id ) ;
#line 36 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.h"
char *ccpacket_emes(ccpacket_err rv ) ;
#line 82
ccpacket *new_ccpacket() ;
#line 40 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.h"
void ccmes_transfer(ccmes *dst , ccmes *src ) ;
#line 43
void ccmes_init(ccmes *mes ) ;
#line 46
void ccmes_empty(ccmes *mes ) ;
#line 49
void ccmes_del(ccmes *mes ) ;
#line 68
char *ccmessv_emes(ccmessv_err rv ) ;
#line 96
ccmessv *new_ccmessv(ccpacket *pk ) ;
#line 77 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.h"
ccast *new_ccast(ccast_id *id , int forcedef ) ;
#line 83
void ccastQuant(void *ctx , double out[3] , double in[3] ) ;
#line 86
void ccast2YCbCr(void *ctx , double out[3] , double in[3] ) ;
#line 90
void ccast2YCbCr_nq(void *ctx , double out[3] , double in[3] ) ;
#line 94
int YCbCr2ccast(void *ctx , double out[3] , double in[3] ) ;
#line 98
void YCbCr2ccast_nq(void *ctx , double out[3] , double in[3] ) ;
#line 104
double get_ccast_dith(double ipat[4][4][3] , double val[3] ) ;
#line 71 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
double filt_v_ev[2][9]  = { {        - 0.00346700000001,        - 0.0483410000001,        0.0286880000001,        0.418873, 
            0.704674000001,        0.427551000001,        0.0324800000001,        - 0.0501460000001, 
            - 0.003793}, 
   {        - 0.013477,        8.10000000001e-05,        - 0.0871190000001,        0.357627, 
            1.000252,        0.378473000001,        - 0.0834960000001,        - 0.000155, 
            - 0.00985}};
#line 77 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
double filt_v_od[2][8]  = { {        - 0.0268100000001,        - 0.0451900000001,        0.186825,        0.614579, 
            0.623721,        0.206987000001,        - 0.0402170000001,        - 0.0264190000001}, 
   {        0.00839600000001,        - 0.0789870000001,        - 0.0137330000001,        0.796594000001, 
            0.813578000001,        0.013555,        - 0.0864660000001,        0.004781}};
#line 84 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
double *filt[2][2]  = { {        & filt_v_ev[0][- (- 4)],        & filt_v_od[0][- (- 4)]}, 
   {        & filt_v_ev[1][- (- 4)],        & filt_v_od[1][- (- 4)]}};
#line 88 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
int fneg[2]  = {      - 4,      - 4};
#line 89 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
int fpos[2]  = {      4,      3};
#line 105 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static void upsample(double ret[3] , double iipat[4][4][3] ) 
{ 
  double ipat[4][4][3] ;
  double tpat[6][4][3] ;
  double opat[6][6][3] ;
  int x ;
  int y ;
  int i ;
  int j ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int ph ;
  int ii ;
  int k ;
  double __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int ph___0 ;
  int jj ;
  int k___0 ;
  double __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;

  {
#line 114
  x = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (x < 4)) {
#line 114
      goto while_break;
    }
#line 115
    y = 0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (y < 4)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      ccast2YCbCr((void *)0, (double *)ipat[x][y], (double *)iipat[x][y]);
      }
#line 115
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  y = 0;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! (y < 4)) {
#line 126
      goto while_break___1;
    }
#line 129
    i = 0;
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 129
      if (! (i < 6)) {
#line 129
        goto while_break___2;
      }
#line 130
      tpat[i][y][0] = 0.;
#line 131
      tpat[i][y][1] = 0.;
#line 132
      tpat[i][y][2] = 0.;
#line 129
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 136
    x = 0;
    {
#line 136
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 136
      if (! (x < 4)) {
#line 136
        goto while_break___3;
      }
      {
#line 139
      ph = x & 1;
#line 140
      __cil_tmp16 = floor((double )x * 1.5 + 0.5);
#line 140
      ii = (int )__cil_tmp16;
#line 143
      k = fneg[ph];
      }
      {
#line 143
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 143
        if (! (k <= fpos[ph])) {
#line 143
          goto while_break___4;
        }
#line 144
        i = ii + k;
        {
#line 145
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 145
          if (! (i < 0)) {
#line 145
            goto while_break___5;
          }
#line 146
          i += 6;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 147
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 147
          if (! (i >= 6)) {
#line 147
            goto while_break___6;
          }
#line 148
          i -= 6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 149
        tpat[i][y][0] += *(filt[0][ph] + k) * ipat[x][y][0];
#line 150
        tpat[i][y][1] += *(filt[0][ph] + k) * ipat[x][y][1];
#line 151
        tpat[i][y][2] += *(filt[0][ph] + k) * ipat[x][y][2];
#line 143
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 136
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 126
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 158
    if (! (i < 6)) {
#line 158
      goto while_break___7;
    }
#line 161
    j = 0;
    {
#line 161
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 161
      if (! (j < 6)) {
#line 161
        goto while_break___8;
      }
#line 162
      opat[i][j][0] = 0.;
#line 163
      opat[i][j][1] = 0.;
#line 164
      opat[i][j][2] = 0.;
#line 161
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 168
    y = 0;
    {
#line 168
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 168
      if (! (y < 4)) {
#line 168
        goto while_break___9;
      }
      {
#line 171
      ph___0 = y & 1;
#line 172
      __cil_tmp24 = floor((double )y * 1.5 + 0.5);
#line 172
      jj = (int )__cil_tmp24;
#line 175
      k___0 = fneg[ph___0];
      }
      {
#line 175
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 175
        if (! (k___0 <= fpos[ph___0])) {
#line 175
          goto while_break___10;
        }
#line 176
        j = jj + k___0;
        {
#line 177
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 177
          if (! (j < 0)) {
#line 177
            goto while_break___11;
          }
#line 178
          j += 6;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 179
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 179
          if (! (j >= 6)) {
#line 179
            goto while_break___12;
          }
#line 180
          j -= 6;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 181
        opat[i][j][0] += *(filt[1][ph___0] + k___0) * tpat[i][y][0];
#line 182
        opat[i][j][1] += *(filt[1][ph___0] + k___0) * tpat[i][y][1];
#line 183
        opat[i][j][2] += *(filt[1][ph___0] + k___0) * tpat[i][y][2];
#line 175
        k___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 168
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 158
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 190
    if (! (i < 6)) {
#line 190
      goto while_break___13;
    }
#line 191
    j = 0;
    {
#line 191
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 191
      if (! (j < 6)) {
#line 191
        goto while_break___14;
      }
      {
#line 192
      YCbCr2ccast((void *)0, (double *)opat[i][j], (double *)opat[i][j]);
      }
#line 191
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 197
  if (ret != (void *)0) {
#line 198
    ret[2] = 0.;
#line 198
    ret[1] = ret[2];
#line 198
    ret[0] = ret[1];
#line 199
    j = 0;
    {
#line 199
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 199
      if (! (j < 6)) {
#line 199
        goto while_break___15;
      }
#line 200
      i = 0;
      {
#line 200
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 200
        if (! (i < 6)) {
#line 200
          goto while_break___16;
        }
#line 201
        ret[0] += opat[i][j][0];
#line 202
        ret[1] += opat[i][j][1];
#line 203
        ret[2] += opat[i][j][2];
#line 200
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 199
      j ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 206
    ret[0] /= (double )36;
#line 207
    ret[1] /= (double )36;
#line 208
    ret[2] /= (double )36;
  }
  return;
}
}
#line 231 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static void quant_rgb(int n , double out[3] , double rgb[3] ) 
{ 
  double ycc[3] ;
  double base[3] ;
  double tmp[3] ;
  double chval[3] ;
  double dist ;
  double bdist ;
  double brgb[3] ;
  double borgb[3] ;
  int ix ;
  int k ;
  int __cil_tmp14 ;
  double dist___44 ;
  int __cil_tmp16 ;
  double tt ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 234
  bdist = 1000000.;
#line 243
  k = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (k < 3)) {
#line 243
      goto while_break;
    }
#line 244
    base[k] = rgb[k];
#line 243
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  ix = 0;
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (! (ix < 8)) {
#line 246
      goto while_break___0;
    }
#line 250
    k = 0;
    {
#line 250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 250
      if (! (k < 3)) {
#line 250
        goto while_break___1;
      }
#line 251
      tmp[k] = base[k];
#line 252
      if (ix & (1 << k)) {
#line 253
        if (n & (1 << k)) {
#line 254
          tmp[k] += 1.;
        } else {
#line 256
          tmp[k] -= 1.;
        }
#line 257
        if (tmp[k] < 0.) {
#line 258
          goto while_break___1;
        } else
#line 257
        if (tmp[k] > 255.) {
#line 258
          goto while_break___1;
        }
      }
#line 250
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 261
    if (k < 3) {
#line 262
      goto while_continue___0;
    }
    {
#line 265
    ccast2YCbCr((void *)0, (double *)ycc, (double *)tmp);
#line 266
    YCbCr2ccast((void *)0, (double *)chval, (double *)ycc);
#line 275
    dist___44 = 0.;
#line 276
    k = 0;
    }
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (k < 3)) {
#line 276
        goto while_break___2;
      }
#line 278
      if (n & (1 << k)) {
#line 279
        tt = chval[k] - base[k];
      } else {
#line 281
        tt = base[k] - chval[k];
      }
#line 283
      if (tt >= 0.) {
#line 284
        dist___44 += 0.100000000001 * tt;
      } else {
#line 286
        dist___44 += 2. * - tt;
      }
#line 276
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 291
    if (dist___44 < bdist) {
#line 292
      k = 0;
      {
#line 292
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 292
        if (! (k < 3)) {
#line 292
          goto while_break___3;
        }
#line 293
        rgb[k] = tmp[k];
#line 294
        out[k] = chval[k];
#line 292
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 296
      bdist = dist___44;
    }
#line 246
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 321 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static double optfunc(void *fdata , double tp[] ) 
{ 
  optcntx *cntx ;
  int i ;
  int k ;
  double iw ;
  double tmp[3] ;
  double err ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double tt ;
  int __cil_tmp14 ;

  {
#line 322
  cntx = (optcntx *)fdata;
#line 325
  err = 0.;
#line 328
  k = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (k < 3)) {
#line 328
      goto while_break;
    }
#line 329
    tmp[k] = 0.;
#line 328
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  iw = 1.;
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (i < cntx->di)) {
#line 332
      goto while_break___0;
    }
#line 333
    if (tp[i] < 0.) {
#line 334
      err += (1000. * tp[i]) * tp[i];
    } else
#line 335
    if (tp[i] > 1.) {
#line 336
      err += (1000. * (tp[i] - 1.)) * (tp[i] - 1.);
    }
#line 338
    k = 0;
    {
#line 338
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 338
      if (! (k < 3)) {
#line 338
        goto while_break___1;
      }
#line 339
      tmp[k] += tp[i] * (*(cntx->ressur))[i][k];
#line 338
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 340
    iw -= tp[i];
#line 332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  k = 0;
  {
#line 342
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 342
    if (! (k < 3)) {
#line 342
      goto while_break___2;
    }
#line 343
    tmp[k] += iw * (*(cntx->ressur))[i][k];
#line 342
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 346
  k = 0;
  {
#line 346
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 346
    if (! (k < 3)) {
#line 346
      goto while_break___3;
    }
#line 347
    tt = tmp[k] - *(cntx->val + k);
#line 348
    err += tt * tt;
#line 346
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 351
  return (err);
}
}
#line 356 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
double get_ccast_dith(double ipat[4][4][3] , double val[3] ) 
{ 
  double itpat[4][4][3] ;
  double tpat[4][4][3] ;
  double irtpat[4][4][3] ;
  double rtpat[4][4][3] ;
  double berr ;
  int n ;
  int k ;
  int x ;
  int y ;
  int i ;
  int j ;
  int ii ;
  struct __anonstruct_482 order[16] ;
  int cix ;
  int nsur ;
  int ncomb ;
  double sur[8][3] ;
  double ressur[8][3] ;
  int bcc[8] ;
  double bw[8] ;
  int biw[8] ;
  double dval[3] ;
  double err[3] ;
  double werr ;
  double errxs ;
  int nitters ;
  int rand_count ;
  double rand_start ;
  double rand_end ;
  double rand_pow ;
  double mxerrxs ;
  unsigned int randv ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  double s[8] ;
  optcntx cntx ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int sw[8] ;
  int rem ;
  int __cil_tmp51 ;
  int tt ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  int __cil_tmp60 ;
  double __cil_tmp61 ;
  double __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  int __cil_tmp66 ;
  double corr[3] ;
  double bdot ;
  int bx ;
  int by ;
  double wycc ;
  double mm ;
  double cell[3] ;
  double ccell[3] ;
  double pcell[3] ;
  int __cil_tmp76 ;
  double dd ;
  int __cil_tmp78 ;
  double rlevel ;
  double __cil_tmp80 ;
  double dot ;
  int __cil_tmp82 ;
  unsigned int tmp ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int __cil_tmp87 ;
  double __cil_tmp88 ;
  double __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;

  {
#line 359
  berr = 0.;
#line 364
  order[0].x = 3;
#line 364
  order[0].y = 1;
#line 364
  order[1].x = 1;
#line 364
  order[1].y = 3;
#line 364
  order[2].x = 1;
#line 364
  order[2].y = 1;
#line 364
  order[3].x = 3;
#line 364
  order[3].y = 0;
#line 364
  order[4].x = 3;
#line 364
  order[4].y = 3;
#line 364
  order[5].x = 1;
#line 364
  order[5].y = 2;
#line 364
  order[6].x = 3;
#line 364
  order[6].y = 2;
#line 364
  order[7].x = 2;
#line 364
  order[7].y = 0;
#line 364
  order[8].x = 1;
#line 364
  order[8].y = 0;
#line 364
  order[9].x = 0;
#line 364
  order[9].y = 3;
#line 364
  order[10].x = 0;
#line 364
  order[10].y = 1;
#line 364
  order[11].x = 2;
#line 364
  order[11].y = 1;
#line 364
  order[12].x = 2;
#line 364
  order[12].y = 2;
#line 364
  order[13].x = 0;
#line 364
  order[13].y = 0;
#line 364
  order[14].x = 0;
#line 364
  order[14].y = 2;
#line 364
  order[15].x = 2;
#line 364
  order[15].y = 3;
#line 374
  cix = 0;
#line 375
  nsur = 8;
#line 375
  ncomb = 4;
#line 385
  nitters = 300;
#line 386
  rand_count = 150;
#line 387
  rand_start = 4.5;
#line 388
  rand_end = 0.200000000001;
#line 389
  rand_pow = 1.5;
#line 390
  mxerrxs = 2.5;
#line 391
  randv = (unsigned int )4660;
#line 398
  n = 0;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (n < 8)) {
#line 398
      goto while_break;
    }
#line 399
    k = 0;
    {
#line 399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 399
      if (! (k < 3)) {
#line 399
        goto while_break___0;
      }
#line 400
      if (n & (1 << k)) {
        {
#line 401
        sur[n][k] = ceil(val[k]);
        }
      } else {
        {
#line 403
        sur[n][k] = floor(val[k]);
        }
      }
#line 399
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 409
    quant_rgb(n, (double *)ressur[n], (double *)sur[n]);
    }
#line 398
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  i = 0;
#line 416
  nsur = 0;
  {
#line 416
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 416
    if (! (i < 8)) {
#line 416
      goto while_break___1;
    }
#line 419
    j = 0;
    {
#line 419
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 419
      if (! (j < nsur)) {
#line 419
        goto while_break___2;
      }
#line 420
      k = 0;
      {
#line 420
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 420
        if (! (k < 3)) {
#line 420
          goto while_break___3;
        }
#line 421
        if (ressur[i][k] != ressur[j][k]) {
#line 422
          goto while_break___3;
        }
#line 420
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 424
      if (k < 3) {
#line 425
        goto while_continue___2;
      }
#line 426
      goto while_break___2;
#line 419
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 428
    if (j < nsur) {
#line 429
      goto while_continue___1;
    }
#line 432
    k = 0;
    {
#line 432
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 432
      if (! (k < 3)) {
#line 432
        goto while_break___4;
      }
#line 433
      sur[nsur][k] = sur[i][k];
#line 434
      ressur[nsur][k] = ressur[i][k];
#line 432
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 436
    nsur ++;
#line 416
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 454
  ncomb = nsur;
#line 455
  n = 0;
  {
#line 455
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 455
    if (! (n < nsur)) {
#line 455
      goto while_break___5;
    }
#line 456
    bcc[n] = n;
#line 457
    bw[n] = 1. / (double )nsur;
#line 458
    s[n] = 0.100000000001;
#line 455
    n ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 461
  cntx.di = nsur - 1;
#line 462
  cntx.val = val;
#line 463
  cntx.ressur = & ressur;
#line 465
  powell((double *)((void *)0), cntx.di, (double *)bw, (double *)s, 0.000100000000001,
         1000, & optfunc, & cntx, (void (*)(void * , int  ))((void *)0), (void *)0);
#line 468
  bw[nsur - 1] = 0.;
#line 469
  n = 0;
  }
  {
#line 469
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 469
    if (! (n < nsur - 1)) {
#line 469
      goto while_break___6;
    }
#line 470
    if (bw[n] < 0.) {
#line 471
      bw[n] = 0.;
    } else
#line 472
    if (bw[n] > 1.) {
#line 473
      bw[n] = 1.;
    }
#line 474
    bw[nsur - 1] += bw[n];
#line 469
    n ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 476
  if (bw[nsur - 1] > 1.) {
#line 477
    n = 0;
    {
#line 477
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 477
      if (! (n < nsur - 1)) {
#line 477
        goto while_break___7;
      }
#line 478
      bw[n] *= 1. / bw[nsur - 1];
#line 477
      n ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 479
    bw[nsur - 1] = 1.;
  }
#line 481
  bw[nsur - 1] = 1. - bw[nsur - 1];
#line 515
  n = 0;
  {
#line 515
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 515
    if (! (n < 8)) {
#line 515
      goto while_break___8;
    }
#line 516
    sw[n] = n;
#line 515
    n ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 518
  i = 0;
  {
#line 518
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 518
    if (! (i < ncomb - 1)) {
#line 518
      goto while_break___9;
    }
#line 519
    j = i + 1;
    {
#line 519
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 519
      if (! (j < ncomb)) {
#line 519
        goto while_break___10;
      }
#line 520
      if (bw[sw[j]] < bw[sw[i]]) {
#line 521
        tt = sw[i];
#line 522
        sw[i] = sw[j];
#line 523
        sw[j] = tt;
      }
#line 519
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 518
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 529
  rem = 16;
#line 530
  i = 0;
  {
#line 530
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 530
    if (! (i < ncomb - 1 && rem > 0)) {
#line 530
      goto while_break___11;
    }
#line 531
    n = sw[i];
#line 532
    biw[n] = (int )(16. * bw[n] + 0.5);
#line 533
    rem -= biw[n];
#line 534
    if (rem <= 0) {
#line 535
      rem = 0;
    }
#line 530
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 537
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 537
    if (! (i < ncomb)) {
#line 537
      goto while_break___12;
    }
#line 538
    n = sw[i];
#line 539
    biw[n] = rem;
#line 537
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 550
  n = 0;
#line 550
  cix = 0;
  {
#line 550
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 550
    if (! (n < ncomb)) {
#line 550
      goto while_break___13;
    }
#line 551
    i = 0;
    {
#line 551
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 551
      if (! (i < biw[n])) {
#line 551
        goto while_break___14;
      }
#line 552
      x = order[cix].x;
#line 553
      y = order[cix].y;
#line 554
      cix ++;
#line 555
      k = 0;
      {
#line 555
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 555
        if (! (k < 3)) {
#line 555
          goto while_break___15;
        }
#line 556
        itpat[x][y][k] = sur[bcc[n]][k];
#line 556
        tpat[x][y][k] = itpat[x][y][k];
#line 557
        irtpat[x][y][k] = ressur[bcc[n]][k];
#line 557
        rtpat[x][y][k] = irtpat[x][y][k];
#line 555
        k ++;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 551
      i ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 550
    n ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 577
  upsample((double *)dval, (double (*)[4][3])rtpat);
#line 579
  werr = 0.;
#line 580
  k = 0;
  }
  {
#line 580
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 580
    if (! (k < 3)) {
#line 580
      goto while_break___16;
    }
    {
#line 581
    err[k] = dval[k] - val[k];
#line 582
    __cil_tmp61 = fabs(err[k]);
    }
#line 582
    if (__cil_tmp61 > werr) {
      {
#line 583
      werr = fabs(err[k]);
      }
    }
#line 580
    k ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 593
  berr = werr;
#line 594
  x = 0;
  {
#line 594
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 594
    if (! (x < 4)) {
#line 594
      goto while_break___17;
    }
#line 595
    y = 0;
    {
#line 595
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 595
      if (! (y < 4)) {
#line 595
        goto while_break___18;
      }
#line 596
      k = 0;
      {
#line 596
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 596
        if (! (k < 3)) {
#line 596
          goto while_break___19;
        }
#line 597
        ipat[x][y][k] = tpat[x][y][k];
#line 596
        k ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 595
      y ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 594
    x ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 603
  errxs = 0.;
#line 604
  ii = 0;
  {
#line 604
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 604
    if (! (ii < nitters)) {
#line 604
      goto while_break___20;
    }
#line 614
    k = 0;
    {
#line 614
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 614
      if (! (k < 3)) {
#line 614
        goto while_break___21;
      }
#line 615
      corr[k] = val[k] - dval[k];
#line 614
      k ++;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 622
    k = 0;
    {
#line 622
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 622
      if (! (k < 3)) {
#line 622
        goto while_break___22;
      }
#line 623
      dd = 16. * corr[k];
#line 624
      if (dd >= 1.) {
#line 625
        dd = 1.;
      } else
#line 626
      if (dd <= - 1.) {
#line 627
        dd = - 1.;
      } else {
#line 629
        dd = 0.;
      }
#line 630
      corr[k] = dd;
#line 622
      k ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 633
    if (corr[0] == 0.) {
#line 633
      if (corr[1] == (double )0) {
#line 633
        if (corr[2] == 0.) {
#line 638
          goto while_break___20;
        }
      }
    }
#line 648
    bdot = 1000000.;
#line 649
    n = 0;
#line 649
    by = n;
#line 649
    bx = by;
#line 650
    x = 0;
    {
#line 650
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 650
      if (! (x < 4)) {
#line 650
        goto while_break___23;
      }
      {
#line 651
      __cil_tmp80 = pow((double )((ii % rand_count) / rand_count), rand_pow);
#line 651
      rlevel = rand_start + (rand_end - rand_start) * __cil_tmp80;
#line 654
      y = 0;
      }
      {
#line 654
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 654
        if (! (y < 4)) {
#line 654
          goto while_break___24;
        }
#line 655
        i = 0;
        {
#line 655
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 655
          if (! (i < ncomb)) {
#line 655
            goto while_break___25;
          }
#line 656
          dot = 0.;
#line 657
          k = 0;
          {
#line 657
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 657
            if (! (k < 3)) {
#line 657
              goto while_break___26;
            }
#line 658
            dot += (ressur[bcc[i]][k] - rtpat[x][y][k]) * corr[k];
#line 657
            k ++;
          }
          while_break___26: /* CIL Label */ ;
          }
#line 665
          if (randv & 2147483648U) {
#line 665
            tmp = (randv << 1) ^ 2744673629U;
          } else {
#line 665
            tmp = randv << 1;
          }
#line 665
          randv = tmp;
#line 666
          dot += (rlevel * 2.) * ((double )(randv - 1U) / 4294967294. - 0.5);
#line 668
          if (dot <= 0.) {
#line 669
            dot = 10000000.;
          } else {
#line 671
            dot = (dot - 1.) * (dot - 1.);
          }
#line 675
          if (dot < bdot) {
#line 676
            bdot = dot;
#line 677
            bx = x;
#line 678
            by = y;
#line 679
            n = i;
          }
#line 655
          i ++;
        }
        while_break___25: /* CIL Label */ ;
        }
#line 654
        y ++;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 650
      x ++;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 693
    k = 0;
    {
#line 693
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 693
      if (! (k < 3)) {
#line 693
        goto while_break___27;
      }
#line 694
      tpat[bx][by][k] = sur[bcc[n]][k];
#line 695
      rtpat[bx][by][k] = ressur[bcc[n]][k];
#line 693
      k ++;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 712
    upsample((double *)dval, (double (*)[4][3])rtpat);
#line 714
    werr = 0.;
#line 715
    k = 0;
    }
    {
#line 715
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 715
      if (! (k < 3)) {
#line 715
        goto while_break___28;
      }
      {
#line 716
      err[k] = dval[k] - val[k];
#line 717
      __cil_tmp88 = fabs(err[k]);
      }
#line 717
      if (__cil_tmp88 > werr) {
        {
#line 718
        werr = fabs(err[k]);
        }
      }
#line 715
      k ++;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 721
    if (werr > berr) {
#line 722
      errxs += werr - berr;
    }
#line 726
    if (werr < berr) {
#line 727
      berr = werr;
#line 728
      errxs = 0.;
#line 729
      x = 0;
      {
#line 729
      while (1) {
        while_continue___29: /* CIL Label */ ;
#line 729
        if (! (x < 4)) {
#line 729
          goto while_break___29;
        }
#line 730
        y = 0;
        {
#line 730
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 730
          if (! (y < 4)) {
#line 730
            goto while_break___30;
          }
#line 731
          k = 0;
          {
#line 731
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 731
            if (! (k < 3)) {
#line 731
              goto while_break___31;
            }
#line 732
            ipat[x][y][k] = tpat[x][y][k];
#line 734
            itpat[x][y][k] = tpat[x][y][k];
#line 735
            irtpat[x][y][k] = rtpat[x][y][k];
#line 731
            k ++;
          }
          while_break___31: /* CIL Label */ ;
          }
#line 730
          y ++;
        }
        while_break___30: /* CIL Label */ ;
        }
#line 729
        x ++;
      }
      while_break___29: /* CIL Label */ ;
      }
    }
#line 748
    if (berr < 0.110000000001) {
#line 753
      goto while_break___20;
    }
#line 757
    if (errxs > mxerrxs) {
#line 762
      errxs = 0.;
#line 763
      x = 0;
      {
#line 763
      while (1) {
        while_continue___32: /* CIL Label */ ;
#line 763
        if (! (x < 4)) {
#line 763
          goto while_break___32;
        }
#line 764
        y = 0;
        {
#line 764
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 764
          if (! (y < 4)) {
#line 764
            goto while_break___33;
          }
#line 765
          k = 0;
          {
#line 765
          while (1) {
            while_continue___34: /* CIL Label */ ;
#line 765
            if (! (k < 3)) {
#line 765
              goto while_break___34;
            }
#line 766
            tpat[x][y][k] = itpat[x][y][k];
#line 767
            rtpat[x][y][k] = irtpat[x][y][k];
#line 765
            k ++;
          }
          while_break___34: /* CIL Label */ ;
          }
#line 764
          y ++;
        }
        while_break___33: /* CIL Label */ ;
        }
#line 763
        x ++;
      }
      while_break___32: /* CIL Label */ ;
      }
    }
#line 604
    ii ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 788
  return (berr);
}
}
#line 7 "h/copyright.h"
static char __copyright_____2[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 119 "numlib/svd.h"
static void svdinverse___1(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *__nptr , char **__endptr ,
                                                        int __base ) ;
#line 301
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *__nptr , char **__endptr ,
                                                         int __base ) ;
#line 305
extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                        int __base ) ;
#line 310
extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                         int __base ) ;
#line 29 "/usr/include/openssl/stack.h"
int OPENSSL_sk_num(OPENSSL_STACK * ) ;
#line 30
void *OPENSSL_sk_value(OPENSSL_STACK * , int  ) ;
#line 32
void *OPENSSL_sk_set(OPENSSL_STACK *st , int i , void const   *data ) ;
#line 34
OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc cmp ) ;
#line 35
OPENSSL_STACK *OPENSSL_sk_new_null(void) ;
#line 36
OPENSSL_STACK *OPENSSL_sk_new_reserve(OPENSSL_sk_compfunc c , int n ) ;
#line 37
int OPENSSL_sk_reserve(OPENSSL_STACK *st , int n ) ;
#line 38
void OPENSSL_sk_free(OPENSSL_STACK * ) ;
#line 39
void OPENSSL_sk_pop_free(OPENSSL_STACK *st , void (*func)(void * ) ) ;
#line 40
OPENSSL_STACK *OPENSSL_sk_deep_copy(OPENSSL_STACK * , OPENSSL_sk_copyfunc c , OPENSSL_sk_freefunc f ) ;
#line 43
int OPENSSL_sk_insert(OPENSSL_STACK *sk , void const   *data , int where ) ;
#line 44
void *OPENSSL_sk_delete(OPENSSL_STACK *st , int loc ) ;
#line 45
void *OPENSSL_sk_delete_ptr(OPENSSL_STACK *st , void const   *p ) ;
#line 46
int OPENSSL_sk_find(OPENSSL_STACK *st , void const   *data ) ;
#line 47
int OPENSSL_sk_find_ex(OPENSSL_STACK *st , void const   *data ) ;
#line 48
int OPENSSL_sk_find_all(OPENSSL_STACK *st , void const   *data , int *pnum ) ;
#line 49
int OPENSSL_sk_push(OPENSSL_STACK *st , void const   *data ) ;
#line 50
int OPENSSL_sk_unshift(OPENSSL_STACK *st , void const   *data ) ;
#line 51
void *OPENSSL_sk_shift(OPENSSL_STACK *st ) ;
#line 52
void *OPENSSL_sk_pop(OPENSSL_STACK *st ) ;
#line 53
void OPENSSL_sk_zero(OPENSSL_STACK *st ) ;
#line 54
OPENSSL_sk_compfunc OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk , OPENSSL_sk_compfunc cmp ) ;
#line 56
OPENSSL_STACK *OPENSSL_sk_dup(OPENSSL_STACK *st ) ;
#line 57
void OPENSSL_sk_sort(OPENSSL_STACK *st ) ;
#line 58
int OPENSSL_sk_is_sorted(OPENSSL_STACK *st ) ;
#line 205 "/usr/include/openssl/safestack.h"
__inline static char *ossl_check_OPENSSL_STRING_type(char *ptr ) 
{ 


  {
#line 205
  return (ptr);
}
}
#line 205 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_STACK *ossl_check_const_OPENSSL_STRING_sk_type(struct stack_st_OPENSSL_STRING *sk ) 
{ 


  {
#line 205
  return ((OPENSSL_STACK *)sk);
}
}
#line 205 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_compfunc ossl_check_OPENSSL_STRING_compfunc_type(sk_OPENSSL_STRING_compfunc cmp ) 
{ 


  {
#line 205
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 205 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OPENSSL_STRING_copyfunc_type(sk_OPENSSL_STRING_copyfunc cpy ) 
{ 


  {
#line 205
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 205 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_freefunc ossl_check_OPENSSL_STRING_freefunc_type(sk_OPENSSL_STRING_freefunc fr ) 
{ 


  {
#line 205
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 231 "/usr/include/openssl/safestack.h"
__inline static char const   *ossl_check_OPENSSL_CSTRING_type(char const   *ptr ) 
{ 


  {
#line 231
  return (ptr);
}
}
#line 231 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_STACK *ossl_check_const_OPENSSL_CSTRING_sk_type(struct stack_st_OPENSSL_CSTRING *sk ) 
{ 


  {
#line 231
  return ((OPENSSL_STACK *)sk);
}
}
#line 231 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_compfunc ossl_check_OPENSSL_CSTRING_compfunc_type(sk_OPENSSL_CSTRING_compfunc cmp ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 231 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OPENSSL_CSTRING_copyfunc_type(sk_OPENSSL_CSTRING_copyfunc cpy ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 231 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_freefunc ossl_check_OPENSSL_CSTRING_freefunc_type(sk_OPENSSL_CSTRING_freefunc fr ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 265 "/usr/include/openssl/safestack.h"
__inline static void *ossl_check_OPENSSL_BLOCK_type(void *ptr ) 
{ 


  {
#line 265
  return (ptr);
}
}
#line 265 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_STACK *ossl_check_const_OPENSSL_BLOCK_sk_type(struct stack_st_OPENSSL_BLOCK *sk ) 
{ 


  {
#line 265
  return ((OPENSSL_STACK *)sk);
}
}
#line 265 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_compfunc ossl_check_OPENSSL_BLOCK_compfunc_type(sk_OPENSSL_BLOCK_compfunc cmp ) 
{ 


  {
#line 265
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 265 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OPENSSL_BLOCK_copyfunc_type(sk_OPENSSL_BLOCK_copyfunc cpy ) 
{ 


  {
#line 265
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 265 "/usr/include/openssl/safestack.h"
__inline static OPENSSL_sk_freefunc ossl_check_OPENSSL_BLOCK_freefunc_type(sk_OPENSSL_BLOCK_freefunc fr ) 
{ 


  {
#line 265
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 29 "/usr/include/openssl/cryptoerr_legacy.h"
int ERR_load_ASN1_strings(void) ;
#line 30
int ERR_load_ASYNC_strings(void) ;
#line 31
int ERR_load_BIO_strings(void) ;
#line 32
int ERR_load_BN_strings(void) ;
#line 33
int ERR_load_BUF_strings(void) ;
#line 35
int ERR_load_CMS_strings(void) ;
#line 38
int ERR_load_COMP_strings(void) ;
#line 40
int ERR_load_CONF_strings(void) ;
#line 41
int ERR_load_CRYPTO_strings(void) ;
#line 43
int ERR_load_CT_strings(void) ;
#line 46
int ERR_load_DH_strings(void) ;
#line 49
int ERR_load_DSA_strings(void) ;
#line 52
int ERR_load_EC_strings(void) ;
#line 55
int ERR_load_ENGINE_strings(void) ;
#line 57
int ERR_load_ERR_strings(void) ;
#line 58
int ERR_load_EVP_strings(void) ;
#line 59
int ERR_load_KDF_strings(void) ;
#line 60
int ERR_load_OBJ_strings(void) ;
#line 62
int ERR_load_OCSP_strings(void) ;
#line 64
int ERR_load_PEM_strings(void) ;
#line 65
int ERR_load_PKCS12_strings(void) ;
#line 66
int ERR_load_PKCS7_strings(void) ;
#line 67
int ERR_load_RAND_strings(void) ;
#line 68
int ERR_load_RSA_strings(void) ;
#line 69
int ERR_load_OSSL_STORE_strings(void) ;
#line 71
int ERR_load_TS_strings(void) ;
#line 73
int ERR_load_UI_strings(void) ;
#line 74
int ERR_load_X509_strings(void) ;
#line 75
int ERR_load_X509V3_strings(void) ;
#line 198 "/usr/include/openssl/core.h"
extern int OSSL_provider_init(OSSL_CORE_HANDLE * , OSSL_DISPATCH * , OSSL_DISPATCH ** ,
                              void ** ) ;
#line 81 "/usr/include/openssl/crypto.h"
CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void) ;
#line 82
int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock ) ;
#line 83
int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock ) ;
#line 84
int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock ) ;
#line 85
void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock ) ;
#line 87
int CRYPTO_atomic_add(int *val , int amount , int *ret , CRYPTO_RWLOCK *lock ) ;
#line 88
int CRYPTO_atomic_or(uint64_t *val , uint64_t op , uint64_t *ret , CRYPTO_RWLOCK *lock ) ;
#line 90
int CRYPTO_atomic_load(uint64_t *val , uint64_t *ret , CRYPTO_RWLOCK *lock ) ;
#line 124
size_t OPENSSL_strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 125
size_t OPENSSL_strlcat(char *dst , char const   *src , size_t siz ) ;
#line 126
size_t OPENSSL_strnlen(char const   *str , size_t maxlen ) ;
#line 127
int OPENSSL_buf2hexstr_ex(char *str , size_t str_n , size_t *strlength , unsigned char const   *buf ,
                          size_t buflen , char const   sep ) ;
#line 130
char *OPENSSL_buf2hexstr(unsigned char const   *buf , long buflen ) ;
#line 131
int OPENSSL_hexstr2buf_ex(unsigned char *buf , size_t buf_n , size_t *buflen , char const   *str ,
                          char const   sep ) ;
#line 133
unsigned char *OPENSSL_hexstr2buf(char const   *str , long *buflen ) ;
#line 134
int OPENSSL_hexchar2int(unsigned char c ) ;
#line 135
int OPENSSL_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 136
int OPENSSL_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 145
unsigned int OPENSSL_version_major(void) ;
#line 146
unsigned int OPENSSL_version_minor(void) ;
#line 147
unsigned int OPENSSL_version_patch(void) ;
#line 148
char const   *OPENSSL_version_pre_release(void) ;
#line 149
char const   *OPENSSL_version_build_metadata(void) ;
#line 151
unsigned long OpenSSL_version_num(void) ;
#line 152
char const   *OpenSSL_version(int type ) ;
#line 164
char const   *OPENSSL_info(int type ) ;
#line 178
int OPENSSL_issetugid(void) ;
#line 185 "/usr/include/openssl/crypto.h"
__inline static OPENSSL_STACK *ossl_check_const_void_sk_type(struct stack_st_void *sk ) 
{ 


  {
#line 185
  return ((OPENSSL_STACK *)sk);
}
}
#line 185 "/usr/include/openssl/crypto.h"
__inline static OPENSSL_sk_compfunc ossl_check_void_compfunc_type(sk_void_compfunc cmp ) 
{ 


  {
#line 185
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 185 "/usr/include/openssl/crypto.h"
__inline static OPENSSL_sk_copyfunc ossl_check_void_copyfunc_type(sk_void_copyfunc cpy ) 
{ 


  {
#line 185
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 185 "/usr/include/openssl/crypto.h"
__inline static OPENSSL_sk_freefunc ossl_check_void_freefunc_type(sk_void_freefunc fr ) 
{ 


  {
#line 185
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 244
int CRYPTO_get_ex_new_index(int class_index , long argl , void *argp , CRYPTO_EX_new *new_func ,
                            CRYPTO_EX_dup *dup_func , CRYPTO_EX_free *free_func ) ;
#line 249
int CRYPTO_free_ex_index(int class_index , int idx ) ;
#line 255
int CRYPTO_new_ex_data(int class_index , void *obj , CRYPTO_EX_DATA *ad ) ;
#line 256
int CRYPTO_dup_ex_data(int class_index , CRYPTO_EX_DATA *to , CRYPTO_EX_DATA *from ) ;
#line 259
void CRYPTO_free_ex_data(int class_index , void *obj , CRYPTO_EX_DATA *ad ) ;
#line 262
int CRYPTO_alloc_ex_data(int class_index , void *obj , CRYPTO_EX_DATA *ad , int idx ) ;
#line 269
int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad , int idx , void *val ) ;
#line 270
void *CRYPTO_get_ex_data(CRYPTO_EX_DATA *ad , int idx ) ;
#line 337
int CRYPTO_set_mem_functions(CRYPTO_malloc_fn malloc_fn , CRYPTO_realloc_fn realloc_fn ,
                             CRYPTO_free_fn free_fn ) ;
#line 340
void CRYPTO_get_mem_functions(CRYPTO_malloc_fn *malloc_fn , CRYPTO_realloc_fn *realloc_fn ,
                              CRYPTO_free_fn *free_fn ) ;
#line 344
void *CRYPTO_malloc(size_t num , char const   *file , int line ) ;
#line 345
void *CRYPTO_zalloc(size_t num , char const   *file , int line ) ;
#line 346
void *CRYPTO_memdup(void const   *str , size_t siz , char const   *file , int line ) ;
#line 347
char *CRYPTO_strdup(char const   *str , char const   *file , int line ) ;
#line 348
char *CRYPTO_strndup(char const   *str , size_t s , char const   *file , int line ) ;
#line 349
void CRYPTO_free(void *ptr , char const   *file , int line ) ;
#line 350
void CRYPTO_clear_free(void *ptr , size_t num , char const   *file , int line ) ;
#line 351
void *CRYPTO_realloc(void *addr , size_t num , char const   *file , int line ) ;
#line 352
void *CRYPTO_clear_realloc(void *addr , size_t old_num , size_t num , char const   *file ,
                           int line ) ;
#line 355
int CRYPTO_secure_malloc_init(size_t sz , size_t minsize ) ;
#line 356
int CRYPTO_secure_malloc_done(void) ;
#line 357
void *CRYPTO_secure_malloc(size_t num , char const   *file , int line ) ;
#line 358
void *CRYPTO_secure_zalloc(size_t num , char const   *file , int line ) ;
#line 359
void CRYPTO_secure_free(void *ptr , char const   *file , int line ) ;
#line 360
void CRYPTO_secure_clear_free(void *ptr , size_t num , char const   *file , int line ) ;
#line 362
int CRYPTO_secure_allocated(void const   *ptr ) ;
#line 363
int CRYPTO_secure_malloc_initialized(void) ;
#line 364
size_t CRYPTO_secure_actual_size(void *ptr ) ;
#line 365
size_t CRYPTO_secure_used(void) ;
#line 367
void OPENSSL_cleanse(void *ptr , size_t len ) ;
#line 415
void OPENSSL_die(char const   *assertion , char const   *file , int line ) ;
#line 422
int OPENSSL_isservice(void) ;
#line 424
void OPENSSL_init(void) ;
#line 427
void OPENSSL_fork_prepare(void) ;
#line 428
void OPENSSL_fork_parent(void) ;
#line 429
void OPENSSL_fork_child(void) ;
#line 433
struct tm *OPENSSL_gmtime(time_t *timer , struct tm *result ) ;
#line 434
int OPENSSL_gmtime_adj(struct tm *tm , int offset_day , long offset_sec ) ;
#line 435
int OPENSSL_gmtime_diff(int *pday , int *psec , struct tm *from , struct tm *to ) ;
#line 445
int CRYPTO_memcmp(void const   *in_a , void const   *in_b , size_t len ) ;
#line 484
void OPENSSL_cleanup(void) ;
#line 485
int OPENSSL_init_crypto(uint64_t opts , OPENSSL_INIT_SETTINGS *settings ) ;
#line 486
int OPENSSL_atexit(void (*handler)(void) ) ;
#line 487
void OPENSSL_thread_stop(void) ;
#line 488
void OPENSSL_thread_stop_ex(OSSL_LIB_CTX *ctx ) ;
#line 491
OPENSSL_INIT_SETTINGS *OPENSSL_INIT_new(void) ;
#line 493
int OPENSSL_INIT_set_config_filename(OPENSSL_INIT_SETTINGS *settings , char const   *config_filename ) ;
#line 495
void OPENSSL_INIT_set_config_file_flags(OPENSSL_INIT_SETTINGS *settings , unsigned long flags ) ;
#line 497
int OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *settings , char const   *config_appname ) ;
#line 500
void OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *settings ) ;
#line 535
int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once , void (*init)(void) ) ;
#line 537
int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key , void (*cleanup)(void * ) ) ;
#line 538
void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key ) ;
#line 539
int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key , void *val ) ;
#line 540
int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key ) ;
#line 542
CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void) ;
#line 543
int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a , CRYPTO_THREAD_ID b ) ;
#line 545
OSSL_LIB_CTX *OSSL_LIB_CTX_new(void) ;
#line 546
OSSL_LIB_CTX *OSSL_LIB_CTX_new_from_dispatch(OSSL_CORE_HANDLE *handle , OSSL_DISPATCH *in ) ;
#line 548
OSSL_LIB_CTX *OSSL_LIB_CTX_new_child(OSSL_CORE_HANDLE *handle , OSSL_DISPATCH *in ) ;
#line 550
int OSSL_LIB_CTX_load_config(OSSL_LIB_CTX *ctx , char const   *config_file ) ;
#line 551
void OSSL_LIB_CTX_free(OSSL_LIB_CTX * ) ;
#line 552
OSSL_LIB_CTX *OSSL_LIB_CTX_get0_global_default(void) ;
#line 553
OSSL_LIB_CTX *OSSL_LIB_CTX_set0_default(OSSL_LIB_CTX *libctx ) ;
#line 30 "/usr/include/openssl/comp.h"
COMP_CTX *COMP_CTX_new(COMP_METHOD *meth ) ;
#line 31
COMP_METHOD *COMP_CTX_get_method(COMP_CTX *ctx ) ;
#line 32
int COMP_CTX_get_type(COMP_CTX *comp ) ;
#line 33
int COMP_get_type(COMP_METHOD *meth ) ;
#line 34
char const   *COMP_get_name(COMP_METHOD *meth ) ;
#line 35
void COMP_CTX_free(COMP_CTX *ctx ) ;
#line 37
int COMP_compress_block(COMP_CTX *ctx , unsigned char *out , int olen , unsigned char *in ,
                        int ilen ) ;
#line 39
int COMP_expand_block(COMP_CTX *ctx , unsigned char *out , int olen , unsigned char *in ,
                      int ilen ) ;
#line 42
COMP_METHOD *COMP_zlib(void) ;
#line 216 "/usr/include/openssl/bio.h"
int BIO_get_new_index(void) ;
#line 217
void BIO_set_flags(BIO *b , int flags ) ;
#line 218
int BIO_test_flags(BIO *b , int flags ) ;
#line 219
void BIO_clear_flags(BIO *b , int flags ) ;
#line 278
BIO_callback_fn BIO_get_callback(BIO *b ) ;
#line 279
void BIO_set_callback(BIO *b , BIO_callback_fn callback ) ;
#line 280
long BIO_debug_callback(BIO *bio , int cmd , char const   *argp , int argi , long argl ,
                        long ret ) ;
#line 288
BIO_callback_fn_ex BIO_get_callback_ex(BIO *b ) ;
#line 289
void BIO_set_callback_ex(BIO *b , BIO_callback_fn_ex callback ) ;
#line 290
long BIO_debug_callback_ex(BIO *bio , int oper , char const   *argp , size_t len ,
                           int argi , long argl , int ret , size_t *processed ) ;
#line 293
char *BIO_get_callback_arg(BIO *b ) ;
#line 294
void BIO_set_callback_arg(BIO *b , char *arg ) ;
#line 298
char const   *BIO_method_name(BIO *b ) ;
#line 299
int BIO_method_type(BIO *b ) ;
#line 304 "/usr/include/openssl/bio.h"
__inline static BIO *ossl_check_BIO_type(BIO *ptr ) 
{ 


  {
#line 304
  return (ptr);
}
}
#line 304 "/usr/include/openssl/bio.h"
__inline static OPENSSL_STACK *ossl_check_const_BIO_sk_type(struct stack_st_BIO *sk ) 
{ 


  {
#line 304
  return ((OPENSSL_STACK *)sk);
}
}
#line 304 "/usr/include/openssl/bio.h"
__inline static OPENSSL_sk_compfunc ossl_check_BIO_compfunc_type(sk_BIO_compfunc cmp ) 
{ 


  {
#line 304
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 304 "/usr/include/openssl/bio.h"
__inline static OPENSSL_sk_copyfunc ossl_check_BIO_copyfunc_type(sk_BIO_copyfunc cpy ) 
{ 


  {
#line 304
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 304 "/usr/include/openssl/bio.h"
__inline static OPENSSL_sk_freefunc ossl_check_BIO_freefunc_type(sk_BIO_freefunc fr ) 
{ 


  {
#line 304
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 562
size_t BIO_ctrl_pending(BIO *b ) ;
#line 563
size_t BIO_ctrl_wpending(BIO *b ) ;
#line 582
size_t BIO_ctrl_get_write_guarantee(BIO *b ) ;
#line 583
size_t BIO_ctrl_get_read_request(BIO *b ) ;
#line 584
int BIO_ctrl_reset_read_request(BIO *b ) ;
#line 609
int BIO_set_ex_data(BIO *bio , int idx , void *data ) ;
#line 610
void *BIO_get_ex_data(BIO *bio , int idx ) ;
#line 611
uint64_t BIO_number_read(BIO *bio ) ;
#line 612
uint64_t BIO_number_written(BIO *bio ) ;
#line 615
int BIO_asn1_set_prefix(BIO *b , asn1_ps_func *prefix , asn1_ps_func *prefix_free ) ;
#line 617
int BIO_asn1_get_prefix(BIO *b , asn1_ps_func **pprefix , asn1_ps_func **pprefix_free ) ;
#line 619
int BIO_asn1_set_suffix(BIO *b , asn1_ps_func *suffix , asn1_ps_func *suffix_free ) ;
#line 621
int BIO_asn1_get_suffix(BIO *b , asn1_ps_func **psuffix , asn1_ps_func **psuffix_free ) ;
#line 624
BIO_METHOD *BIO_s_file(void) ;
#line 625
BIO *BIO_new_file(char const   *filename , char const   *mode ) ;
#line 626
BIO *BIO_new_from_core_bio(OSSL_LIB_CTX *libctx , OSSL_CORE_BIO *corebio ) ;
#line 628
BIO *BIO_new_fp(FILE *stream , int close_flag ) ;
#line 630
BIO *BIO_new_ex(OSSL_LIB_CTX *libctx , BIO_METHOD *method ) ;
#line 631
BIO *BIO_new(BIO_METHOD *type ) ;
#line 632
int BIO_free(BIO *a ) ;
#line 633
void BIO_set_data(BIO *a , void *ptr ) ;
#line 634
void *BIO_get_data(BIO *a ) ;
#line 635
void BIO_set_init(BIO *a , int init ) ;
#line 636
int BIO_get_init(BIO *a ) ;
#line 637
void BIO_set_shutdown(BIO *a , int shut ) ;
#line 638
int BIO_get_shutdown(BIO *a ) ;
#line 639
void BIO_vfree(BIO *a ) ;
#line 640
int BIO_up_ref(BIO *a ) ;
#line 641
int BIO_read(BIO *b , void *data , int dlen ) ;
#line 642
int BIO_read_ex(BIO *b , void *data , size_t dlen , size_t *readbytes ) ;
#line 643
int BIO_gets(BIO *bp , char *buf , int size ) ;
#line 644
int BIO_get_line(BIO *bio , char *buf , int size ) ;
#line 645
int BIO_write(BIO *b , void const   *data , int dlen ) ;
#line 646
int BIO_write_ex(BIO *b , void const   *data , size_t dlen , size_t *written ) ;
#line 647
int BIO_puts(BIO *bp , char const   *buf ) ;
#line 648
int BIO_indent(BIO *b , int indent , int max ) ;
#line 649
long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 650
long BIO_callback_ctrl(BIO *b , int cmd , BIO_info_cb *fp ) ;
#line 651
void *BIO_ptr_ctrl(BIO *bp , int cmd , long larg ) ;
#line 652
long BIO_int_ctrl(BIO *bp , int cmd , long larg , int iarg ) ;
#line 653
BIO *BIO_push(BIO *b , BIO *append ) ;
#line 654
BIO *BIO_pop(BIO *b ) ;
#line 655
void BIO_free_all(BIO *a ) ;
#line 656
BIO *BIO_find_type(BIO *b , int bio_type ) ;
#line 657
BIO *BIO_next(BIO *b ) ;
#line 658
void BIO_set_next(BIO *b , BIO *next ) ;
#line 659
BIO *BIO_get_retry_BIO(BIO *bio , int *reason ) ;
#line 660
int BIO_get_retry_reason(BIO *bio ) ;
#line 661
void BIO_set_retry_reason(BIO *bio , int reason ) ;
#line 662
BIO *BIO_dup_chain(BIO *in ) ;
#line 664
int BIO_nread0(BIO *bio , char **buf ) ;
#line 665
int BIO_nread(BIO *bio , char **buf , int num ) ;
#line 666
int BIO_nwrite0(BIO *bio , char **buf ) ;
#line 667
int BIO_nwrite(BIO *bio , char **buf , int num ) ;
#line 669
BIO_METHOD *BIO_s_mem(void) ;
#line 670
BIO_METHOD *BIO_s_secmem(void) ;
#line 671
BIO *BIO_new_mem_buf(void const   *buf , int len ) ;
#line 673
BIO_METHOD *BIO_s_socket(void) ;
#line 674
BIO_METHOD *BIO_s_connect(void) ;
#line 675
BIO_METHOD *BIO_s_accept(void) ;
#line 677
BIO_METHOD *BIO_s_fd(void) ;
#line 678
BIO_METHOD *BIO_s_log(void) ;
#line 679
BIO_METHOD *BIO_s_bio(void) ;
#line 680
BIO_METHOD *BIO_s_null(void) ;
#line 681
BIO_METHOD *BIO_f_null(void) ;
#line 682
BIO_METHOD *BIO_f_buffer(void) ;
#line 683
BIO_METHOD *BIO_f_readbuffer(void) ;
#line 684
BIO_METHOD *BIO_f_linebuffer(void) ;
#line 685
BIO_METHOD *BIO_f_nbio_test(void) ;
#line 686
BIO_METHOD *BIO_f_prefix(void) ;
#line 687
BIO_METHOD *BIO_s_core(void) ;
#line 689
BIO_METHOD *BIO_s_datagram(void) ;
#line 690
int BIO_dgram_non_fatal_error(int error ) ;
#line 691
BIO *BIO_new_dgram(int fd , int close_flag ) ;
#line 705
int BIO_sock_should_retry(int i ) ;
#line 706
int BIO_sock_non_fatal_error(int error ) ;
#line 707
int BIO_socket_wait(int fd , int for_read , time_t max_time ) ;
#line 709
int BIO_wait(BIO *bio , time_t max_time , unsigned int nap_milliseconds ) ;
#line 710
int BIO_do_connect_retry(BIO *bio , int timeout , int nap_milliseconds ) ;
#line 712
int BIO_fd_should_retry(int i ) ;
#line 713
int BIO_fd_non_fatal_error(int error ) ;
#line 714
int BIO_dump_cb(int (*cb)(void const   * , size_t  , void * ) , void *u , void const   *s ,
                int len ) ;
#line 716
int BIO_dump_indent_cb(int (*cb)(void const   * , size_t  , void * ) , void *u , void const   *s ,
                       int len , int indent ) ;
#line 718
int BIO_dump(BIO *b , void const   *bytes , int len ) ;
#line 719
int BIO_dump_indent(BIO *b , void const   *bytes , int len , int indent ) ;
#line 721
int BIO_dump_fp(FILE *fp , void const   *s , int len ) ;
#line 722
int BIO_dump_indent_fp(FILE *fp , void const   *s , int len , int indent ) ;
#line 724
int BIO_hex_string(BIO *out , int indent , int width , void const   *data , int datalen ) ;
#line 728
BIO_ADDR *BIO_ADDR_new(void) ;
#line 729
int BIO_ADDR_rawmake(BIO_ADDR *ap , int family , void const   *where , size_t wherelen ,
                     unsigned short port ) ;
#line 731
void BIO_ADDR_free(BIO_ADDR * ) ;
#line 732
void BIO_ADDR_clear(BIO_ADDR *ap ) ;
#line 733
int BIO_ADDR_family(BIO_ADDR *ap ) ;
#line 734
int BIO_ADDR_rawaddress(BIO_ADDR *ap , void *p , size_t *l ) ;
#line 735
unsigned short BIO_ADDR_rawport(BIO_ADDR *ap ) ;
#line 736
char *BIO_ADDR_hostname_string(BIO_ADDR *ap , int numeric ) ;
#line 737
char *BIO_ADDR_service_string(BIO_ADDR *ap , int numeric ) ;
#line 738
char *BIO_ADDR_path_string(BIO_ADDR *ap ) ;
#line 740
BIO_ADDRINFO *BIO_ADDRINFO_next(BIO_ADDRINFO *bai ) ;
#line 741
int BIO_ADDRINFO_family(BIO_ADDRINFO *bai ) ;
#line 742
int BIO_ADDRINFO_socktype(BIO_ADDRINFO *bai ) ;
#line 743
int BIO_ADDRINFO_protocol(BIO_ADDRINFO *bai ) ;
#line 744
BIO_ADDR *BIO_ADDRINFO_address(BIO_ADDRINFO *bai ) ;
#line 745
void BIO_ADDRINFO_free(BIO_ADDRINFO *bai ) ;
#line 750
int BIO_parse_hostserv(char const   *hostserv , char **host , char **service , enum BIO_hostserv_priorities hostserv_prio ) ;
#line 755
int BIO_lookup(char const   *host , char const   *service , enum BIO_lookup_type lookup_type ,
               int family , int socktype , BIO_ADDRINFO **res ) ;
#line 758
int BIO_lookup_ex(char const   *host , char const   *service , int lookup_type , int family ,
                  int socktype , int protocol , BIO_ADDRINFO **res ) ;
#line 761
int BIO_sock_error(int sock ) ;
#line 762
int BIO_socket_ioctl(int fd , long type , void *arg ) ;
#line 763
int BIO_socket_nbio(int fd , int mode ) ;
#line 764
int BIO_sock_init(void) ;
#line 768
int BIO_set_tcp_ndelay(int sock , int turn_on ) ;
#line 770
struct hostent *BIO_gethostbyname(char const   *name ) ;
#line 771
int BIO_get_port(char const   *str , unsigned short *port_ptr ) ;
#line 772
int BIO_get_host_ip(char const   *str , unsigned char *ip ) ;
#line 773
int BIO_get_accept_socket(char *host_port , int mode ) ;
#line 774
int BIO_accept(int sock , char **ip_port ) ;
#line 783
int BIO_sock_info(int sock , enum BIO_sock_info_type type , union BIO_sock_info_u *info ) ;
#line 792
int BIO_socket(int domain , int socktype , int protocol , int options ) ;
#line 793
int BIO_connect(int sock , BIO_ADDR *addr , int options ) ;
#line 794
int BIO_bind(int sock , BIO_ADDR *addr , int options ) ;
#line 795
int BIO_listen(int sock , BIO_ADDR *addr , int options ) ;
#line 796
int BIO_accept_ex(int accept_sock , BIO_ADDR *addr , int options ) ;
#line 797
int BIO_closesocket(int sock ) ;
#line 799
BIO *BIO_new_socket(int sock , int close_flag ) ;
#line 800
BIO *BIO_new_connect(char const   *host_port ) ;
#line 801
BIO *BIO_new_accept(char const   *host_port ) ;
#line 804
BIO *BIO_new_fd(int fd , int close_flag ) ;
#line 806
int BIO_new_bio_pair(BIO **bio1 , size_t writebuf1 , BIO **bio2 , size_t writebuf2 ) ;
#line 814
void BIO_copy_next_retry(BIO *b ) ;
#line 837
int BIO_printf(BIO *bio , char const   *format  , ...) ;
#line 839
int BIO_vprintf(BIO *bio , char const   *format , va_list args ) ;
#line 841
int BIO_snprintf(char *buf , size_t n , char const   *format  , ...) ;
#line 843
int BIO_vsnprintf(char *buf , size_t n , char const   *format , va_list args ) ;
#line 849
BIO_METHOD *BIO_meth_new(int type , char const   *name ) ;
#line 850
void BIO_meth_free(BIO_METHOD *biom ) ;
#line 851
int (*BIO_meth_get_write(BIO_METHOD *biom ))(BIO * , char const   * , int  ) ;
#line 852
int (*BIO_meth_get_write_ex(BIO_METHOD *biom ))(BIO * , char const   * , size_t  ,
                                                size_t * ) ;
#line 854
int BIO_meth_set_write(BIO_METHOD *biom , int (*write)(BIO * , char const   * , int  ) ) ;
#line 856
int BIO_meth_set_write_ex(BIO_METHOD *biom , int (*bwrite)(BIO * , char const   * ,
                                                           size_t  , size_t * ) ) ;
#line 858
int (*BIO_meth_get_read(BIO_METHOD *biom ))(BIO * , char * , int  ) ;
#line 859
int (*BIO_meth_get_read_ex(BIO_METHOD *biom ))(BIO * , char * , size_t  , size_t * ) ;
#line 860
int BIO_meth_set_read(BIO_METHOD *biom , int (*read)(BIO * , char * , int  ) ) ;
#line 862
int BIO_meth_set_read_ex(BIO_METHOD *biom , int (*bread)(BIO * , char * , size_t  ,
                                                         size_t * ) ) ;
#line 864
int (*BIO_meth_get_puts(BIO_METHOD *biom ))(BIO * , char const   * ) ;
#line 865
int BIO_meth_set_puts(BIO_METHOD *biom , int (*puts)(BIO * , char const   * ) ) ;
#line 867
int (*BIO_meth_get_gets(BIO_METHOD *biom ))(BIO * , char * , int  ) ;
#line 868
int BIO_meth_set_gets(BIO_METHOD *biom , int (*gets)(BIO * , char * , int  ) ) ;
#line 870
long (*BIO_meth_get_ctrl(BIO_METHOD *biom ))(BIO * , int  , long  , void * ) ;
#line 871
int BIO_meth_set_ctrl(BIO_METHOD *biom , long (*ctrl)(BIO * , int  , long  , void * ) ) ;
#line 873
int (*BIO_meth_get_create(BIO_METHOD *bion ))(BIO * ) ;
#line 874
int BIO_meth_set_create(BIO_METHOD *biom , int (*create)(BIO * ) ) ;
#line 875
int (*BIO_meth_get_destroy(BIO_METHOD *biom ))(BIO * ) ;
#line 876
int BIO_meth_set_destroy(BIO_METHOD *biom , int (*destroy)(BIO * ) ) ;
#line 877
long (*BIO_meth_get_callback_ctrl(BIO_METHOD *biom ))(BIO * , int  , BIO_info_cb * ) ;
#line 879
int BIO_meth_set_callback_ctrl(BIO_METHOD *biom , long (*callback_ctrl)(BIO * , int  ,
                                                                        BIO_info_cb * ) ) ;
#line 51 "/usr/include/openssl/buffer.h"
BUF_MEM *BUF_MEM_new(void) ;
#line 52
BUF_MEM *BUF_MEM_new_ex(unsigned long flags ) ;
#line 53
void BUF_MEM_free(BUF_MEM *a ) ;
#line 54
size_t BUF_MEM_grow(BUF_MEM *str , size_t len ) ;
#line 55
size_t BUF_MEM_grow_clean(BUF_MEM *str , size_t len ) ;
#line 56
void BUF_reverse(unsigned char *out , unsigned char const   *in , size_t siz ) ;
#line 64 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_gettable_params_fn *OSSL_FUNC_core_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 64
  return ((OSSL_FUNC_core_gettable_params_fn *)opf->function);
}
}
#line 67 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_get_params_fn *OSSL_FUNC_core_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 67
  return ((OSSL_FUNC_core_get_params_fn *)opf->function);
}
}
#line 70 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_thread_start_fn *OSSL_FUNC_core_thread_start(OSSL_DISPATCH *opf ) 
{ 


  {
#line 70
  return ((OSSL_FUNC_core_thread_start_fn *)opf->function);
}
}
#line 74 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_get_libctx_fn *OSSL_FUNC_core_get_libctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 74
  return ((OSSL_FUNC_core_get_libctx_fn *)opf->function);
}
}
#line 77 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_new_error_fn *OSSL_FUNC_core_new_error(OSSL_DISPATCH *opf ) 
{ 


  {
#line 77
  return ((OSSL_FUNC_core_new_error_fn *)opf->function);
}
}
#line 79 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_set_error_debug_fn *OSSL_FUNC_core_set_error_debug(OSSL_DISPATCH *opf ) 
{ 


  {
#line 79
  return ((OSSL_FUNC_core_set_error_debug_fn *)opf->function);
}
}
#line 83 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_vset_error_fn *OSSL_FUNC_core_vset_error(OSSL_DISPATCH *opf ) 
{ 


  {
#line 83
  return ((OSSL_FUNC_core_vset_error_fn *)opf->function);
}
}
#line 87 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_set_error_mark_fn *OSSL_FUNC_core_set_error_mark(OSSL_DISPATCH *opf ) 
{ 


  {
#line 87
  return ((OSSL_FUNC_core_set_error_mark_fn *)opf->function);
}
}
#line 89 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_clear_last_error_mark_fn *OSSL_FUNC_core_clear_last_error_mark(OSSL_DISPATCH *opf ) 
{ 


  {
#line 89
  return ((OSSL_FUNC_core_clear_last_error_mark_fn *)opf->function);
}
}
#line 92 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_pop_error_to_mark_fn *OSSL_FUNC_core_pop_error_to_mark(OSSL_DISPATCH *opf ) 
{ 


  {
#line 92
  return ((OSSL_FUNC_core_pop_error_to_mark_fn *)opf->function);
}
}
#line 100 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_obj_add_sigid_fn *OSSL_FUNC_core_obj_add_sigid(OSSL_DISPATCH *opf ) 
{ 


  {
#line 100
  return ((OSSL_FUNC_core_obj_add_sigid_fn *)opf->function);
}
}
#line 103 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_core_obj_create_fn *OSSL_FUNC_core_obj_create(OSSL_DISPATCH *opf ) 
{ 


  {
#line 103
  return ((OSSL_FUNC_core_obj_create_fn *)opf->function);
}
}
#line 109 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_malloc_fn *OSSL_FUNC_CRYPTO_malloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 109
  return ((OSSL_FUNC_CRYPTO_malloc_fn *)opf->function);
}
}
#line 112 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_zalloc_fn *OSSL_FUNC_CRYPTO_zalloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 112
  return ((OSSL_FUNC_CRYPTO_zalloc_fn *)opf->function);
}
}
#line 115 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_free_fn *OSSL_FUNC_CRYPTO_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 115
  return ((OSSL_FUNC_CRYPTO_free_fn *)opf->function);
}
}
#line 118 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_clear_free_fn *OSSL_FUNC_CRYPTO_clear_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 118
  return ((OSSL_FUNC_CRYPTO_clear_free_fn *)opf->function);
}
}
#line 121 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_realloc_fn *OSSL_FUNC_CRYPTO_realloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 121
  return ((OSSL_FUNC_CRYPTO_realloc_fn *)opf->function);
}
}
#line 124 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_clear_realloc_fn *OSSL_FUNC_CRYPTO_clear_realloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 124
  return ((OSSL_FUNC_CRYPTO_clear_realloc_fn *)opf->function);
}
}
#line 128 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_secure_malloc_fn *OSSL_FUNC_CRYPTO_secure_malloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 128
  return ((OSSL_FUNC_CRYPTO_secure_malloc_fn *)opf->function);
}
}
#line 131 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_secure_zalloc_fn *OSSL_FUNC_CRYPTO_secure_zalloc(OSSL_DISPATCH *opf ) 
{ 


  {
#line 131
  return ((OSSL_FUNC_CRYPTO_secure_zalloc_fn *)opf->function);
}
}
#line 134 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_secure_free_fn *OSSL_FUNC_CRYPTO_secure_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 134
  return ((OSSL_FUNC_CRYPTO_secure_free_fn *)opf->function);
}
}
#line 137 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_secure_clear_free_fn *OSSL_FUNC_CRYPTO_secure_clear_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 137
  return ((OSSL_FUNC_CRYPTO_secure_clear_free_fn *)opf->function);
}
}
#line 141 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_CRYPTO_secure_allocated_fn *OSSL_FUNC_CRYPTO_secure_allocated(OSSL_DISPATCH *opf ) 
{ 


  {
#line 141
  return ((OSSL_FUNC_CRYPTO_secure_allocated_fn *)opf->function);
}
}
#line 144 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_OPENSSL_cleanse_fn *OSSL_FUNC_OPENSSL_cleanse(OSSL_DISPATCH *opf ) 
{ 


  {
#line 144
  return ((OSSL_FUNC_OPENSSL_cleanse_fn *)opf->function);
}
}
#line 161 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_new_file_fn *OSSL_FUNC_BIO_new_file(OSSL_DISPATCH *opf ) 
{ 


  {
#line 161
  return ((OSSL_FUNC_BIO_new_file_fn *)opf->function);
}
}
#line 163 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_new_membuf_fn *OSSL_FUNC_BIO_new_membuf(OSSL_DISPATCH *opf ) 
{ 


  {
#line 163
  return ((OSSL_FUNC_BIO_new_membuf_fn *)opf->function);
}
}
#line 164 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_read_ex_fn *OSSL_FUNC_BIO_read_ex(OSSL_DISPATCH *opf ) 
{ 


  {
#line 164
  return ((OSSL_FUNC_BIO_read_ex_fn *)opf->function);
}
}
#line 166 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_write_ex_fn *OSSL_FUNC_BIO_write_ex(OSSL_DISPATCH *opf ) 
{ 


  {
#line 166
  return ((OSSL_FUNC_BIO_write_ex_fn *)opf->function);
}
}
#line 168 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_gets_fn *OSSL_FUNC_BIO_gets(OSSL_DISPATCH *opf ) 
{ 


  {
#line 168
  return ((OSSL_FUNC_BIO_gets_fn *)opf->function);
}
}
#line 169 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_puts_fn *OSSL_FUNC_BIO_puts(OSSL_DISPATCH *opf ) 
{ 


  {
#line 169
  return ((OSSL_FUNC_BIO_puts_fn *)opf->function);
}
}
#line 170 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_up_ref_fn *OSSL_FUNC_BIO_up_ref(OSSL_DISPATCH *opf ) 
{ 


  {
#line 170
  return ((OSSL_FUNC_BIO_up_ref_fn *)opf->function);
}
}
#line 171 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_free_fn *OSSL_FUNC_BIO_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 171
  return ((OSSL_FUNC_BIO_free_fn *)opf->function);
}
}
#line 172 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_vprintf_fn *OSSL_FUNC_BIO_vprintf(OSSL_DISPATCH *opf ) 
{ 


  {
#line 172
  return ((OSSL_FUNC_BIO_vprintf_fn *)opf->function);
}
}
#line 174 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_vsnprintf_fn *OSSL_FUNC_BIO_vsnprintf(OSSL_DISPATCH *opf ) 
{ 


  {
#line 174
  return ((OSSL_FUNC_BIO_vsnprintf_fn *)opf->function);
}
}
#line 176 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_BIO_ctrl_fn *OSSL_FUNC_BIO_ctrl(OSSL_DISPATCH *opf ) 
{ 


  {
#line 176
  return ((OSSL_FUNC_BIO_ctrl_fn *)opf->function);
}
}
#line 180 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_self_test_cb_fn *OSSL_FUNC_self_test_cb(OSSL_DISPATCH *opf ) 
{ 


  {
#line 180
  return ((OSSL_FUNC_self_test_cb_fn *)opf->function);
}
}
#line 188 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_get_entropy_fn *OSSL_FUNC_get_entropy(OSSL_DISPATCH *opf ) 
{ 


  {
#line 188
  return ((OSSL_FUNC_get_entropy_fn *)opf->function);
}
}
#line 191 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cleanup_entropy_fn *OSSL_FUNC_cleanup_entropy(OSSL_DISPATCH *opf ) 
{ 


  {
#line 191
  return ((OSSL_FUNC_cleanup_entropy_fn *)opf->function);
}
}
#line 193 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_get_nonce_fn *OSSL_FUNC_get_nonce(OSSL_DISPATCH *opf ) 
{ 


  {
#line 193
  return ((OSSL_FUNC_get_nonce_fn *)opf->function);
}
}
#line 197 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cleanup_nonce_fn *OSSL_FUNC_cleanup_nonce(OSSL_DISPATCH *opf ) 
{ 


  {
#line 197
  return ((OSSL_FUNC_cleanup_nonce_fn *)opf->function);
}
}
#line 209 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_register_child_cb_fn *OSSL_FUNC_provider_register_child_cb(OSSL_DISPATCH *opf ) 
{ 


  {
#line 209
  return ((OSSL_FUNC_provider_register_child_cb_fn *)opf->function);
}
}
#line 215 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_deregister_child_cb_fn *OSSL_FUNC_provider_deregister_child_cb(OSSL_DISPATCH *opf ) 
{ 


  {
#line 215
  return ((OSSL_FUNC_provider_deregister_child_cb_fn *)opf->function);
}
}
#line 217 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_name_fn *OSSL_FUNC_provider_name(OSSL_DISPATCH *opf ) 
{ 


  {
#line 217
  return ((OSSL_FUNC_provider_name_fn *)opf->function);
}
}
#line 219 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_get0_provider_ctx_fn *OSSL_FUNC_provider_get0_provider_ctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 219
  return ((OSSL_FUNC_provider_get0_provider_ctx_fn *)opf->function);
}
}
#line 221 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_get0_dispatch_fn *OSSL_FUNC_provider_get0_dispatch(OSSL_DISPATCH *opf ) 
{ 


  {
#line 221
  return ((OSSL_FUNC_provider_get0_dispatch_fn *)opf->function);
}
}
#line 223 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_up_ref_fn *OSSL_FUNC_provider_up_ref(OSSL_DISPATCH *opf ) 
{ 


  {
#line 223
  return ((OSSL_FUNC_provider_up_ref_fn *)opf->function);
}
}
#line 225 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_free_fn *OSSL_FUNC_provider_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 225
  return ((OSSL_FUNC_provider_free_fn *)opf->function);
}
}
#line 230 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_teardown_fn *OSSL_FUNC_provider_teardown(OSSL_DISPATCH *opf ) 
{ 


  {
#line 230
  return ((OSSL_FUNC_provider_teardown_fn *)opf->function);
}
}
#line 232 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_gettable_params_fn *OSSL_FUNC_provider_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 232
  return ((OSSL_FUNC_provider_gettable_params_fn *)opf->function);
}
}
#line 235 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_get_params_fn *OSSL_FUNC_provider_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 235
  return ((OSSL_FUNC_provider_get_params_fn *)opf->function);
}
}
#line 238 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_query_operation_fn *OSSL_FUNC_provider_query_operation(OSSL_DISPATCH *opf ) 
{ 


  {
#line 238
  return ((OSSL_FUNC_provider_query_operation_fn *)opf->function);
}
}
#line 241 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_unquery_operation_fn *OSSL_FUNC_provider_unquery_operation(OSSL_DISPATCH *opf ) 
{ 


  {
#line 241
  return ((OSSL_FUNC_provider_unquery_operation_fn *)opf->function);
}
}
#line 244 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_get_reason_strings_fn *OSSL_FUNC_provider_get_reason_strings(OSSL_DISPATCH *opf ) 
{ 


  {
#line 244
  return ((OSSL_FUNC_provider_get_reason_strings_fn *)opf->function);
}
}
#line 247 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_get_capabilities_fn *OSSL_FUNC_provider_get_capabilities(OSSL_DISPATCH *opf ) 
{ 


  {
#line 247
  return ((OSSL_FUNC_provider_get_capabilities_fn *)opf->function);
}
}
#line 250 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_provider_self_test_fn *OSSL_FUNC_provider_self_test(OSSL_DISPATCH *opf ) 
{ 


  {
#line 250
  return ((OSSL_FUNC_provider_self_test_fn *)opf->function);
}
}
#line 287 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_newctx_fn *OSSL_FUNC_digest_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 287
  return ((OSSL_FUNC_digest_newctx_fn *)opf->function);
}
}
#line 288 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_init_fn *OSSL_FUNC_digest_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 288
  return ((OSSL_FUNC_digest_init_fn *)opf->function);
}
}
#line 289 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_update_fn *OSSL_FUNC_digest_update(OSSL_DISPATCH *opf ) 
{ 


  {
#line 289
  return ((OSSL_FUNC_digest_update_fn *)opf->function);
}
}
#line 291 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_final_fn *OSSL_FUNC_digest_final(OSSL_DISPATCH *opf ) 
{ 


  {
#line 291
  return ((OSSL_FUNC_digest_final_fn *)opf->function);
}
}
#line 294 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_digest_fn *OSSL_FUNC_digest_digest(OSSL_DISPATCH *opf ) 
{ 


  {
#line 294
  return ((OSSL_FUNC_digest_digest_fn *)opf->function);
}
}
#line 298 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_freectx_fn *OSSL_FUNC_digest_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 298
  return ((OSSL_FUNC_digest_freectx_fn *)opf->function);
}
}
#line 299 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_dupctx_fn *OSSL_FUNC_digest_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 299
  return ((OSSL_FUNC_digest_dupctx_fn *)opf->function);
}
}
#line 301 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_get_params_fn *OSSL_FUNC_digest_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 301
  return ((OSSL_FUNC_digest_get_params_fn *)opf->function);
}
}
#line 302 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_set_ctx_params_fn *OSSL_FUNC_digest_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 302
  return ((OSSL_FUNC_digest_set_ctx_params_fn *)opf->function);
}
}
#line 304 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_get_ctx_params_fn *OSSL_FUNC_digest_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 304
  return ((OSSL_FUNC_digest_get_ctx_params_fn *)opf->function);
}
}
#line 306 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_gettable_params_fn *OSSL_FUNC_digest_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 306
  return ((OSSL_FUNC_digest_gettable_params_fn *)opf->function);
}
}
#line 308 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_settable_ctx_params_fn *OSSL_FUNC_digest_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 308
  return ((OSSL_FUNC_digest_settable_ctx_params_fn *)opf->function);
}
}
#line 310 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_digest_gettable_ctx_params_fn *OSSL_FUNC_digest_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 310
  return ((OSSL_FUNC_digest_gettable_ctx_params_fn *)opf->function);
}
}
#line 330 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_newctx_fn *OSSL_FUNC_cipher_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 330
  return ((OSSL_FUNC_cipher_newctx_fn *)opf->function);
}
}
#line 331 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_encrypt_init_fn *OSSL_FUNC_cipher_encrypt_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 331
  return ((OSSL_FUNC_cipher_encrypt_init_fn *)opf->function);
}
}
#line 337 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_decrypt_init_fn *OSSL_FUNC_cipher_decrypt_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 337
  return ((OSSL_FUNC_cipher_decrypt_init_fn *)opf->function);
}
}
#line 343 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_update_fn *OSSL_FUNC_cipher_update(OSSL_DISPATCH *opf ) 
{ 


  {
#line 343
  return ((OSSL_FUNC_cipher_update_fn *)opf->function);
}
}
#line 347 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_final_fn *OSSL_FUNC_cipher_final(OSSL_DISPATCH *opf ) 
{ 


  {
#line 347
  return ((OSSL_FUNC_cipher_final_fn *)opf->function);
}
}
#line 350 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_cipher_fn *OSSL_FUNC_cipher_cipher(OSSL_DISPATCH *opf ) 
{ 


  {
#line 350
  return ((OSSL_FUNC_cipher_cipher_fn *)opf->function);
}
}
#line 354 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_freectx_fn *OSSL_FUNC_cipher_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 354
  return ((OSSL_FUNC_cipher_freectx_fn *)opf->function);
}
}
#line 355 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_dupctx_fn *OSSL_FUNC_cipher_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 355
  return ((OSSL_FUNC_cipher_dupctx_fn *)opf->function);
}
}
#line 356 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_get_params_fn *OSSL_FUNC_cipher_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 356
  return ((OSSL_FUNC_cipher_get_params_fn *)opf->function);
}
}
#line 357 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_get_ctx_params_fn *OSSL_FUNC_cipher_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 357
  return ((OSSL_FUNC_cipher_get_ctx_params_fn *)opf->function);
}
}
#line 359 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_set_ctx_params_fn *OSSL_FUNC_cipher_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 359
  return ((OSSL_FUNC_cipher_set_ctx_params_fn *)opf->function);
}
}
#line 361 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_gettable_params_fn *OSSL_FUNC_cipher_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 361
  return ((OSSL_FUNC_cipher_gettable_params_fn *)opf->function);
}
}
#line 363 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_settable_ctx_params_fn *OSSL_FUNC_cipher_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 363
  return ((OSSL_FUNC_cipher_settable_ctx_params_fn *)opf->function);
}
}
#line 365 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_cipher_gettable_ctx_params_fn *OSSL_FUNC_cipher_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 365
  return ((OSSL_FUNC_cipher_gettable_ctx_params_fn *)opf->function);
}
}
#line 383 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_newctx_fn *OSSL_FUNC_mac_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 383
  return ((OSSL_FUNC_mac_newctx_fn *)opf->function);
}
}
#line 384 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_dupctx_fn *OSSL_FUNC_mac_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 384
  return ((OSSL_FUNC_mac_dupctx_fn *)opf->function);
}
}
#line 385 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_freectx_fn *OSSL_FUNC_mac_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 385
  return ((OSSL_FUNC_mac_freectx_fn *)opf->function);
}
}
#line 386 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_init_fn *OSSL_FUNC_mac_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 386
  return ((OSSL_FUNC_mac_init_fn *)opf->function);
}
}
#line 388 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_update_fn *OSSL_FUNC_mac_update(OSSL_DISPATCH *opf ) 
{ 


  {
#line 388
  return ((OSSL_FUNC_mac_update_fn *)opf->function);
}
}
#line 390 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_final_fn *OSSL_FUNC_mac_final(OSSL_DISPATCH *opf ) 
{ 


  {
#line 390
  return ((OSSL_FUNC_mac_final_fn *)opf->function);
}
}
#line 393 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_gettable_params_fn *OSSL_FUNC_mac_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 393
  return ((OSSL_FUNC_mac_gettable_params_fn *)opf->function);
}
}
#line 394 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_gettable_ctx_params_fn *OSSL_FUNC_mac_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 394
  return ((OSSL_FUNC_mac_gettable_ctx_params_fn *)opf->function);
}
}
#line 396 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_settable_ctx_params_fn *OSSL_FUNC_mac_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 396
  return ((OSSL_FUNC_mac_settable_ctx_params_fn *)opf->function);
}
}
#line 398 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_get_params_fn *OSSL_FUNC_mac_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 398
  return ((OSSL_FUNC_mac_get_params_fn *)opf->function);
}
}
#line 399 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_get_ctx_params_fn *OSSL_FUNC_mac_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 399
  return ((OSSL_FUNC_mac_get_ctx_params_fn *)opf->function);
}
}
#line 401 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_mac_set_ctx_params_fn *OSSL_FUNC_mac_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 401
  return ((OSSL_FUNC_mac_set_ctx_params_fn *)opf->function);
}
}
#line 418 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_newctx_fn *OSSL_FUNC_kdf_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 418
  return ((OSSL_FUNC_kdf_newctx_fn *)opf->function);
}
}
#line 419 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_dupctx_fn *OSSL_FUNC_kdf_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 419
  return ((OSSL_FUNC_kdf_dupctx_fn *)opf->function);
}
}
#line 420 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_freectx_fn *OSSL_FUNC_kdf_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 420
  return ((OSSL_FUNC_kdf_freectx_fn *)opf->function);
}
}
#line 421 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_reset_fn *OSSL_FUNC_kdf_reset(OSSL_DISPATCH *opf ) 
{ 


  {
#line 421
  return ((OSSL_FUNC_kdf_reset_fn *)opf->function);
}
}
#line 422 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_derive_fn *OSSL_FUNC_kdf_derive(OSSL_DISPATCH *opf ) 
{ 


  {
#line 422
  return ((OSSL_FUNC_kdf_derive_fn *)opf->function);
}
}
#line 424 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_gettable_params_fn *OSSL_FUNC_kdf_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 424
  return ((OSSL_FUNC_kdf_gettable_params_fn *)opf->function);
}
}
#line 425 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_gettable_ctx_params_fn *OSSL_FUNC_kdf_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 425
  return ((OSSL_FUNC_kdf_gettable_ctx_params_fn *)opf->function);
}
}
#line 427 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_settable_ctx_params_fn *OSSL_FUNC_kdf_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 427
  return ((OSSL_FUNC_kdf_settable_ctx_params_fn *)opf->function);
}
}
#line 429 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_get_params_fn *OSSL_FUNC_kdf_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 429
  return ((OSSL_FUNC_kdf_get_params_fn *)opf->function);
}
}
#line 430 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_get_ctx_params_fn *OSSL_FUNC_kdf_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 430
  return ((OSSL_FUNC_kdf_get_ctx_params_fn *)opf->function);
}
}
#line 432 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kdf_set_ctx_params_fn *OSSL_FUNC_kdf_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 432
  return ((OSSL_FUNC_kdf_set_ctx_params_fn *)opf->function);
}
}
#line 457 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_newctx_fn *OSSL_FUNC_rand_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 457
  return ((OSSL_FUNC_rand_newctx_fn *)opf->function);
}
}
#line 460 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_freectx_fn *OSSL_FUNC_rand_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 460
  return ((OSSL_FUNC_rand_freectx_fn *)opf->function);
}
}
#line 461 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_instantiate_fn *OSSL_FUNC_rand_instantiate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 461
  return ((OSSL_FUNC_rand_instantiate_fn *)opf->function);
}
}
#line 466 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_uninstantiate_fn *OSSL_FUNC_rand_uninstantiate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 466
  return ((OSSL_FUNC_rand_uninstantiate_fn *)opf->function);
}
}
#line 467 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_generate_fn *OSSL_FUNC_rand_generate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 467
  return ((OSSL_FUNC_rand_generate_fn *)opf->function);
}
}
#line 471 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_reseed_fn *OSSL_FUNC_rand_reseed(OSSL_DISPATCH *opf ) 
{ 


  {
#line 471
  return ((OSSL_FUNC_rand_reseed_fn *)opf->function);
}
}
#line 475 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_nonce_fn *OSSL_FUNC_rand_nonce(OSSL_DISPATCH *opf ) 
{ 


  {
#line 475
  return ((OSSL_FUNC_rand_nonce_fn *)opf->function);
}
}
#line 478 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_enable_locking_fn *OSSL_FUNC_rand_enable_locking(OSSL_DISPATCH *opf ) 
{ 


  {
#line 478
  return ((OSSL_FUNC_rand_enable_locking_fn *)opf->function);
}
}
#line 479 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_lock_fn *OSSL_FUNC_rand_lock(OSSL_DISPATCH *opf ) 
{ 


  {
#line 479
  return ((OSSL_FUNC_rand_lock_fn *)opf->function);
}
}
#line 480 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_unlock_fn *OSSL_FUNC_rand_unlock(OSSL_DISPATCH *opf ) 
{ 


  {
#line 480
  return ((OSSL_FUNC_rand_unlock_fn *)opf->function);
}
}
#line 481 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_gettable_params_fn *OSSL_FUNC_rand_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 481
  return ((OSSL_FUNC_rand_gettable_params_fn *)opf->function);
}
}
#line 482 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_gettable_ctx_params_fn *OSSL_FUNC_rand_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 482
  return ((OSSL_FUNC_rand_gettable_ctx_params_fn *)opf->function);
}
}
#line 484 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_settable_ctx_params_fn *OSSL_FUNC_rand_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 484
  return ((OSSL_FUNC_rand_settable_ctx_params_fn *)opf->function);
}
}
#line 486 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_get_params_fn *OSSL_FUNC_rand_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 486
  return ((OSSL_FUNC_rand_get_params_fn *)opf->function);
}
}
#line 487 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_get_ctx_params_fn *OSSL_FUNC_rand_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 487
  return ((OSSL_FUNC_rand_get_ctx_params_fn *)opf->function);
}
}
#line 489 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_set_ctx_params_fn *OSSL_FUNC_rand_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 489
  return ((OSSL_FUNC_rand_set_ctx_params_fn *)opf->function);
}
}
#line 491 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_set_callbacks_fn *OSSL_FUNC_rand_set_callbacks(OSSL_DISPATCH *opf ) 
{ 


  {
#line 491
  return ((OSSL_FUNC_rand_set_callbacks_fn *)opf->function);
}
}
#line 496 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_verify_zeroization_fn *OSSL_FUNC_rand_verify_zeroization(OSSL_DISPATCH *opf ) 
{ 


  {
#line 496
  return ((OSSL_FUNC_rand_verify_zeroization_fn *)opf->function);
}
}
#line 498 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_get_seed_fn *OSSL_FUNC_rand_get_seed(OSSL_DISPATCH *opf ) 
{ 


  {
#line 498
  return ((OSSL_FUNC_rand_get_seed_fn *)opf->function);
}
}
#line 503 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_rand_clear_seed_fn *OSSL_FUNC_rand_clear_seed(OSSL_DISPATCH *opf ) 
{ 


  {
#line 503
  return ((OSSL_FUNC_rand_clear_seed_fn *)opf->function);
}
}
#line 561 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_new_fn *OSSL_FUNC_keymgmt_new(OSSL_DISPATCH *opf ) 
{ 


  {
#line 561
  return ((OSSL_FUNC_keymgmt_new_fn *)opf->function);
}
}
#line 570 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_init_fn *OSSL_FUNC_keymgmt_gen_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 570
  return ((OSSL_FUNC_keymgmt_gen_init_fn *)opf->function);
}
}
#line 572 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_set_template_fn *OSSL_FUNC_keymgmt_gen_set_template(OSSL_DISPATCH *opf ) 
{ 


  {
#line 572
  return ((OSSL_FUNC_keymgmt_gen_set_template_fn *)opf->function);
}
}
#line 574 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_set_params_fn *OSSL_FUNC_keymgmt_gen_set_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 574
  return ((OSSL_FUNC_keymgmt_gen_set_params_fn *)opf->function);
}
}
#line 576 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_settable_params_fn *OSSL_FUNC_keymgmt_gen_settable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 576
  return ((OSSL_FUNC_keymgmt_gen_settable_params_fn *)opf->function);
}
}
#line 579 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_fn *OSSL_FUNC_keymgmt_gen(OSSL_DISPATCH *opf ) 
{ 


  {
#line 579
  return ((OSSL_FUNC_keymgmt_gen_fn *)opf->function);
}
}
#line 581 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gen_cleanup_fn *OSSL_FUNC_keymgmt_gen_cleanup(OSSL_DISPATCH *opf ) 
{ 


  {
#line 581
  return ((OSSL_FUNC_keymgmt_gen_cleanup_fn *)opf->function);
}
}
#line 585 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_load_fn *OSSL_FUNC_keymgmt_load(OSSL_DISPATCH *opf ) 
{ 


  {
#line 585
  return ((OSSL_FUNC_keymgmt_load_fn *)opf->function);
}
}
#line 590 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_free_fn *OSSL_FUNC_keymgmt_free(OSSL_DISPATCH *opf ) 
{ 


  {
#line 590
  return ((OSSL_FUNC_keymgmt_free_fn *)opf->function);
}
}
#line 595 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_get_params_fn *OSSL_FUNC_keymgmt_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 595
  return ((OSSL_FUNC_keymgmt_get_params_fn *)opf->function);
}
}
#line 597 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_gettable_params_fn *OSSL_FUNC_keymgmt_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 597
  return ((OSSL_FUNC_keymgmt_gettable_params_fn *)opf->function);
}
}
#line 602 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_set_params_fn *OSSL_FUNC_keymgmt_set_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 602
  return ((OSSL_FUNC_keymgmt_set_params_fn *)opf->function);
}
}
#line 604 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_settable_params_fn *OSSL_FUNC_keymgmt_settable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 604
  return ((OSSL_FUNC_keymgmt_settable_params_fn *)opf->function);
}
}
#line 609 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_query_operation_name_fn *OSSL_FUNC_keymgmt_query_operation_name(OSSL_DISPATCH *opf ) 
{ 


  {
#line 609
  return ((OSSL_FUNC_keymgmt_query_operation_name_fn *)opf->function);
}
}
#line 614 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_has_fn *OSSL_FUNC_keymgmt_has(OSSL_DISPATCH *opf ) 
{ 


  {
#line 614
  return ((OSSL_FUNC_keymgmt_has_fn *)opf->function);
}
}
#line 618 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_validate_fn *OSSL_FUNC_keymgmt_validate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 618
  return ((OSSL_FUNC_keymgmt_validate_fn *)opf->function);
}
}
#line 623 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_match_fn *OSSL_FUNC_keymgmt_match(OSSL_DISPATCH *opf ) 
{ 


  {
#line 623
  return ((OSSL_FUNC_keymgmt_match_fn *)opf->function);
}
}
#line 632 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_import_fn *OSSL_FUNC_keymgmt_import(OSSL_DISPATCH *opf ) 
{ 


  {
#line 632
  return ((OSSL_FUNC_keymgmt_import_fn *)opf->function);
}
}
#line 634 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_import_types_fn *OSSL_FUNC_keymgmt_import_types(OSSL_DISPATCH *opf ) 
{ 


  {
#line 634
  return ((OSSL_FUNC_keymgmt_import_types_fn *)opf->function);
}
}
#line 636 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_export_fn *OSSL_FUNC_keymgmt_export(OSSL_DISPATCH *opf ) 
{ 


  {
#line 636
  return ((OSSL_FUNC_keymgmt_export_fn *)opf->function);
}
}
#line 639 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_export_types_fn *OSSL_FUNC_keymgmt_export_types(OSSL_DISPATCH *opf ) 
{ 


  {
#line 639
  return ((OSSL_FUNC_keymgmt_export_types_fn *)opf->function);
}
}
#line 644 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keymgmt_dup_fn *OSSL_FUNC_keymgmt_dup(OSSL_DISPATCH *opf ) 
{ 


  {
#line 644
  return ((OSSL_FUNC_keymgmt_dup_fn *)opf->function);
}
}
#line 660 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_newctx_fn *OSSL_FUNC_keyexch_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 660
  return ((OSSL_FUNC_keyexch_newctx_fn *)opf->function);
}
}
#line 661 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_init_fn *OSSL_FUNC_keyexch_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 661
  return ((OSSL_FUNC_keyexch_init_fn *)opf->function);
}
}
#line 663 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_derive_fn *OSSL_FUNC_keyexch_derive(OSSL_DISPATCH *opf ) 
{ 


  {
#line 663
  return ((OSSL_FUNC_keyexch_derive_fn *)opf->function);
}
}
#line 665 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_set_peer_fn *OSSL_FUNC_keyexch_set_peer(OSSL_DISPATCH *opf ) 
{ 


  {
#line 665
  return ((OSSL_FUNC_keyexch_set_peer_fn *)opf->function);
}
}
#line 666 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_freectx_fn *OSSL_FUNC_keyexch_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 666
  return ((OSSL_FUNC_keyexch_freectx_fn *)opf->function);
}
}
#line 667 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_dupctx_fn *OSSL_FUNC_keyexch_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 667
  return ((OSSL_FUNC_keyexch_dupctx_fn *)opf->function);
}
}
#line 668 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_set_ctx_params_fn *OSSL_FUNC_keyexch_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 668
  return ((OSSL_FUNC_keyexch_set_ctx_params_fn *)opf->function);
}
}
#line 670 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_settable_ctx_params_fn *OSSL_FUNC_keyexch_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 670
  return ((OSSL_FUNC_keyexch_settable_ctx_params_fn *)opf->function);
}
}
#line 672 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_get_ctx_params_fn *OSSL_FUNC_keyexch_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 672
  return ((OSSL_FUNC_keyexch_get_ctx_params_fn *)opf->function);
}
}
#line 674 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_keyexch_gettable_ctx_params_fn *OSSL_FUNC_keyexch_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 674
  return ((OSSL_FUNC_keyexch_gettable_ctx_params_fn *)opf->function);
}
}
#line 705 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_newctx_fn *OSSL_FUNC_signature_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 705
  return ((OSSL_FUNC_signature_newctx_fn *)opf->function);
}
}
#line 707 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_sign_init_fn *OSSL_FUNC_signature_sign_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 707
  return ((OSSL_FUNC_signature_sign_init_fn *)opf->function);
}
}
#line 709 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_sign_fn *OSSL_FUNC_signature_sign(OSSL_DISPATCH *opf ) 
{ 


  {
#line 709
  return ((OSSL_FUNC_signature_sign_fn *)opf->function);
}
}
#line 713 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_verify_init_fn *OSSL_FUNC_signature_verify_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 713
  return ((OSSL_FUNC_signature_verify_init_fn *)opf->function);
}
}
#line 715 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_verify_fn *OSSL_FUNC_signature_verify(OSSL_DISPATCH *opf ) 
{ 


  {
#line 715
  return ((OSSL_FUNC_signature_verify_fn *)opf->function);
}
}
#line 720 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_verify_recover_init_fn *OSSL_FUNC_signature_verify_recover_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 720
  return ((OSSL_FUNC_signature_verify_recover_init_fn *)opf->function);
}
}
#line 722 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_verify_recover_fn *OSSL_FUNC_signature_verify_recover(OSSL_DISPATCH *opf ) 
{ 


  {
#line 722
  return ((OSSL_FUNC_signature_verify_recover_fn *)opf->function);
}
}
#line 725 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_sign_init_fn *OSSL_FUNC_signature_digest_sign_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 725
  return ((OSSL_FUNC_signature_digest_sign_init_fn *)opf->function);
}
}
#line 728 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_sign_update_fn *OSSL_FUNC_signature_digest_sign_update(OSSL_DISPATCH *opf ) 
{ 


  {
#line 728
  return ((OSSL_FUNC_signature_digest_sign_update_fn *)opf->function);
}
}
#line 730 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_sign_final_fn *OSSL_FUNC_signature_digest_sign_final(OSSL_DISPATCH *opf ) 
{ 


  {
#line 730
  return ((OSSL_FUNC_signature_digest_sign_final_fn *)opf->function);
}
}
#line 733 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_sign_fn *OSSL_FUNC_signature_digest_sign(OSSL_DISPATCH *opf ) 
{ 


  {
#line 733
  return ((OSSL_FUNC_signature_digest_sign_fn *)opf->function);
}
}
#line 736 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_verify_init_fn *OSSL_FUNC_signature_digest_verify_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 736
  return ((OSSL_FUNC_signature_digest_verify_init_fn *)opf->function);
}
}
#line 739 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_verify_update_fn *OSSL_FUNC_signature_digest_verify_update(OSSL_DISPATCH *opf ) 
{ 


  {
#line 739
  return ((OSSL_FUNC_signature_digest_verify_update_fn *)opf->function);
}
}
#line 741 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_verify_final_fn *OSSL_FUNC_signature_digest_verify_final(OSSL_DISPATCH *opf ) 
{ 


  {
#line 741
  return ((OSSL_FUNC_signature_digest_verify_final_fn *)opf->function);
}
}
#line 743 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_digest_verify_fn *OSSL_FUNC_signature_digest_verify(OSSL_DISPATCH *opf ) 
{ 


  {
#line 743
  return ((OSSL_FUNC_signature_digest_verify_fn *)opf->function);
}
}
#line 746 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_freectx_fn *OSSL_FUNC_signature_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 746
  return ((OSSL_FUNC_signature_freectx_fn *)opf->function);
}
}
#line 747 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_dupctx_fn *OSSL_FUNC_signature_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 747
  return ((OSSL_FUNC_signature_dupctx_fn *)opf->function);
}
}
#line 748 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_get_ctx_params_fn *OSSL_FUNC_signature_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 748
  return ((OSSL_FUNC_signature_get_ctx_params_fn *)opf->function);
}
}
#line 750 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_gettable_ctx_params_fn *OSSL_FUNC_signature_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 750
  return ((OSSL_FUNC_signature_gettable_ctx_params_fn *)opf->function);
}
}
#line 752 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_set_ctx_params_fn *OSSL_FUNC_signature_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 752
  return ((OSSL_FUNC_signature_set_ctx_params_fn *)opf->function);
}
}
#line 754 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_settable_ctx_params_fn *OSSL_FUNC_signature_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 754
  return ((OSSL_FUNC_signature_settable_ctx_params_fn *)opf->function);
}
}
#line 756 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_get_ctx_md_params_fn *OSSL_FUNC_signature_get_ctx_md_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 756
  return ((OSSL_FUNC_signature_get_ctx_md_params_fn *)opf->function);
}
}
#line 758 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_gettable_ctx_md_params_fn *OSSL_FUNC_signature_gettable_ctx_md_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 758
  return ((OSSL_FUNC_signature_gettable_ctx_md_params_fn *)opf->function);
}
}
#line 760 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_set_ctx_md_params_fn *OSSL_FUNC_signature_set_ctx_md_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 760
  return ((OSSL_FUNC_signature_set_ctx_md_params_fn *)opf->function);
}
}
#line 762 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_signature_settable_ctx_md_params_fn *OSSL_FUNC_signature_settable_ctx_md_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 762
  return ((OSSL_FUNC_signature_settable_ctx_md_params_fn *)opf->function);
}
}
#line 780 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_newctx_fn *OSSL_FUNC_asym_cipher_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 780
  return ((OSSL_FUNC_asym_cipher_newctx_fn *)opf->function);
}
}
#line 781 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_encrypt_init_fn *OSSL_FUNC_asym_cipher_encrypt_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 781
  return ((OSSL_FUNC_asym_cipher_encrypt_init_fn *)opf->function);
}
}
#line 783 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_encrypt_fn *OSSL_FUNC_asym_cipher_encrypt(OSSL_DISPATCH *opf ) 
{ 


  {
#line 783
  return ((OSSL_FUNC_asym_cipher_encrypt_fn *)opf->function);
}
}
#line 788 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_decrypt_init_fn *OSSL_FUNC_asym_cipher_decrypt_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 788
  return ((OSSL_FUNC_asym_cipher_decrypt_init_fn *)opf->function);
}
}
#line 790 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_decrypt_fn *OSSL_FUNC_asym_cipher_decrypt(OSSL_DISPATCH *opf ) 
{ 


  {
#line 790
  return ((OSSL_FUNC_asym_cipher_decrypt_fn *)opf->function);
}
}
#line 795 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_freectx_fn *OSSL_FUNC_asym_cipher_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 795
  return ((OSSL_FUNC_asym_cipher_freectx_fn *)opf->function);
}
}
#line 796 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_dupctx_fn *OSSL_FUNC_asym_cipher_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 796
  return ((OSSL_FUNC_asym_cipher_dupctx_fn *)opf->function);
}
}
#line 797 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_get_ctx_params_fn *OSSL_FUNC_asym_cipher_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 797
  return ((OSSL_FUNC_asym_cipher_get_ctx_params_fn *)opf->function);
}
}
#line 799 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_gettable_ctx_params_fn *OSSL_FUNC_asym_cipher_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 799
  return ((OSSL_FUNC_asym_cipher_gettable_ctx_params_fn *)opf->function);
}
}
#line 801 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_set_ctx_params_fn *OSSL_FUNC_asym_cipher_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 801
  return ((OSSL_FUNC_asym_cipher_set_ctx_params_fn *)opf->function);
}
}
#line 803 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_asym_cipher_settable_ctx_params_fn *OSSL_FUNC_asym_cipher_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 803
  return ((OSSL_FUNC_asym_cipher_settable_ctx_params_fn *)opf->function);
}
}
#line 819 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_newctx_fn *OSSL_FUNC_kem_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 819
  return ((OSSL_FUNC_kem_newctx_fn *)opf->function);
}
}
#line 820 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_encapsulate_init_fn *OSSL_FUNC_kem_encapsulate_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 820
  return ((OSSL_FUNC_kem_encapsulate_init_fn *)opf->function);
}
}
#line 822 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_encapsulate_fn *OSSL_FUNC_kem_encapsulate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 822
  return ((OSSL_FUNC_kem_encapsulate_fn *)opf->function);
}
}
#line 826 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_decapsulate_init_fn *OSSL_FUNC_kem_decapsulate_init(OSSL_DISPATCH *opf ) 
{ 


  {
#line 826
  return ((OSSL_FUNC_kem_decapsulate_init_fn *)opf->function);
}
}
#line 828 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_decapsulate_fn *OSSL_FUNC_kem_decapsulate(OSSL_DISPATCH *opf ) 
{ 


  {
#line 828
  return ((OSSL_FUNC_kem_decapsulate_fn *)opf->function);
}
}
#line 831 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_freectx_fn *OSSL_FUNC_kem_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 831
  return ((OSSL_FUNC_kem_freectx_fn *)opf->function);
}
}
#line 832 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_dupctx_fn *OSSL_FUNC_kem_dupctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 832
  return ((OSSL_FUNC_kem_dupctx_fn *)opf->function);
}
}
#line 833 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_get_ctx_params_fn *OSSL_FUNC_kem_get_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 833
  return ((OSSL_FUNC_kem_get_ctx_params_fn *)opf->function);
}
}
#line 834 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_gettable_ctx_params_fn *OSSL_FUNC_kem_gettable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 834
  return ((OSSL_FUNC_kem_gettable_ctx_params_fn *)opf->function);
}
}
#line 836 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_set_ctx_params_fn *OSSL_FUNC_kem_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 836
  return ((OSSL_FUNC_kem_set_ctx_params_fn *)opf->function);
}
}
#line 838 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_kem_settable_ctx_params_fn *OSSL_FUNC_kem_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 838
  return ((OSSL_FUNC_kem_settable_ctx_params_fn *)opf->function);
}
}
#line 852 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_newctx_fn *OSSL_FUNC_encoder_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 852
  return ((OSSL_FUNC_encoder_newctx_fn *)opf->function);
}
}
#line 853 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_freectx_fn *OSSL_FUNC_encoder_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 853
  return ((OSSL_FUNC_encoder_freectx_fn *)opf->function);
}
}
#line 854 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_get_params_fn *OSSL_FUNC_encoder_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 854
  return ((OSSL_FUNC_encoder_get_params_fn *)opf->function);
}
}
#line 855 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_gettable_params_fn *OSSL_FUNC_encoder_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 855
  return ((OSSL_FUNC_encoder_gettable_params_fn *)opf->function);
}
}
#line 857 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_set_ctx_params_fn *OSSL_FUNC_encoder_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 857
  return ((OSSL_FUNC_encoder_set_ctx_params_fn *)opf->function);
}
}
#line 859 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_settable_ctx_params_fn *OSSL_FUNC_encoder_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 859
  return ((OSSL_FUNC_encoder_settable_ctx_params_fn *)opf->function);
}
}
#line 862 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_does_selection_fn *OSSL_FUNC_encoder_does_selection(OSSL_DISPATCH *opf ) 
{ 


  {
#line 862
  return ((OSSL_FUNC_encoder_does_selection_fn *)opf->function);
}
}
#line 864 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_encode_fn *OSSL_FUNC_encoder_encode(OSSL_DISPATCH *opf ) 
{ 


  {
#line 864
  return ((OSSL_FUNC_encoder_encode_fn *)opf->function);
}
}
#line 870 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_import_object_fn *OSSL_FUNC_encoder_import_object(OSSL_DISPATCH *opf ) 
{ 


  {
#line 870
  return ((OSSL_FUNC_encoder_import_object_fn *)opf->function);
}
}
#line 872 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_encoder_free_object_fn *OSSL_FUNC_encoder_free_object(OSSL_DISPATCH *opf ) 
{ 


  {
#line 872
  return ((OSSL_FUNC_encoder_free_object_fn *)opf->function);
}
}
#line 883 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_newctx_fn *OSSL_FUNC_decoder_newctx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 883
  return ((OSSL_FUNC_decoder_newctx_fn *)opf->function);
}
}
#line 884 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_freectx_fn *OSSL_FUNC_decoder_freectx(OSSL_DISPATCH *opf ) 
{ 


  {
#line 884
  return ((OSSL_FUNC_decoder_freectx_fn *)opf->function);
}
}
#line 885 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_get_params_fn *OSSL_FUNC_decoder_get_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 885
  return ((OSSL_FUNC_decoder_get_params_fn *)opf->function);
}
}
#line 886 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_gettable_params_fn *OSSL_FUNC_decoder_gettable_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 886
  return ((OSSL_FUNC_decoder_gettable_params_fn *)opf->function);
}
}
#line 888 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_set_ctx_params_fn *OSSL_FUNC_decoder_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 888
  return ((OSSL_FUNC_decoder_set_ctx_params_fn *)opf->function);
}
}
#line 890 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_settable_ctx_params_fn *OSSL_FUNC_decoder_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 890
  return ((OSSL_FUNC_decoder_settable_ctx_params_fn *)opf->function);
}
}
#line 893 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_does_selection_fn *OSSL_FUNC_decoder_does_selection(OSSL_DISPATCH *opf ) 
{ 


  {
#line 893
  return ((OSSL_FUNC_decoder_does_selection_fn *)opf->function);
}
}
#line 895 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_decode_fn *OSSL_FUNC_decoder_decode(OSSL_DISPATCH *opf ) 
{ 


  {
#line 895
  return ((OSSL_FUNC_decoder_decode_fn *)opf->function);
}
}
#line 899 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_decoder_export_object_fn *OSSL_FUNC_decoder_export_object(OSSL_DISPATCH *opf ) 
{ 


  {
#line 899
  return ((OSSL_FUNC_decoder_export_object_fn *)opf->function);
}
}
#line 923 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_open_fn *OSSL_FUNC_store_open(OSSL_DISPATCH *opf ) 
{ 


  {
#line 923
  return ((OSSL_FUNC_store_open_fn *)opf->function);
}
}
#line 924 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_attach_fn *OSSL_FUNC_store_attach(OSSL_DISPATCH *opf ) 
{ 


  {
#line 924
  return ((OSSL_FUNC_store_attach_fn *)opf->function);
}
}
#line 925 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_settable_ctx_params_fn *OSSL_FUNC_store_settable_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 925
  return ((OSSL_FUNC_store_settable_ctx_params_fn *)opf->function);
}
}
#line 927 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_set_ctx_params_fn *OSSL_FUNC_store_set_ctx_params(OSSL_DISPATCH *opf ) 
{ 


  {
#line 927
  return ((OSSL_FUNC_store_set_ctx_params_fn *)opf->function);
}
}
#line 929 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_load_fn *OSSL_FUNC_store_load(OSSL_DISPATCH *opf ) 
{ 


  {
#line 929
  return ((OSSL_FUNC_store_load_fn *)opf->function);
}
}
#line 933 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_eof_fn *OSSL_FUNC_store_eof(OSSL_DISPATCH *opf ) 
{ 


  {
#line 933
  return ((OSSL_FUNC_store_eof_fn *)opf->function);
}
}
#line 934 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_close_fn *OSSL_FUNC_store_close(OSSL_DISPATCH *opf ) 
{ 


  {
#line 934
  return ((OSSL_FUNC_store_close_fn *)opf->function);
}
}
#line 935 "/usr/include/openssl/core_dispatch.h"
__inline static OSSL_FUNC_store_export_object_fn *OSSL_FUNC_store_export_object(OSSL_DISPATCH *opf ) 
{ 


  {
#line 935
  return ((OSSL_FUNC_store_export_object_fn *)opf->function);
}
}
#line 76 "/usr/include/openssl/bn.h"
void BN_set_flags(BIGNUM *b , int n ) ;
#line 77
int BN_get_flags(BIGNUM *b , int n ) ;
#line 94
void BN_with_flags(BIGNUM *dest , BIGNUM *b , int flags ) ;
#line 97
int BN_GENCB_call(BN_GENCB *cb , int a , int b ) ;
#line 99
BN_GENCB *BN_GENCB_new(void) ;
#line 100
void BN_GENCB_free(BN_GENCB *cb ) ;
#line 103
void BN_GENCB_set_old(BN_GENCB *gencb , void (*callback)(int  , int  , void * ) ,
                      void *cb_arg ) ;
#line 107
void BN_GENCB_set(BN_GENCB *gencb , int (*callback)(int  , int  , BN_GENCB * ) , void *cb_arg ) ;
#line 110
void *BN_GENCB_get_arg(BN_GENCB *cb ) ;
#line 191
int BN_abs_is_word(BIGNUM *a , unsigned long const   w ) ;
#line 192
int BN_is_zero(BIGNUM *a ) ;
#line 193
int BN_is_one(BIGNUM *a ) ;
#line 194
int BN_is_word(BIGNUM *a , unsigned long const   w ) ;
#line 195
int BN_is_odd(BIGNUM *a ) ;
#line 199
void BN_zero_ex(BIGNUM *a ) ;
#line 207
BIGNUM *BN_value_one(void) ;
#line 208
char *BN_options(void) ;
#line 209
BN_CTX *BN_CTX_new_ex(OSSL_LIB_CTX *ctx ) ;
#line 210
BN_CTX *BN_CTX_new(void) ;
#line 211
BN_CTX *BN_CTX_secure_new_ex(OSSL_LIB_CTX *ctx ) ;
#line 212
BN_CTX *BN_CTX_secure_new(void) ;
#line 213
void BN_CTX_free(BN_CTX *c ) ;
#line 214
void BN_CTX_start(BN_CTX *ctx ) ;
#line 215
BIGNUM *BN_CTX_get(BN_CTX *ctx ) ;
#line 216
void BN_CTX_end(BN_CTX *ctx ) ;
#line 217
int BN_rand_ex(BIGNUM *rnd , int bits , int top , int bottom , unsigned int strength ,
               BN_CTX *ctx ) ;
#line 219
int BN_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 220
int BN_priv_rand_ex(BIGNUM *rnd , int bits , int top , int bottom , unsigned int strength ,
                    BN_CTX *ctx ) ;
#line 222
int BN_priv_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 223
int BN_rand_range_ex(BIGNUM *r , BIGNUM *range , unsigned int strength , BN_CTX *ctx ) ;
#line 225
int BN_rand_range(BIGNUM *rnd , BIGNUM *range ) ;
#line 226
int BN_priv_rand_range_ex(BIGNUM *r , BIGNUM *range , unsigned int strength , BN_CTX *ctx ) ;
#line 228
int BN_priv_rand_range(BIGNUM *rnd , BIGNUM *range ) ;
#line 231
int BN_pseudo_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 233
int BN_pseudo_rand_range(BIGNUM *rnd , BIGNUM *range ) ;
#line 235
int BN_num_bits(BIGNUM *a ) ;
#line 236
int BN_num_bits_word(unsigned long l ) ;
#line 237
int BN_security_bits(int L , int N ) ;
#line 238
BIGNUM *BN_new(void) ;
#line 239
BIGNUM *BN_secure_new(void) ;
#line 240
void BN_clear_free(BIGNUM *a ) ;
#line 241
BIGNUM *BN_copy(BIGNUM *a , BIGNUM *b ) ;
#line 242
void BN_swap(BIGNUM *a , BIGNUM *b ) ;
#line 243
BIGNUM *BN_bin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 244
int BN_bn2bin(BIGNUM *a , unsigned char *to ) ;
#line 245
int BN_bn2binpad(BIGNUM *a , unsigned char *to , int tolen ) ;
#line 246
BIGNUM *BN_lebin2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 247
int BN_bn2lebinpad(BIGNUM *a , unsigned char *to , int tolen ) ;
#line 248
BIGNUM *BN_native2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 249
int BN_bn2nativepad(BIGNUM *a , unsigned char *to , int tolen ) ;
#line 250
BIGNUM *BN_mpi2bn(unsigned char const   *s , int len , BIGNUM *ret ) ;
#line 251
int BN_bn2mpi(BIGNUM *a , unsigned char *to ) ;
#line 252
int BN_sub(BIGNUM *r , BIGNUM *a , BIGNUM *b ) ;
#line 253
int BN_usub(BIGNUM *r , BIGNUM *a , BIGNUM *b ) ;
#line 254
int BN_uadd(BIGNUM *r , BIGNUM *a , BIGNUM *b ) ;
#line 255
int BN_add(BIGNUM *r , BIGNUM *a , BIGNUM *b ) ;
#line 256
int BN_mul(BIGNUM *r , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 257
int BN_sqr(BIGNUM *r , BIGNUM *a , BN_CTX *ctx ) ;
#line 262
void BN_set_negative(BIGNUM *b , int n ) ;
#line 267
int BN_is_negative(BIGNUM *b ) ;
#line 269
int BN_div(BIGNUM *dv , BIGNUM *rem , BIGNUM *m , BIGNUM *d , BN_CTX *ctx ) ;
#line 272
int BN_nnmod(BIGNUM *r , BIGNUM *m , BIGNUM *d , BN_CTX *ctx ) ;
#line 273
int BN_mod_add(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *m , BN_CTX *ctx ) ;
#line 275
int BN_mod_add_quick(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *m ) ;
#line 277
int BN_mod_sub(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *m , BN_CTX *ctx ) ;
#line 279
int BN_mod_sub_quick(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *m ) ;
#line 281
int BN_mod_mul(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *m , BN_CTX *ctx ) ;
#line 283
int BN_mod_sqr(BIGNUM *r , BIGNUM *a , BIGNUM *m , BN_CTX *ctx ) ;
#line 284
int BN_mod_lshift1(BIGNUM *r , BIGNUM *a , BIGNUM *m , BN_CTX *ctx ) ;
#line 285
int BN_mod_lshift1_quick(BIGNUM *r , BIGNUM *a , BIGNUM *m ) ;
#line 286
int BN_mod_lshift(BIGNUM *r , BIGNUM *a , int n , BIGNUM *m , BN_CTX *ctx ) ;
#line 288
int BN_mod_lshift_quick(BIGNUM *r , BIGNUM *a , int n , BIGNUM *m ) ;
#line 290
unsigned long BN_mod_word(BIGNUM *a , unsigned long w ) ;
#line 291
unsigned long BN_div_word(BIGNUM *a , unsigned long w ) ;
#line 292
int BN_mul_word(BIGNUM *a , unsigned long w ) ;
#line 293
int BN_add_word(BIGNUM *a , unsigned long w ) ;
#line 294
int BN_sub_word(BIGNUM *a , unsigned long w ) ;
#line 295
int BN_set_word(BIGNUM *a , unsigned long w ) ;
#line 296
unsigned long BN_get_word(BIGNUM *a ) ;
#line 298
int BN_cmp(BIGNUM *a , BIGNUM *b ) ;
#line 299
void BN_free(BIGNUM *a ) ;
#line 300
int BN_is_bit_set(BIGNUM *a , int n ) ;
#line 301
int BN_lshift(BIGNUM *r , BIGNUM *a , int n ) ;
#line 302
int BN_lshift1(BIGNUM *r , BIGNUM *a ) ;
#line 303
int BN_exp(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 305
int BN_mod_exp(BIGNUM *r , BIGNUM *a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ) ;
#line 307
int BN_mod_exp_mont(BIGNUM *r , BIGNUM *a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ,
                    BN_MONT_CTX *m_ctx ) ;
#line 309
int BN_mod_exp_mont_consttime(BIGNUM *rr , BIGNUM *a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ,
                              BN_MONT_CTX *in_mont ) ;
#line 312
int BN_mod_exp_mont_word(BIGNUM *r , unsigned long a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ,
                         BN_MONT_CTX *m_ctx ) ;
#line 314
int BN_mod_exp2_mont(BIGNUM *r , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 , BIGNUM *p2 ,
                     BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
#line 317
int BN_mod_exp_simple(BIGNUM *r , BIGNUM *a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ) ;
#line 319
int BN_mod_exp_mont_consttime_x2(BIGNUM *rr1 , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *m1 ,
                                 BN_MONT_CTX *in_mont1 , BIGNUM *rr2 , BIGNUM *a2 ,
                                 BIGNUM *p2 , BIGNUM *m2 , BN_MONT_CTX *in_mont2 ,
                                 BN_CTX *ctx ) ;
#line 325
int BN_mask_bits(BIGNUM *a , int n ) ;
#line 327
int BN_print_fp(FILE *fp , BIGNUM *a ) ;
#line 329
int BN_print(BIO *bio , BIGNUM *a ) ;
#line 330
int BN_reciprocal(BIGNUM *r , BIGNUM *m , int len , BN_CTX *ctx ) ;
#line 331
int BN_rshift(BIGNUM *r , BIGNUM *a , int n ) ;
#line 332
int BN_rshift1(BIGNUM *r , BIGNUM *a ) ;
#line 333
void BN_clear(BIGNUM *a ) ;
#line 334
BIGNUM *BN_dup(BIGNUM *a ) ;
#line 335
int BN_ucmp(BIGNUM *a , BIGNUM *b ) ;
#line 336
int BN_set_bit(BIGNUM *a , int n ) ;
#line 337
int BN_clear_bit(BIGNUM *a , int n ) ;
#line 338
char *BN_bn2hex(BIGNUM *a ) ;
#line 339
char *BN_bn2dec(BIGNUM *a ) ;
#line 340
int BN_hex2bn(BIGNUM **a , char const   *str ) ;
#line 341
int BN_dec2bn(BIGNUM **a , char const   *str ) ;
#line 342
int BN_asc2bn(BIGNUM **a , char const   *str ) ;
#line 343
int BN_gcd(BIGNUM *r , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 344
int BN_kronecker(BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 347
BIGNUM *BN_mod_inverse(BIGNUM *ret , BIGNUM *a , BIGNUM *n , BN_CTX *ctx ) ;
#line 349
BIGNUM *BN_mod_sqrt(BIGNUM *ret , BIGNUM *a , BIGNUM *n , BN_CTX *ctx ) ;
#line 352
void BN_consttime_swap(unsigned long swap , BIGNUM *a , BIGNUM *b , int nwords ) ;
#line 357
BIGNUM *BN_generate_prime(BIGNUM *ret , int bits , int safe , BIGNUM *add , BIGNUM *rem ,
                          void (*callback)(int  , int  , void * ) , void *cb_arg ) ;
#line 362
int BN_is_prime(BIGNUM *p , int nchecks , void (*callback)(int  , int  , void * ) ,
                BN_CTX *ctx , void *cb_arg ) ;
#line 366
int BN_is_prime_fasttest(BIGNUM *p , int nchecks , void (*callback)(int  , int  ,
                                                                    void * ) , BN_CTX *ctx ,
                         void *cb_arg , int do_trial_division ) ;
#line 373
int BN_is_prime_ex(BIGNUM *p , int nchecks , BN_CTX *ctx , BN_GENCB *cb ) ;
#line 375
int BN_is_prime_fasttest_ex(BIGNUM *p , int nchecks , BN_CTX *ctx , int do_trial_division ,
                            BN_GENCB *cb ) ;
#line 379
int BN_generate_prime_ex2(BIGNUM *ret , int bits , int safe , BIGNUM *add , BIGNUM *rem ,
                          BN_GENCB *cb , BN_CTX *ctx ) ;
#line 382
int BN_generate_prime_ex(BIGNUM *ret , int bits , int safe , BIGNUM *add , BIGNUM *rem ,
                         BN_GENCB *cb ) ;
#line 384
int BN_check_prime(BIGNUM *p , BN_CTX *ctx , BN_GENCB *cb ) ;
#line 388
int BN_X931_generate_Xpq(BIGNUM *Xp , BIGNUM *Xq , int nbits , BN_CTX *ctx ) ;
#line 391
int BN_X931_derive_prime_ex(BIGNUM *p , BIGNUM *p1 , BIGNUM *p2 , BIGNUM *Xp , BIGNUM *Xp1 ,
                            BIGNUM *Xp2 , BIGNUM *e , BN_CTX *ctx , BN_GENCB *cb ) ;
#line 396
int BN_X931_generate_prime_ex(BIGNUM *p , BIGNUM *p1 , BIGNUM *p2 , BIGNUM *Xp1 ,
                              BIGNUM *Xp2 , BIGNUM *Xp , BIGNUM *e , BN_CTX *ctx ,
                              BN_GENCB *cb ) ;
#line 401
BN_MONT_CTX *BN_MONT_CTX_new(void) ;
#line 402
int BN_mod_mul_montgomery(BIGNUM *r , BIGNUM *a , BIGNUM *b , BN_MONT_CTX *mont ,
                          BN_CTX *ctx ) ;
#line 404
int BN_to_montgomery(BIGNUM *r , BIGNUM *a , BN_MONT_CTX *mont , BN_CTX *ctx ) ;
#line 406
int BN_from_montgomery(BIGNUM *r , BIGNUM *a , BN_MONT_CTX *mont , BN_CTX *ctx ) ;
#line 408
void BN_MONT_CTX_free(BN_MONT_CTX *mont ) ;
#line 409
int BN_MONT_CTX_set(BN_MONT_CTX *mont , BIGNUM *mod , BN_CTX *ctx ) ;
#line 410
BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to , BN_MONT_CTX *from ) ;
#line 411
BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont , CRYPTO_RWLOCK *lock , BIGNUM *mod ,
                                    BN_CTX *ctx ) ;
#line 418
BN_BLINDING *BN_BLINDING_new(BIGNUM *A , BIGNUM *Ai , BIGNUM *mod ) ;
#line 419
void BN_BLINDING_free(BN_BLINDING *b ) ;
#line 420
int BN_BLINDING_update(BN_BLINDING *b , BN_CTX *ctx ) ;
#line 421
int BN_BLINDING_convert(BIGNUM *n , BN_BLINDING *b , BN_CTX *ctx ) ;
#line 422
int BN_BLINDING_invert(BIGNUM *n , BN_BLINDING *b , BN_CTX *ctx ) ;
#line 423
int BN_BLINDING_convert_ex(BIGNUM *n , BIGNUM *r , BN_BLINDING *b , BN_CTX * ) ;
#line 424
int BN_BLINDING_invert_ex(BIGNUM *n , BIGNUM *r , BN_BLINDING *b , BN_CTX * ) ;
#line 427
int BN_BLINDING_is_current_thread(BN_BLINDING *b ) ;
#line 428
void BN_BLINDING_set_current_thread(BN_BLINDING *b ) ;
#line 429
int BN_BLINDING_lock(BN_BLINDING *b ) ;
#line 430
int BN_BLINDING_unlock(BN_BLINDING *b ) ;
#line 432
unsigned long BN_BLINDING_get_flags(BN_BLINDING * ) ;
#line 433
void BN_BLINDING_set_flags(BN_BLINDING * , unsigned long  ) ;
#line 434
BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b , BIGNUM *e , BIGNUM *m , BN_CTX *ctx ,
                                      int (*bn_mod_exp)(BIGNUM * , BIGNUM * , BIGNUM * ,
                                                        BIGNUM * , BN_CTX * , BN_MONT_CTX * ) ,
                                      BN_MONT_CTX *m_ctx ) ;
#line 445
void BN_set_params(int mul , int high , int low , int mont ) ;
#line 447
int BN_get_params(int which ) ;
#line 450
BN_RECP_CTX *BN_RECP_CTX_new(void) ;
#line 451
void BN_RECP_CTX_free(BN_RECP_CTX *recp ) ;
#line 452
int BN_RECP_CTX_set(BN_RECP_CTX *recp , BIGNUM *rdiv , BN_CTX *ctx ) ;
#line 453
int BN_mod_mul_reciprocal(BIGNUM *r , BIGNUM *x , BIGNUM *y , BN_RECP_CTX *recp ,
                          BN_CTX *ctx ) ;
#line 455
int BN_mod_exp_recp(BIGNUM *r , BIGNUM *a , BIGNUM *p , BIGNUM *m , BN_CTX *ctx ) ;
#line 457
int BN_div_recp(BIGNUM *dv , BIGNUM *rem , BIGNUM *m , BN_RECP_CTX *recp , BN_CTX *ctx ) ;
#line 472
int BN_GF2m_add(BIGNUM *r , BIGNUM *a , BIGNUM *b ) ;
#line 477
int BN_GF2m_mod(BIGNUM *r , BIGNUM *a , BIGNUM *p ) ;
#line 479
int BN_GF2m_mod_mul(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *p , BN_CTX *ctx ) ;
#line 482
int BN_GF2m_mod_sqr(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 484
int BN_GF2m_mod_inv(BIGNUM *r , BIGNUM *b , BIGNUM *p , BN_CTX *ctx ) ;
#line 486
int BN_GF2m_mod_div(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *p , BN_CTX *ctx ) ;
#line 489
int BN_GF2m_mod_exp(BIGNUM *r , BIGNUM *a , BIGNUM *b , BIGNUM *p , BN_CTX *ctx ) ;
#line 492
int BN_GF2m_mod_sqrt(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 495
int BN_GF2m_mod_solve_quad(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 505
int BN_GF2m_mod_arr(BIGNUM *r , BIGNUM *a , int const   p[] ) ;
#line 507
int BN_GF2m_mod_mul_arr(BIGNUM *r , BIGNUM *a , BIGNUM *b , int const   p[] , BN_CTX *ctx ) ;
#line 510
int BN_GF2m_mod_sqr_arr(BIGNUM *r , BIGNUM *a , int const   p[] , BN_CTX *ctx ) ;
#line 513
int BN_GF2m_mod_inv_arr(BIGNUM *r , BIGNUM *b , int const   p[] , BN_CTX *ctx ) ;
#line 516
int BN_GF2m_mod_div_arr(BIGNUM *r , BIGNUM *a , BIGNUM *b , int const   p[] , BN_CTX *ctx ) ;
#line 519
int BN_GF2m_mod_exp_arr(BIGNUM *r , BIGNUM *a , BIGNUM *b , int const   p[] , BN_CTX *ctx ) ;
#line 522
int BN_GF2m_mod_sqrt_arr(BIGNUM *r , BIGNUM *a , int const   p[] , BN_CTX *ctx ) ;
#line 525
int BN_GF2m_mod_solve_quad_arr(BIGNUM *r , BIGNUM *a , int const   p[] , BN_CTX *ctx ) ;
#line 527
int BN_GF2m_poly2arr(BIGNUM *a , int p[] , int max ) ;
#line 528
int BN_GF2m_arr2poly(int const   p[] , BIGNUM *a ) ;
#line 535
int BN_nist_mod_192(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 536
int BN_nist_mod_224(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 537
int BN_nist_mod_256(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 538
int BN_nist_mod_384(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 539
int BN_nist_mod_521(BIGNUM *r , BIGNUM *a , BIGNUM *p , BN_CTX *ctx ) ;
#line 541
BIGNUM *BN_get0_nist_prime_192(void) ;
#line 542
BIGNUM *BN_get0_nist_prime_224(void) ;
#line 543
BIGNUM *BN_get0_nist_prime_256(void) ;
#line 544
BIGNUM *BN_get0_nist_prime_384(void) ;
#line 545
BIGNUM *BN_get0_nist_prime_521(void) ;
#line 547
int (*BN_nist_mod_func(BIGNUM *p ))(BIGNUM * , BIGNUM * , BIGNUM * , BN_CTX * ) ;
#line 550
int BN_generate_dsa_nonce(BIGNUM *out , BIGNUM *range , BIGNUM *priv , unsigned char const   *message ,
                          size_t message_len , BN_CTX *ctx ) ;
#line 555
BIGNUM *BN_get_rfc2409_prime_768(BIGNUM *bn ) ;
#line 556
BIGNUM *BN_get_rfc2409_prime_1024(BIGNUM *bn ) ;
#line 559
BIGNUM *BN_get_rfc3526_prime_1536(BIGNUM *bn ) ;
#line 560
BIGNUM *BN_get_rfc3526_prime_2048(BIGNUM *bn ) ;
#line 561
BIGNUM *BN_get_rfc3526_prime_3072(BIGNUM *bn ) ;
#line 562
BIGNUM *BN_get_rfc3526_prime_4096(BIGNUM *bn ) ;
#line 563
BIGNUM *BN_get_rfc3526_prime_6144(BIGNUM *bn ) ;
#line 564
BIGNUM *BN_get_rfc3526_prime_8192(BIGNUM *bn ) ;
#line 577
int BN_bntest_rand(BIGNUM *rnd , int bits , int top , int bottom ) ;
#line 71 "/usr/include/openssl/params.h"
OSSL_PARAM *OSSL_PARAM_locate(OSSL_PARAM *p , char const   *key ) ;
#line 72
OSSL_PARAM *OSSL_PARAM_locate_const(OSSL_PARAM *p , char const   *key ) ;
#line 75
OSSL_PARAM OSSL_PARAM_construct_int(char const   *key , int *buf ) ;
#line 76
OSSL_PARAM OSSL_PARAM_construct_uint(char const   *key , unsigned int *buf ) ;
#line 77
OSSL_PARAM OSSL_PARAM_construct_long(char const   *key , long *buf ) ;
#line 78
OSSL_PARAM OSSL_PARAM_construct_ulong(char const   *key , unsigned long *buf ) ;
#line 79
OSSL_PARAM OSSL_PARAM_construct_int32(char const   *key , int32_t *buf ) ;
#line 80
OSSL_PARAM OSSL_PARAM_construct_uint32(char const   *key , uint32_t *buf ) ;
#line 81
OSSL_PARAM OSSL_PARAM_construct_int64(char const   *key , int64_t *buf ) ;
#line 82
OSSL_PARAM OSSL_PARAM_construct_uint64(char const   *key , uint64_t *buf ) ;
#line 83
OSSL_PARAM OSSL_PARAM_construct_size_t(char const   *key , size_t *buf ) ;
#line 84
OSSL_PARAM OSSL_PARAM_construct_time_t(char const   *key , time_t *buf ) ;
#line 85
OSSL_PARAM OSSL_PARAM_construct_BN(char const   *key , unsigned char *buf , size_t bsize ) ;
#line 87
OSSL_PARAM OSSL_PARAM_construct_double(char const   *key , double *buf ) ;
#line 88
OSSL_PARAM OSSL_PARAM_construct_utf8_string(char const   *key , char *buf , size_t bsize ) ;
#line 90
OSSL_PARAM OSSL_PARAM_construct_utf8_ptr(char const   *key , char **buf , size_t bsize ) ;
#line 92
OSSL_PARAM OSSL_PARAM_construct_octet_string(char const   *key , void *buf , size_t bsize ) ;
#line 94
OSSL_PARAM OSSL_PARAM_construct_octet_ptr(char const   *key , void **buf , size_t bsize ) ;
#line 96
OSSL_PARAM OSSL_PARAM_construct_end(void) ;
#line 98
int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to , OSSL_PARAM *paramdefs , char const   *key ,
                                  char const   *value , size_t value_n , int *found ) ;
#line 103
int OSSL_PARAM_get_int(OSSL_PARAM *p , int *val ) ;
#line 104
int OSSL_PARAM_get_uint(OSSL_PARAM *p , unsigned int *val ) ;
#line 105
int OSSL_PARAM_get_long(OSSL_PARAM *p , long *val ) ;
#line 106
int OSSL_PARAM_get_ulong(OSSL_PARAM *p , unsigned long *val ) ;
#line 107
int OSSL_PARAM_get_int32(OSSL_PARAM *p , int32_t *val ) ;
#line 108
int OSSL_PARAM_get_uint32(OSSL_PARAM *p , uint32_t *val ) ;
#line 109
int OSSL_PARAM_get_int64(OSSL_PARAM *p , int64_t *val ) ;
#line 110
int OSSL_PARAM_get_uint64(OSSL_PARAM *p , uint64_t *val ) ;
#line 111
int OSSL_PARAM_get_size_t(OSSL_PARAM *p , size_t *val ) ;
#line 112
int OSSL_PARAM_get_time_t(OSSL_PARAM *p , time_t *val ) ;
#line 114
int OSSL_PARAM_set_int(OSSL_PARAM *p , int val ) ;
#line 115
int OSSL_PARAM_set_uint(OSSL_PARAM *p , unsigned int val ) ;
#line 116
int OSSL_PARAM_set_long(OSSL_PARAM *p , long val ) ;
#line 117
int OSSL_PARAM_set_ulong(OSSL_PARAM *p , unsigned long val ) ;
#line 118
int OSSL_PARAM_set_int32(OSSL_PARAM *p , int32_t val ) ;
#line 119
int OSSL_PARAM_set_uint32(OSSL_PARAM *p , uint32_t val ) ;
#line 120
int OSSL_PARAM_set_int64(OSSL_PARAM *p , int64_t val ) ;
#line 121
int OSSL_PARAM_set_uint64(OSSL_PARAM *p , uint64_t val ) ;
#line 122
int OSSL_PARAM_set_size_t(OSSL_PARAM *p , size_t val ) ;
#line 123
int OSSL_PARAM_set_time_t(OSSL_PARAM *p , time_t val ) ;
#line 125
int OSSL_PARAM_get_double(OSSL_PARAM *p , double *val ) ;
#line 126
int OSSL_PARAM_set_double(OSSL_PARAM *p , double val ) ;
#line 128
int OSSL_PARAM_get_BN(OSSL_PARAM *p , BIGNUM **val ) ;
#line 129
int OSSL_PARAM_set_BN(OSSL_PARAM *p , BIGNUM *val ) ;
#line 131
int OSSL_PARAM_get_utf8_string(OSSL_PARAM *p , char **val , size_t max_len ) ;
#line 132
int OSSL_PARAM_set_utf8_string(OSSL_PARAM *p , char const   *val ) ;
#line 134
int OSSL_PARAM_get_octet_string(OSSL_PARAM *p , void **val , size_t max_len , size_t *used_len ) ;
#line 136
int OSSL_PARAM_set_octet_string(OSSL_PARAM *p , void const   *val , size_t len ) ;
#line 138
int OSSL_PARAM_get_utf8_ptr(OSSL_PARAM *p , char const   **val ) ;
#line 139
int OSSL_PARAM_set_utf8_ptr(OSSL_PARAM *p , char const   *val ) ;
#line 141
int OSSL_PARAM_get_octet_ptr(OSSL_PARAM *p , void const   **val , size_t *used_len ) ;
#line 143
int OSSL_PARAM_set_octet_ptr(OSSL_PARAM *p , void const   *val , size_t used_len ) ;
#line 146
int OSSL_PARAM_get_utf8_string_ptr(OSSL_PARAM *p , char const   **val ) ;
#line 147
int OSSL_PARAM_get_octet_string_ptr(OSSL_PARAM *p , void const   **val , size_t *used_len ) ;
#line 150
int OSSL_PARAM_modified(OSSL_PARAM *p ) ;
#line 151
void OSSL_PARAM_set_all_unmodified(OSSL_PARAM *p ) ;
#line 153
OSSL_PARAM *OSSL_PARAM_dup(OSSL_PARAM *p ) ;
#line 154
OSSL_PARAM *OSSL_PARAM_merge(OSSL_PARAM *p1 , OSSL_PARAM *p2 ) ;
#line 155
void OSSL_PARAM_free(OSSL_PARAM *p ) ;
#line 129 "/usr/include/openssl/asn1.h"
__inline static X509_ALGOR *ossl_check_X509_ALGOR_type(X509_ALGOR *ptr ) 
{ 


  {
#line 129
  return (ptr);
}
}
#line 129 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_ALGOR_sk_type(struct stack_st_X509_ALGOR *sk ) 
{ 


  {
#line 129
  return ((OPENSSL_STACK *)sk);
}
}
#line 129 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_ALGOR_compfunc_type(sk_X509_ALGOR_compfunc cmp ) 
{ 


  {
#line 129
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 129 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_ALGOR_copyfunc_type(sk_X509_ALGOR_copyfunc cpy ) 
{ 


  {
#line 129
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 129 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_ALGOR_freefunc_type(sk_X509_ALGOR_freefunc fr ) 
{ 


  {
#line 129
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 231 "/usr/include/openssl/asn1.h"
__inline static ASN1_STRING_TABLE *ossl_check_ASN1_STRING_TABLE_type(ASN1_STRING_TABLE *ptr ) 
{ 


  {
#line 231
  return (ptr);
}
}
#line 231 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_STRING_TABLE_sk_type(struct stack_st_ASN1_STRING_TABLE *sk ) 
{ 


  {
#line 231
  return ((OPENSSL_STACK *)sk);
}
}
#line 231 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_STRING_TABLE_compfunc_type(sk_ASN1_STRING_TABLE_compfunc cmp ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 231 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_STRING_TABLE_copyfunc_type(sk_ASN1_STRING_TABLE_copyfunc cpy ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 231 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_STRING_TABLE_freefunc_type(sk_ASN1_STRING_TABLE_freefunc fr ) 
{ 


  {
#line 231
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 551 "/usr/include/openssl/asn1.h"
__inline static ASN1_TYPE *ossl_check_ASN1_TYPE_type(ASN1_TYPE *ptr ) 
{ 


  {
#line 551
  return (ptr);
}
}
#line 551 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_TYPE_sk_type(struct stack_st_ASN1_TYPE *sk ) 
{ 


  {
#line 551
  return ((OPENSSL_STACK *)sk);
}
}
#line 551 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_TYPE_compfunc_type(sk_ASN1_TYPE_compfunc cmp ) 
{ 


  {
#line 551
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 551 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_TYPE_copyfunc_type(sk_ASN1_TYPE_copyfunc cpy ) 
{ 


  {
#line 551
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 551 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_TYPE_freefunc_type(sk_ASN1_TYPE_freefunc fr ) 
{ 


  {
#line 551
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 581
extern ASN1_SEQUENCE_ANY *d2i_ASN1_SEQUENCE_ANY(ASN1_SEQUENCE_ANY **a , unsigned char const   **in ,
                                                long len ) ;
#line 581
extern int i2d_ASN1_SEQUENCE_ANY(ASN1_SEQUENCE_ANY *a , unsigned char **out ) ;
#line 581
extern ASN1_ITEM *ASN1_SEQUENCE_ANY_it(void) ;
#line 582
extern ASN1_SEQUENCE_ANY *d2i_ASN1_SET_ANY(ASN1_SEQUENCE_ANY **a , unsigned char const   **in ,
                                           long len ) ;
#line 582
extern int i2d_ASN1_SET_ANY(ASN1_SEQUENCE_ANY *a , unsigned char **out ) ;
#line 582
extern ASN1_ITEM *ASN1_SET_ANY_it(void) ;
#line 620
extern ASN1_TYPE *ASN1_TYPE_new(void) ;
#line 620
extern void ASN1_TYPE_free(ASN1_TYPE *a ) ;
#line 621
extern ASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE **a , unsigned char const   **in , long len ) ;
#line 621
extern int i2d_ASN1_TYPE(ASN1_TYPE *a , unsigned char **out ) ;
#line 621
extern ASN1_ITEM *ASN1_ANY_it(void) ;
#line 623
int ASN1_TYPE_get(ASN1_TYPE *a ) ;
#line 624
void ASN1_TYPE_set(ASN1_TYPE *a , int type , void *value ) ;
#line 625
int ASN1_TYPE_set1(ASN1_TYPE *a , int type , void const   *value ) ;
#line 626
int ASN1_TYPE_cmp(ASN1_TYPE *a , ASN1_TYPE *b ) ;
#line 628
ASN1_TYPE *ASN1_TYPE_pack_sequence(ASN1_ITEM *it , void *s , ASN1_TYPE **t ) ;
#line 629
void *ASN1_TYPE_unpack_sequence(ASN1_ITEM *it , ASN1_TYPE *t ) ;
#line 631 "/usr/include/openssl/asn1.h"
__inline static ASN1_OBJECT *ossl_check_ASN1_OBJECT_type(ASN1_OBJECT *ptr ) 
{ 


  {
#line 631
  return (ptr);
}
}
#line 631 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_OBJECT_sk_type(struct stack_st_ASN1_OBJECT *sk ) 
{ 


  {
#line 631
  return ((OPENSSL_STACK *)sk);
}
}
#line 631 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_OBJECT_compfunc_type(sk_ASN1_OBJECT_compfunc cmp ) 
{ 


  {
#line 631
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 631 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_OBJECT_copyfunc_type(sk_ASN1_OBJECT_copyfunc cpy ) 
{ 


  {
#line 631
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 631 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_OBJECT_freefunc_type(sk_ASN1_OBJECT_freefunc fr ) 
{ 


  {
#line 631
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 659
extern ASN1_OBJECT *ASN1_OBJECT_new(void) ;
#line 659
extern void ASN1_OBJECT_free(ASN1_OBJECT *a ) ;
#line 659
extern ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a , unsigned char const   **in ,
                                    long len ) ;
#line 659
extern int i2d_ASN1_OBJECT(ASN1_OBJECT *a , unsigned char **out ) ;
#line 659
extern ASN1_ITEM *ASN1_OBJECT_it(void) ;
#line 661
ASN1_STRING *ASN1_STRING_new(void) ;
#line 662
void ASN1_STRING_free(ASN1_STRING *a ) ;
#line 663
void ASN1_STRING_clear_free(ASN1_STRING *a ) ;
#line 664
int ASN1_STRING_copy(ASN1_STRING *dst , ASN1_STRING *str ) ;
#line 665
extern ASN1_STRING *ASN1_STRING_dup(ASN1_STRING *a ) ;
#line 666
ASN1_STRING *ASN1_STRING_type_new(int type ) ;
#line 667
int ASN1_STRING_cmp(ASN1_STRING *a , ASN1_STRING *b ) ;
#line 672
int ASN1_STRING_set(ASN1_STRING *str , void const   *data , int len ) ;
#line 673
void ASN1_STRING_set0(ASN1_STRING *str , void *data , int len ) ;
#line 674
int ASN1_STRING_length(ASN1_STRING *x ) ;
#line 676
void ASN1_STRING_length_set(ASN1_STRING *x , int n ) ;
#line 678
int ASN1_STRING_type(ASN1_STRING *x ) ;
#line 680
unsigned char *ASN1_STRING_data(ASN1_STRING *x ) ;
#line 682
unsigned char const   *ASN1_STRING_get0_data(ASN1_STRING *x ) ;
#line 684
extern ASN1_BIT_STRING *ASN1_BIT_STRING_new(void) ;
#line 684
extern void ASN1_BIT_STRING_free(ASN1_BIT_STRING *a ) ;
#line 684
extern ASN1_BIT_STRING *d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a , unsigned char const   **in ,
                                            long len ) ;
#line 684
extern int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a , unsigned char **out ) ;
#line 684
extern ASN1_ITEM *ASN1_BIT_STRING_it(void) ;
#line 685
int ASN1_BIT_STRING_set(ASN1_BIT_STRING *a , unsigned char *d , int length ) ;
#line 686
int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a , int n , int value ) ;
#line 687
int ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a , int n ) ;
#line 688
int ASN1_BIT_STRING_check(ASN1_BIT_STRING *a , unsigned char const   *flags , int flags_len ) ;
#line 691
int ASN1_BIT_STRING_name_print(BIO *out , ASN1_BIT_STRING *bs , BIT_STRING_BITNAME *tbl ,
                               int indent ) ;
#line 693
int ASN1_BIT_STRING_num_asc(char const   *name , BIT_STRING_BITNAME *tbl ) ;
#line 694
int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs , char const   *name , int value ,
                            BIT_STRING_BITNAME *tbl ) ;
#line 697 "/usr/include/openssl/asn1.h"
__inline static ASN1_INTEGER *ossl_check_ASN1_INTEGER_type(ASN1_INTEGER *ptr ) 
{ 


  {
#line 697
  return (ptr);
}
}
#line 697 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_INTEGER_sk_type(struct stack_st_ASN1_INTEGER *sk ) 
{ 


  {
#line 697
  return ((OPENSSL_STACK *)sk);
}
}
#line 697 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_INTEGER_compfunc_type(sk_ASN1_INTEGER_compfunc cmp ) 
{ 


  {
#line 697
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 697 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_INTEGER_copyfunc_type(sk_ASN1_INTEGER_copyfunc cpy ) 
{ 


  {
#line 697
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 697 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_INTEGER_freefunc_type(sk_ASN1_INTEGER_freefunc fr ) 
{ 


  {
#line 697
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 726
extern ASN1_INTEGER *ASN1_INTEGER_new(void) ;
#line 726
extern void ASN1_INTEGER_free(ASN1_INTEGER *a ) ;
#line 726
extern ASN1_INTEGER *d2i_ASN1_INTEGER(ASN1_INTEGER **a , unsigned char const   **in ,
                                      long len ) ;
#line 726
extern int i2d_ASN1_INTEGER(ASN1_INTEGER *a , unsigned char **out ) ;
#line 726
extern ASN1_ITEM *ASN1_INTEGER_it(void) ;
#line 727
ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a , unsigned char const   **pp , long length ) ;
#line 729
extern ASN1_INTEGER *ASN1_INTEGER_dup(ASN1_INTEGER *a ) ;
#line 730
int ASN1_INTEGER_cmp(ASN1_INTEGER *x , ASN1_INTEGER *y ) ;
#line 732
extern ASN1_ENUMERATED *ASN1_ENUMERATED_new(void) ;
#line 732
extern void ASN1_ENUMERATED_free(ASN1_ENUMERATED *a ) ;
#line 732
extern ASN1_ENUMERATED *d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **a , unsigned char const   **in ,
                                            long len ) ;
#line 732
extern int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a , unsigned char **out ) ;
#line 732
extern ASN1_ITEM *ASN1_ENUMERATED_it(void) ;
#line 734
int ASN1_UTCTIME_check(ASN1_UTCTIME *a ) ;
#line 735
ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s , time_t t ) ;
#line 736
ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s , time_t t , int offset_day , long offset_sec ) ;
#line 738
int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s , char const   *str ) ;
#line 739
int ASN1_UTCTIME_cmp_time_t(ASN1_UTCTIME *s , time_t t ) ;
#line 741
int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *a ) ;
#line 742
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s , time_t t ) ;
#line 744
ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s , time_t t ,
                                               int offset_day , long offset_sec ) ;
#line 747
int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s , char const   *str ) ;
#line 749
int ASN1_TIME_diff(int *pday , int *psec , ASN1_TIME *from , ASN1_TIME *to ) ;
#line 752
extern ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void) ;
#line 752
extern void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a ) ;
#line 752
extern ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a , unsigned char const   **in ,
                                                long len ) ;
#line 752
extern int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *a , unsigned char **out ) ;
#line 752
extern ASN1_ITEM *ASN1_OCTET_STRING_it(void) ;
#line 753
extern ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(ASN1_OCTET_STRING *a ) ;
#line 754
int ASN1_OCTET_STRING_cmp(ASN1_OCTET_STRING *a , ASN1_OCTET_STRING *b ) ;
#line 756
int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str , unsigned char const   *data , int len ) ;
#line 759 "/usr/include/openssl/asn1.h"
__inline static ASN1_UTF8STRING *ossl_check_ASN1_UTF8STRING_type(ASN1_UTF8STRING *ptr ) 
{ 


  {
#line 759
  return (ptr);
}
}
#line 759 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_UTF8STRING_sk_type(struct stack_st_ASN1_UTF8STRING *sk ) 
{ 


  {
#line 759
  return ((OPENSSL_STACK *)sk);
}
}
#line 759 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_UTF8STRING_compfunc_type(sk_ASN1_UTF8STRING_compfunc cmp ) 
{ 


  {
#line 759
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 759 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_UTF8STRING_copyfunc_type(sk_ASN1_UTF8STRING_copyfunc cpy ) 
{ 


  {
#line 759
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 759 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_UTF8STRING_freefunc_type(sk_ASN1_UTF8STRING_freefunc fr ) 
{ 


  {
#line 759
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 787
extern ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void) ;
#line 787
extern void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *a ) ;
#line 787
extern ASN1_VISIBLESTRING *d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING **a , unsigned char const   **in ,
                                                  long len ) ;
#line 787
extern int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a , unsigned char **out ) ;
#line 787
extern ASN1_ITEM *ASN1_VISIBLESTRING_it(void) ;
#line 788
extern ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void) ;
#line 788
extern void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *a ) ;
#line 788
extern ASN1_UNIVERSALSTRING *d2i_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING **a , unsigned char const   **in ,
                                                      long len ) ;
#line 788
extern int i2d_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING *a , unsigned char **out ) ;
#line 788
extern ASN1_ITEM *ASN1_UNIVERSALSTRING_it(void) ;
#line 789
extern ASN1_UTF8STRING *ASN1_UTF8STRING_new(void) ;
#line 789
extern void ASN1_UTF8STRING_free(ASN1_UTF8STRING *a ) ;
#line 789
extern ASN1_UTF8STRING *d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **a , unsigned char const   **in ,
                                            long len ) ;
#line 789
extern int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a , unsigned char **out ) ;
#line 789
extern ASN1_ITEM *ASN1_UTF8STRING_it(void) ;
#line 790
extern ASN1_NULL *ASN1_NULL_new(void) ;
#line 790
extern void ASN1_NULL_free(ASN1_NULL *a ) ;
#line 790
extern ASN1_NULL *d2i_ASN1_NULL(ASN1_NULL **a , unsigned char const   **in , long len ) ;
#line 790
extern int i2d_ASN1_NULL(ASN1_NULL *a , unsigned char **out ) ;
#line 790
extern ASN1_ITEM *ASN1_NULL_it(void) ;
#line 791
extern ASN1_BMPSTRING *ASN1_BMPSTRING_new(void) ;
#line 791
extern void ASN1_BMPSTRING_free(ASN1_BMPSTRING *a ) ;
#line 791
extern ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a , unsigned char const   **in ,
                                          long len ) ;
#line 791
extern int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a , unsigned char **out ) ;
#line 791
extern ASN1_ITEM *ASN1_BMPSTRING_it(void) ;
#line 793
int UTF8_getc(unsigned char const   *str , int len , unsigned long *val ) ;
#line 794
int UTF8_putc(unsigned char *str , int len , unsigned long value ) ;
#line 796 "/usr/include/openssl/asn1.h"
__inline static ASN1_GENERALSTRING *ossl_check_ASN1_GENERALSTRING_type(ASN1_GENERALSTRING *ptr ) 
{ 


  {
#line 796
  return (ptr);
}
}
#line 796 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_GENERALSTRING_sk_type(struct stack_st_ASN1_GENERALSTRING *sk ) 
{ 


  {
#line 796
  return ((OPENSSL_STACK *)sk);
}
}
#line 796 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_GENERALSTRING_compfunc_type(sk_ASN1_GENERALSTRING_compfunc cmp ) 
{ 


  {
#line 796
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 796 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_GENERALSTRING_copyfunc_type(sk_ASN1_GENERALSTRING_copyfunc cpy ) 
{ 


  {
#line 796
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 796 "/usr/include/openssl/asn1.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_GENERALSTRING_freefunc_type(sk_ASN1_GENERALSTRING_freefunc fr ) 
{ 


  {
#line 796
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 824
extern ASN1_STRING *ASN1_PRINTABLE_new(void) ;
#line 824
extern void ASN1_PRINTABLE_free(ASN1_STRING *a ) ;
#line 824
extern ASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING **a , unsigned char const   **in ,
                                       long len ) ;
#line 824
extern int i2d_ASN1_PRINTABLE(ASN1_STRING *a , unsigned char **out ) ;
#line 824
extern ASN1_ITEM *ASN1_PRINTABLE_it(void) ;
#line 826
extern ASN1_STRING *DIRECTORYSTRING_new(void) ;
#line 826
extern void DIRECTORYSTRING_free(ASN1_STRING *a ) ;
#line 826
extern ASN1_STRING *d2i_DIRECTORYSTRING(ASN1_STRING **a , unsigned char const   **in ,
                                        long len ) ;
#line 826
extern int i2d_DIRECTORYSTRING(ASN1_STRING *a , unsigned char **out ) ;
#line 826
extern ASN1_ITEM *DIRECTORYSTRING_it(void) ;
#line 827
extern ASN1_STRING *DISPLAYTEXT_new(void) ;
#line 827
extern void DISPLAYTEXT_free(ASN1_STRING *a ) ;
#line 827
extern ASN1_STRING *d2i_DISPLAYTEXT(ASN1_STRING **a , unsigned char const   **in ,
                                    long len ) ;
#line 827
extern int i2d_DISPLAYTEXT(ASN1_STRING *a , unsigned char **out ) ;
#line 827
extern ASN1_ITEM *DISPLAYTEXT_it(void) ;
#line 828
extern ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void) ;
#line 828
extern void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *a ) ;
#line 828
extern ASN1_PRINTABLESTRING *d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING **a , unsigned char const   **in ,
                                                      long len ) ;
#line 828
extern int i2d_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING *a , unsigned char **out ) ;
#line 828
extern ASN1_ITEM *ASN1_PRINTABLESTRING_it(void) ;
#line 829
extern ASN1_T61STRING *ASN1_T61STRING_new(void) ;
#line 829
extern void ASN1_T61STRING_free(ASN1_T61STRING *a ) ;
#line 829
extern ASN1_T61STRING *d2i_ASN1_T61STRING(ASN1_T61STRING **a , unsigned char const   **in ,
                                          long len ) ;
#line 829
extern int i2d_ASN1_T61STRING(ASN1_T61STRING *a , unsigned char **out ) ;
#line 829
extern ASN1_ITEM *ASN1_T61STRING_it(void) ;
#line 830
extern ASN1_IA5STRING *ASN1_IA5STRING_new(void) ;
#line 830
extern void ASN1_IA5STRING_free(ASN1_IA5STRING *a ) ;
#line 830
extern ASN1_IA5STRING *d2i_ASN1_IA5STRING(ASN1_IA5STRING **a , unsigned char const   **in ,
                                          long len ) ;
#line 830
extern int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a , unsigned char **out ) ;
#line 830
extern ASN1_ITEM *ASN1_IA5STRING_it(void) ;
#line 831
extern ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void) ;
#line 831
extern void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *a ) ;
#line 831
extern ASN1_GENERALSTRING *d2i_ASN1_GENERALSTRING(ASN1_GENERALSTRING **a , unsigned char const   **in ,
                                                  long len ) ;
#line 831
extern int i2d_ASN1_GENERALSTRING(ASN1_GENERALSTRING *a , unsigned char **out ) ;
#line 831
extern ASN1_ITEM *ASN1_GENERALSTRING_it(void) ;
#line 832
extern ASN1_UTCTIME *ASN1_UTCTIME_new(void) ;
#line 832
extern void ASN1_UTCTIME_free(ASN1_UTCTIME *a ) ;
#line 832
extern ASN1_UTCTIME *d2i_ASN1_UTCTIME(ASN1_UTCTIME **a , unsigned char const   **in ,
                                      long len ) ;
#line 832
extern int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a , unsigned char **out ) ;
#line 832
extern ASN1_ITEM *ASN1_UTCTIME_it(void) ;
#line 833
extern ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void) ;
#line 833
extern void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *a ) ;
#line 833
extern ASN1_GENERALIZEDTIME *d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME **a , unsigned char const   **in ,
                                                      long len ) ;
#line 833
extern int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a , unsigned char **out ) ;
#line 833
extern ASN1_ITEM *ASN1_GENERALIZEDTIME_it(void) ;
#line 834
extern ASN1_TIME *ASN1_TIME_new(void) ;
#line 834
extern void ASN1_TIME_free(ASN1_TIME *a ) ;
#line 834
extern ASN1_TIME *d2i_ASN1_TIME(ASN1_TIME **a , unsigned char const   **in , long len ) ;
#line 834
extern int i2d_ASN1_TIME(ASN1_TIME *a , unsigned char **out ) ;
#line 834
extern ASN1_ITEM *ASN1_TIME_it(void) ;
#line 836
extern ASN1_TIME *ASN1_TIME_dup(ASN1_TIME *a ) ;
#line 837
extern ASN1_UTCTIME *ASN1_UTCTIME_dup(ASN1_UTCTIME *a ) ;
#line 838
extern ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_dup(ASN1_GENERALIZEDTIME *a ) ;
#line 840
extern ASN1_ITEM *ASN1_OCTET_STRING_NDEF_it(void) ;
#line 842
ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s , time_t t ) ;
#line 843
ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s , time_t t , int offset_day , long offset_sec ) ;
#line 845
int ASN1_TIME_check(ASN1_TIME *t ) ;
#line 846
ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t , ASN1_GENERALIZEDTIME **out ) ;
#line 848
int ASN1_TIME_set_string(ASN1_TIME *s , char const   *str ) ;
#line 849
int ASN1_TIME_set_string_X509(ASN1_TIME *s , char const   *str ) ;
#line 850
int ASN1_TIME_to_tm(ASN1_TIME *s , struct tm *tm ) ;
#line 851
int ASN1_TIME_normalize(ASN1_TIME *s ) ;
#line 852
int ASN1_TIME_cmp_time_t(ASN1_TIME *s , time_t t ) ;
#line 853
int ASN1_TIME_compare(ASN1_TIME *a , ASN1_TIME *b ) ;
#line 855
int i2a_ASN1_INTEGER(BIO *bp , ASN1_INTEGER *a ) ;
#line 856
int a2i_ASN1_INTEGER(BIO *bp , ASN1_INTEGER *bs , char *buf , int size ) ;
#line 857
int i2a_ASN1_ENUMERATED(BIO *bp , ASN1_ENUMERATED *a ) ;
#line 858
int a2i_ASN1_ENUMERATED(BIO *bp , ASN1_ENUMERATED *bs , char *buf , int size ) ;
#line 859
int i2a_ASN1_OBJECT(BIO *bp , ASN1_OBJECT *a ) ;
#line 860
int a2i_ASN1_STRING(BIO *bp , ASN1_STRING *bs , char *buf , int size ) ;
#line 861
int i2a_ASN1_STRING(BIO *bp , ASN1_STRING *a , int type ) ;
#line 862
int i2t_ASN1_OBJECT(char *buf , int buf_len , ASN1_OBJECT *a ) ;
#line 864
int a2d_ASN1_OBJECT(unsigned char *out , int olen , char const   *buf , int num ) ;
#line 865
ASN1_OBJECT *ASN1_OBJECT_create(int nid , unsigned char *data , int len , char const   *sn ,
                                char const   *ln ) ;
#line 868
int ASN1_INTEGER_get_int64(int64_t *pr , ASN1_INTEGER *a ) ;
#line 869
int ASN1_INTEGER_set_int64(ASN1_INTEGER *a , int64_t r ) ;
#line 870
int ASN1_INTEGER_get_uint64(uint64_t *pr , ASN1_INTEGER *a ) ;
#line 871
int ASN1_INTEGER_set_uint64(ASN1_INTEGER *a , uint64_t r ) ;
#line 873
int ASN1_INTEGER_set(ASN1_INTEGER *a , long v ) ;
#line 874
long ASN1_INTEGER_get(ASN1_INTEGER *a ) ;
#line 875
ASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *bn , ASN1_INTEGER *ai ) ;
#line 876
BIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *ai , BIGNUM *bn ) ;
#line 878
int ASN1_ENUMERATED_get_int64(int64_t *pr , ASN1_ENUMERATED *a ) ;
#line 879
int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a , int64_t r ) ;
#line 882
int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a , long v ) ;
#line 883
long ASN1_ENUMERATED_get(ASN1_ENUMERATED *a ) ;
#line 884
ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(BIGNUM *bn , ASN1_ENUMERATED *ai ) ;
#line 885
BIGNUM *ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai , BIGNUM *bn ) ;
#line 889
int ASN1_PRINTABLE_type(unsigned char const   *s , int max ) ;
#line 891
unsigned long ASN1_tag2bit(int tag ) ;
#line 894
int ASN1_get_object(unsigned char const   **pp , long *plength , int *ptag , int *pclass ,
                    long omax ) ;
#line 896
int ASN1_check_infinite_end(unsigned char **p , long len ) ;
#line 897
int ASN1_const_check_infinite_end(unsigned char const   **p , long len ) ;
#line 898
void ASN1_put_object(unsigned char **pp , int constructed , int length , int tag ,
                     int xclass ) ;
#line 900
int ASN1_put_eoc(unsigned char **pp ) ;
#line 901
int ASN1_object_size(int constructed , int length , int tag ) ;
#line 904
void *ASN1_dup(i2d_of_void *i2d , d2i_of_void *d2i , void const   *x ) ;
#line 911
void *ASN1_item_dup(ASN1_ITEM *it , void const   *x ) ;
#line 912
int ASN1_item_sign_ex(ASN1_ITEM *it , X509_ALGOR *algor1 , X509_ALGOR *algor2 , ASN1_BIT_STRING *signature ,
                      void const   *data , ASN1_OCTET_STRING *id , EVP_PKEY *pkey ,
                      EVP_MD *md , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 917
int ASN1_item_verify_ex(ASN1_ITEM *it , X509_ALGOR *alg , ASN1_BIT_STRING *signature ,
                        void const   *data , ASN1_OCTET_STRING *id , EVP_PKEY *pkey ,
                        OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 929
void *ASN1_d2i_fp(void *(*xnew)(void) , d2i_of_void *d2i , FILE *in , void **x ) ;
#line 937
void *ASN1_item_d2i_fp_ex(ASN1_ITEM *it , FILE *in , void *x , OSSL_LIB_CTX *libctx ,
                          char const   *propq ) ;
#line 939
void *ASN1_item_d2i_fp(ASN1_ITEM *it , FILE *in , void *x ) ;
#line 940
int ASN1_i2d_fp(i2d_of_void *i2d , FILE *out , void const   *x ) ;
#line 947
int ASN1_item_i2d_fp(ASN1_ITEM *it , FILE *out , void const   *x ) ;
#line 948
int ASN1_STRING_print_ex_fp(FILE *fp , ASN1_STRING *str , unsigned long flags ) ;
#line 951
int ASN1_STRING_to_UTF8(unsigned char **out , ASN1_STRING *in ) ;
#line 953
void *ASN1_d2i_bio(void *(*xnew)(void) , d2i_of_void *d2i , BIO *in , void **x ) ;
#line 961
void *ASN1_item_d2i_bio_ex(ASN1_ITEM *it , BIO *in , void *pval , OSSL_LIB_CTX *libctx ,
                           char const   *propq ) ;
#line 963
void *ASN1_item_d2i_bio(ASN1_ITEM *it , BIO *in , void *pval ) ;
#line 964
int ASN1_i2d_bio(i2d_of_void *i2d , BIO *out , void const   *x ) ;
#line 971
int ASN1_item_i2d_bio(ASN1_ITEM *it , BIO *out , void const   *x ) ;
#line 972
BIO *ASN1_item_i2d_mem_bio(ASN1_ITEM *it , ASN1_VALUE *val ) ;
#line 973
int ASN1_UTCTIME_print(BIO *fp , ASN1_UTCTIME *a ) ;
#line 974
int ASN1_GENERALIZEDTIME_print(BIO *fp , ASN1_GENERALIZEDTIME *a ) ;
#line 975
int ASN1_TIME_print(BIO *bp , ASN1_TIME *tm ) ;
#line 976
int ASN1_TIME_print_ex(BIO *bp , ASN1_TIME *tm , unsigned long flags ) ;
#line 977
int ASN1_STRING_print(BIO *bp , ASN1_STRING *v ) ;
#line 978
int ASN1_STRING_print_ex(BIO *out , ASN1_STRING *str , unsigned long flags ) ;
#line 979
int ASN1_buf_print(BIO *bp , unsigned char const   *buf , size_t buflen , int off ) ;
#line 980
int ASN1_bn_print(BIO *bp , char const   *number , BIGNUM *num , unsigned char *buf ,
                  int off ) ;
#line 982
int ASN1_parse(BIO *bp , unsigned char const   *pp , long len , int indent ) ;
#line 983
int ASN1_parse_dump(BIO *bp , unsigned char const   *pp , long len , int indent ,
                    int dump ) ;
#line 985
char const   *ASN1_tag2str(int tag ) ;
#line 989
int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s ) ;
#line 991
int ASN1_TYPE_set_octetstring(ASN1_TYPE *a , unsigned char *data , int len ) ;
#line 992
int ASN1_TYPE_get_octetstring(ASN1_TYPE *a , unsigned char *data , int max_len ) ;
#line 993
int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a , long num , unsigned char *data ,
                                  int len ) ;
#line 995
int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a , long *num , unsigned char *data ,
                                  int max_len ) ;
#line 998
void *ASN1_item_unpack(ASN1_STRING *oct , ASN1_ITEM *it ) ;
#line 1000
ASN1_STRING *ASN1_item_pack(void *obj , ASN1_ITEM *it , ASN1_OCTET_STRING **oct ) ;
#line 1003
void ASN1_STRING_set_default_mask(unsigned long mask ) ;
#line 1004
int ASN1_STRING_set_default_mask_asc(char const   *p ) ;
#line 1005
unsigned long ASN1_STRING_get_default_mask(void) ;
#line 1006
int ASN1_mbstring_copy(ASN1_STRING **out , unsigned char const   *in , int len , int inform ,
                       unsigned long mask ) ;
#line 1008
int ASN1_mbstring_ncopy(ASN1_STRING **out , unsigned char const   *in , int len ,
                        int inform , unsigned long mask , long minsize , long maxsize ) ;
#line 1012
ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out , unsigned char const   *in ,
                                    int inlen , int inform , int nid ) ;
#line 1015
ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid ) ;
#line 1016
int ASN1_STRING_TABLE_add(int  , long  , long  , unsigned long  , unsigned long  ) ;
#line 1017
void ASN1_STRING_TABLE_cleanup(void) ;
#line 1022
ASN1_VALUE *ASN1_item_new(ASN1_ITEM *it ) ;
#line 1023
ASN1_VALUE *ASN1_item_new_ex(ASN1_ITEM *it , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1025
void ASN1_item_free(ASN1_VALUE *val , ASN1_ITEM *it ) ;
#line 1026
ASN1_VALUE *ASN1_item_d2i_ex(ASN1_VALUE **val , unsigned char const   **in , long len ,
                             ASN1_ITEM *it , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1029
ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **val , unsigned char const   **in , long len ,
                          ASN1_ITEM *it ) ;
#line 1031
int ASN1_item_i2d(ASN1_VALUE *val , unsigned char **out , ASN1_ITEM *it ) ;
#line 1032
int ASN1_item_ndef_i2d(ASN1_VALUE *val , unsigned char **out , ASN1_ITEM *it ) ;
#line 1035
void ASN1_add_oid_module(void) ;
#line 1036
void ASN1_add_stable_module(void) ;
#line 1038
ASN1_TYPE *ASN1_generate_nconf(char const   *str , CONF *nconf ) ;
#line 1039
ASN1_TYPE *ASN1_generate_v3(char const   *str , X509V3_CTX *cnf ) ;
#line 1040
int ASN1_str2mask(char const   *str , unsigned long *pmask ) ;
#line 1063
int ASN1_item_print(BIO *out , ASN1_VALUE *ifld , int indent , ASN1_ITEM *it , ASN1_PCTX *pctx ) ;
#line 1065
ASN1_PCTX *ASN1_PCTX_new(void) ;
#line 1066
void ASN1_PCTX_free(ASN1_PCTX *p ) ;
#line 1067
unsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p ) ;
#line 1068
void ASN1_PCTX_set_flags(ASN1_PCTX *p , unsigned long flags ) ;
#line 1069
unsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p ) ;
#line 1070
void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p , unsigned long flags ) ;
#line 1071
unsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p ) ;
#line 1072
void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p , unsigned long flags ) ;
#line 1073
unsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p ) ;
#line 1074
void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p , unsigned long flags ) ;
#line 1075
unsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p ) ;
#line 1076
void ASN1_PCTX_set_str_flags(ASN1_PCTX *p , unsigned long flags ) ;
#line 1078
ASN1_SCTX *ASN1_SCTX_new(int (*scan_cb)(ASN1_SCTX * ) ) ;
#line 1079
void ASN1_SCTX_free(ASN1_SCTX *p ) ;
#line 1080
ASN1_ITEM *ASN1_SCTX_get_item(ASN1_SCTX *p ) ;
#line 1081
ASN1_TEMPLATE *ASN1_SCTX_get_template(ASN1_SCTX *p ) ;
#line 1082
unsigned long ASN1_SCTX_get_flags(ASN1_SCTX *p ) ;
#line 1083
void ASN1_SCTX_set_app_data(ASN1_SCTX *p , void *data ) ;
#line 1084
void *ASN1_SCTX_get_app_data(ASN1_SCTX *p ) ;
#line 1086
BIO_METHOD *BIO_f_asn1(void) ;
#line 1089
BIO *BIO_new_NDEF(BIO *out , ASN1_VALUE *val , ASN1_ITEM *it ) ;
#line 1091
int i2d_ASN1_bio_stream(BIO *out , ASN1_VALUE *val , BIO *in , int flags , ASN1_ITEM *it ) ;
#line 1093
int PEM_write_bio_ASN1_stream(BIO *out , ASN1_VALUE *val , BIO *in , int flags , char const   *hdr ,
                              ASN1_ITEM *it ) ;
#line 1096
int SMIME_write_ASN1(BIO *bio , ASN1_VALUE *val , BIO *data , int flags , int ctype_nid ,
                     int econt_nid , struct stack_st_X509_ALGOR *mdalgs , ASN1_ITEM *it ) ;
#line 1099
int SMIME_write_ASN1_ex(BIO *bio , ASN1_VALUE *val , BIO *data , int flags , int ctype_nid ,
                        int econt_nid , struct stack_st_X509_ALGOR *mdalgs , ASN1_ITEM *it ,
                        OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1103
ASN1_VALUE *SMIME_read_ASN1(BIO *bio , BIO **bcont , ASN1_ITEM *it ) ;
#line 1104
ASN1_VALUE *SMIME_read_ASN1_ex(BIO *bio , int flags , BIO **bcont , ASN1_ITEM *it ,
                               ASN1_VALUE **x , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1107
int SMIME_crlf_copy(BIO *in , BIO *out , int flags ) ;
#line 1108
int SMIME_text(BIO *in , BIO *out ) ;
#line 1110
ASN1_ITEM *ASN1_ITEM_lookup(char const   *name ) ;
#line 1111
ASN1_ITEM *ASN1_ITEM_get(size_t i ) ;
#line 52 "/usr/include/openssl/objects.h"
int OBJ_NAME_init(void) ;
#line 53
int OBJ_NAME_new_index(unsigned long (*hash_func)(char const   * ) , int (*cmp_func)(char const   * ,
                                                                                     char const   * ) ,
                       void (*free_func)(char const   * , int  , char const   * ) ) ;
#line 56
char const   *OBJ_NAME_get(char const   *name , int type ) ;
#line 57
int OBJ_NAME_add(char const   *name , int type , char const   *data ) ;
#line 58
int OBJ_NAME_remove(char const   *name , int type ) ;
#line 59
void OBJ_NAME_cleanup(int type ) ;
#line 60
void OBJ_NAME_do_all(int type , void (*fn)(OBJ_NAME * , void * ) , void *arg ) ;
#line 62
void OBJ_NAME_do_all_sorted(int type , void (*fn)(OBJ_NAME * , void * ) , void *arg ) ;
#line 66
extern ASN1_OBJECT *OBJ_dup(ASN1_OBJECT *a ) ;
#line 67
ASN1_OBJECT *OBJ_nid2obj(int n ) ;
#line 68
char const   *OBJ_nid2ln(int n ) ;
#line 69
char const   *OBJ_nid2sn(int n ) ;
#line 70
int OBJ_obj2nid(ASN1_OBJECT *o ) ;
#line 71
ASN1_OBJECT *OBJ_txt2obj(char const   *s , int no_name ) ;
#line 72
int OBJ_obj2txt(char *buf , int buf_len , ASN1_OBJECT *a , int no_name ) ;
#line 73
int OBJ_txt2nid(char const   *s ) ;
#line 74
int OBJ_ln2nid(char const   *s ) ;
#line 75
int OBJ_sn2nid(char const   *s ) ;
#line 76
int OBJ_cmp(ASN1_OBJECT *a , ASN1_OBJECT *b ) ;
#line 77
void const   *OBJ_bsearch_(void const   *key , void const   *base , int num , int size ,
                           int (*cmp)(void const   * , void const   * ) ) ;
#line 79
void const   *OBJ_bsearch_ex_(void const   *key , void const   *base , int num , int size ,
                              int (*cmp)(void const   * , void const   * ) , int flags ) ;
#line 163
int OBJ_new_nid(int num ) ;
#line 164
int OBJ_add_object(ASN1_OBJECT *obj ) ;
#line 165
int OBJ_create(char const   *oid , char const   *sn , char const   *ln ) ;
#line 169
int OBJ_create_objects(BIO *in ) ;
#line 171
size_t OBJ_length(ASN1_OBJECT *obj ) ;
#line 172
unsigned char const   *OBJ_get0_data(ASN1_OBJECT *obj ) ;
#line 174
int OBJ_find_sigid_algs(int signid , int *pdig_nid , int *ppkey_nid ) ;
#line 175
int OBJ_find_sigid_by_algs(int *psignid , int dig_nid , int pkey_nid ) ;
#line 176
int OBJ_add_sigid(int signid , int dig_id , int pkey_id ) ;
#line 177
void OBJ_sigid_free(void) ;
#line 97 "/usr/include/openssl/evp.h"
int EVP_set_default_properties(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 98
int EVP_default_properties_is_fips_enabled(OSSL_LIB_CTX *libctx ) ;
#line 99
int EVP_default_properties_enable_fips(OSSL_LIB_CTX *libctx , int enable ) ;
#line 108
EVP_MD *EVP_MD_meth_new(int md_type , int pkey_type ) ;
#line 109
EVP_MD *EVP_MD_meth_dup(EVP_MD *md ) ;
#line 110
void EVP_MD_meth_free(EVP_MD *md ) ;
#line 112
int EVP_MD_meth_set_input_blocksize(EVP_MD *md , int blocksize ) ;
#line 114
int EVP_MD_meth_set_result_size(EVP_MD *md , int resultsize ) ;
#line 116
int EVP_MD_meth_set_app_datasize(EVP_MD *md , int datasize ) ;
#line 118
int EVP_MD_meth_set_flags(EVP_MD *md , unsigned long flags ) ;
#line 120
int EVP_MD_meth_set_init(EVP_MD *md , int (*init)(EVP_MD_CTX * ) ) ;
#line 122
int EVP_MD_meth_set_update(EVP_MD *md , int (*update)(EVP_MD_CTX * , void const   * ,
                                                      size_t  ) ) ;
#line 126
int EVP_MD_meth_set_final(EVP_MD *md , int (*final)(EVP_MD_CTX * , unsigned char * ) ) ;
#line 129
int EVP_MD_meth_set_copy(EVP_MD *md , int (*copy)(EVP_MD_CTX * , EVP_MD_CTX * ) ) ;
#line 132
int EVP_MD_meth_set_cleanup(EVP_MD *md , int (*cleanup)(EVP_MD_CTX * ) ) ;
#line 134
int EVP_MD_meth_set_ctrl(EVP_MD *md , int (*ctrl)(EVP_MD_CTX * , int  , int  , void * ) ) ;
#line 136
int EVP_MD_meth_get_input_blocksize(EVP_MD *md ) ;
#line 137
int EVP_MD_meth_get_result_size(EVP_MD *md ) ;
#line 138
int EVP_MD_meth_get_app_datasize(EVP_MD *md ) ;
#line 139
unsigned long EVP_MD_meth_get_flags(EVP_MD *md ) ;
#line 141
int (*EVP_MD_meth_get_init(EVP_MD *md ))(EVP_MD_CTX * ) ;
#line 143
int (*EVP_MD_meth_get_update(EVP_MD *md ))(EVP_MD_CTX * , void const   * , size_t  ) ;
#line 146
int (*EVP_MD_meth_get_final(EVP_MD *md ))(EVP_MD_CTX * , unsigned char * ) ;
#line 149
int (*EVP_MD_meth_get_copy(EVP_MD *md ))(EVP_MD_CTX * , EVP_MD_CTX * ) ;
#line 152
int (*EVP_MD_meth_get_cleanup(EVP_MD *md ))(EVP_MD_CTX * ) ;
#line 154
int (*EVP_MD_meth_get_ctrl(EVP_MD *md ))(EVP_MD_CTX * , int  , int  , void * ) ;
#line 232
EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type , int block_size , int key_len ) ;
#line 234
EVP_CIPHER *EVP_CIPHER_meth_dup(EVP_CIPHER *cipher ) ;
#line 236
void EVP_CIPHER_meth_free(EVP_CIPHER *cipher ) ;
#line 238
int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher , int iv_len ) ;
#line 240
int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher , unsigned long flags ) ;
#line 242
int EVP_CIPHER_meth_set_impl_ctx_size(EVP_CIPHER *cipher , int ctx_size ) ;
#line 244
int EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher , int (*init)(EVP_CIPHER_CTX * , unsigned char const   * ,
                                                              unsigned char const   * ,
                                                              int  ) ) ;
#line 250
int EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher , int (*do_cipher)(EVP_CIPHER_CTX * ,
                                                                        unsigned char * ,
                                                                        unsigned char const   * ,
                                                                        size_t  ) ) ;
#line 256
int EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher , int (*cleanup)(EVP_CIPHER_CTX * ) ) ;
#line 259
int EVP_CIPHER_meth_set_set_asn1_params(EVP_CIPHER *cipher , int (*set_asn1_parameters)(EVP_CIPHER_CTX * ,
                                                                                        ASN1_TYPE * ) ) ;
#line 263
int EVP_CIPHER_meth_set_get_asn1_params(EVP_CIPHER *cipher , int (*get_asn1_parameters)(EVP_CIPHER_CTX * ,
                                                                                        ASN1_TYPE * ) ) ;
#line 267
int EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher , int (*ctrl)(EVP_CIPHER_CTX * , int  ,
                                                              int  , void * ) ) ;
#line 271
int (*EVP_CIPHER_meth_get_init(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * , unsigned char const   * ,
                                                     unsigned char const   * , int  ) ;
#line 276
int (*EVP_CIPHER_meth_get_do_cipher(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * , unsigned char * ,
                                                          unsigned char const   * ,
                                                          size_t  ) ;
#line 281
int (*EVP_CIPHER_meth_get_cleanup(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * ) ;
#line 283
int (*EVP_CIPHER_meth_get_set_asn1_params(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * ,
                                                                ASN1_TYPE * ) ;
#line 286
int (*EVP_CIPHER_meth_get_get_asn1_params(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * ,
                                                                ASN1_TYPE * ) ;
#line 289
int (*EVP_CIPHER_meth_get_ctrl(EVP_CIPHER *cipher ))(EVP_CIPHER_CTX * , int  , int  ,
                                                     void * ) ;
#line 531
int EVP_MD_get_type(EVP_MD *md ) ;
#line 534
char const   *EVP_MD_get0_name(EVP_MD *md ) ;
#line 536
char const   *EVP_MD_get0_description(EVP_MD *md ) ;
#line 537
int EVP_MD_is_a(EVP_MD *md , char const   *name ) ;
#line 538
int EVP_MD_names_do_all(EVP_MD *md , void (*fn)(char const   * , void * ) , void *data ) ;
#line 541
OSSL_PROVIDER *EVP_MD_get0_provider(EVP_MD *md ) ;
#line 542
int EVP_MD_get_pkey_type(EVP_MD *md ) ;
#line 544
int EVP_MD_get_size(EVP_MD *md ) ;
#line 546
int EVP_MD_get_block_size(EVP_MD *md ) ;
#line 548
unsigned long EVP_MD_get_flags(EVP_MD *md ) ;
#line 551
EVP_MD *EVP_MD_CTX_get0_md(EVP_MD_CTX *ctx ) ;
#line 552
EVP_MD *EVP_MD_CTX_get1_md(EVP_MD_CTX *ctx ) ;
#line 555
EVP_MD *EVP_MD_CTX_md(EVP_MD_CTX *ctx ) ;
#line 557
int (*EVP_MD_CTX_update_fn(EVP_MD_CTX *ctx ))(EVP_MD_CTX * , void const   * , size_t  ) ;
#line 560
void EVP_MD_CTX_set_update_fn(EVP_MD_CTX *ctx , int (*update)(EVP_MD_CTX * , void const   * ,
                                                              size_t  ) ) ;
#line 571
EVP_PKEY_CTX *EVP_MD_CTX_get_pkey_ctx(EVP_MD_CTX *ctx ) ;
#line 573
void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx , EVP_PKEY_CTX *pctx ) ;
#line 574
void *EVP_MD_CTX_get0_md_data(EVP_MD_CTX *ctx ) ;
#line 577
int EVP_CIPHER_get_nid(EVP_CIPHER *cipher ) ;
#line 579
char const   *EVP_CIPHER_get0_name(EVP_CIPHER *cipher ) ;
#line 581
char const   *EVP_CIPHER_get0_description(EVP_CIPHER *cipher ) ;
#line 582
int EVP_CIPHER_is_a(EVP_CIPHER *cipher , char const   *name ) ;
#line 583
int EVP_CIPHER_names_do_all(EVP_CIPHER *cipher , void (*fn)(char const   * , void * ) ,
                            void *data ) ;
#line 586
OSSL_PROVIDER *EVP_CIPHER_get0_provider(EVP_CIPHER *cipher ) ;
#line 587
int EVP_CIPHER_get_block_size(EVP_CIPHER *cipher ) ;
#line 591
int EVP_CIPHER_impl_ctx_size(EVP_CIPHER *cipher ) ;
#line 593
int EVP_CIPHER_get_key_length(EVP_CIPHER *cipher ) ;
#line 595
int EVP_CIPHER_get_iv_length(EVP_CIPHER *cipher ) ;
#line 597
unsigned long EVP_CIPHER_get_flags(EVP_CIPHER *cipher ) ;
#line 599
int EVP_CIPHER_get_mode(EVP_CIPHER *cipher ) ;
#line 601
int EVP_CIPHER_get_type(EVP_CIPHER *cipher ) ;
#line 603
EVP_CIPHER *EVP_CIPHER_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 605
int EVP_CIPHER_up_ref(EVP_CIPHER *cipher ) ;
#line 606
void EVP_CIPHER_free(EVP_CIPHER *cipher ) ;
#line 608
EVP_CIPHER *EVP_CIPHER_CTX_get0_cipher(EVP_CIPHER_CTX *ctx ) ;
#line 609
EVP_CIPHER *EVP_CIPHER_CTX_get1_cipher(EVP_CIPHER_CTX *ctx ) ;
#line 610
int EVP_CIPHER_CTX_is_encrypting(EVP_CIPHER_CTX *ctx ) ;
#line 612
int EVP_CIPHER_CTX_get_nid(EVP_CIPHER_CTX *ctx ) ;
#line 614
int EVP_CIPHER_CTX_get_block_size(EVP_CIPHER_CTX *ctx ) ;
#line 616
int EVP_CIPHER_CTX_get_key_length(EVP_CIPHER_CTX *ctx ) ;
#line 618
int EVP_CIPHER_CTX_get_iv_length(EVP_CIPHER_CTX *ctx ) ;
#line 620
int EVP_CIPHER_CTX_get_tag_length(EVP_CIPHER_CTX *ctx ) ;
#line 623
EVP_CIPHER *EVP_CIPHER_CTX_cipher(EVP_CIPHER_CTX *ctx ) ;
#line 624
unsigned char const   *EVP_CIPHER_CTX_iv(EVP_CIPHER_CTX *ctx ) ;
#line 625
unsigned char const   *EVP_CIPHER_CTX_original_iv(EVP_CIPHER_CTX *ctx ) ;
#line 626
unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx ) ;
#line 628
int EVP_CIPHER_CTX_get_updated_iv(EVP_CIPHER_CTX *ctx , void *buf , size_t len ) ;
#line 629
int EVP_CIPHER_CTX_get_original_iv(EVP_CIPHER_CTX *ctx , void *buf , size_t len ) ;
#line 632
unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx ) ;
#line 634
int EVP_CIPHER_CTX_get_num(EVP_CIPHER_CTX *ctx ) ;
#line 636
int EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx , int num ) ;
#line 637
int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out , EVP_CIPHER_CTX *in ) ;
#line 638
void *EVP_CIPHER_CTX_get_app_data(EVP_CIPHER_CTX *ctx ) ;
#line 639
void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx , void *data ) ;
#line 640
void *EVP_CIPHER_CTX_get_cipher_data(EVP_CIPHER_CTX *ctx ) ;
#line 641
void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx , void *cipher_data ) ;
#line 674
int EVP_Cipher(EVP_CIPHER_CTX *c , unsigned char *out , unsigned char const   *in ,
               unsigned int inl ) ;
#line 687
int EVP_MD_get_params(EVP_MD *digest , OSSL_PARAM params[] ) ;
#line 688
int EVP_MD_CTX_set_params(EVP_MD_CTX *ctx , OSSL_PARAM params[] ) ;
#line 689
int EVP_MD_CTX_get_params(EVP_MD_CTX *ctx , OSSL_PARAM params[] ) ;
#line 690
OSSL_PARAM *EVP_MD_gettable_params(EVP_MD *digest ) ;
#line 691
OSSL_PARAM *EVP_MD_settable_ctx_params(EVP_MD *md ) ;
#line 692
OSSL_PARAM *EVP_MD_gettable_ctx_params(EVP_MD *md ) ;
#line 693
OSSL_PARAM *EVP_MD_CTX_settable_params(EVP_MD_CTX *ctx ) ;
#line 694
OSSL_PARAM *EVP_MD_CTX_gettable_params(EVP_MD_CTX *ctx ) ;
#line 695
int EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx , int cmd , int p1 , void *p2 ) ;
#line 696
EVP_MD_CTX *EVP_MD_CTX_new(void) ;
#line 697
int EVP_MD_CTX_reset(EVP_MD_CTX *ctx ) ;
#line 698
void EVP_MD_CTX_free(EVP_MD_CTX *ctx ) ;
#line 702
int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out , EVP_MD_CTX *in ) ;
#line 703
void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx , int flags ) ;
#line 704
void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx , int flags ) ;
#line 705
int EVP_MD_CTX_test_flags(EVP_MD_CTX *ctx , int flags ) ;
#line 706
int EVP_DigestInit_ex2(EVP_MD_CTX *ctx , EVP_MD *type , OSSL_PARAM params[] ) ;
#line 708
int EVP_DigestInit_ex(EVP_MD_CTX *ctx , EVP_MD *type , ENGINE *impl ) ;
#line 710
int EVP_DigestUpdate(EVP_MD_CTX *ctx , void const   *d , size_t cnt ) ;
#line 712
int EVP_DigestFinal_ex(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 714
int EVP_Digest(void const   *data , size_t count , unsigned char *md , unsigned int *size ,
               EVP_MD *type , ENGINE *impl ) ;
#line 717
int EVP_Q_digest(OSSL_LIB_CTX *libctx , char const   *name , char const   *propq ,
                 void const   *data , size_t datalen , unsigned char *md , size_t *mdlen ) ;
#line 721
int EVP_MD_CTX_copy(EVP_MD_CTX *out , EVP_MD_CTX *in ) ;
#line 722
int EVP_DigestInit(EVP_MD_CTX *ctx , EVP_MD *type ) ;
#line 723
int EVP_DigestFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s ) ;
#line 725
int EVP_DigestFinalXOF(EVP_MD_CTX *ctx , unsigned char *md , size_t len ) ;
#line 728
EVP_MD *EVP_MD_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 731
int EVP_MD_up_ref(EVP_MD *md ) ;
#line 732
void EVP_MD_free(EVP_MD *md ) ;
#line 734
int EVP_read_pw_string(char *buf , int length , char const   *prompt , int verify ) ;
#line 735
int EVP_read_pw_string_min(char *buf , int minlen , int maxlen , char const   *prompt ,
                           int verify ) ;
#line 737
void EVP_set_pw_prompt(char const   *prompt ) ;
#line 738
char *EVP_get_pw_prompt(void) ;
#line 740
int EVP_BytesToKey(EVP_CIPHER *type , EVP_MD *md , unsigned char const   *salt , unsigned char const   *data ,
                   int datal , int count , unsigned char *key , unsigned char *iv ) ;
#line 745
void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx , int flags ) ;
#line 746
void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx , int flags ) ;
#line 747
int EVP_CIPHER_CTX_test_flags(EVP_CIPHER_CTX *ctx , int flags ) ;
#line 749
int EVP_EncryptInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                    unsigned char const   *iv ) ;
#line 751
int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , ENGINE *impl , unsigned char const   *key ,
                       unsigned char const   *iv ) ;
#line 755
int EVP_EncryptInit_ex2(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                        unsigned char const   *iv , OSSL_PARAM params[] ) ;
#line 759
int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl , unsigned char const   *in ,
                      int inl ) ;
#line 761
int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ) ;
#line 763
int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ) ;
#line 766
int EVP_DecryptInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                    unsigned char const   *iv ) ;
#line 768
int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , ENGINE *impl , unsigned char const   *key ,
                       unsigned char const   *iv ) ;
#line 772
int EVP_DecryptInit_ex2(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                        unsigned char const   *iv , OSSL_PARAM params[] ) ;
#line 776
int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl , unsigned char const   *in ,
                      int inl ) ;
#line 778
int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
#line 780
int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
#line 783
int EVP_CipherInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                   unsigned char const   *iv , int enc ) ;
#line 786
int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , ENGINE *impl , unsigned char const   *key ,
                      unsigned char const   *iv , int enc ) ;
#line 790
int EVP_CipherInit_ex2(EVP_CIPHER_CTX *ctx , EVP_CIPHER *cipher , unsigned char const   *key ,
                       unsigned char const   *iv , int enc , OSSL_PARAM params[] ) ;
#line 793
int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl , unsigned char const   *in ,
                     int inl ) ;
#line 795
int EVP_CipherFinal(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
#line 797
int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx , unsigned char *outm , int *outl ) ;
#line 800
int EVP_SignFinal(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s , EVP_PKEY *pkey ) ;
#line 802
int EVP_SignFinal_ex(EVP_MD_CTX *ctx , unsigned char *md , unsigned int *s , EVP_PKEY *pkey ,
                     OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 806
int EVP_DigestSign(EVP_MD_CTX *ctx , unsigned char *sigret , size_t *siglen , unsigned char const   *tbs ,
                   size_t tbslen ) ;
#line 810
int EVP_VerifyFinal(EVP_MD_CTX *ctx , unsigned char const   *sigbuf , unsigned int siglen ,
                    EVP_PKEY *pkey ) ;
#line 812
int EVP_VerifyFinal_ex(EVP_MD_CTX *ctx , unsigned char const   *sigbuf , unsigned int siglen ,
                       EVP_PKEY *pkey , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 816
int EVP_DigestVerify(EVP_MD_CTX *ctx , unsigned char const   *sigret , size_t siglen ,
                     unsigned char const   *tbs , size_t tbslen ) ;
#line 820
int EVP_DigestSignInit_ex(EVP_MD_CTX *ctx , EVP_PKEY_CTX **pctx , char const   *mdname ,
                          OSSL_LIB_CTX *libctx , char const   *props , EVP_PKEY *pkey ,
                          OSSL_PARAM params[] ) ;
#line 824
int EVP_DigestSignInit(EVP_MD_CTX *ctx , EVP_PKEY_CTX **pctx , EVP_MD *type , ENGINE *e ,
                       EVP_PKEY *pkey ) ;
#line 827
int EVP_DigestSignUpdate(EVP_MD_CTX *ctx , void const   *data , size_t dsize ) ;
#line 828
int EVP_DigestSignFinal(EVP_MD_CTX *ctx , unsigned char *sigret , size_t *siglen ) ;
#line 831
int EVP_DigestVerifyInit_ex(EVP_MD_CTX *ctx , EVP_PKEY_CTX **pctx , char const   *mdname ,
                            OSSL_LIB_CTX *libctx , char const   *props , EVP_PKEY *pkey ,
                            OSSL_PARAM params[] ) ;
#line 835
int EVP_DigestVerifyInit(EVP_MD_CTX *ctx , EVP_PKEY_CTX **pctx , EVP_MD *type , ENGINE *e ,
                         EVP_PKEY *pkey ) ;
#line 838
int EVP_DigestVerifyUpdate(EVP_MD_CTX *ctx , void const   *data , size_t dsize ) ;
#line 839
int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx , unsigned char const   *sig , size_t siglen ) ;
#line 842
int EVP_OpenInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER *type , unsigned char const   *ek ,
                 int ekl , unsigned char const   *iv , EVP_PKEY *priv ) ;
#line 845
int EVP_OpenFinal(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ) ;
#line 847
int EVP_SealInit(EVP_CIPHER_CTX *ctx , EVP_CIPHER *type , unsigned char **ek , int *ekl ,
                 unsigned char *iv , EVP_PKEY **pubk , int npubk ) ;
#line 850
int EVP_SealFinal(EVP_CIPHER_CTX *ctx , unsigned char *out , int *outl ) ;
#line 852
EVP_ENCODE_CTX *EVP_ENCODE_CTX_new(void) ;
#line 853
void EVP_ENCODE_CTX_free(EVP_ENCODE_CTX *ctx ) ;
#line 854
int EVP_ENCODE_CTX_copy(EVP_ENCODE_CTX *dctx , EVP_ENCODE_CTX *sctx ) ;
#line 855
int EVP_ENCODE_CTX_num(EVP_ENCODE_CTX *ctx ) ;
#line 856
void EVP_EncodeInit(EVP_ENCODE_CTX *ctx ) ;
#line 857
int EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx , unsigned char *out , int *outl , unsigned char const   *in ,
                     int inl ) ;
#line 859
void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx , unsigned char *out , int *outl ) ;
#line 860
int EVP_EncodeBlock(unsigned char *t , unsigned char const   *f , int n ) ;
#line 862
void EVP_DecodeInit(EVP_ENCODE_CTX *ctx ) ;
#line 863
int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx , unsigned char *out , int *outl , unsigned char const   *in ,
                     int inl ) ;
#line 865
int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx , unsigned char *out , int *outl ) ;
#line 867
int EVP_DecodeBlock(unsigned char *t , unsigned char const   *f , int n ) ;
#line 873
EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void) ;
#line 874
int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c ) ;
#line 875
void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *c ) ;
#line 876
int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x , int keylen ) ;
#line 877
int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c , int pad ) ;
#line 878
int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx , int type , int arg , void *ptr ) ;
#line 879
int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx , unsigned char *key ) ;
#line 880
int EVP_CIPHER_get_params(EVP_CIPHER *cipher , OSSL_PARAM params[] ) ;
#line 881
int EVP_CIPHER_CTX_set_params(EVP_CIPHER_CTX *ctx , OSSL_PARAM params[] ) ;
#line 882
int EVP_CIPHER_CTX_get_params(EVP_CIPHER_CTX *ctx , OSSL_PARAM params[] ) ;
#line 883
OSSL_PARAM *EVP_CIPHER_gettable_params(EVP_CIPHER *cipher ) ;
#line 884
OSSL_PARAM *EVP_CIPHER_settable_ctx_params(EVP_CIPHER *cipher ) ;
#line 885
OSSL_PARAM *EVP_CIPHER_gettable_ctx_params(EVP_CIPHER *cipher ) ;
#line 886
OSSL_PARAM *EVP_CIPHER_CTX_settable_params(EVP_CIPHER_CTX *ctx ) ;
#line 887
OSSL_PARAM *EVP_CIPHER_CTX_gettable_params(EVP_CIPHER_CTX *ctx ) ;
#line 889
BIO_METHOD *BIO_f_md(void) ;
#line 890
BIO_METHOD *BIO_f_base64(void) ;
#line 891
BIO_METHOD *BIO_f_cipher(void) ;
#line 892
BIO_METHOD *BIO_f_reliable(void) ;
#line 893
int BIO_set_cipher(BIO *b , EVP_CIPHER *c , unsigned char const   *k , unsigned char const   *i ,
                   int enc ) ;
#line 896
EVP_MD *EVP_md_null(void) ;
#line 901
EVP_MD *EVP_md4(void) ;
#line 904
EVP_MD *EVP_md5(void) ;
#line 905
EVP_MD *EVP_md5_sha1(void) ;
#line 908
EVP_MD *EVP_blake2b512(void) ;
#line 909
EVP_MD *EVP_blake2s256(void) ;
#line 911
EVP_MD *EVP_sha1(void) ;
#line 912
EVP_MD *EVP_sha224(void) ;
#line 913
EVP_MD *EVP_sha256(void) ;
#line 914
EVP_MD *EVP_sha384(void) ;
#line 915
EVP_MD *EVP_sha512(void) ;
#line 916
EVP_MD *EVP_sha512_224(void) ;
#line 917
EVP_MD *EVP_sha512_256(void) ;
#line 918
EVP_MD *EVP_sha3_224(void) ;
#line 919
EVP_MD *EVP_sha3_256(void) ;
#line 920
EVP_MD *EVP_sha3_384(void) ;
#line 921
EVP_MD *EVP_sha3_512(void) ;
#line 922
EVP_MD *EVP_shake128(void) ;
#line 923
EVP_MD *EVP_shake256(void) ;
#line 929
EVP_MD *EVP_ripemd160(void) ;
#line 932
EVP_MD *EVP_whirlpool(void) ;
#line 935
EVP_MD *EVP_sm3(void) ;
#line 937
EVP_CIPHER *EVP_enc_null(void) ;
#line 939
EVP_CIPHER *EVP_des_ecb(void) ;
#line 940
EVP_CIPHER *EVP_des_ede(void) ;
#line 941
EVP_CIPHER *EVP_des_ede3(void) ;
#line 942
EVP_CIPHER *EVP_des_ede_ecb(void) ;
#line 943
EVP_CIPHER *EVP_des_ede3_ecb(void) ;
#line 944
EVP_CIPHER *EVP_des_cfb64(void) ;
#line 946
EVP_CIPHER *EVP_des_cfb1(void) ;
#line 947
EVP_CIPHER *EVP_des_cfb8(void) ;
#line 948
EVP_CIPHER *EVP_des_ede_cfb64(void) ;
#line 950
EVP_CIPHER *EVP_des_ede3_cfb64(void) ;
#line 952
EVP_CIPHER *EVP_des_ede3_cfb1(void) ;
#line 953
EVP_CIPHER *EVP_des_ede3_cfb8(void) ;
#line 954
EVP_CIPHER *EVP_des_ofb(void) ;
#line 955
EVP_CIPHER *EVP_des_ede_ofb(void) ;
#line 956
EVP_CIPHER *EVP_des_ede3_ofb(void) ;
#line 957
EVP_CIPHER *EVP_des_cbc(void) ;
#line 958
EVP_CIPHER *EVP_des_ede_cbc(void) ;
#line 959
EVP_CIPHER *EVP_des_ede3_cbc(void) ;
#line 960
EVP_CIPHER *EVP_desx_cbc(void) ;
#line 961
EVP_CIPHER *EVP_des_ede3_wrap(void) ;
#line 969
EVP_CIPHER *EVP_rc4(void) ;
#line 970
EVP_CIPHER *EVP_rc4_40(void) ;
#line 972
EVP_CIPHER *EVP_rc4_hmac_md5(void) ;
#line 983
EVP_CIPHER *EVP_rc2_ecb(void) ;
#line 984
EVP_CIPHER *EVP_rc2_cbc(void) ;
#line 985
EVP_CIPHER *EVP_rc2_40_cbc(void) ;
#line 986
EVP_CIPHER *EVP_rc2_64_cbc(void) ;
#line 987
EVP_CIPHER *EVP_rc2_cfb64(void) ;
#line 989
EVP_CIPHER *EVP_rc2_ofb(void) ;
#line 992
EVP_CIPHER *EVP_bf_ecb(void) ;
#line 993
EVP_CIPHER *EVP_bf_cbc(void) ;
#line 994
EVP_CIPHER *EVP_bf_cfb64(void) ;
#line 996
EVP_CIPHER *EVP_bf_ofb(void) ;
#line 999
EVP_CIPHER *EVP_cast5_ecb(void) ;
#line 1000
EVP_CIPHER *EVP_cast5_cbc(void) ;
#line 1001
EVP_CIPHER *EVP_cast5_cfb64(void) ;
#line 1003
EVP_CIPHER *EVP_cast5_ofb(void) ;
#line 1012
EVP_CIPHER *EVP_aes_128_ecb(void) ;
#line 1013
EVP_CIPHER *EVP_aes_128_cbc(void) ;
#line 1014
EVP_CIPHER *EVP_aes_128_cfb1(void) ;
#line 1015
EVP_CIPHER *EVP_aes_128_cfb8(void) ;
#line 1016
EVP_CIPHER *EVP_aes_128_cfb128(void) ;
#line 1018
EVP_CIPHER *EVP_aes_128_ofb(void) ;
#line 1019
EVP_CIPHER *EVP_aes_128_ctr(void) ;
#line 1020
EVP_CIPHER *EVP_aes_128_ccm(void) ;
#line 1021
EVP_CIPHER *EVP_aes_128_gcm(void) ;
#line 1022
EVP_CIPHER *EVP_aes_128_xts(void) ;
#line 1023
EVP_CIPHER *EVP_aes_128_wrap(void) ;
#line 1024
EVP_CIPHER *EVP_aes_128_wrap_pad(void) ;
#line 1026
EVP_CIPHER *EVP_aes_128_ocb(void) ;
#line 1028
EVP_CIPHER *EVP_aes_192_ecb(void) ;
#line 1029
EVP_CIPHER *EVP_aes_192_cbc(void) ;
#line 1030
EVP_CIPHER *EVP_aes_192_cfb1(void) ;
#line 1031
EVP_CIPHER *EVP_aes_192_cfb8(void) ;
#line 1032
EVP_CIPHER *EVP_aes_192_cfb128(void) ;
#line 1034
EVP_CIPHER *EVP_aes_192_ofb(void) ;
#line 1035
EVP_CIPHER *EVP_aes_192_ctr(void) ;
#line 1036
EVP_CIPHER *EVP_aes_192_ccm(void) ;
#line 1037
EVP_CIPHER *EVP_aes_192_gcm(void) ;
#line 1038
EVP_CIPHER *EVP_aes_192_wrap(void) ;
#line 1039
EVP_CIPHER *EVP_aes_192_wrap_pad(void) ;
#line 1041
EVP_CIPHER *EVP_aes_192_ocb(void) ;
#line 1043
EVP_CIPHER *EVP_aes_256_ecb(void) ;
#line 1044
EVP_CIPHER *EVP_aes_256_cbc(void) ;
#line 1045
EVP_CIPHER *EVP_aes_256_cfb1(void) ;
#line 1046
EVP_CIPHER *EVP_aes_256_cfb8(void) ;
#line 1047
EVP_CIPHER *EVP_aes_256_cfb128(void) ;
#line 1049
EVP_CIPHER *EVP_aes_256_ofb(void) ;
#line 1050
EVP_CIPHER *EVP_aes_256_ctr(void) ;
#line 1051
EVP_CIPHER *EVP_aes_256_ccm(void) ;
#line 1052
EVP_CIPHER *EVP_aes_256_gcm(void) ;
#line 1053
EVP_CIPHER *EVP_aes_256_xts(void) ;
#line 1054
EVP_CIPHER *EVP_aes_256_wrap(void) ;
#line 1055
EVP_CIPHER *EVP_aes_256_wrap_pad(void) ;
#line 1057
EVP_CIPHER *EVP_aes_256_ocb(void) ;
#line 1059
EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void) ;
#line 1060
EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void) ;
#line 1061
EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void) ;
#line 1062
EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void) ;
#line 1064
EVP_CIPHER *EVP_aria_128_ecb(void) ;
#line 1065
EVP_CIPHER *EVP_aria_128_cbc(void) ;
#line 1066
EVP_CIPHER *EVP_aria_128_cfb1(void) ;
#line 1067
EVP_CIPHER *EVP_aria_128_cfb8(void) ;
#line 1068
EVP_CIPHER *EVP_aria_128_cfb128(void) ;
#line 1070
EVP_CIPHER *EVP_aria_128_ctr(void) ;
#line 1071
EVP_CIPHER *EVP_aria_128_ofb(void) ;
#line 1072
EVP_CIPHER *EVP_aria_128_gcm(void) ;
#line 1073
EVP_CIPHER *EVP_aria_128_ccm(void) ;
#line 1074
EVP_CIPHER *EVP_aria_192_ecb(void) ;
#line 1075
EVP_CIPHER *EVP_aria_192_cbc(void) ;
#line 1076
EVP_CIPHER *EVP_aria_192_cfb1(void) ;
#line 1077
EVP_CIPHER *EVP_aria_192_cfb8(void) ;
#line 1078
EVP_CIPHER *EVP_aria_192_cfb128(void) ;
#line 1080
EVP_CIPHER *EVP_aria_192_ctr(void) ;
#line 1081
EVP_CIPHER *EVP_aria_192_ofb(void) ;
#line 1082
EVP_CIPHER *EVP_aria_192_gcm(void) ;
#line 1083
EVP_CIPHER *EVP_aria_192_ccm(void) ;
#line 1084
EVP_CIPHER *EVP_aria_256_ecb(void) ;
#line 1085
EVP_CIPHER *EVP_aria_256_cbc(void) ;
#line 1086
EVP_CIPHER *EVP_aria_256_cfb1(void) ;
#line 1087
EVP_CIPHER *EVP_aria_256_cfb8(void) ;
#line 1088
EVP_CIPHER *EVP_aria_256_cfb128(void) ;
#line 1090
EVP_CIPHER *EVP_aria_256_ctr(void) ;
#line 1091
EVP_CIPHER *EVP_aria_256_ofb(void) ;
#line 1092
EVP_CIPHER *EVP_aria_256_gcm(void) ;
#line 1093
EVP_CIPHER *EVP_aria_256_ccm(void) ;
#line 1096
EVP_CIPHER *EVP_camellia_128_ecb(void) ;
#line 1097
EVP_CIPHER *EVP_camellia_128_cbc(void) ;
#line 1098
EVP_CIPHER *EVP_camellia_128_cfb1(void) ;
#line 1099
EVP_CIPHER *EVP_camellia_128_cfb8(void) ;
#line 1100
EVP_CIPHER *EVP_camellia_128_cfb128(void) ;
#line 1102
EVP_CIPHER *EVP_camellia_128_ofb(void) ;
#line 1103
EVP_CIPHER *EVP_camellia_128_ctr(void) ;
#line 1104
EVP_CIPHER *EVP_camellia_192_ecb(void) ;
#line 1105
EVP_CIPHER *EVP_camellia_192_cbc(void) ;
#line 1106
EVP_CIPHER *EVP_camellia_192_cfb1(void) ;
#line 1107
EVP_CIPHER *EVP_camellia_192_cfb8(void) ;
#line 1108
EVP_CIPHER *EVP_camellia_192_cfb128(void) ;
#line 1110
EVP_CIPHER *EVP_camellia_192_ofb(void) ;
#line 1111
EVP_CIPHER *EVP_camellia_192_ctr(void) ;
#line 1112
EVP_CIPHER *EVP_camellia_256_ecb(void) ;
#line 1113
EVP_CIPHER *EVP_camellia_256_cbc(void) ;
#line 1114
EVP_CIPHER *EVP_camellia_256_cfb1(void) ;
#line 1115
EVP_CIPHER *EVP_camellia_256_cfb8(void) ;
#line 1116
EVP_CIPHER *EVP_camellia_256_cfb128(void) ;
#line 1118
EVP_CIPHER *EVP_camellia_256_ofb(void) ;
#line 1119
EVP_CIPHER *EVP_camellia_256_ctr(void) ;
#line 1122
EVP_CIPHER *EVP_chacha20(void) ;
#line 1124
EVP_CIPHER *EVP_chacha20_poly1305(void) ;
#line 1129
EVP_CIPHER *EVP_seed_ecb(void) ;
#line 1130
EVP_CIPHER *EVP_seed_cbc(void) ;
#line 1131
EVP_CIPHER *EVP_seed_cfb128(void) ;
#line 1133
EVP_CIPHER *EVP_seed_ofb(void) ;
#line 1137
EVP_CIPHER *EVP_sm4_ecb(void) ;
#line 1138
EVP_CIPHER *EVP_sm4_cbc(void) ;
#line 1139
EVP_CIPHER *EVP_sm4_cfb128(void) ;
#line 1141
EVP_CIPHER *EVP_sm4_ofb(void) ;
#line 1142
EVP_CIPHER *EVP_sm4_ctr(void) ;
#line 1168
int EVP_add_cipher(EVP_CIPHER *cipher ) ;
#line 1169
int EVP_add_digest(EVP_MD *digest ) ;
#line 1171
EVP_CIPHER *EVP_get_cipherbyname(char const   *name ) ;
#line 1172
EVP_MD *EVP_get_digestbyname(char const   *name ) ;
#line 1174
void EVP_CIPHER_do_all(void (*fn)(EVP_CIPHER * , char const   * , char const   * ,
                                  void * ) , void *arg ) ;
#line 1177
void EVP_CIPHER_do_all_sorted(void (*fn)(EVP_CIPHER * , char const   * , char const   * ,
                                         void * ) , void *arg ) ;
#line 1180
void EVP_CIPHER_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_CIPHER * , void * ) ,
                                void *arg ) ;
#line 1184
void EVP_MD_do_all(void (*fn)(EVP_MD * , char const   * , char const   * , void * ) ,
                   void *arg ) ;
#line 1187
void EVP_MD_do_all_sorted(void (*fn)(EVP_MD * , char const   * , char const   * ,
                                     void * ) , void *arg ) ;
#line 1190
void EVP_MD_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_MD * , void * ) ,
                            void *arg ) ;
#line 1196
EVP_MAC *EVP_MAC_fetch(OSSL_LIB_CTX *libctx , char const   *algorithm , char const   *properties ) ;
#line 1198
int EVP_MAC_up_ref(EVP_MAC *mac ) ;
#line 1199
void EVP_MAC_free(EVP_MAC *mac ) ;
#line 1200
char const   *EVP_MAC_get0_name(EVP_MAC *mac ) ;
#line 1201
char const   *EVP_MAC_get0_description(EVP_MAC *mac ) ;
#line 1202
int EVP_MAC_is_a(EVP_MAC *mac , char const   *name ) ;
#line 1203
OSSL_PROVIDER *EVP_MAC_get0_provider(EVP_MAC *mac ) ;
#line 1204
int EVP_MAC_get_params(EVP_MAC *mac , OSSL_PARAM params[] ) ;
#line 1206
EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *mac ) ;
#line 1207
void EVP_MAC_CTX_free(EVP_MAC_CTX *ctx ) ;
#line 1208
EVP_MAC_CTX *EVP_MAC_CTX_dup(EVP_MAC_CTX *src ) ;
#line 1209
EVP_MAC *EVP_MAC_CTX_get0_mac(EVP_MAC_CTX *ctx ) ;
#line 1210
int EVP_MAC_CTX_get_params(EVP_MAC_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1211
int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1213
size_t EVP_MAC_CTX_get_mac_size(EVP_MAC_CTX *ctx ) ;
#line 1214
size_t EVP_MAC_CTX_get_block_size(EVP_MAC_CTX *ctx ) ;
#line 1215
unsigned char *EVP_Q_mac(OSSL_LIB_CTX *libctx , char const   *name , char const   *propq ,
                         char const   *subalg , OSSL_PARAM *params , void const   *key ,
                         size_t keylen , unsigned char const   *data , size_t datalen ,
                         unsigned char *out , size_t outsize , size_t *outlen ) ;
#line 1220
int EVP_MAC_init(EVP_MAC_CTX *ctx , unsigned char const   *key , size_t keylen , OSSL_PARAM params[] ) ;
#line 1222
int EVP_MAC_update(EVP_MAC_CTX *ctx , unsigned char const   *data , size_t datalen ) ;
#line 1223
int EVP_MAC_final(EVP_MAC_CTX *ctx , unsigned char *out , size_t *outl , size_t outsize ) ;
#line 1225
int EVP_MAC_finalXOF(EVP_MAC_CTX *ctx , unsigned char *out , size_t outsize ) ;
#line 1226
OSSL_PARAM *EVP_MAC_gettable_params(EVP_MAC *mac ) ;
#line 1227
OSSL_PARAM *EVP_MAC_gettable_ctx_params(EVP_MAC *mac ) ;
#line 1228
OSSL_PARAM *EVP_MAC_settable_ctx_params(EVP_MAC *mac ) ;
#line 1229
OSSL_PARAM *EVP_MAC_CTX_gettable_params(EVP_MAC_CTX *ctx ) ;
#line 1230
OSSL_PARAM *EVP_MAC_CTX_settable_params(EVP_MAC_CTX *ctx ) ;
#line 1232
void EVP_MAC_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_MAC * , void * ) ,
                             void *arg ) ;
#line 1235
int EVP_MAC_names_do_all(EVP_MAC *mac , void (*fn)(char const   * , void * ) , void *data ) ;
#line 1240
EVP_RAND *EVP_RAND_fetch(OSSL_LIB_CTX *libctx , char const   *algorithm , char const   *properties ) ;
#line 1242
int EVP_RAND_up_ref(EVP_RAND *rand ) ;
#line 1243
void EVP_RAND_free(EVP_RAND *rand ) ;
#line 1244
char const   *EVP_RAND_get0_name(EVP_RAND *rand ) ;
#line 1245
char const   *EVP_RAND_get0_description(EVP_RAND *md ) ;
#line 1246
int EVP_RAND_is_a(EVP_RAND *rand , char const   *name ) ;
#line 1247
OSSL_PROVIDER *EVP_RAND_get0_provider(EVP_RAND *rand ) ;
#line 1248
int EVP_RAND_get_params(EVP_RAND *rand , OSSL_PARAM params[] ) ;
#line 1250
EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand , EVP_RAND_CTX *parent ) ;
#line 1251
void EVP_RAND_CTX_free(EVP_RAND_CTX *ctx ) ;
#line 1252
EVP_RAND *EVP_RAND_CTX_get0_rand(EVP_RAND_CTX *ctx ) ;
#line 1253
int EVP_RAND_CTX_get_params(EVP_RAND_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1254
int EVP_RAND_CTX_set_params(EVP_RAND_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1255
OSSL_PARAM *EVP_RAND_gettable_params(EVP_RAND *rand ) ;
#line 1256
OSSL_PARAM *EVP_RAND_gettable_ctx_params(EVP_RAND *rand ) ;
#line 1257
OSSL_PARAM *EVP_RAND_settable_ctx_params(EVP_RAND *rand ) ;
#line 1258
OSSL_PARAM *EVP_RAND_CTX_gettable_params(EVP_RAND_CTX *ctx ) ;
#line 1259
OSSL_PARAM *EVP_RAND_CTX_settable_params(EVP_RAND_CTX *ctx ) ;
#line 1261
void EVP_RAND_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_RAND * , void * ) ,
                              void *arg ) ;
#line 1264
int EVP_RAND_names_do_all(EVP_RAND *rand , void (*fn)(char const   * , void * ) ,
                          void *data ) ;
#line 1268
int EVP_RAND_instantiate(EVP_RAND_CTX *ctx , unsigned int strength , int prediction_resistance ,
                         unsigned char const   *pstr , size_t pstr_len , OSSL_PARAM params[] ) ;
#line 1272
int EVP_RAND_uninstantiate(EVP_RAND_CTX *ctx ) ;
#line 1273
int EVP_RAND_generate(EVP_RAND_CTX *ctx , unsigned char *out , size_t outlen , unsigned int strength ,
                      int prediction_resistance , unsigned char const   *addin , size_t addin_len ) ;
#line 1277
int EVP_RAND_reseed(EVP_RAND_CTX *ctx , int prediction_resistance , unsigned char const   *ent ,
                    size_t ent_len , unsigned char const   *addin , size_t addin_len ) ;
#line 1280
int EVP_RAND_nonce(EVP_RAND_CTX *ctx , unsigned char *out , size_t outlen ) ;
#line 1281
int EVP_RAND_enable_locking(EVP_RAND_CTX *ctx ) ;
#line 1283
int EVP_RAND_verify_zeroization(EVP_RAND_CTX *ctx ) ;
#line 1284
unsigned int EVP_RAND_get_strength(EVP_RAND_CTX *ctx ) ;
#line 1285
int EVP_RAND_get_state(EVP_RAND_CTX *ctx ) ;
#line 1293
int EVP_PKEY_decrypt_old(unsigned char *dec_key , unsigned char const   *enc_key ,
                         int enc_key_len , EVP_PKEY *private_key ) ;
#line 1297
int EVP_PKEY_encrypt_old(unsigned char *enc_key , unsigned char const   *key , int key_len ,
                         EVP_PKEY *pub_key ) ;
#line 1301
int EVP_PKEY_is_a(EVP_PKEY *pkey , char const   *name ) ;
#line 1302
int EVP_PKEY_type_names_do_all(EVP_PKEY *pkey , void (*fn)(char const   * , void * ) ,
                               void *data ) ;
#line 1305
int EVP_PKEY_type(int type ) ;
#line 1306
int EVP_PKEY_get_id(EVP_PKEY *pkey ) ;
#line 1308
int EVP_PKEY_get_base_id(EVP_PKEY *pkey ) ;
#line 1310
int EVP_PKEY_get_bits(EVP_PKEY *pkey ) ;
#line 1312
int EVP_PKEY_get_security_bits(EVP_PKEY *pkey ) ;
#line 1314
int EVP_PKEY_get_size(EVP_PKEY *pkey ) ;
#line 1316
int EVP_PKEY_can_sign(EVP_PKEY *pkey ) ;
#line 1317
int EVP_PKEY_set_type(EVP_PKEY *pkey , int type ) ;
#line 1318
int EVP_PKEY_set_type_str(EVP_PKEY *pkey , char const   *str , int len ) ;
#line 1319
int EVP_PKEY_set_type_by_keymgmt(EVP_PKEY *pkey , EVP_KEYMGMT *keymgmt ) ;
#line 1323
int EVP_PKEY_set1_engine(EVP_PKEY *pkey , ENGINE *e ) ;
#line 1325
ENGINE *EVP_PKEY_get0_engine(EVP_PKEY *pkey ) ;
#line 1328
int EVP_PKEY_assign(EVP_PKEY *pkey , int type , void *key ) ;
#line 1330
void *EVP_PKEY_get0(EVP_PKEY *pkey ) ;
#line 1332
unsigned char const   *EVP_PKEY_get0_hmac(EVP_PKEY *pkey , size_t *len ) ;
#line 1335
unsigned char const   *EVP_PKEY_get0_poly1305(EVP_PKEY *pkey , size_t *len ) ;
#line 1339
unsigned char const   *EVP_PKEY_get0_siphash(EVP_PKEY *pkey , size_t *len ) ;
#line 1344
int EVP_PKEY_set1_RSA(EVP_PKEY *pkey , struct rsa_st *key ) ;
#line 1346
struct rsa_st *EVP_PKEY_get0_RSA(EVP_PKEY *pkey ) ;
#line 1348
struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey ) ;
#line 1353
int EVP_PKEY_set1_DSA(EVP_PKEY *pkey , struct dsa_st *key ) ;
#line 1355
struct dsa_st *EVP_PKEY_get0_DSA(EVP_PKEY *pkey ) ;
#line 1357
struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey ) ;
#line 1362
int EVP_PKEY_set1_DH(EVP_PKEY *pkey , struct dh_st *key ) ;
#line 1363
struct dh_st *EVP_PKEY_get0_DH(EVP_PKEY *pkey ) ;
#line 1364
struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey ) ;
#line 1370
int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey , struct ec_key_st *key ) ;
#line 1372
struct ec_key_st *EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey ) ;
#line 1374
struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey ) ;
#line 1378
EVP_PKEY *EVP_PKEY_new(void) ;
#line 1379
int EVP_PKEY_up_ref(EVP_PKEY *pkey ) ;
#line 1380
EVP_PKEY *EVP_PKEY_dup(EVP_PKEY *pkey ) ;
#line 1381
void EVP_PKEY_free(EVP_PKEY *pkey ) ;
#line 1382
char const   *EVP_PKEY_get0_description(EVP_PKEY *pkey ) ;
#line 1383
OSSL_PROVIDER *EVP_PKEY_get0_provider(EVP_PKEY *key ) ;
#line 1385
EVP_PKEY *d2i_PublicKey(int type , EVP_PKEY **a , unsigned char const   **pp , long length ) ;
#line 1387
int i2d_PublicKey(EVP_PKEY *a , unsigned char **pp ) ;
#line 1390
EVP_PKEY *d2i_PrivateKey_ex(int type , EVP_PKEY **a , unsigned char const   **pp ,
                            long length , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1393
EVP_PKEY *d2i_PrivateKey(int type , EVP_PKEY **a , unsigned char const   **pp , long length ) ;
#line 1395
EVP_PKEY *d2i_AutoPrivateKey_ex(EVP_PKEY **a , unsigned char const   **pp , long length ,
                                OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1398
EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a , unsigned char const   **pp , long length ) ;
#line 1400
int i2d_PrivateKey(EVP_PKEY *a , unsigned char **pp ) ;
#line 1402
int i2d_KeyParams(EVP_PKEY *a , unsigned char **pp ) ;
#line 1403
EVP_PKEY *d2i_KeyParams(int type , EVP_PKEY **a , unsigned char const   **pp , long length ) ;
#line 1405
int i2d_KeyParams_bio(BIO *bp , EVP_PKEY *pkey ) ;
#line 1406
EVP_PKEY *d2i_KeyParams_bio(int type , EVP_PKEY **a , BIO *in ) ;
#line 1408
int EVP_PKEY_copy_parameters(EVP_PKEY *to , EVP_PKEY *from ) ;
#line 1409
int EVP_PKEY_missing_parameters(EVP_PKEY *pkey ) ;
#line 1410
int EVP_PKEY_save_parameters(EVP_PKEY *pkey , int mode ) ;
#line 1411
int EVP_PKEY_parameters_eq(EVP_PKEY *a , EVP_PKEY *b ) ;
#line 1412
int EVP_PKEY_eq(EVP_PKEY *a , EVP_PKEY *b ) ;
#line 1416
int EVP_PKEY_cmp_parameters(EVP_PKEY *a , EVP_PKEY *b ) ;
#line 1418
int EVP_PKEY_cmp(EVP_PKEY *a , EVP_PKEY *b ) ;
#line 1421
int EVP_PKEY_print_public(BIO *out , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1423
int EVP_PKEY_print_private(BIO *out , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1425
int EVP_PKEY_print_params(BIO *out , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1428
int EVP_PKEY_print_public_fp(FILE *fp , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1430
int EVP_PKEY_print_private_fp(FILE *fp , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1432
int EVP_PKEY_print_params_fp(FILE *fp , EVP_PKEY *pkey , int indent , ASN1_PCTX *pctx ) ;
#line 1436
int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey , int *pnid ) ;
#line 1437
int EVP_PKEY_get_default_digest_name(EVP_PKEY *pkey , char *mdname , size_t mdname_sz ) ;
#line 1439
int EVP_PKEY_digestsign_supports_digest(EVP_PKEY *pkey , OSSL_LIB_CTX *libctx , char const   *name ,
                                        char const   *propq ) ;
#line 1451
int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *pkey , unsigned char const   *pub ,
                                     size_t publen ) ;
#line 1463
size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *pkey , unsigned char **ppub ) ;
#line 1466
int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c , ASN1_TYPE *type ) ;
#line 1467
int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c , ASN1_TYPE *type ) ;
#line 1470
int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c , ASN1_TYPE *type ) ;
#line 1471
int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c , ASN1_TYPE *type ) ;
#line 1474
int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx , char const   *pass , int passlen , ASN1_TYPE *param ,
                       EVP_CIPHER *cipher , EVP_MD *md , int en_de ) ;
#line 1477
int PKCS5_PBE_keyivgen_ex(EVP_CIPHER_CTX *cctx , char const   *pass , int passlen ,
                          ASN1_TYPE *param , EVP_CIPHER *cipher , EVP_MD *md , int en_de ,
                          OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1481
int PKCS5_PBKDF2_HMAC_SHA1(char const   *pass , int passlen , unsigned char const   *salt ,
                           int saltlen , int iter , int keylen , unsigned char *out ) ;
#line 1484
int PKCS5_PBKDF2_HMAC(char const   *pass , int passlen , unsigned char const   *salt ,
                      int saltlen , int iter , EVP_MD *digest , int keylen , unsigned char *out ) ;
#line 1487
int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx , char const   *pass , int passlen ,
                          ASN1_TYPE *param , EVP_CIPHER *cipher , EVP_MD *md , int en_de ) ;
#line 1490
int PKCS5_v2_PBE_keyivgen_ex(EVP_CIPHER_CTX *ctx , char const   *pass , int passlen ,
                             ASN1_TYPE *param , EVP_CIPHER *cipher , EVP_MD *md ,
                             int en_de , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1496
int EVP_PBE_scrypt(char const   *pass , size_t passlen , unsigned char const   *salt ,
                   size_t saltlen , uint64_t N , uint64_t r , uint64_t p , uint64_t maxmem ,
                   unsigned char *key , size_t keylen ) ;
#line 1500
int EVP_PBE_scrypt_ex(char const   *pass , size_t passlen , unsigned char const   *salt ,
                      size_t saltlen , uint64_t N , uint64_t r , uint64_t p , uint64_t maxmem ,
                      unsigned char *key , size_t keylen , OSSL_LIB_CTX *ctx , char const   *propq ) ;
#line 1506
int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx , char const   *pass , int passlen ,
                             ASN1_TYPE *param , EVP_CIPHER *c , EVP_MD *md , int en_de ) ;
#line 1509
int PKCS5_v2_scrypt_keyivgen_ex(EVP_CIPHER_CTX *ctx , char const   *pass , int passlen ,
                                ASN1_TYPE *param , EVP_CIPHER *c , EVP_MD *md , int en_de ,
                                OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1515
void PKCS5_PBE_add(void) ;
#line 1517
int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj , char const   *pass , int passlen , ASN1_TYPE *param ,
                       EVP_CIPHER_CTX *ctx , int en_de ) ;
#line 1520
int EVP_PBE_CipherInit_ex(ASN1_OBJECT *pbe_obj , char const   *pass , int passlen ,
                          ASN1_TYPE *param , EVP_CIPHER_CTX *ctx , int en_de , OSSL_LIB_CTX *libctx ,
                          char const   *propq ) ;
#line 1533
int EVP_PBE_alg_add_type(int pbe_type , int pbe_nid , int cipher_nid , int md_nid ,
                         EVP_PBE_KEYGEN *keygen ) ;
#line 1535
int EVP_PBE_alg_add(int nid , EVP_CIPHER *cipher , EVP_MD *md , EVP_PBE_KEYGEN *keygen ) ;
#line 1537
int EVP_PBE_find(int type , int pbe_nid , int *pcnid , int *pmnid , EVP_PBE_KEYGEN **pkeygen ) ;
#line 1539
int EVP_PBE_find_ex(int type , int pbe_nid , int *pcnid , int *pmnid , EVP_PBE_KEYGEN **pkeygen ,
                    EVP_PBE_KEYGEN_EX **pkeygen_ex ) ;
#line 1541
void EVP_PBE_cleanup(void) ;
#line 1542
int EVP_PBE_get(int *ptype , int *ppbe_nid , size_t num ) ;
#line 1559
int EVP_PKEY_asn1_get_count(void) ;
#line 1560
EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx ) ;
#line 1561
EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe , int type ) ;
#line 1562
EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe , char const   *str , int len ) ;
#line 1564
int EVP_PKEY_asn1_add0(EVP_PKEY_ASN1_METHOD *ameth ) ;
#line 1565
int EVP_PKEY_asn1_add_alias(int to , int from ) ;
#line 1566
int EVP_PKEY_asn1_get0_info(int *ppkey_id , int *pkey_base_id , int *ppkey_flags ,
                            char const   **pinfo , char const   **ppem_str , EVP_PKEY_ASN1_METHOD *ameth ) ;
#line 1571
EVP_PKEY_ASN1_METHOD *EVP_PKEY_get0_asn1(EVP_PKEY *pkey ) ;
#line 1572
EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id , int flags , char const   *pem_str ,
                                        char const   *info ) ;
#line 1575
void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst , EVP_PKEY_ASN1_METHOD *src ) ;
#line 1577
void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth ) ;
#line 1578
void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth , int (*pub_decode)(EVP_PKEY * ,
                                                                              X509_PUBKEY * ) ,
                              int (*pub_encode)(X509_PUBKEY * , EVP_PKEY * ) , int (*pub_cmp)(EVP_PKEY * ,
                                                                                              EVP_PKEY * ) ,
                              int (*pub_print)(BIO * , EVP_PKEY * , int  , ASN1_PCTX * ) ,
                              int (*pkey_size)(EVP_PKEY * ) , int (*pkey_bits)(EVP_PKEY * ) ) ;
#line 1590
void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth , int (*priv_decode)(EVP_PKEY * ,
                                                                                PKCS8_PRIV_KEY_INFO * ) ,
                               int (*priv_encode)(PKCS8_PRIV_KEY_INFO * , EVP_PKEY * ) ,
                               int (*priv_print)(BIO * , EVP_PKEY * , int  , ASN1_PCTX * ) ) ;
#line 1600
void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth , int (*param_decode)(EVP_PKEY * ,
                                                                               unsigned char const   ** ,
                                                                               int  ) ,
                             int (*param_encode)(EVP_PKEY * , unsigned char ** ) ,
                             int (*param_missing)(EVP_PKEY * ) , int (*param_copy)(EVP_PKEY * ,
                                                                                   EVP_PKEY * ) ,
                             int (*param_cmp)(EVP_PKEY * , EVP_PKEY * ) , int (*param_print)(BIO * ,
                                                                                             EVP_PKEY * ,
                                                                                             int  ,
                                                                                             ASN1_PCTX * ) ) ;
#line 1616
void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth , void (*pkey_free)(EVP_PKEY * ) ) ;
#line 1618
void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth , int (*pkey_ctrl)(EVP_PKEY * ,
                                                                           int  ,
                                                                           long  ,
                                                                           void * ) ) ;
#line 1621
void EVP_PKEY_asn1_set_item(EVP_PKEY_ASN1_METHOD *ameth , int (*item_verify)(EVP_MD_CTX * ,
                                                                             ASN1_ITEM * ,
                                                                             void const   * ,
                                                                             X509_ALGOR * ,
                                                                             ASN1_BIT_STRING * ,
                                                                             EVP_PKEY * ) ,
                            int (*item_sign)(EVP_MD_CTX * , ASN1_ITEM * , void const   * ,
                                             X509_ALGOR * , X509_ALGOR * , ASN1_BIT_STRING * ) ) ;
#line 1635
void EVP_PKEY_asn1_set_siginf(EVP_PKEY_ASN1_METHOD *ameth , int (*siginf_set)(X509_SIG_INFO * ,
                                                                              X509_ALGOR * ,
                                                                              ASN1_STRING * ) ) ;
#line 1640
void EVP_PKEY_asn1_set_check(EVP_PKEY_ASN1_METHOD *ameth , int (*pkey_check)(EVP_PKEY * ) ) ;
#line 1643
void EVP_PKEY_asn1_set_public_check(EVP_PKEY_ASN1_METHOD *ameth , int (*pkey_pub_check)(EVP_PKEY * ) ) ;
#line 1646
void EVP_PKEY_asn1_set_param_check(EVP_PKEY_ASN1_METHOD *ameth , int (*pkey_param_check)(EVP_PKEY * ) ) ;
#line 1649
void EVP_PKEY_asn1_set_set_priv_key(EVP_PKEY_ASN1_METHOD *ameth , int (*set_priv_key)(EVP_PKEY * ,
                                                                                      unsigned char const   * ,
                                                                                      size_t  ) ) ;
#line 1654
void EVP_PKEY_asn1_set_set_pub_key(EVP_PKEY_ASN1_METHOD *ameth , int (*set_pub_key)(EVP_PKEY * ,
                                                                                    unsigned char const   * ,
                                                                                    size_t  ) ) ;
#line 1658
void EVP_PKEY_asn1_set_get_priv_key(EVP_PKEY_ASN1_METHOD *ameth , int (*get_priv_key)(EVP_PKEY * ,
                                                                                      unsigned char * ,
                                                                                      size_t * ) ) ;
#line 1662
void EVP_PKEY_asn1_set_get_pub_key(EVP_PKEY_ASN1_METHOD *ameth , int (*get_pub_key)(EVP_PKEY * ,
                                                                                    unsigned char * ,
                                                                                    size_t * ) ) ;
#line 1667
void EVP_PKEY_asn1_set_security_bits(EVP_PKEY_ASN1_METHOD *ameth , int (*pkey_security_bits)(EVP_PKEY * ) ) ;
#line 1671
int EVP_PKEY_CTX_get_signature_md(EVP_PKEY_CTX *ctx , EVP_MD **md ) ;
#line 1672
int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 1674
int EVP_PKEY_CTX_set1_id(EVP_PKEY_CTX *ctx , void const   *id , int len ) ;
#line 1675
int EVP_PKEY_CTX_get1_id(EVP_PKEY_CTX *ctx , void *id ) ;
#line 1676
int EVP_PKEY_CTX_get1_id_len(EVP_PKEY_CTX *ctx , size_t *id_len ) ;
#line 1678
int EVP_PKEY_CTX_set_kem_op(EVP_PKEY_CTX *ctx , char const   *op ) ;
#line 1680
char const   *EVP_PKEY_get0_type_name(EVP_PKEY *key ) ;
#line 1711
int EVP_PKEY_CTX_set_mac_key(EVP_PKEY_CTX *ctx , unsigned char const   *key , int keylen ) ;
#line 1743
EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type ) ;
#line 1744
EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id , int flags ) ;
#line 1745
void EVP_PKEY_meth_get0_info(int *ppkey_id , int *pflags , EVP_PKEY_METHOD *meth ) ;
#line 1747
void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst , EVP_PKEY_METHOD *src ) ;
#line 1749
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth ) ;
#line 1750
int EVP_PKEY_meth_add0(EVP_PKEY_METHOD *pmeth ) ;
#line 1751
int EVP_PKEY_meth_remove(EVP_PKEY_METHOD *pmeth ) ;
#line 1752
size_t EVP_PKEY_meth_get_count(void) ;
#line 1753
EVP_PKEY_METHOD *EVP_PKEY_meth_get0(size_t idx ) ;
#line 1756
EVP_KEYMGMT *EVP_KEYMGMT_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 1758
int EVP_KEYMGMT_up_ref(EVP_KEYMGMT *keymgmt ) ;
#line 1759
void EVP_KEYMGMT_free(EVP_KEYMGMT *keymgmt ) ;
#line 1760
OSSL_PROVIDER *EVP_KEYMGMT_get0_provider(EVP_KEYMGMT *keymgmt ) ;
#line 1761
char const   *EVP_KEYMGMT_get0_name(EVP_KEYMGMT *keymgmt ) ;
#line 1762
char const   *EVP_KEYMGMT_get0_description(EVP_KEYMGMT *keymgmt ) ;
#line 1763
int EVP_KEYMGMT_is_a(EVP_KEYMGMT *keymgmt , char const   *name ) ;
#line 1764
void EVP_KEYMGMT_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_KEYMGMT * ,
                                                                   void * ) , void *arg ) ;
#line 1767
int EVP_KEYMGMT_names_do_all(EVP_KEYMGMT *keymgmt , void (*fn)(char const   * , void * ) ,
                             void *data ) ;
#line 1770
OSSL_PARAM *EVP_KEYMGMT_gettable_params(EVP_KEYMGMT *keymgmt ) ;
#line 1771
OSSL_PARAM *EVP_KEYMGMT_settable_params(EVP_KEYMGMT *keymgmt ) ;
#line 1772
OSSL_PARAM *EVP_KEYMGMT_gen_settable_params(EVP_KEYMGMT *keymgmt ) ;
#line 1774
EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey , ENGINE *e ) ;
#line 1775
EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id , ENGINE *e ) ;
#line 1776
EVP_PKEY_CTX *EVP_PKEY_CTX_new_from_name(OSSL_LIB_CTX *libctx , char const   *name ,
                                         char const   *propquery ) ;
#line 1779
EVP_PKEY_CTX *EVP_PKEY_CTX_new_from_pkey(OSSL_LIB_CTX *libctx , EVP_PKEY *pkey , char const   *propquery ) ;
#line 1781
EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx ) ;
#line 1782
void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx ) ;
#line 1783
int EVP_PKEY_CTX_is_a(EVP_PKEY_CTX *ctx , char const   *keytype ) ;
#line 1785
int EVP_PKEY_CTX_get_params(EVP_PKEY_CTX *ctx , OSSL_PARAM *params ) ;
#line 1786
OSSL_PARAM *EVP_PKEY_CTX_gettable_params(EVP_PKEY_CTX *ctx ) ;
#line 1787
int EVP_PKEY_CTX_set_params(EVP_PKEY_CTX *ctx , OSSL_PARAM *params ) ;
#line 1788
OSSL_PARAM *EVP_PKEY_CTX_settable_params(EVP_PKEY_CTX *ctx ) ;
#line 1789
int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx , int keytype , int optype , int cmd , int p1 ,
                      void *p2 ) ;
#line 1791
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx , char const   *type , char const   *value ) ;
#line 1793
int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx , int keytype , int optype , int cmd ,
                             uint64_t value ) ;
#line 1796
int EVP_PKEY_CTX_str2ctrl(EVP_PKEY_CTX *ctx , int cmd , char const   *str ) ;
#line 1797
int EVP_PKEY_CTX_hex2ctrl(EVP_PKEY_CTX *ctx , int cmd , char const   *hex ) ;
#line 1799
int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx , int optype , int cmd , char const   *md ) ;
#line 1801
int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx ) ;
#line 1802
void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx , int *dat , int datlen ) ;
#line 1804
EVP_PKEY *EVP_PKEY_new_mac_key(int type , ENGINE *e , unsigned char const   *key ,
                               int keylen ) ;
#line 1806
EVP_PKEY *EVP_PKEY_new_raw_private_key_ex(OSSL_LIB_CTX *libctx , char const   *keytype ,
                                          char const   *propq , unsigned char const   *priv ,
                                          size_t len ) ;
#line 1810
EVP_PKEY *EVP_PKEY_new_raw_private_key(int type , ENGINE *e , unsigned char const   *priv ,
                                       size_t len ) ;
#line 1813
EVP_PKEY *EVP_PKEY_new_raw_public_key_ex(OSSL_LIB_CTX *libctx , char const   *keytype ,
                                         char const   *propq , unsigned char const   *pub ,
                                         size_t len ) ;
#line 1816
EVP_PKEY *EVP_PKEY_new_raw_public_key(int type , ENGINE *e , unsigned char const   *pub ,
                                      size_t len ) ;
#line 1819
int EVP_PKEY_get_raw_private_key(EVP_PKEY *pkey , unsigned char *priv , size_t *len ) ;
#line 1821
int EVP_PKEY_get_raw_public_key(EVP_PKEY *pkey , unsigned char *pub , size_t *len ) ;
#line 1826
EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *e , unsigned char const   *priv , size_t len ,
                                EVP_CIPHER *cipher ) ;
#line 1830
void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx , void *data ) ;
#line 1831
void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx ) ;
#line 1832
EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx ) ;
#line 1834
EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx ) ;
#line 1836
void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx , void *data ) ;
#line 1837
void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx ) ;
#line 1839
void EVP_SIGNATURE_free(EVP_SIGNATURE *signature ) ;
#line 1840
int EVP_SIGNATURE_up_ref(EVP_SIGNATURE *signature ) ;
#line 1841
OSSL_PROVIDER *EVP_SIGNATURE_get0_provider(EVP_SIGNATURE *signature ) ;
#line 1842
EVP_SIGNATURE *EVP_SIGNATURE_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 1844
int EVP_SIGNATURE_is_a(EVP_SIGNATURE *signature , char const   *name ) ;
#line 1845
char const   *EVP_SIGNATURE_get0_name(EVP_SIGNATURE *signature ) ;
#line 1846
char const   *EVP_SIGNATURE_get0_description(EVP_SIGNATURE *signature ) ;
#line 1847
void EVP_SIGNATURE_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_SIGNATURE * ,
                                                                     void * ) , void *data ) ;
#line 1851
int EVP_SIGNATURE_names_do_all(EVP_SIGNATURE *signature , void (*fn)(char const   * ,
                                                                     void * ) , void *data ) ;
#line 1854
OSSL_PARAM *EVP_SIGNATURE_gettable_ctx_params(EVP_SIGNATURE *sig ) ;
#line 1855
OSSL_PARAM *EVP_SIGNATURE_settable_ctx_params(EVP_SIGNATURE *sig ) ;
#line 1857
void EVP_ASYM_CIPHER_free(EVP_ASYM_CIPHER *cipher ) ;
#line 1858
int EVP_ASYM_CIPHER_up_ref(EVP_ASYM_CIPHER *cipher ) ;
#line 1859
OSSL_PROVIDER *EVP_ASYM_CIPHER_get0_provider(EVP_ASYM_CIPHER *cipher ) ;
#line 1860
EVP_ASYM_CIPHER *EVP_ASYM_CIPHER_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm ,
                                       char const   *properties ) ;
#line 1862
int EVP_ASYM_CIPHER_is_a(EVP_ASYM_CIPHER *cipher , char const   *name ) ;
#line 1863
char const   *EVP_ASYM_CIPHER_get0_name(EVP_ASYM_CIPHER *cipher ) ;
#line 1864
char const   *EVP_ASYM_CIPHER_get0_description(EVP_ASYM_CIPHER *cipher ) ;
#line 1865
void EVP_ASYM_CIPHER_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_ASYM_CIPHER * ,
                                                                       void * ) ,
                                     void *arg ) ;
#line 1869
int EVP_ASYM_CIPHER_names_do_all(EVP_ASYM_CIPHER *cipher , void (*fn)(char const   * ,
                                                                      void * ) , void *data ) ;
#line 1872
OSSL_PARAM *EVP_ASYM_CIPHER_gettable_ctx_params(EVP_ASYM_CIPHER *ciph ) ;
#line 1873
OSSL_PARAM *EVP_ASYM_CIPHER_settable_ctx_params(EVP_ASYM_CIPHER *ciph ) ;
#line 1875
void EVP_KEM_free(EVP_KEM *wrap ) ;
#line 1876
int EVP_KEM_up_ref(EVP_KEM *wrap ) ;
#line 1877
OSSL_PROVIDER *EVP_KEM_get0_provider(EVP_KEM *wrap ) ;
#line 1878
EVP_KEM *EVP_KEM_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 1880
int EVP_KEM_is_a(EVP_KEM *wrap , char const   *name ) ;
#line 1881
char const   *EVP_KEM_get0_name(EVP_KEM *wrap ) ;
#line 1882
char const   *EVP_KEM_get0_description(EVP_KEM *wrap ) ;
#line 1883
void EVP_KEM_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_KEM * , void * ) ,
                             void *arg ) ;
#line 1885
int EVP_KEM_names_do_all(EVP_KEM *wrap , void (*fn)(char const   * , void * ) , void *data ) ;
#line 1887
OSSL_PARAM *EVP_KEM_gettable_ctx_params(EVP_KEM *kem ) ;
#line 1888
OSSL_PARAM *EVP_KEM_settable_ctx_params(EVP_KEM *kem ) ;
#line 1890
int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx ) ;
#line 1891
int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1892
int EVP_PKEY_sign(EVP_PKEY_CTX *ctx , unsigned char *sig , size_t *siglen , unsigned char const   *tbs ,
                  size_t tbslen ) ;
#line 1895
int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx ) ;
#line 1896
int EVP_PKEY_verify_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1897
int EVP_PKEY_verify(EVP_PKEY_CTX *ctx , unsigned char const   *sig , size_t siglen ,
                    unsigned char const   *tbs , size_t tbslen ) ;
#line 1900
int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx ) ;
#line 1901
int EVP_PKEY_verify_recover_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1903
int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx , unsigned char *rout , size_t *routlen ,
                            unsigned char const   *sig , size_t siglen ) ;
#line 1906
int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx ) ;
#line 1907
int EVP_PKEY_encrypt_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1908
int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx , unsigned char *out , size_t *outlen , unsigned char const   *in ,
                     size_t inlen ) ;
#line 1911
int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx ) ;
#line 1912
int EVP_PKEY_decrypt_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1913
int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx , unsigned char *out , size_t *outlen , unsigned char const   *in ,
                     size_t inlen ) ;
#line 1917
int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx ) ;
#line 1918
int EVP_PKEY_derive_init_ex(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1919
int EVP_PKEY_derive_set_peer_ex(EVP_PKEY_CTX *ctx , EVP_PKEY *peer , int validate_peer ) ;
#line 1921
int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx , EVP_PKEY *peer ) ;
#line 1922
int EVP_PKEY_derive(EVP_PKEY_CTX *ctx , unsigned char *key , size_t *keylen ) ;
#line 1924
int EVP_PKEY_encapsulate_init(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1925
int EVP_PKEY_encapsulate(EVP_PKEY_CTX *ctx , unsigned char *wrappedkey , size_t *wrappedkeylen ,
                         unsigned char *genkey , size_t *genkeylen ) ;
#line 1928
int EVP_PKEY_decapsulate_init(EVP_PKEY_CTX *ctx , OSSL_PARAM params[] ) ;
#line 1929
int EVP_PKEY_decapsulate(EVP_PKEY_CTX *ctx , unsigned char *unwrapped , size_t *unwrappedlen ,
                         unsigned char const   *wrapped , size_t wrappedlen ) ;
#line 1935
int EVP_PKEY_fromdata_init(EVP_PKEY_CTX *ctx ) ;
#line 1936
int EVP_PKEY_fromdata(EVP_PKEY_CTX *ctx , EVP_PKEY **ppkey , int selection , OSSL_PARAM param[] ) ;
#line 1938
OSSL_PARAM *EVP_PKEY_fromdata_settable(EVP_PKEY_CTX *ctx , int selection ) ;
#line 1940
int EVP_PKEY_todata(EVP_PKEY *pkey , int selection , OSSL_PARAM **params ) ;
#line 1941
int EVP_PKEY_export(EVP_PKEY *pkey , int selection , OSSL_CALLBACK *export_cb , void *export_cbarg ) ;
#line 1944
OSSL_PARAM *EVP_PKEY_gettable_params(EVP_PKEY *pkey ) ;
#line 1945
int EVP_PKEY_get_params(EVP_PKEY *pkey , OSSL_PARAM params[] ) ;
#line 1946
int EVP_PKEY_get_int_param(EVP_PKEY *pkey , char const   *key_name , int *out ) ;
#line 1948
int EVP_PKEY_get_size_t_param(EVP_PKEY *pkey , char const   *key_name , size_t *out ) ;
#line 1950
int EVP_PKEY_get_bn_param(EVP_PKEY *pkey , char const   *key_name , BIGNUM **bn ) ;
#line 1952
int EVP_PKEY_get_utf8_string_param(EVP_PKEY *pkey , char const   *key_name , char *str ,
                                   size_t max_buf_sz , size_t *out_sz ) ;
#line 1954
int EVP_PKEY_get_octet_string_param(EVP_PKEY *pkey , char const   *key_name , unsigned char *buf ,
                                    size_t max_buf_sz , size_t *out_sz ) ;
#line 1958
OSSL_PARAM *EVP_PKEY_settable_params(EVP_PKEY *pkey ) ;
#line 1959
int EVP_PKEY_set_params(EVP_PKEY *pkey , OSSL_PARAM params[] ) ;
#line 1960
int EVP_PKEY_set_int_param(EVP_PKEY *pkey , char const   *key_name , int in ) ;
#line 1961
int EVP_PKEY_set_size_t_param(EVP_PKEY *pkey , char const   *key_name , size_t in ) ;
#line 1962
int EVP_PKEY_set_bn_param(EVP_PKEY *pkey , char const   *key_name , BIGNUM *bn ) ;
#line 1964
int EVP_PKEY_set_utf8_string_param(EVP_PKEY *pkey , char const   *key_name , char const   *str ) ;
#line 1966
int EVP_PKEY_set_octet_string_param(EVP_PKEY *pkey , char const   *key_name , unsigned char const   *buf ,
                                    size_t bsize ) ;
#line 1969
int EVP_PKEY_get_ec_point_conv_form(EVP_PKEY *pkey ) ;
#line 1970
int EVP_PKEY_get_field_type(EVP_PKEY *pkey ) ;
#line 1972
EVP_PKEY *EVP_PKEY_Q_keygen(OSSL_LIB_CTX *libctx , char const   *propq , char const   *type 
                            , ...) ;
#line 1974
int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx ) ;
#line 1975
int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx , EVP_PKEY **ppkey ) ;
#line 1976
int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx ) ;
#line 1977
int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx , EVP_PKEY **ppkey ) ;
#line 1978
int EVP_PKEY_generate(EVP_PKEY_CTX *ctx , EVP_PKEY **ppkey ) ;
#line 1979
int EVP_PKEY_check(EVP_PKEY_CTX *ctx ) ;
#line 1980
int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx ) ;
#line 1981
int EVP_PKEY_public_check_quick(EVP_PKEY_CTX *ctx ) ;
#line 1982
int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx ) ;
#line 1983
int EVP_PKEY_param_check_quick(EVP_PKEY_CTX *ctx ) ;
#line 1984
int EVP_PKEY_private_check(EVP_PKEY_CTX *ctx ) ;
#line 1985
int EVP_PKEY_pairwise_check(EVP_PKEY_CTX *ctx ) ;
#line 1989
int EVP_PKEY_set_ex_data(EVP_PKEY *key , int idx , void *arg ) ;
#line 1990
void *EVP_PKEY_get_ex_data(EVP_PKEY *key , int idx ) ;
#line 1992
void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx , EVP_PKEY_gen_cb *cb ) ;
#line 1993
EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx ) ;
#line 1995
int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx , int idx ) ;
#line 1997
void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth , int (*init)(EVP_PKEY_CTX * ) ) ;
#line 1999
void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth , int (*copy)(EVP_PKEY_CTX * ,
                                                                 EVP_PKEY_CTX * ) ) ;
#line 2002
void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth , void (*cleanup)(EVP_PKEY_CTX * ) ) ;
#line 2004
void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth , int (*paramgen_init)(EVP_PKEY_CTX * ) ,
                                int (*paramgen)(EVP_PKEY_CTX * , EVP_PKEY * ) ) ;
#line 2007
void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth , int (*keygen_init)(EVP_PKEY_CTX * ) ,
                              int (*keygen)(EVP_PKEY_CTX * , EVP_PKEY * ) ) ;
#line 2010
void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth , int (*sign_init)(EVP_PKEY_CTX * ) ,
                            int (*sign)(EVP_PKEY_CTX * , unsigned char * , size_t * ,
                                        unsigned char const   * , size_t  ) ) ;
#line 2014
void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth , int (*verify_init)(EVP_PKEY_CTX * ) ,
                              int (*verify)(EVP_PKEY_CTX * , unsigned char const   * ,
                                            size_t  , unsigned char const   * , size_t  ) ) ;
#line 2018
void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth , int (*verify_recover_init)(EVP_PKEY_CTX * ) ,
                                      int (*verify_recover)(EVP_PKEY_CTX * , unsigned char * ,
                                                            size_t * , unsigned char const   * ,
                                                            size_t  ) ) ;
#line 2023
void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth , int (*signctx_init)(EVP_PKEY_CTX * ,
                                                                            EVP_MD_CTX * ) ,
                               int (*signctx)(EVP_PKEY_CTX * , unsigned char * , size_t * ,
                                              EVP_MD_CTX * ) ) ;
#line 2028
void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth , int (*verifyctx_init)(EVP_PKEY_CTX * ,
                                                                                EVP_MD_CTX * ) ,
                                 int (*verifyctx)(EVP_PKEY_CTX * , unsigned char const   * ,
                                                  int  , EVP_MD_CTX * ) ) ;
#line 2033
void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth , int (*encrypt_init)(EVP_PKEY_CTX * ) ,
                               int (*encryptfn)(EVP_PKEY_CTX * , unsigned char * ,
                                                size_t * , unsigned char const   * ,
                                                size_t  ) ) ;
#line 2037
void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth , int (*decrypt_init)(EVP_PKEY_CTX * ) ,
                               int (*decrypt)(EVP_PKEY_CTX * , unsigned char * , size_t * ,
                                              unsigned char const   * , size_t  ) ) ;
#line 2041
void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth , int (*derive_init)(EVP_PKEY_CTX * ) ,
                              int (*derive)(EVP_PKEY_CTX * , unsigned char * , size_t * ) ) ;
#line 2044
void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth , int (*ctrl)(EVP_PKEY_CTX * ,
                                                                 int  , int  , void * ) ,
                            int (*ctrl_str)(EVP_PKEY_CTX * , char const   * , char const   * ) ) ;
#line 2048
void EVP_PKEY_meth_set_digestsign(EVP_PKEY_METHOD *pmeth , int (*digestsign)(EVP_MD_CTX * ,
                                                                             unsigned char * ,
                                                                             size_t * ,
                                                                             unsigned char const   * ,
                                                                             size_t  ) ) ;
#line 2052
void EVP_PKEY_meth_set_digestverify(EVP_PKEY_METHOD *pmeth , int (*digestverify)(EVP_MD_CTX * ,
                                                                                 unsigned char const   * ,
                                                                                 size_t  ,
                                                                                 unsigned char const   * ,
                                                                                 size_t  ) ) ;
#line 2057
void EVP_PKEY_meth_set_check(EVP_PKEY_METHOD *pmeth , int (*check)(EVP_PKEY * ) ) ;
#line 2059
void EVP_PKEY_meth_set_public_check(EVP_PKEY_METHOD *pmeth , int (*check)(EVP_PKEY * ) ) ;
#line 2061
void EVP_PKEY_meth_set_param_check(EVP_PKEY_METHOD *pmeth , int (*check)(EVP_PKEY * ) ) ;
#line 2063
void EVP_PKEY_meth_set_digest_custom(EVP_PKEY_METHOD *pmeth , int (*digest_custom)(EVP_PKEY_CTX * ,
                                                                                   EVP_MD_CTX * ) ) ;
#line 2066
void EVP_PKEY_meth_get_init(EVP_PKEY_METHOD *pmeth , int (**pinit)(EVP_PKEY_CTX * ) ) ;
#line 2068
void EVP_PKEY_meth_get_copy(EVP_PKEY_METHOD *pmeth , int (**pcopy)(EVP_PKEY_CTX * ,
                                                                   EVP_PKEY_CTX * ) ) ;
#line 2071
void EVP_PKEY_meth_get_cleanup(EVP_PKEY_METHOD *pmeth , void (**pcleanup)(EVP_PKEY_CTX * ) ) ;
#line 2073
void EVP_PKEY_meth_get_paramgen(EVP_PKEY_METHOD *pmeth , int (**pparamgen_init)(EVP_PKEY_CTX * ) ,
                                int (**pparamgen)(EVP_PKEY_CTX * , EVP_PKEY * ) ) ;
#line 2076
void EVP_PKEY_meth_get_keygen(EVP_PKEY_METHOD *pmeth , int (**pkeygen_init)(EVP_PKEY_CTX * ) ,
                              int (**pkeygen)(EVP_PKEY_CTX * , EVP_PKEY * ) ) ;
#line 2079
void EVP_PKEY_meth_get_sign(EVP_PKEY_METHOD *pmeth , int (**psign_init)(EVP_PKEY_CTX * ) ,
                            int (**psign)(EVP_PKEY_CTX * , unsigned char * , size_t * ,
                                          unsigned char const   * , size_t  ) ) ;
#line 2083
void EVP_PKEY_meth_get_verify(EVP_PKEY_METHOD *pmeth , int (**pverify_init)(EVP_PKEY_CTX * ) ,
                              int (**pverify)(EVP_PKEY_CTX * , unsigned char const   * ,
                                              size_t  , unsigned char const   * ,
                                              size_t  ) ) ;
#line 2087
void EVP_PKEY_meth_get_verify_recover(EVP_PKEY_METHOD *pmeth , int (**pverify_recover_init)(EVP_PKEY_CTX * ) ,
                                      int (**pverify_recover)(EVP_PKEY_CTX * , unsigned char * ,
                                                              size_t * , unsigned char const   * ,
                                                              size_t  ) ) ;
#line 2093
void EVP_PKEY_meth_get_signctx(EVP_PKEY_METHOD *pmeth , int (**psignctx_init)(EVP_PKEY_CTX * ,
                                                                              EVP_MD_CTX * ) ,
                               int (**psignctx)(EVP_PKEY_CTX * , unsigned char * ,
                                                size_t * , EVP_MD_CTX * ) ) ;
#line 2098
void EVP_PKEY_meth_get_verifyctx(EVP_PKEY_METHOD *pmeth , int (**pverifyctx_init)(EVP_PKEY_CTX * ,
                                                                                  EVP_MD_CTX * ) ,
                                 int (**pverifyctx)(EVP_PKEY_CTX * , unsigned char const   * ,
                                                    int  , EVP_MD_CTX * ) ) ;
#line 2103
void EVP_PKEY_meth_get_encrypt(EVP_PKEY_METHOD *pmeth , int (**pencrypt_init)(EVP_PKEY_CTX * ) ,
                               int (**pencryptfn)(EVP_PKEY_CTX * , unsigned char * ,
                                                  size_t * , unsigned char const   * ,
                                                  size_t  ) ) ;
#line 2107
void EVP_PKEY_meth_get_decrypt(EVP_PKEY_METHOD *pmeth , int (**pdecrypt_init)(EVP_PKEY_CTX * ) ,
                               int (**pdecrypt)(EVP_PKEY_CTX * , unsigned char * ,
                                                size_t * , unsigned char const   * ,
                                                size_t  ) ) ;
#line 2111
void EVP_PKEY_meth_get_derive(EVP_PKEY_METHOD *pmeth , int (**pderive_init)(EVP_PKEY_CTX * ) ,
                              int (**pderive)(EVP_PKEY_CTX * , unsigned char * , size_t * ) ) ;
#line 2114
void EVP_PKEY_meth_get_ctrl(EVP_PKEY_METHOD *pmeth , int (**pctrl)(EVP_PKEY_CTX * ,
                                                                   int  , int  , void * ) ,
                            int (**pctrl_str)(EVP_PKEY_CTX * , char const   * , char const   * ) ) ;
#line 2119
void EVP_PKEY_meth_get_digestsign(EVP_PKEY_METHOD *pmeth , int (**digestsign)(EVP_MD_CTX * ,
                                                                              unsigned char * ,
                                                                              size_t * ,
                                                                              unsigned char const   * ,
                                                                              size_t  ) ) ;
#line 2123
void EVP_PKEY_meth_get_digestverify(EVP_PKEY_METHOD *pmeth , int (**digestverify)(EVP_MD_CTX * ,
                                                                                  unsigned char const   * ,
                                                                                  size_t  ,
                                                                                  unsigned char const   * ,
                                                                                  size_t  ) ) ;
#line 2128
void EVP_PKEY_meth_get_check(EVP_PKEY_METHOD *pmeth , int (**pcheck)(EVP_PKEY * ) ) ;
#line 2130
void EVP_PKEY_meth_get_public_check(EVP_PKEY_METHOD *pmeth , int (**pcheck)(EVP_PKEY * ) ) ;
#line 2132
void EVP_PKEY_meth_get_param_check(EVP_PKEY_METHOD *pmeth , int (**pcheck)(EVP_PKEY * ) ) ;
#line 2134
void EVP_PKEY_meth_get_digest_custom(EVP_PKEY_METHOD *pmeth , int (**pdigest_custom)(EVP_PKEY_CTX * ,
                                                                                     EVP_MD_CTX * ) ) ;
#line 2139
void EVP_KEYEXCH_free(EVP_KEYEXCH *exchange ) ;
#line 2140
int EVP_KEYEXCH_up_ref(EVP_KEYEXCH *exchange ) ;
#line 2141
EVP_KEYEXCH *EVP_KEYEXCH_fetch(OSSL_LIB_CTX *ctx , char const   *algorithm , char const   *properties ) ;
#line 2143
OSSL_PROVIDER *EVP_KEYEXCH_get0_provider(EVP_KEYEXCH *exchange ) ;
#line 2144
int EVP_KEYEXCH_is_a(EVP_KEYEXCH *keyexch , char const   *name ) ;
#line 2145
char const   *EVP_KEYEXCH_get0_name(EVP_KEYEXCH *keyexch ) ;
#line 2146
char const   *EVP_KEYEXCH_get0_description(EVP_KEYEXCH *keyexch ) ;
#line 2147
void EVP_KEYEXCH_do_all_provided(OSSL_LIB_CTX *libctx , void (*fn)(EVP_KEYEXCH * ,
                                                                   void * ) , void *data ) ;
#line 2150
int EVP_KEYEXCH_names_do_all(EVP_KEYEXCH *keyexch , void (*fn)(char const   * , void * ) ,
                             void *data ) ;
#line 2153
OSSL_PARAM *EVP_KEYEXCH_gettable_ctx_params(EVP_KEYEXCH *keyexch ) ;
#line 2154
OSSL_PARAM *EVP_KEYEXCH_settable_ctx_params(EVP_KEYEXCH *keyexch ) ;
#line 2156
void EVP_add_alg_module(void) ;
#line 2158
int EVP_PKEY_CTX_set_group_name(EVP_PKEY_CTX *ctx , char const   *name ) ;
#line 2159
int EVP_PKEY_CTX_get_group_name(EVP_PKEY_CTX *ctx , char *name , size_t namelen ) ;
#line 2160
int EVP_PKEY_get_group_name(EVP_PKEY *pkey , char *name , size_t name_sz , size_t *gname_len ) ;
#line 2163
OSSL_LIB_CTX *EVP_PKEY_CTX_get0_libctx(EVP_PKEY_CTX *ctx ) ;
#line 2164
char const   *EVP_PKEY_CTX_get0_propq(EVP_PKEY_CTX *ctx ) ;
#line 2165
OSSL_PROVIDER *EVP_PKEY_CTX_get0_provider(EVP_PKEY_CTX *ctx ) ;
#line 33 "/usr/include/openssl/ec.h"
int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX *ctx , int nid ) ;
#line 34
int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx , int param_enc ) ;
#line 35
int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx , int cofactor_mode ) ;
#line 36
int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx ) ;
#line 38
int EVP_PKEY_CTX_set_ecdh_kdf_type(EVP_PKEY_CTX *ctx , int kdf ) ;
#line 39
int EVP_PKEY_CTX_get_ecdh_kdf_type(EVP_PKEY_CTX *ctx ) ;
#line 41
int EVP_PKEY_CTX_set_ecdh_kdf_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 42
int EVP_PKEY_CTX_get_ecdh_kdf_md(EVP_PKEY_CTX *ctx , EVP_MD **md ) ;
#line 44
int EVP_PKEY_CTX_set_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx , int len ) ;
#line 45
int EVP_PKEY_CTX_get_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx , int *len ) ;
#line 47
int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx , unsigned char *ukm , int len ) ;
#line 51
int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx , unsigned char **ukm ) ;
#line 89
char const   *OSSL_EC_curve_nid2name(int nid ) ;
#line 121
EC_METHOD *EC_GFp_simple_method(void) ;
#line 126
EC_METHOD *EC_GFp_mont_method(void) ;
#line 131
EC_METHOD *EC_GFp_nist_method(void) ;
#line 137
EC_METHOD *EC_GFp_nistp224_method(void) ;
#line 142
EC_METHOD *EC_GFp_nistp256_method(void) ;
#line 147
EC_METHOD *EC_GFp_nistp521_method(void) ;
#line 158
EC_METHOD *EC_GF2m_simple_method(void) ;
#line 171
EC_GROUP *EC_GROUP_new(EC_METHOD *meth ) ;
#line 176
void EC_GROUP_clear_free(EC_GROUP *group ) ;
#line 182
EC_METHOD *EC_GROUP_method_of(EC_GROUP *group ) ;
#line 188
int EC_METHOD_get_field_type(EC_METHOD *meth ) ;
#line 194
void EC_GROUP_free(EC_GROUP *group ) ;
#line 201
int EC_GROUP_copy(EC_GROUP *dst , EC_GROUP *src ) ;
#line 208
EC_GROUP *EC_GROUP_dup(EC_GROUP *src ) ;
#line 218
int EC_GROUP_set_generator(EC_GROUP *group , EC_POINT *generator , BIGNUM *order ,
                           BIGNUM *cofactor ) ;
#line 225
EC_POINT *EC_GROUP_get0_generator(EC_GROUP *group ) ;
#line 231
BN_MONT_CTX *EC_GROUP_get_mont_data(EC_GROUP *group ) ;
#line 239
int EC_GROUP_get_order(EC_GROUP *group , BIGNUM *order , BN_CTX *ctx ) ;
#line 245
BIGNUM *EC_GROUP_get0_order(EC_GROUP *group ) ;
#line 251
int EC_GROUP_order_bits(EC_GROUP *group ) ;
#line 259
int EC_GROUP_get_cofactor(EC_GROUP *group , BIGNUM *cofactor , BN_CTX *ctx ) ;
#line 266
BIGNUM *EC_GROUP_get0_cofactor(EC_GROUP *group ) ;
#line 272
void EC_GROUP_set_curve_name(EC_GROUP *group , int nid ) ;
#line 278
int EC_GROUP_get_curve_name(EC_GROUP *group ) ;
#line 284
BIGNUM *EC_GROUP_get0_field(EC_GROUP *group ) ;
#line 290
int EC_GROUP_get_field_type(EC_GROUP *group ) ;
#line 292
void EC_GROUP_set_asn1_flag(EC_GROUP *group , int flag ) ;
#line 293
int EC_GROUP_get_asn1_flag(EC_GROUP *group ) ;
#line 295
void EC_GROUP_set_point_conversion_form(EC_GROUP *group , point_conversion_form_t form ) ;
#line 297
point_conversion_form_t EC_GROUP_get_point_conversion_form(EC_GROUP * ) ;
#line 299
unsigned char *EC_GROUP_get0_seed(EC_GROUP *x ) ;
#line 300
size_t EC_GROUP_get_seed_len(EC_GROUP * ) ;
#line 301
size_t EC_GROUP_set_seed(EC_GROUP * , unsigned char const   * , size_t len ) ;
#line 313
int EC_GROUP_set_curve(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 326
int EC_GROUP_get_curve(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 339
int EC_GROUP_set_curve_GFp(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 354
int EC_GROUP_get_curve_GFp(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 369
int EC_GROUP_set_curve_GF2m(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b ,
                            BN_CTX *ctx ) ;
#line 384
int EC_GROUP_get_curve_GF2m(EC_GROUP *group , BIGNUM *p , BIGNUM *a , BIGNUM *b ,
                            BN_CTX *ctx ) ;
#line 395
int EC_GROUP_get_degree(EC_GROUP *group ) ;
#line 402
int EC_GROUP_check(EC_GROUP *group , BN_CTX *ctx ) ;
#line 409
int EC_GROUP_check_discriminant(EC_GROUP *group , BN_CTX *ctx ) ;
#line 417
int EC_GROUP_cmp(EC_GROUP *a , EC_GROUP *b , BN_CTX *ctx ) ;
#line 432
EC_GROUP *EC_GROUP_new_curve_GFp(BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 443
EC_GROUP *EC_GROUP_new_curve_GF2m(BIGNUM *p , BIGNUM *a , BIGNUM *b , BN_CTX *ctx ) ;
#line 457
EC_GROUP *EC_GROUP_new_from_params(OSSL_PARAM params[] , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 469
EC_GROUP *EC_GROUP_new_by_curve_name_ex(OSSL_LIB_CTX *libctx , char const   *propq ,
                                        int nid ) ;
#line 480
EC_GROUP *EC_GROUP_new_by_curve_name(int nid ) ;
#line 487
EC_GROUP *EC_GROUP_new_from_ecparameters(ECPARAMETERS *params ) ;
#line 495
ECPARAMETERS *EC_GROUP_get_ecparameters(EC_GROUP *group , ECPARAMETERS *params ) ;
#line 503
EC_GROUP *EC_GROUP_new_from_ecpkparameters(ECPKPARAMETERS *params ) ;
#line 511
ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(EC_GROUP *group , ECPKPARAMETERS *params ) ;
#line 529
size_t EC_get_builtin_curves(EC_builtin_curve *r , size_t nitems ) ;
#line 531
char const   *EC_curve_nid2nist(int nid ) ;
#line 532
int EC_curve_nist2nid(char const   *name ) ;
#line 533
int EC_GROUP_check_named_curve(EC_GROUP *group , int nist_only , BN_CTX *ctx ) ;
#line 544
EC_POINT *EC_POINT_new(EC_GROUP *group ) ;
#line 549
void EC_POINT_free(EC_POINT *point ) ;
#line 554
void EC_POINT_clear_free(EC_POINT *point ) ;
#line 561
int EC_POINT_copy(EC_POINT *dst , EC_POINT *src ) ;
#line 569
EC_POINT *EC_POINT_dup(EC_POINT *src , EC_GROUP *group ) ;
#line 576
int EC_POINT_set_to_infinity(EC_GROUP *group , EC_POINT *point ) ;
#line 583
EC_METHOD *EC_POINT_method_of(EC_POINT *point ) ;
#line 594
int EC_POINT_set_Jprojective_coordinates_GFp(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                             BIGNUM *y , BIGNUM *z , BN_CTX *ctx ) ;
#line 608
int EC_POINT_get_Jprojective_coordinates_GFp(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                             BIGNUM *y , BIGNUM *z , BN_CTX *ctx ) ;
#line 621
int EC_POINT_set_affine_coordinates(EC_GROUP *group , EC_POINT *p , BIGNUM *x , BIGNUM *y ,
                                    BN_CTX *ctx ) ;
#line 633
int EC_POINT_get_affine_coordinates(EC_GROUP *group , EC_POINT *p , BIGNUM *x , BIGNUM *y ,
                                    BN_CTX *ctx ) ;
#line 646
int EC_POINT_set_affine_coordinates_GFp(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                        BIGNUM *y , BN_CTX *ctx ) ;
#line 659
int EC_POINT_get_affine_coordinates_GFp(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                        BIGNUM *y , BN_CTX *ctx ) ;
#line 672
int EC_POINT_set_compressed_coordinates(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                        int y_bit , BN_CTX *ctx ) ;
#line 686
int EC_POINT_set_compressed_coordinates_GFp(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                            int y_bit , BN_CTX *ctx ) ;
#line 699
int EC_POINT_set_affine_coordinates_GF2m(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                         BIGNUM *y , BN_CTX *ctx ) ;
#line 712
int EC_POINT_get_affine_coordinates_GF2m(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                         BIGNUM *y , BN_CTX *ctx ) ;
#line 725
int EC_POINT_set_compressed_coordinates_GF2m(EC_GROUP *group , EC_POINT *p , BIGNUM *x ,
                                             int y_bit , BN_CTX *ctx ) ;
#line 741
size_t EC_POINT_point2oct(EC_GROUP *group , EC_POINT *p , point_conversion_form_t form ,
                          unsigned char *buf , size_t len , BN_CTX *ctx ) ;
#line 753
int EC_POINT_oct2point(EC_GROUP *group , EC_POINT *p , unsigned char const   *buf ,
                       size_t len , BN_CTX *ctx ) ;
#line 764
size_t EC_POINT_point2buf(EC_GROUP *group , EC_POINT *point , point_conversion_form_t form ,
                          unsigned char **pbuf , BN_CTX *ctx ) ;
#line 770
BIGNUM *EC_POINT_point2bn(EC_GROUP * , EC_POINT * , point_conversion_form_t form ,
                          BIGNUM * , BN_CTX * ) ;
#line 774
EC_POINT *EC_POINT_bn2point(EC_GROUP * , BIGNUM * , EC_POINT * , BN_CTX * ) ;
#line 779
char *EC_POINT_point2hex(EC_GROUP * , EC_POINT * , point_conversion_form_t form ,
                         BN_CTX * ) ;
#line 781
EC_POINT *EC_POINT_hex2point(EC_GROUP * , char const   * , EC_POINT * , BN_CTX * ) ;
#line 796
int EC_POINT_add(EC_GROUP *group , EC_POINT *r , EC_POINT *a , EC_POINT *b , BN_CTX *ctx ) ;
#line 806
int EC_POINT_dbl(EC_GROUP *group , EC_POINT *r , EC_POINT *a , BN_CTX *ctx ) ;
#line 815
int EC_POINT_invert(EC_GROUP *group , EC_POINT *a , BN_CTX *ctx ) ;
#line 822
int EC_POINT_is_at_infinity(EC_GROUP *group , EC_POINT *p ) ;
#line 830
int EC_POINT_is_on_curve(EC_GROUP *group , EC_POINT *point , BN_CTX *ctx ) ;
#line 840
int EC_POINT_cmp(EC_GROUP *group , EC_POINT *a , EC_POINT *b , BN_CTX *ctx ) ;
#line 844
int EC_POINT_make_affine(EC_GROUP *group , EC_POINT *point , BN_CTX *ctx ) ;
#line 846
int EC_POINTs_make_affine(EC_GROUP *group , size_t num , EC_POINT *points[] , BN_CTX *ctx ) ;
#line 859
int EC_POINTs_mul(EC_GROUP *group , EC_POINT *r , BIGNUM *n , size_t num , EC_POINT *p[] ,
                  BIGNUM *m[] , BN_CTX *ctx ) ;
#line 874
int EC_POINT_mul(EC_GROUP *group , EC_POINT *r , BIGNUM *n , EC_POINT *q , BIGNUM *m ,
                 BN_CTX *ctx ) ;
#line 883
int EC_GROUP_precompute_mult(EC_GROUP *group , BN_CTX *ctx ) ;
#line 889
int EC_GROUP_have_precompute_mult(EC_GROUP *group ) ;
#line 896
extern ASN1_ITEM *ECPKPARAMETERS_it(void) ;
#line 897
extern ECPKPARAMETERS *ECPKPARAMETERS_new(void) ;
#line 897
extern void ECPKPARAMETERS_free(ECPKPARAMETERS *a ) ;
#line 898
extern ASN1_ITEM *ECPARAMETERS_it(void) ;
#line 899
extern ECPARAMETERS *ECPARAMETERS_new(void) ;
#line 899
extern void ECPARAMETERS_free(ECPARAMETERS *a ) ;
#line 905
int EC_GROUP_get_basis_type(EC_GROUP * ) ;
#line 907
int EC_GROUP_get_trinomial_basis(EC_GROUP * , unsigned int *k ) ;
#line 908
int EC_GROUP_get_pentanomial_basis(EC_GROUP * , unsigned int *k1 , unsigned int *k2 ,
                                   unsigned int *k3 ) ;
#line 912
EC_GROUP *d2i_ECPKParameters(EC_GROUP ** , unsigned char const   **in , long len ) ;
#line 913
int i2d_ECPKParameters(EC_GROUP * , unsigned char **out ) ;
#line 926
int ECPKParameters_print(BIO *bp , EC_GROUP *x , int off ) ;
#line 929
int ECPKParameters_print_fp(FILE *fp , EC_GROUP *x , int off ) ;
#line 961
EC_KEY *EC_KEY_new_ex(OSSL_LIB_CTX *ctx , char const   *propq ) ;
#line 968
EC_KEY *EC_KEY_new(void) ;
#line 970
int EC_KEY_get_flags(EC_KEY *key ) ;
#line 972
void EC_KEY_set_flags(EC_KEY *key , int flags ) ;
#line 974
void EC_KEY_clear_flags(EC_KEY *key , int flags ) ;
#line 976
int EC_KEY_decoded_from_explicit_params(EC_KEY *key ) ;
#line 987
EC_KEY *EC_KEY_new_by_curve_name_ex(OSSL_LIB_CTX *ctx , char const   *propq , int nid ) ;
#line 998
EC_KEY *EC_KEY_new_by_curve_name(int nid ) ;
#line 1003
void EC_KEY_free(EC_KEY *key ) ;
#line 1010
EC_KEY *EC_KEY_copy(EC_KEY *dst , EC_KEY *src ) ;
#line 1016
EC_KEY *EC_KEY_dup(EC_KEY *src ) ;
#line 1022
int EC_KEY_up_ref(EC_KEY *key ) ;
#line 1028
ENGINE *EC_KEY_get0_engine(EC_KEY *eckey ) ;
#line 1034
EC_GROUP *EC_KEY_get0_group(EC_KEY *key ) ;
#line 1042
int EC_KEY_set_group(EC_KEY *key , EC_GROUP *group ) ;
#line 1048
BIGNUM *EC_KEY_get0_private_key(EC_KEY *key ) ;
#line 1056
int EC_KEY_set_private_key(EC_KEY *key , BIGNUM *prv ) ;
#line 1062
EC_POINT *EC_KEY_get0_public_key(EC_KEY *key ) ;
#line 1070
int EC_KEY_set_public_key(EC_KEY *key , EC_POINT *pub ) ;
#line 1072
unsigned int EC_KEY_get_enc_flags(EC_KEY *key ) ;
#line 1073
void EC_KEY_set_enc_flags(EC_KEY *eckey , unsigned int flags ) ;
#line 1074
point_conversion_form_t EC_KEY_get_conv_form(EC_KEY *key ) ;
#line 1075
void EC_KEY_set_conv_form(EC_KEY *eckey , point_conversion_form_t cform ) ;
#line 1083
int EC_KEY_set_ex_data(EC_KEY *key , int idx , void *arg ) ;
#line 1084
void *EC_KEY_get_ex_data(EC_KEY *key , int idx ) ;
#line 1087
void EC_KEY_set_asn1_flag(EC_KEY *eckey , int asn1_flag ) ;
#line 1095
int EC_KEY_precompute_mult(EC_KEY *key , BN_CTX *ctx ) ;
#line 1101
int EC_KEY_generate_key(EC_KEY *key ) ;
#line 1107
int EC_KEY_check_key(EC_KEY *key ) ;
#line 1113
int EC_KEY_can_sign(EC_KEY *eckey ) ;
#line 1122
int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key , BIGNUM *x , BIGNUM *y ) ;
#line 1133
size_t EC_KEY_key2buf(EC_KEY *key , point_conversion_form_t form , unsigned char **pbuf ,
                      BN_CTX *ctx ) ;
#line 1145
int EC_KEY_oct2key(EC_KEY *key , unsigned char const   *buf , size_t len , BN_CTX *ctx ) ;
#line 1155
int EC_KEY_oct2priv(EC_KEY *key , unsigned char const   *buf , size_t len ) ;
#line 1166
size_t EC_KEY_priv2oct(EC_KEY *key , unsigned char *buf , size_t len ) ;
#line 1174
size_t EC_KEY_priv2buf(EC_KEY *eckey , unsigned char **pbuf ) ;
#line 1187
EC_KEY *d2i_ECPrivateKey(EC_KEY **key , unsigned char const   **in , long len ) ;
#line 1197
int i2d_ECPrivateKey(EC_KEY *key , unsigned char **out ) ;
#line 1211
EC_KEY *d2i_ECParameters(EC_KEY **key , unsigned char const   **in , long len ) ;
#line 1221
int i2d_ECParameters(EC_KEY *key , unsigned char **out ) ;
#line 1236
EC_KEY *o2i_ECPublicKey(EC_KEY **key , unsigned char const   **in , long len ) ;
#line 1245
int i2o_ECPublicKey(EC_KEY *key , unsigned char **out ) ;
#line 1252
int ECParameters_print(BIO *bp , EC_KEY *key ) ;
#line 1260
int EC_KEY_print(BIO *bp , EC_KEY *key , int off ) ;
#line 1268
int ECParameters_print_fp(FILE *fp , EC_KEY *key ) ;
#line 1276
int EC_KEY_print_fp(FILE *fp , EC_KEY *key , int off ) ;
#line 1279
EC_KEY_METHOD *EC_KEY_OpenSSL(void) ;
#line 1280
EC_KEY_METHOD *EC_KEY_get_default_method(void) ;
#line 1281
void EC_KEY_set_default_method(EC_KEY_METHOD *meth ) ;
#line 1282
EC_KEY_METHOD *EC_KEY_get_method(EC_KEY *key ) ;
#line 1283
int EC_KEY_set_method(EC_KEY *key , EC_KEY_METHOD *meth ) ;
#line 1284
EC_KEY *EC_KEY_new_method(ENGINE *engine ) ;
#line 1291
int ECDH_KDF_X9_62(unsigned char *out , size_t outlen , unsigned char const   *Z ,
                   size_t Zlen , unsigned char const   *sinfo , size_t sinfolen ,
                   EVP_MD *md ) ;
#line 1296
int ECDH_compute_key(void *out , size_t outlen , EC_POINT *pub_key , EC_KEY *ecdh ,
                     void *(*KDF)(void const   * , size_t  , void * , size_t * ) ) ;
#line 1309
ECDSA_SIG *ECDSA_SIG_new(void) ;
#line 1314
void ECDSA_SIG_free(ECDSA_SIG *sig ) ;
#line 1323
extern ECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **a , unsigned char const   **in , long len ) ;
#line 1323
extern int i2d_ECDSA_SIG(ECDSA_SIG *a , unsigned char **out ) ;
#line 1338
void ECDSA_SIG_get0(ECDSA_SIG *sig , BIGNUM **pr , BIGNUM **ps ) ;
#line 1343
BIGNUM *ECDSA_SIG_get0_r(ECDSA_SIG *sig ) ;
#line 1348
BIGNUM *ECDSA_SIG_get0_s(ECDSA_SIG *sig ) ;
#line 1355
int ECDSA_SIG_set0(ECDSA_SIG *sig , BIGNUM *r , BIGNUM *s ) ;
#line 1365
ECDSA_SIG *ECDSA_do_sign(unsigned char const   *dgst , int dgst_len , EC_KEY *eckey ) ;
#line 1378
ECDSA_SIG *ECDSA_do_sign_ex(unsigned char const   *dgst , int dgstlen , BIGNUM *kinv ,
                            BIGNUM *rp , EC_KEY *eckey ) ;
#line 1391
int ECDSA_do_verify(unsigned char const   *dgst , int dgst_len , ECDSA_SIG *sig ,
                    EC_KEY *eckey ) ;
#line 1401
int ECDSA_sign_setup(EC_KEY *eckey , BN_CTX *ctx , BIGNUM **kinv , BIGNUM **rp ) ;
#line 1414
int ECDSA_sign(int type , unsigned char const   *dgst , int dgstlen , unsigned char *sig ,
               unsigned int *siglen , EC_KEY *eckey ) ;
#line 1431
int ECDSA_sign_ex(int type , unsigned char const   *dgst , int dgstlen , unsigned char *sig ,
                  unsigned int *siglen , BIGNUM *kinv , BIGNUM *rp , EC_KEY *eckey ) ;
#line 1447
int ECDSA_verify(int type , unsigned char const   *dgst , int dgstlen , unsigned char const   *sig ,
                 int siglen , EC_KEY *eckey ) ;
#line 1455
int ECDSA_size(EC_KEY *eckey ) ;
#line 1461
EC_KEY_METHOD *EC_KEY_METHOD_new(EC_KEY_METHOD *meth ) ;
#line 1462
void EC_KEY_METHOD_free(EC_KEY_METHOD *meth ) ;
#line 1463
void EC_KEY_METHOD_set_init(EC_KEY_METHOD *meth , int (*init)(EC_KEY * ) , void (*finish)(EC_KEY * ) ,
                            int (*copy)(EC_KEY * , EC_KEY * ) , int (*set_group)(EC_KEY * ,
                                                                                 EC_GROUP * ) ,
                            int (*set_private)(EC_KEY * , BIGNUM * ) , int (*set_public)(EC_KEY * ,
                                                                                         EC_POINT * ) ) ;
#line 1472
void EC_KEY_METHOD_set_keygen(EC_KEY_METHOD *meth , int (*keygen)(EC_KEY * ) ) ;
#line 1475
void EC_KEY_METHOD_set_compute_key(EC_KEY_METHOD *meth , int (*ckey)(unsigned char ** ,
                                                                     size_t * , EC_POINT * ,
                                                                     EC_KEY * ) ) ;
#line 1480
void EC_KEY_METHOD_set_sign(EC_KEY_METHOD *meth , int (*sign)(int  , unsigned char const   * ,
                                                              int  , unsigned char * ,
                                                              unsigned int * , BIGNUM * ,
                                                              BIGNUM * , EC_KEY * ) ,
                            int (*sign_setup)(EC_KEY * , BN_CTX * , BIGNUM ** , BIGNUM ** ) ,
                            ECDSA_SIG *(*sign_sig)(unsigned char const   * , int  ,
                                                   BIGNUM * , BIGNUM * , EC_KEY * ) ) ;
#line 1495
void EC_KEY_METHOD_set_verify(EC_KEY_METHOD *meth , int (*verify)(int  , unsigned char const   * ,
                                                                  int  , unsigned char const   * ,
                                                                  int  , EC_KEY * ) ,
                              int (*verify_sig)(unsigned char const   * , int  , ECDSA_SIG * ,
                                                EC_KEY * ) ) ;
#line 1505
void EC_KEY_METHOD_get_init(EC_KEY_METHOD *meth , int (**pinit)(EC_KEY * ) , void (**pfinish)(EC_KEY * ) ,
                            int (**pcopy)(EC_KEY * , EC_KEY * ) , int (**pset_group)(EC_KEY * ,
                                                                                     EC_GROUP * ) ,
                            int (**pset_private)(EC_KEY * , BIGNUM * ) , int (**pset_public)(EC_KEY * ,
                                                                                             EC_POINT * ) ) ;
#line 1514
void EC_KEY_METHOD_get_keygen(EC_KEY_METHOD *meth , int (**pkeygen)(EC_KEY * ) ) ;
#line 1517
void EC_KEY_METHOD_get_compute_key(EC_KEY_METHOD *meth , int (**pck)(unsigned char ** ,
                                                                     size_t * , EC_POINT * ,
                                                                     EC_KEY * ) ) ;
#line 1524
void EC_KEY_METHOD_get_sign(EC_KEY_METHOD *meth , int (**psign)(int  , unsigned char const   * ,
                                                                int  , unsigned char * ,
                                                                unsigned int * , BIGNUM * ,
                                                                BIGNUM * , EC_KEY * ) ,
                            int (**psign_setup)(EC_KEY * , BN_CTX * , BIGNUM ** ,
                                                BIGNUM ** ) , ECDSA_SIG *(**psign_sig)(unsigned char const   * ,
                                                                                       int  ,
                                                                                       BIGNUM * ,
                                                                                       BIGNUM * ,
                                                                                       EC_KEY * ) ) ;
#line 1539
void EC_KEY_METHOD_get_verify(EC_KEY_METHOD *meth , int (**pverify)(int  , unsigned char const   * ,
                                                                    int  , unsigned char const   * ,
                                                                    int  , EC_KEY * ) ,
                              int (**pverify_sig)(unsigned char const   * , int  ,
                                                  ECDSA_SIG * , EC_KEY * ) ) ;
#line 119 "/usr/include/openssl/rsa.h"
int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx , int pad_mode ) ;
#line 120
int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx , int *pad_mode ) ;
#line 122
int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx , int saltlen ) ;
#line 123
int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx , int *saltlen ) ;
#line 125
int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx , int bits ) ;
#line 126
int EVP_PKEY_CTX_set1_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx , BIGNUM *pubexp ) ;
#line 127
int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx , int primes ) ;
#line 128
int EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(EVP_PKEY_CTX *ctx , int saltlen ) ;
#line 131
int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx , BIGNUM *pubexp ) ;
#line 143
int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 144
int EVP_PKEY_CTX_set_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx , char const   *mdname , char const   *mdprops ) ;
#line 146
int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx , EVP_MD **md ) ;
#line 147
int EVP_PKEY_CTX_get_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx , char *name , size_t namelen ) ;
#line 149
int EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 150
int EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md_name(EVP_PKEY_CTX *ctx , char const   *mdname ) ;
#line 153
int EVP_PKEY_CTX_set_rsa_pss_keygen_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 154
int EVP_PKEY_CTX_set_rsa_pss_keygen_md_name(EVP_PKEY_CTX *ctx , char const   *mdname ,
                                            char const   *mdprops ) ;
#line 158
int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 159
int EVP_PKEY_CTX_set_rsa_oaep_md_name(EVP_PKEY_CTX *ctx , char const   *mdname , char const   *mdprops ) ;
#line 161
int EVP_PKEY_CTX_get_rsa_oaep_md(EVP_PKEY_CTX *ctx , EVP_MD **md ) ;
#line 162
int EVP_PKEY_CTX_get_rsa_oaep_md_name(EVP_PKEY_CTX *ctx , char *name , size_t namelen ) ;
#line 164
int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx , void *label , int llen ) ;
#line 165
int EVP_PKEY_CTX_get0_rsa_oaep_label(EVP_PKEY_CTX *ctx , unsigned char **label ) ;
#line 206
RSA *RSA_new(void) ;
#line 207
RSA *RSA_new_method(ENGINE *engine ) ;
#line 208
int RSA_bits(RSA *rsa ) ;
#line 209
int RSA_size(RSA *rsa ) ;
#line 210
int RSA_security_bits(RSA *rsa ) ;
#line 212
int RSA_set0_key(RSA *r , BIGNUM *n , BIGNUM *e , BIGNUM *d ) ;
#line 213
int RSA_set0_factors(RSA *r , BIGNUM *p , BIGNUM *q ) ;
#line 214
int RSA_set0_crt_params(RSA *r , BIGNUM *dmp1 , BIGNUM *dmq1 , BIGNUM *iqmp ) ;
#line 217
int RSA_set0_multi_prime_params(RSA *r , BIGNUM *primes[] , BIGNUM *exps[] , BIGNUM *coeffs[] ,
                                int pnum ) ;
#line 222
void RSA_get0_key(RSA *r , BIGNUM **n , BIGNUM **e , BIGNUM **d ) ;
#line 225
void RSA_get0_factors(RSA *r , BIGNUM **p , BIGNUM **q ) ;
#line 227
int RSA_get_multi_prime_extra_count(RSA *r ) ;
#line 228
int RSA_get0_multi_prime_factors(RSA *r , BIGNUM *primes[] ) ;
#line 230
void RSA_get0_crt_params(RSA *r , BIGNUM **dmp1 , BIGNUM **dmq1 , BIGNUM **iqmp ) ;
#line 235
int RSA_get0_multi_prime_crt_params(RSA *r , BIGNUM *exps[] , BIGNUM *coeffs[] ) ;
#line 237
BIGNUM *RSA_get0_n(RSA *d ) ;
#line 238
BIGNUM *RSA_get0_e(RSA *d ) ;
#line 239
BIGNUM *RSA_get0_d(RSA *d ) ;
#line 240
BIGNUM *RSA_get0_p(RSA *d ) ;
#line 241
BIGNUM *RSA_get0_q(RSA *d ) ;
#line 242
BIGNUM *RSA_get0_dmp1(RSA *r ) ;
#line 243
BIGNUM *RSA_get0_dmq1(RSA *r ) ;
#line 244
BIGNUM *RSA_get0_iqmp(RSA *r ) ;
#line 245
RSA_PSS_PARAMS *RSA_get0_pss_params(RSA *r ) ;
#line 246
void RSA_clear_flags(RSA *r , int flags ) ;
#line 247
int RSA_test_flags(RSA *r , int flags ) ;
#line 248
void RSA_set_flags(RSA *r , int flags ) ;
#line 249
int RSA_get_version(RSA *r ) ;
#line 250
ENGINE *RSA_get0_engine(RSA *r ) ;
#line 258
RSA *RSA_generate_key(int bits , unsigned long e , void (*callback)(int  , int  ,
                                                                    void * ) , void *cb_arg ) ;
#line 265
int RSA_generate_key_ex(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
#line 268
int RSA_generate_multi_prime_key(RSA *rsa , int bits , int primes , BIGNUM *e , BN_GENCB *cb ) ;
#line 273
int RSA_X931_derive_ex(RSA *rsa , BIGNUM *p1 , BIGNUM *p2 , BIGNUM *q1 , BIGNUM *q2 ,
                       BIGNUM *Xp1 , BIGNUM *Xp2 , BIGNUM *Xp , BIGNUM *Xq1 , BIGNUM *Xq2 ,
                       BIGNUM *Xq , BIGNUM *e , BN_GENCB *cb ) ;
#line 279
int RSA_X931_generate_key_ex(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
#line 283
int RSA_check_key(RSA * ) ;
#line 284
int RSA_check_key_ex(RSA * , BN_GENCB *cb ) ;
#line 287
int RSA_public_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
#line 290
int RSA_private_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                        RSA *rsa , int padding ) ;
#line 293
int RSA_public_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
#line 296
int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                        RSA *rsa , int padding ) ;
#line 298
void RSA_free(RSA *r ) ;
#line 300
int RSA_up_ref(RSA *r ) ;
#line 301
int RSA_flags(RSA *r ) ;
#line 303
void RSA_set_default_method(RSA_METHOD *meth ) ;
#line 304
RSA_METHOD *RSA_get_default_method(void) ;
#line 305
RSA_METHOD *RSA_null_method(void) ;
#line 306
RSA_METHOD *RSA_get_method(RSA *rsa ) ;
#line 307
int RSA_set_method(RSA *rsa , RSA_METHOD *meth ) ;
#line 310
RSA_METHOD *RSA_PKCS1_OpenSSL(void) ;
#line 312
RSA *d2i_RSAPublicKey(RSA **a , unsigned char const   **in , long len ) ;
#line 312
int i2d_RSAPublicKey(RSA *a , unsigned char **out ) ;
#line 312
ASN1_ITEM *RSAPublicKey_it(void) ;
#line 314
RSA *d2i_RSAPrivateKey(RSA **a , unsigned char const   **in , long len ) ;
#line 314
int i2d_RSAPrivateKey(RSA *a , unsigned char **out ) ;
#line 314
ASN1_ITEM *RSAPrivateKey_it(void) ;
#line 318
int RSA_pkey_ctx_ctrl(EVP_PKEY_CTX *ctx , int optype , int cmd , int p1 , void *p2 ) ;
#line 329
extern RSA_PSS_PARAMS *RSA_PSS_PARAMS_new(void) ;
#line 329
extern void RSA_PSS_PARAMS_free(RSA_PSS_PARAMS *a ) ;
#line 329
extern RSA_PSS_PARAMS *d2i_RSA_PSS_PARAMS(RSA_PSS_PARAMS **a , unsigned char const   **in ,
                                          long len ) ;
#line 329
extern int i2d_RSA_PSS_PARAMS(RSA_PSS_PARAMS *a , unsigned char **out ) ;
#line 329
extern ASN1_ITEM *RSA_PSS_PARAMS_it(void) ;
#line 330
extern RSA_PSS_PARAMS *RSA_PSS_PARAMS_dup(RSA_PSS_PARAMS *a ) ;
#line 340
extern RSA_OAEP_PARAMS *RSA_OAEP_PARAMS_new(void) ;
#line 340
extern void RSA_OAEP_PARAMS_free(RSA_OAEP_PARAMS *a ) ;
#line 340
extern RSA_OAEP_PARAMS *d2i_RSA_OAEP_PARAMS(RSA_OAEP_PARAMS **a , unsigned char const   **in ,
                                            long len ) ;
#line 340
extern int i2d_RSA_OAEP_PARAMS(RSA_OAEP_PARAMS *a , unsigned char **out ) ;
#line 340
extern ASN1_ITEM *RSA_OAEP_PARAMS_it(void) ;
#line 344
int RSA_print_fp(FILE *fp , RSA *r , int offset ) ;
#line 347
int RSA_print(BIO *bp , RSA *r , int offset ) ;
#line 353
int RSA_sign(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
             unsigned int *siglen , RSA *rsa ) ;
#line 356
int RSA_verify(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
               unsigned int siglen , RSA *rsa ) ;
#line 366
int RSA_sign_ASN1_OCTET_STRING(int type , unsigned char const   *m , unsigned int m_length ,
                               unsigned char *sigret , unsigned int *siglen , RSA *rsa ) ;
#line 371
int RSA_verify_ASN1_OCTET_STRING(int type , unsigned char const   *m , unsigned int m_length ,
                                 unsigned char *sigbuf , unsigned int siglen , RSA *rsa ) ;
#line 376
int RSA_blinding_on(RSA *rsa , BN_CTX *ctx ) ;
#line 377
void RSA_blinding_off(RSA *rsa ) ;
#line 378
BN_BLINDING *RSA_setup_blinding(RSA *rsa , BN_CTX *ctx ) ;
#line 381
int RSA_padding_add_PKCS1_type_1(unsigned char *to , int tlen , unsigned char const   *f ,
                                 int fl ) ;
#line 384
int RSA_padding_check_PKCS1_type_1(unsigned char *to , int tlen , unsigned char const   *f ,
                                   int fl , int rsa_len ) ;
#line 388
int RSA_padding_add_PKCS1_type_2(unsigned char *to , int tlen , unsigned char const   *f ,
                                 int fl ) ;
#line 391
int RSA_padding_check_PKCS1_type_2(unsigned char *to , int tlen , unsigned char const   *f ,
                                   int fl , int rsa_len ) ;
#line 394
int PKCS1_MGF1(unsigned char *mask , long len , unsigned char const   *seed , long seedlen ,
               EVP_MD *dgst ) ;
#line 398
int RSA_padding_add_PKCS1_OAEP(unsigned char *to , int tlen , unsigned char const   *f ,
                               int fl , unsigned char const   *p , int pl ) ;
#line 402
int RSA_padding_check_PKCS1_OAEP(unsigned char *to , int tlen , unsigned char const   *f ,
                                 int fl , int rsa_len , unsigned char const   *p ,
                                 int pl ) ;
#line 406
int RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to , int tlen , unsigned char const   *from ,
                                    int flen , unsigned char const   *param , int plen ,
                                    EVP_MD *md , EVP_MD *mgf1md ) ;
#line 411
int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to , int tlen , unsigned char const   *from ,
                                      int flen , int num , unsigned char const   *param ,
                                      int plen , EVP_MD *md , EVP_MD *mgf1md ) ;
#line 416
int RSA_padding_add_none(unsigned char *to , int tlen , unsigned char const   *f ,
                         int fl ) ;
#line 418
int RSA_padding_check_none(unsigned char *to , int tlen , unsigned char const   *f ,
                           int fl , int rsa_len ) ;
#line 421
int RSA_padding_add_X931(unsigned char *to , int tlen , unsigned char const   *f ,
                         int fl ) ;
#line 423
int RSA_padding_check_X931(unsigned char *to , int tlen , unsigned char const   *f ,
                           int fl , int rsa_len ) ;
#line 426
int RSA_X931_hash_id(int nid ) ;
#line 429
int RSA_verify_PKCS1_PSS(RSA *rsa , unsigned char const   *mHash , EVP_MD *Hash ,
                         unsigned char const   *EM , int sLen ) ;
#line 433
int RSA_padding_add_PKCS1_PSS(RSA *rsa , unsigned char *EM , unsigned char const   *mHash ,
                              EVP_MD *Hash , int sLen ) ;
#line 438
int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa , unsigned char const   *mHash , EVP_MD *Hash ,
                              EVP_MD *mgf1Hash , unsigned char const   *EM , int sLen ) ;
#line 443
int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa , unsigned char *EM , unsigned char const   *mHash ,
                                   EVP_MD *Hash , EVP_MD *mgf1Hash , int sLen ) ;
#line 450
int RSA_set_ex_data(RSA *r , int idx , void *arg ) ;
#line 451
void *RSA_get_ex_data(RSA *r , int idx ) ;
#line 453
RSA *RSAPublicKey_dup(RSA *a ) ;
#line 454
RSA *RSAPrivateKey_dup(RSA *a ) ;
#line 478
RSA_METHOD *RSA_meth_new(char const   *name , int flags ) ;
#line 479
void RSA_meth_free(RSA_METHOD *meth ) ;
#line 480
RSA_METHOD *RSA_meth_dup(RSA_METHOD *meth ) ;
#line 481
char const   *RSA_meth_get0_name(RSA_METHOD *meth ) ;
#line 482
int RSA_meth_set1_name(RSA_METHOD *meth , char const   *name ) ;
#line 484
int RSA_meth_get_flags(RSA_METHOD *meth ) ;
#line 485
int RSA_meth_set_flags(RSA_METHOD *meth , int flags ) ;
#line 486
void *RSA_meth_get0_app_data(RSA_METHOD *meth ) ;
#line 487
int RSA_meth_set0_app_data(RSA_METHOD *meth , void *app_data ) ;
#line 490
int (*RSA_meth_get_pub_enc(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned char * ,
                                               RSA * , int  ) ;
#line 495
int RSA_meth_set_pub_enc(RSA_METHOD *rsa , int (*pub_enc)(int  , unsigned char const   * ,
                                                          unsigned char * , RSA * ,
                                                          int  ) ) ;
#line 500
int (*RSA_meth_get_pub_dec(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned char * ,
                                               RSA * , int  ) ;
#line 505
int RSA_meth_set_pub_dec(RSA_METHOD *rsa , int (*pub_dec)(int  , unsigned char const   * ,
                                                          unsigned char * , RSA * ,
                                                          int  ) ) ;
#line 510
int (*RSA_meth_get_priv_enc(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned char * ,
                                                RSA * , int  ) ;
#line 515
int RSA_meth_set_priv_enc(RSA_METHOD *rsa , int (*priv_enc)(int  , unsigned char const   * ,
                                                            unsigned char * , RSA * ,
                                                            int  ) ) ;
#line 520
int (*RSA_meth_get_priv_dec(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned char * ,
                                                RSA * , int  ) ;
#line 525
int RSA_meth_set_priv_dec(RSA_METHOD *rsa , int (*priv_dec)(int  , unsigned char const   * ,
                                                            unsigned char * , RSA * ,
                                                            int  ) ) ;
#line 530
int (*RSA_meth_get_mod_exp(RSA_METHOD *meth ))(BIGNUM * , BIGNUM * , RSA * , BN_CTX * ) ;
#line 534
int RSA_meth_set_mod_exp(RSA_METHOD *rsa , int (*mod_exp)(BIGNUM * , BIGNUM * , RSA * ,
                                                          BN_CTX * ) ) ;
#line 538
int (*RSA_meth_get_bn_mod_exp(RSA_METHOD *meth ))(BIGNUM * , BIGNUM * , BIGNUM * ,
                                                  BIGNUM * , BN_CTX * , BN_MONT_CTX * ) ;
#line 545
int RSA_meth_set_bn_mod_exp(RSA_METHOD *rsa , int (*bn_mod_exp)(BIGNUM * , BIGNUM * ,
                                                                BIGNUM * , BIGNUM * ,
                                                                BN_CTX * , BN_MONT_CTX * ) ) ;
#line 553
int (*RSA_meth_get_init(RSA_METHOD *meth ))(RSA * ) ;
#line 555
int RSA_meth_set_init(RSA_METHOD *rsa , int (*init)(RSA * ) ) ;
#line 557
int (*RSA_meth_get_finish(RSA_METHOD *meth ))(RSA * ) ;
#line 559
int RSA_meth_set_finish(RSA_METHOD *rsa , int (*finish)(RSA * ) ) ;
#line 561
int (*RSA_meth_get_sign(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned int  ,
                                            unsigned char * , unsigned int * , RSA * ) ;
#line 568
int RSA_meth_set_sign(RSA_METHOD *rsa , int (*sign)(int  , unsigned char const   * ,
                                                    unsigned int  , unsigned char * ,
                                                    unsigned int * , RSA * ) ) ;
#line 574
int (*RSA_meth_get_verify(RSA_METHOD *meth ))(int  , unsigned char const   * , unsigned int  ,
                                              unsigned char const   * , unsigned int  ,
                                              RSA * ) ;
#line 581
int RSA_meth_set_verify(RSA_METHOD *rsa , int (*verify)(int  , unsigned char const   * ,
                                                        unsigned int  , unsigned char const   * ,
                                                        unsigned int  , RSA * ) ) ;
#line 587
int (*RSA_meth_get_keygen(RSA_METHOD *meth ))(RSA * , int  , BIGNUM * , BN_GENCB * ) ;
#line 590
int RSA_meth_set_keygen(RSA_METHOD *rsa , int (*keygen)(RSA * , int  , BIGNUM * ,
                                                        BN_GENCB * ) ) ;
#line 594
int (*RSA_meth_get_multi_prime_keygen(RSA_METHOD *meth ))(RSA * , int  , int  , BIGNUM * ,
                                                          BN_GENCB * ) ;
#line 600
int RSA_meth_set_multi_prime_keygen(RSA_METHOD *meth , int (*keygen)(RSA * , int  ,
                                                                     int  , BIGNUM * ,
                                                                     BN_GENCB * ) ) ;
#line 28 "/usr/include/openssl/dsa.h"
int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx , int nbits ) ;
#line 29
int EVP_PKEY_CTX_set_dsa_paramgen_q_bits(EVP_PKEY_CTX *ctx , int qbits ) ;
#line 30
int EVP_PKEY_CTX_set_dsa_paramgen_md_props(EVP_PKEY_CTX *ctx , char const   *md_name ,
                                           char const   *md_properties ) ;
#line 33
int EVP_PKEY_CTX_set_dsa_paramgen_gindex(EVP_PKEY_CTX *ctx , int gindex ) ;
#line 34
int EVP_PKEY_CTX_set_dsa_paramgen_type(EVP_PKEY_CTX *ctx , char const   *name ) ;
#line 35
int EVP_PKEY_CTX_set_dsa_paramgen_seed(EVP_PKEY_CTX *ctx , unsigned char const   *seed ,
                                       size_t seedlen ) ;
#line 38
int EVP_PKEY_CTX_set_dsa_paramgen_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 34 "/usr/include/openssl/dh.h"
int EVP_PKEY_CTX_set_dh_paramgen_type(EVP_PKEY_CTX *ctx , int typ ) ;
#line 35
int EVP_PKEY_CTX_set_dh_paramgen_gindex(EVP_PKEY_CTX *ctx , int gindex ) ;
#line 36
int EVP_PKEY_CTX_set_dh_paramgen_seed(EVP_PKEY_CTX *ctx , unsigned char const   *seed ,
                                      size_t seedlen ) ;
#line 39
int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx , int pbits ) ;
#line 40
int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(EVP_PKEY_CTX *ctx , int qlen ) ;
#line 41
int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx , int gen ) ;
#line 42
int EVP_PKEY_CTX_set_dh_nid(EVP_PKEY_CTX *ctx , int nid ) ;
#line 43
int EVP_PKEY_CTX_set_dh_rfc5114(EVP_PKEY_CTX *ctx , int gen ) ;
#line 44
int EVP_PKEY_CTX_set_dhx_rfc5114(EVP_PKEY_CTX *ctx , int gen ) ;
#line 45
int EVP_PKEY_CTX_set_dh_pad(EVP_PKEY_CTX *ctx , int pad ) ;
#line 47
int EVP_PKEY_CTX_set_dh_kdf_type(EVP_PKEY_CTX *ctx , int kdf ) ;
#line 48
int EVP_PKEY_CTX_get_dh_kdf_type(EVP_PKEY_CTX *ctx ) ;
#line 49
int EVP_PKEY_CTX_set0_dh_kdf_oid(EVP_PKEY_CTX *ctx , ASN1_OBJECT *oid ) ;
#line 50
int EVP_PKEY_CTX_get0_dh_kdf_oid(EVP_PKEY_CTX *ctx , ASN1_OBJECT **oid ) ;
#line 51
int EVP_PKEY_CTX_set_dh_kdf_md(EVP_PKEY_CTX *ctx , EVP_MD *md ) ;
#line 52
int EVP_PKEY_CTX_get_dh_kdf_md(EVP_PKEY_CTX *ctx , EVP_MD **md ) ;
#line 53
int EVP_PKEY_CTX_set_dh_kdf_outlen(EVP_PKEY_CTX *ctx , int len ) ;
#line 54
int EVP_PKEY_CTX_get_dh_kdf_outlen(EVP_PKEY_CTX *ctx , int *len ) ;
#line 55
int EVP_PKEY_CTX_set0_dh_kdf_ukm(EVP_PKEY_CTX *ctx , unsigned char *ukm , int len ) ;
#line 58
int EVP_PKEY_CTX_get0_dh_kdf_ukm(EVP_PKEY_CTX *ctx , unsigned char **ukm ) ;
#line 137
extern ASN1_ITEM *DHparams_it(void) ;
#line 194
DH *DHparams_dup(DH *a ) ;
#line 196
DH_METHOD *DH_OpenSSL(void) ;
#line 198
void DH_set_default_method(DH_METHOD *meth ) ;
#line 199
DH_METHOD *DH_get_default_method(void) ;
#line 200
int DH_set_method(DH *dh , DH_METHOD *meth ) ;
#line 201
DH *DH_new_method(ENGINE *engine ) ;
#line 203
DH *DH_new(void) ;
#line 204
void DH_free(DH *dh ) ;
#line 205
int DH_up_ref(DH *dh ) ;
#line 206
int DH_bits(DH *dh ) ;
#line 207
int DH_size(DH *dh ) ;
#line 208
int DH_security_bits(DH *dh ) ;
#line 213
int DH_set_ex_data(DH *d , int idx , void *arg ) ;
#line 214
void *DH_get_ex_data(DH *d , int idx ) ;
#line 216
int DH_generate_parameters_ex(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
#line 220
int DH_check_params_ex(DH *dh ) ;
#line 221
int DH_check_ex(DH *dh ) ;
#line 222
int DH_check_pub_key_ex(DH *dh , BIGNUM *pub_key ) ;
#line 223
int DH_check_params(DH *dh , int *ret ) ;
#line 224
int DH_check(DH *dh , int *codes ) ;
#line 225
int DH_check_pub_key(DH *dh , BIGNUM *pub_key , int *codes ) ;
#line 227
int DH_generate_key(DH *dh ) ;
#line 228
int DH_compute_key(unsigned char *key , BIGNUM *pub_key , DH *dh ) ;
#line 230
int DH_compute_key_padded(unsigned char *key , BIGNUM *pub_key , DH *dh ) ;
#line 233
DH *d2i_DHparams(DH **a , unsigned char const   **in , long len ) ;
#line 233
int i2d_DHparams(DH *a , unsigned char **out ) ;
#line 234
DH *d2i_DHxparams(DH **a , unsigned char const   **in , long len ) ;
#line 234
int i2d_DHxparams(DH *a , unsigned char **out ) ;
#line 237
int DHparams_print_fp(FILE *fp , DH *x ) ;
#line 239
int DHparams_print(BIO *bp , DH *x ) ;
#line 242
DH *DH_get_1024_160(void) ;
#line 243
DH *DH_get_2048_224(void) ;
#line 244
DH *DH_get_2048_256(void) ;
#line 247
DH *DH_new_by_nid(int nid ) ;
#line 248
int DH_get_nid(DH *dh ) ;
#line 251
int DH_KDF_X9_42(unsigned char *out , size_t outlen , unsigned char const   *Z , size_t Zlen ,
                 ASN1_OBJECT *key_oid , unsigned char const   *ukm , size_t ukmlen ,
                 EVP_MD *md ) ;
#line 257
void DH_get0_pqg(DH *dh , BIGNUM **p , BIGNUM **q , BIGNUM **g ) ;
#line 259
int DH_set0_pqg(DH *dh , BIGNUM *p , BIGNUM *q , BIGNUM *g ) ;
#line 260
void DH_get0_key(DH *dh , BIGNUM **pub_key , BIGNUM **priv_key ) ;
#line 262
int DH_set0_key(DH *dh , BIGNUM *pub_key , BIGNUM *priv_key ) ;
#line 263
BIGNUM *DH_get0_p(DH *dh ) ;
#line 264
BIGNUM *DH_get0_q(DH *dh ) ;
#line 265
BIGNUM *DH_get0_g(DH *dh ) ;
#line 266
BIGNUM *DH_get0_priv_key(DH *dh ) ;
#line 267
BIGNUM *DH_get0_pub_key(DH *dh ) ;
#line 268
void DH_clear_flags(DH *dh , int flags ) ;
#line 269
int DH_test_flags(DH *dh , int flags ) ;
#line 270
void DH_set_flags(DH *dh , int flags ) ;
#line 271
ENGINE *DH_get0_engine(DH *d ) ;
#line 272
long DH_get_length(DH *dh ) ;
#line 273
int DH_set_length(DH *dh , long length ) ;
#line 275
DH_METHOD *DH_meth_new(char const   *name , int flags ) ;
#line 276
void DH_meth_free(DH_METHOD *dhm ) ;
#line 277
DH_METHOD *DH_meth_dup(DH_METHOD *dhm ) ;
#line 278
char const   *DH_meth_get0_name(DH_METHOD *dhm ) ;
#line 279
int DH_meth_set1_name(DH_METHOD *dhm , char const   *name ) ;
#line 280
int DH_meth_get_flags(DH_METHOD *dhm ) ;
#line 281
int DH_meth_set_flags(DH_METHOD *dhm , int flags ) ;
#line 282
void *DH_meth_get0_app_data(DH_METHOD *dhm ) ;
#line 283
int DH_meth_set0_app_data(DH_METHOD *dhm , void *app_data ) ;
#line 284
int (*DH_meth_get_generate_key(DH_METHOD *dhm ))(DH * ) ;
#line 285
int DH_meth_set_generate_key(DH_METHOD *dhm , int (*generate_key)(DH * ) ) ;
#line 287
int (*DH_meth_get_compute_key(DH_METHOD *dhm ))(unsigned char * , BIGNUM * , DH * ) ;
#line 291
int DH_meth_set_compute_key(DH_METHOD *dhm , int (*compute_key)(unsigned char * ,
                                                                BIGNUM * , DH * ) ) ;
#line 296
int (*DH_meth_get_bn_mod_exp(DH_METHOD *dhm ))(DH * , BIGNUM * , BIGNUM * , BIGNUM * ,
                                               BIGNUM * , BN_CTX * , BN_MONT_CTX * ) ;
#line 302
int DH_meth_set_bn_mod_exp(DH_METHOD *dhm , int (*bn_mod_exp)(DH * , BIGNUM * , BIGNUM * ,
                                                              BIGNUM * , BIGNUM * ,
                                                              BN_CTX * , BN_MONT_CTX * ) ) ;
#line 308
int (*DH_meth_get_init(DH_METHOD *dhm ))(DH * ) ;
#line 309
int DH_meth_set_init(DH_METHOD *dhm , int (*init)(DH * ) ) ;
#line 310
int (*DH_meth_get_finish(DH_METHOD *dhm ))(DH * ) ;
#line 311
int DH_meth_set_finish(DH_METHOD *dhm , int (*finish)(DH * ) ) ;
#line 312
int (*DH_meth_get_generate_params(DH_METHOD *dhm ))(DH * , int  , int  , BN_GENCB * ) ;
#line 315
int DH_meth_set_generate_params(DH_METHOD *dhm , int (*generate_params)(DH * , int  ,
                                                                        int  , BN_GENCB * ) ) ;
#line 322
DH *DH_generate_parameters(int prime_len , int generator , void (*callback)(int  ,
                                                                            int  ,
                                                                            void * ) ,
                           void *cb_arg ) ;
#line 62 "/usr/include/openssl/dsa.h"
DSA_SIG *DSA_SIG_new(void) ;
#line 63
void DSA_SIG_free(DSA_SIG *a ) ;
#line 64
extern DSA_SIG *d2i_DSA_SIG(DSA_SIG **a , unsigned char const   **in , long len ) ;
#line 64
extern int i2d_DSA_SIG(DSA_SIG *a , unsigned char **out ) ;
#line 65
void DSA_SIG_get0(DSA_SIG *sig , BIGNUM **pr , BIGNUM **ps ) ;
#line 66
int DSA_SIG_set0(DSA_SIG *sig , BIGNUM *r , BIGNUM *s ) ;
#line 112
DSA *DSAparams_dup(DSA *a ) ;
#line 113
DSA_SIG *DSA_do_sign(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
#line 115
int DSA_do_verify(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig , DSA *dsa ) ;
#line 118
DSA_METHOD *DSA_OpenSSL(void) ;
#line 120
void DSA_set_default_method(DSA_METHOD * ) ;
#line 121
DSA_METHOD *DSA_get_default_method(void) ;
#line 122
int DSA_set_method(DSA *dsa , DSA_METHOD * ) ;
#line 123
DSA_METHOD *DSA_get_method(DSA *d ) ;
#line 125
DSA *DSA_new(void) ;
#line 126
DSA *DSA_new_method(ENGINE *engine ) ;
#line 127
void DSA_free(DSA *r ) ;
#line 129
int DSA_up_ref(DSA *r ) ;
#line 130
int DSA_size(DSA * ) ;
#line 131
int DSA_bits(DSA *d ) ;
#line 132
int DSA_security_bits(DSA *d ) ;
#line 134
int DSA_sign_setup(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
#line 136
int DSA_sign(int type , unsigned char const   *dgst , int dlen , unsigned char *sig ,
             unsigned int *siglen , DSA *dsa ) ;
#line 139
int DSA_verify(int type , unsigned char const   *dgst , int dgst_len , unsigned char const   *sigbuf ,
               int siglen , DSA *dsa ) ;
#line 145
int DSA_set_ex_data(DSA *d , int idx , void *arg ) ;
#line 146
void *DSA_get_ex_data(DSA *d , int idx ) ;
#line 148
DSA *d2i_DSAPublicKey(DSA **a , unsigned char const   **in , long len ) ;
#line 148
int i2d_DSAPublicKey(DSA *a , unsigned char **out ) ;
#line 150
DSA *d2i_DSAPrivateKey(DSA **a , unsigned char const   **in , long len ) ;
#line 150
int i2d_DSAPrivateKey(DSA *a , unsigned char **out ) ;
#line 152
DSA *d2i_DSAparams(DSA **a , unsigned char const   **in , long len ) ;
#line 152
int i2d_DSAparams(DSA *a , unsigned char **out ) ;
#line 159
DSA *DSA_generate_parameters(int bits , unsigned char *seed , int seed_len , int *counter_ret ,
                             unsigned long *h_ret , void (*callback)(int  , int  ,
                                                                     void * ) , void *cb_arg ) ;
#line 167
int DSA_generate_parameters_ex(DSA *dsa , int bits , unsigned char const   *seed ,
                               int seed_len , int *counter_ret , unsigned long *h_ret ,
                               BN_GENCB *cb ) ;
#line 174
int DSA_generate_key(DSA *a ) ;
#line 176
int DSAparams_print(BIO *bp , DSA *x ) ;
#line 177
int DSA_print(BIO *bp , DSA *x , int off ) ;
#line 179
int DSAparams_print_fp(FILE *fp , DSA *x ) ;
#line 180
int DSA_print_fp(FILE *bp , DSA *x , int off ) ;
#line 198
DH *DSA_dup_DH(DSA *r ) ;
#line 201
void DSA_get0_pqg(DSA *d , BIGNUM **p , BIGNUM **q , BIGNUM **g ) ;
#line 203
int DSA_set0_pqg(DSA *d , BIGNUM *p , BIGNUM *q , BIGNUM *g ) ;
#line 204
void DSA_get0_key(DSA *d , BIGNUM **pub_key , BIGNUM **priv_key ) ;
#line 206
int DSA_set0_key(DSA *d , BIGNUM *pub_key , BIGNUM *priv_key ) ;
#line 208
BIGNUM *DSA_get0_p(DSA *d ) ;
#line 209
BIGNUM *DSA_get0_q(DSA *d ) ;
#line 210
BIGNUM *DSA_get0_g(DSA *d ) ;
#line 211
BIGNUM *DSA_get0_pub_key(DSA *d ) ;
#line 212
BIGNUM *DSA_get0_priv_key(DSA *d ) ;
#line 213
void DSA_clear_flags(DSA *d , int flags ) ;
#line 214
int DSA_test_flags(DSA *d , int flags ) ;
#line 215
void DSA_set_flags(DSA *d , int flags ) ;
#line 216
ENGINE *DSA_get0_engine(DSA *d ) ;
#line 218
DSA_METHOD *DSA_meth_new(char const   *name , int flags ) ;
#line 219
void DSA_meth_free(DSA_METHOD *dsam ) ;
#line 220
DSA_METHOD *DSA_meth_dup(DSA_METHOD *dsam ) ;
#line 221
char const   *DSA_meth_get0_name(DSA_METHOD *dsam ) ;
#line 222
int DSA_meth_set1_name(DSA_METHOD *dsam , char const   *name ) ;
#line 224
int DSA_meth_get_flags(DSA_METHOD *dsam ) ;
#line 225
int DSA_meth_set_flags(DSA_METHOD *dsam , int flags ) ;
#line 226
void *DSA_meth_get0_app_data(DSA_METHOD *dsam ) ;
#line 227
int DSA_meth_set0_app_data(DSA_METHOD *dsam , void *app_data ) ;
#line 229
DSA_SIG *(*DSA_meth_get_sign(DSA_METHOD *dsam ))(unsigned char const   * , int  ,
                                                 DSA * ) ;
#line 231
int DSA_meth_set_sign(DSA_METHOD *dsam , DSA_SIG *(*sign)(unsigned char const   * ,
                                                          int  , DSA * ) ) ;
#line 233
int (*DSA_meth_get_sign_setup(DSA_METHOD *dsam ))(DSA * , BN_CTX * , BIGNUM ** , BIGNUM ** ) ;
#line 235
int DSA_meth_set_sign_setup(DSA_METHOD *dsam , int (*sign_setup)(DSA * , BN_CTX * ,
                                                                 BIGNUM ** , BIGNUM ** ) ) ;
#line 237
int (*DSA_meth_get_verify(DSA_METHOD *dsam ))(unsigned char const   * , int  , DSA_SIG * ,
                                              DSA * ) ;
#line 239
int DSA_meth_set_verify(DSA_METHOD *dsam , int (*verify)(unsigned char const   * ,
                                                         int  , DSA_SIG * , DSA * ) ) ;
#line 241
int (*DSA_meth_get_mod_exp(DSA_METHOD *dsam ))(DSA * , BIGNUM * , BIGNUM * , BIGNUM * ,
                                               BIGNUM * , BIGNUM * , BIGNUM * , BN_CTX * ,
                                               BN_MONT_CTX * ) ;
#line 244
int DSA_meth_set_mod_exp(DSA_METHOD *dsam , int (*mod_exp)(DSA * , BIGNUM * , BIGNUM * ,
                                                           BIGNUM * , BIGNUM * , BIGNUM * ,
                                                           BIGNUM * , BN_CTX * , BN_MONT_CTX * ) ) ;
#line 248
int (*DSA_meth_get_bn_mod_exp(DSA_METHOD *dsam ))(DSA * , BIGNUM * , BIGNUM * , BIGNUM * ,
                                                  BIGNUM * , BN_CTX * , BN_MONT_CTX * ) ;
#line 251
int DSA_meth_set_bn_mod_exp(DSA_METHOD *dsam , int (*bn_mod_exp)(DSA * , BIGNUM * ,
                                                                 BIGNUM * , BIGNUM * ,
                                                                 BIGNUM * , BN_CTX * ,
                                                                 BN_MONT_CTX * ) ) ;
#line 254
int (*DSA_meth_get_init(DSA_METHOD *dsam ))(DSA * ) ;
#line 255
int DSA_meth_set_init(DSA_METHOD *dsam , int (*init)(DSA * ) ) ;
#line 257
int (*DSA_meth_get_finish(DSA_METHOD *dsam ))(DSA * ) ;
#line 258
int DSA_meth_set_finish(DSA_METHOD *dsam , int (*finish)(DSA * ) ) ;
#line 260
int (*DSA_meth_get_paramgen(DSA_METHOD *dsam ))(DSA * , int  , unsigned char const   * ,
                                                int  , int * , unsigned long * , BN_GENCB * ) ;
#line 263
int DSA_meth_set_paramgen(DSA_METHOD *dsam , int (*paramgen)(DSA * , int  , unsigned char const   * ,
                                                             int  , int * , unsigned long * ,
                                                             BN_GENCB * ) ) ;
#line 266
int (*DSA_meth_get_keygen(DSA_METHOD *dsam ))(DSA * ) ;
#line 267
int DSA_meth_set_keygen(DSA_METHOD *dsam , int (*keygen)(DSA * ) ) ;
#line 49 "/usr/include/openssl/sha.h"
int SHA1_Init(SHA_CTX *c ) ;
#line 50
int SHA1_Update(SHA_CTX *c , void const   *data , size_t len ) ;
#line 51
int SHA1_Final(unsigned char *md , SHA_CTX *c ) ;
#line 52
void SHA1_Transform(SHA_CTX *c , unsigned char const   *data ) ;
#line 55
unsigned char *SHA1(unsigned char const   *d , size_t n , unsigned char *md ) ;
#line 69
int SHA224_Init(SHA256_CTX *c ) ;
#line 70
int SHA224_Update(SHA256_CTX *c , void const   *data , size_t len ) ;
#line 72
int SHA224_Final(unsigned char *md , SHA256_CTX *c ) ;
#line 73
int SHA256_Init(SHA256_CTX *c ) ;
#line 74
int SHA256_Update(SHA256_CTX *c , void const   *data , size_t len ) ;
#line 76
int SHA256_Final(unsigned char *md , SHA256_CTX *c ) ;
#line 77
void SHA256_Transform(SHA256_CTX *c , unsigned char const   *data ) ;
#line 81
unsigned char *SHA224(unsigned char const   *d , size_t n , unsigned char *md ) ;
#line 82
unsigned char *SHA256(unsigned char const   *d , size_t n , unsigned char *md ) ;
#line 119
int SHA384_Init(SHA512_CTX *c ) ;
#line 120
int SHA384_Update(SHA512_CTX *c , void const   *data , size_t len ) ;
#line 122
int SHA384_Final(unsigned char *md , SHA512_CTX *c ) ;
#line 123
int SHA512_Init(SHA512_CTX *c ) ;
#line 124
int SHA512_Update(SHA512_CTX *c , void const   *data , size_t len ) ;
#line 126
int SHA512_Final(unsigned char *md , SHA512_CTX *c ) ;
#line 127
void SHA512_Transform(SHA512_CTX *c , unsigned char const   *data ) ;
#line 131
unsigned char *SHA384(unsigned char const   *d , size_t n , unsigned char *md ) ;
#line 132
unsigned char *SHA512(unsigned char const   *d , size_t n , unsigned char *md ) ;
#line 49 "/usr/include/openssl/x509.h"
__inline static X509_NAME *ossl_check_X509_NAME_type(X509_NAME *ptr ) 
{ 


  {
#line 49
  return (ptr);
}
}
#line 49 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_NAME_sk_type(struct stack_st_X509_NAME *sk ) 
{ 


  {
#line 49
  return ((OPENSSL_STACK *)sk);
}
}
#line 49 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_NAME_compfunc_type(sk_X509_NAME_compfunc cmp ) 
{ 


  {
#line 49
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 49 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_NAME_copyfunc_type(sk_X509_NAME_copyfunc cpy ) 
{ 


  {
#line 49
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 49 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_NAME_freefunc_type(sk_X509_NAME_freefunc fr ) 
{ 


  {
#line 49
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 75 "/usr/include/openssl/x509.h"
__inline static X509 *ossl_check_X509_type(X509 *ptr ) 
{ 


  {
#line 75
  return (ptr);
}
}
#line 75 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_sk_type(struct stack_st_X509 *sk ) 
{ 


  {
#line 75
  return ((OPENSSL_STACK *)sk);
}
}
#line 75 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_compfunc_type(sk_X509_compfunc cmp ) 
{ 


  {
#line 75
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 75 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_copyfunc_type(sk_X509_copyfunc cpy ) 
{ 


  {
#line 75
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 75 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_freefunc_type(sk_X509_freefunc fr ) 
{ 


  {
#line 75
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 101 "/usr/include/openssl/x509.h"
__inline static X509_REVOKED *ossl_check_X509_REVOKED_type(X509_REVOKED *ptr ) 
{ 


  {
#line 101
  return (ptr);
}
}
#line 101 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_REVOKED_sk_type(struct stack_st_X509_REVOKED *sk ) 
{ 


  {
#line 101
  return ((OPENSSL_STACK *)sk);
}
}
#line 101 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_REVOKED_compfunc_type(sk_X509_REVOKED_compfunc cmp ) 
{ 


  {
#line 101
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 101 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_REVOKED_copyfunc_type(sk_X509_REVOKED_copyfunc cpy ) 
{ 


  {
#line 101
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 101 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_REVOKED_freefunc_type(sk_X509_REVOKED_freefunc fr ) 
{ 


  {
#line 101
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 127 "/usr/include/openssl/x509.h"
__inline static X509_CRL *ossl_check_X509_CRL_type(X509_CRL *ptr ) 
{ 


  {
#line 127
  return (ptr);
}
}
#line 127 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_CRL_sk_type(struct stack_st_X509_CRL *sk ) 
{ 


  {
#line 127
  return ((OPENSSL_STACK *)sk);
}
}
#line 127 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_CRL_compfunc_type(sk_X509_CRL_compfunc cmp ) 
{ 


  {
#line 127
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 127 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_CRL_copyfunc_type(sk_X509_CRL_copyfunc cpy ) 
{ 


  {
#line 127
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 127 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_CRL_freefunc_type(sk_X509_CRL_freefunc fr ) 
{ 


  {
#line 127
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 192 "/usr/include/openssl/x509.h"
__inline static X509_NAME_ENTRY *ossl_check_X509_NAME_ENTRY_type(X509_NAME_ENTRY *ptr ) 
{ 


  {
#line 192
  return (ptr);
}
}
#line 192 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_NAME_ENTRY_sk_type(struct stack_st_X509_NAME_ENTRY *sk ) 
{ 


  {
#line 192
  return ((OPENSSL_STACK *)sk);
}
}
#line 192 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_NAME_ENTRY_compfunc_type(sk_X509_NAME_ENTRY_compfunc cmp ) 
{ 


  {
#line 192
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 192 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_NAME_ENTRY_copyfunc_type(sk_X509_NAME_ENTRY_copyfunc cpy ) 
{ 


  {
#line 192
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 192 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_NAME_ENTRY_freefunc_type(sk_X509_NAME_ENTRY_freefunc fr ) 
{ 


  {
#line 192
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 223 "/usr/include/openssl/x509.h"
__inline static X509_EXTENSION *ossl_check_X509_EXTENSION_type(X509_EXTENSION *ptr ) 
{ 


  {
#line 223
  return (ptr);
}
}
#line 223 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_EXTENSION_sk_type(struct stack_st_X509_EXTENSION *sk ) 
{ 


  {
#line 223
  return ((OPENSSL_STACK *)sk);
}
}
#line 223 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_EXTENSION_compfunc_type(sk_X509_EXTENSION_compfunc cmp ) 
{ 


  {
#line 223
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 223 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_EXTENSION_copyfunc_type(sk_X509_EXTENSION_copyfunc cpy ) 
{ 


  {
#line 223
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 223 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_EXTENSION_freefunc_type(sk_X509_EXTENSION_freefunc fr ) 
{ 


  {
#line 223
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 252 "/usr/include/openssl/x509.h"
__inline static X509_ATTRIBUTE *ossl_check_X509_ATTRIBUTE_type(X509_ATTRIBUTE *ptr ) 
{ 


  {
#line 252
  return (ptr);
}
}
#line 252 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_ATTRIBUTE_sk_type(struct stack_st_X509_ATTRIBUTE *sk ) 
{ 


  {
#line 252
  return ((OPENSSL_STACK *)sk);
}
}
#line 252 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_ATTRIBUTE_compfunc_type(sk_X509_ATTRIBUTE_compfunc cmp ) 
{ 


  {
#line 252
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 252 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_ATTRIBUTE_copyfunc_type(sk_X509_ATTRIBUTE_copyfunc cpy ) 
{ 


  {
#line 252
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 252 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_ATTRIBUTE_freefunc_type(sk_X509_ATTRIBUTE_freefunc fr ) 
{ 


  {
#line 252
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 387 "/usr/include/openssl/x509.h"
__inline static X509_INFO *ossl_check_X509_INFO_type(X509_INFO *ptr ) 
{ 


  {
#line 387
  return (ptr);
}
}
#line 387 "/usr/include/openssl/x509.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_INFO_sk_type(struct stack_st_X509_INFO *sk ) 
{ 


  {
#line 387
  return ((OPENSSL_STACK *)sk);
}
}
#line 387 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_INFO_compfunc_type(sk_X509_INFO_compfunc cmp ) 
{ 


  {
#line 387
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 387 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_INFO_copyfunc_type(sk_X509_INFO_copyfunc cpy ) 
{ 


  {
#line 387
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 387 "/usr/include/openssl/x509.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_INFO_freefunc_type(sk_X509_INFO_freefunc fr ) 
{ 


  {
#line 387
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 80 "/usr/include/openssl/lhash.h"
int OPENSSL_LH_error(OPENSSL_LHASH *lh ) ;
#line 81
OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h , OPENSSL_LH_COMPFUNC c ) ;
#line 82
void OPENSSL_LH_free(OPENSSL_LHASH *lh ) ;
#line 83
void OPENSSL_LH_flush(OPENSSL_LHASH *lh ) ;
#line 84
void *OPENSSL_LH_insert(OPENSSL_LHASH *lh , void *data ) ;
#line 85
void *OPENSSL_LH_delete(OPENSSL_LHASH *lh , void const   *data ) ;
#line 86
void *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh , void const   *data ) ;
#line 87
void OPENSSL_LH_doall(OPENSSL_LHASH *lh , OPENSSL_LH_DOALL_FUNC func ) ;
#line 88
void OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh , OPENSSL_LH_DOALL_FUNCARG func , void *arg ) ;
#line 89
unsigned long OPENSSL_LH_strhash(char const   *c ) ;
#line 90
unsigned long OPENSSL_LH_num_items(OPENSSL_LHASH *lh ) ;
#line 91
unsigned long OPENSSL_LH_get_down_load(OPENSSL_LHASH *lh ) ;
#line 92
void OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh , unsigned long down_load ) ;
#line 95
void OPENSSL_LH_stats(OPENSSL_LHASH *lh , FILE *fp ) ;
#line 96
void OPENSSL_LH_node_stats(OPENSSL_LHASH *lh , FILE *fp ) ;
#line 97
void OPENSSL_LH_node_usage_stats(OPENSSL_LHASH *lh , FILE *fp ) ;
#line 99
void OPENSSL_LH_stats_bio(OPENSSL_LHASH *lh , BIO *out ) ;
#line 100
void OPENSSL_LH_node_stats_bio(OPENSSL_LHASH *lh , BIO *out ) ;
#line 101
void OPENSSL_LH_node_usage_stats_bio(OPENSSL_LHASH *lh , BIO *out ) ;
#line 252 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_STRING *ossl_check_OPENSSL_STRING_lh_plain_type(OPENSSL_STRING *ptr ) 
{ 


  {
#line 252
  return (ptr);
}
}
#line 252 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LHASH *ossl_check_const_OPENSSL_STRING_lh_type(struct lhash_st_OPENSSL_STRING *lh ) 
{ 


  {
#line 252
  return ((OPENSSL_LHASH *)lh);
}
}
#line 252 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_COMPFUNC ossl_check_OPENSSL_STRING_lh_compfunc_type(lh_OPENSSL_STRING_compfunc cmp ) 
{ 


  {
#line 252
  return ((OPENSSL_LH_COMPFUNC )cmp);
}
}
#line 252 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_HASHFUNC ossl_check_OPENSSL_STRING_lh_hashfunc_type(lh_OPENSSL_STRING_hashfunc hfn ) 
{ 


  {
#line 252
  return ((OPENSSL_LH_HASHFUNC )hfn);
}
}
#line 252 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_DOALL_FUNC ossl_check_OPENSSL_STRING_lh_doallfunc_type(lh_OPENSSL_STRING_doallfunc dfn ) 
{ 


  {
#line 252
  return ((OPENSSL_LH_DOALL_FUNC )dfn);
}
}
#line 267 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_CSTRING *ossl_check_OPENSSL_CSTRING_lh_plain_type(OPENSSL_CSTRING *ptr ) 
{ 


  {
#line 267
  return (ptr);
}
}
#line 267 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LHASH *ossl_check_const_OPENSSL_CSTRING_lh_type(struct lhash_st_OPENSSL_CSTRING *lh ) 
{ 


  {
#line 267
  return ((OPENSSL_LHASH *)lh);
}
}
#line 267 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_COMPFUNC ossl_check_OPENSSL_CSTRING_lh_compfunc_type(lh_OPENSSL_CSTRING_compfunc cmp ) 
{ 


  {
#line 267
  return ((OPENSSL_LH_COMPFUNC )cmp);
}
}
#line 267 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_HASHFUNC ossl_check_OPENSSL_CSTRING_lh_hashfunc_type(lh_OPENSSL_CSTRING_hashfunc hfn ) 
{ 


  {
#line 267
  return ((OPENSSL_LH_HASHFUNC )hfn);
}
}
#line 267 "/usr/include/openssl/lhash.h"
__inline static OPENSSL_LH_DOALL_FUNC ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(lh_OPENSSL_CSTRING_doallfunc dfn ) 
{ 


  {
#line 267
  return ((OPENSSL_LH_DOALL_FUNC )dfn);
}
}
#line 68 "/usr/include/openssl/x509_vfy.h"
__inline static X509_LOOKUP *ossl_check_X509_LOOKUP_type(X509_LOOKUP *ptr ) 
{ 


  {
#line 68
  return (ptr);
}
}
#line 68 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_LOOKUP_sk_type(struct stack_st_X509_LOOKUP *sk ) 
{ 


  {
#line 68
  return ((OPENSSL_STACK *)sk);
}
}
#line 68 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_LOOKUP_compfunc_type(sk_X509_LOOKUP_compfunc cmp ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 68 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_LOOKUP_copyfunc_type(sk_X509_LOOKUP_copyfunc cpy ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 68 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_LOOKUP_freefunc_type(sk_X509_LOOKUP_freefunc fr ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 94 "/usr/include/openssl/x509_vfy.h"
__inline static X509_OBJECT *ossl_check_X509_OBJECT_type(X509_OBJECT *ptr ) 
{ 


  {
#line 94
  return (ptr);
}
}
#line 94 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_OBJECT_sk_type(struct stack_st_X509_OBJECT *sk ) 
{ 


  {
#line 94
  return ((OPENSSL_STACK *)sk);
}
}
#line 94 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_OBJECT_compfunc_type(sk_X509_OBJECT_compfunc cmp ) 
{ 


  {
#line 94
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 94 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_OBJECT_copyfunc_type(sk_X509_OBJECT_copyfunc cpy ) 
{ 


  {
#line 94
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 94 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_OBJECT_freefunc_type(sk_X509_OBJECT_freefunc fr ) 
{ 


  {
#line 94
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 120 "/usr/include/openssl/x509_vfy.h"
__inline static X509_VERIFY_PARAM *ossl_check_X509_VERIFY_PARAM_type(X509_VERIFY_PARAM *ptr ) 
{ 


  {
#line 120
  return (ptr);
}
}
#line 120 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_VERIFY_PARAM_sk_type(struct stack_st_X509_VERIFY_PARAM *sk ) 
{ 


  {
#line 120
  return ((OPENSSL_STACK *)sk);
}
}
#line 120 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_VERIFY_PARAM_compfunc_type(sk_X509_VERIFY_PARAM_compfunc cmp ) 
{ 


  {
#line 120
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 120 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_VERIFY_PARAM_copyfunc_type(sk_X509_VERIFY_PARAM_copyfunc cpy ) 
{ 


  {
#line 120
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 120 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_VERIFY_PARAM_freefunc_type(sk_X509_VERIFY_PARAM_freefunc fr ) 
{ 


  {
#line 120
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 157 "/usr/include/openssl/x509_vfy.h"
__inline static X509_TRUST *ossl_check_X509_TRUST_type(X509_TRUST *ptr ) 
{ 


  {
#line 157
  return (ptr);
}
}
#line 157 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_TRUST_sk_type(struct stack_st_X509_TRUST *sk ) 
{ 


  {
#line 157
  return ((OPENSSL_STACK *)sk);
}
}
#line 157 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_TRUST_compfunc_type(sk_X509_TRUST_compfunc cmp ) 
{ 


  {
#line 157
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 157 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_TRUST_copyfunc_type(sk_X509_TRUST_copyfunc cpy ) 
{ 


  {
#line 157
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 157 "/usr/include/openssl/x509_vfy.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_TRUST_freefunc_type(sk_X509_TRUST_freefunc fr ) 
{ 


  {
#line 157
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 214
int X509_TRUST_set(int *t , int trust ) ;
#line 215
int X509_TRUST_get_count(void) ;
#line 216
X509_TRUST *X509_TRUST_get0(int idx ) ;
#line 217
int X509_TRUST_get_by_id(int id ) ;
#line 218
int X509_TRUST_add(int id , int flags , int (*ck)(X509_TRUST * , X509 * , int  ) ,
                   char const   *name , int arg1 , void *arg2 ) ;
#line 220
void X509_TRUST_cleanup(void) ;
#line 221
int X509_TRUST_get_flags(X509_TRUST *xp ) ;
#line 222
char *X509_TRUST_get0_name(X509_TRUST *xp ) ;
#line 223
int X509_TRUST_get_trust(X509_TRUST *xp ) ;
#line 225
int X509_trusted(X509 *x ) ;
#line 226
int X509_add1_trust_object(X509 *x , ASN1_OBJECT *obj ) ;
#line 227
int X509_add1_reject_object(X509 *x , ASN1_OBJECT *obj ) ;
#line 228
void X509_trust_clear(X509 *x ) ;
#line 229
void X509_reject_clear(X509 *x ) ;
#line 230
struct stack_st_ASN1_OBJECT *X509_get0_trust_objects(X509 *x ) ;
#line 231
struct stack_st_ASN1_OBJECT *X509_get0_reject_objects(X509 *x ) ;
#line 233
int (*X509_TRUST_set_default(int (*trust)(int  , X509 * , int  ) ))(int  , X509 * ,
                                                                    int  ) ;
#line 235
int X509_check_trust(X509 *x , int id , int flags ) ;
#line 237
int X509_verify_cert(X509_STORE_CTX *ctx ) ;
#line 238
int X509_STORE_CTX_verify(X509_STORE_CTX *ctx ) ;
#line 239
struct stack_st_X509 *X509_build_chain(X509 *target , struct stack_st_X509 *certs ,
                                       X509_STORE *store , int with_self_signed ,
                                       OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 243
int X509_STORE_set_depth(X509_STORE *store , int depth ) ;
#line 246
int X509_STORE_CTX_print_verify_cb(int ok , X509_STORE_CTX *ctx ) ;
#line 267
void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx , int depth ) ;
#line 478
int X509_OBJECT_idx_by_subject(struct stack_st_X509_OBJECT *h , X509_LOOKUP_TYPE type ,
                               X509_NAME *name ) ;
#line 480
X509_OBJECT *X509_OBJECT_retrieve_by_subject(struct stack_st_X509_OBJECT *h , X509_LOOKUP_TYPE type ,
                                             X509_NAME *name ) ;
#line 483
X509_OBJECT *X509_OBJECT_retrieve_match(struct stack_st_X509_OBJECT *h , X509_OBJECT *x ) ;
#line 485
int X509_OBJECT_up_ref_count(X509_OBJECT *a ) ;
#line 486
X509_OBJECT *X509_OBJECT_new(void) ;
#line 487
void X509_OBJECT_free(X509_OBJECT *a ) ;
#line 488
X509_LOOKUP_TYPE X509_OBJECT_get_type(X509_OBJECT *a ) ;
#line 489
X509 *X509_OBJECT_get0_X509(X509_OBJECT *a ) ;
#line 490
int X509_OBJECT_set1_X509(X509_OBJECT *a , X509 *obj ) ;
#line 491
X509_CRL *X509_OBJECT_get0_X509_CRL(X509_OBJECT *a ) ;
#line 492
int X509_OBJECT_set1_X509_CRL(X509_OBJECT *a , X509_CRL *obj ) ;
#line 493
X509_STORE *X509_STORE_new(void) ;
#line 494
void X509_STORE_free(X509_STORE *v ) ;
#line 495
int X509_STORE_lock(X509_STORE *ctx ) ;
#line 496
int X509_STORE_unlock(X509_STORE *ctx ) ;
#line 497
int X509_STORE_up_ref(X509_STORE *v ) ;
#line 498
struct stack_st_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *v ) ;
#line 499
struct stack_st_X509 *X509_STORE_get1_all_certs(X509_STORE *st ) ;
#line 500
struct stack_st_X509 *X509_STORE_CTX_get1_certs(X509_STORE_CTX *st , X509_NAME *nm ) ;
#line 502
struct stack_st_X509_CRL *X509_STORE_CTX_get1_crls(X509_STORE_CTX *st , X509_NAME *nm ) ;
#line 504
int X509_STORE_set_flags(X509_STORE *ctx , unsigned long flags ) ;
#line 505
int X509_STORE_set_purpose(X509_STORE *ctx , int purpose ) ;
#line 506
int X509_STORE_set_trust(X509_STORE *ctx , int trust ) ;
#line 507
int X509_STORE_set1_param(X509_STORE *ctx , X509_VERIFY_PARAM *pm ) ;
#line 508
X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *ctx ) ;
#line 510
void X509_STORE_set_verify(X509_STORE *ctx , X509_STORE_CTX_verify_fn verify ) ;
#line 513
void X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx , X509_STORE_CTX_verify_fn verify ) ;
#line 515
X509_STORE_CTX_verify_fn X509_STORE_get_verify(X509_STORE *ctx ) ;
#line 516
void X509_STORE_set_verify_cb(X509_STORE *ctx , X509_STORE_CTX_verify_cb verify_cb ) ;
#line 520
X509_STORE_CTX_verify_cb X509_STORE_get_verify_cb(X509_STORE *ctx ) ;
#line 521
void X509_STORE_set_get_issuer(X509_STORE *ctx , X509_STORE_CTX_get_issuer_fn get_issuer ) ;
#line 523
X509_STORE_CTX_get_issuer_fn X509_STORE_get_get_issuer(X509_STORE *ctx ) ;
#line 524
void X509_STORE_set_check_issued(X509_STORE *ctx , X509_STORE_CTX_check_issued_fn check_issued ) ;
#line 526
X509_STORE_CTX_check_issued_fn X509_STORE_get_check_issued(X509_STORE *ctx ) ;
#line 527
void X509_STORE_set_check_revocation(X509_STORE *ctx , X509_STORE_CTX_check_revocation_fn check_revocation ) ;
#line 530
X509_STORE_CTX_check_revocation_fn X509_STORE_get_check_revocation(X509_STORE *ctx ) ;
#line 531
void X509_STORE_set_get_crl(X509_STORE *ctx , X509_STORE_CTX_get_crl_fn get_crl ) ;
#line 533
X509_STORE_CTX_get_crl_fn X509_STORE_get_get_crl(X509_STORE *ctx ) ;
#line 534
void X509_STORE_set_check_crl(X509_STORE *ctx , X509_STORE_CTX_check_crl_fn check_crl ) ;
#line 536
X509_STORE_CTX_check_crl_fn X509_STORE_get_check_crl(X509_STORE *ctx ) ;
#line 537
void X509_STORE_set_cert_crl(X509_STORE *ctx , X509_STORE_CTX_cert_crl_fn cert_crl ) ;
#line 539
X509_STORE_CTX_cert_crl_fn X509_STORE_get_cert_crl(X509_STORE *ctx ) ;
#line 540
void X509_STORE_set_check_policy(X509_STORE *ctx , X509_STORE_CTX_check_policy_fn check_policy ) ;
#line 542
X509_STORE_CTX_check_policy_fn X509_STORE_get_check_policy(X509_STORE *ctx ) ;
#line 543
void X509_STORE_set_lookup_certs(X509_STORE *ctx , X509_STORE_CTX_lookup_certs_fn lookup_certs ) ;
#line 545
X509_STORE_CTX_lookup_certs_fn X509_STORE_get_lookup_certs(X509_STORE *ctx ) ;
#line 546
void X509_STORE_set_lookup_crls(X509_STORE *ctx , X509_STORE_CTX_lookup_crls_fn lookup_crls ) ;
#line 550
X509_STORE_CTX_lookup_crls_fn X509_STORE_get_lookup_crls(X509_STORE *ctx ) ;
#line 551
void X509_STORE_set_cleanup(X509_STORE *ctx , X509_STORE_CTX_cleanup_fn cleanup ) ;
#line 553
X509_STORE_CTX_cleanup_fn X509_STORE_get_cleanup(X509_STORE *ctx ) ;
#line 557
int X509_STORE_set_ex_data(X509_STORE *ctx , int idx , void *data ) ;
#line 558
void *X509_STORE_get_ex_data(X509_STORE *ctx , int idx ) ;
#line 560
X509_STORE_CTX *X509_STORE_CTX_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 561
X509_STORE_CTX *X509_STORE_CTX_new(void) ;
#line 563
int X509_STORE_CTX_get1_issuer(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
#line 565
void X509_STORE_CTX_free(X509_STORE_CTX *ctx ) ;
#line 566
int X509_STORE_CTX_init(X509_STORE_CTX *ctx , X509_STORE *trust_store , X509 *target ,
                        struct stack_st_X509 *untrusted ) ;
#line 568
void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx , struct stack_st_X509 *sk ) ;
#line 569
void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx ) ;
#line 571
X509_STORE *X509_STORE_CTX_get0_store(X509_STORE_CTX *ctx ) ;
#line 572
X509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx ) ;
#line 573
struct stack_st_X509 *X509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx ) ;
#line 574
void X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx , struct stack_st_X509 *sk ) ;
#line 575
void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx , X509_STORE_CTX_verify_cb verify ) ;
#line 577
X509_STORE_CTX_verify_cb X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx ) ;
#line 578
X509_STORE_CTX_verify_fn X509_STORE_CTX_get_verify(X509_STORE_CTX *ctx ) ;
#line 579
X509_STORE_CTX_get_issuer_fn X509_STORE_CTX_get_get_issuer(X509_STORE_CTX *ctx ) ;
#line 580
X509_STORE_CTX_check_issued_fn X509_STORE_CTX_get_check_issued(X509_STORE_CTX *ctx ) ;
#line 581
X509_STORE_CTX_check_revocation_fn X509_STORE_CTX_get_check_revocation(X509_STORE_CTX *ctx ) ;
#line 582
X509_STORE_CTX_get_crl_fn X509_STORE_CTX_get_get_crl(X509_STORE_CTX *ctx ) ;
#line 583
X509_STORE_CTX_check_crl_fn X509_STORE_CTX_get_check_crl(X509_STORE_CTX *ctx ) ;
#line 584
X509_STORE_CTX_cert_crl_fn X509_STORE_CTX_get_cert_crl(X509_STORE_CTX *ctx ) ;
#line 585
X509_STORE_CTX_check_policy_fn X509_STORE_CTX_get_check_policy(X509_STORE_CTX *ctx ) ;
#line 586
X509_STORE_CTX_lookup_certs_fn X509_STORE_CTX_get_lookup_certs(X509_STORE_CTX *ctx ) ;
#line 587
X509_STORE_CTX_lookup_crls_fn X509_STORE_CTX_get_lookup_crls(X509_STORE_CTX *ctx ) ;
#line 588
X509_STORE_CTX_cleanup_fn X509_STORE_CTX_get_cleanup(X509_STORE_CTX *ctx ) ;
#line 603
X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v , X509_LOOKUP_METHOD *m ) ;
#line 604
X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void) ;
#line 605
X509_LOOKUP_METHOD *X509_LOOKUP_file(void) ;
#line 606
X509_LOOKUP_METHOD *X509_LOOKUP_store(void) ;
#line 640
X509_LOOKUP_METHOD *X509_LOOKUP_meth_new(char const   *name ) ;
#line 641
void X509_LOOKUP_meth_free(X509_LOOKUP_METHOD *method ) ;
#line 643
int X509_LOOKUP_meth_set_new_item(X509_LOOKUP_METHOD *method , int (*new_item)(X509_LOOKUP * ) ) ;
#line 645
int (*X509_LOOKUP_meth_get_new_item(X509_LOOKUP_METHOD *method ))(X509_LOOKUP * ) ;
#line 648
int X509_LOOKUP_meth_set_free(X509_LOOKUP_METHOD *method , void (*free_fn)(X509_LOOKUP * ) ) ;
#line 650
void (*X509_LOOKUP_meth_get_free(X509_LOOKUP_METHOD *method ))(X509_LOOKUP * ) ;
#line 653
int X509_LOOKUP_meth_set_init(X509_LOOKUP_METHOD *method , int (*init)(X509_LOOKUP * ) ) ;
#line 655
int (*X509_LOOKUP_meth_get_init(X509_LOOKUP_METHOD *method ))(X509_LOOKUP * ) ;
#line 658
int X509_LOOKUP_meth_set_shutdown(X509_LOOKUP_METHOD *method , int (*shutdown)(X509_LOOKUP * ) ) ;
#line 660
int (*X509_LOOKUP_meth_get_shutdown(X509_LOOKUP_METHOD *method ))(X509_LOOKUP * ) ;
#line 663
int X509_LOOKUP_meth_set_ctrl(X509_LOOKUP_METHOD *method , X509_LOOKUP_ctrl_fn ctrl_fn ) ;
#line 665
X509_LOOKUP_ctrl_fn X509_LOOKUP_meth_get_ctrl(X509_LOOKUP_METHOD *method ) ;
#line 667
int X509_LOOKUP_meth_set_get_by_subject(X509_LOOKUP_METHOD *method , X509_LOOKUP_get_by_subject_fn fn ) ;
#line 669
X509_LOOKUP_get_by_subject_fn X509_LOOKUP_meth_get_get_by_subject(X509_LOOKUP_METHOD *method ) ;
#line 672
int X509_LOOKUP_meth_set_get_by_issuer_serial(X509_LOOKUP_METHOD *method , X509_LOOKUP_get_by_issuer_serial_fn fn ) ;
#line 674
X509_LOOKUP_get_by_issuer_serial_fn X509_LOOKUP_meth_get_get_by_issuer_serial(X509_LOOKUP_METHOD *method ) ;
#line 677
int X509_LOOKUP_meth_set_get_by_fingerprint(X509_LOOKUP_METHOD *method , X509_LOOKUP_get_by_fingerprint_fn fn ) ;
#line 679
X509_LOOKUP_get_by_fingerprint_fn X509_LOOKUP_meth_get_get_by_fingerprint(X509_LOOKUP_METHOD *method ) ;
#line 682
int X509_LOOKUP_meth_set_get_by_alias(X509_LOOKUP_METHOD *method , X509_LOOKUP_get_by_alias_fn fn ) ;
#line 684
X509_LOOKUP_get_by_alias_fn X509_LOOKUP_meth_get_get_by_alias(X509_LOOKUP_METHOD *method ) ;
#line 688
int X509_STORE_add_cert(X509_STORE *ctx , X509 *x ) ;
#line 689
int X509_STORE_add_crl(X509_STORE *ctx , X509_CRL *x ) ;
#line 691
int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs , X509_LOOKUP_TYPE type , X509_NAME *name ,
                                  X509_OBJECT *ret ) ;
#line 694
X509_OBJECT *X509_STORE_CTX_get_obj_by_subject(X509_STORE_CTX *vs , X509_LOOKUP_TYPE type ,
                                               X509_NAME *name ) ;
#line 698
int X509_LOOKUP_ctrl(X509_LOOKUP *ctx , int cmd , char const   *argc , long argl ,
                     char **ret ) ;
#line 700
int X509_LOOKUP_ctrl_ex(X509_LOOKUP *ctx , int cmd , char const   *argc , long argl ,
                        char **ret , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 703
int X509_load_cert_file(X509_LOOKUP *ctx , char const   *file , int type ) ;
#line 704
int X509_load_cert_file_ex(X509_LOOKUP *ctx , char const   *file , int type , OSSL_LIB_CTX *libctx ,
                           char const   *propq ) ;
#line 706
int X509_load_crl_file(X509_LOOKUP *ctx , char const   *file , int type ) ;
#line 707
int X509_load_cert_crl_file(X509_LOOKUP *ctx , char const   *file , int type ) ;
#line 708
int X509_load_cert_crl_file_ex(X509_LOOKUP *ctx , char const   *file , int type ,
                               OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 711
X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method ) ;
#line 712
void X509_LOOKUP_free(X509_LOOKUP *ctx ) ;
#line 713
int X509_LOOKUP_init(X509_LOOKUP *ctx ) ;
#line 714
int X509_LOOKUP_by_subject(X509_LOOKUP *ctx , X509_LOOKUP_TYPE type , X509_NAME *name ,
                           X509_OBJECT *ret ) ;
#line 716
int X509_LOOKUP_by_subject_ex(X509_LOOKUP *ctx , X509_LOOKUP_TYPE type , X509_NAME *name ,
                              X509_OBJECT *ret , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 719
int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx , X509_LOOKUP_TYPE type , X509_NAME *name ,
                                 ASN1_INTEGER *serial , X509_OBJECT *ret ) ;
#line 723
int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx , X509_LOOKUP_TYPE type , unsigned char const   *bytes ,
                               int len , X509_OBJECT *ret ) ;
#line 726
int X509_LOOKUP_by_alias(X509_LOOKUP *ctx , X509_LOOKUP_TYPE type , char const   *str ,
                         int len , X509_OBJECT *ret ) ;
#line 728
int X509_LOOKUP_set_method_data(X509_LOOKUP *ctx , void *data ) ;
#line 729
void *X509_LOOKUP_get_method_data(X509_LOOKUP *ctx ) ;
#line 730
X509_STORE *X509_LOOKUP_get_store(X509_LOOKUP *ctx ) ;
#line 731
int X509_LOOKUP_shutdown(X509_LOOKUP *ctx ) ;
#line 733
int X509_STORE_load_file(X509_STORE *ctx , char const   *file ) ;
#line 734
int X509_STORE_load_path(X509_STORE *ctx , char const   *path ) ;
#line 735
int X509_STORE_load_store(X509_STORE *ctx , char const   *store ) ;
#line 736
int X509_STORE_load_locations(X509_STORE *ctx , char const   *file , char const   *dir ) ;
#line 739
int X509_STORE_set_default_paths(X509_STORE *ctx ) ;
#line 741
int X509_STORE_load_file_ex(X509_STORE *ctx , char const   *file , OSSL_LIB_CTX *libctx ,
                            char const   *propq ) ;
#line 743
int X509_STORE_load_store_ex(X509_STORE *ctx , char const   *store , OSSL_LIB_CTX *libctx ,
                             char const   *propq ) ;
#line 745
int X509_STORE_load_locations_ex(X509_STORE *ctx , char const   *file , char const   *dir ,
                                 OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 748
int X509_STORE_set_default_paths_ex(X509_STORE *ctx , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 753
int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx , int idx , void *data ) ;
#line 754
void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx , int idx ) ;
#line 755
int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx ) ;
#line 756
void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx , int s ) ;
#line 757
int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx ) ;
#line 758
void X509_STORE_CTX_set_error_depth(X509_STORE_CTX *ctx , int depth ) ;
#line 759
X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx ) ;
#line 760
void X509_STORE_CTX_set_current_cert(X509_STORE_CTX *ctx , X509 *x ) ;
#line 761
X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx ) ;
#line 762
X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx ) ;
#line 763
X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx ) ;
#line 764
struct stack_st_X509 *X509_STORE_CTX_get0_chain(X509_STORE_CTX *ctx ) ;
#line 765
struct stack_st_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx ) ;
#line 766
void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx , X509 *target ) ;
#line 767
void X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *c , struct stack_st_X509 *sk ) ;
#line 768
void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx , struct stack_st_X509_CRL *sk ) ;
#line 769
int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx , int purpose ) ;
#line 770
int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx , int trust ) ;
#line 771
int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx , int def_purpose , int purpose ,
                                   int trust ) ;
#line 773
void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx , unsigned long flags ) ;
#line 774
void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx , unsigned long flags , time_t t ) ;
#line 777
X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx ) ;
#line 778
int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx ) ;
#line 779
int X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx ) ;
#line 781
X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx ) ;
#line 782
void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx , X509_VERIFY_PARAM *param ) ;
#line 783
int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx , char const   *name ) ;
#line 789
void X509_STORE_CTX_set0_dane(X509_STORE_CTX *ctx , SSL_DANE *dane ) ;
#line 794
X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void) ;
#line 795
void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param ) ;
#line 796
int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to , X509_VERIFY_PARAM *from ) ;
#line 798
int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to , X509_VERIFY_PARAM *from ) ;
#line 800
int X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param , char const   *name ) ;
#line 801
int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param , unsigned long flags ) ;
#line 803
int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param , unsigned long flags ) ;
#line 805
unsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param ) ;
#line 806
int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param , int purpose ) ;
#line 807
int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param , int trust ) ;
#line 808
void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param , int depth ) ;
#line 809
void X509_VERIFY_PARAM_set_auth_level(X509_VERIFY_PARAM *param , int auth_level ) ;
#line 810
time_t X509_VERIFY_PARAM_get_time(X509_VERIFY_PARAM *param ) ;
#line 811
void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param , time_t t ) ;
#line 812
int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param , ASN1_OBJECT *policy ) ;
#line 814
int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param , struct stack_st_ASN1_OBJECT *policies ) ;
#line 817
int X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM *param , uint32_t flags ) ;
#line 819
uint32_t X509_VERIFY_PARAM_get_inh_flags(X509_VERIFY_PARAM *param ) ;
#line 821
char *X509_VERIFY_PARAM_get0_host(X509_VERIFY_PARAM *param , int idx ) ;
#line 822
int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param , char const   *name , size_t namelen ) ;
#line 824
int X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param , char const   *name , size_t namelen ) ;
#line 826
void X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param , unsigned int flags ) ;
#line 828
unsigned int X509_VERIFY_PARAM_get_hostflags(X509_VERIFY_PARAM *param ) ;
#line 829
char *X509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *param ) ;
#line 830
void X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM * , X509_VERIFY_PARAM * ) ;
#line 831
char *X509_VERIFY_PARAM_get0_email(X509_VERIFY_PARAM *param ) ;
#line 832
int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param , char const   *email ,
                                 size_t emaillen ) ;
#line 834
char *X509_VERIFY_PARAM_get1_ip_asc(X509_VERIFY_PARAM *param ) ;
#line 835
int X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param , unsigned char const   *ip ,
                              size_t iplen ) ;
#line 837
int X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param , char const   *ipasc ) ;
#line 840
int X509_VERIFY_PARAM_get_depth(X509_VERIFY_PARAM *param ) ;
#line 841
int X509_VERIFY_PARAM_get_auth_level(X509_VERIFY_PARAM *param ) ;
#line 842
char const   *X509_VERIFY_PARAM_get0_name(X509_VERIFY_PARAM *param ) ;
#line 844
int X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param ) ;
#line 845
int X509_VERIFY_PARAM_get_count(void) ;
#line 846
X509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id ) ;
#line 847
X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(char const   *name ) ;
#line 848
void X509_VERIFY_PARAM_table_cleanup(void) ;
#line 863
int X509_policy_check(X509_POLICY_TREE **ptree , int *pexplicit_policy , struct stack_st_X509 *certs ,
                      struct stack_st_ASN1_OBJECT *policy_oids , unsigned int flags ) ;
#line 867
void X509_policy_tree_free(X509_POLICY_TREE *tree ) ;
#line 869
int X509_policy_tree_level_count(X509_POLICY_TREE *tree ) ;
#line 870
X509_POLICY_LEVEL *X509_policy_tree_get0_level(X509_POLICY_TREE *tree , int i ) ;
#line 874
struct stack_st_X509_POLICY_NODE *X509_policy_tree_get0_policies(X509_POLICY_TREE *tree ) ;
#line 877
struct stack_st_X509_POLICY_NODE *X509_policy_tree_get0_user_policies(X509_POLICY_TREE *tree ) ;
#line 879
int X509_policy_level_node_count(X509_POLICY_LEVEL *level ) ;
#line 881
X509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level , int i ) ;
#line 884
ASN1_OBJECT *X509_policy_node_get0_policy(X509_POLICY_NODE *node ) ;
#line 887
struct stack_st_POLICYQUALINFO *X509_policy_node_get0_qualifiers(X509_POLICY_NODE *node ) ;
#line 889
X509_POLICY_NODE *X509_policy_node_get0_parent(X509_POLICY_NODE *node ) ;
#line 66 "/usr/include/openssl/pkcs7.h"
__inline static PKCS7_SIGNER_INFO *ossl_check_PKCS7_SIGNER_INFO_type(PKCS7_SIGNER_INFO *ptr ) 
{ 


  {
#line 66
  return (ptr);
}
}
#line 66 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_STACK *ossl_check_const_PKCS7_SIGNER_INFO_sk_type(struct stack_st_PKCS7_SIGNER_INFO *sk ) 
{ 


  {
#line 66
  return ((OPENSSL_STACK *)sk);
}
}
#line 66 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_compfunc ossl_check_PKCS7_SIGNER_INFO_compfunc_type(sk_PKCS7_SIGNER_INFO_compfunc cmp ) 
{ 


  {
#line 66
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 66 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_copyfunc ossl_check_PKCS7_SIGNER_INFO_copyfunc_type(sk_PKCS7_SIGNER_INFO_copyfunc cpy ) 
{ 


  {
#line 66
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 66 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_freefunc ossl_check_PKCS7_SIGNER_INFO_freefunc_type(sk_PKCS7_SIGNER_INFO_freefunc fr ) 
{ 


  {
#line 66
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 102 "/usr/include/openssl/pkcs7.h"
__inline static PKCS7_RECIP_INFO *ossl_check_PKCS7_RECIP_INFO_type(PKCS7_RECIP_INFO *ptr ) 
{ 


  {
#line 102
  return (ptr);
}
}
#line 102 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_STACK *ossl_check_const_PKCS7_RECIP_INFO_sk_type(struct stack_st_PKCS7_RECIP_INFO *sk ) 
{ 


  {
#line 102
  return ((OPENSSL_STACK *)sk);
}
}
#line 102 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_compfunc ossl_check_PKCS7_RECIP_INFO_compfunc_type(sk_PKCS7_RECIP_INFO_compfunc cmp ) 
{ 


  {
#line 102
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 102 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_copyfunc ossl_check_PKCS7_RECIP_INFO_copyfunc_type(sk_PKCS7_RECIP_INFO_copyfunc cpy ) 
{ 


  {
#line 102
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 102 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_freefunc ossl_check_PKCS7_RECIP_INFO_freefunc_type(sk_PKCS7_RECIP_INFO_freefunc fr ) 
{ 


  {
#line 102
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 217 "/usr/include/openssl/pkcs7.h"
__inline static PKCS7 *ossl_check_PKCS7_type(PKCS7 *ptr ) 
{ 


  {
#line 217
  return (ptr);
}
}
#line 217 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_STACK *ossl_check_const_PKCS7_sk_type(struct stack_st_PKCS7 *sk ) 
{ 


  {
#line 217
  return ((OPENSSL_STACK *)sk);
}
}
#line 217 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_compfunc ossl_check_PKCS7_compfunc_type(sk_PKCS7_compfunc cmp ) 
{ 


  {
#line 217
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 217 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_copyfunc ossl_check_PKCS7_copyfunc_type(sk_PKCS7_copyfunc cpy ) 
{ 


  {
#line 217
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 217 "/usr/include/openssl/pkcs7.h"
__inline static OPENSSL_sk_freefunc ossl_check_PKCS7_freefunc_type(sk_PKCS7_freefunc fr ) 
{ 


  {
#line 217
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 302
extern PKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void) ;
#line 302
extern void PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a ) ;
#line 302
extern PKCS7_ISSUER_AND_SERIAL *d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a ,
                                                            unsigned char const   **in ,
                                                            long len ) ;
#line 302
extern int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a , unsigned char **out ) ;
#line 302
extern ASN1_ITEM *PKCS7_ISSUER_AND_SERIAL_it(void) ;
#line 304
int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data , EVP_MD *type ,
                                   unsigned char *md , unsigned int *len ) ;
#line 308
PKCS7 *d2i_PKCS7_fp(FILE *fp , PKCS7 **p7 ) ;
#line 309
int i2d_PKCS7_fp(FILE *fp , PKCS7 *p7 ) ;
#line 311
extern PKCS7 *PKCS7_dup(PKCS7 *a ) ;
#line 312
PKCS7 *d2i_PKCS7_bio(BIO *bp , PKCS7 **p7 ) ;
#line 313
int i2d_PKCS7_bio(BIO *bp , PKCS7 *p7 ) ;
#line 314
int i2d_PKCS7_bio_stream(BIO *out , PKCS7 *p7 , BIO *in , int flags ) ;
#line 315
int PEM_write_bio_PKCS7_stream(BIO *out , PKCS7 *p7 , BIO *in , int flags ) ;
#line 317
extern PKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void) ;
#line 317
extern void PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a ) ;
#line 317
extern PKCS7_SIGNER_INFO *d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a , unsigned char const   **in ,
                                                long len ) ;
#line 317
extern int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a , unsigned char **out ) ;
#line 317
extern ASN1_ITEM *PKCS7_SIGNER_INFO_it(void) ;
#line 318
extern PKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void) ;
#line 318
extern void PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a ) ;
#line 318
extern PKCS7_RECIP_INFO *d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a , unsigned char const   **in ,
                                              long len ) ;
#line 318
extern int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a , unsigned char **out ) ;
#line 318
extern ASN1_ITEM *PKCS7_RECIP_INFO_it(void) ;
#line 319
extern PKCS7_SIGNED *PKCS7_SIGNED_new(void) ;
#line 319
extern void PKCS7_SIGNED_free(PKCS7_SIGNED *a ) ;
#line 319
extern PKCS7_SIGNED *d2i_PKCS7_SIGNED(PKCS7_SIGNED **a , unsigned char const   **in ,
                                      long len ) ;
#line 319
extern int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a , unsigned char **out ) ;
#line 319
extern ASN1_ITEM *PKCS7_SIGNED_it(void) ;
#line 320
extern PKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void) ;
#line 320
extern void PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a ) ;
#line 320
extern PKCS7_ENC_CONTENT *d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a , unsigned char const   **in ,
                                                long len ) ;
#line 320
extern int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a , unsigned char **out ) ;
#line 320
extern ASN1_ITEM *PKCS7_ENC_CONTENT_it(void) ;
#line 321
extern PKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void) ;
#line 321
extern void PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a ) ;
#line 321
extern PKCS7_ENVELOPE *d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a , unsigned char const   **in ,
                                          long len ) ;
#line 321
extern int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a , unsigned char **out ) ;
#line 321
extern ASN1_ITEM *PKCS7_ENVELOPE_it(void) ;
#line 322
extern PKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void) ;
#line 322
extern void PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a ) ;
#line 322
extern PKCS7_SIGN_ENVELOPE *d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a , unsigned char const   **in ,
                                                    long len ) ;
#line 322
extern int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a , unsigned char **out ) ;
#line 322
extern ASN1_ITEM *PKCS7_SIGN_ENVELOPE_it(void) ;
#line 323
extern PKCS7_DIGEST *PKCS7_DIGEST_new(void) ;
#line 323
extern void PKCS7_DIGEST_free(PKCS7_DIGEST *a ) ;
#line 323
extern PKCS7_DIGEST *d2i_PKCS7_DIGEST(PKCS7_DIGEST **a , unsigned char const   **in ,
                                      long len ) ;
#line 323
extern int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a , unsigned char **out ) ;
#line 323
extern ASN1_ITEM *PKCS7_DIGEST_it(void) ;
#line 324
extern PKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void) ;
#line 324
extern void PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a ) ;
#line 324
extern PKCS7_ENCRYPT *d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a , unsigned char const   **in ,
                                        long len ) ;
#line 324
extern int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a , unsigned char **out ) ;
#line 324
extern ASN1_ITEM *PKCS7_ENCRYPT_it(void) ;
#line 325
extern PKCS7 *PKCS7_new(void) ;
#line 325
extern void PKCS7_free(PKCS7 *a ) ;
#line 325
extern PKCS7 *d2i_PKCS7(PKCS7 **a , unsigned char const   **in , long len ) ;
#line 325
extern int i2d_PKCS7(PKCS7 *a , unsigned char **out ) ;
#line 325
extern ASN1_ITEM *PKCS7_it(void) ;
#line 326
PKCS7 *PKCS7_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 328
extern ASN1_ITEM *PKCS7_ATTR_SIGN_it(void) ;
#line 329
extern ASN1_ITEM *PKCS7_ATTR_VERIFY_it(void) ;
#line 331
extern int i2d_PKCS7_NDEF(PKCS7 *a , unsigned char **out ) ;
#line 332
extern int PKCS7_print_ctx(BIO *out , PKCS7 *x , int indent , ASN1_PCTX *pctx ) ;
#line 334
long PKCS7_ctrl(PKCS7 *p7 , int cmd , long larg , char *parg ) ;
#line 336
int PKCS7_type_is_other(PKCS7 *p7 ) ;
#line 337
int PKCS7_set_type(PKCS7 *p7 , int type ) ;
#line 338
int PKCS7_set0_type_other(PKCS7 *p7 , int type , ASN1_TYPE *other ) ;
#line 339
int PKCS7_set_content(PKCS7 *p7 , PKCS7 *p7_data ) ;
#line 340
int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i , X509 *x509 , EVP_PKEY *pkey , EVP_MD *dgst ) ;
#line 342
int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si ) ;
#line 343
int PKCS7_add_signer(PKCS7 *p7 , PKCS7_SIGNER_INFO *p7i ) ;
#line 344
int PKCS7_add_certificate(PKCS7 *p7 , X509 *x509 ) ;
#line 345
int PKCS7_add_crl(PKCS7 *p7 , X509_CRL *x509 ) ;
#line 346
int PKCS7_content_new(PKCS7 *p7 , int nid ) ;
#line 347
int PKCS7_dataVerify(X509_STORE *cert_store , X509_STORE_CTX *ctx , BIO *bio , PKCS7 *p7 ,
                     PKCS7_SIGNER_INFO *si ) ;
#line 349
int PKCS7_signatureVerify(BIO *bio , PKCS7 *p7 , PKCS7_SIGNER_INFO *si , X509 *x509 ) ;
#line 352
BIO *PKCS7_dataInit(PKCS7 *p7 , BIO *bio ) ;
#line 353
int PKCS7_dataFinal(PKCS7 *p7 , BIO *bio ) ;
#line 354
BIO *PKCS7_dataDecode(PKCS7 *p7 , EVP_PKEY *pkey , BIO *in_bio , X509 *pcert ) ;
#line 356
PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7 , X509 *x509 , EVP_PKEY *pkey , EVP_MD *dgst ) ;
#line 358
X509 *PKCS7_cert_from_signer_info(PKCS7 *p7 , PKCS7_SIGNER_INFO *si ) ;
#line 359
int PKCS7_set_digest(PKCS7 *p7 , EVP_MD *md ) ;
#line 360
struct stack_st_PKCS7_SIGNER_INFO *PKCS7_get_signer_info(PKCS7 *p7 ) ;
#line 362
PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7 , X509 *x509 ) ;
#line 363
void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si , EVP_PKEY **pk , X509_ALGOR **pdig ,
                                 X509_ALGOR **psig ) ;
#line 365
void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri , X509_ALGOR **penc ) ;
#line 366
int PKCS7_add_recipient_info(PKCS7 *p7 , PKCS7_RECIP_INFO *ri ) ;
#line 367
int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i , X509 *x509 ) ;
#line 368
int PKCS7_set_cipher(PKCS7 *p7 , EVP_CIPHER *cipher ) ;
#line 369
int PKCS7_stream(unsigned char ***boundary , PKCS7 *p7 ) ;
#line 371
PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7 , int idx ) ;
#line 372
ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7 ) ;
#line 373
ASN1_OCTET_STRING *PKCS7_digest_from_attributes(struct stack_st_X509_ATTRIBUTE *sk ) ;
#line 374
int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si , int nid , int type , void *data ) ;
#line 376
int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si , int nid , int atrtype , void *value ) ;
#line 378
ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si , int nid ) ;
#line 379
ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si , int nid ) ;
#line 380
int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si , struct stack_st_X509_ATTRIBUTE *sk ) ;
#line 382
int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si , struct stack_st_X509_ATTRIBUTE *sk ) ;
#line 385
PKCS7 *PKCS7_sign(X509 *signcert , EVP_PKEY *pkey , struct stack_st_X509 *certs ,
                  BIO *data , int flags ) ;
#line 387
PKCS7 *PKCS7_sign_ex(X509 *signcert , EVP_PKEY *pkey , struct stack_st_X509 *certs ,
                     BIO *data , int flags , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 391
PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7 , X509 *signcert , EVP_PKEY *pkey ,
                                         EVP_MD *md , int flags ) ;
#line 395
int PKCS7_final(PKCS7 *p7 , BIO *data , int flags ) ;
#line 396
int PKCS7_verify(PKCS7 *p7 , struct stack_st_X509 *certs , X509_STORE *store , BIO *indata ,
                 BIO *out , int flags ) ;
#line 398
struct stack_st_X509 *PKCS7_get0_signers(PKCS7 *p7 , struct stack_st_X509 *certs ,
                                         int flags ) ;
#line 400
PKCS7 *PKCS7_encrypt(struct stack_st_X509 *certs , BIO *in , EVP_CIPHER *cipher ,
                     int flags ) ;
#line 402
PKCS7 *PKCS7_encrypt_ex(struct stack_st_X509 *certs , BIO *in , EVP_CIPHER *cipher ,
                        int flags , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 405
int PKCS7_decrypt(PKCS7 *p7 , EVP_PKEY *pkey , X509 *cert , BIO *data , int flags ) ;
#line 408
int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si , struct stack_st_X509_ALGOR *cap ) ;
#line 410
struct stack_st_X509_ALGOR *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si ) ;
#line 411
int PKCS7_simple_smimecap(struct stack_st_X509_ALGOR *sk , int nid , int arg ) ;
#line 413
int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si , ASN1_OBJECT *coid ) ;
#line 414
int PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si , ASN1_TIME *t ) ;
#line 415
int PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si , unsigned char const   *md , int mdlen ) ;
#line 418
int SMIME_write_PKCS7(BIO *bio , PKCS7 *p7 , BIO *data , int flags ) ;
#line 419
PKCS7 *SMIME_read_PKCS7_ex(BIO *bio , BIO **bcont , PKCS7 **p7 ) ;
#line 420
PKCS7 *SMIME_read_PKCS7(BIO *bio , BIO **bcont ) ;
#line 422
BIO *BIO_new_PKCS7(BIO *out , PKCS7 *p7 ) ;
#line 493 "/usr/include/openssl/x509.h"
void X509_CRL_set_default_method(X509_CRL_METHOD *meth ) ;
#line 494
X509_CRL_METHOD *X509_CRL_METHOD_new(int (*crl_init)(X509_CRL * ) , int (*crl_free)(X509_CRL * ) ,
                                     int (*crl_lookup)(X509_CRL * , X509_REVOKED ** ,
                                                       ASN1_INTEGER * , X509_NAME * ) ,
                                     int (*crl_verify)(X509_CRL * , EVP_PKEY * ) ) ;
#line 504
void X509_CRL_METHOD_free(X509_CRL_METHOD *m ) ;
#line 506
void X509_CRL_set_meth_data(X509_CRL *crl , void *dat ) ;
#line 507
void *X509_CRL_get_meth_data(X509_CRL *crl ) ;
#line 509
char const   *X509_verify_cert_error_string(long n ) ;
#line 511
int X509_verify(X509 *a , EVP_PKEY *r ) ;
#line 512
int X509_self_signed(X509 *cert , int verify_signature ) ;
#line 514
int X509_REQ_verify_ex(X509_REQ *a , EVP_PKEY *r , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 516
int X509_REQ_verify(X509_REQ *a , EVP_PKEY *r ) ;
#line 517
int X509_CRL_verify(X509_CRL *a , EVP_PKEY *r ) ;
#line 518
int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a , EVP_PKEY *r ) ;
#line 520
NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(char const   *str , int len ) ;
#line 521
char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *x ) ;
#line 522
EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x ) ;
#line 523
int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x , EVP_PKEY *pkey ) ;
#line 525
int NETSCAPE_SPKI_print(BIO *out , NETSCAPE_SPKI *spki ) ;
#line 527
int X509_signature_dump(BIO *bp , ASN1_STRING *sig , int indent ) ;
#line 528
int X509_signature_print(BIO *bp , X509_ALGOR *alg , ASN1_STRING *sig ) ;
#line 531
int X509_sign(X509 *x , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 532
int X509_sign_ctx(X509 *x , EVP_MD_CTX *ctx ) ;
#line 533
int X509_REQ_sign(X509_REQ *x , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 534
int X509_REQ_sign_ctx(X509_REQ *x , EVP_MD_CTX *ctx ) ;
#line 535
int X509_CRL_sign(X509_CRL *x , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 536
int X509_CRL_sign_ctx(X509_CRL *x , EVP_MD_CTX *ctx ) ;
#line 537
int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 539
int X509_pubkey_digest(X509 *data , EVP_MD *type , unsigned char *md , unsigned int *len ) ;
#line 541
int X509_digest(X509 *data , EVP_MD *type , unsigned char *md , unsigned int *len ) ;
#line 543
ASN1_OCTET_STRING *X509_digest_sig(X509 *cert , EVP_MD **md_used , int *md_is_fallback ) ;
#line 545
int X509_CRL_digest(X509_CRL *data , EVP_MD *type , unsigned char *md , unsigned int *len ) ;
#line 547
int X509_REQ_digest(X509_REQ *data , EVP_MD *type , unsigned char *md , unsigned int *len ) ;
#line 549
int X509_NAME_digest(X509_NAME *data , EVP_MD *type , unsigned char *md , unsigned int *len ) ;
#line 552
X509 *X509_load_http(char const   *url , BIO *bio , BIO *rbio , int timeout ) ;
#line 553
X509_CRL *X509_CRL_load_http(char const   *url , BIO *bio , BIO *rbio , int timeout ) ;
#line 41 "/usr/include/openssl/conf.h"
__inline static CONF_VALUE *ossl_check_CONF_VALUE_type(CONF_VALUE *ptr ) 
{ 


  {
#line 41
  return (ptr);
}
}
#line 41 "/usr/include/openssl/conf.h"
__inline static OPENSSL_STACK *ossl_check_const_CONF_VALUE_sk_type(struct stack_st_CONF_VALUE *sk ) 
{ 


  {
#line 41
  return ((OPENSSL_STACK *)sk);
}
}
#line 41 "/usr/include/openssl/conf.h"
__inline static OPENSSL_sk_compfunc ossl_check_CONF_VALUE_compfunc_type(sk_CONF_VALUE_compfunc cmp ) 
{ 


  {
#line 41
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 41 "/usr/include/openssl/conf.h"
__inline static OPENSSL_sk_copyfunc ossl_check_CONF_VALUE_copyfunc_type(sk_CONF_VALUE_copyfunc cpy ) 
{ 


  {
#line 41
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 41 "/usr/include/openssl/conf.h"
__inline static OPENSSL_sk_freefunc ossl_check_CONF_VALUE_freefunc_type(sk_CONF_VALUE_freefunc fr ) 
{ 


  {
#line 41
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 67 "/usr/include/openssl/conf.h"
__inline static OPENSSL_LHASH *ossl_check_const_CONF_VALUE_lh_type(struct lhash_st_CONF_VALUE *lh ) 
{ 


  {
#line 67
  return ((OPENSSL_LHASH *)lh);
}
}
#line 67 "/usr/include/openssl/conf.h"
__inline static OPENSSL_LH_COMPFUNC ossl_check_CONF_VALUE_lh_compfunc_type(lh_CONF_VALUE_compfunc cmp ) 
{ 


  {
#line 67
  return ((OPENSSL_LH_COMPFUNC )cmp);
}
}
#line 67 "/usr/include/openssl/conf.h"
__inline static OPENSSL_LH_HASHFUNC ossl_check_CONF_VALUE_lh_hashfunc_type(lh_CONF_VALUE_hashfunc hfn ) 
{ 


  {
#line 67
  return ((OPENSSL_LH_HASHFUNC )hfn);
}
}
#line 67 "/usr/include/openssl/conf.h"
__inline static OPENSSL_LH_DOALL_FUNC ossl_check_CONF_VALUE_lh_doallfunc_type(lh_CONF_VALUE_doallfunc dfn ) 
{ 


  {
#line 67
  return ((OPENSSL_LH_DOALL_FUNC )dfn);
}
}
#line 110
int CONF_set_default_method(CONF_METHOD *meth ) ;
#line 111
void CONF_set_nconf(CONF *conf , struct lhash_st_CONF_VALUE *hash ) ;
#line 112
struct lhash_st_CONF_VALUE *CONF_load(struct lhash_st_CONF_VALUE *conf , char const   *file ,
                                      long *eline ) ;
#line 115
struct lhash_st_CONF_VALUE *CONF_load_fp(struct lhash_st_CONF_VALUE *conf , FILE *fp ,
                                         long *eline ) ;
#line 118
struct lhash_st_CONF_VALUE *CONF_load_bio(struct lhash_st_CONF_VALUE *conf , BIO *bp ,
                                          long *eline ) ;
#line 120
struct stack_st_CONF_VALUE *CONF_get_section(struct lhash_st_CONF_VALUE *conf , char const   *section ) ;
#line 122
char *CONF_get_string(struct lhash_st_CONF_VALUE *conf , char const   *group , char const   *name ) ;
#line 124
long CONF_get_number(struct lhash_st_CONF_VALUE *conf , char const   *group , char const   *name ) ;
#line 126
void CONF_free(struct lhash_st_CONF_VALUE *conf ) ;
#line 128
int CONF_dump_fp(struct lhash_st_CONF_VALUE *conf , FILE *out ) ;
#line 130
int CONF_dump_bio(struct lhash_st_CONF_VALUE *conf , BIO *out ) ;
#line 132
void OPENSSL_config(char const   *config_name ) ;
#line 145
CONF *NCONF_new_ex(OSSL_LIB_CTX *libctx , CONF_METHOD *meth ) ;
#line 146
OSSL_LIB_CTX *NCONF_get0_libctx(CONF *conf ) ;
#line 147
CONF *NCONF_new(CONF_METHOD *meth ) ;
#line 148
CONF_METHOD *NCONF_default(void) ;
#line 150
CONF_METHOD *NCONF_WIN32(void) ;
#line 152
void NCONF_free(CONF *conf ) ;
#line 153
void NCONF_free_data(CONF *conf ) ;
#line 155
int NCONF_load(CONF *conf , char const   *file , long *eline ) ;
#line 157
int NCONF_load_fp(CONF *conf , FILE *fp , long *eline ) ;
#line 159
int NCONF_load_bio(CONF *conf , BIO *bp , long *eline ) ;
#line 160
struct stack_st_OPENSSL_CSTRING *NCONF_get_section_names(CONF *conf ) ;
#line 161
struct stack_st_CONF_VALUE *NCONF_get_section(CONF *conf , char const   *section ) ;
#line 163
char *NCONF_get_string(CONF *conf , char const   *group , char const   *name ) ;
#line 164
int NCONF_get_number_e(CONF *conf , char const   *group , char const   *name , long *result ) ;
#line 167
int NCONF_dump_fp(CONF *conf , FILE *out ) ;
#line 169
int NCONF_dump_bio(CONF *conf , BIO *out ) ;
#line 175
int CONF_modules_load(CONF *cnf , char const   *appname , unsigned long flags ) ;
#line 177
int CONF_modules_load_file_ex(OSSL_LIB_CTX *libctx , char const   *filename , char const   *appname ,
                              unsigned long flags ) ;
#line 179
int CONF_modules_load_file(char const   *filename , char const   *appname , unsigned long flags ) ;
#line 181
void CONF_modules_unload(int all ) ;
#line 182
void CONF_modules_finish(void) ;
#line 186
int CONF_module_add(char const   *name , conf_init_func *ifunc , conf_finish_func *ffunc ) ;
#line 189
char const   *CONF_imodule_get_name(CONF_IMODULE *md ) ;
#line 190
char const   *CONF_imodule_get_value(CONF_IMODULE *md ) ;
#line 191
void *CONF_imodule_get_usr_data(CONF_IMODULE *md ) ;
#line 192
void CONF_imodule_set_usr_data(CONF_IMODULE *md , void *usr_data ) ;
#line 193
CONF_MODULE *CONF_imodule_get_module(CONF_IMODULE *md ) ;
#line 194
unsigned long CONF_imodule_get_flags(CONF_IMODULE *md ) ;
#line 195
void CONF_imodule_set_flags(CONF_IMODULE *md , unsigned long flags ) ;
#line 196
void *CONF_module_get_usr_data(CONF_MODULE *pmod ) ;
#line 197
void CONF_module_set_usr_data(CONF_MODULE *pmod , void *usr_data ) ;
#line 199
char *CONF_get1_default_config_file(void) ;
#line 201
int CONF_parse_list(char const   *list , int sep , int nospc , int (*list_cb)(char const   * ,
                                                                              int  ,
                                                                              void * ) ,
                    void *arg ) ;
#line 205
void OPENSSL_load_builtin_modules(void) ;
#line 40 "/usr/include/openssl/http.h"
OSSL_HTTP_REQ_CTX *OSSL_HTTP_REQ_CTX_new(BIO *wbio , BIO *rbio , int buf_size ) ;
#line 41
void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 42
int OSSL_HTTP_REQ_CTX_set_request_line(OSSL_HTTP_REQ_CTX *rctx , int method_POST ,
                                       char const   *server , char const   *port ,
                                       char const   *path ) ;
#line 45
int OSSL_HTTP_REQ_CTX_add1_header(OSSL_HTTP_REQ_CTX *rctx , char const   *name , char const   *value ) ;
#line 47
int OSSL_HTTP_REQ_CTX_set_expected(OSSL_HTTP_REQ_CTX *rctx , char const   *content_type ,
                                   int asn1 , int timeout , int keep_alive ) ;
#line 50
int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx , char const   *content_type ,
                               ASN1_ITEM *it , ASN1_VALUE *req ) ;
#line 52
int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 53
int OSSL_HTTP_REQ_CTX_nbio_d2i(OSSL_HTTP_REQ_CTX *rctx , ASN1_VALUE **pval , ASN1_ITEM *it ) ;
#line 55
BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 56
BIO *OSSL_HTTP_REQ_CTX_get0_mem_bio(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 57
size_t OSSL_HTTP_REQ_CTX_get_resp_len(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 58
void OSSL_HTTP_REQ_CTX_set_max_response_length(OSSL_HTTP_REQ_CTX *rctx , unsigned long len ) ;
#line 60
int OSSL_HTTP_is_alive(OSSL_HTTP_REQ_CTX *rctx ) ;
#line 64
OSSL_HTTP_REQ_CTX *OSSL_HTTP_open(char const   *server , char const   *port , char const   *proxy ,
                                  char const   *no_proxy , int use_ssl , BIO *bio ,
                                  BIO *rbio , OSSL_HTTP_bio_cb_t bio_update_fn , void *arg ,
                                  int buf_size , int overall_timeout ) ;
#line 69
int OSSL_HTTP_proxy_connect(BIO *bio , char const   *server , char const   *port ,
                            char const   *proxyuser , char const   *proxypass , int timeout ,
                            BIO *bio_err , char const   *prog ) ;
#line 72
int OSSL_HTTP_set1_request(OSSL_HTTP_REQ_CTX *rctx , char const   *path , struct stack_st_CONF_VALUE *headers ,
                           char const   *content_type , BIO *req , char const   *expected_content_type ,
                           int expect_asn1 , size_t max_resp_len , int timeout , int keep_alive ) ;
#line 77
BIO *OSSL_HTTP_exchange(OSSL_HTTP_REQ_CTX *rctx , char **redirection_url ) ;
#line 78
BIO *OSSL_HTTP_get(char const   *url , char const   *proxy , char const   *no_proxy ,
                   BIO *bio , BIO *rbio , OSSL_HTTP_bio_cb_t bio_update_fn , void *arg ,
                   int buf_size , struct stack_st_CONF_VALUE *headers , char const   *expected_content_type ,
                   int expect_asn1 , size_t max_resp_len , int timeout ) ;
#line 84
BIO *OSSL_HTTP_transfer(OSSL_HTTP_REQ_CTX **prctx , char const   *server , char const   *port ,
                        char const   *path , int use_ssl , char const   *proxy , char const   *no_proxy ,
                        BIO *bio , BIO *rbio , OSSL_HTTP_bio_cb_t bio_update_fn ,
                        void *arg , int buf_size , struct stack_st_CONF_VALUE *headers ,
                        char const   *content_type , BIO *req , char const   *expected_content_type ,
                        int expect_asn1 , size_t max_resp_len , int timeout , int keep_alive ) ;
#line 94
int OSSL_HTTP_close(OSSL_HTTP_REQ_CTX *rctx , int ok ) ;
#line 97
int OSSL_parse_url(char const   *url , char **pscheme , char **puser , char **phost ,
                   char **pport , int *pport_num , char **ppath , char **pquery ,
                   char **pfrag ) ;
#line 100
int OSSL_HTTP_parse_url(char const   *url , int *pssl , char **puser , char **phost ,
                        char **pport , int *pport_num , char **ppath , char **pquery ,
                        char **pfrag ) ;
#line 103
char const   *OSSL_HTTP_adapt_proxy(char const   *proxy , char const   *no_proxy ,
                                    char const   *server , int use_ssl ) ;
#line 109 "/usr/include/openssl/x509v3.h"
__inline static X509V3_EXT_METHOD *ossl_check_X509V3_EXT_METHOD_type(X509V3_EXT_METHOD *ptr ) 
{ 


  {
#line 109
  return (ptr);
}
}
#line 109 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_X509V3_EXT_METHOD_sk_type(struct stack_st_X509V3_EXT_METHOD *sk ) 
{ 


  {
#line 109
  return ((OPENSSL_STACK *)sk);
}
}
#line 109 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509V3_EXT_METHOD_compfunc_type(sk_X509V3_EXT_METHOD_compfunc cmp ) 
{ 


  {
#line 109
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 109 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509V3_EXT_METHOD_copyfunc_type(sk_X509V3_EXT_METHOD_copyfunc cpy ) 
{ 


  {
#line 109
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 109 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509V3_EXT_METHOD_freefunc_type(sk_X509V3_EXT_METHOD_freefunc fr ) 
{ 


  {
#line 109
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 201 "/usr/include/openssl/x509v3.h"
__inline static ACCESS_DESCRIPTION *ossl_check_ACCESS_DESCRIPTION_type(ACCESS_DESCRIPTION *ptr ) 
{ 


  {
#line 201
  return (ptr);
}
}
#line 201 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_ACCESS_DESCRIPTION_sk_type(struct stack_st_ACCESS_DESCRIPTION *sk ) 
{ 


  {
#line 201
  return ((OPENSSL_STACK *)sk);
}
}
#line 201 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_ACCESS_DESCRIPTION_compfunc_type(sk_ACCESS_DESCRIPTION_compfunc cmp ) 
{ 


  {
#line 201
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 201 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ACCESS_DESCRIPTION_copyfunc_type(sk_ACCESS_DESCRIPTION_copyfunc cpy ) 
{ 


  {
#line 201
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 201 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_ACCESS_DESCRIPTION_freefunc_type(sk_ACCESS_DESCRIPTION_freefunc fr ) 
{ 


  {
#line 201
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 227 "/usr/include/openssl/x509v3.h"
__inline static GENERAL_NAME *ossl_check_GENERAL_NAME_type(GENERAL_NAME *ptr ) 
{ 


  {
#line 227
  return (ptr);
}
}
#line 227 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_GENERAL_NAME_sk_type(struct stack_st_GENERAL_NAME *sk ) 
{ 


  {
#line 227
  return ((OPENSSL_STACK *)sk);
}
}
#line 227 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_GENERAL_NAME_compfunc_type(sk_GENERAL_NAME_compfunc cmp ) 
{ 


  {
#line 227
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 227 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_GENERAL_NAME_copyfunc_type(sk_GENERAL_NAME_copyfunc cpy ) 
{ 


  {
#line 227
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 227 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_GENERAL_NAME_freefunc_type(sk_GENERAL_NAME_freefunc fr ) 
{ 


  {
#line 227
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 260 "/usr/include/openssl/x509v3.h"
__inline static GENERAL_NAMES *ossl_check_GENERAL_NAMES_type(GENERAL_NAMES *ptr ) 
{ 


  {
#line 260
  return (ptr);
}
}
#line 260 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_GENERAL_NAMES_sk_type(struct stack_st_GENERAL_NAMES *sk ) 
{ 


  {
#line 260
  return ((OPENSSL_STACK *)sk);
}
}
#line 260 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_GENERAL_NAMES_compfunc_type(sk_GENERAL_NAMES_compfunc cmp ) 
{ 


  {
#line 260
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 260 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_GENERAL_NAMES_copyfunc_type(sk_GENERAL_NAMES_copyfunc cpy ) 
{ 


  {
#line 260
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 260 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_GENERAL_NAMES_freefunc_type(sk_GENERAL_NAMES_freefunc fr ) 
{ 


  {
#line 260
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 319 "/usr/include/openssl/x509v3.h"
__inline static DIST_POINT *ossl_check_DIST_POINT_type(DIST_POINT *ptr ) 
{ 


  {
#line 319
  return (ptr);
}
}
#line 319 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_DIST_POINT_sk_type(struct stack_st_DIST_POINT *sk ) 
{ 


  {
#line 319
  return ((OPENSSL_STACK *)sk);
}
}
#line 319 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_DIST_POINT_compfunc_type(sk_DIST_POINT_compfunc cmp ) 
{ 


  {
#line 319
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 319 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_DIST_POINT_copyfunc_type(sk_DIST_POINT_copyfunc cpy ) 
{ 


  {
#line 319
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 319 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_DIST_POINT_freefunc_type(sk_DIST_POINT_freefunc fr ) 
{ 


  {
#line 319
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 362 "/usr/include/openssl/x509v3.h"
__inline static SXNETID *ossl_check_SXNETID_type(SXNETID *ptr ) 
{ 


  {
#line 362
  return (ptr);
}
}
#line 362 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_SXNETID_sk_type(struct stack_st_SXNETID *sk ) 
{ 


  {
#line 362
  return ((OPENSSL_STACK *)sk);
}
}
#line 362 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_SXNETID_compfunc_type(sk_SXNETID_compfunc cmp ) 
{ 


  {
#line 362
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 362 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_SXNETID_copyfunc_type(sk_SXNETID_copyfunc cpy ) 
{ 


  {
#line 362
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 362 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_SXNETID_freefunc_type(sk_SXNETID_freefunc fr ) 
{ 


  {
#line 362
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 422 "/usr/include/openssl/x509v3.h"
__inline static POLICYQUALINFO *ossl_check_POLICYQUALINFO_type(POLICYQUALINFO *ptr ) 
{ 


  {
#line 422
  return (ptr);
}
}
#line 422 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_POLICYQUALINFO_sk_type(struct stack_st_POLICYQUALINFO *sk ) 
{ 


  {
#line 422
  return ((OPENSSL_STACK *)sk);
}
}
#line 422 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_POLICYQUALINFO_compfunc_type(sk_POLICYQUALINFO_compfunc cmp ) 
{ 


  {
#line 422
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 422 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_POLICYQUALINFO_copyfunc_type(sk_POLICYQUALINFO_copyfunc cpy ) 
{ 


  {
#line 422
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 422 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_POLICYQUALINFO_freefunc_type(sk_POLICYQUALINFO_freefunc fr ) 
{ 


  {
#line 422
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 456 "/usr/include/openssl/x509v3.h"
__inline static POLICYINFO *ossl_check_POLICYINFO_type(POLICYINFO *ptr ) 
{ 


  {
#line 456
  return (ptr);
}
}
#line 456 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_POLICYINFO_sk_type(struct stack_st_POLICYINFO *sk ) 
{ 


  {
#line 456
  return ((OPENSSL_STACK *)sk);
}
}
#line 456 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_POLICYINFO_compfunc_type(sk_POLICYINFO_compfunc cmp ) 
{ 


  {
#line 456
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 456 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_POLICYINFO_copyfunc_type(sk_POLICYINFO_copyfunc cpy ) 
{ 


  {
#line 456
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 456 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_POLICYINFO_freefunc_type(sk_POLICYINFO_freefunc fr ) 
{ 


  {
#line 456
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 491 "/usr/include/openssl/x509v3.h"
__inline static POLICY_MAPPING *ossl_check_POLICY_MAPPING_type(POLICY_MAPPING *ptr ) 
{ 


  {
#line 491
  return (ptr);
}
}
#line 491 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_POLICY_MAPPING_sk_type(struct stack_st_POLICY_MAPPING *sk ) 
{ 


  {
#line 491
  return ((OPENSSL_STACK *)sk);
}
}
#line 491 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_POLICY_MAPPING_compfunc_type(sk_POLICY_MAPPING_compfunc cmp ) 
{ 


  {
#line 491
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 491 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_POLICY_MAPPING_copyfunc_type(sk_POLICY_MAPPING_copyfunc cpy ) 
{ 


  {
#line 491
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 491 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_POLICY_MAPPING_freefunc_type(sk_POLICY_MAPPING_freefunc fr ) 
{ 


  {
#line 491
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 527 "/usr/include/openssl/x509v3.h"
__inline static GENERAL_SUBTREE *ossl_check_GENERAL_SUBTREE_type(GENERAL_SUBTREE *ptr ) 
{ 


  {
#line 527
  return (ptr);
}
}
#line 527 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_GENERAL_SUBTREE_sk_type(struct stack_st_GENERAL_SUBTREE *sk ) 
{ 


  {
#line 527
  return ((OPENSSL_STACK *)sk);
}
}
#line 527 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_GENERAL_SUBTREE_compfunc_type(sk_GENERAL_SUBTREE_compfunc cmp ) 
{ 


  {
#line 527
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 527 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_GENERAL_SUBTREE_copyfunc_type(sk_GENERAL_SUBTREE_copyfunc cpy ) 
{ 


  {
#line 527
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 527 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_GENERAL_SUBTREE_freefunc_type(sk_GENERAL_SUBTREE_freefunc fr ) 
{ 


  {
#line 527
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 576
extern PROXY_POLICY *PROXY_POLICY_new(void) ;
#line 576
extern void PROXY_POLICY_free(PROXY_POLICY *a ) ;
#line 576
extern PROXY_POLICY *d2i_PROXY_POLICY(PROXY_POLICY **a , unsigned char const   **in ,
                                      long len ) ;
#line 576
extern int i2d_PROXY_POLICY(PROXY_POLICY *a , unsigned char **out ) ;
#line 576
extern ASN1_ITEM *PROXY_POLICY_it(void) ;
#line 577
extern PROXY_CERT_INFO_EXTENSION *PROXY_CERT_INFO_EXTENSION_new(void) ;
#line 577
extern void PROXY_CERT_INFO_EXTENSION_free(PROXY_CERT_INFO_EXTENSION *a ) ;
#line 577
extern PROXY_CERT_INFO_EXTENSION *d2i_PROXY_CERT_INFO_EXTENSION(PROXY_CERT_INFO_EXTENSION **a ,
                                                                unsigned char const   **in ,
                                                                long len ) ;
#line 577
extern int i2d_PROXY_CERT_INFO_EXTENSION(PROXY_CERT_INFO_EXTENSION *a , unsigned char **out ) ;
#line 577
extern ASN1_ITEM *PROXY_CERT_INFO_EXTENSION_it(void) ;
#line 704 "/usr/include/openssl/x509v3.h"
__inline static X509_PURPOSE *ossl_check_X509_PURPOSE_type(X509_PURPOSE *ptr ) 
{ 


  {
#line 704
  return (ptr);
}
}
#line 704 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_PURPOSE_sk_type(struct stack_st_X509_PURPOSE *sk ) 
{ 


  {
#line 704
  return ((OPENSSL_STACK *)sk);
}
}
#line 704 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_PURPOSE_compfunc_type(sk_X509_PURPOSE_compfunc cmp ) 
{ 


  {
#line 704
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 704 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_PURPOSE_copyfunc_type(sk_X509_PURPOSE_copyfunc cpy ) 
{ 


  {
#line 704
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 704 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_PURPOSE_freefunc_type(sk_X509_PURPOSE_freefunc fr ) 
{ 


  {
#line 704
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 769
extern BASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void) ;
#line 769
extern void BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *a ) ;
#line 769
extern BASIC_CONSTRAINTS *d2i_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS **a , unsigned char const   **in ,
                                                long len ) ;
#line 769
extern int i2d_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *a , unsigned char **out ) ;
#line 769
extern ASN1_ITEM *BASIC_CONSTRAINTS_it(void) ;
#line 771
extern SXNET *SXNET_new(void) ;
#line 771
extern void SXNET_free(SXNET *a ) ;
#line 771
extern SXNET *d2i_SXNET(SXNET **a , unsigned char const   **in , long len ) ;
#line 771
extern int i2d_SXNET(SXNET *a , unsigned char **out ) ;
#line 771
extern ASN1_ITEM *SXNET_it(void) ;
#line 772
extern SXNETID *SXNETID_new(void) ;
#line 772
extern void SXNETID_free(SXNETID *a ) ;
#line 772
extern SXNETID *d2i_SXNETID(SXNETID **a , unsigned char const   **in , long len ) ;
#line 772
extern int i2d_SXNETID(SXNETID *a , unsigned char **out ) ;
#line 772
extern ASN1_ITEM *SXNETID_it(void) ;
#line 774
extern ISSUER_SIGN_TOOL *ISSUER_SIGN_TOOL_new(void) ;
#line 774
extern void ISSUER_SIGN_TOOL_free(ISSUER_SIGN_TOOL *a ) ;
#line 774
extern ISSUER_SIGN_TOOL *d2i_ISSUER_SIGN_TOOL(ISSUER_SIGN_TOOL **a , unsigned char const   **in ,
                                              long len ) ;
#line 774
extern int i2d_ISSUER_SIGN_TOOL(ISSUER_SIGN_TOOL *a , unsigned char **out ) ;
#line 774
extern ASN1_ITEM *ISSUER_SIGN_TOOL_it(void) ;
#line 776
int SXNET_add_id_asc(SXNET **psx , char const   *zone , char const   *user , int userlen ) ;
#line 777
int SXNET_add_id_ulong(SXNET **psx , unsigned long lzone , char const   *user , int userlen ) ;
#line 779
int SXNET_add_id_INTEGER(SXNET **psx , ASN1_INTEGER *izone , char const   *user ,
                         int userlen ) ;
#line 782
ASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx , char const   *zone ) ;
#line 783
ASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx , unsigned long lzone ) ;
#line 784
ASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx , ASN1_INTEGER *zone ) ;
#line 786
extern AUTHORITY_KEYID *AUTHORITY_KEYID_new(void) ;
#line 786
extern void AUTHORITY_KEYID_free(AUTHORITY_KEYID *a ) ;
#line 786
extern AUTHORITY_KEYID *d2i_AUTHORITY_KEYID(AUTHORITY_KEYID **a , unsigned char const   **in ,
                                            long len ) ;
#line 786
extern int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *a , unsigned char **out ) ;
#line 786
extern ASN1_ITEM *AUTHORITY_KEYID_it(void) ;
#line 788
extern PKEY_USAGE_PERIOD *PKEY_USAGE_PERIOD_new(void) ;
#line 788
extern void PKEY_USAGE_PERIOD_free(PKEY_USAGE_PERIOD *a ) ;
#line 788
extern PKEY_USAGE_PERIOD *d2i_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD **a , unsigned char const   **in ,
                                                long len ) ;
#line 788
extern int i2d_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD *a , unsigned char **out ) ;
#line 788
extern ASN1_ITEM *PKEY_USAGE_PERIOD_it(void) ;
#line 790
extern GENERAL_NAME *GENERAL_NAME_new(void) ;
#line 790
extern void GENERAL_NAME_free(GENERAL_NAME *a ) ;
#line 790
extern GENERAL_NAME *d2i_GENERAL_NAME(GENERAL_NAME **a , unsigned char const   **in ,
                                      long len ) ;
#line 790
extern int i2d_GENERAL_NAME(GENERAL_NAME *a , unsigned char **out ) ;
#line 790
extern ASN1_ITEM *GENERAL_NAME_it(void) ;
#line 791
extern GENERAL_NAME *GENERAL_NAME_dup(GENERAL_NAME *a ) ;
#line 792
int GENERAL_NAME_cmp(GENERAL_NAME *a , GENERAL_NAME *b ) ;
#line 794
ASN1_BIT_STRING *v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method , X509V3_CTX *ctx ,
                                     struct stack_st_CONF_VALUE *nval ) ;
#line 797
struct stack_st_CONF_VALUE *i2v_ASN1_BIT_STRING(X509V3_EXT_METHOD *method , ASN1_BIT_STRING *bits ,
                                                struct stack_st_CONF_VALUE *extlist ) ;
#line 800
char *i2s_ASN1_IA5STRING(X509V3_EXT_METHOD *method , ASN1_IA5STRING *ia5 ) ;
#line 801
ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method , X509V3_CTX *ctx , char const   *str ) ;
#line 803
char *i2s_ASN1_UTF8STRING(X509V3_EXT_METHOD *method , ASN1_UTF8STRING *utf8 ) ;
#line 804
ASN1_UTF8STRING *s2i_ASN1_UTF8STRING(X509V3_EXT_METHOD *method , X509V3_CTX *ctx ,
                                     char const   *str ) ;
#line 807
struct stack_st_CONF_VALUE *i2v_GENERAL_NAME(X509V3_EXT_METHOD *method , GENERAL_NAME *gen ,
                                             struct stack_st_CONF_VALUE *ret ) ;
#line 810
int GENERAL_NAME_print(BIO *out , GENERAL_NAME *gen ) ;
#line 812
extern GENERAL_NAMES *GENERAL_NAMES_new(void) ;
#line 812
extern void GENERAL_NAMES_free(GENERAL_NAMES *a ) ;
#line 812
extern GENERAL_NAMES *d2i_GENERAL_NAMES(GENERAL_NAMES **a , unsigned char const   **in ,
                                        long len ) ;
#line 812
extern int i2d_GENERAL_NAMES(GENERAL_NAMES *a , unsigned char **out ) ;
#line 812
extern ASN1_ITEM *GENERAL_NAMES_it(void) ;
#line 814
struct stack_st_CONF_VALUE *i2v_GENERAL_NAMES(X509V3_EXT_METHOD *method , GENERAL_NAMES *gen ,
                                              struct stack_st_CONF_VALUE *extlist ) ;
#line 817
GENERAL_NAMES *v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method , X509V3_CTX *ctx , struct stack_st_CONF_VALUE *nval ) ;
#line 820
extern OTHERNAME *OTHERNAME_new(void) ;
#line 820
extern void OTHERNAME_free(OTHERNAME *a ) ;
#line 820
extern OTHERNAME *d2i_OTHERNAME(OTHERNAME **a , unsigned char const   **in , long len ) ;
#line 820
extern int i2d_OTHERNAME(OTHERNAME *a , unsigned char **out ) ;
#line 820
extern ASN1_ITEM *OTHERNAME_it(void) ;
#line 821
extern EDIPARTYNAME *EDIPARTYNAME_new(void) ;
#line 821
extern void EDIPARTYNAME_free(EDIPARTYNAME *a ) ;
#line 821
extern EDIPARTYNAME *d2i_EDIPARTYNAME(EDIPARTYNAME **a , unsigned char const   **in ,
                                      long len ) ;
#line 821
extern int i2d_EDIPARTYNAME(EDIPARTYNAME *a , unsigned char **out ) ;
#line 821
extern ASN1_ITEM *EDIPARTYNAME_it(void) ;
#line 822
int OTHERNAME_cmp(OTHERNAME *a , OTHERNAME *b ) ;
#line 823
void GENERAL_NAME_set0_value(GENERAL_NAME *a , int type , void *value ) ;
#line 824
void *GENERAL_NAME_get0_value(GENERAL_NAME *a , int *ptype ) ;
#line 825
int GENERAL_NAME_set0_othername(GENERAL_NAME *gen , ASN1_OBJECT *oid , ASN1_TYPE *value ) ;
#line 827
int GENERAL_NAME_get0_otherName(GENERAL_NAME *gen , ASN1_OBJECT **poid , ASN1_TYPE **pvalue ) ;
#line 830
char *i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method , ASN1_OCTET_STRING *ia5 ) ;
#line 832
ASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method , X509V3_CTX *ctx ,
                                         char const   *str ) ;
#line 835
extern EXTENDED_KEY_USAGE *EXTENDED_KEY_USAGE_new(void) ;
#line 835
extern void EXTENDED_KEY_USAGE_free(EXTENDED_KEY_USAGE *a ) ;
#line 835
extern EXTENDED_KEY_USAGE *d2i_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE **a , unsigned char const   **in ,
                                                  long len ) ;
#line 835
extern int i2d_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE *a , unsigned char **out ) ;
#line 835
extern ASN1_ITEM *EXTENDED_KEY_USAGE_it(void) ;
#line 836
int i2a_ACCESS_DESCRIPTION(BIO *bp , ACCESS_DESCRIPTION *a ) ;
#line 838
extern TLS_FEATURE *TLS_FEATURE_new(void) ;
#line 838
extern void TLS_FEATURE_free(TLS_FEATURE *a ) ;
#line 840
extern CERTIFICATEPOLICIES *CERTIFICATEPOLICIES_new(void) ;
#line 840
extern void CERTIFICATEPOLICIES_free(CERTIFICATEPOLICIES *a ) ;
#line 840
extern CERTIFICATEPOLICIES *d2i_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES **a , unsigned char const   **in ,
                                                    long len ) ;
#line 840
extern int i2d_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES *a , unsigned char **out ) ;
#line 840
extern ASN1_ITEM *CERTIFICATEPOLICIES_it(void) ;
#line 841
extern POLICYINFO *POLICYINFO_new(void) ;
#line 841
extern void POLICYINFO_free(POLICYINFO *a ) ;
#line 841
extern POLICYINFO *d2i_POLICYINFO(POLICYINFO **a , unsigned char const   **in , long len ) ;
#line 841
extern int i2d_POLICYINFO(POLICYINFO *a , unsigned char **out ) ;
#line 841
extern ASN1_ITEM *POLICYINFO_it(void) ;
#line 842
extern POLICYQUALINFO *POLICYQUALINFO_new(void) ;
#line 842
extern void POLICYQUALINFO_free(POLICYQUALINFO *a ) ;
#line 842
extern POLICYQUALINFO *d2i_POLICYQUALINFO(POLICYQUALINFO **a , unsigned char const   **in ,
                                          long len ) ;
#line 842
extern int i2d_POLICYQUALINFO(POLICYQUALINFO *a , unsigned char **out ) ;
#line 842
extern ASN1_ITEM *POLICYQUALINFO_it(void) ;
#line 843
extern USERNOTICE *USERNOTICE_new(void) ;
#line 843
extern void USERNOTICE_free(USERNOTICE *a ) ;
#line 843
extern USERNOTICE *d2i_USERNOTICE(USERNOTICE **a , unsigned char const   **in , long len ) ;
#line 843
extern int i2d_USERNOTICE(USERNOTICE *a , unsigned char **out ) ;
#line 843
extern ASN1_ITEM *USERNOTICE_it(void) ;
#line 844
extern NOTICEREF *NOTICEREF_new(void) ;
#line 844
extern void NOTICEREF_free(NOTICEREF *a ) ;
#line 844
extern NOTICEREF *d2i_NOTICEREF(NOTICEREF **a , unsigned char const   **in , long len ) ;
#line 844
extern int i2d_NOTICEREF(NOTICEREF *a , unsigned char **out ) ;
#line 844
extern ASN1_ITEM *NOTICEREF_it(void) ;
#line 846
extern CRL_DIST_POINTS *CRL_DIST_POINTS_new(void) ;
#line 846
extern void CRL_DIST_POINTS_free(CRL_DIST_POINTS *a ) ;
#line 846
extern CRL_DIST_POINTS *d2i_CRL_DIST_POINTS(CRL_DIST_POINTS **a , unsigned char const   **in ,
                                            long len ) ;
#line 846
extern int i2d_CRL_DIST_POINTS(CRL_DIST_POINTS *a , unsigned char **out ) ;
#line 846
extern ASN1_ITEM *CRL_DIST_POINTS_it(void) ;
#line 847
extern DIST_POINT *DIST_POINT_new(void) ;
#line 847
extern void DIST_POINT_free(DIST_POINT *a ) ;
#line 847
extern DIST_POINT *d2i_DIST_POINT(DIST_POINT **a , unsigned char const   **in , long len ) ;
#line 847
extern int i2d_DIST_POINT(DIST_POINT *a , unsigned char **out ) ;
#line 847
extern ASN1_ITEM *DIST_POINT_it(void) ;
#line 848
extern DIST_POINT_NAME *DIST_POINT_NAME_new(void) ;
#line 848
extern void DIST_POINT_NAME_free(DIST_POINT_NAME *a ) ;
#line 848
extern DIST_POINT_NAME *d2i_DIST_POINT_NAME(DIST_POINT_NAME **a , unsigned char const   **in ,
                                            long len ) ;
#line 848
extern int i2d_DIST_POINT_NAME(DIST_POINT_NAME *a , unsigned char **out ) ;
#line 848
extern ASN1_ITEM *DIST_POINT_NAME_it(void) ;
#line 849
extern ISSUING_DIST_POINT *ISSUING_DIST_POINT_new(void) ;
#line 849
extern void ISSUING_DIST_POINT_free(ISSUING_DIST_POINT *a ) ;
#line 849
extern ISSUING_DIST_POINT *d2i_ISSUING_DIST_POINT(ISSUING_DIST_POINT **a , unsigned char const   **in ,
                                                  long len ) ;
#line 849
extern int i2d_ISSUING_DIST_POINT(ISSUING_DIST_POINT *a , unsigned char **out ) ;
#line 849
extern ASN1_ITEM *ISSUING_DIST_POINT_it(void) ;
#line 851
int DIST_POINT_set_dpname(DIST_POINT_NAME *dpn , X509_NAME *iname ) ;
#line 853
int NAME_CONSTRAINTS_check(X509 *x , NAME_CONSTRAINTS *nc ) ;
#line 854
int NAME_CONSTRAINTS_check_CN(X509 *x , NAME_CONSTRAINTS *nc ) ;
#line 856
extern ACCESS_DESCRIPTION *ACCESS_DESCRIPTION_new(void) ;
#line 856
extern void ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *a ) ;
#line 856
extern ACCESS_DESCRIPTION *d2i_ACCESS_DESCRIPTION(ACCESS_DESCRIPTION **a , unsigned char const   **in ,
                                                  long len ) ;
#line 856
extern int i2d_ACCESS_DESCRIPTION(ACCESS_DESCRIPTION *a , unsigned char **out ) ;
#line 856
extern ASN1_ITEM *ACCESS_DESCRIPTION_it(void) ;
#line 857
extern AUTHORITY_INFO_ACCESS *AUTHORITY_INFO_ACCESS_new(void) ;
#line 857
extern void AUTHORITY_INFO_ACCESS_free(AUTHORITY_INFO_ACCESS *a ) ;
#line 857
extern AUTHORITY_INFO_ACCESS *d2i_AUTHORITY_INFO_ACCESS(AUTHORITY_INFO_ACCESS **a ,
                                                        unsigned char const   **in ,
                                                        long len ) ;
#line 857
extern int i2d_AUTHORITY_INFO_ACCESS(AUTHORITY_INFO_ACCESS *a , unsigned char **out ) ;
#line 857
extern ASN1_ITEM *AUTHORITY_INFO_ACCESS_it(void) ;
#line 859
extern ASN1_ITEM *POLICY_MAPPING_it(void) ;
#line 860
extern POLICY_MAPPING *POLICY_MAPPING_new(void) ;
#line 860
extern void POLICY_MAPPING_free(POLICY_MAPPING *a ) ;
#line 861
extern ASN1_ITEM *POLICY_MAPPINGS_it(void) ;
#line 863
extern ASN1_ITEM *GENERAL_SUBTREE_it(void) ;
#line 864
extern GENERAL_SUBTREE *GENERAL_SUBTREE_new(void) ;
#line 864
extern void GENERAL_SUBTREE_free(GENERAL_SUBTREE *a ) ;
#line 866
extern ASN1_ITEM *NAME_CONSTRAINTS_it(void) ;
#line 867
extern NAME_CONSTRAINTS *NAME_CONSTRAINTS_new(void) ;
#line 867
extern void NAME_CONSTRAINTS_free(NAME_CONSTRAINTS *a ) ;
#line 869
extern POLICY_CONSTRAINTS *POLICY_CONSTRAINTS_new(void) ;
#line 869
extern void POLICY_CONSTRAINTS_free(POLICY_CONSTRAINTS *a ) ;
#line 870
extern ASN1_ITEM *POLICY_CONSTRAINTS_it(void) ;
#line 872
GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out , X509V3_EXT_METHOD *method , X509V3_CTX *ctx ,
                               int gen_type , char const   *value , int is_nc ) ;
#line 878
GENERAL_NAME *v2i_GENERAL_NAME(X509V3_EXT_METHOD *method , X509V3_CTX *ctx , CONF_VALUE *cnf ) ;
#line 880
GENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out , X509V3_EXT_METHOD *method ,
                                  X509V3_CTX *ctx , CONF_VALUE *cnf , int is_nc ) ;
#line 885
void X509V3_conf_free(CONF_VALUE *val ) ;
#line 887
X509_EXTENSION *X509V3_EXT_nconf_nid(CONF *conf , X509V3_CTX *ctx , int ext_nid ,
                                     char const   *value ) ;
#line 889
X509_EXTENSION *X509V3_EXT_nconf(CONF *conf , X509V3_CTX *ctx , char const   *name ,
                                 char const   *value ) ;
#line 891
int X509V3_EXT_add_nconf_sk(CONF *conf , X509V3_CTX *ctx , char const   *section ,
                            struct stack_st_X509_EXTENSION **sk ) ;
#line 893
int X509V3_EXT_add_nconf(CONF *conf , X509V3_CTX *ctx , char const   *section , X509 *cert ) ;
#line 895
int X509V3_EXT_REQ_add_nconf(CONF *conf , X509V3_CTX *ctx , char const   *section ,
                             X509_REQ *req ) ;
#line 897
int X509V3_EXT_CRL_add_nconf(CONF *conf , X509V3_CTX *ctx , char const   *section ,
                             X509_CRL *crl ) ;
#line 900
X509_EXTENSION *X509V3_EXT_conf_nid(struct lhash_st_CONF_VALUE *conf , X509V3_CTX *ctx ,
                                    int ext_nid , char const   *value ) ;
#line 903
X509_EXTENSION *X509V3_EXT_conf(struct lhash_st_CONF_VALUE *conf , X509V3_CTX *ctx ,
                                char const   *name , char const   *value ) ;
#line 905
int X509V3_EXT_add_conf(struct lhash_st_CONF_VALUE *conf , X509V3_CTX *ctx , char const   *section ,
                        X509 *cert ) ;
#line 907
int X509V3_EXT_REQ_add_conf(struct lhash_st_CONF_VALUE *conf , X509V3_CTX *ctx , char const   *section ,
                            X509_REQ *req ) ;
#line 909
int X509V3_EXT_CRL_add_conf(struct lhash_st_CONF_VALUE *conf , X509V3_CTX *ctx , char const   *section ,
                            X509_CRL *crl ) ;
#line 912
int X509V3_add_value_bool_nf(char const   *name , int asn1_bool , struct stack_st_CONF_VALUE **extlist ) ;
#line 914
int X509V3_get_value_bool(CONF_VALUE *value , int *asn1_bool ) ;
#line 915
int X509V3_get_value_int(CONF_VALUE *value , ASN1_INTEGER **aint ) ;
#line 916
void X509V3_set_nconf(X509V3_CTX *ctx , CONF *conf ) ;
#line 917
void X509V3_set_conf_lhash(X509V3_CTX *ctx , struct lhash_st_CONF_VALUE *lhash ) ;
#line 920
char *X509V3_get_string(X509V3_CTX *ctx , char const   *name , char const   *section ) ;
#line 921
struct stack_st_CONF_VALUE *X509V3_get_section(X509V3_CTX *ctx , char const   *section ) ;
#line 922
void X509V3_string_free(X509V3_CTX *ctx , char *str ) ;
#line 923
void X509V3_section_free(X509V3_CTX *ctx , struct stack_st_CONF_VALUE *section ) ;
#line 924
void X509V3_set_ctx(X509V3_CTX *ctx , X509 *issuer , X509 *subject , X509_REQ *req ,
                    X509_CRL *crl , int flags ) ;
#line 927
int X509V3_set_issuer_pkey(X509V3_CTX *ctx , EVP_PKEY *pkey ) ;
#line 929
int X509V3_add_value(char const   *name , char const   *value , struct stack_st_CONF_VALUE **extlist ) ;
#line 931
int X509V3_add_value_uchar(char const   *name , unsigned char const   *value , struct stack_st_CONF_VALUE **extlist ) ;
#line 933
int X509V3_add_value_bool(char const   *name , int asn1_bool , struct stack_st_CONF_VALUE **extlist ) ;
#line 935
int X509V3_add_value_int(char const   *name , ASN1_INTEGER *aint , struct stack_st_CONF_VALUE **extlist ) ;
#line 937
char *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *meth , ASN1_INTEGER *aint ) ;
#line 938
ASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *meth , char const   *value ) ;
#line 939
char *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *meth , ASN1_ENUMERATED *aint ) ;
#line 940
char *i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *meth , ASN1_ENUMERATED *aint ) ;
#line 942
int X509V3_EXT_add(X509V3_EXT_METHOD *ext ) ;
#line 943
int X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist ) ;
#line 944
int X509V3_EXT_add_alias(int nid_to , int nid_from ) ;
#line 945
void X509V3_EXT_cleanup(void) ;
#line 947
X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext ) ;
#line 948
X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid ) ;
#line 949
int X509V3_add_standard_extensions(void) ;
#line 950
struct stack_st_CONF_VALUE *X509V3_parse_list(char const   *line ) ;
#line 951
void *X509V3_EXT_d2i(X509_EXTENSION *ext ) ;
#line 952
void *X509V3_get_d2i(struct stack_st_X509_EXTENSION *x , int nid , int *crit , int *idx ) ;
#line 955
X509_EXTENSION *X509V3_EXT_i2d(int ext_nid , int crit , void *ext_struc ) ;
#line 956
int X509V3_add1_i2d(struct stack_st_X509_EXTENSION **x , int nid , void *value , int crit ,
                    unsigned long flags ) ;
#line 965
void X509V3_EXT_val_prn(BIO *out , struct stack_st_CONF_VALUE *val , int indent ,
                        int ml ) ;
#line 967
int X509V3_EXT_print(BIO *out , X509_EXTENSION *ext , unsigned long flag , int indent ) ;
#line 970
int X509V3_EXT_print_fp(FILE *out , X509_EXTENSION *ext , int flag , int indent ) ;
#line 972
int X509V3_extensions_print(BIO *out , char const   *title , struct stack_st_X509_EXTENSION *exts ,
                            unsigned long flag , int indent ) ;
#line 976
int X509_check_ca(X509 *x ) ;
#line 977
int X509_check_purpose(X509 *x , int id , int ca ) ;
#line 978
int X509_supported_extension(X509_EXTENSION *ex ) ;
#line 979
int X509_PURPOSE_set(int *p , int purpose ) ;
#line 980
int X509_check_issued(X509 *issuer , X509 *subject ) ;
#line 981
int X509_check_akid(X509 *issuer , AUTHORITY_KEYID *akid ) ;
#line 982
void X509_set_proxy_flag(X509 *x ) ;
#line 983
void X509_set_proxy_pathlen(X509 *x , long l ) ;
#line 984
long X509_get_proxy_pathlen(X509 *x ) ;
#line 986
uint32_t X509_get_extension_flags(X509 *x ) ;
#line 987
uint32_t X509_get_key_usage(X509 *x ) ;
#line 988
uint32_t X509_get_extended_key_usage(X509 *x ) ;
#line 989
ASN1_OCTET_STRING *X509_get0_subject_key_id(X509 *x ) ;
#line 990
ASN1_OCTET_STRING *X509_get0_authority_key_id(X509 *x ) ;
#line 991
GENERAL_NAMES *X509_get0_authority_issuer(X509 *x ) ;
#line 992
ASN1_INTEGER *X509_get0_authority_serial(X509 *x ) ;
#line 994
int X509_PURPOSE_get_count(void) ;
#line 995
X509_PURPOSE *X509_PURPOSE_get0(int idx ) ;
#line 996
int X509_PURPOSE_get_by_sname(char const   *sname ) ;
#line 997
int X509_PURPOSE_get_by_id(int id ) ;
#line 998
int X509_PURPOSE_add(int id , int trust , int flags , int (*ck)(X509_PURPOSE * , X509 * ,
                                                                int  ) , char const   *name ,
                     char const   *sname , void *arg ) ;
#line 1001
char *X509_PURPOSE_get0_name(X509_PURPOSE *xp ) ;
#line 1002
char *X509_PURPOSE_get0_sname(X509_PURPOSE *xp ) ;
#line 1003
int X509_PURPOSE_get_trust(X509_PURPOSE *xp ) ;
#line 1004
void X509_PURPOSE_cleanup(void) ;
#line 1005
int X509_PURPOSE_get_id(X509_PURPOSE * ) ;
#line 1007
struct stack_st_OPENSSL_STRING *X509_get1_email(X509 *x ) ;
#line 1008
struct stack_st_OPENSSL_STRING *X509_REQ_get1_email(X509_REQ *x ) ;
#line 1009
void X509_email_free(struct stack_st_OPENSSL_STRING *sk ) ;
#line 1010
struct stack_st_OPENSSL_STRING *X509_get1_ocsp(X509 *x ) ;
#line 1034
int X509_check_host(X509 *x , char const   *chk , size_t chklen , unsigned int flags ,
                    char **peername ) ;
#line 1036
int X509_check_email(X509 *x , char const   *chk , size_t chklen , unsigned int flags ) ;
#line 1038
int X509_check_ip(X509 *x , unsigned char const   *chk , size_t chklen , unsigned int flags ) ;
#line 1040
int X509_check_ip_asc(X509 *x , char const   *ipasc , unsigned int flags ) ;
#line 1042
ASN1_OCTET_STRING *a2i_IPADDRESS(char const   *ipasc ) ;
#line 1043
ASN1_OCTET_STRING *a2i_IPADDRESS_NC(char const   *ipasc ) ;
#line 1044
int X509V3_NAME_from_section(X509_NAME *nm , struct stack_st_CONF_VALUE *dn_sk , unsigned long chtype ) ;
#line 1047
void X509_POLICY_NODE_print(BIO *out , X509_POLICY_NODE *node , int indent ) ;
#line 1048 "/usr/include/openssl/x509v3.h"
__inline static X509_POLICY_NODE *ossl_check_X509_POLICY_NODE_type(X509_POLICY_NODE *ptr ) 
{ 


  {
#line 1048
  return (ptr);
}
}
#line 1048 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_X509_POLICY_NODE_sk_type(struct stack_st_X509_POLICY_NODE *sk ) 
{ 


  {
#line 1048
  return ((OPENSSL_STACK *)sk);
}
}
#line 1048 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_X509_POLICY_NODE_compfunc_type(sk_X509_POLICY_NODE_compfunc cmp ) 
{ 


  {
#line 1048
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1048 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_X509_POLICY_NODE_copyfunc_type(sk_X509_POLICY_NODE_copyfunc cpy ) 
{ 


  {
#line 1048
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1048 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_X509_POLICY_NODE_freefunc_type(sk_X509_POLICY_NODE_freefunc fr ) 
{ 


  {
#line 1048
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1093 "/usr/include/openssl/x509v3.h"
__inline static ASIdOrRange *ossl_check_ASIdOrRange_type(ASIdOrRange *ptr ) 
{ 


  {
#line 1093
  return (ptr);
}
}
#line 1093 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_ASIdOrRange_sk_type(struct stack_st_ASIdOrRange *sk ) 
{ 


  {
#line 1093
  return ((OPENSSL_STACK *)sk);
}
}
#line 1093 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASIdOrRange_compfunc_type(sk_ASIdOrRange_compfunc cmp ) 
{ 


  {
#line 1093
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1093 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASIdOrRange_copyfunc_type(sk_ASIdOrRange_copyfunc cpy ) 
{ 


  {
#line 1093
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1093 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASIdOrRange_freefunc_type(sk_ASIdOrRange_freefunc fr ) 
{ 


  {
#line 1093
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1138
extern ASRange *ASRange_new(void) ;
#line 1138
extern void ASRange_free(ASRange *a ) ;
#line 1138
extern ASRange *d2i_ASRange(ASRange **a , unsigned char const   **in , long len ) ;
#line 1138
extern int i2d_ASRange(ASRange *a , unsigned char **out ) ;
#line 1138
extern ASN1_ITEM *ASRange_it(void) ;
#line 1139
extern ASIdOrRange *ASIdOrRange_new(void) ;
#line 1139
extern void ASIdOrRange_free(ASIdOrRange *a ) ;
#line 1139
extern ASIdOrRange *d2i_ASIdOrRange(ASIdOrRange **a , unsigned char const   **in ,
                                    long len ) ;
#line 1139
extern int i2d_ASIdOrRange(ASIdOrRange *a , unsigned char **out ) ;
#line 1139
extern ASN1_ITEM *ASIdOrRange_it(void) ;
#line 1140
extern ASIdentifierChoice *ASIdentifierChoice_new(void) ;
#line 1140
extern void ASIdentifierChoice_free(ASIdentifierChoice *a ) ;
#line 1140
extern ASIdentifierChoice *d2i_ASIdentifierChoice(ASIdentifierChoice **a , unsigned char const   **in ,
                                                  long len ) ;
#line 1140
extern int i2d_ASIdentifierChoice(ASIdentifierChoice *a , unsigned char **out ) ;
#line 1140
extern ASN1_ITEM *ASIdentifierChoice_it(void) ;
#line 1141
extern ASIdentifiers *ASIdentifiers_new(void) ;
#line 1141
extern void ASIdentifiers_free(ASIdentifiers *a ) ;
#line 1141
extern ASIdentifiers *d2i_ASIdentifiers(ASIdentifiers **a , unsigned char const   **in ,
                                        long len ) ;
#line 1141
extern int i2d_ASIdentifiers(ASIdentifiers *a , unsigned char **out ) ;
#line 1141
extern ASN1_ITEM *ASIdentifiers_it(void) ;
#line 1158 "/usr/include/openssl/x509v3.h"
__inline static IPAddressOrRange *ossl_check_IPAddressOrRange_type(IPAddressOrRange *ptr ) 
{ 


  {
#line 1158
  return (ptr);
}
}
#line 1158 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_IPAddressOrRange_sk_type(struct stack_st_IPAddressOrRange *sk ) 
{ 


  {
#line 1158
  return ((OPENSSL_STACK *)sk);
}
}
#line 1158 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_IPAddressOrRange_compfunc_type(sk_IPAddressOrRange_compfunc cmp ) 
{ 


  {
#line 1158
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1158 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_IPAddressOrRange_copyfunc_type(sk_IPAddressOrRange_copyfunc cpy ) 
{ 


  {
#line 1158
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1158 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_IPAddressOrRange_freefunc_type(sk_IPAddressOrRange_freefunc fr ) 
{ 


  {
#line 1158
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1204 "/usr/include/openssl/x509v3.h"
__inline static IPAddressFamily *ossl_check_IPAddressFamily_type(IPAddressFamily *ptr ) 
{ 


  {
#line 1204
  return (ptr);
}
}
#line 1204 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_IPAddressFamily_sk_type(struct stack_st_IPAddressFamily *sk ) 
{ 


  {
#line 1204
  return ((OPENSSL_STACK *)sk);
}
}
#line 1204 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_IPAddressFamily_compfunc_type(sk_IPAddressFamily_compfunc cmp ) 
{ 


  {
#line 1204
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1204 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_IPAddressFamily_copyfunc_type(sk_IPAddressFamily_copyfunc cpy ) 
{ 


  {
#line 1204
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1204 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_IPAddressFamily_freefunc_type(sk_IPAddressFamily_freefunc fr ) 
{ 


  {
#line 1204
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1235
extern IPAddressRange *IPAddressRange_new(void) ;
#line 1235
extern void IPAddressRange_free(IPAddressRange *a ) ;
#line 1235
extern IPAddressRange *d2i_IPAddressRange(IPAddressRange **a , unsigned char const   **in ,
                                          long len ) ;
#line 1235
extern int i2d_IPAddressRange(IPAddressRange *a , unsigned char **out ) ;
#line 1235
extern ASN1_ITEM *IPAddressRange_it(void) ;
#line 1236
extern IPAddressOrRange *IPAddressOrRange_new(void) ;
#line 1236
extern void IPAddressOrRange_free(IPAddressOrRange *a ) ;
#line 1236
extern IPAddressOrRange *d2i_IPAddressOrRange(IPAddressOrRange **a , unsigned char const   **in ,
                                              long len ) ;
#line 1236
extern int i2d_IPAddressOrRange(IPAddressOrRange *a , unsigned char **out ) ;
#line 1236
extern ASN1_ITEM *IPAddressOrRange_it(void) ;
#line 1237
extern IPAddressChoice *IPAddressChoice_new(void) ;
#line 1237
extern void IPAddressChoice_free(IPAddressChoice *a ) ;
#line 1237
extern IPAddressChoice *d2i_IPAddressChoice(IPAddressChoice **a , unsigned char const   **in ,
                                            long len ) ;
#line 1237
extern int i2d_IPAddressChoice(IPAddressChoice *a , unsigned char **out ) ;
#line 1237
extern ASN1_ITEM *IPAddressChoice_it(void) ;
#line 1238
extern IPAddressFamily *IPAddressFamily_new(void) ;
#line 1238
extern void IPAddressFamily_free(IPAddressFamily *a ) ;
#line 1238
extern IPAddressFamily *d2i_IPAddressFamily(IPAddressFamily **a , unsigned char const   **in ,
                                            long len ) ;
#line 1238
extern int i2d_IPAddressFamily(IPAddressFamily *a , unsigned char **out ) ;
#line 1238
extern ASN1_ITEM *IPAddressFamily_it(void) ;
#line 1260
int X509v3_asid_add_inherit(ASIdentifiers *asid , int which ) ;
#line 1261
int X509v3_asid_add_id_or_range(ASIdentifiers *asid , int which , ASN1_INTEGER *min ,
                                ASN1_INTEGER *max ) ;
#line 1263
int X509v3_addr_add_inherit(IPAddrBlocks *addr , unsigned int const   afi , unsigned int const   *safi ) ;
#line 1265
int X509v3_addr_add_prefix(IPAddrBlocks *addr , unsigned int const   afi , unsigned int const   *safi ,
                           unsigned char *a , int const   prefixlen ) ;
#line 1268
int X509v3_addr_add_range(IPAddrBlocks *addr , unsigned int const   afi , unsigned int const   *safi ,
                          unsigned char *min , unsigned char *max ) ;
#line 1271
unsigned int X509v3_addr_get_afi(IPAddressFamily *f ) ;
#line 1272
int X509v3_addr_get_range(IPAddressOrRange *aor , unsigned int const   afi , unsigned char *min ,
                          unsigned char *max , int const   length ) ;
#line 1279
int X509v3_asid_is_canonical(ASIdentifiers *asid ) ;
#line 1280
int X509v3_addr_is_canonical(IPAddrBlocks *addr ) ;
#line 1281
int X509v3_asid_canonize(ASIdentifiers *asid ) ;
#line 1282
int X509v3_addr_canonize(IPAddrBlocks *addr ) ;
#line 1287
int X509v3_asid_inherits(ASIdentifiers *asid ) ;
#line 1288
int X509v3_addr_inherits(IPAddrBlocks *addr ) ;
#line 1289
int X509v3_asid_subset(ASIdentifiers *a , ASIdentifiers *b ) ;
#line 1290
int X509v3_addr_subset(IPAddrBlocks *a , IPAddrBlocks *b ) ;
#line 1295
int X509v3_asid_validate_path(X509_STORE_CTX * ) ;
#line 1296
int X509v3_addr_validate_path(X509_STORE_CTX * ) ;
#line 1297
int X509v3_asid_validate_resource_set(struct stack_st_X509 *chain , ASIdentifiers *ext ,
                                      int allow_inheritance ) ;
#line 1300
int X509v3_addr_validate_resource_set(struct stack_st_X509 *chain , IPAddrBlocks *ext ,
                                      int allow_inheritance ) ;
#line 1305 "/usr/include/openssl/x509v3.h"
__inline static ASN1_STRING *ossl_check_ASN1_STRING_type(ASN1_STRING *ptr ) 
{ 


  {
#line 1305
  return (ptr);
}
}
#line 1305 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_ASN1_STRING_sk_type(struct stack_st_ASN1_STRING *sk ) 
{ 


  {
#line 1305
  return ((OPENSSL_STACK *)sk);
}
}
#line 1305 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_ASN1_STRING_compfunc_type(sk_ASN1_STRING_compfunc cmp ) 
{ 


  {
#line 1305
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1305 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ASN1_STRING_copyfunc_type(sk_ASN1_STRING_copyfunc cpy ) 
{ 


  {
#line 1305
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1305 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_ASN1_STRING_freefunc_type(sk_ASN1_STRING_freefunc fr ) 
{ 


  {
#line 1305
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1340
extern NAMING_AUTHORITY *NAMING_AUTHORITY_new(void) ;
#line 1340
extern void NAMING_AUTHORITY_free(NAMING_AUTHORITY *a ) ;
#line 1340
extern NAMING_AUTHORITY *d2i_NAMING_AUTHORITY(NAMING_AUTHORITY **a , unsigned char const   **in ,
                                              long len ) ;
#line 1340
extern int i2d_NAMING_AUTHORITY(NAMING_AUTHORITY *a , unsigned char **out ) ;
#line 1340
extern ASN1_ITEM *NAMING_AUTHORITY_it(void) ;
#line 1341
extern PROFESSION_INFO *PROFESSION_INFO_new(void) ;
#line 1341
extern void PROFESSION_INFO_free(PROFESSION_INFO *a ) ;
#line 1341
extern PROFESSION_INFO *d2i_PROFESSION_INFO(PROFESSION_INFO **a , unsigned char const   **in ,
                                            long len ) ;
#line 1341
extern int i2d_PROFESSION_INFO(PROFESSION_INFO *a , unsigned char **out ) ;
#line 1341
extern ASN1_ITEM *PROFESSION_INFO_it(void) ;
#line 1342
extern ADMISSIONS *ADMISSIONS_new(void) ;
#line 1342
extern void ADMISSIONS_free(ADMISSIONS *a ) ;
#line 1342
extern ADMISSIONS *d2i_ADMISSIONS(ADMISSIONS **a , unsigned char const   **in , long len ) ;
#line 1342
extern int i2d_ADMISSIONS(ADMISSIONS *a , unsigned char **out ) ;
#line 1342
extern ASN1_ITEM *ADMISSIONS_it(void) ;
#line 1343
extern ADMISSION_SYNTAX *ADMISSION_SYNTAX_new(void) ;
#line 1343
extern void ADMISSION_SYNTAX_free(ADMISSION_SYNTAX *a ) ;
#line 1343
extern ADMISSION_SYNTAX *d2i_ADMISSION_SYNTAX(ADMISSION_SYNTAX **a , unsigned char const   **in ,
                                              long len ) ;
#line 1343
extern int i2d_ADMISSION_SYNTAX(ADMISSION_SYNTAX *a , unsigned char **out ) ;
#line 1343
extern ASN1_ITEM *ADMISSION_SYNTAX_it(void) ;
#line 1344 "/usr/include/openssl/x509v3.h"
__inline static PROFESSION_INFO *ossl_check_PROFESSION_INFO_type(PROFESSION_INFO *ptr ) 
{ 


  {
#line 1344
  return (ptr);
}
}
#line 1344 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_PROFESSION_INFO_sk_type(struct stack_st_PROFESSION_INFO *sk ) 
{ 


  {
#line 1344
  return ((OPENSSL_STACK *)sk);
}
}
#line 1344 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_PROFESSION_INFO_compfunc_type(sk_PROFESSION_INFO_compfunc cmp ) 
{ 


  {
#line 1344
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1344 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_PROFESSION_INFO_copyfunc_type(sk_PROFESSION_INFO_copyfunc cpy ) 
{ 


  {
#line 1344
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1344 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_PROFESSION_INFO_freefunc_type(sk_PROFESSION_INFO_freefunc fr ) 
{ 


  {
#line 1344
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1370 "/usr/include/openssl/x509v3.h"
__inline static ADMISSIONS *ossl_check_ADMISSIONS_type(ADMISSIONS *ptr ) 
{ 


  {
#line 1370
  return (ptr);
}
}
#line 1370 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_STACK *ossl_check_const_ADMISSIONS_sk_type(struct stack_st_ADMISSIONS *sk ) 
{ 


  {
#line 1370
  return ((OPENSSL_STACK *)sk);
}
}
#line 1370 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_compfunc ossl_check_ADMISSIONS_compfunc_type(sk_ADMISSIONS_compfunc cmp ) 
{ 


  {
#line 1370
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1370 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_copyfunc ossl_check_ADMISSIONS_copyfunc_type(sk_ADMISSIONS_copyfunc cpy ) 
{ 


  {
#line 1370
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1370 "/usr/include/openssl/x509v3.h"
__inline static OPENSSL_sk_freefunc ossl_check_ADMISSIONS_freefunc_type(sk_ADMISSIONS_freefunc fr ) 
{ 


  {
#line 1370
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1399
ASN1_OBJECT *NAMING_AUTHORITY_get0_authorityId(NAMING_AUTHORITY *n ) ;
#line 1401
ASN1_IA5STRING *NAMING_AUTHORITY_get0_authorityURL(NAMING_AUTHORITY *n ) ;
#line 1403
ASN1_STRING *NAMING_AUTHORITY_get0_authorityText(NAMING_AUTHORITY *n ) ;
#line 1405
void NAMING_AUTHORITY_set0_authorityId(NAMING_AUTHORITY *n , ASN1_OBJECT *namingAuthorityId ) ;
#line 1407
void NAMING_AUTHORITY_set0_authorityURL(NAMING_AUTHORITY *n , ASN1_IA5STRING *namingAuthorityUrl ) ;
#line 1409
void NAMING_AUTHORITY_set0_authorityText(NAMING_AUTHORITY *n , ASN1_STRING *namingAuthorityText ) ;
#line 1412
GENERAL_NAME *ADMISSION_SYNTAX_get0_admissionAuthority(ADMISSION_SYNTAX *as ) ;
#line 1414
void ADMISSION_SYNTAX_set0_admissionAuthority(ADMISSION_SYNTAX *as , GENERAL_NAME *aa ) ;
#line 1416
struct stack_st_ADMISSIONS *ADMISSION_SYNTAX_get0_contentsOfAdmissions(ADMISSION_SYNTAX *as ) ;
#line 1418
void ADMISSION_SYNTAX_set0_contentsOfAdmissions(ADMISSION_SYNTAX *as , struct stack_st_ADMISSIONS *a ) ;
#line 1420
GENERAL_NAME *ADMISSIONS_get0_admissionAuthority(ADMISSIONS *a ) ;
#line 1421
void ADMISSIONS_set0_admissionAuthority(ADMISSIONS *a , GENERAL_NAME *aa ) ;
#line 1422
NAMING_AUTHORITY *ADMISSIONS_get0_namingAuthority(ADMISSIONS *a ) ;
#line 1423
void ADMISSIONS_set0_namingAuthority(ADMISSIONS *a , NAMING_AUTHORITY *na ) ;
#line 1424
PROFESSION_INFOS *ADMISSIONS_get0_professionInfos(ADMISSIONS *a ) ;
#line 1425
void ADMISSIONS_set0_professionInfos(ADMISSIONS *a , PROFESSION_INFOS *pi ) ;
#line 1426
ASN1_OCTET_STRING *PROFESSION_INFO_get0_addProfessionInfo(PROFESSION_INFO *pi ) ;
#line 1428
void PROFESSION_INFO_set0_addProfessionInfo(PROFESSION_INFO *pi , ASN1_OCTET_STRING *aos ) ;
#line 1430
NAMING_AUTHORITY *PROFESSION_INFO_get0_namingAuthority(PROFESSION_INFO *pi ) ;
#line 1432
void PROFESSION_INFO_set0_namingAuthority(PROFESSION_INFO *pi , NAMING_AUTHORITY *na ) ;
#line 1434
struct stack_st_ASN1_STRING *PROFESSION_INFO_get0_professionItems(PROFESSION_INFO *pi ) ;
#line 1436
void PROFESSION_INFO_set0_professionItems(PROFESSION_INFO *pi , struct stack_st_ASN1_STRING *as ) ;
#line 1438
struct stack_st_ASN1_OBJECT *PROFESSION_INFO_get0_professionOIDs(PROFESSION_INFO *pi ) ;
#line 1440
void PROFESSION_INFO_set0_professionOIDs(PROFESSION_INFO *pi , struct stack_st_ASN1_OBJECT *po ) ;
#line 1442
ASN1_PRINTABLESTRING *PROFESSION_INFO_get0_registrationNumber(PROFESSION_INFO *pi ) ;
#line 1444
void PROFESSION_INFO_set0_registrationNumber(PROFESSION_INFO *pi , ASN1_PRINTABLESTRING *rn ) ;
#line 95 "/usr/include/openssl/ocsp.h"
__inline static OCSP_CERTID *ossl_check_OCSP_CERTID_type(OCSP_CERTID *ptr ) 
{ 


  {
#line 95
  return (ptr);
}
}
#line 95 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_STACK *ossl_check_const_OCSP_CERTID_sk_type(struct stack_st_OCSP_CERTID *sk ) 
{ 


  {
#line 95
  return ((OPENSSL_STACK *)sk);
}
}
#line 95 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_compfunc ossl_check_OCSP_CERTID_compfunc_type(sk_OCSP_CERTID_compfunc cmp ) 
{ 


  {
#line 95
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 95 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OCSP_CERTID_copyfunc_type(sk_OCSP_CERTID_copyfunc cpy ) 
{ 


  {
#line 95
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 95 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_freefunc ossl_check_OCSP_CERTID_freefunc_type(sk_OCSP_CERTID_freefunc fr ) 
{ 


  {
#line 95
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 121 "/usr/include/openssl/ocsp.h"
__inline static OCSP_ONEREQ *ossl_check_OCSP_ONEREQ_type(OCSP_ONEREQ *ptr ) 
{ 


  {
#line 121
  return (ptr);
}
}
#line 121 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_STACK *ossl_check_const_OCSP_ONEREQ_sk_type(struct stack_st_OCSP_ONEREQ *sk ) 
{ 


  {
#line 121
  return ((OPENSSL_STACK *)sk);
}
}
#line 121 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_compfunc ossl_check_OCSP_ONEREQ_compfunc_type(sk_OCSP_ONEREQ_compfunc cmp ) 
{ 


  {
#line 121
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 121 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OCSP_ONEREQ_copyfunc_type(sk_OCSP_ONEREQ_copyfunc cpy ) 
{ 


  {
#line 121
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 121 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_freefunc ossl_check_OCSP_ONEREQ_freefunc_type(sk_OCSP_ONEREQ_freefunc fr ) 
{ 


  {
#line 121
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 161 "/usr/include/openssl/ocsp.h"
__inline static OCSP_RESPID *ossl_check_OCSP_RESPID_type(OCSP_RESPID *ptr ) 
{ 


  {
#line 161
  return (ptr);
}
}
#line 161 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_STACK *ossl_check_const_OCSP_RESPID_sk_type(struct stack_st_OCSP_RESPID *sk ) 
{ 


  {
#line 161
  return ((OPENSSL_STACK *)sk);
}
}
#line 161 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_compfunc ossl_check_OCSP_RESPID_compfunc_type(sk_OCSP_RESPID_compfunc cmp ) 
{ 


  {
#line 161
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 161 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OCSP_RESPID_copyfunc_type(sk_OCSP_RESPID_copyfunc cpy ) 
{ 


  {
#line 161
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 161 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_freefunc ossl_check_OCSP_RESPID_freefunc_type(sk_OCSP_RESPID_freefunc fr ) 
{ 


  {
#line 161
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 198 "/usr/include/openssl/ocsp.h"
__inline static OCSP_SINGLERESP *ossl_check_OCSP_SINGLERESP_type(OCSP_SINGLERESP *ptr ) 
{ 


  {
#line 198
  return (ptr);
}
}
#line 198 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_STACK *ossl_check_const_OCSP_SINGLERESP_sk_type(struct stack_st_OCSP_SINGLERESP *sk ) 
{ 


  {
#line 198
  return ((OPENSSL_STACK *)sk);
}
}
#line 198 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_compfunc ossl_check_OCSP_SINGLERESP_compfunc_type(sk_OCSP_SINGLERESP_compfunc cmp ) 
{ 


  {
#line 198
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 198 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_copyfunc ossl_check_OCSP_SINGLERESP_copyfunc_type(sk_OCSP_SINGLERESP_copyfunc cpy ) 
{ 


  {
#line 198
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 198 "/usr/include/openssl/ocsp.h"
__inline static OPENSSL_sk_freefunc ossl_check_OCSP_SINGLERESP_freefunc_type(sk_OCSP_SINGLERESP_freefunc fr ) 
{ 


  {
#line 198
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 267
extern OCSP_CERTID *OCSP_CERTID_dup(OCSP_CERTID *a ) ;
#line 269
OSSL_HTTP_REQ_CTX *OCSP_sendreq_new(BIO *io , char const   *path , OCSP_REQUEST *req ,
                                    int buf_size ) ;
#line 271
OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b , char const   *path , OCSP_REQUEST *req ) ;
#line 296
OCSP_CERTID *OCSP_cert_to_id(EVP_MD *dgst , X509 *subject , X509 *issuer ) ;
#line 299
OCSP_CERTID *OCSP_cert_id_new(EVP_MD *dgst , X509_NAME *issuerName , ASN1_BIT_STRING *issuerKey ,
                              ASN1_INTEGER *serialNumber ) ;
#line 304
OCSP_ONEREQ *OCSP_request_add0_id(OCSP_REQUEST *req , OCSP_CERTID *cid ) ;
#line 306
int OCSP_request_add1_nonce(OCSP_REQUEST *req , unsigned char *val , int len ) ;
#line 307
int OCSP_basic_add1_nonce(OCSP_BASICRESP *resp , unsigned char *val , int len ) ;
#line 308
int OCSP_check_nonce(OCSP_REQUEST *req , OCSP_BASICRESP *bs ) ;
#line 309
int OCSP_copy_nonce(OCSP_BASICRESP *resp , OCSP_REQUEST *req ) ;
#line 311
int OCSP_request_set1_name(OCSP_REQUEST *req , X509_NAME *nm ) ;
#line 312
int OCSP_request_add1_cert(OCSP_REQUEST *req , X509 *cert ) ;
#line 314
int OCSP_request_sign(OCSP_REQUEST *req , X509 *signer , EVP_PKEY *key , EVP_MD *dgst ,
                      struct stack_st_X509 *certs , unsigned long flags ) ;
#line 320
int OCSP_response_status(OCSP_RESPONSE *resp ) ;
#line 321
OCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *resp ) ;
#line 323
ASN1_OCTET_STRING *OCSP_resp_get0_signature(OCSP_BASICRESP *bs ) ;
#line 324
X509_ALGOR *OCSP_resp_get0_tbs_sigalg(OCSP_BASICRESP *bs ) ;
#line 325
OCSP_RESPDATA *OCSP_resp_get0_respdata(OCSP_BASICRESP *bs ) ;
#line 326
int OCSP_resp_get0_signer(OCSP_BASICRESP *bs , X509 **signer , struct stack_st_X509 *extra_certs ) ;
#line 329
int OCSP_resp_count(OCSP_BASICRESP *bs ) ;
#line 330
OCSP_SINGLERESP *OCSP_resp_get0(OCSP_BASICRESP *bs , int idx ) ;
#line 331
ASN1_GENERALIZEDTIME *OCSP_resp_get0_produced_at(OCSP_BASICRESP *bs ) ;
#line 332
struct stack_st_X509 *OCSP_resp_get0_certs(OCSP_BASICRESP *bs ) ;
#line 333
int OCSP_resp_get0_id(OCSP_BASICRESP *bs , ASN1_OCTET_STRING **pid , X509_NAME **pname ) ;
#line 336
int OCSP_resp_get1_id(OCSP_BASICRESP *bs , ASN1_OCTET_STRING **pid , X509_NAME **pname ) ;
#line 340
int OCSP_resp_find(OCSP_BASICRESP *bs , OCSP_CERTID *id , int last ) ;
#line 341
int OCSP_single_get0_status(OCSP_SINGLERESP *single , int *reason , ASN1_GENERALIZEDTIME **revtime ,
                            ASN1_GENERALIZEDTIME **thisupd , ASN1_GENERALIZEDTIME **nextupd ) ;
#line 345
int OCSP_resp_find_status(OCSP_BASICRESP *bs , OCSP_CERTID *id , int *status , int *reason ,
                          ASN1_GENERALIZEDTIME **revtime , ASN1_GENERALIZEDTIME **thisupd ,
                          ASN1_GENERALIZEDTIME **nextupd ) ;
#line 350
int OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd , ASN1_GENERALIZEDTIME *nextupd ,
                        long sec , long maxsec ) ;
#line 353
int OCSP_request_verify(OCSP_REQUEST *req , struct stack_st_X509 *certs , X509_STORE *store ,
                        unsigned long flags ) ;
#line 359
int OCSP_id_issuer_cmp(OCSP_CERTID *a , OCSP_CERTID *b ) ;
#line 360
int OCSP_id_cmp(OCSP_CERTID *a , OCSP_CERTID *b ) ;
#line 362
int OCSP_request_onereq_count(OCSP_REQUEST *req ) ;
#line 363
OCSP_ONEREQ *OCSP_request_onereq_get0(OCSP_REQUEST *req , int i ) ;
#line 364
OCSP_CERTID *OCSP_onereq_get0_id(OCSP_ONEREQ *one ) ;
#line 365
int OCSP_id_get0_info(ASN1_OCTET_STRING **piNameHash , ASN1_OBJECT **pmd , ASN1_OCTET_STRING **pikeyHash ,
                      ASN1_INTEGER **pserial , OCSP_CERTID *cid ) ;
#line 368
int OCSP_request_is_signed(OCSP_REQUEST *req ) ;
#line 369
OCSP_RESPONSE *OCSP_response_create(int status , OCSP_BASICRESP *bs ) ;
#line 370
OCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *rsp , OCSP_CERTID *cid , int status ,
                                        int reason , ASN1_TIME *revtime , ASN1_TIME *thisupd ,
                                        ASN1_TIME *nextupd ) ;
#line 376
int OCSP_basic_add1_cert(OCSP_BASICRESP *resp , X509 *cert ) ;
#line 377
int OCSP_basic_sign(OCSP_BASICRESP *brsp , X509 *signer , EVP_PKEY *key , EVP_MD *dgst ,
                    struct stack_st_X509 *certs , unsigned long flags ) ;
#line 380
int OCSP_basic_sign_ctx(OCSP_BASICRESP *brsp , X509 *signer , EVP_MD_CTX *ctx , struct stack_st_X509 *certs ,
                        unsigned long flags ) ;
#line 383
int OCSP_RESPID_set_by_name(OCSP_RESPID *respid , X509 *cert ) ;
#line 384
int OCSP_RESPID_set_by_key_ex(OCSP_RESPID *respid , X509 *cert , OSSL_LIB_CTX *libctx ,
                              char const   *propq ) ;
#line 386
int OCSP_RESPID_set_by_key(OCSP_RESPID *respid , X509 *cert ) ;
#line 387
int OCSP_RESPID_match_ex(OCSP_RESPID *respid , X509 *cert , OSSL_LIB_CTX *libctx ,
                         char const   *propq ) ;
#line 389
int OCSP_RESPID_match(OCSP_RESPID *respid , X509 *cert ) ;
#line 391
X509_EXTENSION *OCSP_crlID_new(char const   *url , long *n , char *tim ) ;
#line 393
X509_EXTENSION *OCSP_accept_responses_new(char **oids ) ;
#line 395
X509_EXTENSION *OCSP_archive_cutoff_new(char *tim ) ;
#line 397
X509_EXTENSION *OCSP_url_svcloc_new(X509_NAME *issuer , char const   **urls ) ;
#line 399
int OCSP_REQUEST_get_ext_count(OCSP_REQUEST *x ) ;
#line 400
int OCSP_REQUEST_get_ext_by_NID(OCSP_REQUEST *x , int nid , int lastpos ) ;
#line 401
int OCSP_REQUEST_get_ext_by_OBJ(OCSP_REQUEST *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 403
int OCSP_REQUEST_get_ext_by_critical(OCSP_REQUEST *x , int crit , int lastpos ) ;
#line 404
X509_EXTENSION *OCSP_REQUEST_get_ext(OCSP_REQUEST *x , int loc ) ;
#line 405
X509_EXTENSION *OCSP_REQUEST_delete_ext(OCSP_REQUEST *x , int loc ) ;
#line 406
void *OCSP_REQUEST_get1_ext_d2i(OCSP_REQUEST *x , int nid , int *crit , int *idx ) ;
#line 408
int OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST *x , int nid , void *value , int crit ,
                              unsigned long flags ) ;
#line 410
int OCSP_REQUEST_add_ext(OCSP_REQUEST *x , X509_EXTENSION *ex , int loc ) ;
#line 412
int OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ *x ) ;
#line 413
int OCSP_ONEREQ_get_ext_by_NID(OCSP_ONEREQ *x , int nid , int lastpos ) ;
#line 414
int OCSP_ONEREQ_get_ext_by_OBJ(OCSP_ONEREQ *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 415
int OCSP_ONEREQ_get_ext_by_critical(OCSP_ONEREQ *x , int crit , int lastpos ) ;
#line 416
X509_EXTENSION *OCSP_ONEREQ_get_ext(OCSP_ONEREQ *x , int loc ) ;
#line 417
X509_EXTENSION *OCSP_ONEREQ_delete_ext(OCSP_ONEREQ *x , int loc ) ;
#line 418
void *OCSP_ONEREQ_get1_ext_d2i(OCSP_ONEREQ *x , int nid , int *crit , int *idx ) ;
#line 419
int OCSP_ONEREQ_add1_ext_i2d(OCSP_ONEREQ *x , int nid , void *value , int crit , unsigned long flags ) ;
#line 421
int OCSP_ONEREQ_add_ext(OCSP_ONEREQ *x , X509_EXTENSION *ex , int loc ) ;
#line 423
int OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP *x ) ;
#line 424
int OCSP_BASICRESP_get_ext_by_NID(OCSP_BASICRESP *x , int nid , int lastpos ) ;
#line 425
int OCSP_BASICRESP_get_ext_by_OBJ(OCSP_BASICRESP *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 427
int OCSP_BASICRESP_get_ext_by_critical(OCSP_BASICRESP *x , int crit , int lastpos ) ;
#line 429
X509_EXTENSION *OCSP_BASICRESP_get_ext(OCSP_BASICRESP *x , int loc ) ;
#line 430
X509_EXTENSION *OCSP_BASICRESP_delete_ext(OCSP_BASICRESP *x , int loc ) ;
#line 431
void *OCSP_BASICRESP_get1_ext_d2i(OCSP_BASICRESP *x , int nid , int *crit , int *idx ) ;
#line 433
int OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP *x , int nid , void *value , int crit ,
                                unsigned long flags ) ;
#line 435
int OCSP_BASICRESP_add_ext(OCSP_BASICRESP *x , X509_EXTENSION *ex , int loc ) ;
#line 437
int OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP *x ) ;
#line 438
int OCSP_SINGLERESP_get_ext_by_NID(OCSP_SINGLERESP *x , int nid , int lastpos ) ;
#line 439
int OCSP_SINGLERESP_get_ext_by_OBJ(OCSP_SINGLERESP *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 441
int OCSP_SINGLERESP_get_ext_by_critical(OCSP_SINGLERESP *x , int crit , int lastpos ) ;
#line 443
X509_EXTENSION *OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP *x , int loc ) ;
#line 444
X509_EXTENSION *OCSP_SINGLERESP_delete_ext(OCSP_SINGLERESP *x , int loc ) ;
#line 445
void *OCSP_SINGLERESP_get1_ext_d2i(OCSP_SINGLERESP *x , int nid , int *crit , int *idx ) ;
#line 447
int OCSP_SINGLERESP_add1_ext_i2d(OCSP_SINGLERESP *x , int nid , void *value , int crit ,
                                 unsigned long flags ) ;
#line 449
int OCSP_SINGLERESP_add_ext(OCSP_SINGLERESP *x , X509_EXTENSION *ex , int loc ) ;
#line 450
OCSP_CERTID *OCSP_SINGLERESP_get0_id(OCSP_SINGLERESP *x ) ;
#line 452
extern OCSP_SINGLERESP *OCSP_SINGLERESP_new(void) ;
#line 452
extern void OCSP_SINGLERESP_free(OCSP_SINGLERESP *a ) ;
#line 452
extern OCSP_SINGLERESP *d2i_OCSP_SINGLERESP(OCSP_SINGLERESP **a , unsigned char const   **in ,
                                            long len ) ;
#line 452
extern int i2d_OCSP_SINGLERESP(OCSP_SINGLERESP *a , unsigned char **out ) ;
#line 452
extern ASN1_ITEM *OCSP_SINGLERESP_it(void) ;
#line 453
extern OCSP_CERTSTATUS *OCSP_CERTSTATUS_new(void) ;
#line 453
extern void OCSP_CERTSTATUS_free(OCSP_CERTSTATUS *a ) ;
#line 453
extern OCSP_CERTSTATUS *d2i_OCSP_CERTSTATUS(OCSP_CERTSTATUS **a , unsigned char const   **in ,
                                            long len ) ;
#line 453
extern int i2d_OCSP_CERTSTATUS(OCSP_CERTSTATUS *a , unsigned char **out ) ;
#line 453
extern ASN1_ITEM *OCSP_CERTSTATUS_it(void) ;
#line 454
extern OCSP_REVOKEDINFO *OCSP_REVOKEDINFO_new(void) ;
#line 454
extern void OCSP_REVOKEDINFO_free(OCSP_REVOKEDINFO *a ) ;
#line 454
extern OCSP_REVOKEDINFO *d2i_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO **a , unsigned char const   **in ,
                                              long len ) ;
#line 454
extern int i2d_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO *a , unsigned char **out ) ;
#line 454
extern ASN1_ITEM *OCSP_REVOKEDINFO_it(void) ;
#line 455
extern OCSP_BASICRESP *OCSP_BASICRESP_new(void) ;
#line 455
extern void OCSP_BASICRESP_free(OCSP_BASICRESP *a ) ;
#line 455
extern OCSP_BASICRESP *d2i_OCSP_BASICRESP(OCSP_BASICRESP **a , unsigned char const   **in ,
                                          long len ) ;
#line 455
extern int i2d_OCSP_BASICRESP(OCSP_BASICRESP *a , unsigned char **out ) ;
#line 455
extern ASN1_ITEM *OCSP_BASICRESP_it(void) ;
#line 456
extern OCSP_RESPDATA *OCSP_RESPDATA_new(void) ;
#line 456
extern void OCSP_RESPDATA_free(OCSP_RESPDATA *a ) ;
#line 456
extern OCSP_RESPDATA *d2i_OCSP_RESPDATA(OCSP_RESPDATA **a , unsigned char const   **in ,
                                        long len ) ;
#line 456
extern int i2d_OCSP_RESPDATA(OCSP_RESPDATA *a , unsigned char **out ) ;
#line 456
extern ASN1_ITEM *OCSP_RESPDATA_it(void) ;
#line 457
extern OCSP_RESPID *OCSP_RESPID_new(void) ;
#line 457
extern void OCSP_RESPID_free(OCSP_RESPID *a ) ;
#line 457
extern OCSP_RESPID *d2i_OCSP_RESPID(OCSP_RESPID **a , unsigned char const   **in ,
                                    long len ) ;
#line 457
extern int i2d_OCSP_RESPID(OCSP_RESPID *a , unsigned char **out ) ;
#line 457
extern ASN1_ITEM *OCSP_RESPID_it(void) ;
#line 458
extern OCSP_RESPONSE *OCSP_RESPONSE_new(void) ;
#line 458
extern void OCSP_RESPONSE_free(OCSP_RESPONSE *a ) ;
#line 458
extern OCSP_RESPONSE *d2i_OCSP_RESPONSE(OCSP_RESPONSE **a , unsigned char const   **in ,
                                        long len ) ;
#line 458
extern int i2d_OCSP_RESPONSE(OCSP_RESPONSE *a , unsigned char **out ) ;
#line 458
extern ASN1_ITEM *OCSP_RESPONSE_it(void) ;
#line 459
extern OCSP_RESPBYTES *OCSP_RESPBYTES_new(void) ;
#line 459
extern void OCSP_RESPBYTES_free(OCSP_RESPBYTES *a ) ;
#line 459
extern OCSP_RESPBYTES *d2i_OCSP_RESPBYTES(OCSP_RESPBYTES **a , unsigned char const   **in ,
                                          long len ) ;
#line 459
extern int i2d_OCSP_RESPBYTES(OCSP_RESPBYTES *a , unsigned char **out ) ;
#line 459
extern ASN1_ITEM *OCSP_RESPBYTES_it(void) ;
#line 460
extern OCSP_ONEREQ *OCSP_ONEREQ_new(void) ;
#line 460
extern void OCSP_ONEREQ_free(OCSP_ONEREQ *a ) ;
#line 460
extern OCSP_ONEREQ *d2i_OCSP_ONEREQ(OCSP_ONEREQ **a , unsigned char const   **in ,
                                    long len ) ;
#line 460
extern int i2d_OCSP_ONEREQ(OCSP_ONEREQ *a , unsigned char **out ) ;
#line 460
extern ASN1_ITEM *OCSP_ONEREQ_it(void) ;
#line 461
extern OCSP_CERTID *OCSP_CERTID_new(void) ;
#line 461
extern void OCSP_CERTID_free(OCSP_CERTID *a ) ;
#line 461
extern OCSP_CERTID *d2i_OCSP_CERTID(OCSP_CERTID **a , unsigned char const   **in ,
                                    long len ) ;
#line 461
extern int i2d_OCSP_CERTID(OCSP_CERTID *a , unsigned char **out ) ;
#line 461
extern ASN1_ITEM *OCSP_CERTID_it(void) ;
#line 462
extern OCSP_REQUEST *OCSP_REQUEST_new(void) ;
#line 462
extern void OCSP_REQUEST_free(OCSP_REQUEST *a ) ;
#line 462
extern OCSP_REQUEST *d2i_OCSP_REQUEST(OCSP_REQUEST **a , unsigned char const   **in ,
                                      long len ) ;
#line 462
extern int i2d_OCSP_REQUEST(OCSP_REQUEST *a , unsigned char **out ) ;
#line 462
extern ASN1_ITEM *OCSP_REQUEST_it(void) ;
#line 463
extern OCSP_SIGNATURE *OCSP_SIGNATURE_new(void) ;
#line 463
extern void OCSP_SIGNATURE_free(OCSP_SIGNATURE *a ) ;
#line 463
extern OCSP_SIGNATURE *d2i_OCSP_SIGNATURE(OCSP_SIGNATURE **a , unsigned char const   **in ,
                                          long len ) ;
#line 463
extern int i2d_OCSP_SIGNATURE(OCSP_SIGNATURE *a , unsigned char **out ) ;
#line 463
extern ASN1_ITEM *OCSP_SIGNATURE_it(void) ;
#line 464
extern OCSP_REQINFO *OCSP_REQINFO_new(void) ;
#line 464
extern void OCSP_REQINFO_free(OCSP_REQINFO *a ) ;
#line 464
extern OCSP_REQINFO *d2i_OCSP_REQINFO(OCSP_REQINFO **a , unsigned char const   **in ,
                                      long len ) ;
#line 464
extern int i2d_OCSP_REQINFO(OCSP_REQINFO *a , unsigned char **out ) ;
#line 464
extern ASN1_ITEM *OCSP_REQINFO_it(void) ;
#line 465
extern OCSP_CRLID *OCSP_CRLID_new(void) ;
#line 465
extern void OCSP_CRLID_free(OCSP_CRLID *a ) ;
#line 465
extern OCSP_CRLID *d2i_OCSP_CRLID(OCSP_CRLID **a , unsigned char const   **in , long len ) ;
#line 465
extern int i2d_OCSP_CRLID(OCSP_CRLID *a , unsigned char **out ) ;
#line 465
extern ASN1_ITEM *OCSP_CRLID_it(void) ;
#line 466
extern OCSP_SERVICELOC *OCSP_SERVICELOC_new(void) ;
#line 466
extern void OCSP_SERVICELOC_free(OCSP_SERVICELOC *a ) ;
#line 466
extern OCSP_SERVICELOC *d2i_OCSP_SERVICELOC(OCSP_SERVICELOC **a , unsigned char const   **in ,
                                            long len ) ;
#line 466
extern int i2d_OCSP_SERVICELOC(OCSP_SERVICELOC *a , unsigned char **out ) ;
#line 466
extern ASN1_ITEM *OCSP_SERVICELOC_it(void) ;
#line 468
char const   *OCSP_response_status_str(long s ) ;
#line 469
char const   *OCSP_cert_status_str(long s ) ;
#line 470
char const   *OCSP_crl_reason_str(long s ) ;
#line 472
int OCSP_REQUEST_print(BIO *bp , OCSP_REQUEST *a , unsigned long flags ) ;
#line 473
int OCSP_RESPONSE_print(BIO *bp , OCSP_RESPONSE *o , unsigned long flags ) ;
#line 475
int OCSP_basic_verify(OCSP_BASICRESP *bs , struct stack_st_X509 *certs , X509_STORE *st ,
                      unsigned long flags ) ;
#line 563 "/usr/include/openssl/x509.h"
X509 *d2i_X509_fp(FILE *fp , X509 **x509 ) ;
#line 564
int i2d_X509_fp(FILE *fp , X509 *x509 ) ;
#line 565
X509_CRL *d2i_X509_CRL_fp(FILE *fp , X509_CRL **crl ) ;
#line 566
int i2d_X509_CRL_fp(FILE *fp , X509_CRL *crl ) ;
#line 567
X509_REQ *d2i_X509_REQ_fp(FILE *fp , X509_REQ **req ) ;
#line 568
int i2d_X509_REQ_fp(FILE *fp , X509_REQ *req ) ;
#line 570
RSA *d2i_RSAPrivateKey_fp(FILE *fp , RSA **rsa ) ;
#line 571
int i2d_RSAPrivateKey_fp(FILE *fp , RSA *rsa ) ;
#line 572
RSA *d2i_RSAPublicKey_fp(FILE *fp , RSA **rsa ) ;
#line 573
int i2d_RSAPublicKey_fp(FILE *fp , RSA *rsa ) ;
#line 574
RSA *d2i_RSA_PUBKEY_fp(FILE *fp , RSA **rsa ) ;
#line 575
int i2d_RSA_PUBKEY_fp(FILE *fp , RSA *rsa ) ;
#line 579
DSA *d2i_DSA_PUBKEY_fp(FILE *fp , DSA **dsa ) ;
#line 580
int i2d_DSA_PUBKEY_fp(FILE *fp , DSA *dsa ) ;
#line 581
DSA *d2i_DSAPrivateKey_fp(FILE *fp , DSA **dsa ) ;
#line 582
int i2d_DSAPrivateKey_fp(FILE *fp , DSA *dsa ) ;
#line 587
EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp , EC_KEY **eckey ) ;
#line 588
int i2d_EC_PUBKEY_fp(FILE *fp , EC_KEY *eckey ) ;
#line 589
EC_KEY *d2i_ECPrivateKey_fp(FILE *fp , EC_KEY **eckey ) ;
#line 590
int i2d_ECPrivateKey_fp(FILE *fp , EC_KEY *eckey ) ;
#line 593
X509_SIG *d2i_PKCS8_fp(FILE *fp , X509_SIG **p8 ) ;
#line 594
int i2d_PKCS8_fp(FILE *fp , X509_SIG *p8 ) ;
#line 595
X509_PUBKEY *d2i_X509_PUBKEY_fp(FILE *fp , X509_PUBKEY **xpk ) ;
#line 596
int i2d_X509_PUBKEY_fp(FILE *fp , X509_PUBKEY *xpk ) ;
#line 597
PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp , PKCS8_PRIV_KEY_INFO **p8inf ) ;
#line 599
int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp , PKCS8_PRIV_KEY_INFO *p8inf ) ;
#line 600
int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp , EVP_PKEY *key ) ;
#line 601
int i2d_PrivateKey_fp(FILE *fp , EVP_PKEY *pkey ) ;
#line 602
EVP_PKEY *d2i_PrivateKey_ex_fp(FILE *fp , EVP_PKEY **a , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 604
EVP_PKEY *d2i_PrivateKey_fp(FILE *fp , EVP_PKEY **a ) ;
#line 605
int i2d_PUBKEY_fp(FILE *fp , EVP_PKEY *pkey ) ;
#line 606
EVP_PKEY *d2i_PUBKEY_fp(FILE *fp , EVP_PKEY **a ) ;
#line 609
X509 *d2i_X509_bio(BIO *bp , X509 **x509 ) ;
#line 610
int i2d_X509_bio(BIO *bp , X509 *x509 ) ;
#line 611
X509_CRL *d2i_X509_CRL_bio(BIO *bp , X509_CRL **crl ) ;
#line 612
int i2d_X509_CRL_bio(BIO *bp , X509_CRL *crl ) ;
#line 613
X509_REQ *d2i_X509_REQ_bio(BIO *bp , X509_REQ **req ) ;
#line 614
int i2d_X509_REQ_bio(BIO *bp , X509_REQ *req ) ;
#line 616
RSA *d2i_RSAPrivateKey_bio(BIO *bp , RSA **rsa ) ;
#line 617
int i2d_RSAPrivateKey_bio(BIO *bp , RSA *rsa ) ;
#line 618
RSA *d2i_RSAPublicKey_bio(BIO *bp , RSA **rsa ) ;
#line 619
int i2d_RSAPublicKey_bio(BIO *bp , RSA *rsa ) ;
#line 620
RSA *d2i_RSA_PUBKEY_bio(BIO *bp , RSA **rsa ) ;
#line 621
int i2d_RSA_PUBKEY_bio(BIO *bp , RSA *rsa ) ;
#line 625
DSA *d2i_DSA_PUBKEY_bio(BIO *bp , DSA **dsa ) ;
#line 626
int i2d_DSA_PUBKEY_bio(BIO *bp , DSA *dsa ) ;
#line 627
DSA *d2i_DSAPrivateKey_bio(BIO *bp , DSA **dsa ) ;
#line 628
int i2d_DSAPrivateKey_bio(BIO *bp , DSA *dsa ) ;
#line 634
EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp , EC_KEY **eckey ) ;
#line 635
int i2d_EC_PUBKEY_bio(BIO *bp , EC_KEY *eckey ) ;
#line 636
EC_KEY *d2i_ECPrivateKey_bio(BIO *bp , EC_KEY **eckey ) ;
#line 637
int i2d_ECPrivateKey_bio(BIO *bp , EC_KEY *eckey ) ;
#line 641
X509_SIG *d2i_PKCS8_bio(BIO *bp , X509_SIG **p8 ) ;
#line 642
int i2d_PKCS8_bio(BIO *bp , X509_SIG *p8 ) ;
#line 643
X509_PUBKEY *d2i_X509_PUBKEY_bio(BIO *bp , X509_PUBKEY **xpk ) ;
#line 644
int i2d_X509_PUBKEY_bio(BIO *bp , X509_PUBKEY *xpk ) ;
#line 645
PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp , PKCS8_PRIV_KEY_INFO **p8inf ) ;
#line 647
int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp , PKCS8_PRIV_KEY_INFO *p8inf ) ;
#line 648
int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp , EVP_PKEY *key ) ;
#line 649
int i2d_PrivateKey_bio(BIO *bp , EVP_PKEY *pkey ) ;
#line 650
EVP_PKEY *d2i_PrivateKey_ex_bio(BIO *bp , EVP_PKEY **a , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 652
EVP_PKEY *d2i_PrivateKey_bio(BIO *bp , EVP_PKEY **a ) ;
#line 653
int i2d_PUBKEY_bio(BIO *bp , EVP_PKEY *pkey ) ;
#line 654
EVP_PKEY *d2i_PUBKEY_bio(BIO *bp , EVP_PKEY **a ) ;
#line 656
extern X509 *X509_dup(X509 *a ) ;
#line 657
extern X509_ALGOR *X509_ALGOR_dup(X509_ALGOR *a ) ;
#line 658
extern X509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *a ) ;
#line 659
extern X509_CRL *X509_CRL_dup(X509_CRL *a ) ;
#line 660
extern X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *a ) ;
#line 661
extern X509_PUBKEY *X509_PUBKEY_dup(X509_PUBKEY *a ) ;
#line 662
extern X509_REQ *X509_REQ_dup(X509_REQ *a ) ;
#line 663
extern X509_REVOKED *X509_REVOKED_dup(X509_REVOKED *a ) ;
#line 664
int X509_ALGOR_set0(X509_ALGOR *alg , ASN1_OBJECT *aobj , int ptype , void *pval ) ;
#line 666
void X509_ALGOR_get0(ASN1_OBJECT **paobj , int *pptype , void const   **ppval , X509_ALGOR *algor ) ;
#line 668
void X509_ALGOR_set_md(X509_ALGOR *alg , EVP_MD *md ) ;
#line 669
int X509_ALGOR_cmp(X509_ALGOR *a , X509_ALGOR *b ) ;
#line 670
int X509_ALGOR_copy(X509_ALGOR *dest , X509_ALGOR *src ) ;
#line 672
extern X509_NAME *X509_NAME_dup(X509_NAME *a ) ;
#line 673
extern X509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *a ) ;
#line 675
int X509_cmp_time(ASN1_TIME *s , time_t *t ) ;
#line 676
int X509_cmp_current_time(ASN1_TIME *s ) ;
#line 677
int X509_cmp_timeframe(X509_VERIFY_PARAM *vpm , ASN1_TIME *start , ASN1_TIME *end ) ;
#line 679
ASN1_TIME *X509_time_adj(ASN1_TIME *s , long adj , time_t *t ) ;
#line 680
ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s , int offset_day , long offset_sec , time_t *t ) ;
#line 682
ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s , long adj ) ;
#line 684
char const   *X509_get_default_cert_area(void) ;
#line 685
char const   *X509_get_default_cert_dir(void) ;
#line 686
char const   *X509_get_default_cert_file(void) ;
#line 687
char const   *X509_get_default_cert_dir_env(void) ;
#line 688
char const   *X509_get_default_cert_file_env(void) ;
#line 689
char const   *X509_get_default_private_dir(void) ;
#line 691
X509_REQ *X509_to_X509_REQ(X509 *x , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 692
X509 *X509_REQ_to_X509(X509_REQ *r , int days , EVP_PKEY *pkey ) ;
#line 694
extern X509_ALGOR *X509_ALGOR_new(void) ;
#line 694
extern void X509_ALGOR_free(X509_ALGOR *a ) ;
#line 694
extern X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a , unsigned char const   **in , long len ) ;
#line 694
extern int i2d_X509_ALGOR(X509_ALGOR *a , unsigned char **out ) ;
#line 694
extern ASN1_ITEM *X509_ALGOR_it(void) ;
#line 695
extern X509_ALGORS *d2i_X509_ALGORS(X509_ALGORS **a , unsigned char const   **in ,
                                    long len ) ;
#line 695
extern int i2d_X509_ALGORS(X509_ALGORS *a , unsigned char **out ) ;
#line 695
extern ASN1_ITEM *X509_ALGORS_it(void) ;
#line 696
extern X509_VAL *X509_VAL_new(void) ;
#line 696
extern void X509_VAL_free(X509_VAL *a ) ;
#line 696
extern X509_VAL *d2i_X509_VAL(X509_VAL **a , unsigned char const   **in , long len ) ;
#line 696
extern int i2d_X509_VAL(X509_VAL *a , unsigned char **out ) ;
#line 696
extern ASN1_ITEM *X509_VAL_it(void) ;
#line 698
extern X509_PUBKEY *X509_PUBKEY_new(void) ;
#line 698
extern void X509_PUBKEY_free(X509_PUBKEY *a ) ;
#line 698
extern X509_PUBKEY *d2i_X509_PUBKEY(X509_PUBKEY **a , unsigned char const   **in ,
                                    long len ) ;
#line 698
extern int i2d_X509_PUBKEY(X509_PUBKEY *a , unsigned char **out ) ;
#line 698
extern ASN1_ITEM *X509_PUBKEY_it(void) ;
#line 700
X509_PUBKEY *X509_PUBKEY_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 701
int X509_PUBKEY_set(X509_PUBKEY **x , EVP_PKEY *pkey ) ;
#line 702
EVP_PKEY *X509_PUBKEY_get0(X509_PUBKEY *key ) ;
#line 703
EVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key ) ;
#line 704
int X509_get_pubkey_parameters(EVP_PKEY *pkey , struct stack_st_X509 *chain ) ;
#line 705
long X509_get_pathlen(X509 *x ) ;
#line 706
extern EVP_PKEY *d2i_PUBKEY(EVP_PKEY **a , unsigned char const   **in , long len ) ;
#line 706
extern int i2d_PUBKEY(EVP_PKEY *a , unsigned char **out ) ;
#line 707
EVP_PKEY *d2i_PUBKEY_ex(EVP_PKEY **a , unsigned char const   **pp , long length ,
                        OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 710
RSA *d2i_RSA_PUBKEY(RSA **a , unsigned char const   **in , long len ) ;
#line 710
int i2d_RSA_PUBKEY(RSA *a , unsigned char **out ) ;
#line 714
DSA *d2i_DSA_PUBKEY(DSA **a , unsigned char const   **in , long len ) ;
#line 714
int i2d_DSA_PUBKEY(DSA *a , unsigned char **out ) ;
#line 719
EC_KEY *d2i_EC_PUBKEY(EC_KEY **a , unsigned char const   **in , long len ) ;
#line 719
int i2d_EC_PUBKEY(EC_KEY *a , unsigned char **out ) ;
#line 723
extern X509_SIG *X509_SIG_new(void) ;
#line 723
extern void X509_SIG_free(X509_SIG *a ) ;
#line 723
extern X509_SIG *d2i_X509_SIG(X509_SIG **a , unsigned char const   **in , long len ) ;
#line 723
extern int i2d_X509_SIG(X509_SIG *a , unsigned char **out ) ;
#line 723
extern ASN1_ITEM *X509_SIG_it(void) ;
#line 724
void X509_SIG_get0(X509_SIG *sig , X509_ALGOR **palg , ASN1_OCTET_STRING **pdigest ) ;
#line 726
void X509_SIG_getm(X509_SIG *sig , X509_ALGOR **palg , ASN1_OCTET_STRING **pdigest ) ;
#line 729
extern X509_REQ_INFO *X509_REQ_INFO_new(void) ;
#line 729
extern void X509_REQ_INFO_free(X509_REQ_INFO *a ) ;
#line 729
extern X509_REQ_INFO *d2i_X509_REQ_INFO(X509_REQ_INFO **a , unsigned char const   **in ,
                                        long len ) ;
#line 729
extern int i2d_X509_REQ_INFO(X509_REQ_INFO *a , unsigned char **out ) ;
#line 729
extern ASN1_ITEM *X509_REQ_INFO_it(void) ;
#line 730
extern X509_REQ *X509_REQ_new(void) ;
#line 730
extern void X509_REQ_free(X509_REQ *a ) ;
#line 730
extern X509_REQ *d2i_X509_REQ(X509_REQ **a , unsigned char const   **in , long len ) ;
#line 730
extern int i2d_X509_REQ(X509_REQ *a , unsigned char **out ) ;
#line 730
extern ASN1_ITEM *X509_REQ_it(void) ;
#line 731
X509_REQ *X509_REQ_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 733
extern X509_ATTRIBUTE *X509_ATTRIBUTE_new(void) ;
#line 733
extern void X509_ATTRIBUTE_free(X509_ATTRIBUTE *a ) ;
#line 733
extern X509_ATTRIBUTE *d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **a , unsigned char const   **in ,
                                          long len ) ;
#line 733
extern int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a , unsigned char **out ) ;
#line 733
extern ASN1_ITEM *X509_ATTRIBUTE_it(void) ;
#line 734
X509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid , int atrtype , void *value ) ;
#line 736
extern X509_EXTENSION *X509_EXTENSION_new(void) ;
#line 736
extern void X509_EXTENSION_free(X509_EXTENSION *a ) ;
#line 736
extern X509_EXTENSION *d2i_X509_EXTENSION(X509_EXTENSION **a , unsigned char const   **in ,
                                          long len ) ;
#line 736
extern int i2d_X509_EXTENSION(X509_EXTENSION *a , unsigned char **out ) ;
#line 736
extern ASN1_ITEM *X509_EXTENSION_it(void) ;
#line 737
extern X509_EXTENSIONS *d2i_X509_EXTENSIONS(X509_EXTENSIONS **a , unsigned char const   **in ,
                                            long len ) ;
#line 737
extern int i2d_X509_EXTENSIONS(X509_EXTENSIONS *a , unsigned char **out ) ;
#line 737
extern ASN1_ITEM *X509_EXTENSIONS_it(void) ;
#line 739
extern X509_NAME_ENTRY *X509_NAME_ENTRY_new(void) ;
#line 739
extern void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a ) ;
#line 739
extern X509_NAME_ENTRY *d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a , unsigned char const   **in ,
                                            long len ) ;
#line 739
extern int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a , unsigned char **out ) ;
#line 739
extern ASN1_ITEM *X509_NAME_ENTRY_it(void) ;
#line 741
extern X509_NAME *X509_NAME_new(void) ;
#line 741
extern void X509_NAME_free(X509_NAME *a ) ;
#line 741
extern X509_NAME *d2i_X509_NAME(X509_NAME **a , unsigned char const   **in , long len ) ;
#line 741
extern int i2d_X509_NAME(X509_NAME *a , unsigned char **out ) ;
#line 741
extern ASN1_ITEM *X509_NAME_it(void) ;
#line 743
int X509_NAME_set(X509_NAME **xn , X509_NAME *name ) ;
#line 745
extern X509_CINF *X509_CINF_new(void) ;
#line 745
extern void X509_CINF_free(X509_CINF *a ) ;
#line 745
extern X509_CINF *d2i_X509_CINF(X509_CINF **a , unsigned char const   **in , long len ) ;
#line 745
extern int i2d_X509_CINF(X509_CINF *a , unsigned char **out ) ;
#line 745
extern ASN1_ITEM *X509_CINF_it(void) ;
#line 746
extern X509 *X509_new(void) ;
#line 746
extern void X509_free(X509 *a ) ;
#line 746
extern X509 *d2i_X509(X509 **a , unsigned char const   **in , long len ) ;
#line 746
extern int i2d_X509(X509 *a , unsigned char **out ) ;
#line 746
extern ASN1_ITEM *X509_it(void) ;
#line 747
X509 *X509_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 748
extern X509_CERT_AUX *X509_CERT_AUX_new(void) ;
#line 748
extern void X509_CERT_AUX_free(X509_CERT_AUX *a ) ;
#line 748
extern X509_CERT_AUX *d2i_X509_CERT_AUX(X509_CERT_AUX **a , unsigned char const   **in ,
                                        long len ) ;
#line 748
extern int i2d_X509_CERT_AUX(X509_CERT_AUX *a , unsigned char **out ) ;
#line 748
extern ASN1_ITEM *X509_CERT_AUX_it(void) ;
#line 752
int X509_set_ex_data(X509 *r , int idx , void *arg ) ;
#line 753
void *X509_get_ex_data(X509 *r , int idx ) ;
#line 754
extern X509 *d2i_X509_AUX(X509 **a , unsigned char const   **in , long len ) ;
#line 754
extern int i2d_X509_AUX(X509 *a , unsigned char **out ) ;
#line 756
int i2d_re_X509_tbs(X509 *x , unsigned char **pp ) ;
#line 758
int X509_SIG_INFO_get(X509_SIG_INFO *siginf , int *mdnid , int *pknid , int *secbits ,
                      uint32_t *flags ) ;
#line 760
void X509_SIG_INFO_set(X509_SIG_INFO *siginf , int mdnid , int pknid , int secbits ,
                       uint32_t flags ) ;
#line 763
int X509_get_signature_info(X509 *x , int *mdnid , int *pknid , int *secbits , uint32_t *flags ) ;
#line 766
void X509_get0_signature(ASN1_BIT_STRING **psig , X509_ALGOR **palg , X509 *x ) ;
#line 768
int X509_get_signature_nid(X509 *x ) ;
#line 770
void X509_set0_distinguishing_id(X509 *x , ASN1_OCTET_STRING *d_id ) ;
#line 771
ASN1_OCTET_STRING *X509_get0_distinguishing_id(X509 *x ) ;
#line 772
void X509_REQ_set0_distinguishing_id(X509_REQ *x , ASN1_OCTET_STRING *d_id ) ;
#line 773
ASN1_OCTET_STRING *X509_REQ_get0_distinguishing_id(X509_REQ *x ) ;
#line 775
int X509_alias_set1(X509 *x , unsigned char const   *name , int len ) ;
#line 776
int X509_keyid_set1(X509 *x , unsigned char const   *id , int len ) ;
#line 777
unsigned char *X509_alias_get0(X509 *x , int *len ) ;
#line 778
unsigned char *X509_keyid_get0(X509 *x , int *len ) ;
#line 780
extern X509_REVOKED *X509_REVOKED_new(void) ;
#line 780
extern void X509_REVOKED_free(X509_REVOKED *a ) ;
#line 780
extern X509_REVOKED *d2i_X509_REVOKED(X509_REVOKED **a , unsigned char const   **in ,
                                      long len ) ;
#line 780
extern int i2d_X509_REVOKED(X509_REVOKED *a , unsigned char **out ) ;
#line 780
extern ASN1_ITEM *X509_REVOKED_it(void) ;
#line 781
extern X509_CRL_INFO *X509_CRL_INFO_new(void) ;
#line 781
extern void X509_CRL_INFO_free(X509_CRL_INFO *a ) ;
#line 781
extern X509_CRL_INFO *d2i_X509_CRL_INFO(X509_CRL_INFO **a , unsigned char const   **in ,
                                        long len ) ;
#line 781
extern int i2d_X509_CRL_INFO(X509_CRL_INFO *a , unsigned char **out ) ;
#line 781
extern ASN1_ITEM *X509_CRL_INFO_it(void) ;
#line 782
extern X509_CRL *X509_CRL_new(void) ;
#line 782
extern void X509_CRL_free(X509_CRL *a ) ;
#line 782
extern X509_CRL *d2i_X509_CRL(X509_CRL **a , unsigned char const   **in , long len ) ;
#line 782
extern int i2d_X509_CRL(X509_CRL *a , unsigned char **out ) ;
#line 782
extern ASN1_ITEM *X509_CRL_it(void) ;
#line 783
X509_CRL *X509_CRL_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 785
int X509_CRL_add0_revoked(X509_CRL *crl , X509_REVOKED *rev ) ;
#line 786
int X509_CRL_get0_by_serial(X509_CRL *crl , X509_REVOKED **ret , ASN1_INTEGER *serial ) ;
#line 788
int X509_CRL_get0_by_cert(X509_CRL *crl , X509_REVOKED **ret , X509 *x ) ;
#line 790
X509_PKEY *X509_PKEY_new(void) ;
#line 791
void X509_PKEY_free(X509_PKEY *a ) ;
#line 793
extern NETSCAPE_SPKI *NETSCAPE_SPKI_new(void) ;
#line 793
extern void NETSCAPE_SPKI_free(NETSCAPE_SPKI *a ) ;
#line 793
extern NETSCAPE_SPKI *d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **a , unsigned char const   **in ,
                                        long len ) ;
#line 793
extern int i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a , unsigned char **out ) ;
#line 793
extern ASN1_ITEM *NETSCAPE_SPKI_it(void) ;
#line 794
extern NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void) ;
#line 794
extern void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a ) ;
#line 794
extern NETSCAPE_SPKAC *d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **a , unsigned char const   **in ,
                                          long len ) ;
#line 794
extern int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a , unsigned char **out ) ;
#line 794
extern ASN1_ITEM *NETSCAPE_SPKAC_it(void) ;
#line 795
extern NETSCAPE_CERT_SEQUENCE *NETSCAPE_CERT_SEQUENCE_new(void) ;
#line 795
extern void NETSCAPE_CERT_SEQUENCE_free(NETSCAPE_CERT_SEQUENCE *a ) ;
#line 795
extern NETSCAPE_CERT_SEQUENCE *d2i_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE **a ,
                                                          unsigned char const   **in ,
                                                          long len ) ;
#line 795
extern int i2d_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE *a , unsigned char **out ) ;
#line 795
extern ASN1_ITEM *NETSCAPE_CERT_SEQUENCE_it(void) ;
#line 797
X509_INFO *X509_INFO_new(void) ;
#line 798
void X509_INFO_free(X509_INFO *a ) ;
#line 799
char *X509_NAME_oneline(X509_NAME *a , char *buf , int size ) ;
#line 803
int ASN1_verify(i2d_of_void *i2d , X509_ALGOR *algor1 , ASN1_BIT_STRING *signature ,
                char *data , EVP_PKEY *pkey ) ;
#line 806
int ASN1_digest(i2d_of_void *i2d , EVP_MD *type , char *data , unsigned char *md ,
                unsigned int *len ) ;
#line 809
int ASN1_sign(i2d_of_void *i2d , X509_ALGOR *algor1 , X509_ALGOR *algor2 , ASN1_BIT_STRING *signature ,
              char *data , EVP_PKEY *pkey , EVP_MD *type ) ;
#line 813
int ASN1_item_digest(ASN1_ITEM *it , EVP_MD *type , void *data , unsigned char *md ,
                     unsigned int *len ) ;
#line 815
int ASN1_item_verify(ASN1_ITEM *it , X509_ALGOR *alg , ASN1_BIT_STRING *signature ,
                     void const   *data , EVP_PKEY *pkey ) ;
#line 818
int ASN1_item_verify_ctx(ASN1_ITEM *it , X509_ALGOR *alg , ASN1_BIT_STRING *signature ,
                         void const   *data , EVP_MD_CTX *ctx ) ;
#line 821
int ASN1_item_sign(ASN1_ITEM *it , X509_ALGOR *algor1 , X509_ALGOR *algor2 , ASN1_BIT_STRING *signature ,
                   void const   *data , EVP_PKEY *pkey , EVP_MD *md ) ;
#line 824
int ASN1_item_sign_ctx(ASN1_ITEM *it , X509_ALGOR *algor1 , X509_ALGOR *algor2 , ASN1_BIT_STRING *signature ,
                       void const   *data , EVP_MD_CTX *ctx ) ;
#line 832
long X509_get_version(X509 *x ) ;
#line 833
int X509_set_version(X509 *x , long version ) ;
#line 834
int X509_set_serialNumber(X509 *x , ASN1_INTEGER *serial ) ;
#line 835
ASN1_INTEGER *X509_get_serialNumber(X509 *x ) ;
#line 836
ASN1_INTEGER *X509_get0_serialNumber(X509 *x ) ;
#line 837
int X509_set_issuer_name(X509 *x , X509_NAME *name ) ;
#line 838
X509_NAME *X509_get_issuer_name(X509 *a ) ;
#line 839
int X509_set_subject_name(X509 *x , X509_NAME *name ) ;
#line 840
X509_NAME *X509_get_subject_name(X509 *a ) ;
#line 841
ASN1_TIME *X509_get0_notBefore(X509 *x ) ;
#line 842
ASN1_TIME *X509_getm_notBefore(X509 *x ) ;
#line 843
int X509_set1_notBefore(X509 *x , ASN1_TIME *tm ) ;
#line 844
ASN1_TIME *X509_get0_notAfter(X509 *x ) ;
#line 845
ASN1_TIME *X509_getm_notAfter(X509 *x ) ;
#line 846
int X509_set1_notAfter(X509 *x , ASN1_TIME *tm ) ;
#line 847
int X509_set_pubkey(X509 *x , EVP_PKEY *pkey ) ;
#line 848
int X509_up_ref(X509 *x ) ;
#line 849
int X509_get_signature_type(X509 *x ) ;
#line 863
X509_PUBKEY *X509_get_X509_PUBKEY(X509 *x ) ;
#line 864
struct stack_st_X509_EXTENSION *X509_get0_extensions(X509 *x ) ;
#line 865
void X509_get0_uids(X509 *x , ASN1_BIT_STRING **piuid , ASN1_BIT_STRING **psuid ) ;
#line 867
X509_ALGOR *X509_get0_tbs_sigalg(X509 *x ) ;
#line 869
EVP_PKEY *X509_get0_pubkey(X509 *x ) ;
#line 870
EVP_PKEY *X509_get_pubkey(X509 *x ) ;
#line 871
ASN1_BIT_STRING *X509_get0_pubkey_bitstr(X509 *x ) ;
#line 875
long X509_REQ_get_version(X509_REQ *req ) ;
#line 876
int X509_REQ_set_version(X509_REQ *x , long version ) ;
#line 877
X509_NAME *X509_REQ_get_subject_name(X509_REQ *req ) ;
#line 878
int X509_REQ_set_subject_name(X509_REQ *req , X509_NAME *name ) ;
#line 879
void X509_REQ_get0_signature(X509_REQ *req , ASN1_BIT_STRING **psig , X509_ALGOR **palg ) ;
#line 881
void X509_REQ_set0_signature(X509_REQ *req , ASN1_BIT_STRING *psig ) ;
#line 882
int X509_REQ_set1_signature_algo(X509_REQ *req , X509_ALGOR *palg ) ;
#line 883
int X509_REQ_get_signature_nid(X509_REQ *req ) ;
#line 884
int i2d_re_X509_REQ_tbs(X509_REQ *req , unsigned char **pp ) ;
#line 885
int X509_REQ_set_pubkey(X509_REQ *x , EVP_PKEY *pkey ) ;
#line 886
EVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req ) ;
#line 887
EVP_PKEY *X509_REQ_get0_pubkey(X509_REQ *req ) ;
#line 888
X509_PUBKEY *X509_REQ_get_X509_PUBKEY(X509_REQ *req ) ;
#line 889
int X509_REQ_extension_nid(int nid ) ;
#line 890
int *X509_REQ_get_extension_nids(void) ;
#line 891
void X509_REQ_set_extension_nids(int *nids ) ;
#line 892
struct stack_st_X509_EXTENSION *X509_REQ_get_extensions(X509_REQ *req ) ;
#line 893
int X509_REQ_add_extensions_nid(X509_REQ *req , struct stack_st_X509_EXTENSION *exts ,
                                int nid ) ;
#line 895
int X509_REQ_add_extensions(X509_REQ *req , struct stack_st_X509_EXTENSION *ext ) ;
#line 896
int X509_REQ_get_attr_count(X509_REQ *req ) ;
#line 897
int X509_REQ_get_attr_by_NID(X509_REQ *req , int nid , int lastpos ) ;
#line 898
int X509_REQ_get_attr_by_OBJ(X509_REQ *req , ASN1_OBJECT *obj , int lastpos ) ;
#line 900
X509_ATTRIBUTE *X509_REQ_get_attr(X509_REQ *req , int loc ) ;
#line 901
X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req , int loc ) ;
#line 902
int X509_REQ_add1_attr(X509_REQ *req , X509_ATTRIBUTE *attr ) ;
#line 903
int X509_REQ_add1_attr_by_OBJ(X509_REQ *req , ASN1_OBJECT *obj , int type , unsigned char const   *bytes ,
                              int len ) ;
#line 906
int X509_REQ_add1_attr_by_NID(X509_REQ *req , int nid , int type , unsigned char const   *bytes ,
                              int len ) ;
#line 909
int X509_REQ_add1_attr_by_txt(X509_REQ *req , char const   *attrname , int type ,
                              unsigned char const   *bytes , int len ) ;
#line 916
int X509_CRL_set_version(X509_CRL *x , long version ) ;
#line 917
int X509_CRL_set_issuer_name(X509_CRL *x , X509_NAME *name ) ;
#line 918
int X509_CRL_set1_lastUpdate(X509_CRL *x , ASN1_TIME *tm ) ;
#line 919
int X509_CRL_set1_nextUpdate(X509_CRL *x , ASN1_TIME *tm ) ;
#line 920
int X509_CRL_sort(X509_CRL *crl ) ;
#line 921
int X509_CRL_up_ref(X509_CRL *crl ) ;
#line 928
long X509_CRL_get_version(X509_CRL *crl ) ;
#line 929
ASN1_TIME *X509_CRL_get0_lastUpdate(X509_CRL *crl ) ;
#line 930
ASN1_TIME *X509_CRL_get0_nextUpdate(X509_CRL *crl ) ;
#line 932
ASN1_TIME *X509_CRL_get_lastUpdate(X509_CRL *crl ) ;
#line 933
ASN1_TIME *X509_CRL_get_nextUpdate(X509_CRL *crl ) ;
#line 935
X509_NAME *X509_CRL_get_issuer(X509_CRL *crl ) ;
#line 936
struct stack_st_X509_EXTENSION *X509_CRL_get0_extensions(X509_CRL *crl ) ;
#line 937
struct stack_st_X509_REVOKED *X509_CRL_get_REVOKED(X509_CRL *crl ) ;
#line 938
void X509_CRL_get0_signature(X509_CRL *crl , ASN1_BIT_STRING **psig , X509_ALGOR **palg ) ;
#line 940
int X509_CRL_get_signature_nid(X509_CRL *crl ) ;
#line 941
int i2d_re_X509_CRL_tbs(X509_CRL *req , unsigned char **pp ) ;
#line 943
ASN1_INTEGER *X509_REVOKED_get0_serialNumber(X509_REVOKED *x ) ;
#line 944
int X509_REVOKED_set_serialNumber(X509_REVOKED *x , ASN1_INTEGER *serial ) ;
#line 945
ASN1_TIME *X509_REVOKED_get0_revocationDate(X509_REVOKED *x ) ;
#line 946
int X509_REVOKED_set_revocationDate(X509_REVOKED *r , ASN1_TIME *tm ) ;
#line 948
struct stack_st_X509_EXTENSION *X509_REVOKED_get0_extensions(X509_REVOKED *r ) ;
#line 950
X509_CRL *X509_CRL_diff(X509_CRL *base , X509_CRL *newer , EVP_PKEY *skey , EVP_MD *md ,
                        unsigned int flags ) ;
#line 953
int X509_REQ_check_private_key(X509_REQ *x509 , EVP_PKEY *pkey ) ;
#line 955
int X509_check_private_key(X509 *x509 , EVP_PKEY *pkey ) ;
#line 956
int X509_chain_check_suiteb(int *perror_depth , X509 *x , struct stack_st_X509 *chain ,
                            unsigned long flags ) ;
#line 959
int X509_CRL_check_suiteb(X509_CRL *crl , EVP_PKEY *pk , unsigned long flags ) ;
#line 960
struct stack_st_X509 *X509_chain_up_ref(struct stack_st_X509 *chain ) ;
#line 962
int X509_issuer_and_serial_cmp(X509 *a , X509 *b ) ;
#line 963
unsigned long X509_issuer_and_serial_hash(X509 *a ) ;
#line 965
int X509_issuer_name_cmp(X509 *a , X509 *b ) ;
#line 966
unsigned long X509_issuer_name_hash(X509 *a ) ;
#line 968
int X509_subject_name_cmp(X509 *a , X509 *b ) ;
#line 969
unsigned long X509_subject_name_hash(X509 *x ) ;
#line 972
unsigned long X509_issuer_name_hash_old(X509 *a ) ;
#line 973
unsigned long X509_subject_name_hash_old(X509 *x ) ;
#line 981
int X509_add_cert(struct stack_st_X509 *sk , X509 *cert , int flags ) ;
#line 982
int X509_add_certs(struct stack_st_X509 *sk , struct stack_st_X509 *certs , int flags ) ;
#line 984
int X509_cmp(X509 *a , X509 *b ) ;
#line 985
int X509_NAME_cmp(X509_NAME *a , X509_NAME *b ) ;
#line 988
int X509_certificate_type(X509 *x , EVP_PKEY *pubkey ) ;
#line 991
unsigned long X509_NAME_hash_ex(X509_NAME *x , OSSL_LIB_CTX *libctx , char const   *propq ,
                                int *ok ) ;
#line 993
unsigned long X509_NAME_hash_old(X509_NAME *x ) ;
#line 995
int X509_CRL_cmp(X509_CRL *a , X509_CRL *b ) ;
#line 996
int X509_CRL_match(X509_CRL *a , X509_CRL *b ) ;
#line 997
int X509_aux_print(BIO *out , X509 *x , int indent ) ;
#line 999
int X509_print_ex_fp(FILE *bp , X509 *x , unsigned long nmflag , unsigned long cflag ) ;
#line 1001
int X509_print_fp(FILE *bp , X509 *x ) ;
#line 1002
int X509_CRL_print_fp(FILE *bp , X509_CRL *x ) ;
#line 1003
int X509_REQ_print_fp(FILE *bp , X509_REQ *req ) ;
#line 1004
int X509_NAME_print_ex_fp(FILE *fp , X509_NAME *nm , int indent , unsigned long flags ) ;
#line 1008
int X509_NAME_print(BIO *bp , X509_NAME *name , int obase ) ;
#line 1009
int X509_NAME_print_ex(BIO *out , X509_NAME *nm , int indent , unsigned long flags ) ;
#line 1011
int X509_print_ex(BIO *bp , X509 *x , unsigned long nmflag , unsigned long cflag ) ;
#line 1013
int X509_print(BIO *bp , X509 *x ) ;
#line 1014
int X509_ocspid_print(BIO *bp , X509 *x ) ;
#line 1015
int X509_CRL_print_ex(BIO *out , X509_CRL *x , unsigned long nmflag ) ;
#line 1016
int X509_CRL_print(BIO *bp , X509_CRL *x ) ;
#line 1017
int X509_REQ_print_ex(BIO *bp , X509_REQ *x , unsigned long nmflag , unsigned long cflag ) ;
#line 1019
int X509_REQ_print(BIO *bp , X509_REQ *req ) ;
#line 1021
int X509_NAME_entry_count(X509_NAME *name ) ;
#line 1022
int X509_NAME_get_text_by_NID(X509_NAME *name , int nid , char *buf , int len ) ;
#line 1024
int X509_NAME_get_text_by_OBJ(X509_NAME *name , ASN1_OBJECT *obj , char *buf , int len ) ;
#line 1031
int X509_NAME_get_index_by_NID(X509_NAME *name , int nid , int lastpos ) ;
#line 1032
int X509_NAME_get_index_by_OBJ(X509_NAME *name , ASN1_OBJECT *obj , int lastpos ) ;
#line 1034
X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name , int loc ) ;
#line 1035
X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name , int loc ) ;
#line 1036
int X509_NAME_add_entry(X509_NAME *name , X509_NAME_ENTRY *ne , int loc , int set ) ;
#line 1038
int X509_NAME_add_entry_by_OBJ(X509_NAME *name , ASN1_OBJECT *obj , int type , unsigned char const   *bytes ,
                               int len , int loc , int set ) ;
#line 1041
int X509_NAME_add_entry_by_NID(X509_NAME *name , int nid , int type , unsigned char const   *bytes ,
                               int len , int loc , int set ) ;
#line 1044
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne , char const   *field ,
                                               int type , unsigned char const   *bytes ,
                                               int len ) ;
#line 1048
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne , int nid , int type ,
                                               unsigned char const   *bytes , int len ) ;
#line 1052
int X509_NAME_add_entry_by_txt(X509_NAME *name , char const   *field , int type ,
                               unsigned char const   *bytes , int len , int loc ,
                               int set ) ;
#line 1055
X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne , ASN1_OBJECT *obj ,
                                               int type , unsigned char const   *bytes ,
                                               int len ) ;
#line 1059
int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne , ASN1_OBJECT *obj ) ;
#line 1060
int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne , int type , unsigned char const   *bytes ,
                             int len ) ;
#line 1062
ASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne ) ;
#line 1063
ASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne ) ;
#line 1064
int X509_NAME_ENTRY_set(X509_NAME_ENTRY *ne ) ;
#line 1066
int X509_NAME_get0_der(X509_NAME *nm , unsigned char const   **pder , size_t *pderlen ) ;
#line 1069
int X509v3_get_ext_count(struct stack_st_X509_EXTENSION *x ) ;
#line 1070
int X509v3_get_ext_by_NID(struct stack_st_X509_EXTENSION *x , int nid , int lastpos ) ;
#line 1072
int X509v3_get_ext_by_OBJ(struct stack_st_X509_EXTENSION *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 1074
int X509v3_get_ext_by_critical(struct stack_st_X509_EXTENSION *x , int crit , int lastpos ) ;
#line 1076
X509_EXTENSION *X509v3_get_ext(struct stack_st_X509_EXTENSION *x , int loc ) ;
#line 1077
X509_EXTENSION *X509v3_delete_ext(struct stack_st_X509_EXTENSION *x , int loc ) ;
#line 1078
struct stack_st_X509_EXTENSION *X509v3_add_ext(struct stack_st_X509_EXTENSION **x ,
                                               X509_EXTENSION *ex , int loc ) ;
#line 1081
int X509_get_ext_count(X509 *x ) ;
#line 1082
int X509_get_ext_by_NID(X509 *x , int nid , int lastpos ) ;
#line 1083
int X509_get_ext_by_OBJ(X509 *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 1084
int X509_get_ext_by_critical(X509 *x , int crit , int lastpos ) ;
#line 1085
X509_EXTENSION *X509_get_ext(X509 *x , int loc ) ;
#line 1086
X509_EXTENSION *X509_delete_ext(X509 *x , int loc ) ;
#line 1087
int X509_add_ext(X509 *x , X509_EXTENSION *ex , int loc ) ;
#line 1088
void *X509_get_ext_d2i(X509 *x , int nid , int *crit , int *idx ) ;
#line 1089
int X509_add1_ext_i2d(X509 *x , int nid , void *value , int crit , unsigned long flags ) ;
#line 1092
int X509_CRL_get_ext_count(X509_CRL *x ) ;
#line 1093
int X509_CRL_get_ext_by_NID(X509_CRL *x , int nid , int lastpos ) ;
#line 1094
int X509_CRL_get_ext_by_OBJ(X509_CRL *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 1096
int X509_CRL_get_ext_by_critical(X509_CRL *x , int crit , int lastpos ) ;
#line 1097
X509_EXTENSION *X509_CRL_get_ext(X509_CRL *x , int loc ) ;
#line 1098
X509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x , int loc ) ;
#line 1099
int X509_CRL_add_ext(X509_CRL *x , X509_EXTENSION *ex , int loc ) ;
#line 1100
void *X509_CRL_get_ext_d2i(X509_CRL *x , int nid , int *crit , int *idx ) ;
#line 1101
int X509_CRL_add1_ext_i2d(X509_CRL *x , int nid , void *value , int crit , unsigned long flags ) ;
#line 1104
int X509_REVOKED_get_ext_count(X509_REVOKED *x ) ;
#line 1105
int X509_REVOKED_get_ext_by_NID(X509_REVOKED *x , int nid , int lastpos ) ;
#line 1106
int X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x , ASN1_OBJECT *obj , int lastpos ) ;
#line 1108
int X509_REVOKED_get_ext_by_critical(X509_REVOKED *x , int crit , int lastpos ) ;
#line 1110
X509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x , int loc ) ;
#line 1111
X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x , int loc ) ;
#line 1112
int X509_REVOKED_add_ext(X509_REVOKED *x , X509_EXTENSION *ex , int loc ) ;
#line 1113
void *X509_REVOKED_get_ext_d2i(X509_REVOKED *x , int nid , int *crit , int *idx ) ;
#line 1115
int X509_REVOKED_add1_ext_i2d(X509_REVOKED *x , int nid , void *value , int crit ,
                              unsigned long flags ) ;
#line 1118
X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex , int nid , int crit ,
                                             ASN1_OCTET_STRING *data ) ;
#line 1121
X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex , ASN1_OBJECT *obj ,
                                             int crit , ASN1_OCTET_STRING *data ) ;
#line 1124
int X509_EXTENSION_set_object(X509_EXTENSION *ex , ASN1_OBJECT *obj ) ;
#line 1125
int X509_EXTENSION_set_critical(X509_EXTENSION *ex , int crit ) ;
#line 1126
int X509_EXTENSION_set_data(X509_EXTENSION *ex , ASN1_OCTET_STRING *data ) ;
#line 1127
ASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex ) ;
#line 1128
ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ne ) ;
#line 1129
int X509_EXTENSION_get_critical(X509_EXTENSION *ex ) ;
#line 1131
int X509at_get_attr_count(struct stack_st_X509_ATTRIBUTE *x ) ;
#line 1132
int X509at_get_attr_by_NID(struct stack_st_X509_ATTRIBUTE *x , int nid , int lastpos ) ;
#line 1134
int X509at_get_attr_by_OBJ(struct stack_st_X509_ATTRIBUTE *sk , ASN1_OBJECT *obj ,
                           int lastpos ) ;
#line 1136
X509_ATTRIBUTE *X509at_get_attr(struct stack_st_X509_ATTRIBUTE *x , int loc ) ;
#line 1137
X509_ATTRIBUTE *X509at_delete_attr(struct stack_st_X509_ATTRIBUTE *x , int loc ) ;
#line 1138
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr(struct stack_st_X509_ATTRIBUTE **x ,
                                                 X509_ATTRIBUTE *attr ) ;
#line 1140
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_OBJ(struct stack_st_X509_ATTRIBUTE **x ,
                                                        ASN1_OBJECT *obj , int type ,
                                                        unsigned char const   *bytes ,
                                                        int len ) ;
#line 1145
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_NID(struct stack_st_X509_ATTRIBUTE **x ,
                                                        int nid , int type , unsigned char const   *bytes ,
                                                        int len ) ;
#line 1149
struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_txt(struct stack_st_X509_ATTRIBUTE **x ,
                                                        char const   *attrname , int type ,
                                                        unsigned char const   *bytes ,
                                                        int len ) ;
#line 1154
void *X509at_get0_data_by_OBJ(struct stack_st_X509_ATTRIBUTE *x , ASN1_OBJECT *obj ,
                              int lastpos , int type ) ;
#line 1156
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr , int nid , int atrtype ,
                                             void const   *data , int len ) ;
#line 1159
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr , ASN1_OBJECT *obj ,
                                             int atrtype , void const   *data , int len ) ;
#line 1163
X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr , char const   *atrname ,
                                             int type , unsigned char const   *bytes ,
                                             int len ) ;
#line 1167
int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr , ASN1_OBJECT *obj ) ;
#line 1168
int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr , int attrtype , void const   *data ,
                             int len ) ;
#line 1170
void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr , int idx , int atrtype , void *data ) ;
#line 1172
int X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr ) ;
#line 1173
ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr ) ;
#line 1174
ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr , int idx ) ;
#line 1176
int EVP_PKEY_get_attr_count(EVP_PKEY *key ) ;
#line 1177
int EVP_PKEY_get_attr_by_NID(EVP_PKEY *key , int nid , int lastpos ) ;
#line 1178
int EVP_PKEY_get_attr_by_OBJ(EVP_PKEY *key , ASN1_OBJECT *obj , int lastpos ) ;
#line 1180
X509_ATTRIBUTE *EVP_PKEY_get_attr(EVP_PKEY *key , int loc ) ;
#line 1181
X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key , int loc ) ;
#line 1182
int EVP_PKEY_add1_attr(EVP_PKEY *key , X509_ATTRIBUTE *attr ) ;
#line 1183
int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key , ASN1_OBJECT *obj , int type , unsigned char const   *bytes ,
                              int len ) ;
#line 1186
int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key , int nid , int type , unsigned char const   *bytes ,
                              int len ) ;
#line 1189
int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key , char const   *attrname , int type ,
                              unsigned char const   *bytes , int len ) ;
#line 1194
X509 *X509_find_by_issuer_and_serial(struct stack_st_X509 *sk , X509_NAME *name ,
                                     ASN1_INTEGER *serial ) ;
#line 1196
X509 *X509_find_by_subject(struct stack_st_X509 *sk , X509_NAME *name ) ;
#line 1198
extern PBEPARAM *PBEPARAM_new(void) ;
#line 1198
extern void PBEPARAM_free(PBEPARAM *a ) ;
#line 1198
extern PBEPARAM *d2i_PBEPARAM(PBEPARAM **a , unsigned char const   **in , long len ) ;
#line 1198
extern int i2d_PBEPARAM(PBEPARAM *a , unsigned char **out ) ;
#line 1198
extern ASN1_ITEM *PBEPARAM_it(void) ;
#line 1199
extern PBE2PARAM *PBE2PARAM_new(void) ;
#line 1199
extern void PBE2PARAM_free(PBE2PARAM *a ) ;
#line 1199
extern PBE2PARAM *d2i_PBE2PARAM(PBE2PARAM **a , unsigned char const   **in , long len ) ;
#line 1199
extern int i2d_PBE2PARAM(PBE2PARAM *a , unsigned char **out ) ;
#line 1199
extern ASN1_ITEM *PBE2PARAM_it(void) ;
#line 1200
extern PBKDF2PARAM *PBKDF2PARAM_new(void) ;
#line 1200
extern void PBKDF2PARAM_free(PBKDF2PARAM *a ) ;
#line 1200
extern PBKDF2PARAM *d2i_PBKDF2PARAM(PBKDF2PARAM **a , unsigned char const   **in ,
                                    long len ) ;
#line 1200
extern int i2d_PBKDF2PARAM(PBKDF2PARAM *a , unsigned char **out ) ;
#line 1200
extern ASN1_ITEM *PBKDF2PARAM_it(void) ;
#line 1202
extern SCRYPT_PARAMS *SCRYPT_PARAMS_new(void) ;
#line 1202
extern void SCRYPT_PARAMS_free(SCRYPT_PARAMS *a ) ;
#line 1202
extern SCRYPT_PARAMS *d2i_SCRYPT_PARAMS(SCRYPT_PARAMS **a , unsigned char const   **in ,
                                        long len ) ;
#line 1202
extern int i2d_SCRYPT_PARAMS(SCRYPT_PARAMS *a , unsigned char **out ) ;
#line 1202
extern ASN1_ITEM *SCRYPT_PARAMS_it(void) ;
#line 1205
int PKCS5_pbe_set0_algor(X509_ALGOR *algor , int alg , int iter , unsigned char const   *salt ,
                         int saltlen ) ;
#line 1207
int PKCS5_pbe_set0_algor_ex(X509_ALGOR *algor , int alg , int iter , unsigned char const   *salt ,
                            int saltlen , OSSL_LIB_CTX *libctx ) ;
#line 1211
X509_ALGOR *PKCS5_pbe_set(int alg , int iter , unsigned char const   *salt , int saltlen ) ;
#line 1213
X509_ALGOR *PKCS5_pbe_set_ex(int alg , int iter , unsigned char const   *salt , int saltlen ,
                             OSSL_LIB_CTX *libctx ) ;
#line 1217
X509_ALGOR *PKCS5_pbe2_set(EVP_CIPHER *cipher , int iter , unsigned char *salt , int saltlen ) ;
#line 1219
X509_ALGOR *PKCS5_pbe2_set_iv(EVP_CIPHER *cipher , int iter , unsigned char *salt ,
                              int saltlen , unsigned char *aiv , int prf_nid ) ;
#line 1222
X509_ALGOR *PKCS5_pbe2_set_iv_ex(EVP_CIPHER *cipher , int iter , unsigned char *salt ,
                                 int saltlen , unsigned char *aiv , int prf_nid ,
                                 OSSL_LIB_CTX *libctx ) ;
#line 1228
X509_ALGOR *PKCS5_pbe2_set_scrypt(EVP_CIPHER *cipher , unsigned char const   *salt ,
                                  int saltlen , unsigned char *aiv , uint64_t N ,
                                  uint64_t r , uint64_t p ) ;
#line 1234
X509_ALGOR *PKCS5_pbkdf2_set(int iter , unsigned char *salt , int saltlen , int prf_nid ,
                             int keylen ) ;
#line 1236
X509_ALGOR *PKCS5_pbkdf2_set_ex(int iter , unsigned char *salt , int saltlen , int prf_nid ,
                                int keylen , OSSL_LIB_CTX *libctx ) ;
#line 1242
extern PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void) ;
#line 1242
extern void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a ) ;
#line 1242
extern PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a , unsigned char const   **in ,
                                                    long len ) ;
#line 1242
extern int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a , unsigned char **out ) ;
#line 1242
extern ASN1_ITEM *PKCS8_PRIV_KEY_INFO_it(void) ;
#line 1244
EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8 ) ;
#line 1245
EVP_PKEY *EVP_PKCS82PKEY_ex(PKCS8_PRIV_KEY_INFO *p8 , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 1247
PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey ) ;
#line 1249
int PKCS8_pkey_set0(PKCS8_PRIV_KEY_INFO *priv , ASN1_OBJECT *aobj , int version ,
                    int ptype , void *pval , unsigned char *penc , int penclen ) ;
#line 1252
int PKCS8_pkey_get0(ASN1_OBJECT **ppkalg , unsigned char const   **pk , int *ppklen ,
                    X509_ALGOR **pa , PKCS8_PRIV_KEY_INFO *p8 ) ;
#line 1257
struct stack_st_X509_ATTRIBUTE *PKCS8_pkey_get0_attrs(PKCS8_PRIV_KEY_INFO *p8 ) ;
#line 1258
int PKCS8_pkey_add1_attr(PKCS8_PRIV_KEY_INFO *p8 , X509_ATTRIBUTE *attr ) ;
#line 1259
int PKCS8_pkey_add1_attr_by_NID(PKCS8_PRIV_KEY_INFO *p8 , int nid , int type , unsigned char const   *bytes ,
                                int len ) ;
#line 1261
int PKCS8_pkey_add1_attr_by_OBJ(PKCS8_PRIV_KEY_INFO *p8 , ASN1_OBJECT *obj , int type ,
                                unsigned char const   *bytes , int len ) ;
#line 1265
int X509_PUBKEY_set0_param(X509_PUBKEY *pub , ASN1_OBJECT *aobj , int ptype , void *pval ,
                           unsigned char *penc , int penclen ) ;
#line 1268
int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg , unsigned char const   **pk , int *ppklen ,
                           X509_ALGOR **pa , X509_PUBKEY *pub ) ;
#line 1271
int X509_PUBKEY_eq(X509_PUBKEY *a , X509_PUBKEY *b ) ;
#line 369 "/usr/include/openssl/pem.h"
int PEM_get_EVP_CIPHER_INFO(char *header , EVP_CIPHER_INFO *cipher ) ;
#line 370
int PEM_do_header(EVP_CIPHER_INFO *cipher , unsigned char *data , long *len , pem_password_cb *callback ,
                  void *u ) ;
#line 373
int PEM_read_bio(BIO *bp , char **name , char **header , unsigned char **data , long *len ) ;
#line 378
int PEM_read_bio_ex(BIO *bp , char **name , char **header , unsigned char **data ,
                    long *len , unsigned int flags ) ;
#line 380
int PEM_bytes_read_bio_secmem(unsigned char **pdata , long *plen , char **pnm , char const   *name ,
                              BIO *bp , pem_password_cb *cb , void *u ) ;
#line 383
int PEM_write_bio(BIO *bp , char const   *name , char const   *hdr , unsigned char const   *data ,
                  long len ) ;
#line 385
int PEM_bytes_read_bio(unsigned char **pdata , long *plen , char **pnm , char const   *name ,
                       BIO *bp , pem_password_cb *cb , void *u ) ;
#line 388
void *PEM_ASN1_read_bio(d2i_of_void *d2i , char const   *name , BIO *bp , void **x ,
                        pem_password_cb *cb , void *u ) ;
#line 390
int PEM_ASN1_write_bio(i2d_of_void *i2d , char const   *name , BIO *bp , void const   *x ,
                       EVP_CIPHER *enc , unsigned char const   *kstr , int klen ,
                       pem_password_cb *cb , void *u ) ;
#line 395
struct stack_st_X509_INFO *PEM_X509_INFO_read_bio(BIO *bp , struct stack_st_X509_INFO *sk ,
                                                  pem_password_cb *cb , void *u ) ;
#line 398
struct stack_st_X509_INFO *PEM_X509_INFO_read_bio_ex(BIO *bp , struct stack_st_X509_INFO *sk ,
                                                     pem_password_cb *cb , void *u ,
                                                     OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 402
int PEM_X509_INFO_write_bio(BIO *bp , X509_INFO *xi , EVP_CIPHER *enc , unsigned char const   *kstr ,
                            int klen , pem_password_cb *cd , void *u ) ;
#line 407
int PEM_read(FILE *fp , char **name , char **header , unsigned char **data , long *len ) ;
#line 409
int PEM_write(FILE *fp , char const   *name , char const   *hdr , unsigned char const   *data ,
              long len ) ;
#line 411
void *PEM_ASN1_read(d2i_of_void *d2i , char const   *name , FILE *fp , void **x ,
                    pem_password_cb *cb , void *u ) ;
#line 413
int PEM_ASN1_write(i2d_of_void *i2d , char const   *name , FILE *fp , void const   *x ,
                   EVP_CIPHER *enc , unsigned char const   *kstr , int klen , pem_password_cb *callback ,
                   void *u ) ;
#line 417
struct stack_st_X509_INFO *PEM_X509_INFO_read(FILE *fp , struct stack_st_X509_INFO *sk ,
                                              pem_password_cb *cb , void *u ) ;
#line 420
struct stack_st_X509_INFO *PEM_X509_INFO_read_ex(FILE *fp , struct stack_st_X509_INFO *sk ,
                                                 pem_password_cb *cb , void *u , OSSL_LIB_CTX *libctx ,
                                                 char const   *propq ) ;
#line 424
int PEM_SignInit(EVP_MD_CTX *ctx , EVP_MD *type ) ;
#line 425
int PEM_SignUpdate(EVP_MD_CTX *ctx , unsigned char const   *d , unsigned int cnt ) ;
#line 426
int PEM_SignFinal(EVP_MD_CTX *ctx , unsigned char *sigret , unsigned int *siglen ,
                  EVP_PKEY *pkey ) ;
#line 430
int PEM_def_callback(char *buf , int num , int rwflag , void *userdata ) ;
#line 431
void PEM_proc_type(char *buf , int type ) ;
#line 432
void PEM_dek_info(char *buf , char const   *type , int len , char const   *str ) ;
#line 436
extern X509 *PEM_read_bio_X509(BIO *out , X509 **x , pem_password_cb *cb , void *u ) ;
#line 436
extern X509 *PEM_read_X509(FILE *out , X509 **x , pem_password_cb *cb , void *u ) ;
#line 436
extern int PEM_write_bio_X509(BIO *out , X509 *x ) ;
#line 436
extern int PEM_write_X509(FILE *out , X509 *x ) ;
#line 437
extern X509 *PEM_read_bio_X509_AUX(BIO *out , X509 **x , pem_password_cb *cb , void *u ) ;
#line 437
extern X509 *PEM_read_X509_AUX(FILE *out , X509 **x , pem_password_cb *cb , void *u ) ;
#line 437
extern int PEM_write_bio_X509_AUX(BIO *out , X509 *x ) ;
#line 437
extern int PEM_write_X509_AUX(FILE *out , X509 *x ) ;
#line 438
extern X509_REQ *PEM_read_bio_X509_REQ(BIO *out , X509_REQ **x , pem_password_cb *cb ,
                                       void *u ) ;
#line 438
extern X509_REQ *PEM_read_X509_REQ(FILE *out , X509_REQ **x , pem_password_cb *cb ,
                                   void *u ) ;
#line 438
extern int PEM_write_bio_X509_REQ(BIO *out , X509_REQ *x ) ;
#line 438
extern int PEM_write_X509_REQ(FILE *out , X509_REQ *x ) ;
#line 439
extern int PEM_write_bio_X509_REQ_NEW(BIO *out , X509_REQ *x ) ;
#line 439
extern int PEM_write_X509_REQ_NEW(FILE *out , X509_REQ *x ) ;
#line 440
extern X509_CRL *PEM_read_bio_X509_CRL(BIO *out , X509_CRL **x , pem_password_cb *cb ,
                                       void *u ) ;
#line 440
extern X509_CRL *PEM_read_X509_CRL(FILE *out , X509_CRL **x , pem_password_cb *cb ,
                                   void *u ) ;
#line 440
extern int PEM_write_bio_X509_CRL(BIO *out , X509_CRL *x ) ;
#line 440
extern int PEM_write_X509_CRL(FILE *out , X509_CRL *x ) ;
#line 441
extern X509_PUBKEY *PEM_read_bio_X509_PUBKEY(BIO *out , X509_PUBKEY **x , pem_password_cb *cb ,
                                             void *u ) ;
#line 441
extern X509_PUBKEY *PEM_read_X509_PUBKEY(FILE *out , X509_PUBKEY **x , pem_password_cb *cb ,
                                         void *u ) ;
#line 441
extern int PEM_write_bio_X509_PUBKEY(BIO *out , X509_PUBKEY *x ) ;
#line 441
extern int PEM_write_X509_PUBKEY(FILE *out , X509_PUBKEY *x ) ;
#line 442
extern PKCS7 *PEM_read_bio_PKCS7(BIO *out , PKCS7 **x , pem_password_cb *cb , void *u ) ;
#line 442
extern PKCS7 *PEM_read_PKCS7(FILE *out , PKCS7 **x , pem_password_cb *cb , void *u ) ;
#line 442
extern int PEM_write_bio_PKCS7(BIO *out , PKCS7 *x ) ;
#line 442
extern int PEM_write_PKCS7(FILE *out , PKCS7 *x ) ;
#line 443
extern NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *out , NETSCAPE_CERT_SEQUENCE **x ,
                                                                   pem_password_cb *cb ,
                                                                   void *u ) ;
#line 443
extern NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *out , NETSCAPE_CERT_SEQUENCE **x ,
                                                               pem_password_cb *cb ,
                                                               void *u ) ;
#line 443
extern int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *out , NETSCAPE_CERT_SEQUENCE *x ) ;
#line 443
extern int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *out , NETSCAPE_CERT_SEQUENCE *x ) ;
#line 444
extern X509_SIG *PEM_read_bio_PKCS8(BIO *out , X509_SIG **x , pem_password_cb *cb ,
                                    void *u ) ;
#line 444
extern X509_SIG *PEM_read_PKCS8(FILE *out , X509_SIG **x , pem_password_cb *cb , void *u ) ;
#line 444
extern int PEM_write_bio_PKCS8(BIO *out , X509_SIG *x ) ;
#line 444
extern int PEM_write_PKCS8(FILE *out , X509_SIG *x ) ;
#line 445
extern PKCS8_PRIV_KEY_INFO *PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *out , PKCS8_PRIV_KEY_INFO **x ,
                                                             pem_password_cb *cb ,
                                                             void *u ) ;
#line 445
extern PKCS8_PRIV_KEY_INFO *PEM_read_PKCS8_PRIV_KEY_INFO(FILE *out , PKCS8_PRIV_KEY_INFO **x ,
                                                         pem_password_cb *cb , void *u ) ;
#line 445
extern int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *out , PKCS8_PRIV_KEY_INFO *x ) ;
#line 445
extern int PEM_write_PKCS8_PRIV_KEY_INFO(FILE *out , PKCS8_PRIV_KEY_INFO *x ) ;
#line 447
RSA *PEM_read_bio_RSAPrivateKey(BIO *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 447
RSA *PEM_read_RSAPrivateKey(FILE *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 447
int PEM_write_bio_RSAPrivateKey(BIO *out , RSA *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                                int klen , pem_password_cb *cb , void *u ) ;
#line 447
int PEM_write_RSAPrivateKey(FILE *out , RSA *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                            int klen , pem_password_cb *cb , void *u ) ;
#line 448
RSA *PEM_read_bio_RSAPublicKey(BIO *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 448
RSA *PEM_read_RSAPublicKey(FILE *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 448
int PEM_write_bio_RSAPublicKey(BIO *out , RSA *x ) ;
#line 448
int PEM_write_RSAPublicKey(FILE *out , RSA *x ) ;
#line 449
RSA *PEM_read_bio_RSA_PUBKEY(BIO *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 449
RSA *PEM_read_RSA_PUBKEY(FILE *out , RSA **x , pem_password_cb *cb , void *u ) ;
#line 449
int PEM_write_bio_RSA_PUBKEY(BIO *out , RSA *x ) ;
#line 449
int PEM_write_RSA_PUBKEY(FILE *out , RSA *x ) ;
#line 453
DSA *PEM_read_bio_DSAPrivateKey(BIO *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 453
DSA *PEM_read_DSAPrivateKey(FILE *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 453
int PEM_write_bio_DSAPrivateKey(BIO *out , DSA *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                                int klen , pem_password_cb *cb , void *u ) ;
#line 453
int PEM_write_DSAPrivateKey(FILE *out , DSA *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                            int klen , pem_password_cb *cb , void *u ) ;
#line 454
DSA *PEM_read_bio_DSA_PUBKEY(BIO *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 454
DSA *PEM_read_DSA_PUBKEY(FILE *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 454
int PEM_write_bio_DSA_PUBKEY(BIO *out , DSA *x ) ;
#line 454
int PEM_write_DSA_PUBKEY(FILE *out , DSA *x ) ;
#line 455
DSA *PEM_read_bio_DSAparams(BIO *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 455
DSA *PEM_read_DSAparams(FILE *out , DSA **x , pem_password_cb *cb , void *u ) ;
#line 455
int PEM_write_bio_DSAparams(BIO *out , DSA *x ) ;
#line 455
int PEM_write_DSAparams(FILE *out , DSA *x ) ;
#line 461
EC_GROUP *PEM_read_bio_ECPKParameters(BIO *out , EC_GROUP **x , pem_password_cb *cb ,
                                      void *u ) ;
#line 461
EC_GROUP *PEM_read_ECPKParameters(FILE *out , EC_GROUP **x , pem_password_cb *cb ,
                                  void *u ) ;
#line 461
int PEM_write_bio_ECPKParameters(BIO *out , EC_GROUP *x ) ;
#line 461
int PEM_write_ECPKParameters(FILE *out , EC_GROUP *x ) ;
#line 462
EC_KEY *PEM_read_bio_ECPrivateKey(BIO *out , EC_KEY **x , pem_password_cb *cb , void *u ) ;
#line 462
EC_KEY *PEM_read_ECPrivateKey(FILE *out , EC_KEY **x , pem_password_cb *cb , void *u ) ;
#line 462
int PEM_write_bio_ECPrivateKey(BIO *out , EC_KEY *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                               int klen , pem_password_cb *cb , void *u ) ;
#line 462
int PEM_write_ECPrivateKey(FILE *out , EC_KEY *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                           int klen , pem_password_cb *cb , void *u ) ;
#line 463
EC_KEY *PEM_read_bio_EC_PUBKEY(BIO *out , EC_KEY **x , pem_password_cb *cb , void *u ) ;
#line 463
EC_KEY *PEM_read_EC_PUBKEY(FILE *out , EC_KEY **x , pem_password_cb *cb , void *u ) ;
#line 463
int PEM_write_bio_EC_PUBKEY(BIO *out , EC_KEY *x ) ;
#line 463
int PEM_write_EC_PUBKEY(FILE *out , EC_KEY *x ) ;
#line 469
DH *PEM_read_bio_DHparams(BIO *out , DH **x , pem_password_cb *cb , void *u ) ;
#line 469
DH *PEM_read_DHparams(FILE *out , DH **x , pem_password_cb *cb , void *u ) ;
#line 469
int PEM_write_bio_DHparams(BIO *out , DH *x ) ;
#line 469
int PEM_write_DHparams(FILE *out , DH *x ) ;
#line 470
int PEM_write_bio_DHxparams(BIO *out , DH *x ) ;
#line 470
int PEM_write_DHxparams(FILE *out , DH *x ) ;
#line 473
extern EVP_PKEY *PEM_read_bio_PrivateKey(BIO *out , EVP_PKEY **x , pem_password_cb *cb ,
                                         void *u ) ;
#line 473
extern EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *out , EVP_PKEY **x , pem_password_cb *cb ,
                                            void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 473
extern EVP_PKEY *PEM_read_PrivateKey(FILE *out , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 473
extern EVP_PKEY *PEM_read_PrivateKey_ex(FILE *out , EVP_PKEY **x , pem_password_cb *cb ,
                                        void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 473
extern int PEM_write_bio_PrivateKey(BIO *out , EVP_PKEY *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                                    int klen , pem_password_cb *cb , void *u ) ;
#line 473
extern int PEM_write_bio_PrivateKey_ex(BIO *out , EVP_PKEY *x , EVP_CIPHER *enc ,
                                       unsigned char const   *kstr , int klen , pem_password_cb *cb ,
                                       void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 473
extern int PEM_write_PrivateKey(FILE *out , EVP_PKEY *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                                int klen , pem_password_cb *cb , void *u ) ;
#line 473
extern int PEM_write_PrivateKey_ex(FILE *out , EVP_PKEY *x , EVP_CIPHER *enc , unsigned char const   *kstr ,
                                   int klen , pem_password_cb *cb , void *u , OSSL_LIB_CTX *libctx ,
                                   char const   *propq ) ;
#line 474
extern EVP_PKEY *PEM_read_bio_PUBKEY(BIO *out , EVP_PKEY **x , pem_password_cb *cb ,
                                     void *u ) ;
#line 474
extern EVP_PKEY *PEM_read_bio_PUBKEY_ex(BIO *out , EVP_PKEY **x , pem_password_cb *cb ,
                                        void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 474
extern EVP_PKEY *PEM_read_PUBKEY(FILE *out , EVP_PKEY **x , pem_password_cb *cb ,
                                 void *u ) ;
#line 474
extern EVP_PKEY *PEM_read_PUBKEY_ex(FILE *out , EVP_PKEY **x , pem_password_cb *cb ,
                                    void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 474
extern int PEM_write_bio_PUBKEY(BIO *out , EVP_PKEY *x ) ;
#line 474
extern int PEM_write_bio_PUBKEY_ex(BIO *out , EVP_PKEY *x , OSSL_LIB_CTX *libctx ,
                                   char const   *propq ) ;
#line 474
extern int PEM_write_PUBKEY(FILE *out , EVP_PKEY *x ) ;
#line 474
extern int PEM_write_PUBKEY_ex(FILE *out , EVP_PKEY *x , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 476
int PEM_write_bio_PrivateKey_traditional(BIO *bp , EVP_PKEY *x , EVP_CIPHER *enc ,
                                         unsigned char const   *kstr , int klen ,
                                         pem_password_cb *cb , void *u ) ;
#line 482
int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp , EVP_PKEY *x , int nid , char const   *kstr ,
                                      int klen , pem_password_cb *cb , void *u ) ;
#line 485
int PEM_write_bio_PKCS8PrivateKey(BIO * , EVP_PKEY * , EVP_CIPHER * , char const   *kstr ,
                                  int klen , pem_password_cb *cb , void *u ) ;
#line 488
int i2d_PKCS8PrivateKey_bio(BIO *bp , EVP_PKEY *x , EVP_CIPHER *enc , char const   *kstr ,
                            int klen , pem_password_cb *cb , void *u ) ;
#line 491
int i2d_PKCS8PrivateKey_nid_bio(BIO *bp , EVP_PKEY *x , int nid , char const   *kstr ,
                                int klen , pem_password_cb *cb , void *u ) ;
#line 494
EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp , EVP_PKEY **x , pem_password_cb *cb , void *u ) ;
#line 498
int i2d_PKCS8PrivateKey_fp(FILE *fp , EVP_PKEY *x , EVP_CIPHER *enc , char const   *kstr ,
                           int klen , pem_password_cb *cb , void *u ) ;
#line 501
int i2d_PKCS8PrivateKey_nid_fp(FILE *fp , EVP_PKEY *x , int nid , char const   *kstr ,
                               int klen , pem_password_cb *cb , void *u ) ;
#line 504
int PEM_write_PKCS8PrivateKey_nid(FILE *fp , EVP_PKEY *x , int nid , char const   *kstr ,
                                  int klen , pem_password_cb *cb , void *u ) ;
#line 508
EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp , EVP_PKEY **x , pem_password_cb *cb , void *u ) ;
#line 511
int PEM_write_PKCS8PrivateKey(FILE *fp , EVP_PKEY *x , EVP_CIPHER *enc , char const   *kstr ,
                              int klen , pem_password_cb *cd , void *u ) ;
#line 515
EVP_PKEY *PEM_read_bio_Parameters_ex(BIO *bp , EVP_PKEY **x , OSSL_LIB_CTX *libctx ,
                                     char const   *propq ) ;
#line 517
EVP_PKEY *PEM_read_bio_Parameters(BIO *bp , EVP_PKEY **x ) ;
#line 518
int PEM_write_bio_Parameters(BIO *bp , EVP_PKEY *x ) ;
#line 520
EVP_PKEY *b2i_PrivateKey(unsigned char const   **in , long length ) ;
#line 521
EVP_PKEY *b2i_PublicKey(unsigned char const   **in , long length ) ;
#line 522
EVP_PKEY *b2i_PrivateKey_bio(BIO *in ) ;
#line 523
EVP_PKEY *b2i_PublicKey_bio(BIO *in ) ;
#line 524
int i2b_PrivateKey_bio(BIO *out , EVP_PKEY *pk ) ;
#line 525
int i2b_PublicKey_bio(BIO *out , EVP_PKEY *pk ) ;
#line 526
EVP_PKEY *b2i_PVK_bio(BIO *in , pem_password_cb *cb , void *u ) ;
#line 527
EVP_PKEY *b2i_PVK_bio_ex(BIO *in , pem_password_cb *cb , void *u , OSSL_LIB_CTX *libctx ,
                         char const   *propq ) ;
#line 529
int i2b_PVK_bio(BIO *out , EVP_PKEY *pk , int enclevel , pem_password_cb *cb , void *u ) ;
#line 531
int i2b_PVK_bio_ex(BIO *out , EVP_PKEY *pk , int enclevel , pem_password_cb *cb ,
                   void *u , OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 32 "/usr/include/openssl/hmac.h"
size_t HMAC_size(HMAC_CTX *e ) ;
#line 33
HMAC_CTX *HMAC_CTX_new(void) ;
#line 34
int HMAC_CTX_reset(HMAC_CTX *ctx ) ;
#line 35
void HMAC_CTX_free(HMAC_CTX *ctx ) ;
#line 38
int HMAC_Init(HMAC_CTX *ctx , void const   *key , int len , EVP_MD *md ) ;
#line 43
int HMAC_Init_ex(HMAC_CTX *ctx , void const   *key , int len , EVP_MD *md , ENGINE *impl ) ;
#line 45
int HMAC_Update(HMAC_CTX *ctx , unsigned char const   *data , size_t len ) ;
#line 47
int HMAC_Final(HMAC_CTX *ctx , unsigned char *md , unsigned int *len ) ;
#line 49
int HMAC_CTX_copy(HMAC_CTX *dctx , HMAC_CTX *sctx ) ;
#line 50
void HMAC_CTX_set_flags(HMAC_CTX *ctx , unsigned long flags ) ;
#line 51
EVP_MD *HMAC_CTX_get_md(HMAC_CTX *ctx ) ;
#line 54
unsigned char *HMAC(EVP_MD *evp_md , void const   *key , int key_len , unsigned char const   *data ,
                    size_t data_len , unsigned char *md , unsigned int *md_len ) ;
#line 52 "/usr/include/openssl/async.h"
int ASYNC_init_thread(size_t max_size , size_t init_size ) ;
#line 53
void ASYNC_cleanup_thread(void) ;
#line 56
ASYNC_WAIT_CTX *ASYNC_WAIT_CTX_new(void) ;
#line 57
void ASYNC_WAIT_CTX_free(ASYNC_WAIT_CTX *ctx ) ;
#line 58
int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx , void const   *key , int fd ,
                               void *custom_data , void (*cleanup)(ASYNC_WAIT_CTX * ,
                                                                   void const   * ,
                                                                   int  , void * ) ) ;
#line 63
int ASYNC_WAIT_CTX_get_fd(ASYNC_WAIT_CTX *ctx , void const   *key , int *fd , void **custom_data ) ;
#line 65
int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx , int *fd , size_t *numfds ) ;
#line 67
int ASYNC_WAIT_CTX_get_callback(ASYNC_WAIT_CTX *ctx , ASYNC_callback_fn *callback ,
                                void **callback_arg ) ;
#line 70
int ASYNC_WAIT_CTX_set_callback(ASYNC_WAIT_CTX *ctx , ASYNC_callback_fn callback ,
                                void *callback_arg ) ;
#line 73
int ASYNC_WAIT_CTX_set_status(ASYNC_WAIT_CTX *ctx , int status ) ;
#line 74
int ASYNC_WAIT_CTX_get_status(ASYNC_WAIT_CTX *ctx ) ;
#line 75
int ASYNC_WAIT_CTX_get_changed_fds(ASYNC_WAIT_CTX *ctx , int *addfd , size_t *numaddfds ,
                                   int *delfd , size_t *numdelfds ) ;
#line 78
int ASYNC_WAIT_CTX_clear_fd(ASYNC_WAIT_CTX *ctx , void const   *key ) ;
#line 81
int ASYNC_is_capable(void) ;
#line 83
int ASYNC_start_job(ASYNC_JOB **job , ASYNC_WAIT_CTX *ctx , int *ret , int (*func)(void * ) ,
                    void *args , size_t size ) ;
#line 85
int ASYNC_pause_job(void) ;
#line 87
ASYNC_JOB *ASYNC_get_current_job(void) ;
#line 88
ASYNC_WAIT_CTX *ASYNC_get_wait_ctx(ASYNC_JOB *job ) ;
#line 89
void ASYNC_block_pause(void) ;
#line 90
void ASYNC_unblock_pause(void) ;
#line 42 "/usr/include/openssl/ct.h"
__inline static SCT *ossl_check_SCT_type(SCT *ptr ) 
{ 


  {
#line 42
  return (ptr);
}
}
#line 42 "/usr/include/openssl/ct.h"
__inline static OPENSSL_STACK *ossl_check_const_SCT_sk_type(struct stack_st_SCT *sk ) 
{ 


  {
#line 42
  return ((OPENSSL_STACK *)sk);
}
}
#line 42 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_compfunc ossl_check_SCT_compfunc_type(sk_SCT_compfunc cmp ) 
{ 


  {
#line 42
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 42 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_copyfunc ossl_check_SCT_copyfunc_type(sk_SCT_copyfunc cpy ) 
{ 


  {
#line 42
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 42 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_freefunc ossl_check_SCT_freefunc_type(sk_SCT_freefunc fr ) 
{ 


  {
#line 42
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 68 "/usr/include/openssl/ct.h"
__inline static CTLOG *ossl_check_CTLOG_type(CTLOG *ptr ) 
{ 


  {
#line 68
  return (ptr);
}
}
#line 68 "/usr/include/openssl/ct.h"
__inline static OPENSSL_STACK *ossl_check_const_CTLOG_sk_type(struct stack_st_CTLOG *sk ) 
{ 


  {
#line 68
  return ((OPENSSL_STACK *)sk);
}
}
#line 68 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_compfunc ossl_check_CTLOG_compfunc_type(sk_CTLOG_compfunc cmp ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 68 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_copyfunc ossl_check_CTLOG_copyfunc_type(sk_CTLOG_copyfunc cpy ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 68 "/usr/include/openssl/ct.h"
__inline static OPENSSL_sk_freefunc ossl_check_CTLOG_freefunc_type(sk_CTLOG_freefunc fr ) 
{ 


  {
#line 68
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 134
CT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 141
CT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new(void) ;
#line 144
void CT_POLICY_EVAL_CTX_free(CT_POLICY_EVAL_CTX *ctx ) ;
#line 147
X509 *CT_POLICY_EVAL_CTX_get0_cert(CT_POLICY_EVAL_CTX *ctx ) ;
#line 154
int CT_POLICY_EVAL_CTX_set1_cert(CT_POLICY_EVAL_CTX *ctx , X509 *cert ) ;
#line 157
X509 *CT_POLICY_EVAL_CTX_get0_issuer(CT_POLICY_EVAL_CTX *ctx ) ;
#line 164
int CT_POLICY_EVAL_CTX_set1_issuer(CT_POLICY_EVAL_CTX *ctx , X509 *issuer ) ;
#line 167
CTLOG_STORE *CT_POLICY_EVAL_CTX_get0_log_store(CT_POLICY_EVAL_CTX *ctx ) ;
#line 170
void CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(CT_POLICY_EVAL_CTX *ctx , CTLOG_STORE *log_store ) ;
#line 178
uint64_t CT_POLICY_EVAL_CTX_get_time(CT_POLICY_EVAL_CTX *ctx ) ;
#line 186
void CT_POLICY_EVAL_CTX_set_time(CT_POLICY_EVAL_CTX *ctx , uint64_t time_in_ms ) ;
#line 196
SCT *SCT_new(void) ;
#line 202
SCT *SCT_new_from_base64(unsigned char version , char const   *logid_base64 , ct_log_entry_type_t entry_type ,
                         uint64_t timestamp , char const   *extensions_base64 , char const   *signature_base64 ) ;
#line 212
void SCT_free(SCT *sct ) ;
#line 218
void SCT_LIST_free(struct stack_st_SCT *a ) ;
#line 223
sct_version_t SCT_get_version(SCT *sct ) ;
#line 229
int SCT_set_version(SCT *sct , sct_version_t version ) ;
#line 234
ct_log_entry_type_t SCT_get_log_entry_type(SCT *sct ) ;
#line 240
int SCT_set_log_entry_type(SCT *sct , ct_log_entry_type_t entry_type ) ;
#line 247
size_t SCT_get0_log_id(SCT *sct , unsigned char **log_id ) ;
#line 254
int SCT_set0_log_id(SCT *sct , unsigned char *log_id , size_t log_id_len ) ;
#line 261
int SCT_set1_log_id(SCT *sct , unsigned char const   *log_id , size_t log_id_len ) ;
#line 267
uint64_t SCT_get_timestamp(SCT *sct ) ;
#line 272
void SCT_set_timestamp(SCT *sct , uint64_t timestamp ) ;
#line 279
int SCT_get_signature_nid(SCT *sct ) ;
#line 287
int SCT_set_signature_nid(SCT *sct , int nid ) ;
#line 294
size_t SCT_get0_extensions(SCT *sct , unsigned char **ext ) ;
#line 300
void SCT_set0_extensions(SCT *sct , unsigned char *ext , size_t ext_len ) ;
#line 307
int SCT_set1_extensions(SCT *sct , unsigned char const   *ext , size_t ext_len ) ;
#line 315
size_t SCT_get0_signature(SCT *sct , unsigned char **sig ) ;
#line 321
void SCT_set0_signature(SCT *sct , unsigned char *sig , size_t sig_len ) ;
#line 327
int SCT_set1_signature(SCT *sct , unsigned char const   *sig , size_t sig_len ) ;
#line 333
sct_source_t SCT_get_source(SCT *sct ) ;
#line 339
int SCT_set_source(SCT *sct , sct_source_t source ) ;
#line 344
char const   *SCT_validation_status_string(SCT *sct ) ;
#line 352
void SCT_print(SCT *sct , BIO *out , int indent , CTLOG_STORE *logs ) ;
#line 361
void SCT_LIST_print(struct stack_st_SCT *sct_list , BIO *out , int indent , char const   *separator ,
                    CTLOG_STORE *logs ) ;
#line 368
sct_validation_status_t SCT_get_validation_status(SCT *sct ) ;
#line 377
int SCT_validate(SCT *sct , CT_POLICY_EVAL_CTX *ctx ) ;
#line 386
int SCT_LIST_validate(struct stack_st_SCT *scts , CT_POLICY_EVAL_CTX *ctx ) ;
#line 406
int i2o_SCT_LIST(struct stack_st_SCT *a , unsigned char **pp ) ;
#line 418
struct stack_st_SCT *o2i_SCT_LIST(struct stack_st_SCT **a , unsigned char const   **pp ,
                                  size_t len ) ;
#line 433
int i2d_SCT_LIST(struct stack_st_SCT *a , unsigned char **pp ) ;
#line 445
struct stack_st_SCT *d2i_SCT_LIST(struct stack_st_SCT **a , unsigned char const   **pp ,
                                  long len ) ;
#line 457
int i2o_SCT(SCT *sct , unsigned char **out ) ;
#line 470
SCT *o2i_SCT(SCT **psct , unsigned char const   **in , size_t len ) ;
#line 484
CTLOG *CTLOG_new_ex(EVP_PKEY *public_key , char const   *name , OSSL_LIB_CTX *libctx ,
                    char const   *propq ) ;
#line 491
CTLOG *CTLOG_new(EVP_PKEY *public_key , char const   *name ) ;
#line 501
int CTLOG_new_from_base64_ex(CTLOG **ct_log , char const   *pkey_base64 , char const   *name ,
                             OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 510
int CTLOG_new_from_base64(CTLOG **ct_log , char const   *pkey_base64 , char const   *name ) ;
#line 516
void CTLOG_free(CTLOG *log ) ;
#line 519
char const   *CTLOG_get0_name(CTLOG *log ) ;
#line 521
void CTLOG_get0_log_id(CTLOG *log , uint8_t **log_id , size_t *log_id_len ) ;
#line 524
EVP_PKEY *CTLOG_get0_public_key(CTLOG *log ) ;
#line 535
CTLOG_STORE *CTLOG_STORE_new_ex(OSSL_LIB_CTX *libctx , char const   *propq ) ;
#line 542
CTLOG_STORE *CTLOG_STORE_new(void) ;
#line 547
void CTLOG_STORE_free(CTLOG_STORE *store ) ;
#line 553
CTLOG *CTLOG_STORE_get0_log_by_id(CTLOG_STORE *store , uint8_t *log_id , size_t log_id_len ) ;
#line 561
int CTLOG_STORE_load_file(CTLOG_STORE *store , char const   *file ) ;
#line 567
int CTLOG_STORE_load_default_file(CTLOG_STORE *store ) ;
#line 29 "/usr/include/openssl/sslerr_legacy.h"
int ERR_load_SSL_strings(void) ;
#line 244 "/usr/include/openssl/ssl.h"
__inline static SRTP_PROTECTION_PROFILE *ossl_check_SRTP_PROTECTION_PROFILE_type(SRTP_PROTECTION_PROFILE *ptr ) 
{ 


  {
#line 244
  return (ptr);
}
}
#line 244 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_STACK *ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(struct stack_st_SRTP_PROTECTION_PROFILE *sk ) 
{ 


  {
#line 244
  return ((OPENSSL_STACK *)sk);
}
}
#line 244 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_compfunc ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(sk_SRTP_PROTECTION_PROFILE_compfunc cmp ) 
{ 


  {
#line 244
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 244 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_copyfunc ossl_check_SRTP_PROTECTION_PROFILE_copyfunc_type(sk_SRTP_PROTECTION_PROFILE_copyfunc cpy ) 
{ 


  {
#line 244
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 244 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_freefunc ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(sk_SRTP_PROTECTION_PROFILE_freefunc fr ) 
{ 


  {
#line 244
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 601
uint64_t SSL_CTX_get_options(SSL_CTX *ctx ) ;
#line 602
uint64_t SSL_get_options(SSL *s ) ;
#line 603
uint64_t SSL_CTX_clear_options(SSL_CTX *ctx , uint64_t op ) ;
#line 604
uint64_t SSL_clear_options(SSL *s , uint64_t op ) ;
#line 605
uint64_t SSL_CTX_set_options(SSL_CTX *ctx , uint64_t op ) ;
#line 606
uint64_t SSL_set_options(SSL *s , uint64_t op ) ;
#line 639
void SSL_CTX_set_msg_callback(SSL_CTX *ctx , void (*cb)(int  , int  , int  , void const   * ,
                                                        size_t  , SSL * , void * ) ) ;
#line 643
void SSL_set_msg_callback(SSL *ssl , void (*cb)(int  , int  , int  , void const   * ,
                                                size_t  , SSL * , void * ) ) ;
#line 656
int SSL_SRP_CTX_init(SSL *s ) ;
#line 657
int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx ) ;
#line 658
int SSL_SRP_CTX_free(SSL *ctx ) ;
#line 659
int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx ) ;
#line 660
int SSL_srp_server_param_with_username(SSL *s , int *ad ) ;
#line 662
int SRP_Calc_A_param(SSL *s ) ;
#line 698
struct lhash_st_SSL_SESSION *SSL_CTX_sessions(SSL_CTX *ctx ) ;
#line 724
void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx , int (*new_session_cb)(struct ssl_st * ,
                                                                  SSL_SESSION * ) ) ;
#line 727
int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx ))(struct ssl_st * , SSL_SESSION * ) ;
#line 729
void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx , void (*remove_session_cb)(struct ssl_ctx_st * ,
                                                                         SSL_SESSION * ) ) ;
#line 733
void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx ))(struct ssl_ctx_st * , SSL_SESSION * ) ;
#line 735
void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx , SSL_SESSION *(*get_session_cb)(struct ssl_st * ,
                                                                           unsigned char const   * ,
                                                                           int  ,
                                                                           int * ) ) ;
#line 741
SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx ))(struct ssl_st * , unsigned char const   * ,
                                                       int  , int * ) ;
#line 744
void SSL_CTX_set_info_callback(SSL_CTX *ctx , void (*cb)(SSL * , int  , int  ) ) ;
#line 746
void (*SSL_CTX_get_info_callback(SSL_CTX *ctx ))(SSL * , int  , int  ) ;
#line 748
void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx , int (*client_cert_cb)(SSL * , X509 ** ,
                                                                     EVP_PKEY ** ) ) ;
#line 751
int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx ))(SSL * , X509 ** , EVP_PKEY ** ) ;
#line 754
int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx , ENGINE *e ) ;
#line 756
void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx , int (*app_gen_cookie_cb)(SSL * ,
                                                                            unsigned char * ,
                                                                            unsigned int * ) ) ;
#line 762
void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx , int (*app_verify_cookie_cb)(SSL * ,
                                                                             unsigned char const   * ,
                                                                             unsigned int  ) ) ;
#line 769
void SSL_CTX_set_stateless_cookie_generate_cb(SSL_CTX *ctx , int (*gen_stateless_cookie_cb)(SSL * ,
                                                                                            unsigned char * ,
                                                                                            size_t * ) ) ;
#line 774
void SSL_CTX_set_stateless_cookie_verify_cb(SSL_CTX *ctx , int (*verify_stateless_cookie_cb)(SSL * ,
                                                                                             unsigned char const   * ,
                                                                                             size_t  ) ) ;
#line 785
void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s , SSL_CTX_npn_advertised_cb_func cb ,
                                           void *arg ) ;
#line 796
void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s , SSL_CTX_npn_select_cb_func cb ,
                                      void *arg ) ;
#line 801
void SSL_get0_next_proto_negotiated(SSL *s , unsigned char const   **data , unsigned int *len ) ;
#line 806
int SSL_select_next_proto(unsigned char **out , unsigned char *outlen , unsigned char const   *in ,
                          unsigned int inlen , unsigned char const   *client , unsigned int client_len ) ;
#line 815
int SSL_CTX_set_alpn_protos(SSL_CTX *ctx , unsigned char const   *protos , unsigned int protos_len ) ;
#line 817
int SSL_set_alpn_protos(SSL *ssl , unsigned char const   *protos , unsigned int protos_len ) ;
#line 825
void SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx , SSL_CTX_alpn_select_cb_func cb , void *arg ) ;
#line 828
void SSL_get0_alpn_selected(SSL *ssl , unsigned char const   **data , unsigned int *len ) ;
#line 844
void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx , SSL_psk_client_cb_func cb ) ;
#line 845
void SSL_set_psk_client_callback(SSL *ssl , SSL_psk_client_cb_func cb ) ;
#line 851
void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx , SSL_psk_server_cb_func cb ) ;
#line 852
void SSL_set_psk_server_callback(SSL *ssl , SSL_psk_server_cb_func cb ) ;
#line 854
int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx , char const   *identity_hint ) ;
#line 855
int SSL_use_psk_identity_hint(SSL *s , char const   *identity_hint ) ;
#line 856
char const   *SSL_get_psk_identity_hint(SSL *s ) ;
#line 857
char const   *SSL_get_psk_identity(SSL *s ) ;
#line 869
void SSL_set_psk_find_session_callback(SSL *s , SSL_psk_find_session_cb_func cb ) ;
#line 870
void SSL_CTX_set_psk_find_session_callback(SSL_CTX *ctx , SSL_psk_find_session_cb_func cb ) ;
#line 872
void SSL_set_psk_use_session_callback(SSL *s , SSL_psk_use_session_cb_func cb ) ;
#line 873
void SSL_CTX_set_psk_use_session_callback(SSL_CTX *ctx , SSL_psk_use_session_cb_func cb ) ;
#line 878
int SSL_CTX_has_client_custom_ext(SSL_CTX *ctx , unsigned int ext_type ) ;
#line 881
int SSL_CTX_add_client_custom_ext(SSL_CTX *ctx , unsigned int ext_type , custom_ext_add_cb add_cb ,
                                  custom_ext_free_cb free_cb , void *add_arg , custom_ext_parse_cb parse_cb ,
                                  void *parse_arg ) ;
#line 889
int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx , unsigned int ext_type , custom_ext_add_cb add_cb ,
                                  custom_ext_free_cb free_cb , void *add_arg , custom_ext_parse_cb parse_cb ,
                                  void *parse_arg ) ;
#line 897
int SSL_CTX_add_custom_ext(SSL_CTX *ctx , unsigned int ext_type , unsigned int context ,
                           SSL_custom_ext_add_cb_ex add_cb , SSL_custom_ext_free_cb_ex free_cb ,
                           void *add_arg , SSL_custom_ext_parse_cb_ex parse_cb , void *parse_arg ) ;
#line 905
int SSL_extension_supported(unsigned int ext_type ) ;
#line 942
void SSL_CTX_set_keylog_callback(SSL_CTX *ctx , SSL_CTX_keylog_cb_func cb ) ;
#line 948
SSL_CTX_keylog_cb_func SSL_CTX_get_keylog_callback(SSL_CTX *ctx ) ;
#line 950
int SSL_CTX_set_max_early_data(SSL_CTX *ctx , uint32_t max_early_data ) ;
#line 951
uint32_t SSL_CTX_get_max_early_data(SSL_CTX *ctx ) ;
#line 952
int SSL_set_max_early_data(SSL *s , uint32_t max_early_data ) ;
#line 953
uint32_t SSL_get_max_early_data(SSL *s ) ;
#line 954
int SSL_CTX_set_recv_max_early_data(SSL_CTX *ctx , uint32_t recv_max_early_data ) ;
#line 955
uint32_t SSL_CTX_get_recv_max_early_data(SSL_CTX *ctx ) ;
#line 956
int SSL_set_recv_max_early_data(SSL *s , uint32_t recv_max_early_data ) ;
#line 957
uint32_t SSL_get_recv_max_early_data(SSL *s ) ;
#line 214 "/usr/include/openssl/tls1.h"
int SSL_CTX_set_tlsext_max_fragment_length(SSL_CTX *ctx , uint8_t mode ) ;
#line 215
int SSL_set_tlsext_max_fragment_length(SSL *ssl , uint8_t mode ) ;
#line 219
char const   *SSL_get_servername(SSL *s , int const   type ) ;
#line 220
int SSL_get_servername_type(SSL *s ) ;
#line 228
int SSL_export_keying_material(SSL *s , unsigned char *out , size_t olen , char const   *label ,
                               size_t llen , unsigned char const   *context , size_t contextlen ,
                               int use_context ) ;
#line 240
int SSL_export_keying_material_early(SSL *s , unsigned char *out , size_t olen , char const   *label ,
                                     size_t llen , unsigned char const   *context ,
                                     size_t contextlen ) ;
#line 246
int SSL_get_peer_signature_type_nid(SSL *s , int *pnid ) ;
#line 247
int SSL_get_signature_type_nid(SSL *s , int *pnid ) ;
#line 249
int SSL_get_sigalgs(SSL *s , int idx , int *psign , int *phash , int *psignandhash ,
                    unsigned char *rsig , unsigned char *rhash ) ;
#line 253
int SSL_get_shared_sigalgs(SSL *s , int idx , int *psign , int *phash , int *psignandhash ,
                           unsigned char *rsig , unsigned char *rhash ) ;
#line 257
int SSL_check_chain(SSL *s , X509 *x , EVP_PKEY *pk , struct stack_st_X509 *chain ) ;
#line 333
int SSL_CTX_set_tlsext_ticket_key_evp_cb(SSL_CTX *ctx , int (*fp)(SSL * , unsigned char * ,
                                                                  unsigned char * ,
                                                                  EVP_CIPHER_CTX * ,
                                                                  EVP_MAC_CTX * ,
                                                                  int  ) ) ;
#line 44 "/usr/include/openssl/srtp.h"
int SSL_CTX_set_tlsext_use_srtp(SSL_CTX *ctx , char const   *profiles ) ;
#line 45
int SSL_set_tlsext_use_srtp(SSL *ssl , char const   *profiles ) ;
#line 47
struct stack_st_SRTP_PROTECTION_PROFILE *SSL_get_srtp_profiles(SSL *ssl ) ;
#line 48
SRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *s ) ;
#line 977 "/usr/include/openssl/ssl.h"
__inline static SSL_CIPHER *ossl_check_SSL_CIPHER_type(SSL_CIPHER *ptr ) 
{ 


  {
#line 977
  return (ptr);
}
}
#line 977 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_STACK *ossl_check_const_SSL_CIPHER_sk_type(struct stack_st_SSL_CIPHER *sk ) 
{ 


  {
#line 977
  return ((OPENSSL_STACK *)sk);
}
}
#line 977 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_compfunc ossl_check_SSL_CIPHER_compfunc_type(sk_SSL_CIPHER_compfunc cmp ) 
{ 


  {
#line 977
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 977 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_copyfunc ossl_check_SSL_CIPHER_copyfunc_type(sk_SSL_CIPHER_copyfunc cpy ) 
{ 


  {
#line 977
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 977 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_freefunc ossl_check_SSL_CIPHER_freefunc_type(sk_SSL_CIPHER_freefunc fr ) 
{ 


  {
#line 977
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1003 "/usr/include/openssl/ssl.h"
__inline static SSL_COMP *ossl_check_SSL_COMP_type(SSL_COMP *ptr ) 
{ 


  {
#line 1003
  return (ptr);
}
}
#line 1003 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_STACK *ossl_check_const_SSL_COMP_sk_type(struct stack_st_SSL_COMP *sk ) 
{ 


  {
#line 1003
  return ((OPENSSL_STACK *)sk);
}
}
#line 1003 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_compfunc ossl_check_SSL_COMP_compfunc_type(sk_SSL_COMP_compfunc cmp ) 
{ 


  {
#line 1003
  return ((OPENSSL_sk_compfunc )cmp);
}
}
#line 1003 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_copyfunc ossl_check_SSL_COMP_copyfunc_type(sk_SSL_COMP_copyfunc cpy ) 
{ 


  {
#line 1003
  return ((OPENSSL_sk_copyfunc )cpy);
}
}
#line 1003 "/usr/include/openssl/ssl.h"
__inline static OPENSSL_sk_freefunc ossl_check_SSL_COMP_freefunc_type(sk_SSL_COMP_freefunc fr ) 
{ 


  {
#line 1003
  return ((OPENSSL_sk_freefunc )fr);
}
}
#line 1041
void SSL_set_debug(SSL *s , int debug ) ;
#line 1146
int SSL_in_init(SSL *s ) ;
#line 1147
int SSL_in_before(SSL *s ) ;
#line 1148
int SSL_is_init_finished(SSL *s ) ;
#line 1164
size_t SSL_get_finished(SSL *s , void *buf , size_t count ) ;
#line 1165
size_t SSL_get_peer_finished(SSL *s , void *buf , size_t count ) ;
#line 1199
extern SSL_SESSION *PEM_read_bio_SSL_SESSION(BIO *out , SSL_SESSION **x , pem_password_cb *cb ,
                                             void *u ) ;
#line 1199
extern SSL_SESSION *PEM_read_SSL_SESSION(FILE *out , SSL_SESSION **x , pem_password_cb *cb ,
                                         void *u ) ;
#line 1199
extern int PEM_write_bio_SSL_SESSION(BIO *out , SSL_SESSION *x ) ;
#line 1199
extern int PEM_write_SSL_SESSION(FILE *out , SSL_SESSION *x ) ;
#line 1541
char const   *SSL_group_to_name(SSL *s , int id ) ;
#line 1549
int SSL_set0_tmp_dh_pkey(SSL *s , EVP_PKEY *dhpkey ) ;
#line 1550
int SSL_CTX_set0_tmp_dh_pkey(SSL_CTX *ctx , EVP_PKEY *dhpkey ) ;
#line 1584
BIO_METHOD *BIO_f_ssl(void) ;
#line 1585
BIO *BIO_new_ssl(SSL_CTX *ctx , int client ) ;
#line 1586
BIO *BIO_new_ssl_connect(SSL_CTX *ctx ) ;
#line 1587
BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx ) ;
#line 1588
int BIO_ssl_copy_session_id(BIO *to , BIO *from ) ;
#line 1589
void BIO_ssl_shutdown(BIO *ssl_bio ) ;
#line 1591
int SSL_CTX_set_cipher_list(SSL_CTX * , char const   *str ) ;
#line 1592
SSL_CTX *SSL_CTX_new(SSL_METHOD *meth ) ;
#line 1593
SSL_CTX *SSL_CTX_new_ex(OSSL_LIB_CTX *libctx , char const   *propq , SSL_METHOD *meth ) ;
#line 1595
int SSL_CTX_up_ref(SSL_CTX *ctx ) ;
#line 1596
void SSL_CTX_free(SSL_CTX * ) ;
#line 1597
long SSL_CTX_set_timeout(SSL_CTX *ctx , long t ) ;
#line 1598
long SSL_CTX_get_timeout(SSL_CTX *ctx ) ;
#line 1599
X509_STORE *SSL_CTX_get_cert_store(SSL_CTX * ) ;
#line 1600
void SSL_CTX_set_cert_store(SSL_CTX * , X509_STORE * ) ;
#line 1601
void SSL_CTX_set1_cert_store(SSL_CTX * , X509_STORE * ) ;
#line 1602
int SSL_want(SSL *s ) ;
#line 1603
int SSL_clear(SSL *s ) ;
#line 1605
void SSL_CTX_flush_sessions(SSL_CTX *ctx , long tm ) ;
#line 1607
SSL_CIPHER *SSL_get_current_cipher(SSL *s ) ;
#line 1608
SSL_CIPHER *SSL_get_pending_cipher(SSL *s ) ;
#line 1609
int SSL_CIPHER_get_bits(SSL_CIPHER *c , int *alg_bits ) ;
#line 1610
char const   *SSL_CIPHER_get_version(SSL_CIPHER *c ) ;
#line 1611
char const   *SSL_CIPHER_get_name(SSL_CIPHER *c ) ;
#line 1612
char const   *SSL_CIPHER_standard_name(SSL_CIPHER *c ) ;
#line 1613
char const   *OPENSSL_cipher_name(char const   *rfc_name ) ;
#line 1614
uint32_t SSL_CIPHER_get_id(SSL_CIPHER *c ) ;
#line 1615
uint16_t SSL_CIPHER_get_protocol_id(SSL_CIPHER *c ) ;
#line 1616
int SSL_CIPHER_get_kx_nid(SSL_CIPHER *c ) ;
#line 1617
int SSL_CIPHER_get_auth_nid(SSL_CIPHER *c ) ;
#line 1618
EVP_MD *SSL_CIPHER_get_handshake_digest(SSL_CIPHER *c ) ;
#line 1619
int SSL_CIPHER_is_aead(SSL_CIPHER *c ) ;
#line 1621
int SSL_get_fd(SSL *s ) ;
#line 1622
int SSL_get_rfd(SSL *s ) ;
#line 1623
int SSL_get_wfd(SSL *s ) ;
#line 1624
char const   *SSL_get_cipher_list(SSL *s , int n ) ;
#line 1625
char *SSL_get_shared_ciphers(SSL *s , char *buf , int size ) ;
#line 1626
int SSL_get_read_ahead(SSL *s ) ;
#line 1627
int SSL_pending(SSL *s ) ;
#line 1628
int SSL_has_pending(SSL *s ) ;
#line 1630
int SSL_set_fd(SSL *s , int fd ) ;
#line 1631
int SSL_set_rfd(SSL *s , int fd ) ;
#line 1632
int SSL_set_wfd(SSL *s , int fd ) ;
#line 1634
void SSL_set0_rbio(SSL *s , BIO *rbio ) ;
#line 1635
void SSL_set0_wbio(SSL *s , BIO *wbio ) ;
#line 1636
void SSL_set_bio(SSL *s , BIO *rbio , BIO *wbio ) ;
#line 1637
BIO *SSL_get_rbio(SSL *s ) ;
#line 1638
BIO *SSL_get_wbio(SSL *s ) ;
#line 1639
int SSL_set_cipher_list(SSL *s , char const   *str ) ;
#line 1640
int SSL_CTX_set_ciphersuites(SSL_CTX *ctx , char const   *str ) ;
#line 1641
int SSL_set_ciphersuites(SSL *s , char const   *str ) ;
#line 1642
void SSL_set_read_ahead(SSL *s , int yes ) ;
#line 1643
int SSL_get_verify_mode(SSL *s ) ;
#line 1644
int SSL_get_verify_depth(SSL *s ) ;
#line 1645
SSL_verify_cb SSL_get_verify_callback(SSL *s ) ;
#line 1646
void SSL_set_verify(SSL *s , int mode , SSL_verify_cb callback ) ;
#line 1647
void SSL_set_verify_depth(SSL *s , int depth ) ;
#line 1648
void SSL_set_cert_cb(SSL *s , int (*cb)(SSL * , void * ) , void *arg ) ;
#line 1650
int SSL_use_RSAPrivateKey(SSL *ssl , RSA *rsa ) ;
#line 1652
int SSL_use_RSAPrivateKey_ASN1(SSL *ssl , unsigned char const   *d , long len ) ;
#line 1655
int SSL_use_PrivateKey(SSL *ssl , EVP_PKEY *pkey ) ;
#line 1656
int SSL_use_PrivateKey_ASN1(int pk , SSL *ssl , unsigned char const   *d , long len ) ;
#line 1658
int SSL_use_certificate(SSL *ssl , X509 *x ) ;
#line 1659
int SSL_use_certificate_ASN1(SSL *ssl , unsigned char const   *d , int len ) ;
#line 1660
int SSL_use_cert_and_key(SSL *ssl , X509 *x509 , EVP_PKEY *privatekey , struct stack_st_X509 *chain ,
                         int override ) ;
#line 1669
int SSL_CTX_use_serverinfo(SSL_CTX *ctx , unsigned char const   *serverinfo , size_t serverinfo_length ) ;
#line 1671
int SSL_CTX_use_serverinfo_ex(SSL_CTX *ctx , unsigned int version , unsigned char const   *serverinfo ,
                              size_t serverinfo_length ) ;
#line 1674
int SSL_CTX_use_serverinfo_file(SSL_CTX *ctx , char const   *file ) ;
#line 1678
int SSL_use_RSAPrivateKey_file(SSL *ssl , char const   *file , int type ) ;
#line 1681
int SSL_use_PrivateKey_file(SSL *ssl , char const   *file , int type ) ;
#line 1682
int SSL_use_certificate_file(SSL *ssl , char const   *file , int type ) ;
#line 1686
int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1689
int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1691
int SSL_CTX_use_certificate_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1694
int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx , char const   *file ) ;
#line 1695
int SSL_use_certificate_chain_file(SSL *ssl , char const   *file ) ;
#line 1696
struct stack_st_X509_NAME *SSL_load_client_CA_file(char const   *file ) ;
#line 1698
struct stack_st_X509_NAME *SSL_load_client_CA_file_ex(char const   *file , OSSL_LIB_CTX *libctx ,
                                                      char const   *propq ) ;
#line 1700
int SSL_add_file_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs , char const   *file ) ;
#line 1702
int SSL_add_dir_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs , char const   *dir ) ;
#line 1704
int SSL_add_store_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs , char const   *uri ) ;
#line 1713
char const   *SSL_state_string(SSL *s ) ;
#line 1714
char const   *SSL_rstate_string(SSL *s ) ;
#line 1715
char const   *SSL_state_string_long(SSL *s ) ;
#line 1716
char const   *SSL_rstate_string_long(SSL *s ) ;
#line 1717
long SSL_SESSION_get_time(SSL_SESSION *s ) ;
#line 1718
long SSL_SESSION_set_time(SSL_SESSION *s , long t ) ;
#line 1719
long SSL_SESSION_get_timeout(SSL_SESSION *s ) ;
#line 1720
long SSL_SESSION_set_timeout(SSL_SESSION *s , long t ) ;
#line 1721
int SSL_SESSION_get_protocol_version(SSL_SESSION *s ) ;
#line 1722
int SSL_SESSION_set_protocol_version(SSL_SESSION *s , int version ) ;
#line 1724
char const   *SSL_SESSION_get0_hostname(SSL_SESSION *s ) ;
#line 1725
int SSL_SESSION_set1_hostname(SSL_SESSION *s , char const   *hostname ) ;
#line 1726
void SSL_SESSION_get0_alpn_selected(SSL_SESSION *s , unsigned char const   **alpn ,
                                    size_t *len ) ;
#line 1729
int SSL_SESSION_set1_alpn_selected(SSL_SESSION *s , unsigned char const   *alpn ,
                                   size_t len ) ;
#line 1732
SSL_CIPHER *SSL_SESSION_get0_cipher(SSL_SESSION *s ) ;
#line 1733
int SSL_SESSION_set_cipher(SSL_SESSION *s , SSL_CIPHER *cipher ) ;
#line 1734
int SSL_SESSION_has_ticket(SSL_SESSION *s ) ;
#line 1735
unsigned long SSL_SESSION_get_ticket_lifetime_hint(SSL_SESSION *s ) ;
#line 1736
void SSL_SESSION_get0_ticket(SSL_SESSION *s , unsigned char const   **tick , size_t *len ) ;
#line 1738
uint32_t SSL_SESSION_get_max_early_data(SSL_SESSION *s ) ;
#line 1739
int SSL_SESSION_set_max_early_data(SSL_SESSION *s , uint32_t max_early_data ) ;
#line 1741
int SSL_copy_session_id(SSL *to , SSL *from ) ;
#line 1742
X509 *SSL_SESSION_get0_peer(SSL_SESSION *s ) ;
#line 1743
int SSL_SESSION_set1_id_context(SSL_SESSION *s , unsigned char const   *sid_ctx ,
                                unsigned int sid_ctx_len ) ;
#line 1746
int SSL_SESSION_set1_id(SSL_SESSION *s , unsigned char const   *sid , unsigned int sid_len ) ;
#line 1748
int SSL_SESSION_is_resumable(SSL_SESSION *s ) ;
#line 1750
SSL_SESSION *SSL_SESSION_new(void) ;
#line 1751
SSL_SESSION *SSL_SESSION_dup(SSL_SESSION *src ) ;
#line 1752
unsigned char const   *SSL_SESSION_get_id(SSL_SESSION *s , unsigned int *len ) ;
#line 1754
unsigned char const   *SSL_SESSION_get0_id_context(SSL_SESSION *s , unsigned int *len ) ;
#line 1756
unsigned int SSL_SESSION_get_compress_id(SSL_SESSION *s ) ;
#line 1758
int SSL_SESSION_print_fp(FILE *fp , SSL_SESSION *ses ) ;
#line 1760
int SSL_SESSION_print(BIO *fp , SSL_SESSION *ses ) ;
#line 1761
int SSL_SESSION_print_keylog(BIO *bp , SSL_SESSION *x ) ;
#line 1762
int SSL_SESSION_up_ref(SSL_SESSION *ses ) ;
#line 1763
void SSL_SESSION_free(SSL_SESSION *ses ) ;
#line 1764
int i2d_SSL_SESSION(SSL_SESSION *in , unsigned char **pp ) ;
#line 1765
int SSL_set_session(SSL *to , SSL_SESSION *session ) ;
#line 1766
int SSL_CTX_add_session(SSL_CTX *ctx , SSL_SESSION *session ) ;
#line 1767
int SSL_CTX_remove_session(SSL_CTX *ctx , SSL_SESSION *session ) ;
#line 1768
int SSL_CTX_set_generate_session_id(SSL_CTX *ctx , GEN_SESSION_CB cb ) ;
#line 1769
int SSL_set_generate_session_id(SSL *s , GEN_SESSION_CB cb ) ;
#line 1770
int SSL_has_matching_session_id(SSL *s , unsigned char const   *id , unsigned int id_len ) ;
#line 1773
SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a , unsigned char const   **pp , long length ) ;
#line 1777
X509 *SSL_get0_peer_certificate(SSL *s ) ;
#line 1778
X509 *SSL_get1_peer_certificate(SSL *s ) ;
#line 1785
struct stack_st_X509 *SSL_get_peer_cert_chain(SSL *s ) ;
#line 1787
int SSL_CTX_get_verify_mode(SSL_CTX *ctx ) ;
#line 1788
int SSL_CTX_get_verify_depth(SSL_CTX *ctx ) ;
#line 1789
SSL_verify_cb SSL_CTX_get_verify_callback(SSL_CTX *ctx ) ;
#line 1790
void SSL_CTX_set_verify(SSL_CTX *ctx , int mode , SSL_verify_cb callback ) ;
#line 1791
void SSL_CTX_set_verify_depth(SSL_CTX *ctx , int depth ) ;
#line 1792
void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx , int (*cb)(X509_STORE_CTX * ,
                                                               void * ) , void *arg ) ;
#line 1795
void SSL_CTX_set_cert_cb(SSL_CTX *c , int (*cb)(SSL * , void * ) , void *arg ) ;
#line 1799
int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx , RSA *rsa ) ;
#line 1801
int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx , unsigned char const   *d , long len ) ;
#line 1804
int SSL_CTX_use_PrivateKey(SSL_CTX *ctx , EVP_PKEY *pkey ) ;
#line 1805
int SSL_CTX_use_PrivateKey_ASN1(int pk , SSL_CTX *ctx , unsigned char const   *d ,
                                long len ) ;
#line 1807
int SSL_CTX_use_certificate(SSL_CTX *ctx , X509 *x ) ;
#line 1808
int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx , int len , unsigned char const   *d ) ;
#line 1810
int SSL_CTX_use_cert_and_key(SSL_CTX *ctx , X509 *x509 , EVP_PKEY *privatekey , struct stack_st_X509 *chain ,
                             int override ) ;
#line 1813
void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx , pem_password_cb *cb ) ;
#line 1814
void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx , void *u ) ;
#line 1815
pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx ) ;
#line 1816
void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx ) ;
#line 1817
void SSL_set_default_passwd_cb(SSL *s , pem_password_cb *cb ) ;
#line 1818
void SSL_set_default_passwd_cb_userdata(SSL *s , void *u ) ;
#line 1819
pem_password_cb *SSL_get_default_passwd_cb(SSL *s ) ;
#line 1820
void *SSL_get_default_passwd_cb_userdata(SSL *s ) ;
#line 1822
int SSL_CTX_check_private_key(SSL_CTX *ctx ) ;
#line 1823
int SSL_check_private_key(SSL *ctx ) ;
#line 1825
int SSL_CTX_set_session_id_context(SSL_CTX *ctx , unsigned char const   *sid_ctx ,
                                   unsigned int sid_ctx_len ) ;
#line 1829
SSL *SSL_new(SSL_CTX *ctx ) ;
#line 1830
int SSL_up_ref(SSL *s ) ;
#line 1831
int SSL_is_dtls(SSL *s ) ;
#line 1832
int SSL_set_session_id_context(SSL *ssl , unsigned char const   *sid_ctx , unsigned int sid_ctx_len ) ;
#line 1835
int SSL_CTX_set_purpose(SSL_CTX *ctx , int purpose ) ;
#line 1836
int SSL_set_purpose(SSL *ssl , int purpose ) ;
#line 1837
int SSL_CTX_set_trust(SSL_CTX *ctx , int trust ) ;
#line 1838
int SSL_set_trust(SSL *ssl , int trust ) ;
#line 1840
int SSL_set1_host(SSL *s , char const   *hostname ) ;
#line 1841
int SSL_add1_host(SSL *s , char const   *hostname ) ;
#line 1842
char const   *SSL_get0_peername(SSL *s ) ;
#line 1843
void SSL_set_hostflags(SSL *s , unsigned int flags ) ;
#line 1845
int SSL_CTX_dane_enable(SSL_CTX *ctx ) ;
#line 1846
int SSL_CTX_dane_mtype_set(SSL_CTX *ctx , EVP_MD *md , uint8_t mtype , uint8_t ord ) ;
#line 1848
int SSL_dane_enable(SSL *s , char const   *basedomain ) ;
#line 1849
int SSL_dane_tlsa_add(SSL *s , uint8_t usage , uint8_t selector , uint8_t mtype ,
                      unsigned char const   *data , size_t dlen ) ;
#line 1851
int SSL_get0_dane_authority(SSL *s , X509 **mcert , EVP_PKEY **mspki ) ;
#line 1852
int SSL_get0_dane_tlsa(SSL *s , uint8_t *usage , uint8_t *selector , uint8_t *mtype ,
                       unsigned char const   **data , size_t *dlen ) ;
#line 1859
SSL_DANE *SSL_get0_dane(SSL *ssl ) ;
#line 1863
unsigned long SSL_CTX_dane_set_flags(SSL_CTX *ctx , unsigned long flags ) ;
#line 1864
unsigned long SSL_CTX_dane_clear_flags(SSL_CTX *ctx , unsigned long flags ) ;
#line 1865
unsigned long SSL_dane_set_flags(SSL *ssl , unsigned long flags ) ;
#line 1866
unsigned long SSL_dane_clear_flags(SSL *ssl , unsigned long flags ) ;
#line 1868
int SSL_CTX_set1_param(SSL_CTX *ctx , X509_VERIFY_PARAM *vpm ) ;
#line 1869
int SSL_set1_param(SSL *ssl , X509_VERIFY_PARAM *vpm ) ;
#line 1871
X509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *ctx ) ;
#line 1872
X509_VERIFY_PARAM *SSL_get0_param(SSL *ssl ) ;
#line 1876
int SSL_CTX_set_srp_username(SSL_CTX *ctx , char *name ) ;
#line 1877
int SSL_CTX_set_srp_password(SSL_CTX *ctx , char *password ) ;
#line 1878
int SSL_CTX_set_srp_strength(SSL_CTX *ctx , int strength ) ;
#line 1880
int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx , char *(*cb)(SSL * , void * ) ) ;
#line 1883
int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx , int (*cb)(SSL * , void * ) ) ;
#line 1886
int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx , int (*cb)(SSL * , int * , void * ) ) ;
#line 1888
int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx , void *arg ) ;
#line 1891
int SSL_set_srp_server_param(SSL *s , BIGNUM *N , BIGNUM *g , BIGNUM *sa , BIGNUM *v ,
                             char *info ) ;
#line 1894
int SSL_set_srp_server_param_pw(SSL *s , char const   *user , char const   *pass ,
                                char const   *grp ) ;
#line 1897
BIGNUM *SSL_get_srp_g(SSL *s ) ;
#line 1898
BIGNUM *SSL_get_srp_N(SSL *s ) ;
#line 1900
char *SSL_get_srp_username(SSL *s ) ;
#line 1901
char *SSL_get_srp_userinfo(SSL *s ) ;
#line 1914
void SSL_CTX_set_client_hello_cb(SSL_CTX *c , SSL_client_hello_cb_fn cb , void *arg ) ;
#line 1916
int SSL_client_hello_isv2(SSL *s ) ;
#line 1917
unsigned int SSL_client_hello_get0_legacy_version(SSL *s ) ;
#line 1918
size_t SSL_client_hello_get0_random(SSL *s , unsigned char const   **out ) ;
#line 1919
size_t SSL_client_hello_get0_session_id(SSL *s , unsigned char const   **out ) ;
#line 1920
size_t SSL_client_hello_get0_ciphers(SSL *s , unsigned char const   **out ) ;
#line 1921
size_t SSL_client_hello_get0_compression_methods(SSL *s , unsigned char const   **out ) ;
#line 1923
int SSL_client_hello_get1_extensions_present(SSL *s , int **out , size_t *outlen ) ;
#line 1924
int SSL_client_hello_get0_ext(SSL *s , unsigned int type , unsigned char const   **out ,
                              size_t *outlen ) ;
#line 1927
void SSL_certs_clear(SSL *s ) ;
#line 1928
void SSL_free(SSL *ssl ) ;
#line 1933
int SSL_waiting_for_async(SSL *s ) ;
#line 1934
int SSL_get_all_async_fds(SSL *s , int *fds , size_t *numfds ) ;
#line 1935
int SSL_get_changed_async_fds(SSL *s , int *addfd , size_t *numaddfds , int *delfd ,
                              size_t *numdelfds ) ;
#line 1938
int SSL_CTX_set_async_callback(SSL_CTX *ctx , SSL_async_callback_fn callback ) ;
#line 1939
int SSL_CTX_set_async_callback_arg(SSL_CTX *ctx , void *arg ) ;
#line 1940
int SSL_set_async_callback(SSL *s , SSL_async_callback_fn callback ) ;
#line 1941
int SSL_set_async_callback_arg(SSL *s , void *arg ) ;
#line 1942
int SSL_get_async_status(SSL *s , int *status ) ;
#line 1945
int SSL_accept(SSL *ssl ) ;
#line 1946
int SSL_stateless(SSL *s ) ;
#line 1947
int SSL_connect(SSL *ssl ) ;
#line 1948
int SSL_read(SSL *ssl , void *buf , int num ) ;
#line 1949
int SSL_read_ex(SSL *ssl , void *buf , size_t num , size_t *readbytes ) ;
#line 1955
int SSL_read_early_data(SSL *s , void *buf , size_t num , size_t *readbytes ) ;
#line 1957
int SSL_peek(SSL *ssl , void *buf , int num ) ;
#line 1958
int SSL_peek_ex(SSL *ssl , void *buf , size_t num , size_t *readbytes ) ;
#line 1959
ssize_t SSL_sendfile(SSL *s , int fd , __off_t offset , size_t size , int flags ) ;
#line 1961
int SSL_write(SSL *ssl , void const   *buf , int num ) ;
#line 1962
int SSL_write_ex(SSL *s , void const   *buf , size_t num , size_t *written ) ;
#line 1963
int SSL_write_early_data(SSL *s , void const   *buf , size_t num , size_t *written ) ;
#line 1965
long SSL_ctrl(SSL *ssl , int cmd , long larg , void *parg ) ;
#line 1966
long SSL_callback_ctrl(SSL * , int  , void (*)(void) ) ;
#line 1967
long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
#line 1968
long SSL_CTX_callback_ctrl(SSL_CTX * , int  , void (*)(void) ) ;
#line 1974
int SSL_get_early_data_status(SSL *s ) ;
#line 1976
int SSL_get_error(SSL *s , int ret_code ) ;
#line 1977
char const   *SSL_get_version(SSL *s ) ;
#line 1982
int SSL_CTX_set_ssl_version(SSL_CTX *ctx , SSL_METHOD *meth ) ;
#line 1998
SSL_METHOD *TLS_method(void) ;
#line 1999
SSL_METHOD *TLS_server_method(void) ;
#line 2000
SSL_METHOD *TLS_client_method(void) ;
#line 2004
SSL_METHOD *TLSv1_method(void) ;
#line 2005
SSL_METHOD *TLSv1_server_method(void) ;
#line 2006
SSL_METHOD *TLSv1_client_method(void) ;
#line 2012
SSL_METHOD *TLSv1_1_method(void) ;
#line 2013
SSL_METHOD *TLSv1_1_server_method(void) ;
#line 2014
SSL_METHOD *TLSv1_1_client_method(void) ;
#line 2020
SSL_METHOD *TLSv1_2_method(void) ;
#line 2021
SSL_METHOD *TLSv1_2_server_method(void) ;
#line 2022
SSL_METHOD *TLSv1_2_client_method(void) ;
#line 2028
SSL_METHOD *DTLSv1_method(void) ;
#line 2029
SSL_METHOD *DTLSv1_server_method(void) ;
#line 2030
SSL_METHOD *DTLSv1_client_method(void) ;
#line 2037
SSL_METHOD *DTLSv1_2_method(void) ;
#line 2038
SSL_METHOD *DTLSv1_2_server_method(void) ;
#line 2039
SSL_METHOD *DTLSv1_2_client_method(void) ;
#line 2043
SSL_METHOD *DTLS_method(void) ;
#line 2044
SSL_METHOD *DTLS_server_method(void) ;
#line 2045
SSL_METHOD *DTLS_client_method(void) ;
#line 2047
size_t DTLS_get_data_mtu(SSL *s ) ;
#line 2049
struct stack_st_SSL_CIPHER *SSL_get_ciphers(SSL *s ) ;
#line 2050
struct stack_st_SSL_CIPHER *SSL_CTX_get_ciphers(SSL_CTX *ctx ) ;
#line 2051
struct stack_st_SSL_CIPHER *SSL_get_client_ciphers(SSL *s ) ;
#line 2052
struct stack_st_SSL_CIPHER *SSL_get1_supported_ciphers(SSL *s ) ;
#line 2054
int SSL_do_handshake(SSL *s ) ;
#line 2055
int SSL_key_update(SSL *s , int updatetype ) ;
#line 2056
int SSL_get_key_update_type(SSL *s ) ;
#line 2057
int SSL_renegotiate(SSL *s ) ;
#line 2058
int SSL_renegotiate_abbreviated(SSL *s ) ;
#line 2059
int SSL_renegotiate_pending(SSL *s ) ;
#line 2060
int SSL_new_session_ticket(SSL *s ) ;
#line 2061
int SSL_shutdown(SSL *s ) ;
#line 2062
int SSL_verify_client_post_handshake(SSL *s ) ;
#line 2063
void SSL_CTX_set_post_handshake_auth(SSL_CTX *ctx , int val ) ;
#line 2064
void SSL_set_post_handshake_auth(SSL *s , int val ) ;
#line 2066
SSL_METHOD *SSL_CTX_get_ssl_method(SSL_CTX *ctx ) ;
#line 2067
SSL_METHOD *SSL_get_ssl_method(SSL *s ) ;
#line 2068
int SSL_set_ssl_method(SSL *s , SSL_METHOD *method ) ;
#line 2069
char const   *SSL_alert_type_string_long(int value ) ;
#line 2070
char const   *SSL_alert_type_string(int value ) ;
#line 2071
char const   *SSL_alert_desc_string_long(int value ) ;
#line 2072
char const   *SSL_alert_desc_string(int value ) ;
#line 2074
void SSL_set0_CA_list(SSL *s , struct stack_st_X509_NAME *name_list ) ;
#line 2075
void SSL_CTX_set0_CA_list(SSL_CTX *ctx , struct stack_st_X509_NAME *name_list ) ;
#line 2076
struct stack_st_X509_NAME *SSL_get0_CA_list(SSL *s ) ;
#line 2077
struct stack_st_X509_NAME *SSL_CTX_get0_CA_list(SSL_CTX *ctx ) ;
#line 2078
int SSL_add1_to_CA_list(SSL *ssl , X509 *x ) ;
#line 2079
int SSL_CTX_add1_to_CA_list(SSL_CTX *ctx , X509 *x ) ;
#line 2080
struct stack_st_X509_NAME *SSL_get0_peer_CA_list(SSL *s ) ;
#line 2082
void SSL_set_client_CA_list(SSL *s , struct stack_st_X509_NAME *name_list ) ;
#line 2083
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx , struct stack_st_X509_NAME *name_list ) ;
#line 2084
struct stack_st_X509_NAME *SSL_get_client_CA_list(SSL *s ) ;
#line 2085
struct stack_st_X509_NAME *SSL_CTX_get_client_CA_list(SSL_CTX *s ) ;
#line 2086
int SSL_add_client_CA(SSL *ssl , X509 *x ) ;
#line 2087
int SSL_CTX_add_client_CA(SSL_CTX *ctx , X509 *x ) ;
#line 2089
void SSL_set_connect_state(SSL *s ) ;
#line 2090
void SSL_set_accept_state(SSL *s ) ;
#line 2092
long SSL_get_default_timeout(SSL *s ) ;
#line 2098
char *SSL_CIPHER_description(SSL_CIPHER * , char *buf , int size ) ;
#line 2099
struct stack_st_X509_NAME *SSL_dup_CA_list(struct stack_st_X509_NAME *sk ) ;
#line 2101
SSL *SSL_dup(SSL *ssl ) ;
#line 2103
X509 *SSL_get_certificate(SSL *ssl ) ;
#line 2107
struct evp_pkey_st *SSL_get_privatekey(SSL *ssl ) ;
#line 2109
X509 *SSL_CTX_get0_certificate(SSL_CTX *ctx ) ;
#line 2110
EVP_PKEY *SSL_CTX_get0_privatekey(SSL_CTX *ctx ) ;
#line 2112
void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx , int mode ) ;
#line 2113
int SSL_CTX_get_quiet_shutdown(SSL_CTX *ctx ) ;
#line 2114
void SSL_set_quiet_shutdown(SSL *ssl , int mode ) ;
#line 2115
int SSL_get_quiet_shutdown(SSL *ssl ) ;
#line 2116
void SSL_set_shutdown(SSL *ssl , int mode ) ;
#line 2117
int SSL_get_shutdown(SSL *ssl ) ;
#line 2118
int SSL_version(SSL *ssl ) ;
#line 2119
int SSL_client_version(SSL *s ) ;
#line 2120
int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx ) ;
#line 2121
int SSL_CTX_set_default_verify_dir(SSL_CTX *ctx ) ;
#line 2122
int SSL_CTX_set_default_verify_file(SSL_CTX *ctx ) ;
#line 2123
int SSL_CTX_set_default_verify_store(SSL_CTX *ctx ) ;
#line 2124
int SSL_CTX_load_verify_file(SSL_CTX *ctx , char const   *CAfile ) ;
#line 2125
int SSL_CTX_load_verify_dir(SSL_CTX *ctx , char const   *CApath ) ;
#line 2126
int SSL_CTX_load_verify_store(SSL_CTX *ctx , char const   *CAstore ) ;
#line 2127
int SSL_CTX_load_verify_locations(SSL_CTX *ctx , char const   *CAfile , char const   *CApath ) ;
#line 2131
SSL_SESSION *SSL_get_session(SSL *ssl ) ;
#line 2132
SSL_SESSION *SSL_get1_session(SSL *ssl ) ;
#line 2133
SSL_CTX *SSL_get_SSL_CTX(SSL *ssl ) ;
#line 2134
SSL_CTX *SSL_set_SSL_CTX(SSL *ssl , SSL_CTX *ctx ) ;
#line 2135
void SSL_set_info_callback(SSL *ssl , void (*cb)(SSL * , int  , int  ) ) ;
#line 2137
void (*SSL_get_info_callback(SSL *ssl ))(SSL * , int  , int  ) ;
#line 2139
OSSL_HANDSHAKE_STATE SSL_get_state(SSL *ssl ) ;
#line 2141
void SSL_set_verify_result(SSL *ssl , long v ) ;
#line 2142
long SSL_get_verify_result(SSL *ssl ) ;
#line 2143
struct stack_st_X509 *SSL_get0_verified_chain(SSL *s ) ;
#line 2145
size_t SSL_get_client_random(SSL *ssl , unsigned char *out , size_t outlen ) ;
#line 2147
size_t SSL_get_server_random(SSL *ssl , unsigned char *out , size_t outlen ) ;
#line 2149
size_t SSL_SESSION_get_master_key(SSL_SESSION *sess , unsigned char *out , size_t outlen ) ;
#line 2151
int SSL_SESSION_set1_master_key(SSL_SESSION *sess , unsigned char const   *in , size_t len ) ;
#line 2153
uint8_t SSL_SESSION_get_max_fragment_length(SSL_SESSION *sess ) ;
#line 2157
int SSL_set_ex_data(SSL *ssl , int idx , void *data ) ;
#line 2158
void *SSL_get_ex_data(SSL *ssl , int idx ) ;
#line 2161
int SSL_SESSION_set_ex_data(SSL_SESSION *ss , int idx , void *data ) ;
#line 2162
void *SSL_SESSION_get_ex_data(SSL_SESSION *ss , int idx ) ;
#line 2165
int SSL_CTX_set_ex_data(SSL_CTX *ssl , int idx , void *data ) ;
#line 2166
void *SSL_CTX_get_ex_data(SSL_CTX *ssl , int idx ) ;
#line 2168
int SSL_get_ex_data_X509_STORE_CTX_idx(void) ;
#line 2209
void SSL_CTX_set_default_read_buffer_len(SSL_CTX *ctx , size_t len ) ;
#line 2210
void SSL_set_default_read_buffer_len(SSL *s , size_t len ) ;
#line 2216
void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx , DH *(*dh)(SSL * , int  , int  ) ) ;
#line 2220
void SSL_set_tmp_dh_callback(SSL *ssl , DH *(*dh)(SSL * , int  , int  ) ) ;
#line 2226
COMP_METHOD *SSL_get_current_compression(SSL *s ) ;
#line 2227
COMP_METHOD *SSL_get_current_expansion(SSL *s ) ;
#line 2228
char const   *SSL_COMP_get_name(COMP_METHOD *comp ) ;
#line 2229
char const   *SSL_COMP_get0_name(SSL_COMP *comp ) ;
#line 2230
int SSL_COMP_get_id(SSL_COMP *comp ) ;
#line 2231
struct stack_st_SSL_COMP *SSL_COMP_get_compression_methods(void) ;
#line 2232
struct stack_st_SSL_COMP *SSL_COMP_set0_compression_methods(struct stack_st_SSL_COMP *meths ) ;
#line 2237
int SSL_COMP_add_compression_method(int id , COMP_METHOD *cm ) ;
#line 2239
SSL_CIPHER *SSL_CIPHER_find(SSL *ssl , unsigned char const   *ptr ) ;
#line 2240
int SSL_CIPHER_get_cipher_nid(SSL_CIPHER *c ) ;
#line 2241
int SSL_CIPHER_get_digest_nid(SSL_CIPHER *c ) ;
#line 2242
int SSL_bytes_to_cipher_list(SSL *s , unsigned char const   *bytes , size_t len ,
                             int isv2format , struct stack_st_SSL_CIPHER **sk , struct stack_st_SSL_CIPHER **scsvs ) ;
#line 2247
int SSL_set_session_ticket_ext(SSL *s , void *ext_data , int ext_len ) ;
#line 2249
int SSL_set_session_ticket_ext_cb(SSL *s , tls_session_ticket_ext_cb_fn cb , void *arg ) ;
#line 2254
int SSL_set_session_secret_cb(SSL *s , tls_session_secret_cb_fn session_secret_cb ,
                              void *arg ) ;
#line 2258
void SSL_CTX_set_not_resumable_session_callback(SSL_CTX *ctx , int (*cb)(SSL * , int  ) ) ;
#line 2263
void SSL_set_not_resumable_session_callback(SSL *ssl , int (*cb)(SSL * , int  ) ) ;
#line 2267
void SSL_CTX_set_record_padding_callback(SSL_CTX *ctx , size_t (*cb)(SSL * , int  ,
                                                                     size_t  , void * ) ) ;
#line 2270
void SSL_CTX_set_record_padding_callback_arg(SSL_CTX *ctx , void *arg ) ;
#line 2271
void *SSL_CTX_get_record_padding_callback_arg(SSL_CTX *ctx ) ;
#line 2272
int SSL_CTX_set_block_padding(SSL_CTX *ctx , size_t block_size ) ;
#line 2274
int SSL_set_record_padding_callback(SSL *ssl , size_t (*cb)(SSL * , int  , size_t  ,
                                                            void * ) ) ;
#line 2277
void SSL_set_record_padding_callback_arg(SSL *ssl , void *arg ) ;
#line 2278
void *SSL_get_record_padding_callback_arg(SSL *ssl ) ;
#line 2279
int SSL_set_block_padding(SSL *ssl , size_t block_size ) ;
#line 2281
int SSL_set_num_tickets(SSL *s , size_t num_tickets ) ;
#line 2282
size_t SSL_get_num_tickets(SSL *s ) ;
#line 2283
int SSL_CTX_set_num_tickets(SSL_CTX *ctx , size_t num_tickets ) ;
#line 2284
size_t SSL_CTX_get_num_tickets(SSL_CTX *ctx ) ;
#line 2290
int SSL_session_reused(SSL *s ) ;
#line 2291
int SSL_is_server(SSL *s ) ;
#line 2293
SSL_CONF_CTX *SSL_CONF_CTX_new(void) ;
#line 2294
int SSL_CONF_CTX_finish(SSL_CONF_CTX *cctx ) ;
#line 2295
void SSL_CONF_CTX_free(SSL_CONF_CTX *cctx ) ;
#line 2296
unsigned int SSL_CONF_CTX_set_flags(SSL_CONF_CTX *cctx , unsigned int flags ) ;
#line 2297
unsigned int SSL_CONF_CTX_clear_flags(SSL_CONF_CTX *cctx , unsigned int flags ) ;
#line 2299
int SSL_CONF_CTX_set1_prefix(SSL_CONF_CTX *cctx , char const   *pre ) ;
#line 2301
void SSL_CONF_CTX_set_ssl(SSL_CONF_CTX *cctx , SSL *ssl ) ;
#line 2302
void SSL_CONF_CTX_set_ssl_ctx(SSL_CONF_CTX *cctx , SSL_CTX *ctx ) ;
#line 2304
int SSL_CONF_cmd(SSL_CONF_CTX *cctx , char const   *cmd , char const   *value ) ;
#line 2305
int SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx , int *pargc , char ***pargv ) ;
#line 2306
int SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx , char const   *cmd ) ;
#line 2308
void SSL_add_ssl_module(void) ;
#line 2309
int SSL_config(SSL *s , char const   *name ) ;
#line 2310
int SSL_CTX_config(SSL_CTX *ctx , char const   *name ) ;
#line 2313
void SSL_trace(int write_p , int version , int content_type , void const   *buf ,
               size_t len , SSL *ssl , void *arg ) ;
#line 2318
int DTLSv1_listen(SSL *s , BIO_ADDR *client ) ;
#line 2344
int SSL_set_ct_validation_callback(SSL *s , ssl_ct_validation_cb callback , void *arg ) ;
#line 2346
int SSL_CTX_set_ct_validation_callback(SSL_CTX *ctx , ssl_ct_validation_cb callback ,
                                       void *arg ) ;
#line 2372
int SSL_enable_ct(SSL *s , int validation_mode ) ;
#line 2373
int SSL_CTX_enable_ct(SSL_CTX *ctx , int validation_mode ) ;
#line 2378
int SSL_ct_is_enabled(SSL *s ) ;
#line 2379
int SSL_CTX_ct_is_enabled(SSL_CTX *ctx ) ;
#line 2382
struct stack_st_SCT *SSL_get0_peer_scts(SSL *s ) ;
#line 2391
int SSL_CTX_set_default_ctlog_list_file(SSL_CTX *ctx ) ;
#line 2400
int SSL_CTX_set_ctlog_list_file(SSL_CTX *ctx , char const   *path ) ;
#line 2406
void SSL_CTX_set0_ctlog_store(SSL_CTX *ctx , CTLOG_STORE *logs ) ;
#line 2415
CTLOG_STORE *SSL_CTX_get0_ctlog_store(SSL_CTX *ctx ) ;
#line 2477
void SSL_set_security_level(SSL *s , int level ) ;
#line 2478
int SSL_get_security_level(SSL *s ) ;
#line 2479
void SSL_set_security_callback(SSL *s , int (*cb)(SSL * , SSL_CTX * , int  , int  ,
                                                  int  , void * , void * ) ) ;
#line 2483
int (*SSL_get_security_callback(SSL *s ))(SSL * , SSL_CTX * , int  , int  , int  ,
                                          void * , void * ) ;
#line 2487
void SSL_set0_security_ex_data(SSL *s , void *ex ) ;
#line 2488
void *SSL_get0_security_ex_data(SSL *s ) ;
#line 2490
void SSL_CTX_set_security_level(SSL_CTX *ctx , int level ) ;
#line 2491
int SSL_CTX_get_security_level(SSL_CTX *ctx ) ;
#line 2492
void SSL_CTX_set_security_callback(SSL_CTX *ctx , int (*cb)(SSL * , SSL_CTX * , int  ,
                                                            int  , int  , void * ,
                                                            void * ) ) ;
#line 2496
int (*SSL_CTX_get_security_callback(SSL_CTX *ctx ))(SSL * , SSL_CTX * , int  , int  ,
                                                    int  , void * , void * ) ;
#line 2502
void SSL_CTX_set0_security_ex_data(SSL_CTX *ctx , void *ex ) ;
#line 2503
void *SSL_CTX_get0_security_ex_data(SSL_CTX *ctx ) ;
#line 2512
int OPENSSL_init_ssl(uint64_t opts , OPENSSL_INIT_SETTINGS *settings ) ;
#line 2515
struct openssl_ssl_test_functions *SSL_test_functions(void) ;
#line 2518
int SSL_free_buffers(SSL *ssl ) ;
#line 2519
int SSL_alloc_buffers(SSL *ssl ) ;
#line 2561
int SSL_CTX_set_session_ticket_cb(SSL_CTX *ctx , SSL_CTX_generate_session_ticket_fn gen_cb ,
                                  SSL_CTX_decrypt_session_ticket_fn dec_cb , void *arg ) ;
#line 2565
int SSL_SESSION_set1_ticket_appdata(SSL_SESSION *ss , void const   *data , size_t len ) ;
#line 2566
int SSL_SESSION_get0_ticket_appdata(SSL_SESSION *ss , void **data , size_t *len ) ;
#line 2570
void DTLS_set_timer_cb(SSL *s , DTLS_timer_cb cb ) ;
#line 2574
void SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx , SSL_allow_early_data_cb_fn cb ,
                                     void *arg ) ;
#line 2577
void SSL_set_allow_early_data_cb(SSL *s , SSL_allow_early_data_cb_fn cb , void *arg ) ;
#line 2582
char const   *OSSL_default_cipher_list(void) ;
#line 2583
char const   *OSSL_default_ciphersuites(void) ;
#line 88 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(int *__stat_loc ) ;
#line 111
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 132
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
#line 148
extern  __attribute__((__nothrow__)) __pid_t wait3(int *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 164
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , int *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 307 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 316
  if ((size_t )__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 318
    return ((struct cmsghdr *)0);
  }
#line 320
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))));
#line 322
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  } else
#line 322
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  }
#line 328
  return (__cmsg);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 108
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int __fds[2] ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr *__addr ,
                                              socklen_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr *__addr ,
                                                     socklen_t *__len ) ;
#line 126
extern int connect(int __fd , struct sockaddr *__addr , socklen_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr *__addr ,
                                                     socklen_t *__len ) ;
#line 138
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 145
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 152
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr *__addr , socklen_t __addr_len ) ;
#line 163
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 174
extern ssize_t sendmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 216
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 255
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void *__optval , socklen_t *__optlen ) ;
#line 277
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 296
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 306
extern int accept(int __fd , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 324
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 329
extern  __attribute__((__nothrow__)) int sockatmark(int __fd ) ;
#line 337
extern  __attribute__((__nothrow__)) int isfdtype(int __fd , int __fdtype ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) ;
#line 34
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  ssize_t __cil_tmp13 ;

  {
  {
#line 36
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 36
  sz = __cil_tmp6;
#line 37
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 37
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 37
  if (__cil_tmp8) {
#line 37
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 38
      __cil_tmp9 = __recv_alias(__fd, __buf, __n, __flags);
      }
#line 38
      return (__cil_tmp9);
    }
  }
  {
#line 39
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 39
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 39
  if (__cil_tmp11) {
#line 39
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 40
      __cil_tmp12 = __recv_chk_warn(__fd, __buf, __n, sz, __flags);
      }
#line 40
      return (__cil_tmp12);
    }
  }
  {
#line 41
  __cil_tmp13 = __recv_chk(__fd, __buf, __n, sz, __flags);
  }
#line 41
  return (__cil_tmp13);
}
}
#line 44
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 48
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 52
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , struct sockaddr *__addr , socklen_t *__addr_len ) ;
#line 61
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 struct sockaddr *__addr , socklen_t *__addr_len ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__buf, 0);
#line 64
  sz = __cil_tmp8;
#line 65
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 65
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 65
  if (__cil_tmp10) {
#line 65
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 66
      __cil_tmp11 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
      }
#line 66
      return (__cil_tmp11);
    }
  }
  {
#line 67
  __cil_tmp13 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 67
  __cil_tmp12 = __builtin_constant_p(__n);
  }
#line 67
  if (__cil_tmp13) {
#line 67
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 68
      __cil_tmp14 = __recvfrom_chk_warn(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
      }
#line 68
      return (__cil_tmp14);
    }
  }
  {
#line 70
  __cil_tmp15 = __recvfrom_chk(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
  }
#line 70
  return (__cil_tmp15);
}
}
#line 235 "/usr/include/netinet/in.h"
extern struct in6_addr in6addr_any ;
#line 236
extern struct in6_addr in6addr_loopback ;
#line 382
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong ) ;
#line 383
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort ) ;
#line 385
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong ) ;
#line 387
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort ) ;
#line 510
extern  __attribute__((__nothrow__)) int bindresvport(int __sockfd , struct sockaddr_in *__sock_in ) ;
#line 513
extern  __attribute__((__nothrow__)) int bindresvport6(int __sockfd , struct sockaddr_in6 *__sock_in ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 37
extern  __attribute__((__nothrow__)) in_addr_t inet_lnaof(struct in_addr __in ) ;
#line 41
extern  __attribute__((__nothrow__)) struct in_addr inet_makeaddr(in_addr_t __net ,
                                                                  in_addr_t __host ) ;
#line 45
extern  __attribute__((__nothrow__)) in_addr_t inet_netof(struct in_addr __in ) ;
#line 49
extern  __attribute__((__nothrow__)) in_addr_t inet_network(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 58
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   *__cp ,
                                                   void *__buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   *__cp ,
                                                             char *__buf , socklen_t __len ) ;
#line 73
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 77
extern  __attribute__((__nothrow__)) char *inet_neta(in_addr_t __net , char *__buf ,
                                                     size_t __len ) ;
#line 83
extern  __attribute__((__nothrow__)) char *inet_net_ntop(int __af , void const   *__cp ,
                                                         int __bits , char *__buf ,
                                                         size_t __len ) ;
#line 89
extern  __attribute__((__nothrow__)) int inet_net_pton(int __af , char const   *__cp ,
                                                       void *__buf , size_t __len ) ;
#line 95
extern  __attribute__((__nothrow__)) unsigned int inet_nsap_addr(char const   *__cp ,
                                                                 unsigned char *__buf ,
                                                                 int __len ) ;
#line 100
extern  __attribute__((__nothrow__)) char *inet_nsap_ntoa(int __len , unsigned char const   *__cp ,
                                                          char *__buf ) ;
#line 53 "/usr/include/rpc/netdb.h"
extern  __attribute__((__nothrow__)) void setrpcent(int __stayopen ) ;
#line 54
extern  __attribute__((__nothrow__)) void endrpcent(void) ;
#line 55
extern  __attribute__((__nothrow__)) struct rpcent *getrpcbyname(char const   *__name ) ;
#line 56
extern  __attribute__((__nothrow__)) struct rpcent *getrpcbynumber(int __number ) ;
#line 57
extern  __attribute__((__nothrow__)) struct rpcent *getrpcent(void) ;
#line 60
extern  __attribute__((__nothrow__)) int getrpcbyname_r(char const   *__name , struct rpcent *__result_buf ,
                                                        char *__buffer , size_t __buflen ,
                                                        struct rpcent **__result ) ;
#line 64
extern  __attribute__((__nothrow__)) int getrpcbynumber_r(int __number , struct rpcent *__result_buf ,
                                                          char *__buffer , size_t __buflen ,
                                                          struct rpcent **__result ) ;
#line 68
extern  __attribute__((__nothrow__)) int getrpcent_r(struct rpcent *__result_buf ,
                                                     char *__buffer , size_t __buflen ,
                                                     struct rpcent **__result ) ;
#line 59 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *__h_errno_location(void) ;
#line 90
extern  __attribute__((__nothrow__)) void herror(char const   *__str ) ;
#line 93
extern  __attribute__((__nothrow__)) char const   *hstrerror(int __err_num ) ;
#line 115
extern void sethostent(int __stay_open ) ;
#line 121
extern void endhostent(void) ;
#line 128
extern struct hostent *gethostent(void) ;
#line 135
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 142
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 153
extern struct hostent *gethostbyname2(char const   *__name , int __af ) ;
#line 165
extern int gethostent_r(struct hostent *__result_buf , char *__buf , size_t __buflen ,
                        struct hostent **__result , int *__h_errnop ) ;
#line 170
extern int gethostbyaddr_r(void const   *__addr , __socklen_t __len , int __type ,
                           struct hostent *__result_buf , char *__buf , size_t __buflen ,
                           struct hostent **__result , int *__h_errnop ) ;
#line 177
extern int gethostbyname_r(char const   *__name , struct hostent *__result_buf , char *__buf ,
                           size_t __buflen , struct hostent **__result , int *__h_errnop ) ;
#line 183
extern int gethostbyname2_r(char const   *__name , int __af , struct hostent *__result_buf ,
                            char *__buf , size_t __buflen , struct hostent **__result ,
                            int *__h_errnop ) ;
#line 196
extern void setnetent(int __stay_open ) ;
#line 202
extern void endnetent(void) ;
#line 209
extern struct netent *getnetent(void) ;
#line 216
extern struct netent *getnetbyaddr(uint32_t __net , int __type ) ;
#line 222
extern struct netent *getnetbyname(char const   *__name ) ;
#line 235
extern int getnetent_r(struct netent *__result_buf , char *__buf , size_t __buflen ,
                       struct netent **__result , int *__h_errnop ) ;
#line 240
extern int getnetbyaddr_r(uint32_t __net , int __type , struct netent *__result_buf ,
                          char *__buf , size_t __buflen , struct netent **__result ,
                          int *__h_errnop ) ;
#line 246
extern int getnetbyname_r(char const   *__name , struct netent *__result_buf , char *__buf ,
                          size_t __buflen , struct netent **__result , int *__h_errnop ) ;
#line 268
extern void setservent(int __stay_open ) ;
#line 274
extern void endservent(void) ;
#line 281
extern struct servent *getservent(void) ;
#line 288
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 295
extern struct servent *getservbyport(int __port , char const   *__proto ) ;
#line 306
extern int getservent_r(struct servent *__result_buf , char *__buf , size_t __buflen ,
                        struct servent **__result ) ;
#line 310
extern int getservbyname_r(char const   *__name , char const   *__proto , struct servent *__result_buf ,
                           char *__buf , size_t __buflen , struct servent **__result ) ;
#line 316
extern int getservbyport_r(int __port , char const   *__proto , struct servent *__result_buf ,
                           char *__buf , size_t __buflen , struct servent **__result ) ;
#line 336
extern void setprotoent(int __stay_open ) ;
#line 342
extern void endprotoent(void) ;
#line 349
extern struct protoent *getprotoent(void) ;
#line 355
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 361
extern struct protoent *getprotobynumber(int __proto ) ;
#line 372
extern int getprotoent_r(struct protoent *__result_buf , char *__buf , size_t __buflen ,
                         struct protoent **__result ) ;
#line 376
extern int getprotobyname_r(char const   *__name , struct protoent *__result_buf ,
                            char *__buf , size_t __buflen , struct protoent **__result ) ;
#line 381
extern int getprotobynumber_r(int __proto , struct protoent *__result_buf , char *__buf ,
                              size_t __buflen , struct protoent **__result ) ;
#line 393
extern int setnetgrent(char const   *__netgroup ) ;
#line 401
extern void endnetgrent(void) ;
#line 410
extern int getnetgrent(char **__hostp , char **__userp , char **__domainp ) ;
#line 421
extern int innetgr(char const   *__netgroup , char const   *__host , char const   *__user ,
                   char const   *__domain ) ;
#line 430
extern int getnetgrent_r(char **__hostp , char **__userp , char **__domainp , char *__buffer ,
                         size_t __buflen ) ;
#line 449
extern int rcmd(char **__ahost , unsigned short __rport , char const   *__locuser ,
                char const   *__remuser , char const   *__cmd , int *__fd2p ) ;
#line 461
extern int rcmd_af(char **__ahost , unsigned short __rport , char const   *__locuser ,
                   char const   *__remuser , char const   *__cmd , int *__fd2p , sa_family_t __af ) ;
#line 477
extern int rexec(char **__ahost , int __rport , char const   *__name , char const   *__pass ,
                 char const   *__cmd , int *__fd2p ) ;
#line 489
extern int rexec_af(char **__ahost , int __rport , char const   *__name , char const   *__pass ,
                    char const   *__cmd , int *__fd2p , sa_family_t __af ) ;
#line 503
extern int ruserok(char const   *__rhost , int __suser , char const   *__remuser ,
                   char const   *__locuser ) ;
#line 513
extern int ruserok_af(char const   *__rhost , int __suser , char const   *__remuser ,
                      char const   *__locuser , sa_family_t __af ) ;
#line 526
extern int iruserok(uint32_t __raddr , int __suser , char const   *__remuser , char const   *__locuser ) ;
#line 537
extern int iruserok_af(void const   *__raddr , int __suser , char const   *__remuser ,
                       char const   *__locuser , sa_family_t __af ) ;
#line 549
extern int rresvport(int *__alport ) ;
#line 558
extern int rresvport_af(int *__alport , sa_family_t __af ) ;
#line 660
extern int getaddrinfo(char const   *__name , char const   *__service , struct addrinfo *__req ,
                       struct addrinfo **__pai ) ;
#line 666
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 669
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
#line 675
extern int getnameinfo(struct sockaddr *__sa , socklen_t __salen , char *__host ,
                       socklen_t __hostlen , char *__serv , socklen_t __servlen ,
                       int __flags ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 255
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 109 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
char *ccpacket_emes(ccpacket_err rv ) 
{ 
  char *__cil_tmp2 ;

  {
#line 111
  if ((unsigned int )rv & 268435456U) {
    {
#line 112
    __cil_tmp2 = ccpacket_emes((ccpacket_err )((unsigned int )rv & 268435455U));
    }
#line 112
    return (__cil_tmp2);
  }
  {
#line 117
  if ((unsigned int )rv == (unsigned int )0) {
#line 117
    goto case_0;
  }
#line 119
  if ((unsigned int )rv == (unsigned int )2) {
#line 119
    goto case_2;
  }
#line 121
  if ((unsigned int )rv == (unsigned int )1) {
#line 121
    goto case_1;
  }
#line 123
  if ((unsigned int )rv == (unsigned int )3) {
#line 123
    goto case_3;
  }
#line 125
  if ((unsigned int )rv == (unsigned int )4) {
#line 125
    goto case_4;
  }
#line 128
  if ((unsigned int )rv == (unsigned int )5) {
#line 128
    goto case_5;
  }
#line 130
  if ((unsigned int )rv == (unsigned int )6) {
#line 130
    goto case_6;
  }
#line 132
  if ((unsigned int )rv == (unsigned int )7) {
#line 132
    goto case_7;
  }
#line 116
  goto switch_break;
  case_0: /* CIL Label */ 
#line 118
  return ("Packet: OK");
  case_2: /* CIL Label */ 
#line 120
  return ("Packet: getting a ssl contextfailed");
  case_1: /* CIL Label */ 
#line 122
  return ("Packet: malloc failed");
  case_3: /* CIL Label */ 
#line 124
  return ("Packet: connecting to host failed");
  case_4: /* CIL Label */ 
#line 126
  return ("Packet: ssl connect to host failed");
  case_5: /* CIL Label */ 
#line 129
  return ("Packet:: i/o timed out");
  case_6: /* CIL Label */ 
#line 131
  return ("Packet: message failed to send");
  case_7: /* CIL Label */ 
#line 133
  return ("Packet: failed to read message");
  switch_break: /* CIL Label */ ;
  }
#line 136
  return ("Unknown ccpacket error");
}
}
#line 140 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static ccpacket_err connect_ccpacket_imp(ccpacket___0 *p ) 
{ 
  struct sockaddr_in server ;
  uint8_t sesid[32] ;
  unsigned int tmp ;
  int rv ;
  in_addr_t __cil_tmp6 ;
  __uint16_t __cil_tmp7 ;
  SSL_METHOD *__cil_tmp8 ;
  SSL_CTX *__cil_tmp9 ;
  int __cil_tmp10 ;
  struct linger ling ;
  struct timeval tv ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  SSL *__cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 144
  sesid[0] = (uint8_t )0;
#line 144
  tmp = (unsigned int )1;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (tmp >= 32) {
#line 144
      goto while_break;
    }
#line 144
    sesid[tmp] = 0;
#line 144
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  server.sin_family = (sa_family_t )2;
#line 153
  server.sin_addr.s_addr = inet_addr((char const   *)p->dip);
#line 154
  server.sin_port = __bswap_16((__uint16_t )((short )p->dport));
#line 163
  __cil_tmp8 = TLS_client_method();
#line 163
  __cil_tmp9 = SSL_CTX_new(__cil_tmp8);
#line 163
  p->ctx = __cil_tmp9;
  }
#line 163
  if (p->ctx == (void *)0) {

#line 167
    return ((ccpacket_err )2);
  }
  {
#line 176
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS *)((void *)0));
#line 181
  p->sock = socket(2, 1, 6);
  }
#line 181
  if (p->sock == -1) {

#line 183
    return ((ccpacket_err )3);
  }
  {
#line 213
  tv.tv_sec = (__time_t )2;
#line 214
  tv.tv_usec = (__suseconds_t )0;
#line 216
  rv = setsockopt(p->sock, 1, 20, (char const   *)(& tv), (socklen_t )sizeof(tv));
  }
#line 216
  if (rv < 0) {

#line 219
    return ((ccpacket_err )3);
  }
  {
#line 221
  tv.tv_sec = (__time_t )2;
#line 222
  tv.tv_usec = (__suseconds_t )0;
#line 223
  rv = setsockopt(p->sock, 1, 21, (char const   *)(& tv), (socklen_t )sizeof(tv));
  }
#line 223
  if (rv < 0) {

#line 226
    return ((ccpacket_err )3);
  }
  {
#line 242
  rv = connect(p->sock, (struct sockaddr *)(& server), (socklen_t )sizeof(server));
  }
#line 242
  if (rv != 0) {

#line 244
    return ((ccpacket_err )3);
  }
  {
#line 254
  __cil_tmp18 = SSL_connect(p->ssl);
  }
  {
#line 254
  __cil_tmp17 = SSL_set_fd(p->ssl, p->sock);
  }
  {
#line 254
  p->ssl = SSL_new(p->ctx);
  }
#line 254
  if (p->ssl == (void *)0) {

#line 260
    return ((ccpacket_err )4);
  } else
#line 254
  if (__cil_tmp17 != 1) {

#line 260
    return ((ccpacket_err )4);
  } else
#line 254
  if (__cil_tmp18 != 1) {

#line 260
    return ((ccpacket_err )4);
  }

#line 263
  return ((ccpacket_err )0);
}
}
#line 267 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static ccpacket_err connect_ccpacket(ccpacket___0 *p , char *dip , int dport ) 
{ 
  char *__cil_tmp4 ;
  ccpacket_err __cil_tmp5 ;

  {
  {
#line 273
  p->dip = strdup((char const   *)dip);
  }
#line 273
  if (p->dip == (void *)0) {
#line 274
    return ((ccpacket_err )1);
  }
  {
#line 275
  p->dport = dport;
#line 277
  __cil_tmp5 = connect_ccpacket_imp(p);
  }
#line 277
  return (__cil_tmp5);
}
}
#line 280
static void clear_ccpacket(ccpacket___0 *p ) ;
#line 283 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static ccpacket_err re_connect_ccpacket(ccpacket___0 *p ) 
{ 
  ccpacket_err __cil_tmp2 ;

  {
  {
#line 286
  clear_ccpacket(p);
#line 287
  __cil_tmp2 = connect_ccpacket_imp(p);
  }
#line 287
  return (__cil_tmp2);
}
}
#line 299 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static ccpacket_err send_ccpacket(ccpacket___0 *p , uint8_t *buf , uint32_t len ) 
{ 
  int lens ;
  int ilen ;
  uint8_t *sbuf ;
  uint32_t slen ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 306
  if (p->ssl == (void *)0) {
#line 307
    return ((ccpacket_err )4);
  }
  {
#line 309
  sbuf = (uint8_t *)malloc((unsigned long )(4U + len));
  }
#line 309
  if (sbuf == (void *)0) {
#line 310
    return ((ccpacket_err )1);
  }
  {
#line 313
  write_ORD32_be(sbuf, len);
#line 314
  memcpy(sbuf + 4, buf, (unsigned long )len);
#line 315
  slen = len + 4U;
#line 322
  lens = 0;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! ((unsigned int )lens < slen)) {
#line 322
      goto while_break;
    }

#line 324
    if (p->ssl == (void *)0) {
#line 325
      return ((ccpacket_err )4);
    }
    {
#line 334
    ilen = SSL_write(p->ssl, sbuf + lens, (int )(slen - (unsigned int )lens));
    }
#line 334
    if (ilen < 0) {
      {
#line 346
      free(sbuf);
#line 351
      __cil_tmp11 = SSL_get_error(p->ssl, ilen);
      }
      {
#line 351
      __cil_tmp10 = SSL_get_error(p->ssl, ilen);
      }
#line 351
      if (__cil_tmp10 == 2) {
#line 354
        return ((ccpacket_err )5);
      } else
#line 351
      if (__cil_tmp11 == 3) {
#line 354
        return ((ccpacket_err )5);
      }
#line 355
      return ((ccpacket_err )6);
    }
#line 322
    lens += ilen;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 362
  free(sbuf);
  }
#line 364
  return ((ccpacket_err )0);
}
}
#line 369 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static ccpacket_err receive_ccpacket(ccpacket___0 *p , uint8_t **pbuf , uint32_t *plen ) 
{ 
  uint8_t *ibuf ;
  int ioff ;
  int ilen ;
  uint8_t hbuf[4] ;
  uint8_t *rbuf ;
  int tlen ;
  int clen ;
  int rlen ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;

  {
#line 374
  rbuf = (uint8_t *)hbuf;
#line 377
  if (p->ssl == (void *)0) {
#line 378
    return ((ccpacket_err )4);
  }
  {
#line 385
  tlen = 4;
#line 388
  ibuf = (uint8_t *)malloc((unsigned long )tlen);
  }
#line 388
  if (ibuf == (void *)0) {
#line 389
    return ((ccpacket_err )1);
  }
#line 391
  *(ibuf + 2) = (uint8_t )0;
#line 391
  *(ibuf + 2) = *(ibuf + 2);
#line 391
  *(ibuf + 1) = *(ibuf + 2);
#line 391
  *(ibuf + 0) = *(ibuf + 1);
#line 395
  rlen = 0;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (rlen < tlen)) {
#line 395
      goto while_break;
    }
    {
#line 396
    ioff = 0;
#line 400
    ilen = SSL_read(p->ssl, ibuf, tlen);
    }
#line 400
    if (ilen < 0) {
      {
#line 415
      free(ibuf);
#line 416
      __cil_tmp15 = SSL_get_error(p->ssl, ilen);
      }
      {
#line 416
      __cil_tmp14 = SSL_get_error(p->ssl, ilen);
      }
#line 416
      if (__cil_tmp14 == 2) {
#line 419
        return ((ccpacket_err )5);
      } else
#line 416
      if (__cil_tmp15 == 3) {
#line 419
        return ((ccpacket_err )5);
      }
#line 420
      return ((ccpacket_err )7);
    }

#line 423
    if (ilen == 0) {
      {
#line 428
      free(ibuf);
      }
#line 429
      return ((ccpacket_err )7);
    }
#line 432
    clen = ilen;
#line 432
    if (clen > tlen - rlen) {
#line 433
      clen = tlen - rlen;
    }
    {
#line 434
    memcpy(rbuf + rlen, ibuf + ioff, (unsigned long )clen);
#line 435
    rlen += clen;
#line 436
    ioff += clen;
#line 437
    ilen -= clen;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  __cil_tmp16 = read_ORD32_be(rbuf);
#line 442
  tlen = (int )__cil_tmp16;
  }
#line 445
  if (tlen < 0) {

#line 451
    return ((ccpacket_err )7);
  } else
#line 445
  if (tlen > 128896) {

#line 451
    return ((ccpacket_err )7);
  }
  {
#line 454
  rbuf = (uint8_t *)malloc((unsigned long )tlen);
  }
#line 454
  if (rbuf == (void *)0) {

#line 460
    return ((ccpacket_err )1);
  }
#line 462
  rlen = 0;
#line 465
  if (ilen > 0) {
#line 466
    clen = ilen;
#line 466
    if (clen > tlen - rlen) {
#line 467
      clen = tlen - rlen;
    }
    {
#line 469
    memcpy(rbuf + rlen, ibuf + ioff, (unsigned long )clen);
#line 470
    rlen += clen;
#line 471
    ioff += clen;
#line 472
    ilen -= clen;
    }
  }
  {
#line 476
  free(ibuf);
#line 477
  ibuf = (uint8_t *)malloc((unsigned long )tlen);
  }
#line 477
  if (ibuf == (void *)0) {
#line 478
    return ((ccpacket_err )1);
  }
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! (rlen < tlen)) {
#line 483
      goto while_break___0;
    }
    {
#line 484
    ioff = 0;
#line 488
    ilen = SSL_read(p->ssl, ibuf, tlen);
    }
#line 488
    if (ilen < 0) {
      {
#line 503
      free(ibuf);
#line 504
      __cil_tmp21 = SSL_get_error(p->ssl, ilen);
      }
      {
#line 504
      __cil_tmp20 = SSL_get_error(p->ssl, ilen);
      }
#line 504
      if (__cil_tmp20 == 2) {
#line 507
        return ((ccpacket_err )5);
      } else
#line 504
      if (__cil_tmp21 == 3) {
#line 507
        return ((ccpacket_err )5);
      }
#line 508
      return ((ccpacket_err )7);
    }

#line 511
    if (ilen == 0) {
      {
#line 516
      free(ibuf);
      }
#line 517
      return ((ccpacket_err )7);
    }
#line 520
    clen = ilen;
#line 520
    if (clen > tlen - rlen) {
#line 521
      clen = tlen - rlen;
    }
    {
#line 522
    memcpy(rbuf + rlen, ibuf + ioff, (unsigned long )clen);
#line 523
    rlen += clen;
#line 524
    ioff += clen;
#line 525
    ilen -= clen;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 531
  if (ilen > 0) {

  }
  {
#line 535
  free(ibuf);
#line 541
  *pbuf = rbuf;
#line 542
  *plen = (uint32_t )rlen;
  }
#line 544
  return ((ccpacket_err )0);
}
}
#line 548 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static void clear_ccpacket(ccpacket___0 *p ) 
{ 


  {
#line 549
  if (p != (void *)0) {
#line 551
    if (p->ssl != (void *)0) {
      {
#line 555
      SSL_free(p->ssl);
#line 557
      p->ssl = (SSL *)((void *)0);
      }
    }
#line 559
    if (p->ctx != (void *)0) {
      {
#line 563
      SSL_CTX_free(p->ctx);
#line 565
      p->ctx = (SSL_CTX *)((void *)0);
      }
    }
#line 567
    if (p->sock != -1) {
      {
#line 568
      close(p->sock);
#line 569
      p->sock = 0;
      }
    }
  }
  return;
}
}
#line 575 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
static void del_ccpacket(ccpacket___0 *p ) 
{ 


  {
#line 576
  if (p != (void *)0) {
    {
#line 577
    clear_ccpacket(p);
    }
#line 578
    if (p->dip != (void *)0) {
      {
#line 579
      free(p->dip);
#line 580
      p->dip = (char *)((void *)0);
      }
    }
    {
#line 585
    free(p);
    }
  }
  return;
}
}
#line 591 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccpacket.c"
ccpacket___0 *new_ccpacket(void) 
{ 
  ccpacket___0 *p ;
  void *__cil_tmp2 ;

  {
  {
#line 592
  p = (ccpacket___0 *)((void *)0);
#line 595
  OPENSSL_init_ssl((uint64_t )2097154L, (OPENSSL_INIT_SETTINGS *)((void *)0));
#line 596
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS *)((void *)0));
#line 599
  __cil_tmp2 = calloc((unsigned long )1, sizeof(ccpacket___0 ));
#line 599
  p = (ccpacket___0 *)__cil_tmp2;
  }
#line 599
  if (p == (void *)0) {

#line 601
    return ((ccpacket___0 *)((void *)0));
  }
#line 609
  p->del = & del_ccpacket;
#line 610
  p->connect = & connect_ccpacket;
#line 611
  p->reconnect = & re_connect_ccpacket;
#line 612
  p->send = & send_ccpacket;
#line 613
  p->receive = & receive_ccpacket;
#line 615
  return (p);
}
}
#line 7 "h/copyright.h"
static char __copyright_____3[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 119 "numlib/svd.h"
static void svdinverse___2(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 104 "ccast/chan/cast_channel.pb-c.h"
void extensions__api__cast_channel__cast_message__init(Extensions__Api__CastChannel__CastMessage *message ) ;
#line 106
size_t extensions__api__cast_channel__cast_message__get_packed_size(Extensions__Api__CastChannel__CastMessage *message ) ;
#line 108
size_t extensions__api__cast_channel__cast_message__pack(Extensions__Api__CastChannel__CastMessage *message ,
                                                         uint8_t *out ) ;
#line 111
size_t extensions__api__cast_channel__cast_message__pack_to_buffer(Extensions__Api__CastChannel__CastMessage *message ,
                                                                   ProtobufCBuffer *buffer ) ;
#line 115
Extensions__Api__CastChannel__CastMessage *extensions__api__cast_channel__cast_message__unpack(ProtobufCAllocator *allocator ,
                                                                                               size_t len ,
                                                                                               uint8_t *data ) ;
#line 119
void extensions__api__cast_channel__cast_message__free_unpacked(Extensions__Api__CastChannel__CastMessage *message ,
                                                                ProtobufCAllocator *allocator ) ;
#line 123
void extensions__api__cast_channel__auth_challenge__init(Extensions__Api__CastChannel__AuthChallenge *message ) ;
#line 125
size_t extensions__api__cast_channel__auth_challenge__get_packed_size(Extensions__Api__CastChannel__AuthChallenge *message ) ;
#line 127
size_t extensions__api__cast_channel__auth_challenge__pack(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                           uint8_t *out ) ;
#line 130
size_t extensions__api__cast_channel__auth_challenge__pack_to_buffer(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                                     ProtobufCBuffer *buffer ) ;
#line 134
Extensions__Api__CastChannel__AuthChallenge *extensions__api__cast_channel__auth_challenge__unpack(ProtobufCAllocator *allocator ,
                                                                                                   size_t len ,
                                                                                                   uint8_t *data ) ;
#line 138
void extensions__api__cast_channel__auth_challenge__free_unpacked(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                                  ProtobufCAllocator *allocator ) ;
#line 142
void extensions__api__cast_channel__auth_response__init(Extensions__Api__CastChannel__AuthResponse *message ) ;
#line 144
size_t extensions__api__cast_channel__auth_response__get_packed_size(Extensions__Api__CastChannel__AuthResponse *message ) ;
#line 146
size_t extensions__api__cast_channel__auth_response__pack(Extensions__Api__CastChannel__AuthResponse *message ,
                                                          uint8_t *out ) ;
#line 149
size_t extensions__api__cast_channel__auth_response__pack_to_buffer(Extensions__Api__CastChannel__AuthResponse *message ,
                                                                    ProtobufCBuffer *buffer ) ;
#line 153
Extensions__Api__CastChannel__AuthResponse *extensions__api__cast_channel__auth_response__unpack(ProtobufCAllocator *allocator ,
                                                                                                 size_t len ,
                                                                                                 uint8_t *data ) ;
#line 157
void extensions__api__cast_channel__auth_response__free_unpacked(Extensions__Api__CastChannel__AuthResponse *message ,
                                                                 ProtobufCAllocator *allocator ) ;
#line 161
void extensions__api__cast_channel__auth_error__init(Extensions__Api__CastChannel__AuthError *message ) ;
#line 163
size_t extensions__api__cast_channel__auth_error__get_packed_size(Extensions__Api__CastChannel__AuthError *message ) ;
#line 165
size_t extensions__api__cast_channel__auth_error__pack(Extensions__Api__CastChannel__AuthError *message ,
                                                       uint8_t *out ) ;
#line 168
size_t extensions__api__cast_channel__auth_error__pack_to_buffer(Extensions__Api__CastChannel__AuthError *message ,
                                                                 ProtobufCBuffer *buffer ) ;
#line 172
Extensions__Api__CastChannel__AuthError *extensions__api__cast_channel__auth_error__unpack(ProtobufCAllocator *allocator ,
                                                                                           size_t len ,
                                                                                           uint8_t *data ) ;
#line 176
void extensions__api__cast_channel__auth_error__free_unpacked(Extensions__Api__CastChannel__AuthError *message ,
                                                              ProtobufCAllocator *allocator ) ;
#line 180
void extensions__api__cast_channel__device_auth_message__init(Extensions__Api__CastChannel__DeviceAuthMessage *message ) ;
#line 182
size_t extensions__api__cast_channel__device_auth_message__get_packed_size(Extensions__Api__CastChannel__DeviceAuthMessage *message ) ;
#line 184
size_t extensions__api__cast_channel__device_auth_message__pack(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                uint8_t *out ) ;
#line 187
size_t extensions__api__cast_channel__device_auth_message__pack_to_buffer(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                          ProtobufCBuffer *buffer ) ;
#line 191
Extensions__Api__CastChannel__DeviceAuthMessage *extensions__api__cast_channel__device_auth_message__unpack(ProtobufCAllocator *allocator ,
                                                                                                            size_t len ,
                                                                                                            uint8_t *data ) ;
#line 195
void extensions__api__cast_channel__device_auth_message__free_unpacked(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                       ProtobufCAllocator *allocator ) ;
#line 221
ProtobufCMessageDescriptor extensions__api__cast_channel__cast_message__descriptor ;
#line 222
ProtobufCEnumDescriptor extensions__api__cast_channel__cast_message__protocol_version__descriptor ;
#line 223
ProtobufCEnumDescriptor extensions__api__cast_channel__cast_message__payload_type__descriptor ;
#line 224
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_challenge__descriptor ;
#line 225
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_response__descriptor ;
#line 226
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_error__descriptor ;
#line 227
ProtobufCEnumDescriptor extensions__api__cast_channel__auth_error__error_type__descriptor ;
#line 228
ProtobufCMessageDescriptor extensions__api__cast_channel__device_auth_message__descriptor ;
#line 57 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
char *ccmessv_emes(ccmessv_err rv ) 
{ 
  char *__cil_tmp2 ;

  {
#line 59
  if ((unsigned int )rv & 268435456U) {
    {
#line 60
    __cil_tmp2 = ccmessv_emes((ccmessv_err )((unsigned int )rv & 268435455U));
    }
#line 60
    return (__cil_tmp2);
  }
  {
#line 65
  if ((unsigned int )rv == (unsigned int )0) {
#line 65
    goto case_0;
  }
#line 67
  if ((unsigned int )rv == (unsigned int )2) {
#line 67
    goto case_2;
  }
#line 69
  if ((unsigned int )rv == (unsigned int )1) {
#line 69
    goto case_1;
  }
#line 71
  if ((unsigned int )rv == (unsigned int )3) {
#line 71
    goto case_3;
  }
#line 73
  if ((unsigned int )rv == (unsigned int )4) {
#line 73
    goto case_4;
  }
#line 76
  if ((unsigned int )rv == (unsigned int )5) {
#line 76
    goto case_5;
  }
#line 78
  if ((unsigned int )rv == (unsigned int )6) {
#line 78
    goto case_6;
  }
#line 80
  if ((unsigned int )rv == (unsigned int )7) {
#line 80
    goto case_7;
  }
#line 82
  if ((unsigned int )rv == (unsigned int )8) {
#line 82
    goto case_8;
  }
#line 84
  if ((unsigned int )rv == (unsigned int )9) {
#line 84
    goto case_9;
  }
#line 64
  goto switch_break;
  case_0: /* CIL Label */ 
#line 66
  return ("ccmes: OK");
  case_2: /* CIL Label */ 
#line 68
  return ("ccmes: getting a ssl contextfailed");
  case_1: /* CIL Label */ 
#line 70
  return ("ccmes: malloc failed");
  case_3: /* CIL Label */ 
#line 72
  return ("ccmes: connecting to host failed\220");
  case_4: /* CIL Label */ 
#line 74
  return ("ccmes: ssl connect to host failed");
  case_5: /* CIL Label */ 
#line 77
  return ("ccmes: message failed to send");
  case_6: /* CIL Label */ 
#line 79
  return ("ccmes: failed to receive\220");
  case_7: /* CIL Label */ 
#line 81
  return ("ccmes: failed to unpack");
  case_8: /* CIL Label */ 
#line 83
  return ("ccmes: i/o has timed out\220");
  case_9: /* CIL Label */ 
#line 85
  return ("ccmes: connection has been closed");
  switch_break: /* CIL Label */ ;
  }
#line 88
  return ("Unknown ccmessv error");
}
}
#line 146 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
void ccmes_transfer(ccmes *dst , ccmes *src ) 
{ 


  {
  {
#line 147
  *dst = *src;
#line 148
  memset((void *)src, 0, sizeof(*src));
  }
  return;
}
}
#line 152 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
void ccmes_init(ccmes *mes ) 
{ 


  {
  {
#line 153
  memset((void *)mes, 0, sizeof(*mes));
  }
  return;
}
}
#line 157 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
void ccmes_empty(ccmes *mes ) 
{ 


  {
#line 158
  if (mes->tnode != (void *)0) {
    {
#line 159
    yajl_tree_free(mes->tnode);
    }
  }
#line 161
  if (mes->data != (void *)0) {
    {
#line 162
    free(mes->data);
    }
  }
  {
#line 164
  memset((void *)mes, 0, sizeof(*mes));
  }
  return;
}
}
#line 168 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
void ccmes_del(ccmes *mes ) 
{ 


  {
#line 169
  if (mes != (void *)0) {
    {
#line 170
    ccmes_empty(mes);
#line 171
    free(mes);
    }
  }
  return;
}
}
#line 177 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
ccmessv_err send_ccmessv(ccmessv *p , ccmes *mes ) 
{ 
  ccpacket_err perr ;
  uint8_t *buf ;
  unsigned int len ;
  Extensions__Api__CastChannel__CastMessage msg ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;
  ccpacket_err __cil_tmp9 ;

  {
#line 181
  msg.base.descriptor = & extensions__api__cast_channel__cast_message__descriptor;
#line 181
  msg.base.n_unknown_fields = (unsigned int )0;
#line 181
  msg.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 181
  msg.protocol_version = (Extensions__Api__CastChannel__CastMessage__ProtocolVersion )0;
#line 181
  msg.source_id = (char *)((void *)0);
#line 181
  msg.destination_id = (char *)((void *)0);
#line 181
  msg.namespace_ = (char *)((void *)0);
#line 181
  msg.payload_type = (Extensions__Api__CastChannel__CastMessage__PayloadType )0;
#line 181
  msg.payload_utf8 = (char *)((void *)0);
#line 181
  msg.has_payload_binary = 0;
#line 181
  msg.payload_binary.len = (size_t )0;
#line 181
  msg.payload_binary.data = (uint8_t *)((void *)0);
#line 184
  if (p->pk == (void *)0) {
#line 185
    return ((ccmessv_err )9);
  }
#line 191
  msg.protocol_version = (Extensions__Api__CastChannel__CastMessage__ProtocolVersion )0;
#line 193
  msg.source_id = mes->source_id;
#line 194
  msg.destination_id = mes->destination_id;
#line 195
  msg.namespace_ = mes->namespace;
#line 197
  if (mes->binary) {
#line 198
    msg.payload_type = (Extensions__Api__CastChannel__CastMessage__PayloadType )1;
#line 199
    msg.has_payload_binary = 1;
#line 200
    msg.payload_binary.len = (size_t )mes->bin_len;
#line 201
    msg.payload_binary.data = (uint8_t *)mes->data;
#line 202
    msg.payload_utf8 = (char *)((void *)0);
  } else {
#line 204
    msg.payload_type = (Extensions__Api__CastChannel__CastMessage__PayloadType )0;
#line 205
    msg.payload_utf8 = (char *)mes->data;
#line 206
    msg.has_payload_binary = 0;
#line 207
    msg.payload_binary.len = (size_t )0;
#line 208
    msg.payload_binary.data = (uint8_t *)((void *)0);
  }
  {
#line 210
  __cil_tmp7 = extensions__api__cast_channel__cast_message__get_packed_size(& msg);
#line 210
  len = (unsigned int )__cil_tmp7;
#line 212
  buf = (uint8_t *)malloc((unsigned long )len);
  }
#line 212
  if (buf == (void *)0) {
#line 213
    return ((ccmessv_err )1);
  }
  {
#line 215
  extensions__api__cast_channel__cast_message__pack(& msg, buf);
#line 217
  pthread_mutex_lock(& p->slock);
#line 218
  perr = (*((p->pk)->send))(p->pk, buf, len);
  }
#line 218
  if ((unsigned int )perr != 0U) {
    {
#line 219
    pthread_mutex_unlock(& p->slock);
#line 220
    free(buf);
    }
#line 221
    if ((unsigned int )perr == 5U) {
#line 222
      return ((ccmessv_err )8);
    }
#line 223
    return ((ccmessv_err )5);
  }
  {
#line 225
  pthread_mutex_unlock(& p->slock);
#line 226
  free(buf);
  }
#line 228
  return ((ccmessv_err )0);
}
}
#line 234 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
ccmessv_err receive_ccmessv(ccmessv *p , ccmes *mes ) 
{ 
  ccpacket_err perr ;
  uint8_t *buf ;
  unsigned int len ;
  Extensions__Api__CastChannel__CastMessage *msg ;
  ccpacket_err __cil_tmp7 ;
  Extensions__Api__CastChannel__CastMessage *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  yajl_val tyn ;
  yajl_val idn ;
  char errbuf[1024] ;
  yajl_val __cil_tmp17 ;
  yajl_val __cil_tmp18 ;
  char *tmp ;
  yajl_val __cil_tmp20 ;

  {
#line 240
  if (p->pk == (void *)0) {
#line 241
    return ((ccmessv_err )9);
  }
  {
#line 243
  perr = (*((p->pk)->receive))(p->pk, & buf, & len);
  }
#line 243
  if ((unsigned int )perr != 0U) {
#line 244
    if ((unsigned int )perr == 5U) {
#line 245
      return ((ccmessv_err )8);
    }
#line 246
    return ((ccmessv_err )6);
  }
  {
#line 249
  msg = extensions__api__cast_channel__cast_message__unpack((ProtobufCAllocator *)((void *)0),
                                                            (size_t )len, buf);
  }
#line 250
  if (msg == (void *)0) {
#line 251
    return ((ccmessv_err )7);
  }
  {
#line 253
  ccmes_init(mes);
#line 255
  mes->source_id = strdup((char const   *)msg->source_id);
  }
#line 255
  if (mes->source_id == (void *)0) {
#line 256
    return ((ccmessv_err )1);
  }
  {
#line 257
  mes->destination_id = strdup((char const   *)msg->destination_id);
  }
#line 257
  if (mes->destination_id == (void *)0) {
#line 258
    return ((ccmessv_err )1);
  }
  {
#line 259
  mes->namespace = strdup((char const   *)msg->namespace_);
  }
#line 259
  if (mes->namespace == (void *)0) {
#line 260
    return ((ccmessv_err )1);
  }
#line 262
  if ((unsigned int )msg->payload_type == 1U) {
    {
#line 263
    mes->binary = 1;
#line 264
    mes->data = (uint8_t *)malloc(msg->payload_binary.len);
    }
#line 264
    if (mes->data == (void *)0) {
#line 265
      return ((ccmessv_err )1);
    }
    {
#line 266
    memcpy(mes->data, msg->payload_binary.data, msg->payload_binary.len);
#line 267
    mes->bin_len = (uint32_t )msg->payload_binary.len;
    }
  } else {
    {
#line 269
    mes->binary = 0;
#line 270
    __cil_tmp13 = strdup((char const   *)msg->payload_utf8);
#line 270
    mes->data = (uint8_t *)__cil_tmp13;
    }
#line 270
    if (mes->data == (void *)0) {
#line 271
      return ((ccmessv_err )1);
    }
  }
  {
#line 273
  extensions__api__cast_channel__cast_message__free_unpacked(msg, (ProtobufCAllocator *)((void *)0));
#line 280
  mes->mtype = (char *)((void *)0);
#line 281
  mes->rqid = 0;
  }
#line 282
  if (mes->tnode == (void *)0) {
#line 282
    if (! mes->binary) {
      {
#line 286
      mes->tnode = yajl_tree_parse((char const   *)((char *)mes->data), (char *)errbuf,
                                   sizeof(errbuf));
      }
#line 286
      if (mes->tnode == (void *)0) {

      } else {
        {
#line 288
        tyn = yajl_tree_get_first(mes->tnode, "type\313U", (yajl_type )1);
        }
#line 288
        if (tyn == (void *)0) {

        } else {
#line 291
          if (tyn != (void *)0 && (unsigned int )tyn->type == 1U) {
#line 291
            tmp = tyn->u.string;
          } else {
#line 291
            tmp = (char *)((void *)0);
          }
          {
#line 291
          mes->mtype = tmp;
#line 292
          idn = yajl_tree_get_first(mes->tnode, "requestId\300\021\032\313U", (yajl_type )2);
          }
#line 292
          if (idn != (void *)0) {
#line 293
            mes->rqid = (int )idn->u.number.i;
          } else {

          }
        }
      }
    }
  }
#line 300
  return ((ccmessv_err )0);
}
}
#line 304 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
void del_ccmessv(ccmessv *p ) 
{ 


  {
#line 305
  if (p != (void *)0) {
    {
#line 306
    pthread_mutex_destroy(& p->slock);
    }
#line 307
    if (p->pk != (void *)0) {
      {
#line 308
      (*((p->pk)->del))(p->pk);
      }
    }
    {
#line 309
    free(p);
    }
  }
  return;
}
}
#line 315 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmes.c"
ccmessv *new_ccmessv(ccpacket *pk ) 
{ 
  ccmessv *p ;
  void *__cil_tmp3 ;

  {
  {
#line 316
  p = (ccmessv *)((void *)0);
#line 318
  __cil_tmp3 = calloc((unsigned long )1, sizeof(ccmessv ));
#line 318
  p = (ccmessv *)__cil_tmp3;
  }
#line 318
  if (p == (void *)0) {

#line 320
    return ((ccmessv *)((void *)0));
  }
  {
#line 323
  pthread_mutex_init(& p->slock, (pthread_mutexattr_t *)((void *)0));
#line 325
  p->pk = pk;
#line 328
  p->del = & del_ccmessv;
#line 329
  p->send = & send_ccmessv;
#line 330
  p->receive = & receive_ccmessv;
  }
#line 332
  return (p);
}
}
#line 7 "h/copyright.h"
static char __copyright_____4[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 119 "numlib/svd.h"
static void svdinverse___3(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 163 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
char *cctype2str(cctype typ ) 
{ 


  {
  {
#line 165
  if ((unsigned int )typ == (unsigned int )0) {
#line 165
    goto case_0;
  }
#line 167
  if ((unsigned int )typ == (unsigned int )1) {
#line 167
    goto case_1;
  }
#line 169
  if ((unsigned int )typ == (unsigned int )2) {
#line 169
    goto case_2;
  }
#line 171
  if ((unsigned int )typ == (unsigned int )3) {
#line 171
    goto case_3;
  }
#line 173
  if ((unsigned int )typ == (unsigned int )4) {
#line 173
    goto case_4;
  }
#line 175
  if ((unsigned int )typ == (unsigned int )5) {
#line 175
    goto case_5;
  }
#line 177
  goto switch_default;
  case_0: /* CIL Label */ 
#line 166
  return ("Unknown");
  case_1: /* CIL Label */ 
#line 168
  return ("One");
  case_2: /* CIL Label */ 
#line 170
  return ("Two");
  case_3: /* CIL Label */ 
#line 172
  return ("Audio");
  case_4: /* CIL Label */ 
#line 174
  return ("Ultra");
  case_5: /* CIL Label */ 
#line 176
  return ("Other");
  switch_default: /* CIL Label */ 
#line 178
  return ("Unexpected");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 200 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int write_string(uint8_t *buf , int off , char *s ) 
{ 
  int len ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 201
  __cil_tmp5 = strlen((char const   *)s);
#line 201
  len = (int )__cil_tmp5;
  }
#line 202
  if (len >= 192) {
#line 203
    len = 192;
  }
  {
#line 204
  *(buf + off) = (uint8_t )len;
#line 205
  off ++;
#line 206
  memcpy(buf + off, s, (unsigned long )len);
#line 207
  off += len;
  }
#line 208
  return (off);
}
}
#line 212 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int init_mDNS(void) 
{ 


  {
#line 222
  return (0);
}
}
#line 227 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int init_socket_mDNS(SOCKET *psock ) 
{ 
  int nRet ;
  int nOptVal ;
  int off ;
  SOCKET sock ;
  struct sockaddr_in stSourceAddr ;
  struct ip_mreq stIpMreq ;
  int __cil_tmp8 ;
  int on ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  __uint16_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  in_addr_t __cil_tmp16 ;
  int __cil_tmp17 ;
  struct timeval tv ;
  int __cil_tmp19 ;

  {
  {
#line 237
  sock = socket(2, 2, 0);
  }
#line 238
  if (sock == -1) {

#line 240
    return (1);
  }
  {
#line 257
  on = 1;
#line 258
  __cil_tmp10 = setsockopt(sock, 1, 2, (char const   *)(& on), (socklen_t )sizeof(on));
  }
#line 258
  if (__cil_tmp10) {
    {
#line 260
    close(sock);
    }
#line 261
    return (1);
  }
  {
#line 273
  __cil_tmp11 = setsockopt(sock, 1, 15, (char const   *)(& on), (socklen_t )sizeof(on));
  }
#line 273
  if (__cil_tmp11) {

  }
  {
#line 280
  stSourceAddr.sin_family = (sa_family_t )2;
#line 281
  stSourceAddr.sin_port = __bswap_16((__uint16_t )5353);
#line 282
  stSourceAddr.sin_addr.s_addr = (in_addr_t )0;
#line 289
  nRet = bind(sock, (struct sockaddr *)(& stSourceAddr), (socklen_t )sizeof(struct sockaddr ));
  }
#line 291
  if (nRet == -1) {
    {
#line 293
    close(sock);
    }
#line 294
    return (1);
  }
  {
#line 305
  nOptVal = 0;
#line 306
  nRet = setsockopt(sock, 0, 34, (char *)(& nOptVal), (socklen_t )sizeof(int ));
  }
#line 308
  if (nRet == -1) {

  }
  {
#line 322
  nOptVal = 64;
#line 323
  nRet = setsockopt(sock, 0, 33, (char *)(& nOptVal), (socklen_t )sizeof(int ));
  }
#line 325
  if (nRet == -1) {
    {
#line 327
    close(sock);
    }
#line 328
    return (1);
  }
#line 331
  if (psock != (void *)0) {
#line 332
    *psock = sock;
  }
  {
#line 338
  stIpMreq.imr_multiaddr.s_addr = inet_addr("224.0.0.251");
#line 339
  stIpMreq.imr_interface.s_addr = (in_addr_t )0;
#line 340
  nRet = setsockopt(sock, 0, 35, (char *)(& stIpMreq), (socklen_t )sizeof(struct ip_mreq ));
  }
#line 343
  if (nRet == -1) {
    {
#line 345
    close(sock);
    }
#line 346
    return (1);
  }
  {
#line 363
  tv.tv_sec = (__time_t )0;
#line 364
  tv.tv_usec = (__suseconds_t )100000;
#line 365
  __cil_tmp19 = setsockopt(sock, 1, 20, (char const   *)(& tv), (socklen_t )sizeof(tv));
  }
#line 365
  if (__cil_tmp19 < 0) {
    {
#line 367
    close(sock);
    }
#line 368
    return (1);
  }
#line 373
  if (psock != (void *)0) {
#line 374
    *psock = sock;
  }

#line 378
  return (0);
}
}
#line 384 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int send_mDNS(SOCKET sock ) 
{ 
  int nRet ;
  int off ;
  uint8_t achOutBuf[2048] ;
  struct sockaddr_in stDestAddr ;
  in_addr_t __cil_tmp6 ;
  __uint16_t __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 393
  stDestAddr.sin_family = (sa_family_t )2;
#line 394
  stDestAddr.sin_addr.s_addr = inet_addr("224.0.0.251");
#line 395
  stDestAddr.sin_port = __bswap_16((__uint16_t )5353);
#line 398
  write_ORD16_be((uint8_t *)achOutBuf + 0, (unsigned int )0);
#line 399
  write_ORD16_be((uint8_t *)achOutBuf + 2, (unsigned int )0);
#line 400
  write_ORD16_be((uint8_t *)achOutBuf + 4, (unsigned int )1);
#line 401
  write_ORD16_be((uint8_t *)achOutBuf + 6, (unsigned int )0);
#line 402
  write_ORD16_be((uint8_t *)achOutBuf + 8, (unsigned int )0);
#line 403
  write_ORD16_be((uint8_t *)achOutBuf + 10, (unsigned int )0);
#line 404
  off = 12;
#line 405
  off = write_string((uint8_t *)achOutBuf, off, "_googlecast");
#line 406
  off = write_string((uint8_t *)achOutBuf, off, "_tcp");
#line 407
  off = write_string((uint8_t *)achOutBuf, off, "localU");
#line 408
  write_ORD8((uint8_t *)achOutBuf + off, (unsigned int )0);
#line 409
  off ++;
#line 410
  write_ORD16_be((uint8_t *)achOutBuf + off, (unsigned int )12);
#line 411
  off += 2;
#line 413
  write_ORD16_be((uint8_t *)achOutBuf + off, (unsigned int )1);
#line 414
  off += 2;
#line 416
  __cil_tmp11 = sendto(sock, (char *)((uint8_t *)achOutBuf), (size_t )off, 0, (struct sockaddr *)(& stDestAddr),
                       (socklen_t )sizeof(struct sockaddr ));
#line 416
  nRet = (int )__cil_tmp11;
  }
#line 420
  if (nRet == -1) {

#line 422
    return (1);
  }

#line 427
  return (0);
}
}
#line 430
static int parse_dns(char **pname , char **pip , cctype *ptyp , int *pcaflags , uint8_t *buf ,
                     int size ) ;
#line 433 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
void free_ccids(ccast_id **ids ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 434
  if (ids != (void *)0) {
#line 437
    i = 0;
    {
#line 437
    while (1) {
      while_continue: /* CIL Label */ ;
#line 437
      if (! (*(ids + i) != (void *)0)) {
#line 437
        goto while_break;
      }
      {
#line 438
      free((*(ids + i))->name);
#line 439
      free((*(ids + i))->ip);
#line 440
      free(*(ids + i));
      }
#line 437
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 442
    free(ids);
    }
  }
  return;
}
}
#line 450 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int receive_mDNS(SOCKET sock , ccast_id ***ids , int *nids , int emsec ) 
{ 
  unsigned int smsec ;
  unsigned int nSize ;
  int off ;
  int size ;
  uint8_t achInBuf[2048] ;
  struct sockaddr_in stSourceAddr ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int i ;
  char *name ;
  char *ip ;
  cctype typ ;
  int caflags ;
  struct sockaddr stSockAddr ;
  ssize_t __cil_tmp19 ;
  int *__cil_tmp20 ;
  int *__cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  ccast_id **tids ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;

  {
#line 460
  emsec += smsec;
  {
#line 460
  smsec = msec_time();
  }
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (__cil_tmp12 <= (unsigned int )emsec)) {
#line 460
      goto while_break;
    }
    {
#line 468
    nSize = (unsigned int )sizeof(struct sockaddr );
#line 469
    __cil_tmp19 = recvfrom(sock, (char *)((uint8_t *)achInBuf), (size_t )2048, 0,
                           (struct sockaddr *)(& stSockAddr), & nSize);
#line 469
    size = (int )__cil_tmp19;
    }
#line 471
    if (size == -1) {
      {
#line 472
      __cil_tmp20 = __errno_location();
      }
#line 472
      if (*__cil_tmp20 == 11) {
#line 473
        goto while_continue;
      }
      {
#line 474
      __cil_tmp21 = __errno_location();
#line 474
      a1logd(g_log, 2, "recvfrom failed with %d\n\230", *__cil_tmp21);
#line 475
      free_ccids(*ids);
#line 476
      *ids = (ccast_id **)((void *)0);
      }
#line 477
      return (1);
    }
    {
#line 480
    a1logd(g_log, 3, "Got mDNS message length %d bytes\n", size);
#line 485
    __cil_tmp22 = parse_dns(& name, & ip, & typ, & caflags, (uint8_t *)achInBuf, size);
    }
#line 485
    if (__cil_tmp22 != 0) {

    } else {

#line 491
      if (name != (void *)0) {
#line 491
        if (ip != (void *)0) {

#line 495
          if ((unsigned int )typ == 3U) {
            {
            {
#line 498
            free(name);
            }
            {
#line 499
            free(ip);
            }
            }
          } else
#line 495
          if ((unsigned int )typ == 5U) {
            {
            {
#line 498
            free(name);
            }
            {
#line 499
            free(ip);
            }
            }
          } else {
#line 504
            i = 0;
            {
#line 504
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 504
              if (! (i < *nids)) {
#line 504
                goto while_break___0;
              }
              {
#line 505
              __cil_tmp24 = strcmp((char const   *)(*(*ids + i))->ip, (char const   *)ip);
              }
              {
#line 505
              __cil_tmp23 = strcmp((char const   *)(*(*ids + i))->name, (char const   *)name);
              }
#line 505
              if (__cil_tmp23 == 0) {
#line 505
                if (__cil_tmp24 == 0) {
#line 507
                  goto while_break___0;
                }
              }
#line 504
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 509
            if (i < *nids) {
              {
#line 511
              free(name);
#line 512
              free(ip);
              }
            } else {
              {
#line 515
              *(*ids + *nids) = (ccast_id *)malloc(sizeof(ccast_id ));
              }
#line 515
              *ids = tids;
              {
#line 515
              tids = (ccast_id **)realloc(*ids, (unsigned long )(*nids + 2) * sizeof(ccast_id *));
              }
#line 515
              if (tids == (void *)0) {
                {
                {
#line 518
                free(name);
                }
                {
#line 519
                free(ip);
                }
                {
#line 520
                free_ccids(*ids);
                }
#line 521
                *ids = (ccast_id **)((void *)0);
                }
#line 522
                return (1);
              } else
#line 515
              if (*(*ids + *nids) == (void *)0) {
                {
                {
#line 518
                free(name);
                }
                {
#line 519
                free(ip);
                }
                {
#line 520
                free_ccids(*ids);
                }
#line 521
                *ids = (ccast_id **)((void *)0);
                }
#line 522
                return (1);
              } else {
#line 525
                (*(*ids + *nids))->name = name;
#line 526
                (*(*ids + *nids))->ip = ip;
#line 527
                (*(*ids + *nids))->typ = typ;
#line 528
                (*nids) ++;
#line 529
                *(*ids + *nids) = (ccast_id *)((void *)0);
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  a1logd(g_log, 3, "receive_mDNS() returning %d in list\n", *nids);
  }
#line 539
  return (0);
}
}
#line 547 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
ccast_id **get_ccids(void) 
{ 
  ccast_id **ids ;
  int nids ;
  int i ;
  int j ;
  int k ;
  unsigned int smsec ;
  int waittime ;
  SOCKET sock ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  char const   *tmp ;
  int __cil_tmp17 ;
  void *__cil_tmp18 ;
  int __cil_tmp19 ;
  ccast_id *tmp___0 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;

  {
  {
#line 548
  ids = (ccast_id **)((void *)0);
#line 549
  nids = 0;
#line 552
  waittime = 200;
#line 555
  a1logd(g_log, 2, "get_ccids: called\n");
#line 557
  __cil_tmp9 = init_mDNS();
  }
#line 557
  if (__cil_tmp9) {
    {
#line 558
    a1logd(g_log, 0, "get_ccids: init_mDNS() failed\n");
    }
#line 559
    return ((ccast_id **)((void *)0));
  }
  {
#line 562
  __cil_tmp10 = init_socket_mDNS(& sock);
  }
#line 562
  if (__cil_tmp10) {
    {
#line 563
    a1logd(g_log, 0, "get_ccids: init_socket_mDNS() failed\n");
    }
#line 564
    return ((ccast_id **)((void *)0));
  }
  {
#line 567
  smsec = msec_time();
#line 570
  k = 1;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (__cil_tmp12 - smsec < 700U || (nids == 0 && __cil_tmp13 - smsec < 1600U))) {
#line 570
      goto while_break;
    }
    {
#line 575
    a1logd(g_log, 2, "get_ccids: Sending mDNS query #%d:\n", k);
#line 576
    __cil_tmp14 = send_mDNS(sock);
    }
#line 576
    if (__cil_tmp14) {
      {
#line 577
      a1logd(g_log, 0, "get_ccids: send_mDNS() #1 failed\n");
#line 578
      close(sock);
      }
#line 579
      return ((ccast_id **)((void *)0));
    }
    {
#line 582
    a1logd(g_log, 2, "get_ccids: Waiting for mDNS reply #%d:\n", k);
#line 583
    __cil_tmp15 = receive_mDNS(sock, & ids, & nids, waittime);
    }
#line 583
    if (__cil_tmp15) {
      {
#line 584
      a1logd(g_log, 0, "get_ccids: receive_mDNS() #%d failed\n", k);
#line 585
      close(sock);
      }
#line 586
      return ((ccast_id **)((void *)0));
    }
#line 588
    if (nids == 1) {
#line 588
      tmp = "reply";
    } else {
#line 588
      tmp = "replies";
    }
    {
#line 588
    a1logd(g_log, 2, "get_ccids: have %d %s\n", nids, tmp);
    }
#line 590
    if (waittime < 500) {
#line 591
      waittime = 500;
    }
#line 573
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 593
  close(sock);
  }
#line 596
  if (ids == (void *)0) {
    {
#line 597
    a1logd(g_log, 2, "get_ccids: no devices found\nY\016");
#line 598
    ids = (ccast_id **)calloc(sizeof(ccast_id *), (unsigned long )1);
    }
#line 598
    if (ids == (void *)0) {
      {
#line 599
      a1logd(g_log, 0, "get_ccids: calloc fail\n");
      }
#line 600
      return ((ccast_id **)((void *)0));
    }
  }
#line 604
  i = 0;
  {
#line 604
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 604
    if (! (*(ids + i) != (void *)0 && *(ids + (i + 1)) != (void *)0)) {
#line 604
      goto while_break___0;
    }
#line 605
    j = i + 1;
    {
#line 605
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 605
      if (! (*(ids + j) != (void *)0)) {
#line 605
        goto while_break___1;
      }
      {
#line 606
      __cil_tmp19 = strcmp((char const   *)(*(ids + i))->name, (char const   *)(*(ids + j))->name);
      }
#line 606
      if (__cil_tmp19 > 0) {
#line 608
        tmp___0 = *(ids + i);
#line 609
        *(ids + i) = *(ids + j);
#line 610
        *(ids + j) = tmp___0;
      }
#line 605
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 604
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 615
    if (! (*(ids + i) != (void *)0)) {
#line 615
      goto while_break___2;
    }
    {
#line 616
    a1logd(g_log, 2, "  Entry %d:\nL", i);
#line 617
    a1logd(g_log, 2, "   Name: %s\n\r\234\001", (*(ids + i))->name);
#line 618
    a1logd(g_log, 2, "   IP:   %s\nN", (*(ids + i))->ip);
#line 619
    __cil_tmp23 = cctype2str((*(ids + i))->typ);
#line 619
    a1logd(g_log, 2, "   Type: %s\n\017\020\002", __cil_tmp23);
    }
#line 615
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 621
  a1logd(g_log, 2, "get_ccids: Returning %d devices\n\230\001", i);
  }
#line 623
  return (ids);
}
}
#line 626 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
void ccast_id_copy(ccast_id *dst , ccast_id *src ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 627
  dst->name = strdup((char const   *)src->name);
#line 628
  dst->ip = strdup((char const   *)src->ip);
  }
  return;
}
}
#line 631 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
ccast_id *ccast_id_clone(ccast_id *src ) 
{ 
  ccast_id *dst ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 634
  dst = (ccast_id *)calloc(sizeof(ccast_id ), (unsigned long )1);
  }
#line 634
  if (dst == (void *)0) {
#line 635
    return (dst);
  }
  {
#line 637
  dst->name = strdup((char const   *)src->name);
  }
#line 637
  if (src->name != (void *)0) {
#line 637
    if (dst->name == (void *)0) {
      {
#line 638
      free(dst);
      }
#line 639
      return ((ccast_id *)((void *)0));
    }
  }
  {
#line 641
  dst->ip = strdup((char const   *)src->ip);
  }
#line 641
  if (src->ip != (void *)0) {
#line 641
    if (dst->ip == (void *)0) {
      {
#line 642
      free(dst->name);
#line 643
      free(dst);
      }
#line 644
      return ((ccast_id *)((void *)0));
    }
  }
#line 646
  return (dst);
}
}
#line 649 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
void ccast_id_del(ccast_id *id ) 
{ 


  {
  {
#line 650
  free(id->name);
#line 651
  free(id->ip);
#line 652
  free(id);
  }
  return;
}
}
#line 659 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int read_string_imp(char **rv , int *slen , uint8_t *buf , int off , int size ,
                           int rec ) 
{ 
  int len ;
  int d1 ;
  int poff ;
  unsigned int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 661
  d1 = 0;
#line 665
  if (rec > 10) {

#line 667
    return (- 1);
  }
#line 670
  if (off >= size) {

#line 672
    return (- 1);
  }
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! 1) {
#line 675
      goto while_break;
    }
#line 677
    len = (int )*(buf + off);
#line 678
    if ((len & 192) == 192) {

#line 682
      if (size - off < 2) {

#line 684
        return (- 1);
      }
      {
#line 687
      __cil_tmp10 = read_ORD16_be(buf + off);
#line 687
      poff = (int )__cil_tmp10;
#line 687
      off += 2;
#line 688
      poff -= 49152;
      }
#line 690
      if (poff < 0) {
#line 691
        return (- 1);
      } else
#line 690
      if (poff >= size) {
#line 691
        return (- 1);
      }
      {
#line 695
      read_string_imp(rv, slen, buf, poff, size, rec + 1);
      }
#line 697
      if (slen != (void *)0) {

      }
#line 700
      goto while_break;
    } else {
#line 705
      off ++;
#line 706
      if (off + len >= size) {

#line 708
        return (- 1);
      }
#line 711
      if (len == 0) {

#line 713
        goto while_break;
      }
#line 716
      if (rv != (void *)0) {
        {
#line 717
        memcpy(*rv, buf + off, (unsigned long )len);
#line 724
        *rv += len;
        }
      }
#line 726
      off += len;
#line 728
      if (slen != (void *)0) {
#line 729
        *slen += len;
      }
    }
#line 734
    d1 = 1;
#line 736
    if (slen != (void *)0) {
#line 737
      (*slen) ++;
    }
#line 740
    if (rv != (void *)0) {
#line 741
      *(*rv + 0) = (char )'.';
#line 742
      (*rv) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  if (slen != (void *)0) {

  }
#line 749
  return (off);
}
}
#line 754 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int read_string(char **rv , uint8_t *buf , int off , int size ) 
{ 
  int len ;
  int toff ;
  char *trv ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 755
  len = 0;
  {
#line 755
  toff = off;
#line 761
  toff = read_string_imp((char **)((void *)0), & len, buf, off, size, 0);
  }
#line 761
  if (toff < 0) {

#line 763
    return (toff);
  }

#line 767
  if (len == 0) {
#line 769
    len ++;
  }
  {
#line 771
  *rv = (char *)malloc((unsigned long )len);
  }
#line 771
  if (*rv == (void *)0) {

#line 773
    return (- 1);
  }
  {
#line 776
  off = read_string_imp(& trv, (int *)((void *)0), buf, off, size, 0);
  }
#line 777
  if (off >= 0) {
#line 778
    *(*rv + (len - 1)) = (char )'\000';
  } else {

  }
#line 783
  return (off);
}
}
#line 788 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
int parse_query(uint8_t *buf , int off , int size ) 
{ 
  char *sv ;
  int qtype ;
  int qclass ;
  int __cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  unsigned int __cil_tmp9 ;

  {
  {
#line 793
  off = read_string(& sv, buf, off, size);
  }
#line 793
  if (off < 0) {
#line 794
    return (- 1);
  }
  {
#line 796
  free(sv);
  }
#line 798
  if (size - off < 2) {
#line 799
    return (- 1);
  }
  {
#line 800
  __cil_tmp8 = read_ORD16_be(buf + off);
#line 800
  qtype = (int )__cil_tmp8;
#line 800
  off += 2;
  }
#line 803
  if (size - off < 2) {
#line 804
    return (- 1);
  }
  {
#line 805
  __cil_tmp9 = read_ORD16_be(buf + off);
#line 805
  qclass = (int )__cil_tmp9;
#line 805
  off += 2;
  }
#line 808
  return (off);
}
}
#line 813 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
int parse_reply(char **pname , char **pip , cctype *ptyp , int *pcaflags , uint8_t *buf ,
                int off , int size ) 
{ 
  char *sv ;
  int rtype ;
  int rclass ;
  int rdlength ;
  unsigned int ttl ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  char *cp ;
  char *fn ;
  int rdsize ;
  int caflags ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int slen ;
  char *ss ;
  unsigned int __cil_tmp26 ;
  void *__cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  char *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;

  {
  {
#line 819
  off = read_string(& sv, buf, off, size);
  }
#line 819
  if (off < 0) {
#line 820
    return (- 1);
  }

#line 824
  if (size - off < 2) {
    {
#line 825
    free(sv);
    }
#line 826
    return (- 1);
  }
  {
#line 828
  __cil_tmp14 = read_ORD16_be(buf + off);
#line 828
  rtype = (int )__cil_tmp14;
#line 828
  off += 2;
  }
#line 831
  if (size - off < 2) {
    {
#line 832
    free(sv);
    }
#line 833
    return (- 1);
  }
  {
#line 835
  __cil_tmp15 = read_ORD16_be(buf + off);
#line 835
  rclass = (int )__cil_tmp15;
#line 835
  off += 2;
  }
#line 839
  if ((rclass & 32767) != 1) {
    {
#line 841
    free(sv);
    }
#line 842
    return (- 1);
  }
#line 845
  if (size - off < 4) {
#line 846
    return (- 1);
  }
  {
#line 847
  ttl = read_ORD32_be(buf + off);
#line 847
  off += 4;
  }
#line 850
  if (size - off < 2) {
#line 851
    return (- 1);
  }
  {
#line 852
  __cil_tmp17 = read_ORD16_be(buf + off);
#line 852
  rdlength = (int )__cil_tmp17;
#line 852
  off += 2;
  }
#line 855
  if (off + rdlength > size) {
    {
#line 857
    free(sv);
    }
#line 858
    return (- 1);
  }
#line 862
  if (rtype == 16) {
    {
#line 863
    fn = (char *)((void *)0);
#line 864
    rdsize = off + rdlength;
#line 865
    caflags = 0;
#line 867
    cp = strchr((char const   *)sv, '.');
    }
#line 867
    if (cp == (void *)0) {
      {
#line 868
      free(sv);
      }
#line 869
      return (- 1);
    }
    {
#line 871
    *cp = (char )'\000';
#line 872
    __cil_tmp23 = strcmp((char const   *)(cp + 1), "_googlecast._tcp.local");
    }
#line 872
    if (__cil_tmp23 != 0) {
      {
#line 874
      free(sv);
      }
#line 875
      return (- 1);
    }
    {
#line 905
    while (1) {
      while_continue: /* CIL Label */ ;
#line 905
      if (! (off < rdsize)) {
#line 905
        goto while_break;
      }
#line 910
      if (rdsize - off < 1) {
#line 911
        goto done_tx;
      }
      {
#line 913
      __cil_tmp26 = read_ORD8(buf + off);
#line 913
      slen = (int )__cil_tmp26;
#line 913
      off ++;
      }
#line 915
      if (rdsize - off < slen) {
#line 916
        goto done_tx;
      }
      {
#line 918
      ss = (char *)malloc((unsigned long )(slen + 1));
      }
#line 918
      if (ss == (void *)0) {

#line 920
        return (- 1);
      }
      {
#line 923
      memcpy(ss, buf + off, (unsigned long )slen);
#line 924
      *(ss + slen) = (char )'\000';
#line 925
      off += slen;
#line 930
      __cil_tmp28 = strncmp((char const   *)ss, "fn=", (unsigned long )3);
      }
#line 930
      if (__cil_tmp28 == 0) {
        {
#line 931
        fn = (char *)malloc((unsigned long )((slen - 3) + 1));
        }
#line 931
        if (fn == (void *)0) {

#line 933
          return (- 1);
        }
        {
#line 935
        strcpy(fn, (char const   *)(ss + 3));
        }
      }
      {
#line 938
      __cil_tmp30 = strncmp((char const   *)ss, "ca=", (unsigned long )3);
      }
#line 938
      if (__cil_tmp30 == 0) {
        {
#line 939
        caflags = atoi((char const   *)(ss + 3));
        }
      }
      {
#line 941
      free(ss);
      }
    }
    while_break: /* CIL Label */ ;
    }
    done_tx: 
#line 946
    if (fn != (void *)0) {

    } else {

    }
    {
#line 952
    a1logd(g_log, 2, "ca bits 0x%x\n", caflags);
#line 954
    __cil_tmp32 = strncmp((char const   *)sv, "Chromecast-Ultra\251", (unsigned long )16);
    }
#line 954
    if (__cil_tmp32 == 0) {
#line 955
      *ptyp = (cctype )4;
    } else {
      {
#line 956
      __cil_tmp33 = strncmp((char const   *)sv, "Chromecast-Audio\251", (unsigned long )16);
      }
#line 956
      if (__cil_tmp33 == 0) {
#line 957
        *ptyp = (cctype )3;
      } else
#line 963
      if (caflags & 1) {
#line 964
        *ptyp = (cctype )1;
      } else
#line 965
      if (caflags & 4) {
#line 966
        *ptyp = (cctype )3;
      } else {
#line 968
        *ptyp = (cctype )5;
      }
    }
#line 971
    if (fn != (void *)0) {
#line 972
      *pname = fn;
    } else {
      {
#line 974
      free(fn);
#line 975
      *pname = strdup((char const   *)sv);
      }
#line 975
      if (*pname == (void *)0) {
        {
#line 977
        free(sv);
        }
#line 978
        return (- 1);
      }
    }
#line 982
    off = rdsize;
  } else
#line 984
  if (rtype == 1) {
    {
#line 986
    *pip = (char *)malloc((unsigned long )16);
    }
#line 986
    if (*pip == (void *)0) {
      {
#line 988
      free(*pname);
#line 989
      free(sv);
      }
    }
    {
#line 991
    sprintf(*pip, "%d.%d.%d.%d", (int )*(buf + off), (int )*(buf + (off + 1)), (int )*(buf + (off + 2)),
            (int )*(buf + (off + 3)));
#line 994
    off += rdlength;
    }
  } else
#line 995
  if (rtype == 28) {
    {
#line 997
    *pip = (char *)malloc((unsigned long )40);
    }
#line 997
    if (*pip == (void *)0) {
      {
#line 999
      free(*pname);
#line 1000
      free(sv);
      }
    }
    {
#line 1002
    sprintf(*pip, "%x:%x:%x:%x:%x:%x:%x:%x", (int )*(buf + off) * 245 + (int )*(buf + (off + 1)),
            (int )*(buf + (off + 2)) * 245 + (int )*(buf + (off + 3)), (int )*(buf + (off + 4)) * 245 + (int )*(buf + (off + 5)),
            (int )*(buf + (off + 6)) * 245 + (int )*(buf + (off + 7)), (int )*(buf + (off + 8)) * 245 + (int )*(buf + (off + 9)),
            (int )*(buf + (off + 10)) * 245 + (int )*(buf + (off + 11)), (int )*(buf + (off + 12)) * 245 + (int )*(buf + (off + 13)),
            (int )*(buf + (off + 14)) * 245 + (int )*(buf + (off + 15)));
#line 1013
    off += rdlength;
    }
  } else {
#line 1016
    off += rdlength;
  }
  {
#line 1018
  free(sv);
  }
#line 1020
  return (off);
}
}
#line 1026 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccmdns.c"
static int parse_dns(char **pname , char **pip , cctype *ptyp , int *pcaflags , uint8_t *buf ,
                     int size ) 
{ 
  int i ;
  int off ;
  int id ;
  int flags ;
  int qdcount ;
  int ancount ;
  int nscount ;
  int arcount ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 1027
  off = 0;
#line 1032
  *pname = (char *)((void *)0);
#line 1033
  *pip = (char *)((void *)0);
#line 1036
  if (size - off < 2) {
#line 1036
    return (1);
  }
  {
#line 1037
  __cil_tmp15 = read_ORD16_be(buf + off);
#line 1037
  id = (int )__cil_tmp15;
#line 1037
  off += 2;
  }
#line 1040
  if (size - off < 2) {
#line 1040
    return (1);
  }
  {
#line 1041
  __cil_tmp16 = read_ORD16_be(buf + off);
#line 1041
  flags = (int )__cil_tmp16;
#line 1041
  off += 2;
  }
#line 1044
  if (size - off < 2) {
#line 1044
    return (1);
  }
  {
#line 1045
  __cil_tmp17 = read_ORD16_be(buf + off);
#line 1045
  qdcount = (int )__cil_tmp17;
#line 1045
  off += 2;
  }
#line 1048
  if (size - off < 2) {
#line 1048
    return (1);
  }
  {
#line 1049
  __cil_tmp18 = read_ORD16_be(buf + off);
#line 1049
  ancount = (int )__cil_tmp18;
#line 1049
  off += 2;
  }
#line 1052
  if (size - off < 2) {
#line 1052
    return (1);
  }
  {
#line 1053
  __cil_tmp19 = read_ORD16_be(buf + off);
#line 1053
  nscount = (int )__cil_tmp19;
#line 1053
  off += 2;
  }
#line 1056
  if (size - off < 2) {
#line 1056
    return (1);
  }
  {
#line 1057
  __cil_tmp20 = read_ORD16_be(buf + off);
#line 1057
  arcount = (int )__cil_tmp20;
#line 1057
  off += 2;
#line 1063
  i = 0;
  }
  {
#line 1063
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1063
    if (! (i < qdcount)) {
#line 1063
      goto while_break;
    }
    {
#line 1064
    off = parse_query(buf, off, size);
    }
#line 1064
    if (off < 0) {

#line 1066
      return (1);
    }
#line 1063
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1071
  i = 0;
  {
#line 1071
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1071
    if (! (i < ancount)) {
#line 1071
      goto while_break___0;
    }
    {
#line 1072
    off = parse_reply(pname, pip, ptyp, pcaflags, buf, off, size);
    }
#line 1072
    if (off < 0) {

#line 1074
      return (1);
    }
#line 1071
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1079
  i = 0;
  {
#line 1079
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1079
    if (! (i < nscount)) {
#line 1079
      goto while_break___1;
    }
    {
#line 1080
    off = parse_reply(pname, pip, ptyp, pcaflags, buf, off, size);
    }
#line 1080
    if (off < 0) {

#line 1082
      return (1);
    }
#line 1079
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1087
  i = 0;
  {
#line 1087
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1087
    if (! (i < arcount)) {
#line 1087
      goto while_break___2;
    }
    {
#line 1088
    off = parse_reply(pname, pip, ptyp, pcaflags, buf, off, size);
    }
#line 1088
    if (off < 0) {

#line 1090
      return (1);
    }
#line 1087
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1093
  return (0);
}
}
#line 7 "h/copyright.h"
static char __copyright_____5[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 119 "numlib/svd.h"
static void svdinverse___4(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 77 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int cc_rec_thread(void *context ) 
{ 
  ccast *p ;
  ccmessv *sv ;
  ccmessv_err merr ;
  ccmes mes ;
  ccmes smes ;
  int errc ;
  char errbuf[1024] ;
  yajl_val tyn ;
  yajl_val idn ;
  int rv ;
  ccmessv_err __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  ccmessv_err __cil_tmp16 ;
  int found ;
  int __cil_tmp18 ;
  ccmes *nmes ;
  void *__cil_tmp20 ;

  {
  {
#line 78
  p = (ccast *)context;
#line 79
  sv = p->messv;
#line 82
  errc = 0;
#line 85
  rv = 0;
#line 89
  ccmes_init(& mes);
#line 90
  ccmes_init(& smes);
#line 93
  smes.source_id = "sender-0\220";
#line 94
  smes.destination_id = "receiver-0";
#line 95
  smes.namespace = "urn:x-cast:com.google.cast.tp.heartbeat";
#line 96
  smes.binary = 0;
#line 97
  smes.data = (uint8_t *)"{ \"type\": \"PONG\" }";
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (! p->stop)) {
#line 99
      goto while_break;
    }
    {
#line 101
    merr = (*(sv->receive))(sv, & mes);
    }
#line 101
    if ((unsigned int )merr != 0U) {
#line 102
      if ((unsigned int )merr == 8U) {
        {
#line 104
        msec_sleep((unsigned int )100);
        }
      } else {
        {
#line 107
        msec_sleep((unsigned int )100);
#line 116
        __cil_tmp13 = errc;
#line 116
        errc ++;
        }
#line 116
        if (__cil_tmp13 > 20) {
#line 119
          rv = 1;
#line 120
          goto while_break;
        }
      }
#line 123
      goto while_continue;
    }
    {
#line 126
    errc = 0;
#line 129
    __cil_tmp14 = strcmp((char const   *)mes.mtype, "CLOSE");
    }
#line 129
    if (mes.mtype != (void *)0) {
#line 129
      if (__cil_tmp14 == 0) {
#line 133
        rv = 1;
#line 134
        goto while_break;
      } else {
#line 129
        goto _L___46;
      }
    } else {
      _L___46: /* CIL Label */ 
      {
#line 136
      __cil_tmp15 = strcmp((char const   *)mes.mtype, "PING");
      }
#line 136
      if (mes.mtype != (void *)0) {
#line 136
        if (__cil_tmp15 == 0) {
          {
#line 137
          merr = (*(sv->send))(sv, & smes);
          }
#line 137
          if ((unsigned int )merr != 0U) {

          }
        } else {
#line 136
          goto _L___45;
        }
      } else {
        _L___45: /* CIL Label */ 
        {
#line 156
        __cil_tmp18 = strcmp((char const   *)p->w_rqns, (char const   *)mes.namespace);
#line 156
        found = ((p->w_rqns == (void *)0 || __cil_tmp18 == 0) && p->w_rq != 0) && (p->w_rqid == 0 || p->w_rqid == mes.rqid);
        }
#line 160
        if (found) {
          _L: /* CIL Label */ 
          {
#line 162
          __cil_tmp20 = calloc((unsigned long )1, sizeof(ccmes ));
#line 162
          nmes = (ccmes *)__cil_tmp20;
          }
#line 162
          if (nmes == (void *)0) {

          } else {
            {
#line 165
            ccmes_transfer(nmes, & mes);
#line 168
            pthread_mutex_lock(& p->rlock);
#line 169
            nmes->next = p->rmes;
#line 170
            p->rmes = nmes;
            }
#line 173
            if (found) {
              {
#line 175
              pthread_cond_signal(& p->rcond);
              }
            }
            {
#line 177
            pthread_mutex_unlock(& p->rlock);
            }
          }
        } else
#line 160
        if (mes.rqid != 0) {
#line 160
          goto _L;
        }
      }
    }
    {
#line 183
    ccmes_empty(& mes);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  p->stopped = 1;
#line 191
  pthread_mutex_lock(& p->rlock);
  }
#line 192
  if (p->w_rq != 0) {
    {
#line 194
    pthread_cond_signal(& p->rcond);
    }
  }
  {
#line 196
  pthread_mutex_unlock(& p->rlock);
  }
#line 200
  return (rv);
}
}
#line 208 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int get_a_reply_id(ccast *p , char *namespace , int rqid , ccmes *rmes , int to ) 
{ 
  ccmes *nlist ;
  ccmes *mes ;
  ccmes *xmes ;
  ccmes *fmes ;
  int rv ;
  int ins ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 209
  nlist = (ccmes *)((void *)0);
#line 210
  fmes = (ccmes *)((void *)0);
#line 211
  rv = 0;
#line 216
  pthread_mutex_lock(& p->rlock);
  }
#line 218
  if (p->stop) {
    {
    {
#line 219
    pthread_mutex_unlock(& p->rlock);
    }
    }
#line 221
    return (1);
  } else
#line 218
  if (p->stopped) {
    {
    {
#line 219
    pthread_mutex_unlock(& p->rlock);
    }
    }
#line 221
    return (1);
  }
#line 225
  p->w_rq = 1;
#line 226
  p->w_rqns = namespace;
#line 227
  p->w_rqid = rqid;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (! p->stop && ! p->stopped)) {
#line 230
      goto while_break;
    }
#line 233
    mes = p->rmes;
    {
#line 233
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      if (! (mes != (void *)0)) {
#line 233
        goto while_break___0;
      }
      {
#line 234
      __cil_tmp12 = strcmp((char const   *)namespace, (char const   *)mes->namespace);
#line 234
      ins = namespace == (void *)0 || __cil_tmp12 == 0;
#line 235
      xmes = mes->next;
      }
#line 236
      if (ins) {
#line 236
        if (rqid != 0) {
#line 236
          if (mes->rqid < rqid) {
            {
#line 237
            ccmes_del(mes);
            }
          } else {
#line 236
            goto _L;
          }
        } else {
#line 236
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      _L___47: /* CIL Label */ 
#line 238
      if (ins) {
#line 238
        if (rqid == 0) {
#line 239
          fmes = mes;
        } else
#line 238
        if (mes->rqid == rqid) {
#line 239
          fmes = mes;
        } else {
#line 241
          mes->next = nlist;
#line 242
          nlist = mes;
        }
      } else {
#line 241
        mes->next = nlist;
#line 242
        nlist = mes;
      }
#line 233
      mes = xmes;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 245
    p->rmes = nlist;
#line 247
    if (fmes != (void *)0) {
#line 248
      goto while_break;
    }
    {
#line 254
    __cil_tmp13 = acond_timedwait_imp(& p->rcond, & p->rlock, to);
    }
#line 254
    if (__cil_tmp13 != 0) {
#line 256
      rv = 2;
#line 257
      goto while_break;
    }

  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  p->w_rq = 0;
#line 265
  pthread_mutex_unlock(& p->rlock);
  }
#line 267
  if (p->stop) {
    {
    {
#line 269
    ccmes_init(rmes);
    }
    }
#line 270
    return (1);
  } else
#line 267
  if (p->stopped) {
    {
    {
#line 269
    ccmes_init(rmes);
    }
    }
#line 270
    return (1);
  }
#line 273
  if (rv != 0) {

  } else {
    {
#line 276
    ccmes_transfer(rmes, fmes);
    }
  }
#line 280
  return (rv);
}
}
#line 285
void ccast_delete_from_cleanup_list(ccast *p ) ;
#line 288 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void cleanup_ccast(ccast *p ) 
{ 
  ccmes *mes ;
  ccmes *xmes ;

  {
#line 292
  p->stop = 1;
#line 296
  if (p->rmesth != (void *)0) {
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (! (! p->stopped)) {
#line 298
        goto while_break;
      }
      {
#line 299
      msec_sleep((unsigned int )10);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 301
    (*((p->rmesth)->del))(p->rmesth);
#line 302
    p->rmesth = (athread *)((void *)0);
    }
  }
#line 305
  if (p->sessionId != (void *)0) {
    {
#line 306
    free(p->sessionId);
#line 307
    p->sessionId = (char *)((void *)0);
    }
  }
#line 310
  if (p->transportId != (void *)0) {
    {
#line 311
    free(p->transportId);
#line 312
    p->transportId = (char *)((void *)0);
    }
  }
#line 315
  p->mediaSessionId = 0;
#line 317
  if (p->messv != (void *)0) {
    {
#line 318
    (*((p->messv)->del))(p->messv);
#line 319
    p->messv = (struct _ccmessv *)((void *)0);
    }
  }
#line 325
  mes = p->rmes;
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (mes != (void *)0)) {
#line 325
      goto while_break___0;
    }
    {
#line 326
    xmes = mes->next;
#line 327
    ccmes_del(mes);
    }
#line 325
    mes = xmes;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 329
  p->rmes = (struct _ccmes *)((void *)0);
  return;
}
}
#line 335 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void shutdown_ccast(ccast *p ) 
{ 
  ccmes mes ;
  int reqid ;
  char mesbuf[1024] ;

  {
  {
#line 340
  ccmes_init(& mes);
#line 342
  p->stop = 1;
  }
#line 345
  if (p->transportId != (void *)0) {
#line 345
    if (p->messv != (void *)0) {
      {
#line 346
      mes.source_id = "sender-0\220";
#line 347
      mes.destination_id = p->transportId;
#line 348
      mes.namespace = "urn:x-cast:com.google.cast.tp.connection\220";
#line 349
      mes.binary = 0;
#line 350
      mes.data = (uint8_t *)"{ \"type\": \"CLOSE\" }";
#line 351
      (*((p->messv)->send))(p->messv, & mes);
      }
    }
  }
#line 355
  if (p->sessionId != (void *)0) {
#line 355
    if (p->messv != (void *)0) {
      {
#line 356
      (p->requestId) ++;
#line 356
      reqid = p->requestId;
#line 358
      sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"STOP\", \"sessionId\": \"%s\" }",
              reqid, p->sessionId);
#line 360
      mes.source_id = "sender-0\220";
#line 361
      mes.destination_id = "receiver-0";
#line 362
      mes.namespace = "urn:x-cast:com.google.cast.receiver";
#line 363
      mes.binary = 0;
#line 364
      mes.data = (uint8_t *)((char *)mesbuf);
#line 365
      (*((p->messv)->send))(p->messv, & mes);
      }
    }
  }
#line 369
  if (p->messv != (void *)0) {
    {
#line 370
    mes.source_id = "sender-0\220";
#line 371
    mes.destination_id = "receiver-0";
#line 372
    mes.namespace = "urn:x-cast:com.google.cast.receiver";
#line 373
    mes.binary = 0;
#line 374
    mes.data = (uint8_t *)"{ \"type\": \"CLOSE\" }";
#line 375
    (*((p->messv)->send))(p->messv, & mes);
    }
  }
  {
#line 378
  cleanup_ccast(p);
  }
  return;
}
}
#line 381 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void del_ccast(ccast *p ) 
{ 


  {
#line 382
  if (p != (void *)0) {
    {
#line 384
    shutdown_ccast(p);
#line 386
    pthread_mutex_destroy(& p->rlock);
#line 387
    pthread_cond_destroy(& p->rcond);
#line 389
    free(p);
    }
  }
  return;
}
}
#line 393
static int load_ccast(ccast *p , char *url , unsigned char *ibuf , size_t ilen , double bg[3] ,
                      double x , double y , double w , double h ) ;
#line 395
void ccast_install_signal_handlers(ccast *p ) ;
#line 399 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int start_ccast(ccast *p ) 
{ 
  ccpacket *pk ;
  ccpacket_err perr ;
  ccmessv_err merr ;
  ccmes mes ;
  ccmes rmes ;
  char mesbuf[1024] ;
  int reqid ;
  int tries ;
  int maxtries ;
  char *connection_chan ;
  char *heartbeat_chan ;
  char *receiver_chan ;
  int app ;
  int naps ;
  char *__cil_tmp16 ;
  ccpacket *__cil_tmp17 ;
  ccpacket_err __cil_tmp18 ;
  ccmessv *__cil_tmp19 ;
  ccmessv_err __cil_tmp20 ;
  athread *__cil_tmp21 ;
  char *appid ;
  ccmessv_err __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  yajl_val idn ;
  yajl_val tpn ;
  yajl_val __cil_tmp30 ;
  yajl_val __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *tmp ;
  char *__cil_tmp34 ;
  char *tmp___0 ;
  ccmessv_err __cil_tmp36 ;
  int __cil_tmp37 ;

  {
#line 400
  pk = (ccpacket *)((void *)0);
#line 405
  maxtries = 6;
#line 406
  connection_chan = "urn:x-cast:com.google.cast.tp.connection\220";
#line 407
  heartbeat_chan = "urn:x-cast:com.google.cast.tp.heartbeat";
#line 408
  receiver_chan = "urn:x-cast:com.google.cast.receiver";
#line 411
  tries = 0;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (tries < maxtries)) {
#line 411
      goto while_break;
    }
#line 412
    app = 0;
    {
#line 412
    naps = 2;
#line 415
    __cil_tmp16 = getenv("ARGYLL_CCAST_DEFAULT_RECEIVER");
    }
#line 415
    if (__cil_tmp16 != (void *)0) {
#line 416
      app = 1;
    } else
#line 415
    if (p->forcedef) {
#line 416
      app = 1;
    }
    {
#line 418
    ccmes_init(& mes);
#line 419
    ccmes_init(& rmes);
#line 421
    p->stop = 0;
#line 422
    p->stopped = 0;
#line 425
    pthread_mutex_init(& p->rlock, (pthread_mutexattr_t *)((void *)0));
#line 426
    pthread_cond_init(& p->rcond, (pthread_condattr_t *)((void *)0));
#line 429
    pk = new_ccpacket();
    }
#line 429
    if (pk == (void *)0) {

#line 431
      goto retry;
    }
    {
#line 434
    perr = (*(pk->connect))(pk, p->id.ip, 8009);
    }
#line 434
    if ((unsigned int )perr != 0U) {

#line 436
      goto retry;
    }
    {
#line 441
    p->messv = new_ccmessv(pk);
    }
#line 441
    if (p->messv == (void *)0) {

#line 443
      goto retry;
    }
    {
#line 445
    pk = (ccpacket *)((void *)0);
#line 448
    mes.source_id = "sender-0\220";
#line 449
    mes.destination_id = "receiver-0";
#line 450
    mes.namespace = connection_chan;
#line 451
    mes.binary = 0;
#line 452
    mes.data = (uint8_t *)"{ \"type\": \"CONNECT\" }";
#line 453
    merr = (*((p->messv)->send))(p->messv, & mes);
    }
#line 453
    if ((unsigned int )merr != 0U) {

#line 455
      goto retry;
    }
    {
#line 461
    p->rmesth = new_athread_reusable(& cc_rec_thread, (void *)p, 0);
    }
#line 461
    if (p->rmesth == (void *)0) {

#line 463
      goto retry;
    }
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (! (app < naps)) {
#line 480
        goto while_break___0;
      }
#line 483
      (p->requestId) ++;
#line 483
      reqid = p->requestId;
#line 485
      if (app == 0) {
#line 486
        appid = "B5C2CBFC\220";
#line 487
        p->patgenrcv = 1;
#line 488
        p->load_delay = (int )350.;
      } else {
#line 490
        appid = "CC1AD845\220";
#line 491
        p->patgenrcv = 0;
#line 492
        p->load_delay = (int )1500.;
      }
      {
#line 497
      sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"LAUNCH\", \"appId\": \"%s\" }",
              reqid, appid);
#line 504
      mes.namespace = receiver_chan;
#line 505
      mes.data = (uint8_t *)((char *)mesbuf);
#line 506
      merr = (*((p->messv)->send))(p->messv, & mes);
      }
#line 506
      if ((unsigned int )merr != 0U) {

#line 508
        goto retry;
      }
      {
#line 517
      __cil_tmp24 = get_a_reply_id(p, receiver_chan, reqid, & rmes, 15000);
      }
#line 517
      if (__cil_tmp24 != 0) {

#line 519
        goto retry;
      }
      {
#line 522
      __cil_tmp25 = strcmp((char const   *)rmes.mtype, "RECEIVER_STATUS");
      }
#line 522
      if (rmes.mtype != (void *)0) {
#line 522
        if (__cil_tmp25 == 0) {
#line 522
          if (rmes.tnode != (void *)0) {
#line 525
            goto while_break___0;
          }
        }
      }
      {
#line 528
      __cil_tmp26 = strcmp((char const   *)rmes.mtype, "LAUNCH_ERROR");
      }
#line 528
      if (rmes.mtype == (void *)0) {
        {
        {
        {
        {
#line 533
        ccmes_empty(& rmes);
        }
        }
        }
        }
#line 534
        goto retry;
      } else
#line 528
      if (__cil_tmp26 != 0) {
        {
        {
        {
        {
#line 533
        ccmes_empty(& rmes);
        }
        }
        }
        }
#line 534
        goto retry;
      } else
#line 528
      if (rmes.tnode == (void *)0) {
        {
        {
        {
        {
#line 533
        ccmes_empty(& rmes);
        }
        }
        }
        }
#line 534
        goto retry;
      } else
#line 528
      if (app + 1 >= naps) {
        {
        {
        {
        {
#line 533
        ccmes_empty(& rmes);
        }
        }
        }
        }
#line 534
        goto retry;
      }
#line 480
      app ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 543
    tpn = yajl_tree_get_first(rmes.tnode, "transportId", (yajl_type )1);
    }
    {
#line 543
    idn = yajl_tree_get_first(rmes.tnode, "sessionId", (yajl_type )1);
    }
#line 543
    if (idn == (void *)0) {
      {
      {
#line 546
      ccmes_empty(& rmes);
      }
      }
#line 547
      goto retry;
    } else
#line 543
    if (tpn == (void *)0) {
      {
      {
#line 546
      ccmes_empty(& rmes);
      }
      }
#line 547
      goto retry;
    }
#line 549
    if (idn != (void *)0 && (unsigned int )idn->type == 1U) {
      {
#line 549
      __cil_tmp32 = strdup((char const   *)idn->u.string);
#line 549
      tmp = __cil_tmp32;
      }
    } else {
#line 549
      tmp = (char *)((void *)0);
    }
#line 549
    p->sessionId = tmp;
#line 550
    if (tpn != (void *)0 && (unsigned int )tpn->type == 1U) {
      {
#line 550
      __cil_tmp34 = strdup((char const   *)tpn->u.string);
#line 550
      tmp___0 = __cil_tmp34;
      }
    } else {
#line 550
      tmp___0 = (char *)((void *)0);
    }
#line 550
    p->transportId = tmp___0;
#line 551
    if (p->sessionId == (void *)0) {
      {
      {
#line 553
      ccmes_empty(& rmes);
      }
      }
#line 554
      goto retry;
    } else
#line 551
    if (p->transportId == (void *)0) {
      {
      {
#line 553
      ccmes_empty(& rmes);
      }
      }
#line 554
      goto retry;
    }
    {
#line 557
    ccmes_empty(& rmes);
#line 562
    mes.destination_id = p->transportId;
#line 563
    mes.namespace = connection_chan;
#line 564
    mes.data = (uint8_t *)"{ \"type\": \"CONNECT\" }";
#line 565
    merr = (*((p->messv)->send))(p->messv, & mes);
    }
#line 565
    if ((unsigned int )merr != 0U) {

#line 567
      goto retry;
    }
#line 573
    goto while_break;
    retry: ;
#line 578
    if (pk != (void *)0) {
      {
#line 579
      (*(pk->del))(pk);
#line 580
      pk = (ccpacket *)((void *)0);
      }
    }
    {
#line 583
    cleanup_ccast(p);
    }
#line 411
    tries ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  if (tries >= maxtries) {

#line 589
    return (1);
  }
  {
#line 594
  ccast_install_signal_handlers(p);
  }
#line 596
  return (0);
}
}
#line 602 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int get_load_delay(ccast *p ) 
{ 


  {
#line 603
  return (p->load_delay);
}
}
#line 608 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int get_direct_send(ccast *p ) 
{ 


  {
#line 609
  return (p->patgenrcv);
}
}
#line 614 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
ccast *new_ccast(ccast_id *id , int forcedef ) 
{ 
  ccast *p ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 616
  p = (ccast *)((void *)0);
#line 618
  __cil_tmp4 = calloc((unsigned long )1, sizeof(ccast ));
#line 618
  p = (ccast *)__cil_tmp4;
  }
#line 618
  if (p == (void *)0) {

#line 620
    return ((ccast *)((void *)0));
  }
  {
#line 624
  p->del = & del_ccast;
#line 625
  p->load = & load_ccast;
#line 626
  p->shutdown = & shutdown_ccast;
#line 627
  p->get_load_delay = & get_load_delay;
#line 628
  p->get_direct_send = & get_direct_send;
#line 633
  p->forcedef = forcedef;
#line 635
  ccast_id_copy(& p->id, id);
#line 638
  __cil_tmp5 = start_ccast(p);
  }
#line 638
  if (__cil_tmp5) {
    {
#line 639
    del_ccast(p);
    }
#line 640
    return ((ccast *)((void *)0));
  }
#line 643
  return (p);
}
}
#line 651 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static int load_ccast(ccast *p , char *url , unsigned char *ibuf , size_t ilen , double bg[3] ,
                      double x , double y , double w , double h ) 
{ 
  ccmessv_err merr ;
  int reqid ;
  int firstid ;
  int lastid ;
  ccmes mes ;
  char *media_chan ;
  char *direct_chan ;
  char *receiver_chan ;
  int dchan ;
  int i ;
  int maxtries ;
  int rv ;
  unsigned char *iibuf ;
  size_t iilen ;
  char *xl ;
  char mesbuf[1024] ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  ccmessv_err __cil_tmp29 ;
  char *mesbuf___0 ;
  char *cp ;
  size_t maxlen ;
  size_t meslen ;
  size_t enclen ;
  size_t senclen ;
  int dlen ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  ccmessv_err __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  int __cil_tmp55 ;
  ccmessv_err __cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;
  yajl_val errors ;
  yajl_val __cil_tmp61 ;
  yajl_val error___48 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  char *tmp ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;
  yajl_val errors___0 ;
  yajl_val __cil_tmp70 ;
  yajl_val error___50 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  yajl_val node ;
  yajl_val i___51 ;
  yajl_val __cil_tmp76 ;
  int __cil_tmp77 ;
  int __cil_tmp78 ;
  int __cil_tmp79 ;

  {
#line 662
  media_chan = "urn:x-cast:com.google.cast.media\220";
#line 663
  direct_chan = "urn:x-cast:net.hoech.cast.patterngeneratorn\032\313U";
#line 664
  receiver_chan = "urn:x-cast:com.google.cast.receiver";
#line 666
  dchan = 0;
#line 667
  maxtries = 4;
  {
#line 667
  rv = 0;
#line 669
  ccmes_init(& mes);
#line 672
  i = 0;
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! 1) {
#line 672
      goto while_break;
    }
#line 673
    iibuf = ibuf;
#line 674
    iilen = ilen;
#line 675
    (p->requestId) ++;
#line 675
    reqid = p->requestId;
#line 675
    lastid = reqid;
#line 675
    firstid = lastid;
#line 679
    if (p->messv == (void *)0) {

    } else {
#line 684
      if (url == (void *)0) {
#line 684
        if (! p->patgenrcv) {

#line 686
          return (1);
        }
      }
#line 690
      if (url != (void *)0) {
        {
#line 693
        xl = strrchr((char const   *)url, '.');
#line 695
        __cil_tmp27 = strcasecmp((char const   *)xl, ".webmU");
        }
#line 695
        if (xl != (void *)0) {
#line 695
          if (__cil_tmp27 == 0) {
            {
#line 696
            sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"LOAD\", \"media\": { \"contentId\": \"%s\",",
                    reqid, url);
#line 698
            strcat((char *)mesbuf, "\"contentType\": \"video/webm\" },\"autplay\": \"true\" }U");
            }
          } else {
#line 695
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 702
          __cil_tmp28 = strcasecmp((char const   *)xl, ".mp4");
          }
#line 702
          if (xl != (void *)0) {
#line 702
            if (__cil_tmp28 == 0) {
              {
#line 703
              sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"LOAD\", \"media\": { \"contentId\": \"%s\",\313U",
                      reqid, url);
#line 705
              strcat((char *)mesbuf, "\"contentType\": \"video/mp4\" },\"autplay\": \"true\" }\313U");
              }
            } else {
              {
              {
#line 710
              sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"LOAD\", \"media\": { \"contentId\": \"%s\",",
                      reqid, url);
              }
              {
#line 712
              strcat((char *)mesbuf, "\"contentType\": \"image/png\" } }");
              }
              }
            }
          } else {
            {
            {
#line 710
            sprintf((char *)mesbuf, "{ \"requestId\": %d, \"type\": \"LOAD\", \"media\": { \"contentId\": \"%s\",",
                    reqid, url);
            }
            {
#line 712
            strcat((char *)mesbuf, "\"contentType\": \"image/png\" } }");
            }
            }
          }
        }
        {
#line 716
        mes.source_id = "sender-0\220";
#line 717
        mes.destination_id = p->transportId;
#line 718
        mes.namespace = media_chan;
#line 719
        mes.binary = 0;
#line 720
        mes.data = (uint8_t *)((char *)mesbuf);
#line 724
        merr = (*((p->messv)->send))(p->messv, & mes);
        }
#line 724
        if ((unsigned int )merr != 0U) {
#line 726
          rv = 1;
#line 727
          goto retry;
        }
      } else
#line 771
      if (iibuf != (void *)0) {
        {
#line 774
        senclen = (size_t )0;
#line 777
        mesbuf___0 = (char *)malloc((unsigned long )62464);
        }
#line 777
        if (mesbuf___0 == (void *)0) {

#line 779
          return (1);
        }
#line 782
        dchan = 1;
#line 784
        enclen = (ilen * 4UL + 2UL) / 3UL;
#line 785
        maxlen = (size_t )46080;
#line 786
        meslen = iilen;
#line 787
        if (meslen > maxlen) {
#line 788
          meslen = maxlen;
        }
        {
#line 790
        cp = mesbuf___0;
#line 791
        __cil_tmp38 = sprintf(cp, "{ n\032\313U");
        }
        {
#line 791
        cp += __cil_tmp38;
#line 792
        __cil_tmp39 = sprintf(cp, "\"requestId\": %d,\230\001", reqid);
        }
        {
#line 792
        cp += __cil_tmp39;
#line 793
        __cil_tmp40 = sprintf(cp, "\"foreground\": { \220");
        }
        {
#line 793
        cp += __cil_tmp40;
#line 794
        __cil_tmp41 = sprintf(cp, "\"contentType\": \"image/png\",");
        }
        {
#line 794
        cp += __cil_tmp41;
#line 795
        __cil_tmp42 = sprintf(cp, "\"encoding\": \"base64\",");
        }
        {
#line 795
        cp += __cil_tmp42;
#line 796
        __cil_tmp43 = sprintf(cp, "\"data\": \"");
        }
        {
#line 796
        cp += __cil_tmp43;
#line 797
        ebase64(& dlen, cp, iibuf, (int )meslen);
#line 799
        iibuf += meslen;
#line 800
        iilen -= meslen;
#line 801
        senclen += (unsigned long )dlen;
#line 802
        cp += dlen;
#line 803
        __cil_tmp44 = sprintf(cp, "\",");
        }
        {
#line 803
        cp += __cil_tmp44;
#line 804
        __cil_tmp45 = sprintf(cp, "\"size\": %lu\032\313U", (unsigned long )((ilen * 4UL + 2UL) / 3UL));
        }
        {
#line 804
        cp += __cil_tmp45;
#line 805
        __cil_tmp46 = sprintf(cp, " },\032\313U");
        }
        {
#line 805
        cp += __cil_tmp46;
#line 807
        __cil_tmp47 = sprintf(cp, "\"background\": \"rgb(%d, %d, %d)\",\230\001",
                              (int )(bg[0] * 255. + 0.5), (int )(bg[1] * 255. + 0.5),
                              (int )(bg[2] * 255. + 0.5));
        }
        {
#line 807
        cp += __cil_tmp47;
#line 812
        __cil_tmp48 = sprintf(cp, "\"offset\": [%f, %f],", x, y);
        }
        {
#line 812
        cp += __cil_tmp48;
#line 813
        __cil_tmp49 = sprintf(cp, "\"scale\": [%f, %f]", w, h);
        }
        {
#line 813
        cp += __cil_tmp49;
#line 814
        __cil_tmp50 = sprintf(cp, " }");
        }
        {
#line 814
        cp += __cil_tmp50;
#line 816
        mes.source_id = "sender-0\220";
#line 817
        mes.destination_id = p->transportId;
#line 818
        mes.namespace = direct_chan;
#line 819
        mes.binary = 0;
#line 820
        mes.data = (uint8_t *)mesbuf___0;
#line 825
        merr = (*((p->messv)->send))(p->messv, & mes);
        }
#line 825
        if ((unsigned int )merr != 0U) {
          {
#line 827
          free(mesbuf___0);
#line 828
          rv = 1;
          }
#line 829
          goto retry;
        }
        {
#line 833
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 833
          if (! (iilen > 0UL)) {
#line 833
            goto while_break___0;
          }
#line 836
          meslen = iilen;
#line 837
          if (meslen > maxlen) {
#line 838
            meslen = maxlen;
          }
          {
#line 842
          (p->requestId) ++;
#line 842
          reqid = p->requestId;
#line 842
          lastid = reqid;
#line 844
          cp = mesbuf___0;
#line 845
          __cil_tmp52 = sprintf(cp, "{ n\032\313U");
          }
          {
#line 845
          cp += __cil_tmp52;
#line 846
          __cil_tmp53 = sprintf(cp, "\"requestId\": %d,\230\001", reqid);
          }
          {
#line 846
          cp += __cil_tmp53;
#line 847
          __cil_tmp54 = sprintf(cp, "\"foreground\": \"");
          }
          {
#line 847
          cp += __cil_tmp54;
#line 848
          ebase64(& dlen, cp, iibuf, (int )meslen);
#line 850
          iibuf += meslen;
#line 851
          iilen -= meslen;
#line 852
          senclen += (unsigned long )dlen;
#line 855
          cp += dlen;
#line 856
          __cil_tmp55 = sprintf(cp, "\" }");
          }
          {
#line 856
          cp += __cil_tmp55;
#line 858
          mes.source_id = "sender-0\220";
#line 859
          mes.destination_id = p->transportId;
#line 860
          mes.namespace = direct_chan;
#line 861
          mes.binary = 0;
#line 862
          mes.data = (uint8_t *)mesbuf___0;
#line 866
          merr = (*((p->messv)->send))(p->messv, & mes);
          }
#line 866
          if ((unsigned int )merr != 0U) {
            {
#line 868
            free(mesbuf___0);
#line 869
            rv = 1;
            }
#line 870
            goto retry;
          }
#line 873
          if (lastid - firstid > 0) {
            {
#line 876
            __cil_tmp57 = get_a_reply_id(p, direct_chan, firstid, & mes, 10000);
            }
#line 876
            if (__cil_tmp57 != 0) {
#line 878
              rv = 2;
#line 879
              goto retry;
            }
#line 881
            if (mes.mtype == (void *)0) {
#line 883
              rv = 2;
#line 884
              goto retry;
            } else {
              {
#line 886
              __cil_tmp58 = strcmp((char const   *)mes.mtype, "ACK");
              }
#line 886
              if (dchan) {
#line 886
                if (__cil_tmp58 == 0) {

                } else {
#line 886
                  goto _L___49;
                }
              } else {
                _L___49: /* CIL Label */ 
                {
#line 889
                __cil_tmp59 = strcmp((char const   *)mes.mtype, "NACK");
                }
#line 889
                if (dchan) {
#line 889
                  if (__cil_tmp59 == 0) {
                    {
#line 892
                    errors = yajl_tree_get_first(mes.tnode, "errors", (yajl_type )4);
                    }
#line 892
                    if (errors != (void *)0) {

#line 894
                      if (errors != (void *)0) {
#line 894
                        if ((unsigned int )errors->type == 4U) {
#line 895
                          i = 0;
                          {
#line 895
                          while (1) {
                            while_continue___1: /* CIL Label */ ;
#line 895
                            if (! ((unsigned long )i < errors->u.array.len)) {
#line 895
                              goto while_break___1;
                            }
#line 896
                            error___48 = *(errors->u.array.values + i);
#line 895
                            i ++;
                          }
                          while_break___1: /* CIL Label */ ;
                          }
                        } else {

                        }
                      } else {

                      }
                    } else {

                    }
#line 906
                    rv = 2;
#line 907
                    goto retry;
                  } else {
#line 910
                    rv = 3;
#line 912
                    goto retry;
                  }
                } else {
#line 910
                  rv = 3;
#line 912
                  goto retry;
                }
              }
            }
            {
#line 914
            ccmes_empty(& mes);
#line 915
            firstid ++;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 918
        free(mesbuf___0);
        }
#line 921
        if (iilen == 0UL) {
#line 921
          if (senclen != enclen) {
            {
#line 922
            fprintf(stderr, "ccast load finished but senclen %lu != enclen %lu\n",
                    (unsigned long )senclen, (unsigned long )enclen);
            }
          }
        }
      } else {

#line 928
        return (1);
      }
    }
#line 933
    reqid = firstid;
    {
#line 933
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 933
      if (! (reqid <= lastid)) {
#line 933
        goto while_break___2;
      }
#line 935
      if (dchan) {
#line 935
        tmp = direct_chan;
      } else {
#line 935
        tmp = media_chan;
      }
      {
#line 935
      __cil_tmp66 = get_a_reply_id(p, tmp, reqid, & mes, 5000);
      }
#line 935
      if (__cil_tmp66 != 0) {
#line 937
        rv = 2;
#line 938
        goto retry;
      }
#line 950
      if (mes.mtype == (void *)0) {
#line 952
        rv = 2;
#line 953
        goto retry;
      } else {
        {
#line 955
        __cil_tmp67 = strcmp((char const   *)mes.mtype, "ACK");
        }
#line 955
        if (dchan) {
#line 955
          if (__cil_tmp67 == 0) {

          } else {
#line 955
            goto _L___53;
          }
        } else {
          _L___53: /* CIL Label */ 
          {
#line 958
          __cil_tmp68 = strcmp((char const   *)mes.mtype, "NACK");
          }
#line 958
          if (dchan) {
#line 958
            if (__cil_tmp68 == 0) {
              {
#line 961
              errors___0 = yajl_tree_get_first(mes.tnode, "errors", (yajl_type )4);
              }
#line 961
              if (errors___0 != (void *)0) {

#line 963
                if (errors___0 != (void *)0) {
#line 963
                  if ((unsigned int )errors___0->type == 4U) {
#line 964
                    i = 0;
                    {
#line 964
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 964
                      if (! ((unsigned long )i < errors___0->u.array.len)) {
#line 964
                        goto while_break___3;
                      }
#line 965
                      error___50 = *(errors___0->u.array.values + i);
#line 964
                      i ++;
                    }
                    while_break___3: /* CIL Label */ ;
                    }
                  } else {

                  }
                } else {

                }
              } else {

              }
#line 975
              rv = 2;
#line 976
              goto retry;
            } else {
#line 958
              goto _L___52;
            }
          } else {
            _L___52: /* CIL Label */ 
            {
#line 978
            __cil_tmp73 = strcmp((char const   *)mes.mtype, "MEDIA_STATUS");
            }
#line 978
            if (__cil_tmp73 == 0) {
              {
#line 980
              i___51 = yajl_tree_get_first(mes.tnode, "mediaSessionId", (yajl_type )2);
              }
#line 980
              if (i___51 != (void *)0) {
#line 981
                p->mediaSessionId = (int )i___51->u.number.i;
              } else {

              }
            } else {
#line 989
              rv = 3;
#line 991
              goto retry;
            }
          }
        }
      }
      {
#line 993
      ccmes_empty(& mes);
      }
#line 933
      reqid ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 996
    goto while_break;
    retry: ;
#line 1001
    if (i + 1 >= maxtries) {
#line 1002
      return (rv);
    }
    {
#line 1006
    shutdown_ccast(p);
#line 1007
    __cil_tmp78 = start_ccast(p);
    }
#line 1007
    if (__cil_tmp78) {

#line 1009
      return (1);
    }
#line 1012
    rv = 0;
#line 672
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  p->loaded1 = 1;
#line 1020
  if ((double )p->load_delay > 0.) {
    {
#line 1021
    msec_sleep((unsigned int )p->load_delay);
    }
  }
#line 1023
  return (rv);
}
}
#line 1029 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static ccast *ccast_list  =    (ccast *)((void *)0);
#line 1032 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void ccast_cleanup(void) 
{ 
  ccast *pp ;
  ccast *np ;

  {
#line 1035
  pp = ccast_list;
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! (pp != (void *)0)) {
#line 1035
      goto while_break;
    }
    {
#line 1036
    np = pp->next;
#line 1037
    a1logd(g_log, 2, "ccast_cleanup: closing 0x%x\n", pp);
#line 1038
    (*(pp->shutdown))(pp);
    }
#line 1035
    pp = np;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 1047 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void (*ccast_hup)(int  )  =    (__sighandler_t )0;
#line 1048 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void (*ccast_int)(int  )  =    (__sighandler_t )0;
#line 1049 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void (*ccast_term)(int  )  =    (__sighandler_t )0;
#line 1053 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
static void ccast_sighandler(int arg ) 
{ 
  static pthread_mutex_t lock ;
  int __cil_tmp3 ;

  {
#line 1054
  lock.__data.__lock = 0;
#line 1054
  lock.__data.__count = (unsigned int )0;
#line 1054
  lock.__data.__owner = 0;
#line 1054
  lock.__data.__nusers = (unsigned int )0;
#line 1054
  lock.__data.__kind = 0;
#line 1054
  lock.__data.__spins = (short )0;
#line 1054
  lock.__data.__elision = (short )0;
#line 1054
  lock.__data.__list.__prev = (struct __pthread_internal_list *)0;
  {
#line 1054
  lock.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 1056
  a1logd(g_log, 2, "ccast_sighandler: invoked with arg = %d\n\230\001", arg);
#line 1059
  __cil_tmp3 = pthread_mutex_trylock(& lock);
  }
#line 1059
  if (__cil_tmp3) {
#line 1060
    return;
  }
  {
#line 1063
  ccast_cleanup();
#line 1064
  a1logd(g_log, 2, "ccast_sighandler: done ccast_sighandler()\n");
  }
#line 1068
  if (ccast_hup != (__sighandler_t )0) {
#line 1068
    if (arg == 1) {
#line 1068
      if (ccast_hup != (__sighandler_t )1) {
        {
#line 1069
        (*ccast_hup)(arg);
        }
      }
    }
  }
#line 1071
  if (ccast_int != (__sighandler_t )0) {
#line 1071
    if (arg == 2) {
#line 1071
      if (ccast_int != (__sighandler_t )1) {
        {
#line 1072
        (*ccast_int)(arg);
        }
      }
    }
  }
#line 1073
  if (ccast_term != (__sighandler_t )0) {
#line 1073
    if (arg == 15) {
#line 1073
      if (ccast_term != (__sighandler_t )1) {
        {
#line 1074
        (*ccast_term)(arg);
        }
      }
    }
  }
  {
#line 1076
  a1logd(g_log, 2, "ccast_sighandler: calling exit()\n");
#line 1078
  pthread_mutex_unlock(& lock);
#line 1079
  exit(0);
  }
}
}
#line 1084 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void ccast_install_signal_handlers(ccast *p ) 
{ 
  __sighandler_t __cil_tmp2 ;
  __sighandler_t __cil_tmp3 ;
  __sighandler_t __cil_tmp4 ;

  {
#line 1086
  if (ccast_list == (void *)0) {
    {
#line 1087
    a1logd(g_log, 2, "ccast_install_signal_handlers: called\n");
#line 1089
    ccast_hup = signal(1, & ccast_sighandler);
#line 1091
    ccast_int = signal(2, & ccast_sighandler);
#line 1092
    ccast_term = signal(15, & ccast_sighandler);
    }
  }
  {
#line 1096
  p->next = ccast_list;
#line 1097
  ccast_list = p;
#line 1098
  a1logd(g_log, 6, "ccast_install_signal_handlers: done\n");
  }
  return;
}
}
#line 1102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void ccast_delete_from_cleanup_list(ccast *p ) 
{ 
  ccast *pp ;

  {
#line 1105
  if (ccast_list != (void *)0) {
    {
#line 1106
    a1logd(g_log, 6, "ccast_install_signal_handlers: called\n");
    }
#line 1107
    if (ccast_list == p) {
#line 1108
      ccast_list = p->next;
#line 1109
      if (ccast_list == (void *)0) {
        {
#line 1111
        signal(1, ccast_hup);
#line 1113
        signal(2, ccast_int);
#line 1114
        signal(15, ccast_term);
        }
      }
    } else {
#line 1118
      pp = ccast_list;
      {
#line 1118
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1118
        if (! (pp != (void *)0)) {
#line 1118
          goto while_break;
        }
#line 1119
        if (pp->next == p) {
#line 1120
          pp->next = p->next;
#line 1121
          goto while_break;
        }
#line 1118
        pp = pp->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1125
    a1logd(g_log, 6, "ccast_install_signal_handlers: done\n");
    }
  }
  return;
}
}
#line 1136 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void ccastQuant(void *ctx , double out[3] , double in[3] ) 
{ 
  double r ;
  double g ;
  double b ;
  double Y ;
  double Cb ;
  double Cr ;
  double or ;
  double og ;
  double ob ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;
  double __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  double __cil_tmp23 ;
  double __cil_tmp24 ;
  double __cil_tmp25 ;
  double __cil_tmp26 ;
  double __cil_tmp27 ;
  double __cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;

  {
#line 1137
  r = in[0];
#line 1137
  g = in[1];
#line 1137
  b = in[2];
#line 1140
  or = r;
#line 1140
  og = g;
  {
#line 1140
  ob = b;
#line 1144
  r = floor(r * 255. + 0.5);
#line 1145
  g = floor(g * 255. + 0.5);
#line 1146
  b = floor(b * 255. + 0.5);
#line 1149
  __cil_tmp18 = floor((((235. - 16.) * 0.0722000000001) / 255.) * 512. + 0.5);
  }
  {
#line 1149
  __cil_tmp17 = floor((((235. - 16.) * 0.7152) / 255.) * 512. + 0.5);
  }
  {
#line 1149
  __cil_tmp16 = floor((((235. - 16.) * 0.212600000001) / 255.) * 512. + 0.5);
#line 1149
  Y = (r * (__cil_tmp16 / 512.) + g * (__cil_tmp17 / 512.)) + b * (__cil_tmp18 / 512.);
#line 1153
  __cil_tmp21 = floor((((240. - 16.) * (1. - 0.0722000000001)) / (255. * 1.8556)) * 512. + 0.5);
  }
  {
#line 1153
  __cil_tmp20 = floor((((240. - 16.) * 0.7152) / (255. * 1.8556)) * 512. + 0.5);
  }
  {
#line 1153
  __cil_tmp19 = floor((((240. - 16.) * 0.212600000001) / (255. * 1.8556)) * 512. + 0.5);
#line 1153
  Cb = (r * - (__cil_tmp19 / 512.) + g * - (__cil_tmp20 / 512.)) + b * (__cil_tmp21 / 512.);
#line 1157
  __cil_tmp24 = floor((((240. - 16.) * 0.0722000000001) / (255. * 1.5748)) * 512. + 0.5);
  }
  {
#line 1157
  __cil_tmp23 = floor((((240. - 16.) * 0.7152) / (255. * 1.5748)) * 512. + 0.5);
  }
  {
#line 1157
  __cil_tmp22 = floor((((240. - 16.) * (1. - 0.212600000001)) / (255. * 1.5748)) * 512. + 0.5);
#line 1157
  Cr = (r * (__cil_tmp22 / 512.) + g * - (__cil_tmp23 / 512.)) + b * - (__cil_tmp24 / 512.);
#line 1164
  Y = floor(Y + 0.5);
#line 1165
  Cb = floor(Cb + 0.5);
#line 1166
  Cr = floor(Cr + 0.5);
#line 1170
  r = (Y * 255.) / (235. - 16.) + (Cr * (1.5748 * 255.)) / (240. - 16.);
#line 1173
  g = ((Y * 255.) / (235. - 16.) + (Cb * (- 0.187324273001 * 255.)) / (240. - 16.)) + (Cr * (- 0.468124273 * 255.)) / (240. - 16.);
#line 1177
  b = (Y * 255.) / (235. - 16.) + (Cb * (1.8556 * 255.)) / (240. - 16.);
  }
#line 1181
  if (r > 255.) {
#line 1182
    r = 255.;
  } else
#line 1183
  if (r < 0.) {
#line 1184
    r = 0.;
  }
#line 1185
  if (g > 255.) {
#line 1186
    g = 255.;
  } else
#line 1187
  if (g < 0.) {
#line 1188
    g = 0.;
  }
#line 1189
  if (b > 255.) {
#line 1190
    b = 255.;
  } else
#line 1191
  if (b < 0.) {
#line 1192
    b = 0.;
  }
  {
#line 1196
  __cil_tmp28 = floor(r + 0.5);
#line 1196
  r = __cil_tmp28 / 255.;
#line 1197
  __cil_tmp29 = floor(g + 0.5);
#line 1197
  g = __cil_tmp29 / 255.;
#line 1198
  __cil_tmp30 = floor(b + 0.5);
#line 1198
  b = __cil_tmp30 / 255.;
#line 1200
  out[0] = r;
#line 1201
  out[1] = g;
#line 1202
  out[2] = b;
#line 1204
  __cil_tmp33 = fabs(ob - b);
  }
  {
#line 1204
  __cil_tmp32 = fabs(og - g);
  }
  {
#line 1204
  __cil_tmp31 = fabs(or - r);
  }
#line 1204
  if (__cil_tmp31 > 3.) {
    {
    {
    {
#line 1207
    printf("%f %f %f -> %f %f %f\nU", or, og, ob, r, g, b);
    }
    }
    }
  } else
#line 1204
  if (__cil_tmp32 > 3.) {
    {
    {
    {
#line 1207
    printf("%f %f %f -> %f %f %f\nU", or, og, ob, r, g, b);
    }
    }
    }
  } else
#line 1204
  if (__cil_tmp33 > 3.) {
    {
    {
    {
#line 1207
    printf("%f %f %f -> %f %f %f\nU", or, og, ob, r, g, b);
    }
    }
    }
  }
  return;
}
}
#line 1214 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void ccast2YCbCr_nq(void *ctx , double out[3] , double in[3] ) 
{ 
  double r ;
  double g ;
  double b ;
  double Y ;
  double Cb ;
  double Cr ;
  double __cil_tmp10 ;
  double __cil_tmp11 ;
  double __cil_tmp12 ;
  double __cil_tmp13 ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  double __cil_tmp17 ;
  double __cil_tmp18 ;

  {
#line 1215
  r = in[0];
#line 1215
  g = in[1];
  {
#line 1215
  b = in[2];
#line 1221
  __cil_tmp12 = floor((((235. - 16.) * 0.0722000000001) / 255.) * 512. + 0.5);
  }
  {
#line 1221
  __cil_tmp11 = floor((((235. - 16.) * 0.7152) / 255.) * 512. + 0.5);
  }
  {
#line 1221
  __cil_tmp10 = floor((((235. - 16.) * 0.212600000001) / 255.) * 512. + 0.5);
#line 1221
  Y = ((r * (__cil_tmp10 / 512.) + g * (__cil_tmp11 / 512.)) + b * (__cil_tmp12 / 512.)) + 16.;
#line 1226
  __cil_tmp15 = floor((((240. - 16.) * (1. - 0.0722000000001)) / (255. * 1.8556)) * 512. + 0.5);
  }
  {
#line 1226
  __cil_tmp14 = floor((((240. - 16.) * 0.7152) / (255. * 1.8556)) * 512. + 0.5);
  }
  {
#line 1226
  __cil_tmp13 = floor((((240. - 16.) * 0.212600000001) / (255. * 1.8556)) * 512. + 0.5);
#line 1226
  Cb = ((r * - (__cil_tmp13 / 512.) + g * - (__cil_tmp14 / 512.)) + b * (__cil_tmp15 / 512.)) + 16.;
#line 1231
  __cil_tmp18 = floor((((240. - 16.) * 0.0722000000001) / (255. * 1.5748)) * 512. + 0.5);
  }
  {
#line 1231
  __cil_tmp17 = floor((((240. - 16.) * 0.7152) / (255. * 1.5748)) * 512. + 0.5);
  }
  {
#line 1231
  __cil_tmp16 = floor((((240. - 16.) * (1. - 0.212600000001)) / (255. * 1.5748)) * 512. + 0.5);
#line 1231
  Cr = ((r * (__cil_tmp16 / 512.) + g * - (__cil_tmp17 / 512.)) + b * - (__cil_tmp18 / 512.)) + 16.;
#line 1236
  out[0] = Y;
#line 1237
  out[1] = Cb;
#line 1238
  out[2] = Cr;
  }
  return;
}
}
#line 1244 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void ccast2YCbCr(void *ctx , double out[3] , double in[3] ) 
{ 
  double rgb[3] ;
  double __cil_tmp5 ;
  double __cil_tmp6 ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;

  {
  {
#line 1250
  rgb[0] = floor(in[0] + 0.5);
#line 1251
  rgb[1] = floor(in[1] + 0.5);
#line 1252
  rgb[2] = floor(in[2] + 0.5);
#line 1254
  ccast2YCbCr_nq(ctx, out, (double *)rgb);
#line 1257
  out[0] = floor(out[0] + 0.5);
#line 1258
  out[1] = floor(out[1] + 0.5);
#line 1259
  out[2] = floor(out[2] + 0.5);
  }
  return;
}
}
#line 1265 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
void YCbCr2ccast_nq(void *ctx , double out[3] , double in[3] ) 
{ 
  double Y ;
  double Cb ;
  double Cr ;
  double r ;
  double g ;
  double b ;

  {
#line 1266
  Y = in[0];
#line 1266
  Cb = in[1];
#line 1266
  Cr = in[2];
#line 1271
  Y -= 16.;
#line 1272
  Cb -= 16.;
#line 1273
  Cr -= 16.;
#line 1277
  r = (Y * 255.) / (235. - 16.) + (Cr * (1.5748 * 255.)) / (240. - 16.);
#line 1280
  g = ((Y * 255.) / (235. - 16.) + (Cb * (- 0.187324273001 * 255.)) / (240. - 16.)) + (Cr * (- 0.468124273 * 255.)) / (240. - 16.);
#line 1284
  b = (Y * 255.) / (235. - 16.) + (Cb * (1.8556 * 255.)) / (240. - 16.);
#line 1287
  out[0] = r;
#line 1288
  out[1] = g;
#line 1289
  out[2] = b;
  return;
}
}
#line 1297 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/ccast.c"
int YCbCr2ccast(void *ctx , double out[3] , double in[3] ) 
{ 
  double YCbCr[3] ;
  int k ;
  int rv ;
  double __cil_tmp7 ;
  double __cil_tmp8 ;
  double __cil_tmp9 ;
  double __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 1299
  rv = 0;
#line 1304
  YCbCr[0] = floor(in[0] + 0.5);
#line 1305
  YCbCr[1] = floor(in[1] + 0.5);
#line 1306
  YCbCr[2] = floor(in[2] + 0.5);
#line 1308
  YCbCr2ccast_nq(ctx, out, (double *)YCbCr);
#line 1311
  k = 0;
  }
  {
#line 1311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1311
    if (! (k < 3)) {
#line 1311
      goto while_break;
    }
    {
#line 1312
    out[k] = floor(out[k] + 0.5);
    }
#line 1314
    if (out[k] > 255.) {
#line 1315
      out[k] = 255.;
#line 1316
      rv = 1;
    } else
#line 1317
    if (out[k] < 0.) {
#line 1318
      out[k] = 0.;
#line 1319
      rv = 1;
    }
#line 1311
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1325
  return (rv);
}
}
#line 10 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__cast_message__init(Extensions__Api__CastChannel__CastMessage *message ) 
{ 
  static Extensions__Api__CastChannel__CastMessage init_value ;

  {
#line 13
  init_value.base.descriptor = & extensions__api__cast_channel__cast_message__descriptor;
#line 13
  init_value.base.n_unknown_fields = (unsigned int )0;
#line 13
  init_value.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 13
  init_value.protocol_version = (Extensions__Api__CastChannel__CastMessage__ProtocolVersion )0;
#line 13
  init_value.source_id = (char *)((void *)0);
#line 13
  init_value.destination_id = (char *)((void *)0);
#line 13
  init_value.namespace_ = (char *)((void *)0);
#line 13
  init_value.payload_type = (Extensions__Api__CastChannel__CastMessage__PayloadType )0;
#line 13
  init_value.payload_utf8 = (char *)((void *)0);
#line 13
  init_value.has_payload_binary = 0;
#line 13
  init_value.payload_binary.len = (size_t )0;
#line 13
  init_value.payload_binary.data = (uint8_t *)((void *)0);
#line 14
  *message = init_value;
  return;
}
}
#line 16 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__cast_message__get_packed_size(Extensions__Api__CastChannel__CastMessage *message ) 
{ 
  int tmp ;
  size_t __cil_tmp3 ;

  {
  {
#line 20
  __cil_tmp3 = protobuf_c_message_get_packed_size((ProtobufCMessage *)message);
  }
#line 20
  return (__cil_tmp3);
}
}
#line 22 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__cast_message__pack(Extensions__Api__CastChannel__CastMessage *message ,
                                                         uint8_t *out ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 27
  __cil_tmp4 = protobuf_c_message_pack((ProtobufCMessage *)message, out);
  }
#line 27
  return (__cil_tmp4);
}
}
#line 29 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__cast_message__pack_to_buffer(Extensions__Api__CastChannel__CastMessage *message ,
                                                                   ProtobufCBuffer *buffer ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 34
  __cil_tmp4 = protobuf_c_message_pack_to_buffer((ProtobufCMessage *)message, buffer);
  }
#line 34
  return (__cil_tmp4);
}
}
#line 37 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
Extensions__Api__CastChannel__CastMessage *extensions__api__cast_channel__cast_message__unpack(ProtobufCAllocator *allocator ,
                                                                                               size_t len ,
                                                                                               uint8_t *data ) 
{ 
  ProtobufCMessage *__cil_tmp4 ;

  {
  {
#line 42
  __cil_tmp4 = protobuf_c_message_unpack(& extensions__api__cast_channel__cast_message__descriptor,
                                         allocator, len, data);
  }
#line 42
  return ((Extensions__Api__CastChannel__CastMessage *)__cil_tmp4);
}
}
#line 46 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__cast_message__free_unpacked(Extensions__Api__CastChannel__CastMessage *message ,
                                                                ProtobufCAllocator *allocator ) 
{ 
  int tmp ;

  {
  {
#line 51
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
  }
  return;
}
}
#line 53 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_challenge__init(Extensions__Api__CastChannel__AuthChallenge *message ) 
{ 
  static Extensions__Api__CastChannel__AuthChallenge init_value ;

  {
#line 56
  init_value.base.descriptor = & extensions__api__cast_channel__auth_challenge__descriptor;
#line 56
  init_value.base.n_unknown_fields = (unsigned int )0;
#line 56
  init_value.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 57
  *message = init_value;
  return;
}
}
#line 59 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_challenge__get_packed_size(Extensions__Api__CastChannel__AuthChallenge *message ) 
{ 
  int tmp ;
  size_t __cil_tmp3 ;

  {
  {
#line 63
  __cil_tmp3 = protobuf_c_message_get_packed_size((ProtobufCMessage *)message);
  }
#line 63
  return (__cil_tmp3);
}
}
#line 65 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_challenge__pack(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                           uint8_t *out ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 70
  __cil_tmp4 = protobuf_c_message_pack((ProtobufCMessage *)message, out);
  }
#line 70
  return (__cil_tmp4);
}
}
#line 72 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_challenge__pack_to_buffer(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                                     ProtobufCBuffer *buffer ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 77
  __cil_tmp4 = protobuf_c_message_pack_to_buffer((ProtobufCMessage *)message, buffer);
  }
#line 77
  return (__cil_tmp4);
}
}
#line 80 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
Extensions__Api__CastChannel__AuthChallenge *extensions__api__cast_channel__auth_challenge__unpack(ProtobufCAllocator *allocator ,
                                                                                                   size_t len ,
                                                                                                   uint8_t *data ) 
{ 
  ProtobufCMessage *__cil_tmp4 ;

  {
  {
#line 85
  __cil_tmp4 = protobuf_c_message_unpack(& extensions__api__cast_channel__auth_challenge__descriptor,
                                         allocator, len, data);
  }
#line 85
  return ((Extensions__Api__CastChannel__AuthChallenge *)__cil_tmp4);
}
}
#line 89 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_challenge__free_unpacked(Extensions__Api__CastChannel__AuthChallenge *message ,
                                                                  ProtobufCAllocator *allocator ) 
{ 
  int tmp ;

  {
  {
#line 94
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
  }
  return;
}
}
#line 96 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_response__init(Extensions__Api__CastChannel__AuthResponse *message ) 
{ 
  static Extensions__Api__CastChannel__AuthResponse init_value ;

  {
#line 99
  init_value.base.descriptor = & extensions__api__cast_channel__auth_response__descriptor;
#line 99
  init_value.base.n_unknown_fields = (unsigned int )0;
#line 99
  init_value.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 99
  init_value.signature.len = (size_t )0;
#line 99
  init_value.signature.data = (uint8_t *)((void *)0);
#line 99
  init_value.client_auth_certificate.len = (size_t )0;
#line 99
  init_value.client_auth_certificate.data = (uint8_t *)((void *)0);
#line 100
  *message = init_value;
  return;
}
}
#line 102 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_response__get_packed_size(Extensions__Api__CastChannel__AuthResponse *message ) 
{ 
  int tmp ;
  size_t __cil_tmp3 ;

  {
  {
#line 106
  __cil_tmp3 = protobuf_c_message_get_packed_size((ProtobufCMessage *)message);
  }
#line 106
  return (__cil_tmp3);
}
}
#line 108 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_response__pack(Extensions__Api__CastChannel__AuthResponse *message ,
                                                          uint8_t *out ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 113
  __cil_tmp4 = protobuf_c_message_pack((ProtobufCMessage *)message, out);
  }
#line 113
  return (__cil_tmp4);
}
}
#line 115 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_response__pack_to_buffer(Extensions__Api__CastChannel__AuthResponse *message ,
                                                                    ProtobufCBuffer *buffer ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = protobuf_c_message_pack_to_buffer((ProtobufCMessage *)message, buffer);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 123 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
Extensions__Api__CastChannel__AuthResponse *extensions__api__cast_channel__auth_response__unpack(ProtobufCAllocator *allocator ,
                                                                                                 size_t len ,
                                                                                                 uint8_t *data ) 
{ 
  ProtobufCMessage *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp4 = protobuf_c_message_unpack(& extensions__api__cast_channel__auth_response__descriptor,
                                         allocator, len, data);
  }
#line 128
  return ((Extensions__Api__CastChannel__AuthResponse *)__cil_tmp4);
}
}
#line 132 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_response__free_unpacked(Extensions__Api__CastChannel__AuthResponse *message ,
                                                                 ProtobufCAllocator *allocator ) 
{ 
  int tmp ;

  {
  {
#line 137
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
  }
  return;
}
}
#line 139 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_error__init(Extensions__Api__CastChannel__AuthError *message ) 
{ 
  static Extensions__Api__CastChannel__AuthError init_value ;

  {
#line 142
  init_value.base.descriptor = & extensions__api__cast_channel__auth_error__descriptor;
#line 142
  init_value.base.n_unknown_fields = (unsigned int )0;
#line 142
  init_value.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 142
  init_value.error_type = (Extensions__Api__CastChannel__AuthError__ErrorType )0;
#line 143
  *message = init_value;
  return;
}
}
#line 145 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_error__get_packed_size(Extensions__Api__CastChannel__AuthError *message ) 
{ 
  int tmp ;
  size_t __cil_tmp3 ;

  {
  {
#line 149
  __cil_tmp3 = protobuf_c_message_get_packed_size((ProtobufCMessage *)message);
  }
#line 149
  return (__cil_tmp3);
}
}
#line 151 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_error__pack(Extensions__Api__CastChannel__AuthError *message ,
                                                       uint8_t *out ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 156
  __cil_tmp4 = protobuf_c_message_pack((ProtobufCMessage *)message, out);
  }
#line 156
  return (__cil_tmp4);
}
}
#line 158 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__auth_error__pack_to_buffer(Extensions__Api__CastChannel__AuthError *message ,
                                                                 ProtobufCBuffer *buffer ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 163
  __cil_tmp4 = protobuf_c_message_pack_to_buffer((ProtobufCMessage *)message, buffer);
  }
#line 163
  return (__cil_tmp4);
}
}
#line 166 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
Extensions__Api__CastChannel__AuthError *extensions__api__cast_channel__auth_error__unpack(ProtobufCAllocator *allocator ,
                                                                                           size_t len ,
                                                                                           uint8_t *data ) 
{ 
  ProtobufCMessage *__cil_tmp4 ;

  {
  {
#line 171
  __cil_tmp4 = protobuf_c_message_unpack(& extensions__api__cast_channel__auth_error__descriptor,
                                         allocator, len, data);
  }
#line 171
  return ((Extensions__Api__CastChannel__AuthError *)__cil_tmp4);
}
}
#line 175 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__auth_error__free_unpacked(Extensions__Api__CastChannel__AuthError *message ,
                                                              ProtobufCAllocator *allocator ) 
{ 
  int tmp ;

  {
  {
#line 180
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
  }
  return;
}
}
#line 182 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__device_auth_message__init(Extensions__Api__CastChannel__DeviceAuthMessage *message ) 
{ 
  static Extensions__Api__CastChannel__DeviceAuthMessage init_value ;

  {
#line 185
  init_value.base.descriptor = & extensions__api__cast_channel__device_auth_message__descriptor;
#line 185
  init_value.base.n_unknown_fields = (unsigned int )0;
#line 185
  init_value.base.unknown_fields = (ProtobufCMessageUnknownField *)((void *)0);
#line 185
  init_value.challenge = (Extensions__Api__CastChannel__AuthChallenge *)((void *)0);
#line 185
  init_value.response = (Extensions__Api__CastChannel__AuthResponse *)((void *)0);
#line 185
  init_value.error = (Extensions__Api__CastChannel__AuthError *)((void *)0);
#line 186
  *message = init_value;
  return;
}
}
#line 188 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__device_auth_message__get_packed_size(Extensions__Api__CastChannel__DeviceAuthMessage *message ) 
{ 
  int tmp ;
  size_t __cil_tmp3 ;

  {
  {
#line 192
  __cil_tmp3 = protobuf_c_message_get_packed_size((ProtobufCMessage *)message);
  }
#line 192
  return (__cil_tmp3);
}
}
#line 194 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__device_auth_message__pack(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                uint8_t *out ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 199
  __cil_tmp4 = protobuf_c_message_pack((ProtobufCMessage *)message, out);
  }
#line 199
  return (__cil_tmp4);
}
}
#line 201 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
size_t extensions__api__cast_channel__device_auth_message__pack_to_buffer(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                          ProtobufCBuffer *buffer ) 
{ 
  int tmp ;
  size_t __cil_tmp4 ;

  {
  {
#line 206
  __cil_tmp4 = protobuf_c_message_pack_to_buffer((ProtobufCMessage *)message, buffer);
  }
#line 206
  return (__cil_tmp4);
}
}
#line 209 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
Extensions__Api__CastChannel__DeviceAuthMessage *extensions__api__cast_channel__device_auth_message__unpack(ProtobufCAllocator *allocator ,
                                                                                                            size_t len ,
                                                                                                            uint8_t *data ) 
{ 
  ProtobufCMessage *__cil_tmp4 ;

  {
  {
#line 214
  __cil_tmp4 = protobuf_c_message_unpack(& extensions__api__cast_channel__device_auth_message__descriptor,
                                         allocator, len, data);
  }
#line 214
  return ((Extensions__Api__CastChannel__DeviceAuthMessage *)__cil_tmp4);
}
}
#line 218 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
void extensions__api__cast_channel__device_auth_message__free_unpacked(Extensions__Api__CastChannel__DeviceAuthMessage *message ,
                                                                       ProtobufCAllocator *allocator ) 
{ 
  int tmp ;

  {
  {
#line 223
  protobuf_c_message_free_unpacked((ProtobufCMessage *)message, allocator);
  }
  return;
}
}
#line 225 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValue extensions__api__cast_channel__cast_message__protocol_version__enum_values_by_number[1]  = {      {"CASTV2_1_0",
      "EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PROTOCOL_VERSION__CASTV2_1_0",
      0}};
#line 229 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__cast_message__protocol_version__value_ranges[2]  = {      {0,
      (unsigned int )0}, 
        {0, (unsigned int )1}};
#line 232 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValueIndex extensions__api__cast_channel__cast_message__protocol_version__enum_values_by_name[1]  = {      {"CASTV2_1_0",
      (unsigned int )0}};
#line 236 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumDescriptor extensions__api__cast_channel__cast_message__protocol_version__descriptor  = 
#line 236
     {(uint32_t )289609135, "extensions.api.cast_channel.CastMessage.ProtocolVersion",
    "ProtocolVersion", "Extensions__Api__CastChannel__CastMessage__ProtocolVersion",
    "extensions.api.cast_channel", (unsigned int )1, (ProtobufCEnumValue *)extensions__api__cast_channel__cast_message__protocol_version__enum_values_by_number,
    (unsigned int )1, (ProtobufCEnumValueIndex *)extensions__api__cast_channel__cast_message__protocol_version__enum_values_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__cast_message__protocol_version__value_ranges,
    (void *)0, (void *)0, (void *)0, (void *)0};
#line 251 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValue extensions__api__cast_channel__cast_message__payload_type__enum_values_by_number[2]  = {      {"STRING",
      "EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PAYLOAD_TYPE__STRING", 0}, 
        {"BINARY", "EXTENSIONS__API__CAST_CHANNEL__CAST_MESSAGE__PAYLOAD_TYPE__BINARY",
      1}};
#line 256 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__cast_message__payload_type__value_ranges[2]  = {      {0,
      (unsigned int )0}, 
        {0, (unsigned int )2}};
#line 259 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValueIndex extensions__api__cast_channel__cast_message__payload_type__enum_values_by_name[2]  = {      {"BINARY",
      (unsigned int )1}, 
        {"STRING", (unsigned int )0}};
#line 264 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumDescriptor extensions__api__cast_channel__cast_message__payload_type__descriptor  = 
#line 264
     {(uint32_t )289609135, "extensions.api.cast_channel.CastMessage.PayloadType", "PayloadType",
    "Extensions__Api__CastChannel__CastMessage__PayloadType", "extensions.api.cast_channel",
    (unsigned int )2, (ProtobufCEnumValue *)extensions__api__cast_channel__cast_message__payload_type__enum_values_by_number,
    (unsigned int )2, (ProtobufCEnumValueIndex *)extensions__api__cast_channel__cast_message__payload_type__enum_values_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__cast_message__payload_type__value_ranges,
    (void *)0, (void *)0, (void *)0, (void *)0};
#line 279 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCFieldDescriptor extensions__api__cast_channel__cast_message__field_descriptors[7]  = {      {"protocol_version\251",
      (uint32_t )1, (ProtobufCLabel )0, (ProtobufCType )13, (unsigned int )0, (unsigned int )0,
      & extensions__api__cast_channel__cast_message__protocol_version__descriptor,
      (void *)0, (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}, 
        {"source_id", (uint32_t )2, (ProtobufCLabel )0, (ProtobufCType )14, (unsigned int )0,
      (unsigned int )0, (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0,
      (void *)0}, 
        {"destination_id", (uint32_t )3, (ProtobufCLabel )0, (ProtobufCType )14, (unsigned int )0,
      (unsigned int )0, (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0,
      (void *)0}, 
        {"namespace", (uint32_t )4, (ProtobufCLabel )0, (ProtobufCType )14, (unsigned int )0,
      (unsigned int )0, (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0,
      (void *)0}, 
        {"payload_type", (uint32_t )5, (ProtobufCLabel )0, (ProtobufCType )13, (unsigned int )0,
      (unsigned int )0, & extensions__api__cast_channel__cast_message__payload_type__descriptor,
      (void *)0, (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}, 
        {"payload_utf8", (uint32_t )6, (ProtobufCLabel )1, (ProtobufCType )14, (unsigned int )0,
      (unsigned int )0, (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0,
      (void *)0}, 
        {"payload_binary", (uint32_t )7, (ProtobufCLabel )1, (ProtobufCType )15, (unsigned int )0,
      (unsigned int )0, (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0,
      (void *)0}};
#line 366 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static unsigned int const   extensions__api__cast_channel__cast_message__field_indices_by_name[7]  = {      (unsigned int )2,      (unsigned int )3,      (unsigned int )6,      (unsigned int )4, 
        (unsigned int )5,      (unsigned int )0,      (unsigned int )1};
#line 375 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__cast_message__number_ranges[2]  = {      {1,
      (unsigned int )0}, 
        {0, (unsigned int )7}};
#line 380 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCMessageDescriptor extensions__api__cast_channel__cast_message__descriptor  = 
#line 380
     {(uint32_t )682290937, "extensions.api.cast_channel.CastMessage", "CastMessage",
    "Extensions__Api__CastChannel__CastMessage", "extensions.api.cast_channel", sizeof(Extensions__Api__CastChannel__CastMessage ),
    (unsigned int )7, (ProtobufCFieldDescriptor *)extensions__api__cast_channel__cast_message__field_descriptors,
    (unsigned int const   *)extensions__api__cast_channel__cast_message__field_indices_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__cast_message__number_ranges,
    (ProtobufCMessageInit )(& extensions__api__cast_channel__cast_message__init),
    (void *)0, (void *)0, (void *)0};
#line 398 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_challenge__descriptor  = 
#line 398
     {(uint32_t )682290937, "extensions.api.cast_channel.AuthChallenge", "AuthChallenge",
    "Extensions__Api__CastChannel__AuthChallenge", "extensions.api.cast_channel",
    sizeof(Extensions__Api__CastChannel__AuthChallenge ), (unsigned int )0, (ProtobufCFieldDescriptor *)((void *)0),
    (unsigned int const   *)((void *)0), (unsigned int )0, (ProtobufCIntRange *)((void *)0),
    (ProtobufCMessageInit )(& extensions__api__cast_channel__auth_challenge__init),
    (void *)0, (void *)0, (void *)0};
#line 413 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCFieldDescriptor extensions__api__cast_channel__auth_response__field_descriptors[2]  = {      {"signature",
      (uint32_t )1, (ProtobufCLabel )0, (ProtobufCType )15, (unsigned int )0, (unsigned int )0,
      (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}, 
        {"client_auth_certificate",
      (uint32_t )2, (ProtobufCLabel )0, (ProtobufCType )15, (unsigned int )0, (unsigned int )0,
      (void *)0, (void *)0, (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}};
#line 440 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static unsigned int const   extensions__api__cast_channel__auth_response__field_indices_by_name[2]  = {      (unsigned int )1,      (unsigned int )0};
#line 444 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__auth_response__number_ranges[2]  = {      {1,
      (unsigned int )0}, 
        {0, (unsigned int )2}};
#line 449 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_response__descriptor  = 
#line 449
     {(uint32_t )682290937, "extensions.api.cast_channel.AuthResponse\323\001 ", "AuthResponse",
    "Extensions__Api__CastChannel__AuthResponse", "extensions.api.cast_channel", sizeof(Extensions__Api__CastChannel__AuthResponse ),
    (unsigned int )2, (ProtobufCFieldDescriptor *)extensions__api__cast_channel__auth_response__field_descriptors,
    (unsigned int const   *)extensions__api__cast_channel__auth_response__field_indices_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__auth_response__number_ranges,
    (ProtobufCMessageInit )(& extensions__api__cast_channel__auth_response__init),
    (void *)0, (void *)0, (void *)0};
#line 464 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValue extensions__api__cast_channel__auth_error__error_type__enum_values_by_number[2]  = {      {"INTERNAL_ERROR",
      "EXTENSIONS__API__CAST_CHANNEL__AUTH_ERROR__ERROR_TYPE__INTERNAL_ERROR", 0}, 
        {"NO_TLS",
      "EXTENSIONS__API__CAST_CHANNEL__AUTH_ERROR__ERROR_TYPE__NO_TLS", 1}};
#line 469 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__auth_error__error_type__value_ranges[2]  = {      {0,
      (unsigned int )0}, 
        {0, (unsigned int )2}};
#line 472 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumValueIndex extensions__api__cast_channel__auth_error__error_type__enum_values_by_name[2]  = {      {"INTERNAL_ERROR",
      (unsigned int )0}, 
        {"NO_TLS", (unsigned int )1}};
#line 477 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCEnumDescriptor extensions__api__cast_channel__auth_error__error_type__descriptor  = 
#line 477
     {(uint32_t )289609135, "extensions.api.cast_channel.AuthError.ErrorType", "ErrorType",
    "Extensions__Api__CastChannel__AuthError__ErrorType", "extensions.api.cast_channel",
    (unsigned int )2, (ProtobufCEnumValue *)extensions__api__cast_channel__auth_error__error_type__enum_values_by_number,
    (unsigned int )2, (ProtobufCEnumValueIndex *)extensions__api__cast_channel__auth_error__error_type__enum_values_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__auth_error__error_type__value_ranges,
    (void *)0, (void *)0, (void *)0, (void *)0};
#line 492 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCFieldDescriptor extensions__api__cast_channel__auth_error__field_descriptors[1]  = {      {"error_type",
      (uint32_t )1, (ProtobufCLabel )0, (ProtobufCType )13, (unsigned int )0, (unsigned int )0,
      & extensions__api__cast_channel__auth_error__error_type__descriptor, (void *)0,
      (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}};
#line 507 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static unsigned int const   extensions__api__cast_channel__auth_error__field_indices_by_name[1]  = {      (unsigned int )0};
#line 510 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__auth_error__number_ranges[2]  = {      {1,
      (unsigned int )0}, 
        {0, (unsigned int )1}};
#line 515 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCMessageDescriptor extensions__api__cast_channel__auth_error__descriptor  = 
#line 515
     {(uint32_t )682290937, "extensions.api.cast_channel.AuthError\001", "AuthError\025",
    "Extensions__Api__CastChannel__AuthError", "extensions.api.cast_channel", sizeof(Extensions__Api__CastChannel__AuthError ),
    (unsigned int )1, (ProtobufCFieldDescriptor *)extensions__api__cast_channel__auth_error__field_descriptors,
    (unsigned int const   *)extensions__api__cast_channel__auth_error__field_indices_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__auth_error__number_ranges,
    (ProtobufCMessageInit )(& extensions__api__cast_channel__auth_error__init), (void *)0,
    (void *)0, (void *)0};
#line 530 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCFieldDescriptor extensions__api__cast_channel__device_auth_message__field_descriptors[3]  = {      {"challenge",
      (uint32_t )1, (ProtobufCLabel )1, (ProtobufCType )16, (unsigned int )0, (unsigned int )0,
      & extensions__api__cast_channel__auth_challenge__descriptor, (void *)0, (uint32_t )0,
      (unsigned int )0, (void *)0, (void *)0}, 
        {"response\251", (uint32_t )2, (ProtobufCLabel )1, (ProtobufCType )16, (unsigned int )0,
      (unsigned int )0, & extensions__api__cast_channel__auth_response__descriptor,
      (void *)0, (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}, 
        {"error", (uint32_t )3, (ProtobufCLabel )1, (ProtobufCType )16, (unsigned int )0,
      (unsigned int )0, & extensions__api__cast_channel__auth_error__descriptor, (void *)0,
      (uint32_t )0, (unsigned int )0, (void *)0, (void *)0}};
#line 569 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static unsigned int const   extensions__api__cast_channel__device_auth_message__field_indices_by_name[3]  = {      (unsigned int )0,      (unsigned int )2,      (unsigned int )1};
#line 574 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
static ProtobufCIntRange extensions__api__cast_channel__device_auth_message__number_ranges[2]  = {      {1,
      (unsigned int )0}, 
        {0, (unsigned int )3}};
#line 579 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/chan/cast_channel.pb-c.c"
ProtobufCMessageDescriptor extensions__api__cast_channel__device_auth_message__descriptor  = 
#line 579
     {(uint32_t )682290937, "extensions.api.cast_channel.DeviceAuthMessage", "DeviceAuthMessage",
    "Extensions__Api__CastChannel__DeviceAuthMessage", "extensions.api.cast_channel",
    sizeof(Extensions__Api__CastChannel__DeviceAuthMessage ), (unsigned int )3, (ProtobufCFieldDescriptor *)extensions__api__cast_channel__device_auth_message__field_descriptors,
    (unsigned int const   *)extensions__api__cast_channel__device_auth_message__field_indices_by_name,
    (unsigned int )1, (ProtobufCIntRange *)extensions__api__cast_channel__device_auth_message__number_ranges,
    (ProtobufCMessageInit )(& extensions__api__cast_channel__device_auth_message__init),
    (void *)0, (void *)0, (void *)0};
#line 7 "h/copyright.h"
static char __copyright_____6[35]  =    "Copyright 1995-2013 Graeme W. Gill";
#line 119 "numlib/svd.h"
static void svdinverse___5(double **u , double *w , double **v , double **ia , int m ,
                           int n ) ;
#line 100 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
int vv  =    0;
#line 105 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static void upsample___0(double ret[3] , double iipat[4][4][3] ) 
{ 
  double ipat[4][4][3] ;
  double tpat[6][4][3] ;
  double opat[6][6][3] ;
  int x ;
  int y ;
  int i ;
  int j ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int ph ;
  int ii ;
  int k ;
  double __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int ph___0 ;
  int jj ;
  int k___0 ;
  double __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
#line 114
  x = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (x < 4)) {
#line 114
      goto while_break;
    }
#line 115
    y = 0;
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (y < 4)) {
#line 115
        goto while_break___0;
      }
      {
#line 116
      ccast2YCbCr((void *)0, (double *)ipat[x][y], (double *)iipat[x][y]);
      }
#line 115
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  y = 0;
  {
#line 126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 126
    if (! (y < 4)) {
#line 126
      goto while_break___1;
    }
#line 129
    i = 0;
    {
#line 129
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 129
      if (! (i < 6)) {
#line 129
        goto while_break___2;
      }
#line 130
      tpat[i][y][0] = 0.;
#line 131
      tpat[i][y][1] = 0.;
#line 132
      tpat[i][y][2] = 0.;
#line 129
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 136
    x = 0;
    {
#line 136
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 136
      if (! (x < 4)) {
#line 136
        goto while_break___3;
      }
      {
#line 139
      ph = x & 1;
#line 140
      __cil_tmp16 = floor((double )x * 1.5 + 0.5);
#line 140
      ii = (int )__cil_tmp16;
#line 143
      k = fneg[ph];
      }
      {
#line 143
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 143
        if (! (k <= fpos[ph])) {
#line 143
          goto while_break___4;
        }
#line 144
        i = ii + k;
        {
#line 145
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 145
          if (! (i < 0)) {
#line 145
            goto while_break___5;
          }
#line 146
          i += 6;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 147
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 147
          if (! (i >= 6)) {
#line 147
            goto while_break___6;
          }
#line 148
          i -= 6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 149
        tpat[i][y][0] += *(filt[0][ph] + k) * ipat[x][y][0];
#line 150
        tpat[i][y][1] += *(filt[0][ph] + k) * ipat[x][y][1];
#line 151
        tpat[i][y][2] += *(filt[0][ph] + k) * ipat[x][y][2];
#line 143
        k ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 136
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 126
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 158
    if (! (i < 6)) {
#line 158
      goto while_break___7;
    }
#line 161
    j = 0;
    {
#line 161
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 161
      if (! (j < 6)) {
#line 161
        goto while_break___8;
      }
#line 162
      opat[i][j][0] = 0.;
#line 163
      opat[i][j][1] = 0.;
#line 164
      opat[i][j][2] = 0.;
#line 161
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 168
    y = 0;
    {
#line 168
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 168
      if (! (y < 4)) {
#line 168
        goto while_break___9;
      }
      {
#line 171
      ph___0 = y & 1;
#line 172
      __cil_tmp24 = floor((double )y * 1.5 + 0.5);
#line 172
      jj = (int )__cil_tmp24;
#line 175
      k___0 = fneg[ph___0];
      }
      {
#line 175
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 175
        if (! (k___0 <= fpos[ph___0])) {
#line 175
          goto while_break___10;
        }
#line 176
        j = jj + k___0;
        {
#line 177
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 177
          if (! (j < 0)) {
#line 177
            goto while_break___11;
          }
#line 178
          j += 6;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
#line 179
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 179
          if (! (j >= 6)) {
#line 179
            goto while_break___12;
          }
#line 180
          j -= 6;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 181
        opat[i][j][0] += *(filt[1][ph___0] + k___0) * tpat[i][y][0];
#line 182
        opat[i][j][1] += *(filt[1][ph___0] + k___0) * tpat[i][y][1];
#line 183
        opat[i][j][2] += *(filt[1][ph___0] + k___0) * tpat[i][y][2];
#line 175
        k___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 168
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 158
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 190
    if (! (i < 6)) {
#line 190
      goto while_break___13;
    }
#line 191
    j = 0;
    {
#line 191
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 191
      if (! (j < 6)) {
#line 191
        goto while_break___14;
      }
      {
#line 192
      YCbCr2ccast((void *)0, (double *)opat[i][j], (double *)opat[i][j]);
      }
#line 191
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 197
  if (ret != (void *)0) {
#line 198
    ret[2] = 0.;
#line 198
    ret[1] = ret[2];
#line 198
    ret[0] = ret[1];
#line 199
    j = 0;
    {
#line 199
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 199
      if (! (j < 6)) {
#line 199
        goto while_break___15;
      }
#line 200
      i = 0;
      {
#line 200
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 200
        if (! (i < 6)) {
#line 200
          goto while_break___16;
        }
#line 201
        ret[0] += opat[i][j][0];
#line 202
        ret[1] += opat[i][j][1];
#line 203
        ret[2] += opat[i][j][2];
#line 200
        i ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 199
      j ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 206
    ret[0] /= (double )36;
#line 207
    ret[1] /= (double )36;
#line 208
    ret[2] /= (double )36;
  }
#line 212
  if (vv) {
    {
#line 213
    printf("Result\n");
#line 214
    j = 0;
    }
    {
#line 214
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 214
      if (! (j < 6)) {
#line 214
        goto while_break___17;
      }
#line 215
      i = 0;
      {
#line 215
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 215
        if (! (i < 6)) {
#line 215
          goto while_break___18;
        }
#line 216
        if (i > 0) {
          {
#line 217
          printf(", ");
          }
        }
        {
#line 218
        printf("% 5.1f % 5.1f % 5.1f", opat[i][j][0], opat[i][j][1], opat[i][j][2]);
        }
#line 215
        i ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 220
      printf("\n");
      }
#line 214
      j ++;
    }
    while_break___17: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 231 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static void quant_rgb___0(int n , double out[3] , double rgb[3] ) 
{ 
  double ycc[3] ;
  double base[3] ;
  double tmp[3] ;
  double chval[3] ;
  double dist ;
  double bdist ;
  double brgb[3] ;
  double borgb[3] ;
  int ix ;
  int k ;
  int __cil_tmp14 ;
  double dist___54 ;
  int __cil_tmp16 ;
  double tt ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 234
  bdist = 1000000.;
#line 243
  k = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (k < 3)) {
#line 243
      goto while_break;
    }
#line 244
    base[k] = rgb[k];
#line 243
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  ix = 0;
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (! (ix < 8)) {
#line 246
      goto while_break___0;
    }
#line 250
    k = 0;
    {
#line 250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 250
      if (! (k < 3)) {
#line 250
        goto while_break___1;
      }
#line 251
      tmp[k] = base[k];
#line 252
      if (ix & (1 << k)) {
#line 253
        if (n & (1 << k)) {
#line 254
          tmp[k] += 1.;
        } else {
#line 256
          tmp[k] -= 1.;
        }
#line 257
        if (tmp[k] < 0.) {
#line 258
          goto while_break___1;
        } else
#line 257
        if (tmp[k] > 255.) {
#line 258
          goto while_break___1;
        }
      }
#line 250
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 261
    if (k < 3) {
#line 262
      goto while_continue___0;
    }
    {
#line 265
    ccast2YCbCr((void *)0, (double *)ycc, (double *)tmp);
#line 266
    YCbCr2ccast((void *)0, (double *)chval, (double *)ycc);
#line 275
    dist___54 = 0.;
#line 276
    k = 0;
    }
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      if (! (k < 3)) {
#line 276
        goto while_break___2;
      }
#line 278
      if (n & (1 << k)) {
#line 279
        tt = chval[k] - base[k];
      } else {
#line 281
        tt = base[k] - chval[k];
      }
#line 283
      if (tt >= 0.) {
#line 284
        dist___54 += 0.100000000001 * tt;
      } else {
#line 286
        dist___54 += 2. * - tt;
      }
#line 276
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 291
    if (dist___54 < bdist) {
#line 292
      k = 0;
      {
#line 292
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 292
        if (! (k < 3)) {
#line 292
          goto while_break___3;
        }
#line 293
        rgb[k] = tmp[k];
#line 294
        out[k] = chval[k];
#line 292
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 296
      bdist = dist___54;
    }
#line 246
    ix ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 321 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
static double optfunc___0(void *fdata , double tp[] ) 
{ 
  optcntx *cntx ;
  int i ;
  int k ;
  double iw ;
  double tmp[3] ;
  double err ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double tt ;
  int __cil_tmp14 ;

  {
#line 322
  cntx = (optcntx *)fdata;
#line 325
  err = 0.;
#line 328
  k = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (k < 3)) {
#line 328
      goto while_break;
    }
#line 329
    tmp[k] = 0.;
#line 328
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  iw = 1.;
#line 332
  i = 0;
  {
#line 332
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 332
    if (! (i < cntx->di)) {
#line 332
      goto while_break___0;
    }
#line 333
    if (tp[i] < 0.) {
#line 334
      err += (1000. * tp[i]) * tp[i];
    } else
#line 335
    if (tp[i] > 1.) {
#line 336
      err += (1000. * (tp[i] - 1.)) * (tp[i] - 1.);
    }
#line 338
    k = 0;
    {
#line 338
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 338
      if (! (k < 3)) {
#line 338
        goto while_break___1;
      }
#line 339
      tmp[k] += tp[i] * (*(cntx->ressur))[i][k];
#line 338
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 340
    iw -= tp[i];
#line 332
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  k = 0;
  {
#line 342
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 342
    if (! (k < 3)) {
#line 342
      goto while_break___2;
    }
#line 343
    tmp[k] += iw * (*(cntx->ressur))[i][k];
#line 342
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 346
  k = 0;
  {
#line 346
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 346
    if (! (k < 3)) {
#line 346
      goto while_break___3;
    }
#line 347
    tt = tmp[k] - *(cntx->val + k);
#line 348
    err += tt * tt;
#line 346
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 351
  return (err);
}
}
#line 796 "/root/patron-artifact/pkg/argyll_tmp/argyll-2.2.0+repack/ccast/dpat.c"
int main(int argc , char *argv[] ) 
{ 
  double val[3] ;
  double out[3] ;
  double err ;
  double ipat[4][4][3] ;
  double aerr ;
  double acount ;
  double xerr ;
  int x ;
  int y ;
  int i ;
  int j ;
  int k ;
  int nn ;
  time_t __cil_tmp16 ;
  double __cil_tmp17 ;
  int __cil_tmp18 ;
  double __cil_tmp19 ;
  double __cil_tmp20 ;
  int __cil_tmp21 ;

  {
  {
#line 806
  printf("Hi there\n");
#line 808
  __cil_tmp16 = time((time_t *)((void *)0));
#line 808
  rand32((unsigned int )__cil_tmp16);
#line 912
  aerr = 0.;
#line 913
  acount = 0.;
#line 914
  xerr = 0.;
#line 915
  nn = 0;
  }
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (! (nn < 200000)) {
#line 915
      goto while_break;
    }
#line 917
    k = 0;
    {
#line 917
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 917
      if (! (k < 3)) {
#line 917
        goto while_break___0;
      }
      {
#line 918
      val[k] = d_rand(- 5., 255. + 5.);
      }
#line 919
      if (val[k] < 0.) {
#line 920
        val[k] = 0.;
      } else
#line 921
      if (val[k] > 255.) {
#line 922
        val[k] = 255.;
      }
#line 917
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 925
    err = get_ccast_dith((double (*)[4][3])ipat, (double *)val);
    }
#line 927
    if (err >= 1.5) {
      {
      {
#line 932
      printf("Target RGB %f %f %f, err %f\n", val[0], val[1], val[2], err);
      }
      }
    } else
#line 927
    if (err >= 1.) {
#line 927
      if (val[0] != 0.) {
#line 927
        if (val[0] != 255.) {
#line 927
          if (val[1] != 0.) {
#line 927
            if (val[1] != 255.) {
#line 927
              if (val[2] != 0.) {
#line 927
                if (val[2] != 255.) {
                  {
                  {
#line 932
                  printf("Target RGB %f %f %f, err %f\n", val[0], val[1], val[2],
                         err);
                  }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 938
    aerr += err;
#line 939
    acount ++;
#line 940
    if (err > xerr) {
#line 941
      xerr = err;
    }
#line 915
    nn ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 944
  aerr /= acount;
#line 945
  printf("After %d trials, aerr = %f, maxerr = %f\n\230\001", nn, aerr, xerr);
  }
#line 949
  return (0);
}
}
