/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 34 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef signed char __int8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 45 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int8_t __int_least8_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint8_t __uint_least8_t;
#line 54 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int16_t __int_least16_t;
#line 55 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint16_t __uint_least16_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int32_t __int_least32_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint32_t __uint_least32_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __int64_t __int_least64_t;
#line 59 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __uint64_t __uint_least64_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __quad_t;
#line 64 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_quad_t;
#line 72 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 73 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 154 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct_0 {
   int __val[2] ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct_0 __fsid_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 157 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 161 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds64_t;
#line 165 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 169 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef void *__timer_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 185 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 188 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 192 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 199 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 203 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 204 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 207 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 210 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 215 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_2 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_1 {
   int __count ;
   union __anonunion_2 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_1 __mbstate_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
struct _G_fpos_t {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h"
typedef struct _G_fpos_t __fpos_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
struct _G_fpos64_t {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 14 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h"
typedef struct _G_fpos64_t __fpos64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_marker ;
#line 37
struct _IO_codecvt ;
#line 38
struct _IO_wide_data ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
typedef void _IO_lock_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_read_function_t(void * , char * , size_t  );
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef __ssize_t cookie_write_function_t(void * , char const   * , size_t  );
#line 45 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_seek_function_t(void * , __off64_t * , int  );
#line 48 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef int cookie_close_function_t(void * );
#line 55 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h"
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
#line 52 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 70 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 77 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 84 "/usr/include/stdio.h"
typedef __fpos_t fpos_t;
#line 89 "/usr/include/stdio.h"
typedef __fpos64_t fpos64_t;
#line 850
struct obstack ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/wait.h"
typedef __pid_t pid_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct_3 {
   unsigned long __val[16] ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct_3 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 46 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_6 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_7 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 71 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 79 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_12 {
   void *_lower ;
   void *_upper ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_11 {
   struct __anonstruct_12 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 89 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_10 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion_11 _bounds ;
};
#line 108 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_13 {
   long si_band ;
   int si_fd ;
};
#line 116 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_14 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 51 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion_5 {
   int _pad[28] ;
   struct __anonstruct_6 _kill ;
   struct __anonstruct_7 _timer ;
   struct __anonstruct_8 _rt ;
   struct __anonstruct_9 _sigchld ;
   struct __anonstruct_10 _sigfault ;
   struct __anonstruct_13 _sigpoll ;
   struct __anonstruct_14 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_4 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion_5 _sifields ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_4 siginfo_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__15 {
    SI_ASYNCNL = -60,
    SI_DETHREAD = -7,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 71
enum __anonenum__16 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
    ILL_BADIADDR = 9
} ;
#line 94
enum __anonenum__17 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
    FPE_FLTUNK = 14,
    FPE_CONDTRAP = 15
} ;
#line 119
enum __anonenum__18 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2,
    SEGV_BNDERR = 3,
    SEGV_PKUERR = 4,
    SEGV_ACCADI = 5,
    SEGV_ADIDERR = 6,
    SEGV_ADIPERR = 7,
    SEGV_MTEAERR = 8,
    SEGV_MTESERR = 9
} ;
#line 142
enum __anonenum__19 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5
} ;
#line 159
enum __anonenum__20 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2,
    TRAP_BRANCH = 3,
    TRAP_HWBKPT = 4,
    TRAP_UNK = 5
} ;
#line 176
enum __anonenum__21 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 193
enum __anonenum__22 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h"
typedef __sigval_t sigval_t;
#line 17 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union pthread_attr_t ;
#line 17 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef union pthread_attr_t pthread_attr_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct __anonstruct_24 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
union __anonunion_23 {
   int _pad[12] ;
   __pid_t _tid ;
   struct __anonstruct_24 _sigev_thread ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_23 _sigev_un ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h"
typedef struct sigevent sigevent_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__25 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 188 "/usr/include/signal.h"
typedef __sighandler_t sighandler_t;
#line 193 "/usr/include/signal.h"
typedef __sighandler_t sig_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion_26 {
   __sighandler_t sa_handler ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion_26 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpx_sw_bytes {
   __uint32_t magic1 ;
   __uint32_t extended_size ;
   __uint64_t xstate_bv ;
   __uint32_t xstate_size ;
   __uint32_t __glibc_reserved1[7] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 53 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 167 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
union __anonunion_27 {
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct sigcontext {
   __uint64_t r8 ;
   __uint64_t r9 ;
   __uint64_t r10 ;
   __uint64_t r11 ;
   __uint64_t r12 ;
   __uint64_t r13 ;
   __uint64_t r14 ;
   __uint64_t r15 ;
   __uint64_t rdi ;
   __uint64_t rsi ;
   __uint64_t rbp ;
   __uint64_t rbx ;
   __uint64_t rdx ;
   __uint64_t rax ;
   __uint64_t rcx ;
   __uint64_t rsp ;
   __uint64_t rip ;
   __uint64_t eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   __uint64_t err ;
   __uint64_t trapno ;
   __uint64_t oldmask ;
   __uint64_t cr2 ;
   union __anonunion_27  ;
   struct _fpstate *fpstate ;
   __uint64_t __fpstate_word ;
   __uint64_t __reserved1[8] ;
};
#line 177 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xsave_hdr {
   __uint64_t xstate_bv ;
   __uint64_t __glibc_reserved1[2] ;
   __uint64_t __glibc_reserved2[5] ;
};
#line 184 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _ymmh_state {
   __uint32_t ymmh_space[64] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h"
struct _xstate {
   struct _fpstate fpstate ;
   struct _xsave_hdr xstate_hdr ;
   struct _ymmh_state ymmh ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
struct __anonstruct_28 {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h"
typedef struct __anonstruct_28 stack_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef long long greg_t;
#line 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 50
enum __anonenum__29 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 101 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short __glibc_reserved1[3] ;
};
#line 108 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 113 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t __glibc_reserved1[24] ;
};
#line 130 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 133 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct __anonstruct_30 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long long __reserved1[8] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct __anonstruct_30 mcontext_t;
#line 142 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
struct ucontext_t {
   unsigned long uc_flags ;
   struct ucontext_t *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
   unsigned long long __ssp[4] ;
};
#line 151 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
typedef struct ucontext_t ucontext_t;
#line 232 "/usr/include/unistd.h"
typedef __gid_t gid_t;
#line 255 "/usr/include/unistd.h"
typedef __useconds_t useconds_t;
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__31 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 71
enum __anonenum__32 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236,
    _SC_V7_ILP32_OFF32 = 237,
    _SC_V7_ILP32_OFFBIG = 238,
    _SC_V7_LP64_OFF64 = 239,
    _SC_V7_LPBIG_OFFBIG = 240,
    _SC_SS_REPL_MAX = 241,
    _SC_TRACE_EVENT_NAME_MAX = 242,
    _SC_TRACE_NAME_MAX = 243,
    _SC_TRACE_SYS_MAX = 244,
    _SC_TRACE_USER_EVENT_MAX = 245,
    _SC_XOPEN_STREAMS = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT = 248,
    _SC_MINSIGSTKSZ = 249,
    _SC_SIGSTKSZ = 250
} ;
#line 539
enum __anonenum__33 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS = 5,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
    _CS_V6_ENV = 1148,
    _CS_V7_ENV = 1149
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__34 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
struct __anonstruct_36 {
   unsigned int __low ;
   unsigned int __high ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
union __anonunion_35 {
   unsigned long long __value64 ;
   struct __anonstruct_36 __value32 ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h"
typedef union __anonunion_35 __atomic_wide_counter;
#line 51 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 57 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 94 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_cond_s {
   __atomic_wide_counter __wseq ;
   __atomic_wide_counter __g1_start ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
#line 105 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned int __tss_t;
#line 106 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef unsigned long __thrd_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __anonstruct_37 {
   int __data ;
};
#line 111 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __anonstruct_37 __once_flag;
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_38 {
   char __size[4] ;
   int __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_38 pthread_mutexattr_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_39 {
   char __size[4] ;
   int __align ;
};
#line 45 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_39 pthread_condattr_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 56 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_40 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_40 pthread_mutex_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_41 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
#line 80 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_41 pthread_cond_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_42 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 91 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_42 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_43 {
   char __size[8] ;
   long __align ;
};
#line 97 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_43 pthread_rwlockattr_t;
#line 103 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_spinlock_t;
#line 108 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_44 {
   char __size[32] ;
   long __align ;
};
#line 112 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_44 pthread_barrier_t;
#line 114 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_45 {
   char __size[4] ;
   int __align ;
};
#line 118 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_45 pthread_barrierattr_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/wait.h"
enum __anonenum__46 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/wait.h"
typedef enum __anonenum__46 idtype_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/wait.h"
typedef __id_t id_t;
#line 140
struct rusage ;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 37 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __quad_t quad_t;
#line 38 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsid_t fsid_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 47 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino64_t;
#line 59 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 69 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 74 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 114 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __daddr_t daddr_t;
#line 115 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 121 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h"
typedef __clock_t clock_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h"
typedef __timer_t timer_t;
#line 138 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __suseconds_t suseconds_t;
#line 148 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long ulong;
#line 149 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 150 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int8_t int8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 158 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint8_t u_int8_t;
#line 159 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint16_t u_int16_t;
#line 160 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint32_t u_int32_t;
#line 161 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uint64_t u_int64_t;
#line 164 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long register_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 49 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 59 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_47 {
   __fd_mask fds_bits[16] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_47 fd_set;
#line 77 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 185 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blksize_t blksize_t;
#line 192 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt_t blkcnt_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt_t fsblkcnt_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt_t fsfilcnt_t;
#line 219 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 220 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 221 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef int wchar_t;
#line 59 "/usr/include/stdlib.h"
struct __anonstruct_48 {
   int quot ;
   int rem ;
};
#line 63 "/usr/include/stdlib.h"
typedef struct __anonstruct_48 div_t;
#line 67 "/usr/include/stdlib.h"
struct __anonstruct_49 {
   long quot ;
   long rem ;
};
#line 71 "/usr/include/stdlib.h"
typedef struct __anonstruct_49 ldiv_t;
#line 77 "/usr/include/stdlib.h"
struct __anonstruct_50 {
   long long quot ;
   long long rem ;
};
#line 81 "/usr/include/stdlib.h"
typedef struct __anonstruct_50 lldiv_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_data ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h"
typedef struct __locale_struct *__locale_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h"
typedef __locale_t locale_t;
#line 424 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 491 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 816 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 819 "/usr/include/stdlib.h"
typedef __compar_fn_t comparison_fn_t;
#line 823 "/usr/include/stdlib.h"
typedef int (*__compar_d_fn_t)(void const   * , void const   * , void * );
#line 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef long ptrdiff_t;
#line 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
struct __anonstruct_51 {
   long long __max_align_ll ;
   long double __max_align_ld ;
};
#line 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h"
typedef struct __anonstruct_51 max_align_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 43 "/usr/include/stdint.h"
typedef __int_least8_t int_least8_t;
#line 44 "/usr/include/stdint.h"
typedef __int_least16_t int_least16_t;
#line 45 "/usr/include/stdint.h"
typedef __int_least32_t int_least32_t;
#line 46 "/usr/include/stdint.h"
typedef __int_least64_t int_least64_t;
#line 49 "/usr/include/stdint.h"
typedef __uint_least8_t uint_least8_t;
#line 50 "/usr/include/stdint.h"
typedef __uint_least16_t uint_least16_t;
#line 51 "/usr/include/stdint.h"
typedef __uint_least32_t uint_least32_t;
#line 52 "/usr/include/stdint.h"
typedef __uint_least64_t uint_least64_t;
#line 58 "/usr/include/stdint.h"
typedef signed char int_fast8_t;
#line 60 "/usr/include/stdint.h"
typedef long int_fast16_t;
#line 61 "/usr/include/stdint.h"
typedef long int_fast32_t;
#line 62 "/usr/include/stdint.h"
typedef long int_fast64_t;
#line 71 "/usr/include/stdint.h"
typedef unsigned char uint_fast8_t;
#line 73 "/usr/include/stdint.h"
typedef unsigned long uint_fast16_t;
#line 74 "/usr/include/stdint.h"
typedef unsigned long uint_fast32_t;
#line 75 "/usr/include/stdint.h"
typedef unsigned long uint_fast64_t;
#line 90 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 101 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 102 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 271 "/usr/include/inttypes.h"
struct __anonstruct_52 {
   long quot ;
   long rem ;
};
#line 275 "/usr/include/inttypes.h"
typedef struct __anonstruct_52 imaxdiv_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__53 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 93 "/usr/include/SDL/SDL_stdinc.h"
enum __anonenum__54 {
    SDL_FALSE = 0,
    SDL_TRUE = 1
} ;
#line 96 "/usr/include/SDL/SDL_stdinc.h"
typedef enum __anonenum__54 SDL_bool;
#line 98 "/usr/include/SDL/SDL_stdinc.h"
typedef int8_t Sint8;
#line 99 "/usr/include/SDL/SDL_stdinc.h"
typedef uint8_t Uint8;
#line 100 "/usr/include/SDL/SDL_stdinc.h"
typedef int16_t Sint16;
#line 101 "/usr/include/SDL/SDL_stdinc.h"
typedef uint16_t Uint16;
#line 102 "/usr/include/SDL/SDL_stdinc.h"
typedef int32_t Sint32;
#line 103 "/usr/include/SDL/SDL_stdinc.h"
typedef uint32_t Uint32;
#line 106 "/usr/include/SDL/SDL_stdinc.h"
typedef int64_t Sint64;
#line 108 "/usr/include/SDL/SDL_stdinc.h"
typedef uint64_t Uint64;
#line 125 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_uint8[1];
#line 126 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_sint8[1];
#line 127 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_uint16[1];
#line 128 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_sint16[1];
#line 129 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_uint32[1];
#line 130 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_sint32[1];
#line 131 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_uint64[1];
#line 132 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_sint64[1];
#line 146
enum __anonenum__55 {
    DUMMY_ENUM_VALUE = 0
} ;
#line 148 "/usr/include/SDL/SDL_stdinc.h"
typedef enum __anonenum__55 SDL_DUMMY_ENUM;
#line 151 "/usr/include/SDL/SDL_stdinc.h"
typedef int SDL_dummy_enum[1];
#line 55 "/usr/include/SDL/SDL_error.h"
enum __anonenum__56 {
    SDL_ENOMEM = 0,
    SDL_EFREAD = 1,
    SDL_EFWRITE = 2,
    SDL_EFSEEK = 3,
    SDL_UNSUPPORTED = 4,
    SDL_LASTERROR = 5
} ;
#line 62 "/usr/include/SDL/SDL_error.h"
typedef enum __anonenum__56 SDL_errorcode;
#line 55 "/usr/include/SDL/SDL_mutex.h"
struct SDL_mutex ;
#line 56 "/usr/include/SDL/SDL_mutex.h"
typedef struct SDL_mutex SDL_mutex;
#line 86
struct SDL_semaphore ;
#line 87 "/usr/include/SDL/SDL_mutex.h"
typedef struct SDL_semaphore SDL_sem;
#line 133
struct SDL_cond ;
#line 134 "/usr/include/SDL/SDL_mutex.h"
typedef struct SDL_cond SDL_cond;
#line 45 "/usr/include/SDL/SDL_thread.h"
struct SDL_Thread ;
#line 46 "/usr/include/SDL/SDL_thread.h"
typedef struct SDL_Thread SDL_Thread;
#line 78 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_58 {
   int autoclose ;
   FILE *fp ;
};
#line 83 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_59 {
   Uint8 *base ;
   Uint8 *here ;
   Uint8 *stop ;
};
#line 88 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_60 {
   void *data1 ;
};
#line 65 "/usr/include/SDL/SDL_rwops.h"
union __anonunion_57 {
   struct __anonstruct_58 stdio ;
   struct __anonstruct_59 mem ;
   struct __anonstruct_60 unknown ;
};
#line 42 "/usr/include/SDL/SDL_rwops.h"
struct SDL_RWops {
   int (*seek)(struct SDL_RWops * , int  , int  ) ;
   int (*read)(struct SDL_RWops * , void * , int  , int  ) ;
   int (*write)(struct SDL_RWops * , void const   * , int  , int  ) ;
   int (*close)(struct SDL_RWops * ) ;
   Uint32 type ;
   union __anonunion_57 hidden ;
};
#line 93 "/usr/include/SDL/SDL_rwops.h"
typedef struct SDL_RWops SDL_RWops;
#line 74 "/usr/include/SDL/SDL_audio.h"
struct SDL_AudioSpec {
   int freq ;
   Uint16 format ;
   Uint8 channels ;
   Uint8 silence ;
   Uint16 samples ;
   Uint16 padding ;
   Uint32 size ;
   void (*callback)(void * , Uint8 * , int  ) ;
   void *userdata ;
};
#line 93 "/usr/include/SDL/SDL_audio.h"
typedef struct SDL_AudioSpec SDL_AudioSpec;
#line 126 "/usr/include/SDL/SDL_audio.h"
struct SDL_AudioCVT {
   int needed ;
   Uint16 src_format ;
   Uint16 dst_format ;
   double rate_incr ;
   Uint8 *buf ;
   int len ;
   int len_cvt ;
   int len_mult ;
   double len_ratio ;
   void (*filters[10])(struct SDL_AudioCVT * , Uint16  ) ;
   int filter_index ;
};
#line 138 "/usr/include/SDL/SDL_audio.h"
typedef struct SDL_AudioCVT SDL_AudioCVT;
#line 180
enum __anonenum__61 {
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING = 1,
    SDL_AUDIO_PAUSED = 2
} ;
#line 184 "/usr/include/SDL/SDL_audio.h"
typedef enum __anonenum__61 SDL_audiostatus;
#line 59 "/usr/include/SDL/SDL_cdrom.h"
enum __anonenum__62 {
    CD_TRAYEMPTY = 0,
    CD_STOPPED = 1,
    CD_PLAYING = 2,
    CD_PAUSED = 3,
    CD_ERROR = -1
} ;
#line 65 "/usr/include/SDL/SDL_cdrom.h"
typedef enum __anonenum__62 CDstatus;
#line 70 "/usr/include/SDL/SDL_cdrom.h"
struct SDL_CDtrack {
   Uint8 id ;
   Uint8 type ;
   Uint16 unused ;
   Uint32 length ;
   Uint32 offset ;
};
#line 76 "/usr/include/SDL/SDL_cdrom.h"
typedef struct SDL_CDtrack SDL_CDtrack;
#line 79 "/usr/include/SDL/SDL_cdrom.h"
struct SDL_CD {
   int id ;
   CDstatus status ;
   int numtracks ;
   int cur_track ;
   int cur_frame ;
   SDL_CDtrack track[100] ;
};
#line 90 "/usr/include/SDL/SDL_cdrom.h"
typedef struct SDL_CD SDL_CD;
#line 31 "/usr/include/SDL/SDL_keysym.h"
enum __anonenum__63 {
    SDLK_UNKNOWN = 0,
    SDLK_FIRST = 0,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_CLEAR = 12,
    SDLK_RETURN = 13,
    SDLK_PAUSE = 19,
    SDLK_ESCAPE = 27,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_DELETE = 127,
    SDLK_WORLD_0 = 160,
    SDLK_WORLD_1 = 161,
    SDLK_WORLD_2 = 162,
    SDLK_WORLD_3 = 163,
    SDLK_WORLD_4 = 164,
    SDLK_WORLD_5 = 165,
    SDLK_WORLD_6 = 166,
    SDLK_WORLD_7 = 167,
    SDLK_WORLD_8 = 168,
    SDLK_WORLD_9 = 169,
    SDLK_WORLD_10 = 170,
    SDLK_WORLD_11 = 171,
    SDLK_WORLD_12 = 172,
    SDLK_WORLD_13 = 173,
    SDLK_WORLD_14 = 174,
    SDLK_WORLD_15 = 175,
    SDLK_WORLD_16 = 176,
    SDLK_WORLD_17 = 177,
    SDLK_WORLD_18 = 178,
    SDLK_WORLD_19 = 179,
    SDLK_WORLD_20 = 180,
    SDLK_WORLD_21 = 181,
    SDLK_WORLD_22 = 182,
    SDLK_WORLD_23 = 183,
    SDLK_WORLD_24 = 184,
    SDLK_WORLD_25 = 185,
    SDLK_WORLD_26 = 186,
    SDLK_WORLD_27 = 187,
    SDLK_WORLD_28 = 188,
    SDLK_WORLD_29 = 189,
    SDLK_WORLD_30 = 190,
    SDLK_WORLD_31 = 191,
    SDLK_WORLD_32 = 192,
    SDLK_WORLD_33 = 193,
    SDLK_WORLD_34 = 194,
    SDLK_WORLD_35 = 195,
    SDLK_WORLD_36 = 196,
    SDLK_WORLD_37 = 197,
    SDLK_WORLD_38 = 198,
    SDLK_WORLD_39 = 199,
    SDLK_WORLD_40 = 200,
    SDLK_WORLD_41 = 201,
    SDLK_WORLD_42 = 202,
    SDLK_WORLD_43 = 203,
    SDLK_WORLD_44 = 204,
    SDLK_WORLD_45 = 205,
    SDLK_WORLD_46 = 206,
    SDLK_WORLD_47 = 207,
    SDLK_WORLD_48 = 208,
    SDLK_WORLD_49 = 209,
    SDLK_WORLD_50 = 210,
    SDLK_WORLD_51 = 211,
    SDLK_WORLD_52 = 212,
    SDLK_WORLD_53 = 213,
    SDLK_WORLD_54 = 214,
    SDLK_WORLD_55 = 215,
    SDLK_WORLD_56 = 216,
    SDLK_WORLD_57 = 217,
    SDLK_WORLD_58 = 218,
    SDLK_WORLD_59 = 219,
    SDLK_WORLD_60 = 220,
    SDLK_WORLD_61 = 221,
    SDLK_WORLD_62 = 222,
    SDLK_WORLD_63 = 223,
    SDLK_WORLD_64 = 224,
    SDLK_WORLD_65 = 225,
    SDLK_WORLD_66 = 226,
    SDLK_WORLD_67 = 227,
    SDLK_WORLD_68 = 228,
    SDLK_WORLD_69 = 229,
    SDLK_WORLD_70 = 230,
    SDLK_WORLD_71 = 231,
    SDLK_WORLD_72 = 232,
    SDLK_WORLD_73 = 233,
    SDLK_WORLD_74 = 234,
    SDLK_WORLD_75 = 235,
    SDLK_WORLD_76 = 236,
    SDLK_WORLD_77 = 237,
    SDLK_WORLD_78 = 238,
    SDLK_WORLD_79 = 239,
    SDLK_WORLD_80 = 240,
    SDLK_WORLD_81 = 241,
    SDLK_WORLD_82 = 242,
    SDLK_WORLD_83 = 243,
    SDLK_WORLD_84 = 244,
    SDLK_WORLD_85 = 245,
    SDLK_WORLD_86 = 246,
    SDLK_WORLD_87 = 247,
    SDLK_WORLD_88 = 248,
    SDLK_WORLD_89 = 249,
    SDLK_WORLD_90 = 250,
    SDLK_WORLD_91 = 251,
    SDLK_WORLD_92 = 252,
    SDLK_WORLD_93 = 253,
    SDLK_WORLD_94 = 254,
    SDLK_WORLD_95 = 255,
    SDLK_KP0 = 256,
    SDLK_KP1 = 257,
    SDLK_KP2 = 258,
    SDLK_KP3 = 259,
    SDLK_KP4 = 260,
    SDLK_KP5 = 261,
    SDLK_KP6 = 262,
    SDLK_KP7 = 263,
    SDLK_KP8 = 264,
    SDLK_KP9 = 265,
    SDLK_KP_PERIOD = 266,
    SDLK_KP_DIVIDE = 267,
    SDLK_KP_MULTIPLY = 268,
    SDLK_KP_MINUS = 269,
    SDLK_KP_PLUS = 270,
    SDLK_KP_ENTER = 271,
    SDLK_KP_EQUALS = 272,
    SDLK_UP = 273,
    SDLK_DOWN = 274,
    SDLK_RIGHT = 275,
    SDLK_LEFT = 276,
    SDLK_INSERT = 277,
    SDLK_HOME = 278,
    SDLK_END = 279,
    SDLK_PAGEUP = 280,
    SDLK_PAGEDOWN = 281,
    SDLK_F1 = 282,
    SDLK_F2 = 283,
    SDLK_F3 = 284,
    SDLK_F4 = 285,
    SDLK_F5 = 286,
    SDLK_F6 = 287,
    SDLK_F7 = 288,
    SDLK_F8 = 289,
    SDLK_F9 = 290,
    SDLK_F10 = 291,
    SDLK_F11 = 292,
    SDLK_F12 = 293,
    SDLK_F13 = 294,
    SDLK_F14 = 295,
    SDLK_F15 = 296,
    SDLK_NUMLOCK = 300,
    SDLK_CAPSLOCK = 301,
    SDLK_SCROLLOCK = 302,
    SDLK_RSHIFT = 303,
    SDLK_LSHIFT = 304,
    SDLK_RCTRL = 305,
    SDLK_LCTRL = 306,
    SDLK_RALT = 307,
    SDLK_LALT = 308,
    SDLK_RMETA = 309,
    SDLK_LMETA = 310,
    SDLK_LSUPER = 311,
    SDLK_RSUPER = 312,
    SDLK_MODE = 313,
    SDLK_COMPOSE = 314,
    SDLK_HELP = 315,
    SDLK_PRINT = 316,
    SDLK_SYSREQ = 317,
    SDLK_BREAK = 318,
    SDLK_MENU = 319,
    SDLK_POWER = 320,
    SDLK_EURO = 321,
    SDLK_UNDO = 322,
    SDLK_LAST = 323
} ;
#line 302 "/usr/include/SDL/SDL_keysym.h"
typedef enum __anonenum__63 SDLKey;
#line 305
enum __anonenum__64 {
    KMOD_NONE = 0,
    KMOD_LSHIFT = 1,
    KMOD_RSHIFT = 2,
    KMOD_LCTRL = 64,
    KMOD_RCTRL = 128,
    KMOD_LALT = 256,
    KMOD_RALT = 512,
    KMOD_LMETA = 1024,
    KMOD_RMETA = 2048,
    KMOD_NUM = 4096,
    KMOD_CAPS = 8192,
    KMOD_MODE = 16384,
    KMOD_RESERVED = 32768
} ;
#line 319 "/usr/include/SDL/SDL_keysym.h"
typedef enum __anonenum__64 SDLMod;
#line 59 "/usr/include/SDL/SDL_keyboard.h"
struct SDL_keysym {
   Uint8 scancode ;
   SDLKey sym ;
   SDLMod mod ;
   Uint16 unicode ;
};
#line 64 "/usr/include/SDL/SDL_keyboard.h"
typedef struct SDL_keysym SDL_keysym;
#line 50 "/usr/include/SDL/SDL_video.h"
struct SDL_Rect {
   Sint16 x ;
   Sint16 y ;
   Uint16 w ;
   Uint16 h ;
};
#line 53 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Rect SDL_Rect;
#line 55 "/usr/include/SDL/SDL_video.h"
struct SDL_Color {
   Uint8 r ;
   Uint8 g ;
   Uint8 b ;
   Uint8 unused ;
};
#line 60 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Color SDL_Color;
#line 63 "/usr/include/SDL/SDL_video.h"
struct SDL_Palette {
   int ncolors ;
   SDL_Color *colors ;
};
#line 66 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Palette SDL_Palette;
#line 70 "/usr/include/SDL/SDL_video.h"
struct SDL_PixelFormat {
   SDL_Palette *palette ;
   Uint8 BitsPerPixel ;
   Uint8 BytesPerPixel ;
   Uint8 Rloss ;
   Uint8 Gloss ;
   Uint8 Bloss ;
   Uint8 Aloss ;
   Uint8 Rshift ;
   Uint8 Gshift ;
   Uint8 Bshift ;
   Uint8 Ashift ;
   Uint32 Rmask ;
   Uint32 Gmask ;
   Uint32 Bmask ;
   Uint32 Amask ;
   Uint32 colorkey ;
   Uint8 alpha ;
};
#line 91 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_PixelFormat SDL_PixelFormat;
#line 105
struct private_hwdata ;
#line 115
struct SDL_BlitMap ;
#line 96 "/usr/include/SDL/SDL_video.h"
struct SDL_Surface {
   Uint32 flags ;
   SDL_PixelFormat *format ;
   int w ;
   int h ;
   Uint16 pitch ;
   void *pixels ;
   int offset ;
   struct private_hwdata *hwdata ;
   SDL_Rect clip_rect ;
   Uint32 unused1 ;
   Uint32 locked ;
   struct SDL_BlitMap *map ;
   unsigned int format_version ;
   int refcount ;
};
#line 122 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Surface SDL_Surface;
#line 166 "/usr/include/SDL/SDL_video.h"
typedef int (*SDL_blit)(struct SDL_Surface * , SDL_Rect * , struct SDL_Surface * ,
                        SDL_Rect * );
#line 171 "/usr/include/SDL/SDL_video.h"
struct SDL_VideoInfo {
   Uint32 hw_available ;
   Uint32 wm_available ;
   Uint32 UnusedBits1 ;
   Uint32 UnusedBits2 ;
   Uint32 blit_hw ;
   Uint32 blit_hw_CC ;
   Uint32 blit_hw_A ;
   Uint32 blit_sw ;
   Uint32 blit_sw_CC ;
   Uint32 blit_sw_A ;
   Uint32 blit_fill ;
   Uint32 UnusedBits3 ;
   Uint32 video_mem ;
   SDL_PixelFormat *vfmt ;
   int current_w ;
   int current_h ;
};
#line 188 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_VideoInfo SDL_VideoInfo;
#line 217
struct private_yuvhwfuncs ;
#line 218
struct private_yuvhwdata ;
#line 208 "/usr/include/SDL/SDL_video.h"
struct SDL_Overlay {
   Uint32 format ;
   int w ;
   int h ;
   int planes ;
   Uint16 *pitches ;
   Uint8 **pixels ;
   struct private_yuvhwfuncs *hwfuncs ;
   struct private_yuvhwdata *hwdata ;
   Uint32 hw_overlay ;
   Uint32 UnusedBits ;
};
#line 226 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Overlay SDL_Overlay;
#line 230
enum __anonenum__65 {
    SDL_GL_RED_SIZE = 0,
    SDL_GL_GREEN_SIZE = 1,
    SDL_GL_BLUE_SIZE = 2,
    SDL_GL_ALPHA_SIZE = 3,
    SDL_GL_BUFFER_SIZE = 4,
    SDL_GL_DOUBLEBUFFER = 5,
    SDL_GL_DEPTH_SIZE = 6,
    SDL_GL_STENCIL_SIZE = 7,
    SDL_GL_ACCUM_RED_SIZE = 8,
    SDL_GL_ACCUM_GREEN_SIZE = 9,
    SDL_GL_ACCUM_BLUE_SIZE = 10,
    SDL_GL_ACCUM_ALPHA_SIZE = 11,
    SDL_GL_STEREO = 12,
    SDL_GL_MULTISAMPLEBUFFERS = 13,
    SDL_GL_MULTISAMPLESAMPLES = 14,
    SDL_GL_ACCELERATED_VISUAL = 15,
    SDL_GL_SWAP_CONTROL = 16
} ;
#line 248 "/usr/include/SDL/SDL_video.h"
typedef enum __anonenum__65 SDL_GLattr;
#line 923
enum __anonenum__66 {
    SDL_GRAB_QUERY = -1,
    SDL_GRAB_OFF = 0,
    SDL_GRAB_ON = 1,
    SDL_GRAB_FULLSCREEN = 2
} ;
#line 928 "/usr/include/SDL/SDL_video.h"
typedef enum __anonenum__66 SDL_GrabMode;
#line 40 "/usr/include/SDL/SDL_mouse.h"
struct WMcursor ;
#line 40 "/usr/include/SDL/SDL_mouse.h"
typedef struct WMcursor WMcursor;
#line 41 "/usr/include/SDL/SDL_mouse.h"
struct SDL_Cursor {
   SDL_Rect area ;
   Sint16 hot_x ;
   Sint16 hot_y ;
   Uint8 *data ;
   Uint8 *mask ;
   Uint8 *save[2] ;
   WMcursor *wm_cursor ;
};
#line 48 "/usr/include/SDL/SDL_mouse.h"
typedef struct SDL_Cursor SDL_Cursor;
#line 46 "/usr/include/SDL/SDL_joystick.h"
struct _SDL_Joystick ;
#line 47 "/usr/include/SDL/SDL_joystick.h"
typedef struct _SDL_Joystick SDL_Joystick;
#line 52 "/usr/include/SDL/SDL_events.h"
enum __anonenum__67 {
    SDL_NOEVENT = 0,
    SDL_ACTIVEEVENT = 1,
    SDL_KEYDOWN = 2,
    SDL_KEYUP = 3,
    SDL_MOUSEMOTION = 4,
    SDL_MOUSEBUTTONDOWN = 5,
    SDL_MOUSEBUTTONUP = 6,
    SDL_JOYAXISMOTION = 7,
    SDL_JOYBALLMOTION = 8,
    SDL_JOYHATMOTION = 9,
    SDL_JOYBUTTONDOWN = 10,
    SDL_JOYBUTTONUP = 11,
    SDL_QUIT = 12,
    SDL_SYSWMEVENT = 13,
    SDL_EVENT_RESERVEDA = 14,
    SDL_EVENT_RESERVEDB = 15,
    SDL_VIDEORESIZE = 16,
    SDL_VIDEOEXPOSE = 17,
    SDL_EVENT_RESERVED2 = 18,
    SDL_EVENT_RESERVED3 = 19,
    SDL_EVENT_RESERVED4 = 20,
    SDL_EVENT_RESERVED5 = 21,
    SDL_EVENT_RESERVED6 = 22,
    SDL_EVENT_RESERVED7 = 23,
    SDL_USEREVENT = 24,
    SDL_NUMEVENTS = 32
} ;
#line 83 "/usr/include/SDL/SDL_events.h"
typedef enum __anonenum__67 SDL_EventType;
#line 88
enum __anonenum__68 {
    SDL_ACTIVEEVENTMASK = 2,
    SDL_KEYDOWNMASK = 4,
    SDL_KEYUPMASK = 8,
    SDL_KEYEVENTMASK = 12,
    SDL_MOUSEMOTIONMASK = 16,
    SDL_MOUSEBUTTONDOWNMASK = 32,
    SDL_MOUSEBUTTONUPMASK = 64,
    SDL_MOUSEEVENTMASK = 112,
    SDL_JOYAXISMOTIONMASK = 128,
    SDL_JOYBALLMOTIONMASK = 256,
    SDL_JOYHATMOTIONMASK = 512,
    SDL_JOYBUTTONDOWNMASK = 1024,
    SDL_JOYBUTTONUPMASK = 2048,
    SDL_JOYEVENTMASK = 3968,
    SDL_VIDEORESIZEMASK = 65536,
    SDL_VIDEOEXPOSEMASK = 131072,
    SDL_QUITMASK = 4096,
    SDL_SYSWMEVENTMASK = 8192
} ;
#line 114 "/usr/include/SDL/SDL_events.h"
typedef enum __anonenum__68 SDL_EventMask;
#line 119 "/usr/include/SDL/SDL_events.h"
struct SDL_ActiveEvent {
   Uint8 type ;
   Uint8 gain ;
   Uint8 state ;
};
#line 123 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ActiveEvent SDL_ActiveEvent;
#line 126 "/usr/include/SDL/SDL_events.h"
struct SDL_KeyboardEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 state ;
   SDL_keysym keysym ;
};
#line 131 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_KeyboardEvent SDL_KeyboardEvent;
#line 134 "/usr/include/SDL/SDL_events.h"
struct SDL_MouseMotionEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 state ;
   Uint16 x ;
   Uint16 y ;
   Sint16 xrel ;
   Sint16 yrel ;
};
#line 141 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_MouseMotionEvent SDL_MouseMotionEvent;
#line 144 "/usr/include/SDL/SDL_events.h"
struct SDL_MouseButtonEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 button ;
   Uint8 state ;
   Uint16 x ;
   Uint16 y ;
};
#line 150 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_MouseButtonEvent SDL_MouseButtonEvent;
#line 153 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyAxisEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 axis ;
   Sint16 value ;
};
#line 158 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyAxisEvent SDL_JoyAxisEvent;
#line 161 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyBallEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 ball ;
   Sint16 xrel ;
   Sint16 yrel ;
};
#line 167 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyBallEvent SDL_JoyBallEvent;
#line 170 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyHatEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 hat ;
   Uint8 value ;
};
#line 180 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyHatEvent SDL_JoyHatEvent;
#line 183 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyButtonEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 button ;
   Uint8 state ;
};
#line 188 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyButtonEvent SDL_JoyButtonEvent;
#line 194 "/usr/include/SDL/SDL_events.h"
struct SDL_ResizeEvent {
   Uint8 type ;
   int w ;
   int h ;
};
#line 198 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ResizeEvent SDL_ResizeEvent;
#line 201 "/usr/include/SDL/SDL_events.h"
struct SDL_ExposeEvent {
   Uint8 type ;
};
#line 203 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ExposeEvent SDL_ExposeEvent;
#line 206 "/usr/include/SDL/SDL_events.h"
struct SDL_QuitEvent {
   Uint8 type ;
};
#line 208 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_QuitEvent SDL_QuitEvent;
#line 211 "/usr/include/SDL/SDL_events.h"
struct SDL_UserEvent {
   Uint8 type ;
   int code ;
   void *data1 ;
   void *data2 ;
};
#line 216 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_UserEvent SDL_UserEvent;
#line 219
struct SDL_SysWMmsg ;
#line 220 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
#line 221 "/usr/include/SDL/SDL_events.h"
struct SDL_SysWMEvent {
   Uint8 type ;
   SDL_SysWMmsg *msg ;
};
#line 224 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_SysWMEvent SDL_SysWMEvent;
#line 227 "/usr/include/SDL/SDL_events.h"
union SDL_Event {
   Uint8 type ;
   SDL_ActiveEvent active ;
   SDL_KeyboardEvent key ;
   SDL_MouseMotionEvent motion ;
   SDL_MouseButtonEvent button ;
   SDL_JoyAxisEvent jaxis ;
   SDL_JoyBallEvent jball ;
   SDL_JoyHatEvent jhat ;
   SDL_JoyButtonEvent jbutton ;
   SDL_ResizeEvent resize ;
   SDL_ExposeEvent expose ;
   SDL_QuitEvent quit ;
   SDL_UserEvent user ;
   SDL_SysWMEvent syswm ;
};
#line 242 "/usr/include/SDL/SDL_events.h"
typedef union SDL_Event SDL_Event;
#line 253
enum __anonenum__69 {
    SDL_ADDEVENT = 0,
    SDL_PEEKEVENT = 1,
    SDL_GETEVENT = 2
} ;
#line 257 "/usr/include/SDL/SDL_events.h"
typedef enum __anonenum__69 SDL_eventaction;
#line 300 "/usr/include/SDL/SDL_events.h"
typedef int (*SDL_EventFilter)(SDL_Event * );
#line 55 "/usr/include/SDL/SDL_timer.h"
typedef Uint32 (*SDL_TimerCallback)(Uint32  );
#line 101 "/usr/include/SDL/SDL_timer.h"
typedef Uint32 (*SDL_NewTimerCallback)(Uint32  , void * );
#line 104
struct _SDL_TimerID ;
#line 104 "/usr/include/SDL/SDL_timer.h"
typedef struct _SDL_TimerID *SDL_TimerID;
#line 47 "/usr/include/SDL/SDL_version.h"
struct SDL_version {
   Uint8 major ;
   Uint8 minor ;
   Uint8 patch ;
};
#line 51 "/usr/include/SDL/SDL_version.h"
typedef struct SDL_version SDL_version;
#line 26 "/usr/include/x86_64-linux-gnu/bits/timex.h"
struct timex {
   unsigned int modes ;
   __syscall_slong_t offset ;
   __syscall_slong_t freq ;
   __syscall_slong_t maxerror ;
   __syscall_slong_t esterror ;
   int status ;
   __syscall_slong_t constant ;
   __syscall_slong_t precision ;
   __syscall_slong_t tolerance ;
   struct timeval time ;
   __syscall_slong_t tick ;
   __syscall_slong_t ppsfreq ;
   __syscall_slong_t jitter ;
   int shift ;
   __syscall_slong_t stabil ;
   __syscall_slong_t jitcnt ;
   __syscall_slong_t calcnt ;
   __syscall_slong_t errcnt ;
   __syscall_slong_t stbcnt ;
   int tai ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
   int  ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 41 "/usr/include/paper.h"
struct paper ;
#line 163 "/usr/include/math.h"
typedef float float_t;
#line 164 "/usr/include/math.h"
typedef double double_t;
#line 251
enum __anonenum__70 {
    FP_INT_UPWARD = 0,
    FP_INT_DOWNWARD = 1,
    FP_INT_TOWARDZERO = 2,
    FP_INT_TONEARESTFROMZERO = 3,
    FP_INT_TONEAREST = 4
} ;
#line 934
enum __anonenum__71 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h"
typedef int error_t;
#line 38 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.h"
enum __anonenum__72 {
    SND_HARP = 0,
    SND_CLICK = 1,
    SND_BLEEP = 2,
    SND_BUBBLE = 3,
    SND_STAMP = 4,
    SND_LINE_START = 5,
    SND_LINE_END = 6,
    SND_SCROLL = 7,
    SND_PAINT1 = 8,
    SND_PAINT2 = 9,
    SND_PAINT3 = 10,
    SND_PAINT4 = 11,
    SND_ERASER1 = 12,
    SND_ERASER2 = 13,
    SND_SAVE = 14,
    SND_PROMPT = 15,
    SND_FLIP = 16,
    SND_MIRROR = 17,
    SND_KEYCLICK = 18,
    SND_KEYCLICKRING = 19,
    SND_RETURN = 20,
    SND_SHRINK = 21,
    SND_GROW = 22,
    SND_ITALIC_ON = 23,
    SND_ITALIC_OFF = 24,
    SND_AREYOUSURE = 25,
    SND_YOUCANNOT = 26,
    SND_TUXOK = 27,
    SND_THICK = 28,
    SND_THIN = 29,
    SND_FILL = 30,
    NUM_SOUNDS = 31
} ;
#line 6 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.h"
struct ge_GIF {
   uint16_t w ;
   uint16_t h ;
   int depth ;
   int fd ;
   int offset ;
   int nframes ;
   uint8_t *frame ;
   uint8_t *back ;
   uint32_t partial ;
   uint8_t buffer[255] ;
};
#line 15 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.h"
typedef struct ge_GIF ge_GIF;
#line 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__92 {
    _PC_LINK_MAX___0 = 0,
    _PC_MAX_CANON___0 = 1,
    _PC_MAX_INPUT___0 = 2,
    _PC_NAME_MAX___0 = 3,
    _PC_PATH_MAX___0 = 4,
    _PC_PIPE_BUF___0 = 5,
    _PC_CHOWN_RESTRICTED___0 = 6,
    _PC_NO_TRUNC___0 = 7,
    _PC_VDISABLE___0 = 8,
    _PC_SYNC_IO___0 = 9,
    _PC_ASYNC_IO___0 = 10,
    _PC_PRIO_IO___0 = 11,
    _PC_SOCK_MAXBUF___0 = 12,
    _PC_FILESIZEBITS___0 = 13,
    _PC_REC_INCR_XFER_SIZE___0 = 14,
    _PC_REC_MAX_XFER_SIZE___0 = 15,
    _PC_REC_MIN_XFER_SIZE___0 = 16,
    _PC_REC_XFER_ALIGN___0 = 17,
    _PC_ALLOC_SIZE_MIN___0 = 18,
    _PC_SYMLINK_MAX___0 = 19,
    _PC_2_SYMLINKS___0 = 20
} ;
#line 71
enum __anonenum__93 {
    _SC_ARG_MAX___0 = 0,
    _SC_CHILD_MAX___0 = 1,
    _SC_CLK_TCK___0 = 2,
    _SC_NGROUPS_MAX___0 = 3,
    _SC_OPEN_MAX___0 = 4,
    _SC_STREAM_MAX___0 = 5,
    _SC_TZNAME_MAX___0 = 6,
    _SC_JOB_CONTROL___0 = 7,
    _SC_SAVED_IDS___0 = 8,
    _SC_REALTIME_SIGNALS___0 = 9,
    _SC_PRIORITY_SCHEDULING___0 = 10,
    _SC_TIMERS___0 = 11,
    _SC_ASYNCHRONOUS_IO___0 = 12,
    _SC_PRIORITIZED_IO___0 = 13,
    _SC_SYNCHRONIZED_IO___0 = 14,
    _SC_FSYNC___0 = 15,
    _SC_MAPPED_FILES___0 = 16,
    _SC_MEMLOCK___0 = 17,
    _SC_MEMLOCK_RANGE___0 = 18,
    _SC_MEMORY_PROTECTION___0 = 19,
    _SC_MESSAGE_PASSING___0 = 20,
    _SC_SEMAPHORES___0 = 21,
    _SC_SHARED_MEMORY_OBJECTS___0 = 22,
    _SC_AIO_LISTIO_MAX___0 = 23,
    _SC_AIO_MAX___0 = 24,
    _SC_AIO_PRIO_DELTA_MAX___0 = 25,
    _SC_DELAYTIMER_MAX___0 = 26,
    _SC_MQ_OPEN_MAX___0 = 27,
    _SC_MQ_PRIO_MAX___0 = 28,
    _SC_VERSION___0 = 29,
    _SC_PAGESIZE___0 = 30,
    _SC_RTSIG_MAX___0 = 31,
    _SC_SEM_NSEMS_MAX___0 = 32,
    _SC_SEM_VALUE_MAX___0 = 33,
    _SC_SIGQUEUE_MAX___0 = 34,
    _SC_TIMER_MAX___0 = 35,
    _SC_BC_BASE_MAX___0 = 36,
    _SC_BC_DIM_MAX___0 = 37,
    _SC_BC_SCALE_MAX___0 = 38,
    _SC_BC_STRING_MAX___0 = 39,
    _SC_COLL_WEIGHTS_MAX___0 = 40,
    _SC_EQUIV_CLASS_MAX___0 = 41,
    _SC_EXPR_NEST_MAX___0 = 42,
    _SC_LINE_MAX___0 = 43,
    _SC_RE_DUP_MAX___0 = 44,
    _SC_CHARCLASS_NAME_MAX___0 = 45,
    _SC_2_VERSION___0 = 46,
    _SC_2_C_BIND___0 = 47,
    _SC_2_C_DEV___0 = 48,
    _SC_2_FORT_DEV___0 = 49,
    _SC_2_FORT_RUN___0 = 50,
    _SC_2_SW_DEV___0 = 51,
    _SC_2_LOCALEDEF___0 = 52,
    _SC_PII___0 = 53,
    _SC_PII_XTI___0 = 54,
    _SC_PII_SOCKET___0 = 55,
    _SC_PII_INTERNET___0 = 56,
    _SC_PII_OSI___0 = 57,
    _SC_POLL___0 = 58,
    _SC_SELECT___0 = 59,
    _SC_UIO_MAXIOV___0 = 60,
    _SC_IOV_MAX___0 = 60,
    _SC_PII_INTERNET_STREAM___0 = 61,
    _SC_PII_INTERNET_DGRAM___0 = 62,
    _SC_PII_OSI_COTS___0 = 63,
    _SC_PII_OSI_CLTS___0 = 64,
    _SC_PII_OSI_M___0 = 65,
    _SC_T_IOV_MAX___0 = 66,
    _SC_THREADS___0 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___0 = 68,
    _SC_GETGR_R_SIZE_MAX___0 = 69,
    _SC_GETPW_R_SIZE_MAX___0 = 70,
    _SC_LOGIN_NAME_MAX___0 = 71,
    _SC_TTY_NAME_MAX___0 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___0 = 73,
    _SC_THREAD_KEYS_MAX___0 = 74,
    _SC_THREAD_STACK_MIN___0 = 75,
    _SC_THREAD_THREADS_MAX___0 = 76,
    _SC_THREAD_ATTR_STACKADDR___0 = 77,
    _SC_THREAD_ATTR_STACKSIZE___0 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___0 = 79,
    _SC_THREAD_PRIO_INHERIT___0 = 80,
    _SC_THREAD_PRIO_PROTECT___0 = 81,
    _SC_THREAD_PROCESS_SHARED___0 = 82,
    _SC_NPROCESSORS_CONF___0 = 83,
    _SC_NPROCESSORS_ONLN___0 = 84,
    _SC_PHYS_PAGES___0 = 85,
    _SC_AVPHYS_PAGES___0 = 86,
    _SC_ATEXIT_MAX___0 = 87,
    _SC_PASS_MAX___0 = 88,
    _SC_XOPEN_VERSION___0 = 89,
    _SC_XOPEN_XCU_VERSION___0 = 90,
    _SC_XOPEN_UNIX___0 = 91,
    _SC_XOPEN_CRYPT___0 = 92,
    _SC_XOPEN_ENH_I18N___0 = 93,
    _SC_XOPEN_SHM___0 = 94,
    _SC_2_CHAR_TERM___0 = 95,
    _SC_2_C_VERSION___0 = 96,
    _SC_2_UPE___0 = 97,
    _SC_XOPEN_XPG2___0 = 98,
    _SC_XOPEN_XPG3___0 = 99,
    _SC_XOPEN_XPG4___0 = 100,
    _SC_CHAR_BIT___0 = 101,
    _SC_CHAR_MAX___0 = 102,
    _SC_CHAR_MIN___0 = 103,
    _SC_INT_MAX___0 = 104,
    _SC_INT_MIN___0 = 105,
    _SC_LONG_BIT___0 = 106,
    _SC_WORD_BIT___0 = 107,
    _SC_MB_LEN_MAX___0 = 108,
    _SC_NZERO___0 = 109,
    _SC_SSIZE_MAX___0 = 110,
    _SC_SCHAR_MAX___0 = 111,
    _SC_SCHAR_MIN___0 = 112,
    _SC_SHRT_MAX___0 = 113,
    _SC_SHRT_MIN___0 = 114,
    _SC_UCHAR_MAX___0 = 115,
    _SC_UINT_MAX___0 = 116,
    _SC_ULONG_MAX___0 = 117,
    _SC_USHRT_MAX___0 = 118,
    _SC_NL_ARGMAX___0 = 119,
    _SC_NL_LANGMAX___0 = 120,
    _SC_NL_MSGMAX___0 = 121,
    _SC_NL_NMAX___0 = 122,
    _SC_NL_SETMAX___0 = 123,
    _SC_NL_TEXTMAX___0 = 124,
    _SC_XBS5_ILP32_OFF32___0 = 125,
    _SC_XBS5_ILP32_OFFBIG___0 = 126,
    _SC_XBS5_LP64_OFF64___0 = 127,
    _SC_XBS5_LPBIG_OFFBIG___0 = 128,
    _SC_XOPEN_LEGACY___0 = 129,
    _SC_XOPEN_REALTIME___0 = 130,
    _SC_XOPEN_REALTIME_THREADS___0 = 131,
    _SC_ADVISORY_INFO___0 = 132,
    _SC_BARRIERS___0 = 133,
    _SC_BASE___0 = 134,
    _SC_C_LANG_SUPPORT___0 = 135,
    _SC_C_LANG_SUPPORT_R___0 = 136,
    _SC_CLOCK_SELECTION___0 = 137,
    _SC_CPUTIME___0 = 138,
    _SC_THREAD_CPUTIME___0 = 139,
    _SC_DEVICE_IO___0 = 140,
    _SC_DEVICE_SPECIFIC___0 = 141,
    _SC_DEVICE_SPECIFIC_R___0 = 142,
    _SC_FD_MGMT___0 = 143,
    _SC_FIFO___0 = 144,
    _SC_PIPE___0 = 145,
    _SC_FILE_ATTRIBUTES___0 = 146,
    _SC_FILE_LOCKING___0 = 147,
    _SC_FILE_SYSTEM___0 = 148,
    _SC_MONOTONIC_CLOCK___0 = 149,
    _SC_MULTI_PROCESS___0 = 150,
    _SC_SINGLE_PROCESS___0 = 151,
    _SC_NETWORKING___0 = 152,
    _SC_READER_WRITER_LOCKS___0 = 153,
    _SC_SPIN_LOCKS___0 = 154,
    _SC_REGEXP___0 = 155,
    _SC_REGEX_VERSION___0 = 156,
    _SC_SHELL___0 = 157,
    _SC_SIGNALS___0 = 158,
    _SC_SPAWN___0 = 159,
    _SC_SPORADIC_SERVER___0 = 160,
    _SC_THREAD_SPORADIC_SERVER___0 = 161,
    _SC_SYSTEM_DATABASE___0 = 162,
    _SC_SYSTEM_DATABASE_R___0 = 163,
    _SC_TIMEOUTS___0 = 164,
    _SC_TYPED_MEMORY_OBJECTS___0 = 165,
    _SC_USER_GROUPS___0 = 166,
    _SC_USER_GROUPS_R___0 = 167,
    _SC_2_PBS___0 = 168,
    _SC_2_PBS_ACCOUNTING___0 = 169,
    _SC_2_PBS_LOCATE___0 = 170,
    _SC_2_PBS_MESSAGE___0 = 171,
    _SC_2_PBS_TRACK___0 = 172,
    _SC_SYMLOOP_MAX___0 = 173,
    _SC_STREAMS___0 = 174,
    _SC_2_PBS_CHECKPOINT___0 = 175,
    _SC_V6_ILP32_OFF32___0 = 176,
    _SC_V6_ILP32_OFFBIG___0 = 177,
    _SC_V6_LP64_OFF64___0 = 178,
    _SC_V6_LPBIG_OFFBIG___0 = 179,
    _SC_HOST_NAME_MAX___0 = 180,
    _SC_TRACE___0 = 181,
    _SC_TRACE_EVENT_FILTER___0 = 182,
    _SC_TRACE_INHERIT___0 = 183,
    _SC_TRACE_LOG___0 = 184,
    _SC_LEVEL1_ICACHE_SIZE___0 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___0 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___0 = 187,
    _SC_LEVEL1_DCACHE_SIZE___0 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___0 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___0 = 190,
    _SC_LEVEL2_CACHE_SIZE___0 = 191,
    _SC_LEVEL2_CACHE_ASSOC___0 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___0 = 193,
    _SC_LEVEL3_CACHE_SIZE___0 = 194,
    _SC_LEVEL3_CACHE_ASSOC___0 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___0 = 196,
    _SC_LEVEL4_CACHE_SIZE___0 = 197,
    _SC_LEVEL4_CACHE_ASSOC___0 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___0 = 199,
    _SC_IPV6___0 = 235,
    _SC_RAW_SOCKETS___0 = 236,
    _SC_V7_ILP32_OFF32___0 = 237,
    _SC_V7_ILP32_OFFBIG___0 = 238,
    _SC_V7_LP64_OFF64___0 = 239,
    _SC_V7_LPBIG_OFFBIG___0 = 240,
    _SC_SS_REPL_MAX___0 = 241,
    _SC_TRACE_EVENT_NAME_MAX___0 = 242,
    _SC_TRACE_NAME_MAX___0 = 243,
    _SC_TRACE_SYS_MAX___0 = 244,
    _SC_TRACE_USER_EVENT_MAX___0 = 245,
    _SC_XOPEN_STREAMS___0 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___0 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___0 = 248,
    _SC_MINSIGSTKSZ___0 = 249,
    _SC_SIGSTKSZ___0 = 250
} ;
#line 539
enum __anonenum__94 {
    _CS_PATH___0 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___0 = 1,
    _CS_GNU_LIBC_VERSION___0 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___0 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___0 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___0 = 5,
    _CS_LFS_CFLAGS___0 = 1000,
    _CS_LFS_LDFLAGS___0 = 1001,
    _CS_LFS_LIBS___0 = 1002,
    _CS_LFS_LINTFLAGS___0 = 1003,
    _CS_LFS64_CFLAGS___0 = 1004,
    _CS_LFS64_LDFLAGS___0 = 1005,
    _CS_LFS64_LIBS___0 = 1006,
    _CS_LFS64_LINTFLAGS___0 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___0 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___0 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___0 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___0 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___0 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___0 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___0 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___0 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___0 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___0 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___0 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___0 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___0 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___0 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___0 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___0 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___0 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___0 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___0 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___0 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___0 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___0 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___0 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___0 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___0 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___0 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___0 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___0 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___0 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___0 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___0 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___0 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___0 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___0 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___0 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___0 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___0 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___0 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___0 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___0 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___0 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___0 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___0 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___0 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___0 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___0 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___0 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___0 = 1147,
    _CS_V6_ENV___0 = 1148,
    _CS_V7_ENV___0 = 1149
} ;
#line 37 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
struct Node {
   uint16_t key ;
   struct Node *children[] ;
};
#line 41 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
typedef struct Node Node;
#line 32 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/get_fname.h"
enum __anonenum__111 {
    DIR_SAVE = 0,
    DIR_DATA = 1,
    DIR_EXPORT = 2,
    DIR_EXPORT_PARENT = 3
} ;
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 103 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef signed char __s8;
#line 21 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef short __s16;
#line 24 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 27 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 31 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 25 "/usr/include/linux/posix_types.h"
struct __anonstruct_128 {
   unsigned long fds_bits[16] ;
};
#line 27 "/usr/include/linux/posix_types.h"
typedef struct __anonstruct_128 __kernel_fd_set;
#line 30 "/usr/include/linux/posix_types.h"
typedef void (*__kernel_sighandler_t)(int  );
#line 33 "/usr/include/linux/posix_types.h"
typedef int __kernel_key_t;
#line 34 "/usr/include/linux/posix_types.h"
typedef int __kernel_mqd_t;
#line 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_uid_t;
#line 12 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned short __kernel_old_gid_t;
#line 15 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h"
typedef unsigned long __kernel_old_dev_t;
#line 15 "/usr/include/asm-generic/posix_types.h"
typedef long __kernel_long_t;
#line 16 "/usr/include/asm-generic/posix_types.h"
typedef unsigned long __kernel_ulong_t;
#line 20 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_ino_t;
#line 24 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_mode_t;
#line 28 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 32 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_ipc_pid_t;
#line 36 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid_t;
#line 37 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid_t;
#line 41 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_suseconds_t;
#line 45 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_daddr_t;
#line 49 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_uid32_t;
#line 50 "/usr/include/asm-generic/posix_types.h"
typedef unsigned int __kernel_gid32_t;
#line 72 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_ulong_t __kernel_size_t;
#line 73 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ssize_t;
#line 74 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_ptrdiff_t;
#line 79 "/usr/include/asm-generic/posix_types.h"
struct __anonstruct_129 {
   int val[2] ;
};
#line 81 "/usr/include/asm-generic/posix_types.h"
typedef struct __anonstruct_129 __kernel_fsid_t;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_off_t;
#line 88 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 89 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_old_time_t;
#line 90 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_time_t;
#line 91 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_time64_t;
#line 92 "/usr/include/asm-generic/posix_types.h"
typedef __kernel_long_t __kernel_clock_t;
#line 93 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_timer_t;
#line 94 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_clockid_t;
#line 95 "/usr/include/asm-generic/posix_types.h"
typedef char *__kernel_caddr_t;
#line 96 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_uid16_t;
#line 97 "/usr/include/asm-generic/posix_types.h"
typedef unsigned short __kernel_gid16_t;
#line 24 "/usr/include/linux/types.h"
typedef __u16 __le16;
#line 25 "/usr/include/linux/types.h"
typedef __u16 __be16;
#line 26 "/usr/include/linux/types.h"
typedef __u32 __le32;
#line 27 "/usr/include/linux/types.h"
typedef __u32 __be32;
#line 28 "/usr/include/linux/types.h"
typedef __u64 __le64;
#line 29 "/usr/include/linux/types.h"
typedef __u64 __be64;
#line 31 "/usr/include/linux/types.h"
typedef __u16 __sum16;
#line 32 "/usr/include/linux/types.h"
typedef __u32 __wsum;
#line 47 "/usr/include/linux/types.h"
typedef unsigned int __poll_t;
#line 56 "/usr/include/linux/stat.h"
struct statx_timestamp {
   __s64 tv_sec ;
   __u32 tv_nsec ;
   __s32 __reserved ;
};
#line 99 "/usr/include/linux/stat.h"
struct statx {
   __u32 stx_mask ;
   __u32 stx_blksize ;
   __u64 stx_attributes ;
   __u32 stx_nlink ;
   __u32 stx_uid ;
   __u32 stx_gid ;
   __u16 stx_mode ;
   __u16 __spare0[1] ;
   __u64 stx_ino ;
   __u64 stx_size ;
   __u64 stx_blocks ;
   __u64 stx_attributes_mask ;
   struct statx_timestamp stx_atime ;
   struct statx_timestamp stx_btime ;
   struct statx_timestamp stx_ctime ;
   struct statx_timestamp stx_mtime ;
   __u32 stx_rdev_major ;
   __u32 stx_rdev_minor ;
   __u32 stx_dev_major ;
   __u32 stx_dev_minor ;
   __u64 stx_mnt_id ;
   __u64 __spare2 ;
   __u64 __spare3[12] ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__130 {
    _PC_LINK_MAX___1 = 0,
    _PC_MAX_CANON___1 = 1,
    _PC_MAX_INPUT___1 = 2,
    _PC_NAME_MAX___1 = 3,
    _PC_PATH_MAX___1 = 4,
    _PC_PIPE_BUF___1 = 5,
    _PC_CHOWN_RESTRICTED___1 = 6,
    _PC_NO_TRUNC___1 = 7,
    _PC_VDISABLE___1 = 8,
    _PC_SYNC_IO___1 = 9,
    _PC_ASYNC_IO___1 = 10,
    _PC_PRIO_IO___1 = 11,
    _PC_SOCK_MAXBUF___1 = 12,
    _PC_FILESIZEBITS___1 = 13,
    _PC_REC_INCR_XFER_SIZE___1 = 14,
    _PC_REC_MAX_XFER_SIZE___1 = 15,
    _PC_REC_MIN_XFER_SIZE___1 = 16,
    _PC_REC_XFER_ALIGN___1 = 17,
    _PC_ALLOC_SIZE_MIN___1 = 18,
    _PC_SYMLINK_MAX___1 = 19,
    _PC_2_SYMLINKS___1 = 20
} ;
#line 71
enum __anonenum__131 {
    _SC_ARG_MAX___1 = 0,
    _SC_CHILD_MAX___1 = 1,
    _SC_CLK_TCK___1 = 2,
    _SC_NGROUPS_MAX___1 = 3,
    _SC_OPEN_MAX___1 = 4,
    _SC_STREAM_MAX___1 = 5,
    _SC_TZNAME_MAX___1 = 6,
    _SC_JOB_CONTROL___1 = 7,
    _SC_SAVED_IDS___1 = 8,
    _SC_REALTIME_SIGNALS___1 = 9,
    _SC_PRIORITY_SCHEDULING___1 = 10,
    _SC_TIMERS___1 = 11,
    _SC_ASYNCHRONOUS_IO___1 = 12,
    _SC_PRIORITIZED_IO___1 = 13,
    _SC_SYNCHRONIZED_IO___1 = 14,
    _SC_FSYNC___1 = 15,
    _SC_MAPPED_FILES___1 = 16,
    _SC_MEMLOCK___1 = 17,
    _SC_MEMLOCK_RANGE___1 = 18,
    _SC_MEMORY_PROTECTION___1 = 19,
    _SC_MESSAGE_PASSING___1 = 20,
    _SC_SEMAPHORES___1 = 21,
    _SC_SHARED_MEMORY_OBJECTS___1 = 22,
    _SC_AIO_LISTIO_MAX___1 = 23,
    _SC_AIO_MAX___1 = 24,
    _SC_AIO_PRIO_DELTA_MAX___1 = 25,
    _SC_DELAYTIMER_MAX___1 = 26,
    _SC_MQ_OPEN_MAX___1 = 27,
    _SC_MQ_PRIO_MAX___1 = 28,
    _SC_VERSION___1 = 29,
    _SC_PAGESIZE___1 = 30,
    _SC_RTSIG_MAX___1 = 31,
    _SC_SEM_NSEMS_MAX___1 = 32,
    _SC_SEM_VALUE_MAX___1 = 33,
    _SC_SIGQUEUE_MAX___1 = 34,
    _SC_TIMER_MAX___1 = 35,
    _SC_BC_BASE_MAX___1 = 36,
    _SC_BC_DIM_MAX___1 = 37,
    _SC_BC_SCALE_MAX___1 = 38,
    _SC_BC_STRING_MAX___1 = 39,
    _SC_COLL_WEIGHTS_MAX___1 = 40,
    _SC_EQUIV_CLASS_MAX___1 = 41,
    _SC_EXPR_NEST_MAX___1 = 42,
    _SC_LINE_MAX___1 = 43,
    _SC_RE_DUP_MAX___1 = 44,
    _SC_CHARCLASS_NAME_MAX___1 = 45,
    _SC_2_VERSION___1 = 46,
    _SC_2_C_BIND___1 = 47,
    _SC_2_C_DEV___1 = 48,
    _SC_2_FORT_DEV___1 = 49,
    _SC_2_FORT_RUN___1 = 50,
    _SC_2_SW_DEV___1 = 51,
    _SC_2_LOCALEDEF___1 = 52,
    _SC_PII___1 = 53,
    _SC_PII_XTI___1 = 54,
    _SC_PII_SOCKET___1 = 55,
    _SC_PII_INTERNET___1 = 56,
    _SC_PII_OSI___1 = 57,
    _SC_POLL___1 = 58,
    _SC_SELECT___1 = 59,
    _SC_UIO_MAXIOV___1 = 60,
    _SC_IOV_MAX___1 = 60,
    _SC_PII_INTERNET_STREAM___1 = 61,
    _SC_PII_INTERNET_DGRAM___1 = 62,
    _SC_PII_OSI_COTS___1 = 63,
    _SC_PII_OSI_CLTS___1 = 64,
    _SC_PII_OSI_M___1 = 65,
    _SC_T_IOV_MAX___1 = 66,
    _SC_THREADS___1 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___1 = 68,
    _SC_GETGR_R_SIZE_MAX___1 = 69,
    _SC_GETPW_R_SIZE_MAX___1 = 70,
    _SC_LOGIN_NAME_MAX___1 = 71,
    _SC_TTY_NAME_MAX___1 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___1 = 73,
    _SC_THREAD_KEYS_MAX___1 = 74,
    _SC_THREAD_STACK_MIN___1 = 75,
    _SC_THREAD_THREADS_MAX___1 = 76,
    _SC_THREAD_ATTR_STACKADDR___1 = 77,
    _SC_THREAD_ATTR_STACKSIZE___1 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___1 = 79,
    _SC_THREAD_PRIO_INHERIT___1 = 80,
    _SC_THREAD_PRIO_PROTECT___1 = 81,
    _SC_THREAD_PROCESS_SHARED___1 = 82,
    _SC_NPROCESSORS_CONF___1 = 83,
    _SC_NPROCESSORS_ONLN___1 = 84,
    _SC_PHYS_PAGES___1 = 85,
    _SC_AVPHYS_PAGES___1 = 86,
    _SC_ATEXIT_MAX___1 = 87,
    _SC_PASS_MAX___1 = 88,
    _SC_XOPEN_VERSION___1 = 89,
    _SC_XOPEN_XCU_VERSION___1 = 90,
    _SC_XOPEN_UNIX___1 = 91,
    _SC_XOPEN_CRYPT___1 = 92,
    _SC_XOPEN_ENH_I18N___1 = 93,
    _SC_XOPEN_SHM___1 = 94,
    _SC_2_CHAR_TERM___1 = 95,
    _SC_2_C_VERSION___1 = 96,
    _SC_2_UPE___1 = 97,
    _SC_XOPEN_XPG2___1 = 98,
    _SC_XOPEN_XPG3___1 = 99,
    _SC_XOPEN_XPG4___1 = 100,
    _SC_CHAR_BIT___1 = 101,
    _SC_CHAR_MAX___1 = 102,
    _SC_CHAR_MIN___1 = 103,
    _SC_INT_MAX___1 = 104,
    _SC_INT_MIN___1 = 105,
    _SC_LONG_BIT___1 = 106,
    _SC_WORD_BIT___1 = 107,
    _SC_MB_LEN_MAX___1 = 108,
    _SC_NZERO___1 = 109,
    _SC_SSIZE_MAX___1 = 110,
    _SC_SCHAR_MAX___1 = 111,
    _SC_SCHAR_MIN___1 = 112,
    _SC_SHRT_MAX___1 = 113,
    _SC_SHRT_MIN___1 = 114,
    _SC_UCHAR_MAX___1 = 115,
    _SC_UINT_MAX___1 = 116,
    _SC_ULONG_MAX___1 = 117,
    _SC_USHRT_MAX___1 = 118,
    _SC_NL_ARGMAX___1 = 119,
    _SC_NL_LANGMAX___1 = 120,
    _SC_NL_MSGMAX___1 = 121,
    _SC_NL_NMAX___1 = 122,
    _SC_NL_SETMAX___1 = 123,
    _SC_NL_TEXTMAX___1 = 124,
    _SC_XBS5_ILP32_OFF32___1 = 125,
    _SC_XBS5_ILP32_OFFBIG___1 = 126,
    _SC_XBS5_LP64_OFF64___1 = 127,
    _SC_XBS5_LPBIG_OFFBIG___1 = 128,
    _SC_XOPEN_LEGACY___1 = 129,
    _SC_XOPEN_REALTIME___1 = 130,
    _SC_XOPEN_REALTIME_THREADS___1 = 131,
    _SC_ADVISORY_INFO___1 = 132,
    _SC_BARRIERS___1 = 133,
    _SC_BASE___1 = 134,
    _SC_C_LANG_SUPPORT___1 = 135,
    _SC_C_LANG_SUPPORT_R___1 = 136,
    _SC_CLOCK_SELECTION___1 = 137,
    _SC_CPUTIME___1 = 138,
    _SC_THREAD_CPUTIME___1 = 139,
    _SC_DEVICE_IO___1 = 140,
    _SC_DEVICE_SPECIFIC___1 = 141,
    _SC_DEVICE_SPECIFIC_R___1 = 142,
    _SC_FD_MGMT___1 = 143,
    _SC_FIFO___1 = 144,
    _SC_PIPE___1 = 145,
    _SC_FILE_ATTRIBUTES___1 = 146,
    _SC_FILE_LOCKING___1 = 147,
    _SC_FILE_SYSTEM___1 = 148,
    _SC_MONOTONIC_CLOCK___1 = 149,
    _SC_MULTI_PROCESS___1 = 150,
    _SC_SINGLE_PROCESS___1 = 151,
    _SC_NETWORKING___1 = 152,
    _SC_READER_WRITER_LOCKS___1 = 153,
    _SC_SPIN_LOCKS___1 = 154,
    _SC_REGEXP___1 = 155,
    _SC_REGEX_VERSION___1 = 156,
    _SC_SHELL___1 = 157,
    _SC_SIGNALS___1 = 158,
    _SC_SPAWN___1 = 159,
    _SC_SPORADIC_SERVER___1 = 160,
    _SC_THREAD_SPORADIC_SERVER___1 = 161,
    _SC_SYSTEM_DATABASE___1 = 162,
    _SC_SYSTEM_DATABASE_R___1 = 163,
    _SC_TIMEOUTS___1 = 164,
    _SC_TYPED_MEMORY_OBJECTS___1 = 165,
    _SC_USER_GROUPS___1 = 166,
    _SC_USER_GROUPS_R___1 = 167,
    _SC_2_PBS___1 = 168,
    _SC_2_PBS_ACCOUNTING___1 = 169,
    _SC_2_PBS_LOCATE___1 = 170,
    _SC_2_PBS_MESSAGE___1 = 171,
    _SC_2_PBS_TRACK___1 = 172,
    _SC_SYMLOOP_MAX___1 = 173,
    _SC_STREAMS___1 = 174,
    _SC_2_PBS_CHECKPOINT___1 = 175,
    _SC_V6_ILP32_OFF32___1 = 176,
    _SC_V6_ILP32_OFFBIG___1 = 177,
    _SC_V6_LP64_OFF64___1 = 178,
    _SC_V6_LPBIG_OFFBIG___1 = 179,
    _SC_HOST_NAME_MAX___1 = 180,
    _SC_TRACE___1 = 181,
    _SC_TRACE_EVENT_FILTER___1 = 182,
    _SC_TRACE_INHERIT___1 = 183,
    _SC_TRACE_LOG___1 = 184,
    _SC_LEVEL1_ICACHE_SIZE___1 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___1 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___1 = 187,
    _SC_LEVEL1_DCACHE_SIZE___1 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___1 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___1 = 190,
    _SC_LEVEL2_CACHE_SIZE___1 = 191,
    _SC_LEVEL2_CACHE_ASSOC___1 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___1 = 193,
    _SC_LEVEL3_CACHE_SIZE___1 = 194,
    _SC_LEVEL3_CACHE_ASSOC___1 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___1 = 196,
    _SC_LEVEL4_CACHE_SIZE___1 = 197,
    _SC_LEVEL4_CACHE_ASSOC___1 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___1 = 199,
    _SC_IPV6___1 = 235,
    _SC_RAW_SOCKETS___1 = 236,
    _SC_V7_ILP32_OFF32___1 = 237,
    _SC_V7_ILP32_OFFBIG___1 = 238,
    _SC_V7_LP64_OFF64___1 = 239,
    _SC_V7_LPBIG_OFFBIG___1 = 240,
    _SC_SS_REPL_MAX___1 = 241,
    _SC_TRACE_EVENT_NAME_MAX___1 = 242,
    _SC_TRACE_NAME_MAX___1 = 243,
    _SC_TRACE_SYS_MAX___1 = 244,
    _SC_TRACE_USER_EVENT_MAX___1 = 245,
    _SC_XOPEN_STREAMS___1 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___1 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___1 = 248,
    _SC_MINSIGSTKSZ___1 = 249,
    _SC_SIGSTKSZ___1 = 250
} ;
#line 539
enum __anonenum__132 {
    _CS_PATH___1 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___1 = 1,
    _CS_GNU_LIBC_VERSION___1 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___1 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___1 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___1 = 5,
    _CS_LFS_CFLAGS___1 = 1000,
    _CS_LFS_LDFLAGS___1 = 1001,
    _CS_LFS_LIBS___1 = 1002,
    _CS_LFS_LINTFLAGS___1 = 1003,
    _CS_LFS64_CFLAGS___1 = 1004,
    _CS_LFS64_LDFLAGS___1 = 1005,
    _CS_LFS64_LIBS___1 = 1006,
    _CS_LFS64_LINTFLAGS___1 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___1 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___1 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___1 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___1 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___1 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___1 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___1 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___1 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___1 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___1 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___1 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___1 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___1 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___1 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___1 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___1 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___1 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___1 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___1 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___1 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___1 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___1 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___1 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___1 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___1 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___1 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___1 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___1 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___1 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___1 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___1 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___1 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___1 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___1 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___1 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___1 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___1 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___1 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___1 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___1 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___1 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___1 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___1 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___1 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___1 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___1 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___1 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___1 = 1147,
    _CS_V6_ENV___1 = 1148,
    _CS_V7_ENV___1 = 1149
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 97 "/usr/include/dirent.h"
enum __anonenum__133 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 127
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/ctype.h"
enum __anonenum__136 {
    _ISupper___0 = 256,
    _ISlower___0 = 512,
    _ISalpha___0 = 1024,
    _ISdigit___0 = 2048,
    _ISxdigit___0 = 4096,
    _ISspace___0 = 8192,
    _ISprint___0 = 16384,
    _ISgraph___0 = 32768,
    _ISblank___0 = 1,
    _IScntrl___0 = 2,
    _ISpunct___0 = 4,
    _ISalnum___0 = 8
} ;
#line 77 "/usr/include/SDL/SDL_ttf.h"
struct _TTF_Font ;
#line 77 "/usr/include/SDL/SDL_ttf.h"
typedef struct _TTF_Font TTF_Font;
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.h"
struct tp_ftw_str {
   char *str ;
   unsigned char len ;
};
#line 45 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.h"
typedef struct tp_ftw_str tp_ftw_str;
#line 41 "/usr/include/SDL_Pango.h"
struct _contextImpl ;
#line 41 "/usr/include/SDL_Pango.h"
typedef struct _contextImpl SDLPango_Context;
#line 46 "/usr/include/SDL_Pango.h"
struct _SDLPango_Matrix {
   Uint8 m[4][4] ;
};
#line 48 "/usr/include/SDL_Pango.h"
typedef struct _SDLPango_Matrix SDLPango_Matrix;
#line 75
enum __anonenum__153 {
    SDLPANGO_DIRECTION_LTR = 0,
    SDLPANGO_DIRECTION_RTL = 1,
    SDLPANGO_DIRECTION_WEAK_LTR = 2,
    SDLPANGO_DIRECTION_WEAK_RTL = 3,
    SDLPANGO_DIRECTION_NEUTRAL = 4
} ;
#line 81 "/usr/include/SDL_Pango.h"
typedef enum __anonenum__153 SDLPango_Direction;
#line 86
enum __anonenum__154 {
    SDLPANGO_ALIGN_LEFT = 0,
    SDLPANGO_ALIGN_CENTER = 1,
    SDLPANGO_ALIGN_RIGHT = 2
} ;
#line 90 "/usr/include/SDL_Pango.h"
typedef enum __anonenum__154 SDLPango_Alignment;
#line 94 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
enum __anonenum__155 {
    FONT_TYPE_PANGO = 0,
    FONT_TYPE_TTF = 1
} ;
#line 102 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
struct TuxPaint_Font_s {
   SDLPango_Context *pango_context ;
   int typ ;
   TTF_Font *ttf_font ;
   int height ;
   char *desc ;
};
#line 111 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
typedef struct TuxPaint_Font_s TuxPaint_Font;
#line 150 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
struct style_info {
   char *filename ;
   char *directory ;
   char *family ;
   char *style ;
   int italic ;
   int boldness ;
   int score ;
   int truetype ;
};
#line 160 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
typedef struct style_info style_info;
#line 163 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
struct family_info {
   char *directory ;
   char *family ;
   char *filename[4] ;
   TuxPaint_Font *handle ;
   int score ;
};
#line 170 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
typedef struct family_info family_info;
#line 46 "/usr/include/ctype.h"
enum __anonenum__176 {
    _ISupper___1 = 256,
    _ISlower___1 = 512,
    _ISalpha___1 = 1024,
    _ISdigit___1 = 2048,
    _ISxdigit___1 = 4096,
    _ISspace___1 = 8192,
    _ISprint___1 = 16384,
    _ISgraph___1 = 32768,
    _ISblank___1 = 1,
    _IScntrl___1 = 2,
    _ISpunct___1 = 4,
    _ISalnum___1 = 8
} ;
#line 251 "/usr/include/math.h"
enum __anonenum__193 {
    FP_INT_UPWARD___0 = 0,
    FP_INT_DOWNWARD___0 = 1,
    FP_INT_TOWARDZERO___0 = 2,
    FP_INT_TONEARESTFROMZERO___0 = 3,
    FP_INT_TONEAREST___0 = 4
} ;
#line 934
enum __anonenum__194 {
    FP_NAN___0 = 0,
    FP_INFINITE___0 = 1,
    FP_ZERO___0 = 2,
    FP_SUBNORMAL___0 = 3,
    FP_NORMAL___0 = 4
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__213 {
    _ISupper___2 = 256,
    _ISlower___2 = 512,
    _ISalpha___2 = 1024,
    _ISdigit___2 = 2048,
    _ISxdigit___2 = 4096,
    _ISspace___2 = 8192,
    _ISprint___2 = 16384,
    _ISgraph___2 = 32768,
    _ISblank___2 = 1,
    _IScntrl___2 = 2,
    _ISpunct___2 = 4,
    _ISalnum___2 = 8
} ;
#line 67 "/usr/include/SDL/SDL_mixer.h"
enum __anonenum__230 {
    MIX_INIT_FLAC = 1,
    MIX_INIT_MOD = 2,
    MIX_INIT_MP3 = 4,
    MIX_INIT_OGG = 8,
    MIX_INIT_FLUIDSYNTH = 16
} ;
#line 74 "/usr/include/SDL/SDL_mixer.h"
typedef enum __anonenum__230 MIX_InitFlags;
#line 102 "/usr/include/SDL/SDL_mixer.h"
struct Mix_Chunk {
   int allocated ;
   Uint8 *abuf ;
   Uint32 alen ;
   Uint8 volume ;
};
#line 107 "/usr/include/SDL/SDL_mixer.h"
typedef struct Mix_Chunk Mix_Chunk;
#line 110
enum __anonenum__231 {
    MIX_NO_FADING = 0,
    MIX_FADING_OUT = 1,
    MIX_FADING_IN = 2
} ;
#line 114 "/usr/include/SDL/SDL_mixer.h"
typedef enum __anonenum__231 Mix_Fading;
#line 116
enum __anonenum__232 {
    MUS_NONE = 0,
    MUS_CMD = 1,
    MUS_WAV = 2,
    MUS_MOD = 3,
    MUS_MID = 4,
    MUS_OGG = 5,
    MUS_MP3 = 6,
    MUS_MP3_MAD = 7,
    MUS_FLAC = 8,
    MUS_MODPLUG = 9
} ;
#line 127 "/usr/include/SDL/SDL_mixer.h"
typedef enum __anonenum__232 Mix_MusicType;
#line 130
struct _Mix_Music ;
#line 130 "/usr/include/SDL/SDL_mixer.h"
typedef struct _Mix_Music Mix_Music;
#line 252 "/usr/include/SDL/SDL_mixer.h"
typedef void (*Mix_EffectFunc_t)(int  , void * , int  , void * );
#line 263 "/usr/include/SDL/SDL_mixer.h"
typedef void (*Mix_EffectDone_t)(int  , void * );
#line 38 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.h"
enum __anonenum__233 {
    SND_HARP___0 = 0,
    SND_CLICK___0 = 1,
    SND_BLEEP___0 = 2,
    SND_BUBBLE___0 = 3,
    SND_STAMP___0 = 4,
    SND_LINE_START___0 = 5,
    SND_LINE_END___0 = 6,
    SND_SCROLL___0 = 7,
    SND_PAINT1___0 = 8,
    SND_PAINT2___0 = 9,
    SND_PAINT3___0 = 10,
    SND_PAINT4___0 = 11,
    SND_ERASER1___0 = 12,
    SND_ERASER2___0 = 13,
    SND_SAVE___0 = 14,
    SND_PROMPT___0 = 15,
    SND_FLIP___0 = 16,
    SND_MIRROR___0 = 17,
    SND_KEYCLICK___0 = 18,
    SND_KEYCLICKRING___0 = 19,
    SND_RETURN___0 = 20,
    SND_SHRINK___0 = 21,
    SND_GROW___0 = 22,
    SND_ITALIC_ON___0 = 23,
    SND_ITALIC_OFF___0 = 24,
    SND_AREYOUSURE___0 = 25,
    SND_YOUCANNOT___0 = 26,
    SND_TUXOK___0 = 27,
    SND_THICK___0 = 28,
    SND_THIN___0 = 29,
    SND_FILL___0 = 30,
    NUM_SOUNDS___0 = 31
} ;
#line 67 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
struct queue_s {
   int x ;
   int y ;
   int y_outside ;
};
#line 69 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
typedef struct queue_s queue_t;
#line 46 "/usr/include/ctype.h"
enum __anonenum__254 {
    _ISupper___3 = 256,
    _ISlower___3 = 512,
    _ISalpha___3 = 1024,
    _ISdigit___3 = 2048,
    _ISxdigit___3 = 4096,
    _ISspace___3 = 8192,
    _ISprint___3 = 16384,
    _ISgraph___3 = 32768,
    _ISblank___3 = 1,
    _IScntrl___3 = 2,
    _ISpunct___3 = 4,
    _ISalnum___3 = 8
} ;
#line 8 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/obj/../src/parse.h"
struct cfginfo {
   char const   *all_locale_fonts ;
   char const   *alt_print_command_default ;
   char const   *altprintcommand ;
   char const   *autosave_on_quit ;
   char const   *colorfile ;
   char const   *datadir ;
   char const   *disable_label ;
   char const   *disable_magic_controls ;
   char const   *disable_shape_controls ;
   char const   *disable_print ;
   char const   *disable_quit ;
   char const   *disable_save ;
   char const   *disable_screensaver ;
   char const   *disable_stamp_controls ;
   char const   *dont_do_xor ;
   char const   *dont_load_stamps ;
   char const   *exportdir ;
   char const   *fullscreen ;
   char const   *grab_input ;
   char const   *hide_cursor ;
   char const   *keymouse ;
   char const   *mirrorstamps ;
   char const   *native_screensize ;
   char const   *new_colors_last ;
   char const   *no_button_distinction ;
   char const   *no_fancy_cursors ;
   char const   *no_system_fonts ;
   char const   *noshortcuts ;
   char const   *ok_to_use_lockfile ;
   char const   *only_uppercase ;
   char const   *papersize ;
   char const   *parsertmp_fullscreen_native ;
   char const   *parsertmp_lang ;
   char const   *parsertmp_locale ;
   char const   *parsertmp_sysconfig ;
   char const   *parsertmp_windowsize ;
   char const   *button_size ;
   char const   *colors_rows ;
   char const   *print_delay ;
   char const   *printcommand ;
   char const   *_promptless_save_over ;
   char const   *_promptless_save_over_new ;
   char const   *_promptless_save_over_ask ;
   char const   *rotate_orientation ;
   char const   *savedir ;
   char const   *simple_shapes ;
   char const   *stamp_size_override ;
   char const   *start_blank ;
   char const   *use_print_config ;
   char const   *use_sound ;
   char const   *use_stereo ;
   char const   *wheely ;
   char const   *mouseaccessibility ;
   char const   *onscreen_keyboard ;
   char const   *onscreen_keyboard_layout ;
   char const   *onscreen_keyboard_disable_change ;
   char const   *joystick_dev ;
   char const   *joystick_slowness ;
   char const   *joystick_lowthreshold ;
   char const   *joystick_maxsteps ;
   char const   *joystick_hat_slowness ;
   char const   *joystick_hat_timeout ;
   char const   *joystick_button_escape ;
   char const   *joystick_button_selectbrushtool ;
   char const   *joystick_button_selectstamptool ;
   char const   *joystick_button_selectlinestool ;
   char const   *joystick_button_selectshapestool ;
   char const   *joystick_button_selecttexttool ;
   char const   *joystick_button_selectlabeltool ;
   char const   *joystick_button_selectmagictool ;
   char const   *joystick_button_undo ;
   char const   *joystick_button_redo ;
   char const   *joystick_button_selecterasertool ;
   char const   *joystick_button_new ;
   char const   *joystick_button_open ;
   char const   *joystick_button_save ;
   char const   *joystick_button_pagesetup ;
   char const   *joystick_button_print ;
   char const   *joystick_buttons_ignore ;
};
#line 22 "src/parse.gperf"
struct cfg {
   char const   *name ;
   void (*val)(void) ;
};
#line 46 "/usr/include/ctype.h"
enum __anonenum__273 {
    _ISupper___4 = 256,
    _ISlower___4 = 512,
    _ISalpha___4 = 1024,
    _ISdigit___4 = 2048,
    _ISxdigit___4 = 4096,
    _ISspace___4 = 8192,
    _ISprint___4 = 16384,
    _ISgraph___4 = 32768,
    _ISblank___4 = 1,
    _IScntrl___4 = 2,
    _ISpunct___4 = 4,
    _ISalnum___4 = 8
} ;
#line 94 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
enum __anonenum__292 {
    FONT_TYPE_PANGO___0 = 0,
    FONT_TYPE_TTF___0 = 1
} ;
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
enum __anonenum__293 {
    LANG_ACH = 0,
    LANG_AF = 1,
    LANG_AK = 2,
    LANG_AM = 3,
    LANG_AN = 4,
    LANG_AR = 5,
    LANG_AS = 6,
    LANG_AST = 7,
    LANG_AZ = 8,
    LANG_BE = 9,
    LANG_BG = 10,
    LANG_BM = 11,
    LANG_BN = 12,
    LANG_BO = 13,
    LANG_BR = 14,
    LANG_BRX = 15,
    LANG_BS = 16,
    LANG_CA_VALENCIA = 17,
    LANG_CA = 18,
    LANG_CGG = 19,
    LANG_CS = 20,
    LANG_CY = 21,
    LANG_DA = 22,
    LANG_DE = 23,
    LANG_DOI = 24,
    LANG_EL = 25,
    LANG_EN = 26,
    LANG_EN_AU = 27,
    LANG_EN_CA = 28,
    LANG_EN_GB = 29,
    LANG_EN_ZA = 30,
    LANG_EO = 31,
    LANG_ES_MX = 32,
    LANG_ES = 33,
    LANG_ET = 34,
    LANG_EU = 35,
    LANG_FA = 36,
    LANG_FF = 37,
    LANG_FI = 38,
    LANG_FO = 39,
    LANG_FR = 40,
    LANG_GA = 41,
    LANG_GD = 42,
    LANG_GL = 43,
    LANG_GR = 44,
    LANG_GU = 45,
    LANG_HE = 46,
    LANG_HI = 47,
    LANG_HR = 48,
    LANG_HU = 49,
    LANG_HY = 50,
    LANG_I_KLINGON_ROMANIZED = 51,
    LANG_ID = 52,
    LANG_IS = 53,
    LANG_IT = 54,
    LANG_IU = 55,
    LANG_JA = 56,
    LANG_KA = 57,
    LANG_KAB = 58,
    LANG_KN = 59,
    LANG_KM = 60,
    LANG_KOK_ROMAN = 61,
    LANG_KOK = 62,
    LANG_KO = 63,
    LANG_KS_DEVANAGARI = 64,
    LANG_KS = 65,
    LANG_KU = 66,
    LANG_LB = 67,
    LANG_LG = 68,
    LANG_LT = 69,
    LANG_LV = 70,
    LANG_MAI = 71,
    LANG_ML = 72,
    LANG_MK = 73,
    LANG_MN = 74,
    LANG_MNI_BENGALI = 75,
    LANG_MNI_METEI_MAYEK = 76,
    LANG_MR = 77,
    LANG_MS = 78,
    LANG_NB = 79,
    LANG_NE = 80,
    LANG_NL = 81,
    LANG_NN = 82,
    LANG_NR = 83,
    LANG_NSO = 84,
    LANG_OC = 85,
    LANG_OJ = 86,
    LANG_OR = 87,
    LANG_PA = 88,
    LANG_PL = 89,
    LANG_PT_BR = 90,
    LANG_PT = 91,
    LANG_RO = 92,
    LANG_RU = 93,
    LANG_RW = 94,
    LANG_SAT_OL_CHIKI = 95,
    LANG_SAT = 96,
    LANG_SA = 97,
    LANG_SC = 98,
    LANG_SD = 99,
    LANG_SD_DEVANAGARI = 100,
    LANG_SHS = 101,
    LANG_SI = 102,
    LANG_SK = 103,
    LANG_SL = 104,
    LANG_SON = 105,
    LANG_SQ = 106,
    LANG_SR_LATIN = 107,
    LANG_SR = 108,
    LANG_SU = 109,
    LANG_SV = 110,
    LANG_SW = 111,
    LANG_TA = 112,
    LANG_TE = 113,
    LANG_TH = 114,
    LANG_TL = 115,
    LANG_TR = 116,
    LANG_TW = 117,
    LANG_UK = 118,
    LANG_UR = 119,
    LANG_VEC = 120,
    LANG_VE = 121,
    LANG_VI = 122,
    LANG_WA = 123,
    LANG_WO = 124,
    LANG_XH = 125,
    LANG_ZAM = 126,
    LANG_ZH_CN = 127,
    LANG_ZH_TW = 128,
    LANG_ZU = 129,
    NUM_LANGS = 130
} ;
#line 178 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
struct language_to_locale_struct {
   char const   *language ;
   char const   *locale ;
};
#line 182 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
typedef struct language_to_locale_struct language_to_locale_struct;
#line 193 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
struct w_langs {
   int langint ;
   int need_own_font ;
   int need_right_to_left ;
   int need_right_to_left_word ;
   int lang_y_nudge ;
   char const   *lang_prefix ;
   char const   *short_lang_prefix ;
};
#line 202 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
typedef struct w_langs w_langs;
#line 32 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/get_fname.h"
enum __anonenum__294 {
    DIR_SAVE___0 = 0,
    DIR_DATA___0 = 1,
    DIR_EXPORT___0 = 2,
    DIR_EXPORT_PARENT___0 = 3
} ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h"
enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048
} ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 180 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 193 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[118] ;
   unsigned long __ss_align ;
};
#line 202
enum __anonenum__295 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_TRYHARD = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_BATCH = 262144,
    MSG_ZEROCOPY = 67108864,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824
} ;
#line 259 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 277 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 334
enum __anonenum__296 {
    SCM_RIGHTS = 1,
    SCM_CREDENTIALS = 2
} ;
#line 346 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 363 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h"
struct osockaddr {
   unsigned short sa_family ;
   unsigned char sa_data[14] ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/socket.h"
enum __anonenum__299 {
    SHUT_RD = 0,
    SHUT_WR = 1,
    SHUT_RDWR = 2
} ;
#line 79
struct sockaddr_at ;
#line 79
struct sockaddr_ax25 ;
#line 79
struct sockaddr_dl ;
#line 79
struct sockaddr_eon ;
#line 79
struct sockaddr_in ;
#line 79
struct sockaddr_in6 ;
#line 79
struct sockaddr_inarp ;
#line 79
struct sockaddr_ipx ;
#line 79
struct sockaddr_iso ;
#line 79
struct sockaddr_ns ;
#line 79
struct sockaddr_un ;
#line 79
struct sockaddr_x25 ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_300 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 80 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_300 __SOCKADDR_ARG;
#line 83 "/usr/include/x86_64-linux-gnu/sys/socket.h"
union __anonunion_301 {
   struct sockaddr *__sockaddr__ ;
   struct sockaddr_at *__sockaddr_at__ ;
   struct sockaddr_ax25 *__sockaddr_ax25__ ;
   struct sockaddr_dl *__sockaddr_dl__ ;
   struct sockaddr_eon *__sockaddr_eon__ ;
   struct sockaddr_in *__sockaddr_in__ ;
   struct sockaddr_in6 *__sockaddr_in6__ ;
   struct sockaddr_inarp *__sockaddr_inarp__ ;
   struct sockaddr_ipx *__sockaddr_ipx__ ;
   struct sockaddr_iso *__sockaddr_iso__ ;
   struct sockaddr_ns *__sockaddr_ns__ ;
   struct sockaddr_un *__sockaddr_un__ ;
   struct sockaddr_x25 *__sockaddr_x25__ ;
};
#line 84 "/usr/include/x86_64-linux-gnu/sys/socket.h"
typedef union __anonunion_301 __CONST_SOCKADDR_ARG;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct mmsghdr {
   struct msghdr msg_hdr ;
   unsigned int msg_len ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__302 {
    _PC_LINK_MAX___2 = 0,
    _PC_MAX_CANON___2 = 1,
    _PC_MAX_INPUT___2 = 2,
    _PC_NAME_MAX___2 = 3,
    _PC_PATH_MAX___2 = 4,
    _PC_PIPE_BUF___2 = 5,
    _PC_CHOWN_RESTRICTED___2 = 6,
    _PC_NO_TRUNC___2 = 7,
    _PC_VDISABLE___2 = 8,
    _PC_SYNC_IO___2 = 9,
    _PC_ASYNC_IO___2 = 10,
    _PC_PRIO_IO___2 = 11,
    _PC_SOCK_MAXBUF___2 = 12,
    _PC_FILESIZEBITS___2 = 13,
    _PC_REC_INCR_XFER_SIZE___2 = 14,
    _PC_REC_MAX_XFER_SIZE___2 = 15,
    _PC_REC_MIN_XFER_SIZE___2 = 16,
    _PC_REC_XFER_ALIGN___2 = 17,
    _PC_ALLOC_SIZE_MIN___2 = 18,
    _PC_SYMLINK_MAX___2 = 19,
    _PC_2_SYMLINKS___2 = 20
} ;
#line 71
enum __anonenum__303 {
    _SC_ARG_MAX___2 = 0,
    _SC_CHILD_MAX___2 = 1,
    _SC_CLK_TCK___2 = 2,
    _SC_NGROUPS_MAX___2 = 3,
    _SC_OPEN_MAX___2 = 4,
    _SC_STREAM_MAX___2 = 5,
    _SC_TZNAME_MAX___2 = 6,
    _SC_JOB_CONTROL___2 = 7,
    _SC_SAVED_IDS___2 = 8,
    _SC_REALTIME_SIGNALS___2 = 9,
    _SC_PRIORITY_SCHEDULING___2 = 10,
    _SC_TIMERS___2 = 11,
    _SC_ASYNCHRONOUS_IO___2 = 12,
    _SC_PRIORITIZED_IO___2 = 13,
    _SC_SYNCHRONIZED_IO___2 = 14,
    _SC_FSYNC___2 = 15,
    _SC_MAPPED_FILES___2 = 16,
    _SC_MEMLOCK___2 = 17,
    _SC_MEMLOCK_RANGE___2 = 18,
    _SC_MEMORY_PROTECTION___2 = 19,
    _SC_MESSAGE_PASSING___2 = 20,
    _SC_SEMAPHORES___2 = 21,
    _SC_SHARED_MEMORY_OBJECTS___2 = 22,
    _SC_AIO_LISTIO_MAX___2 = 23,
    _SC_AIO_MAX___2 = 24,
    _SC_AIO_PRIO_DELTA_MAX___2 = 25,
    _SC_DELAYTIMER_MAX___2 = 26,
    _SC_MQ_OPEN_MAX___2 = 27,
    _SC_MQ_PRIO_MAX___2 = 28,
    _SC_VERSION___2 = 29,
    _SC_PAGESIZE___2 = 30,
    _SC_RTSIG_MAX___2 = 31,
    _SC_SEM_NSEMS_MAX___2 = 32,
    _SC_SEM_VALUE_MAX___2 = 33,
    _SC_SIGQUEUE_MAX___2 = 34,
    _SC_TIMER_MAX___2 = 35,
    _SC_BC_BASE_MAX___2 = 36,
    _SC_BC_DIM_MAX___2 = 37,
    _SC_BC_SCALE_MAX___2 = 38,
    _SC_BC_STRING_MAX___2 = 39,
    _SC_COLL_WEIGHTS_MAX___2 = 40,
    _SC_EQUIV_CLASS_MAX___2 = 41,
    _SC_EXPR_NEST_MAX___2 = 42,
    _SC_LINE_MAX___2 = 43,
    _SC_RE_DUP_MAX___2 = 44,
    _SC_CHARCLASS_NAME_MAX___2 = 45,
    _SC_2_VERSION___2 = 46,
    _SC_2_C_BIND___2 = 47,
    _SC_2_C_DEV___2 = 48,
    _SC_2_FORT_DEV___2 = 49,
    _SC_2_FORT_RUN___2 = 50,
    _SC_2_SW_DEV___2 = 51,
    _SC_2_LOCALEDEF___2 = 52,
    _SC_PII___2 = 53,
    _SC_PII_XTI___2 = 54,
    _SC_PII_SOCKET___2 = 55,
    _SC_PII_INTERNET___2 = 56,
    _SC_PII_OSI___2 = 57,
    _SC_POLL___2 = 58,
    _SC_SELECT___2 = 59,
    _SC_UIO_MAXIOV___2 = 60,
    _SC_IOV_MAX___2 = 60,
    _SC_PII_INTERNET_STREAM___2 = 61,
    _SC_PII_INTERNET_DGRAM___2 = 62,
    _SC_PII_OSI_COTS___2 = 63,
    _SC_PII_OSI_CLTS___2 = 64,
    _SC_PII_OSI_M___2 = 65,
    _SC_T_IOV_MAX___2 = 66,
    _SC_THREADS___2 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___2 = 68,
    _SC_GETGR_R_SIZE_MAX___2 = 69,
    _SC_GETPW_R_SIZE_MAX___2 = 70,
    _SC_LOGIN_NAME_MAX___2 = 71,
    _SC_TTY_NAME_MAX___2 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___2 = 73,
    _SC_THREAD_KEYS_MAX___2 = 74,
    _SC_THREAD_STACK_MIN___2 = 75,
    _SC_THREAD_THREADS_MAX___2 = 76,
    _SC_THREAD_ATTR_STACKADDR___2 = 77,
    _SC_THREAD_ATTR_STACKSIZE___2 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___2 = 79,
    _SC_THREAD_PRIO_INHERIT___2 = 80,
    _SC_THREAD_PRIO_PROTECT___2 = 81,
    _SC_THREAD_PROCESS_SHARED___2 = 82,
    _SC_NPROCESSORS_CONF___2 = 83,
    _SC_NPROCESSORS_ONLN___2 = 84,
    _SC_PHYS_PAGES___2 = 85,
    _SC_AVPHYS_PAGES___2 = 86,
    _SC_ATEXIT_MAX___2 = 87,
    _SC_PASS_MAX___2 = 88,
    _SC_XOPEN_VERSION___2 = 89,
    _SC_XOPEN_XCU_VERSION___2 = 90,
    _SC_XOPEN_UNIX___2 = 91,
    _SC_XOPEN_CRYPT___2 = 92,
    _SC_XOPEN_ENH_I18N___2 = 93,
    _SC_XOPEN_SHM___2 = 94,
    _SC_2_CHAR_TERM___2 = 95,
    _SC_2_C_VERSION___2 = 96,
    _SC_2_UPE___2 = 97,
    _SC_XOPEN_XPG2___2 = 98,
    _SC_XOPEN_XPG3___2 = 99,
    _SC_XOPEN_XPG4___2 = 100,
    _SC_CHAR_BIT___2 = 101,
    _SC_CHAR_MAX___2 = 102,
    _SC_CHAR_MIN___2 = 103,
    _SC_INT_MAX___2 = 104,
    _SC_INT_MIN___2 = 105,
    _SC_LONG_BIT___2 = 106,
    _SC_WORD_BIT___2 = 107,
    _SC_MB_LEN_MAX___2 = 108,
    _SC_NZERO___2 = 109,
    _SC_SSIZE_MAX___2 = 110,
    _SC_SCHAR_MAX___2 = 111,
    _SC_SCHAR_MIN___2 = 112,
    _SC_SHRT_MAX___2 = 113,
    _SC_SHRT_MIN___2 = 114,
    _SC_UCHAR_MAX___2 = 115,
    _SC_UINT_MAX___2 = 116,
    _SC_ULONG_MAX___2 = 117,
    _SC_USHRT_MAX___2 = 118,
    _SC_NL_ARGMAX___2 = 119,
    _SC_NL_LANGMAX___2 = 120,
    _SC_NL_MSGMAX___2 = 121,
    _SC_NL_NMAX___2 = 122,
    _SC_NL_SETMAX___2 = 123,
    _SC_NL_TEXTMAX___2 = 124,
    _SC_XBS5_ILP32_OFF32___2 = 125,
    _SC_XBS5_ILP32_OFFBIG___2 = 126,
    _SC_XBS5_LP64_OFF64___2 = 127,
    _SC_XBS5_LPBIG_OFFBIG___2 = 128,
    _SC_XOPEN_LEGACY___2 = 129,
    _SC_XOPEN_REALTIME___2 = 130,
    _SC_XOPEN_REALTIME_THREADS___2 = 131,
    _SC_ADVISORY_INFO___2 = 132,
    _SC_BARRIERS___2 = 133,
    _SC_BASE___2 = 134,
    _SC_C_LANG_SUPPORT___2 = 135,
    _SC_C_LANG_SUPPORT_R___2 = 136,
    _SC_CLOCK_SELECTION___2 = 137,
    _SC_CPUTIME___2 = 138,
    _SC_THREAD_CPUTIME___2 = 139,
    _SC_DEVICE_IO___2 = 140,
    _SC_DEVICE_SPECIFIC___2 = 141,
    _SC_DEVICE_SPECIFIC_R___2 = 142,
    _SC_FD_MGMT___2 = 143,
    _SC_FIFO___2 = 144,
    _SC_PIPE___2 = 145,
    _SC_FILE_ATTRIBUTES___2 = 146,
    _SC_FILE_LOCKING___2 = 147,
    _SC_FILE_SYSTEM___2 = 148,
    _SC_MONOTONIC_CLOCK___2 = 149,
    _SC_MULTI_PROCESS___2 = 150,
    _SC_SINGLE_PROCESS___2 = 151,
    _SC_NETWORKING___2 = 152,
    _SC_READER_WRITER_LOCKS___2 = 153,
    _SC_SPIN_LOCKS___2 = 154,
    _SC_REGEXP___2 = 155,
    _SC_REGEX_VERSION___2 = 156,
    _SC_SHELL___2 = 157,
    _SC_SIGNALS___2 = 158,
    _SC_SPAWN___2 = 159,
    _SC_SPORADIC_SERVER___2 = 160,
    _SC_THREAD_SPORADIC_SERVER___2 = 161,
    _SC_SYSTEM_DATABASE___2 = 162,
    _SC_SYSTEM_DATABASE_R___2 = 163,
    _SC_TIMEOUTS___2 = 164,
    _SC_TYPED_MEMORY_OBJECTS___2 = 165,
    _SC_USER_GROUPS___2 = 166,
    _SC_USER_GROUPS_R___2 = 167,
    _SC_2_PBS___2 = 168,
    _SC_2_PBS_ACCOUNTING___2 = 169,
    _SC_2_PBS_LOCATE___2 = 170,
    _SC_2_PBS_MESSAGE___2 = 171,
    _SC_2_PBS_TRACK___2 = 172,
    _SC_SYMLOOP_MAX___2 = 173,
    _SC_STREAMS___2 = 174,
    _SC_2_PBS_CHECKPOINT___2 = 175,
    _SC_V6_ILP32_OFF32___2 = 176,
    _SC_V6_ILP32_OFFBIG___2 = 177,
    _SC_V6_LP64_OFF64___2 = 178,
    _SC_V6_LPBIG_OFFBIG___2 = 179,
    _SC_HOST_NAME_MAX___2 = 180,
    _SC_TRACE___2 = 181,
    _SC_TRACE_EVENT_FILTER___2 = 182,
    _SC_TRACE_INHERIT___2 = 183,
    _SC_TRACE_LOG___2 = 184,
    _SC_LEVEL1_ICACHE_SIZE___2 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___2 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___2 = 187,
    _SC_LEVEL1_DCACHE_SIZE___2 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___2 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___2 = 190,
    _SC_LEVEL2_CACHE_SIZE___2 = 191,
    _SC_LEVEL2_CACHE_ASSOC___2 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___2 = 193,
    _SC_LEVEL3_CACHE_SIZE___2 = 194,
    _SC_LEVEL3_CACHE_ASSOC___2 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___2 = 196,
    _SC_LEVEL4_CACHE_SIZE___2 = 197,
    _SC_LEVEL4_CACHE_ASSOC___2 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___2 = 199,
    _SC_IPV6___2 = 235,
    _SC_RAW_SOCKETS___2 = 236,
    _SC_V7_ILP32_OFF32___2 = 237,
    _SC_V7_ILP32_OFFBIG___2 = 238,
    _SC_V7_LP64_OFF64___2 = 239,
    _SC_V7_LPBIG_OFFBIG___2 = 240,
    _SC_SS_REPL_MAX___2 = 241,
    _SC_TRACE_EVENT_NAME_MAX___2 = 242,
    _SC_TRACE_NAME_MAX___2 = 243,
    _SC_TRACE_SYS_MAX___2 = 244,
    _SC_TRACE_USER_EVENT_MAX___2 = 245,
    _SC_XOPEN_STREAMS___2 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___2 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___2 = 248,
    _SC_MINSIGSTKSZ___2 = 249,
    _SC_SIGSTKSZ___2 = 250
} ;
#line 539
enum __anonenum__304 {
    _CS_PATH___2 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___2 = 1,
    _CS_GNU_LIBC_VERSION___2 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___2 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___2 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___2 = 5,
    _CS_LFS_CFLAGS___2 = 1000,
    _CS_LFS_LDFLAGS___2 = 1001,
    _CS_LFS_LIBS___2 = 1002,
    _CS_LFS_LINTFLAGS___2 = 1003,
    _CS_LFS64_CFLAGS___2 = 1004,
    _CS_LFS64_LDFLAGS___2 = 1005,
    _CS_LFS64_LIBS___2 = 1006,
    _CS_LFS64_LINTFLAGS___2 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___2 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___2 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___2 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___2 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___2 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___2 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___2 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___2 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___2 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___2 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___2 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___2 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___2 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___2 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___2 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___2 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___2 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___2 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___2 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___2 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___2 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___2 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___2 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___2 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___2 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___2 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___2 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___2 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___2 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___2 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___2 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___2 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___2 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___2 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___2 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___2 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___2 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___2 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___2 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___2 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___2 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___2 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___2 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___2 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___2 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___2 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___2 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___2 = 1147,
    _CS_V6_ENV___2 = 1148,
    _CS_V7_ENV___2 = 1149
} ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
enum __pid_type {
    F_OWNER_TID = 0,
    F_OWNER_PID = 1,
    F_OWNER_PGRP = 2,
    F_OWNER_GID = 2
} ;
#line 274 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct f_owner_ex {
   enum __pid_type type ;
   __pid_t pid ;
};
#line 358 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
struct file_handle {
   unsigned int handle_bytes ;
   int handle_type ;
   unsigned char f_handle[0] ;
};
#line 33 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__316 {
    SI_ASYNCNL___0 = -60,
    SI_DETHREAD___0 = -7,
    SI_TKILL___0 = -6,
    SI_SIGIO___0 = -5,
    SI_ASYNCIO___0 = -4,
    SI_MESGQ___0 = -3,
    SI_TIMER___0 = -2,
    SI_QUEUE___0 = -1,
    SI_USER___0 = 0,
    SI_KERNEL___0 = 128
} ;
#line 71
enum __anonenum__317 {
    ILL_ILLOPC___0 = 1,
    ILL_ILLOPN___0 = 2,
    ILL_ILLADR___0 = 3,
    ILL_ILLTRP___0 = 4,
    ILL_PRVOPC___0 = 5,
    ILL_PRVREG___0 = 6,
    ILL_COPROC___0 = 7,
    ILL_BADSTK___0 = 8,
    ILL_BADIADDR___0 = 9
} ;
#line 94
enum __anonenum__318 {
    FPE_INTDIV___0 = 1,
    FPE_INTOVF___0 = 2,
    FPE_FLTDIV___0 = 3,
    FPE_FLTOVF___0 = 4,
    FPE_FLTUND___0 = 5,
    FPE_FLTRES___0 = 6,
    FPE_FLTINV___0 = 7,
    FPE_FLTSUB___0 = 8,
    FPE_FLTUNK___0 = 14,
    FPE_CONDTRAP___0 = 15
} ;
#line 119
enum __anonenum__319 {
    SEGV_MAPERR___0 = 1,
    SEGV_ACCERR___0 = 2,
    SEGV_BNDERR___0 = 3,
    SEGV_PKUERR___0 = 4,
    SEGV_ACCADI___0 = 5,
    SEGV_ADIDERR___0 = 6,
    SEGV_ADIPERR___0 = 7,
    SEGV_MTEAERR___0 = 8,
    SEGV_MTESERR___0 = 9
} ;
#line 142
enum __anonenum__320 {
    BUS_ADRALN___0 = 1,
    BUS_ADRERR___0 = 2,
    BUS_OBJERR___0 = 3,
    BUS_MCEERR_AR___0 = 4,
    BUS_MCEERR_AO___0 = 5
} ;
#line 159
enum __anonenum__321 {
    TRAP_BRKPT___0 = 1,
    TRAP_TRACE___0 = 2,
    TRAP_BRANCH___0 = 3,
    TRAP_HWBKPT___0 = 4,
    TRAP_UNK___0 = 5
} ;
#line 176
enum __anonenum__322 {
    CLD_EXITED___0 = 1,
    CLD_KILLED___0 = 2,
    CLD_DUMPED___0 = 3,
    CLD_TRAPPED___0 = 4,
    CLD_STOPPED___0 = 5,
    CLD_CONTINUED___0 = 6
} ;
#line 193
enum __anonenum__323 {
    POLL_IN___0 = 1,
    POLL_OUT___0 = 2,
    POLL_MSG___0 = 3,
    POLL_ERR___0 = 4,
    POLL_PRI___0 = 5,
    POLL_HUP___0 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__326 {
    SIGEV_SIGNAL___0 = 0,
    SIGEV_NONE___0 = 1,
    SIGEV_THREAD___0 = 2,
    SIGEV_THREAD_ID___0 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__330 {
    REG_R8___0 = 0,
    REG_R9___0 = 1,
    REG_R10___0 = 2,
    REG_R11___0 = 3,
    REG_R12___0 = 4,
    REG_R13___0 = 5,
    REG_R14___0 = 6,
    REG_R15___0 = 7,
    REG_RDI___0 = 8,
    REG_RSI___0 = 9,
    REG_RBP___0 = 10,
    REG_RBX___0 = 11,
    REG_RDX___0 = 12,
    REG_RAX___0 = 13,
    REG_RCX___0 = 14,
    REG_RSP___0 = 15,
    REG_RIP___0 = 16,
    REG_EFL___0 = 17,
    REG_CSGSFS___0 = 18,
    REG_ERR___0 = 19,
    REG_TRAPNO___0 = 20,
    REG_OLDMASK___0 = 21,
    REG_CR2___0 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__332 {
    SS_ONSTACK___0 = 1,
    SS_DISABLE___0 = 2
} ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h"
struct sched_param {
   int sched_priority ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_334 {
   __cpu_mask __bits[16] ;
};
#line 42 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_334 cpu_set_t;
#line 134 "/usr/include/linux/prctl.h"
struct prctl_mm_map {
   __u64 start_code ;
   __u64 end_code ;
   __u64 start_data ;
   __u64 end_data ;
   __u64 start_brk ;
   __u64 brk ;
   __u64 start_stack ;
   __u64 arg_start ;
   __u64 arg_end ;
   __u64 env_start ;
   __u64 env_end ;
   __u64 *auxv ;
   __u32 auxv_size ;
   __u32 exe_fd ;
};
#line 46 "/usr/include/ctype.h"
enum __anonenum__176___0 {
    _ISupper___5 = 256,
    _ISlower___5 = 512,
    _ISalpha___5 = 1024,
    _ISdigit___5 = 2048,
    _ISxdigit___5 = 4096,
    _ISspace___5 = 8192,
    _ISprint___5 = 16384,
    _ISgraph___5 = 32768,
    _ISblank___5 = 1,
    _IScntrl___5 = 2,
    _ISpunct___5 = 4,
    _ISalnum___5 = 8
} ;
#line 38 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.h"
enum __anonenum__338 {
    SND_HARP___1 = 0,
    SND_CLICK___1 = 1,
    SND_BLEEP___1 = 2,
    SND_BUBBLE___1 = 3,
    SND_STAMP___1 = 4,
    SND_LINE_START___1 = 5,
    SND_LINE_END___1 = 6,
    SND_SCROLL___1 = 7,
    SND_PAINT1___1 = 8,
    SND_PAINT2___1 = 9,
    SND_PAINT3___1 = 10,
    SND_PAINT4___1 = 11,
    SND_ERASER1___1 = 12,
    SND_ERASER2___1 = 13,
    SND_SAVE___1 = 14,
    SND_PROMPT___1 = 15,
    SND_FLIP___1 = 16,
    SND_MIRROR___1 = 17,
    SND_KEYCLICK___1 = 18,
    SND_KEYCLICKRING___1 = 19,
    SND_RETURN___1 = 20,
    SND_SHRINK___1 = 21,
    SND_GROW___1 = 22,
    SND_ITALIC_ON___1 = 23,
    SND_ITALIC_OFF___1 = 24,
    SND_AREYOUSURE___1 = 25,
    SND_YOUCANNOT___1 = 26,
    SND_TUXOK___1 = 27,
    SND_THICK___1 = 28,
    SND_THIN___1 = 29,
    SND_FILL___1 = 30,
    NUM_SOUNDS___1 = 31
} ;
#line 46 "/usr/include/ctype.h"
enum __anonenum__176___1 {
    _ISupper___6 = 256,
    _ISlower___6 = 512,
    _ISalpha___6 = 1024,
    _ISdigit___6 = 2048,
    _ISxdigit___6 = 4096,
    _ISspace___6 = 8192,
    _ISprint___6 = 16384,
    _ISgraph___6 = 32768,
    _ISblank___6 = 1,
    _IScntrl___6 = 2,
    _ISpunct___6 = 4,
    _ISalnum___6 = 8
} ;
#line 46
enum __anonenum__176___2 {
    _ISupper___7 = 256,
    _ISlower___7 = 512,
    _ISalpha___7 = 1024,
    _ISdigit___7 = 2048,
    _ISxdigit___7 = 4096,
    _ISspace___7 = 8192,
    _ISprint___7 = 16384,
    _ISgraph___7 = 32768,
    _ISblank___7 = 1,
    _IScntrl___7 = 2,
    _ISpunct___7 = 4,
    _ISalnum___7 = 8
} ;
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
enum __anonenum__339 {
    LANG_ACH___0 = 0,
    LANG_AF___0 = 1,
    LANG_AK___0 = 2,
    LANG_AM___0 = 3,
    LANG_AN___0 = 4,
    LANG_AR___0 = 5,
    LANG_AS___0 = 6,
    LANG_AST___0 = 7,
    LANG_AZ___0 = 8,
    LANG_BE___0 = 9,
    LANG_BG___0 = 10,
    LANG_BM___0 = 11,
    LANG_BN___0 = 12,
    LANG_BO___0 = 13,
    LANG_BR___0 = 14,
    LANG_BRX___0 = 15,
    LANG_BS___0 = 16,
    LANG_CA_VALENCIA___0 = 17,
    LANG_CA___0 = 18,
    LANG_CGG___0 = 19,
    LANG_CS___0 = 20,
    LANG_CY___0 = 21,
    LANG_DA___0 = 22,
    LANG_DE___0 = 23,
    LANG_DOI___0 = 24,
    LANG_EL___0 = 25,
    LANG_EN___0 = 26,
    LANG_EN_AU___0 = 27,
    LANG_EN_CA___0 = 28,
    LANG_EN_GB___0 = 29,
    LANG_EN_ZA___0 = 30,
    LANG_EO___0 = 31,
    LANG_ES_MX___0 = 32,
    LANG_ES___0 = 33,
    LANG_ET___0 = 34,
    LANG_EU___0 = 35,
    LANG_FA___0 = 36,
    LANG_FF___0 = 37,
    LANG_FI___0 = 38,
    LANG_FO___0 = 39,
    LANG_FR___0 = 40,
    LANG_GA___0 = 41,
    LANG_GD___0 = 42,
    LANG_GL___0 = 43,
    LANG_GR___0 = 44,
    LANG_GU___0 = 45,
    LANG_HE___0 = 46,
    LANG_HI___0 = 47,
    LANG_HR___0 = 48,
    LANG_HU___0 = 49,
    LANG_HY___0 = 50,
    LANG_I_KLINGON_ROMANIZED___0 = 51,
    LANG_ID___0 = 52,
    LANG_IS___0 = 53,
    LANG_IT___0 = 54,
    LANG_IU___0 = 55,
    LANG_JA___0 = 56,
    LANG_KA___0 = 57,
    LANG_KAB___0 = 58,
    LANG_KN___0 = 59,
    LANG_KM___0 = 60,
    LANG_KOK_ROMAN___0 = 61,
    LANG_KOK___0 = 62,
    LANG_KO___0 = 63,
    LANG_KS_DEVANAGARI___0 = 64,
    LANG_KS___0 = 65,
    LANG_KU___0 = 66,
    LANG_LB___0 = 67,
    LANG_LG___0 = 68,
    LANG_LT___0 = 69,
    LANG_LV___0 = 70,
    LANG_MAI___0 = 71,
    LANG_ML___0 = 72,
    LANG_MK___0 = 73,
    LANG_MN___0 = 74,
    LANG_MNI_BENGALI___0 = 75,
    LANG_MNI_METEI_MAYEK___0 = 76,
    LANG_MR___0 = 77,
    LANG_MS___0 = 78,
    LANG_NB___0 = 79,
    LANG_NE___0 = 80,
    LANG_NL___0 = 81,
    LANG_NN___0 = 82,
    LANG_NR___0 = 83,
    LANG_NSO___0 = 84,
    LANG_OC___0 = 85,
    LANG_OJ___0 = 86,
    LANG_OR___0 = 87,
    LANG_PA___0 = 88,
    LANG_PL___0 = 89,
    LANG_PT_BR___0 = 90,
    LANG_PT___0 = 91,
    LANG_RO___0 = 92,
    LANG_RU___0 = 93,
    LANG_RW___0 = 94,
    LANG_SAT_OL_CHIKI___0 = 95,
    LANG_SAT___0 = 96,
    LANG_SA___0 = 97,
    LANG_SC___0 = 98,
    LANG_SD___0 = 99,
    LANG_SD_DEVANAGARI___0 = 100,
    LANG_SHS___0 = 101,
    LANG_SI___0 = 102,
    LANG_SK___0 = 103,
    LANG_SL___0 = 104,
    LANG_SON___0 = 105,
    LANG_SQ___0 = 106,
    LANG_SR_LATIN___0 = 107,
    LANG_SR___0 = 108,
    LANG_SU___0 = 109,
    LANG_SV___0 = 110,
    LANG_SW___0 = 111,
    LANG_TA___0 = 112,
    LANG_TE___0 = 113,
    LANG_TH___0 = 114,
    LANG_TL___0 = 115,
    LANG_TR___0 = 116,
    LANG_TW___0 = 117,
    LANG_UK___0 = 118,
    LANG_UR___0 = 119,
    LANG_VEC___0 = 120,
    LANG_VE___0 = 121,
    LANG_VI___0 = 122,
    LANG_WA___0 = 123,
    LANG_WO___0 = 124,
    LANG_XH___0 = 125,
    LANG_ZAM___0 = 126,
    LANG_ZH_CN___0 = 127,
    LANG_ZH_TW___0 = 128,
    LANG_ZU___0 = 129,
    NUM_LANGS___0 = 130
} ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
typedef unsigned long wctype_t;
#line 56
enum __anonenum__340 {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = 16777216,
    _ISwlower = 33554432,
    _ISwalpha = 67108864,
    _ISwdigit = 134217728,
    _ISwxdigit = 268435456,
    _ISwspace = 536870912,
    _ISwprint = 1073741824,
    _ISwgraph = (-0x7FFFFFFF-1),
    _ISwblank = 65536,
    _ISwcntrl = 131072,
    _ISwpunct = 262144,
    _ISwalnum = 524288
} ;
#line 48 "/usr/include/wctype.h"
typedef __int32_t *wctrans_t;
#line 119 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct scaleparams {
   unsigned int numer ;
   unsigned int denom ;
};
#line 122 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct scaleparams scaleparams;
#line 46 "/usr/include/ctype.h"
enum __anonenum__360 {
    _ISupper___8 = 256,
    _ISlower___8 = 512,
    _ISalpha___8 = 1024,
    _ISdigit___8 = 2048,
    _ISxdigit___8 = 4096,
    _ISspace___8 = 8192,
    _ISprint___8 = 16384,
    _ISgraph___8 = 32768,
    _ISblank___8 = 1,
    _IScntrl___8 = 2,
    _ISpunct___8 = 4,
    _ISalnum___8 = 8
} ;
#line 28 "/usr/include/wordexp.h"
enum __anonenum__361 {
    WRDE_DOOFFS = 1,
    WRDE_APPEND = 2,
    WRDE_NOCMD = 4,
    WRDE_REUSE = 8,
    WRDE_SHOWERR = 16,
    WRDE_UNDEF = 32,
    __WRDE_FLAGS = 63
} ;
#line 41 "/usr/include/wordexp.h"
struct __anonstruct_362 {
   size_t we_wordc ;
   char **we_wordv ;
   size_t we_offs ;
};
#line 46 "/usr/include/wordexp.h"
typedef struct __anonstruct_362 wordexp_t;
#line 49
enum __anonenum__363 {
    WRDE_NOSYS = -1,
    WRDE_NOSPACE = 1,
    WRDE_BADCHAR = 2,
    WRDE_BADVAL = 3,
    WRDE_CMDSUB = 4,
    WRDE_SYNTAX = 5
} ;
#line 251 "/usr/include/math.h"
enum __anonenum__364 {
    FP_INT_UPWARD___1 = 0,
    FP_INT_DOWNWARD___1 = 1,
    FP_INT_TOWARDZERO___1 = 2,
    FP_INT_TONEARESTFROMZERO___1 = 3,
    FP_INT_TONEAREST___1 = 4
} ;
#line 934
enum __anonenum__365 {
    FP_NAN___1 = 0,
    FP_INFINITE___1 = 1,
    FP_ZERO___1 = 2,
    FP_SUBNORMAL___1 = 3,
    FP_NORMAL___1 = 4
} ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
enum __anonenum__366 {
    __ISwupper___0 = 0,
    __ISwlower___0 = 1,
    __ISwalpha___0 = 2,
    __ISwdigit___0 = 3,
    __ISwxdigit___0 = 4,
    __ISwspace___0 = 5,
    __ISwprint___0 = 6,
    __ISwgraph___0 = 7,
    __ISwblank___0 = 8,
    __ISwcntrl___0 = 9,
    __ISwpunct___0 = 10,
    __ISwalnum___0 = 11,
    _ISwupper___0 = 16777216,
    _ISwlower___0 = 33554432,
    _ISwalpha___0 = 67108864,
    _ISwdigit___0 = 134217728,
    _ISwxdigit___0 = 268435456,
    _ISwspace___0 = 536870912,
    _ISwprint___0 = 1073741824,
    _ISwgraph___0 = (-0x7FFFFFFF-1),
    _ISwblank___0 = 65536,
    _ISwcntrl___0 = 131072,
    _ISwpunct___0 = 262144,
    _ISwalnum___0 = 524288
} ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/confname.h"
enum __anonenum__369 {
    _PC_LINK_MAX___3 = 0,
    _PC_MAX_CANON___3 = 1,
    _PC_MAX_INPUT___3 = 2,
    _PC_NAME_MAX___3 = 3,
    _PC_PATH_MAX___3 = 4,
    _PC_PIPE_BUF___3 = 5,
    _PC_CHOWN_RESTRICTED___3 = 6,
    _PC_NO_TRUNC___3 = 7,
    _PC_VDISABLE___3 = 8,
    _PC_SYNC_IO___3 = 9,
    _PC_ASYNC_IO___3 = 10,
    _PC_PRIO_IO___3 = 11,
    _PC_SOCK_MAXBUF___3 = 12,
    _PC_FILESIZEBITS___3 = 13,
    _PC_REC_INCR_XFER_SIZE___3 = 14,
    _PC_REC_MAX_XFER_SIZE___3 = 15,
    _PC_REC_MIN_XFER_SIZE___3 = 16,
    _PC_REC_XFER_ALIGN___3 = 17,
    _PC_ALLOC_SIZE_MIN___3 = 18,
    _PC_SYMLINK_MAX___3 = 19,
    _PC_2_SYMLINKS___3 = 20
} ;
#line 71
enum __anonenum__370 {
    _SC_ARG_MAX___3 = 0,
    _SC_CHILD_MAX___3 = 1,
    _SC_CLK_TCK___3 = 2,
    _SC_NGROUPS_MAX___3 = 3,
    _SC_OPEN_MAX___3 = 4,
    _SC_STREAM_MAX___3 = 5,
    _SC_TZNAME_MAX___3 = 6,
    _SC_JOB_CONTROL___3 = 7,
    _SC_SAVED_IDS___3 = 8,
    _SC_REALTIME_SIGNALS___3 = 9,
    _SC_PRIORITY_SCHEDULING___3 = 10,
    _SC_TIMERS___3 = 11,
    _SC_ASYNCHRONOUS_IO___3 = 12,
    _SC_PRIORITIZED_IO___3 = 13,
    _SC_SYNCHRONIZED_IO___3 = 14,
    _SC_FSYNC___3 = 15,
    _SC_MAPPED_FILES___3 = 16,
    _SC_MEMLOCK___3 = 17,
    _SC_MEMLOCK_RANGE___3 = 18,
    _SC_MEMORY_PROTECTION___3 = 19,
    _SC_MESSAGE_PASSING___3 = 20,
    _SC_SEMAPHORES___3 = 21,
    _SC_SHARED_MEMORY_OBJECTS___3 = 22,
    _SC_AIO_LISTIO_MAX___3 = 23,
    _SC_AIO_MAX___3 = 24,
    _SC_AIO_PRIO_DELTA_MAX___3 = 25,
    _SC_DELAYTIMER_MAX___3 = 26,
    _SC_MQ_OPEN_MAX___3 = 27,
    _SC_MQ_PRIO_MAX___3 = 28,
    _SC_VERSION___3 = 29,
    _SC_PAGESIZE___3 = 30,
    _SC_RTSIG_MAX___3 = 31,
    _SC_SEM_NSEMS_MAX___3 = 32,
    _SC_SEM_VALUE_MAX___3 = 33,
    _SC_SIGQUEUE_MAX___3 = 34,
    _SC_TIMER_MAX___3 = 35,
    _SC_BC_BASE_MAX___3 = 36,
    _SC_BC_DIM_MAX___3 = 37,
    _SC_BC_SCALE_MAX___3 = 38,
    _SC_BC_STRING_MAX___3 = 39,
    _SC_COLL_WEIGHTS_MAX___3 = 40,
    _SC_EQUIV_CLASS_MAX___3 = 41,
    _SC_EXPR_NEST_MAX___3 = 42,
    _SC_LINE_MAX___3 = 43,
    _SC_RE_DUP_MAX___3 = 44,
    _SC_CHARCLASS_NAME_MAX___3 = 45,
    _SC_2_VERSION___3 = 46,
    _SC_2_C_BIND___3 = 47,
    _SC_2_C_DEV___3 = 48,
    _SC_2_FORT_DEV___3 = 49,
    _SC_2_FORT_RUN___3 = 50,
    _SC_2_SW_DEV___3 = 51,
    _SC_2_LOCALEDEF___3 = 52,
    _SC_PII___3 = 53,
    _SC_PII_XTI___3 = 54,
    _SC_PII_SOCKET___3 = 55,
    _SC_PII_INTERNET___3 = 56,
    _SC_PII_OSI___3 = 57,
    _SC_POLL___3 = 58,
    _SC_SELECT___3 = 59,
    _SC_UIO_MAXIOV___3 = 60,
    _SC_IOV_MAX___3 = 60,
    _SC_PII_INTERNET_STREAM___3 = 61,
    _SC_PII_INTERNET_DGRAM___3 = 62,
    _SC_PII_OSI_COTS___3 = 63,
    _SC_PII_OSI_CLTS___3 = 64,
    _SC_PII_OSI_M___3 = 65,
    _SC_T_IOV_MAX___3 = 66,
    _SC_THREADS___3 = 67,
    _SC_THREAD_SAFE_FUNCTIONS___3 = 68,
    _SC_GETGR_R_SIZE_MAX___3 = 69,
    _SC_GETPW_R_SIZE_MAX___3 = 70,
    _SC_LOGIN_NAME_MAX___3 = 71,
    _SC_TTY_NAME_MAX___3 = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS___3 = 73,
    _SC_THREAD_KEYS_MAX___3 = 74,
    _SC_THREAD_STACK_MIN___3 = 75,
    _SC_THREAD_THREADS_MAX___3 = 76,
    _SC_THREAD_ATTR_STACKADDR___3 = 77,
    _SC_THREAD_ATTR_STACKSIZE___3 = 78,
    _SC_THREAD_PRIORITY_SCHEDULING___3 = 79,
    _SC_THREAD_PRIO_INHERIT___3 = 80,
    _SC_THREAD_PRIO_PROTECT___3 = 81,
    _SC_THREAD_PROCESS_SHARED___3 = 82,
    _SC_NPROCESSORS_CONF___3 = 83,
    _SC_NPROCESSORS_ONLN___3 = 84,
    _SC_PHYS_PAGES___3 = 85,
    _SC_AVPHYS_PAGES___3 = 86,
    _SC_ATEXIT_MAX___3 = 87,
    _SC_PASS_MAX___3 = 88,
    _SC_XOPEN_VERSION___3 = 89,
    _SC_XOPEN_XCU_VERSION___3 = 90,
    _SC_XOPEN_UNIX___3 = 91,
    _SC_XOPEN_CRYPT___3 = 92,
    _SC_XOPEN_ENH_I18N___3 = 93,
    _SC_XOPEN_SHM___3 = 94,
    _SC_2_CHAR_TERM___3 = 95,
    _SC_2_C_VERSION___3 = 96,
    _SC_2_UPE___3 = 97,
    _SC_XOPEN_XPG2___3 = 98,
    _SC_XOPEN_XPG3___3 = 99,
    _SC_XOPEN_XPG4___3 = 100,
    _SC_CHAR_BIT___3 = 101,
    _SC_CHAR_MAX___3 = 102,
    _SC_CHAR_MIN___3 = 103,
    _SC_INT_MAX___3 = 104,
    _SC_INT_MIN___3 = 105,
    _SC_LONG_BIT___3 = 106,
    _SC_WORD_BIT___3 = 107,
    _SC_MB_LEN_MAX___3 = 108,
    _SC_NZERO___3 = 109,
    _SC_SSIZE_MAX___3 = 110,
    _SC_SCHAR_MAX___3 = 111,
    _SC_SCHAR_MIN___3 = 112,
    _SC_SHRT_MAX___3 = 113,
    _SC_SHRT_MIN___3 = 114,
    _SC_UCHAR_MAX___3 = 115,
    _SC_UINT_MAX___3 = 116,
    _SC_ULONG_MAX___3 = 117,
    _SC_USHRT_MAX___3 = 118,
    _SC_NL_ARGMAX___3 = 119,
    _SC_NL_LANGMAX___3 = 120,
    _SC_NL_MSGMAX___3 = 121,
    _SC_NL_NMAX___3 = 122,
    _SC_NL_SETMAX___3 = 123,
    _SC_NL_TEXTMAX___3 = 124,
    _SC_XBS5_ILP32_OFF32___3 = 125,
    _SC_XBS5_ILP32_OFFBIG___3 = 126,
    _SC_XBS5_LP64_OFF64___3 = 127,
    _SC_XBS5_LPBIG_OFFBIG___3 = 128,
    _SC_XOPEN_LEGACY___3 = 129,
    _SC_XOPEN_REALTIME___3 = 130,
    _SC_XOPEN_REALTIME_THREADS___3 = 131,
    _SC_ADVISORY_INFO___3 = 132,
    _SC_BARRIERS___3 = 133,
    _SC_BASE___3 = 134,
    _SC_C_LANG_SUPPORT___3 = 135,
    _SC_C_LANG_SUPPORT_R___3 = 136,
    _SC_CLOCK_SELECTION___3 = 137,
    _SC_CPUTIME___3 = 138,
    _SC_THREAD_CPUTIME___3 = 139,
    _SC_DEVICE_IO___3 = 140,
    _SC_DEVICE_SPECIFIC___3 = 141,
    _SC_DEVICE_SPECIFIC_R___3 = 142,
    _SC_FD_MGMT___3 = 143,
    _SC_FIFO___3 = 144,
    _SC_PIPE___3 = 145,
    _SC_FILE_ATTRIBUTES___3 = 146,
    _SC_FILE_LOCKING___3 = 147,
    _SC_FILE_SYSTEM___3 = 148,
    _SC_MONOTONIC_CLOCK___3 = 149,
    _SC_MULTI_PROCESS___3 = 150,
    _SC_SINGLE_PROCESS___3 = 151,
    _SC_NETWORKING___3 = 152,
    _SC_READER_WRITER_LOCKS___3 = 153,
    _SC_SPIN_LOCKS___3 = 154,
    _SC_REGEXP___3 = 155,
    _SC_REGEX_VERSION___3 = 156,
    _SC_SHELL___3 = 157,
    _SC_SIGNALS___3 = 158,
    _SC_SPAWN___3 = 159,
    _SC_SPORADIC_SERVER___3 = 160,
    _SC_THREAD_SPORADIC_SERVER___3 = 161,
    _SC_SYSTEM_DATABASE___3 = 162,
    _SC_SYSTEM_DATABASE_R___3 = 163,
    _SC_TIMEOUTS___3 = 164,
    _SC_TYPED_MEMORY_OBJECTS___3 = 165,
    _SC_USER_GROUPS___3 = 166,
    _SC_USER_GROUPS_R___3 = 167,
    _SC_2_PBS___3 = 168,
    _SC_2_PBS_ACCOUNTING___3 = 169,
    _SC_2_PBS_LOCATE___3 = 170,
    _SC_2_PBS_MESSAGE___3 = 171,
    _SC_2_PBS_TRACK___3 = 172,
    _SC_SYMLOOP_MAX___3 = 173,
    _SC_STREAMS___3 = 174,
    _SC_2_PBS_CHECKPOINT___3 = 175,
    _SC_V6_ILP32_OFF32___3 = 176,
    _SC_V6_ILP32_OFFBIG___3 = 177,
    _SC_V6_LP64_OFF64___3 = 178,
    _SC_V6_LPBIG_OFFBIG___3 = 179,
    _SC_HOST_NAME_MAX___3 = 180,
    _SC_TRACE___3 = 181,
    _SC_TRACE_EVENT_FILTER___3 = 182,
    _SC_TRACE_INHERIT___3 = 183,
    _SC_TRACE_LOG___3 = 184,
    _SC_LEVEL1_ICACHE_SIZE___3 = 185,
    _SC_LEVEL1_ICACHE_ASSOC___3 = 186,
    _SC_LEVEL1_ICACHE_LINESIZE___3 = 187,
    _SC_LEVEL1_DCACHE_SIZE___3 = 188,
    _SC_LEVEL1_DCACHE_ASSOC___3 = 189,
    _SC_LEVEL1_DCACHE_LINESIZE___3 = 190,
    _SC_LEVEL2_CACHE_SIZE___3 = 191,
    _SC_LEVEL2_CACHE_ASSOC___3 = 192,
    _SC_LEVEL2_CACHE_LINESIZE___3 = 193,
    _SC_LEVEL3_CACHE_SIZE___3 = 194,
    _SC_LEVEL3_CACHE_ASSOC___3 = 195,
    _SC_LEVEL3_CACHE_LINESIZE___3 = 196,
    _SC_LEVEL4_CACHE_SIZE___3 = 197,
    _SC_LEVEL4_CACHE_ASSOC___3 = 198,
    _SC_LEVEL4_CACHE_LINESIZE___3 = 199,
    _SC_IPV6___3 = 235,
    _SC_RAW_SOCKETS___3 = 236,
    _SC_V7_ILP32_OFF32___3 = 237,
    _SC_V7_ILP32_OFFBIG___3 = 238,
    _SC_V7_LP64_OFF64___3 = 239,
    _SC_V7_LPBIG_OFFBIG___3 = 240,
    _SC_SS_REPL_MAX___3 = 241,
    _SC_TRACE_EVENT_NAME_MAX___3 = 242,
    _SC_TRACE_NAME_MAX___3 = 243,
    _SC_TRACE_SYS_MAX___3 = 244,
    _SC_TRACE_USER_EVENT_MAX___3 = 245,
    _SC_XOPEN_STREAMS___3 = 246,
    _SC_THREAD_ROBUST_PRIO_INHERIT___3 = 247,
    _SC_THREAD_ROBUST_PRIO_PROTECT___3 = 248,
    _SC_MINSIGSTKSZ___3 = 249,
    _SC_SIGSTKSZ___3 = 250
} ;
#line 539
enum __anonenum__371 {
    _CS_PATH___3 = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS___3 = 1,
    _CS_GNU_LIBC_VERSION___3 = 2,
    _CS_GNU_LIBPTHREAD_VERSION___3 = 3,
    _CS_V5_WIDTH_RESTRICTED_ENVS___3 = 4,
    _CS_V7_WIDTH_RESTRICTED_ENVS___3 = 5,
    _CS_LFS_CFLAGS___3 = 1000,
    _CS_LFS_LDFLAGS___3 = 1001,
    _CS_LFS_LIBS___3 = 1002,
    _CS_LFS_LINTFLAGS___3 = 1003,
    _CS_LFS64_CFLAGS___3 = 1004,
    _CS_LFS64_LDFLAGS___3 = 1005,
    _CS_LFS64_LIBS___3 = 1006,
    _CS_LFS64_LINTFLAGS___3 = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS___3 = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS___3 = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS___3 = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS___3 = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS___3 = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS___3 = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS___3 = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS___3 = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS___3 = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS___3 = 1109,
    _CS_XBS5_LP64_OFF64_LIBS___3 = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS___3 = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS___3 = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS___3 = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS___3 = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS___3 = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS___3 = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS___3 = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS___3 = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS___3 = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS___3 = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS___3 = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS___3 = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS___3 = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS___3 = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS___3 = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS___3 = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS___3 = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS___3 = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS___3 = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS___3 = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS___3 = 1131,
    _CS_POSIX_V7_ILP32_OFF32_CFLAGS___3 = 1132,
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS___3 = 1133,
    _CS_POSIX_V7_ILP32_OFF32_LIBS___3 = 1134,
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS___3 = 1135,
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS___3 = 1136,
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS___3 = 1137,
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS___3 = 1138,
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS___3 = 1139,
    _CS_POSIX_V7_LP64_OFF64_CFLAGS___3 = 1140,
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS___3 = 1141,
    _CS_POSIX_V7_LP64_OFF64_LIBS___3 = 1142,
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS___3 = 1143,
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS___3 = 1144,
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS___3 = 1145,
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS___3 = 1146,
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS___3 = 1147,
    _CS_V6_ENV___3 = 1148,
    _CS_V7_ENV___3 = 1149
} ;
#line 97 "/usr/include/dirent.h"
enum __anonenum__372 {
    DT_UNKNOWN___0 = 0,
    DT_FIFO___0 = 1,
    DT_CHR___0 = 2,
    DT_DIR___0 = 4,
    DT_BLK___0 = 6,
    DT_REG___0 = 8,
    DT_LNK___0 = 10,
    DT_SOCK___0 = 12,
    DT_WHT___0 = 14
} ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h"
enum __anonenum__384 {
    SI_ASYNCNL___1 = -60,
    SI_DETHREAD___1 = -7,
    SI_TKILL___1 = -6,
    SI_SIGIO___1 = -5,
    SI_ASYNCIO___1 = -4,
    SI_MESGQ___1 = -3,
    SI_TIMER___1 = -2,
    SI_QUEUE___1 = -1,
    SI_USER___1 = 0,
    SI_KERNEL___1 = 128
} ;
#line 71
enum __anonenum__385 {
    ILL_ILLOPC___1 = 1,
    ILL_ILLOPN___1 = 2,
    ILL_ILLADR___1 = 3,
    ILL_ILLTRP___1 = 4,
    ILL_PRVOPC___1 = 5,
    ILL_PRVREG___1 = 6,
    ILL_COPROC___1 = 7,
    ILL_BADSTK___1 = 8,
    ILL_BADIADDR___1 = 9
} ;
#line 94
enum __anonenum__386 {
    FPE_INTDIV___1 = 1,
    FPE_INTOVF___1 = 2,
    FPE_FLTDIV___1 = 3,
    FPE_FLTOVF___1 = 4,
    FPE_FLTUND___1 = 5,
    FPE_FLTRES___1 = 6,
    FPE_FLTINV___1 = 7,
    FPE_FLTSUB___1 = 8,
    FPE_FLTUNK___1 = 14,
    FPE_CONDTRAP___1 = 15
} ;
#line 119
enum __anonenum__387 {
    SEGV_MAPERR___1 = 1,
    SEGV_ACCERR___1 = 2,
    SEGV_BNDERR___1 = 3,
    SEGV_PKUERR___1 = 4,
    SEGV_ACCADI___1 = 5,
    SEGV_ADIDERR___1 = 6,
    SEGV_ADIPERR___1 = 7,
    SEGV_MTEAERR___1 = 8,
    SEGV_MTESERR___1 = 9
} ;
#line 142
enum __anonenum__388 {
    BUS_ADRALN___1 = 1,
    BUS_ADRERR___1 = 2,
    BUS_OBJERR___1 = 3,
    BUS_MCEERR_AR___1 = 4,
    BUS_MCEERR_AO___1 = 5
} ;
#line 159
enum __anonenum__389 {
    TRAP_BRKPT___1 = 1,
    TRAP_TRACE___1 = 2,
    TRAP_BRANCH___1 = 3,
    TRAP_HWBKPT___1 = 4,
    TRAP_UNK___1 = 5
} ;
#line 176
enum __anonenum__390 {
    CLD_EXITED___1 = 1,
    CLD_KILLED___1 = 2,
    CLD_DUMPED___1 = 3,
    CLD_TRAPPED___1 = 4,
    CLD_STOPPED___1 = 5,
    CLD_CONTINUED___1 = 6
} ;
#line 193
enum __anonenum__391 {
    POLL_IN___1 = 1,
    POLL_OUT___1 = 2,
    POLL_MSG___1 = 3,
    POLL_ERR___1 = 4,
    POLL_PRI___1 = 5,
    POLL_HUP___1 = 6
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h"
enum __anonenum__394 {
    SIGEV_SIGNAL___1 = 0,
    SIGEV_NONE___1 = 1,
    SIGEV_THREAD___1 = 2,
    SIGEV_THREAD_ID___1 = 4
} ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/ucontext.h"
enum __anonenum__398 {
    REG_R8___1 = 0,
    REG_R9___1 = 1,
    REG_R10___1 = 2,
    REG_R11___1 = 3,
    REG_R12___1 = 4,
    REG_R13___1 = 5,
    REG_R14___1 = 6,
    REG_R15___1 = 7,
    REG_RDI___1 = 8,
    REG_RSI___1 = 9,
    REG_RBP___1 = 10,
    REG_RBX___1 = 11,
    REG_RDX___1 = 12,
    REG_RAX___1 = 13,
    REG_RCX___1 = 14,
    REG_RSP___1 = 15,
    REG_RIP___1 = 16,
    REG_EFL___1 = 17,
    REG_CSGSFS___1 = 18,
    REG_ERR___1 = 19,
    REG_TRAPNO___1 = 20,
    REG_OLDMASK___1 = 21,
    REG_CR2___1 = 22
} ;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h"
enum __anonenum__400 {
    SS_ONSTACK___1 = 1,
    SS_DISABLE___1 = 2
} ;
#line 58 "/usr/include/SDL/SDL_image.h"
enum __anonenum__420 {
    IMG_INIT_JPG = 1,
    IMG_INIT_PNG = 2,
    IMG_INIT_TIF = 4,
    IMG_INIT_WEBP = 8
} ;
#line 64 "/usr/include/SDL/SDL_image.h"
typedef enum __anonenum__420 IMG_InitFlags;
#line 77 "/usr/include/SDL/SDL_gfxBlitFunc.h"
struct __anonstruct_421 {
   Uint8 *s_pixels ;
   int s_width ;
   int s_height ;
   int s_skip ;
   Uint8 *d_pixels ;
   int d_width ;
   int d_height ;
   int d_skip ;
   void *aux_data ;
   SDL_PixelFormat *src ;
   Uint8 *table ;
   SDL_PixelFormat *dst ;
};
#line 90 "/usr/include/SDL/SDL_gfxBlitFunc.h"
typedef struct __anonstruct_421 SDL_gfxBlitInfo;
#line 42 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
#line 43 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned char guint8;
#line 45 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef short gint16;
#line 46 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned short guint16;
#line 53 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int gint32;
#line 54 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned int guint32;
#line 63 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gint64;
#line 64 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guint64;
#line 79 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gssize;
#line 80 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long gsize;
#line 90 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef gint64 goffset;
#line 106 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef long gintptr;
#line 107 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef unsigned long guintptr;
#line 199 "/usr/lib/x86_64-linux-gnu/glib-2.0/include/glibconfig.h"
typedef int GPid;
#line 46 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
#line 47 "/usr/include/glib-2.0/glib/gtypes.h"
typedef short gshort;
#line 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef long glong;
#line 49 "/usr/include/glib-2.0/glib/gtypes.h"
typedef int gint;
#line 50 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gboolean;
#line 52 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned char guchar;
#line 53 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned short gushort;
#line 54 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned long gulong;
#line 55 "/usr/include/glib-2.0/glib/gtypes.h"
typedef unsigned int guint;
#line 57 "/usr/include/glib-2.0/glib/gtypes.h"
typedef float gfloat;
#line 58 "/usr/include/glib-2.0/glib/gtypes.h"
typedef double gdouble;
#line 103 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void *gpointer;
#line 104 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void const   *gconstpointer;
#line 106 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareFunc)(gconstpointer  , gconstpointer  );
#line 108 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint (*GCompareDataFunc)(gconstpointer  , gconstpointer  , gpointer  );
#line 111 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gboolean (*GEqualFunc)(gconstpointer  , gconstpointer  );
#line 113 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GDestroyNotify)(gpointer  );
#line 114 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFunc)(gpointer  , gpointer  );
#line 116 "/usr/include/glib-2.0/glib/gtypes.h"
typedef guint (*GHashFunc)(gconstpointer  );
#line 117 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GHFunc)(gpointer  , gpointer  , gpointer  );
#line 133 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gpointer (*GCopyFunc)(gconstpointer  , gpointer  );
#line 143 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFreeFunc)(gpointer  );
#line 157 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gchar *(*GTranslateFunc)(gchar * , gpointer  );
#line 501
union _GDoubleIEEE754 ;
#line 501 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
#line 502
union _GFloatIEEE754 ;
#line 502 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GFloatIEEE754 GFloatIEEE754;
#line 511 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_427 {
   guint mantissa ;
   guint biased_exponent ;
   guint sign ;
};
#line 508 "/usr/include/glib-2.0/glib/gtypes.h"
union _GFloatIEEE754 {
   gfloat v_float ;
   struct __anonstruct_427 mpn ;
};
#line 520 "/usr/include/glib-2.0/glib/gtypes.h"
struct __anonstruct_428 {
   guint mantissa_low ;
   guint mantissa_high ;
   guint biased_exponent ;
   guint sign ;
};
#line 517 "/usr/include/glib-2.0/glib/gtypes.h"
union _GDoubleIEEE754 {
   gdouble v_double ;
   struct __anonstruct_428 mpn ;
};
#line 551
struct _GTimeVal ;
#line 551 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;
#line 553 "/usr/include/glib-2.0/glib/gtypes.h"
struct _GTimeVal {
   glong tv_sec ;
   glong tv_usec ;
};
#line 559 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint grefcount;
#line 560 "/usr/include/glib-2.0/glib/gtypes.h"
typedef gint gatomicrefcount;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
struct _GBytes ;
#line 36 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GBytes GBytes;
#line 37
struct _GArray ;
#line 37 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GArray GArray;
#line 38
struct _GByteArray ;
#line 38 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GByteArray GByteArray;
#line 39
struct _GPtrArray ;
#line 39 "/usr/include/glib-2.0/glib/garray.h"
typedef struct _GPtrArray GPtrArray;
#line 41 "/usr/include/glib-2.0/glib/garray.h"
struct _GArray {
   gchar *data ;
   guint len ;
};
#line 47 "/usr/include/glib-2.0/glib/garray.h"
struct _GByteArray {
   guint8 *data ;
   guint len ;
};
#line 53 "/usr/include/glib-2.0/glib/garray.h"
struct _GPtrArray {
   gpointer *pdata ;
   guint len ;
};
#line 36 "/usr/include/glib-2.0/glib/gquark.h"
typedef guint32 GQuark;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError ;
#line 41 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;
#line 43 "/usr/include/glib-2.0/glib/gerror.h"
struct _GError {
   GQuark domain ;
   gint code ;
   gchar *message ;
};
#line 140 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorInitFunc)(GError * );
#line 158 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorCopyFunc)(GError * , GError * );
#line 173 "/usr/include/glib-2.0/glib/gerror.h"
typedef void (*GErrorClearFunc)(GError * );
#line 252 "/usr/include/glib-2.0/glib/gutils.h"
enum __anonenum__429 {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8
} ;
#line 263 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__429 GUserDirectory;
#line 276
struct _GDebugKey ;
#line 276 "/usr/include/glib-2.0/glib/gutils.h"
typedef struct _GDebugKey GDebugKey;
#line 277 "/usr/include/glib-2.0/glib/gutils.h"
struct _GDebugKey {
   gchar *key ;
   guint value ;
};
#line 305
enum __anonenum__430 {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4
} ;
#line 311 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum __anonenum__430 GFormatSizeFlags;
#line 333 "/usr/include/glib-2.0/glib/gutils.h"
typedef void (*GVoidFunc)(void);
#line 42 "/usr/include/glib-2.0/glib/gthread.h"
enum __anonenum__431 {
    G_THREAD_ERROR_AGAIN = 0
} ;
#line 45 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__431 GThreadError;
#line 47 "/usr/include/glib-2.0/glib/gthread.h"
typedef gpointer (*GThreadFunc)(gpointer  );
#line 49
struct _GThread ;
#line 49 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GThread GThread;
#line 51
union _GMutex ;
#line 51 "/usr/include/glib-2.0/glib/gthread.h"
typedef union _GMutex GMutex;
#line 52
struct _GRecMutex ;
#line 52 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRecMutex GRecMutex;
#line 53
struct _GRWLock ;
#line 53 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GRWLock GRWLock;
#line 54
struct _GCond ;
#line 54 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GCond GCond;
#line 55
struct _GPrivate ;
#line 55 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GPrivate GPrivate;
#line 56
struct _GOnce ;
#line 56 "/usr/include/glib-2.0/glib/gthread.h"
typedef struct _GOnce GOnce;
#line 58 "/usr/include/glib-2.0/glib/gthread.h"
union _GMutex {
   gpointer p ;
   guint i[2] ;
};
#line 65 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRWLock {
   gpointer p ;
   guint i[2] ;
};
#line 72 "/usr/include/glib-2.0/glib/gthread.h"
struct _GCond {
   gpointer p ;
   guint i[2] ;
};
#line 79 "/usr/include/glib-2.0/glib/gthread.h"
struct _GRecMutex {
   gpointer p ;
   guint i[2] ;
};
#line 87 "/usr/include/glib-2.0/glib/gthread.h"
struct _GPrivate {
   gpointer p ;
   GDestroyNotify notify ;
   gpointer future[2] ;
};
#line 95
enum __anonenum__432 {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2
} ;
#line 100 "/usr/include/glib-2.0/glib/gthread.h"
typedef enum __anonenum__432 GOnceStatus;
#line 103 "/usr/include/glib-2.0/glib/gthread.h"
struct _GOnce {
   GOnceStatus status ;
   gpointer retval ;
};
#line 285 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GMutexLocker;
#line 360 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRecMutexLocker;
#line 439 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockWriterLocker;
#line 550 "/usr/include/glib-2.0/glib/gthread.h"
typedef void GRWLockReaderLocker;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
struct _GAsyncQueue ;
#line 36 "/usr/include/glib-2.0/glib/gasyncqueue.h"
typedef struct _GAsyncQueue GAsyncQueue;
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
struct _GTimeZone ;
#line 32 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef struct _GTimeZone GTimeZone;
#line 49
enum __anonenum__433 {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2
} ;
#line 54 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef enum __anonenum__433 GTimeType;
#line 87 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef gint64 GTimeSpan;
#line 96
struct _GDateTime ;
#line 96 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef struct _GDateTime GDateTime;
#line 58 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
enum __anonenum__434 {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7
} ;
#line 68 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef enum __anonenum__434 GBookmarkFileError;
#line 78
struct _GBookmarkFile ;
#line 78 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef struct _GBookmarkFile GBookmarkFile;
#line 47 "/usr/include/glib-2.0/glib/gchecksum.h"
enum __anonenum__435 {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4
} ;
#line 53 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef enum __anonenum__435 GChecksumType;
#line 65
struct _GChecksum ;
#line 65 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef struct _GChecksum GChecksum;
#line 54 "/usr/include/glib-2.0/glib/gconvert.h"
enum __anonenum__436 {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7
} ;
#line 64 "/usr/include/glib-2.0/glib/gconvert.h"
typedef enum __anonenum__436 GConvertError;
#line 83
struct _GIConv ;
#line 83 "/usr/include/glib-2.0/glib/gconvert.h"
typedef struct _GIConv *GIConv;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
struct _GData ;
#line 36 "/usr/include/glib-2.0/glib/gdataset.h"
typedef struct _GData GData;
#line 38 "/usr/include/glib-2.0/glib/gdataset.h"
typedef void (*GDataForeachFunc)(GQuark  , gpointer  , gpointer  );
#line 57 "/usr/include/glib-2.0/glib/gdataset.h"
typedef gpointer (*GDuplicateFunc)(gpointer  , gpointer  );
#line 48 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
#line 49 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint16 GDateYear;
#line 50 "/usr/include/glib-2.0/glib/gdate.h"
typedef guint8 GDateDay;
#line 51
struct _GDate ;
#line 51 "/usr/include/glib-2.0/glib/gdate.h"
typedef struct _GDate GDate;
#line 54
enum __anonenum__437 {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2
} ;
#line 59 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__437 GDateDMY;
#line 62
enum __anonenum__438 {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__438 GDateWeekday;
#line 73
enum __anonenum__439 {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12
} ;
#line 88 "/usr/include/glib-2.0/glib/gdate.h"
typedef enum __anonenum__439 GDateMonth;
#line 99 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate {
   guint julian_days ;
   guint julian ;
   guint dmy ;
   guint day ;
   guint month ;
   guint year ;
};
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
struct _GDir ;
#line 37 "/usr/include/glib-2.0/glib/gdir.h"
typedef struct _GDir GDir;
#line 33 "/usr/include/glib-2.0/glib/gfileutils.h"
enum __anonenum__440 {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24
} ;
#line 60 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__440 GFileError;
#line 66
enum __anonenum__441 {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16
} ;
#line 73 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__441 GFileTest;
#line 99
enum __anonenum__442 {
    G_FILE_SET_CONTENTS_NONE = 0,
    G_FILE_SET_CONTENTS_CONSISTENT = 1,
    G_FILE_SET_CONTENTS_DURABLE = 2,
    G_FILE_SET_CONTENTS_ONLY_EXISTING = 4
} ;
#line 105 "/usr/include/glib-2.0/glib/gfileutils.h"
typedef enum __anonenum__442 GFileSetContentsFlags;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable ;
#line 52 "/usr/include/glib-2.0/glib/gmem.h"
typedef struct _GMemVTable GMemVTable;
#line 380 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable {
   gpointer (*malloc)(gsize  ) ;
   gpointer (*realloc)(gpointer  , gsize  ) ;
   void (*free)(gpointer  ) ;
   gpointer (*calloc)(gsize  , gsize  ) ;
   gpointer (*try_malloc)(gsize  ) ;
   gpointer (*try_realloc)(gpointer  , gsize  ) ;
};
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode ;
#line 36 "/usr/include/glib-2.0/glib/gnode.h"
typedef struct _GNode GNode;
#line 39
enum __anonenum__443 {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
    G_TRAVERSE_MASK = 3,
    G_TRAVERSE_LEAFS = 1,
    G_TRAVERSE_NON_LEAFS = 2
} ;
#line 47 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__443 GTraverseFlags;
#line 50
enum __anonenum__444 {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3
} ;
#line 56 "/usr/include/glib-2.0/glib/gnode.h"
typedef enum __anonenum__444 GTraverseType;
#line 58 "/usr/include/glib-2.0/glib/gnode.h"
typedef gboolean (*GNodeTraverseFunc)(GNode * , gpointer  );
#line 60 "/usr/include/glib-2.0/glib/gnode.h"
typedef void (*GNodeForeachFunc)(GNode * , gpointer  );
#line 65 "/usr/include/glib-2.0/glib/gnode.h"
struct _GNode {
   gpointer data ;
   GNode *next ;
   GNode *prev ;
   GNode *parent ;
   GNode *children ;
};
#line 37 "/usr/include/glib-2.0/glib/glist.h"
struct _GList ;
#line 37 "/usr/include/glib-2.0/glib/glist.h"
typedef struct _GList GList;
#line 39 "/usr/include/glib-2.0/glib/glist.h"
struct _GList {
   gpointer data ;
   GList *next ;
   GList *prev ;
};
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTable ;
#line 37 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTable GHashTable;
#line 39 "/usr/include/glib-2.0/glib/ghash.h"
typedef gboolean (*GHRFunc)(gpointer  , gpointer  , gpointer  );
#line 43
struct _GHashTableIter ;
#line 43 "/usr/include/glib-2.0/glib/ghash.h"
typedef struct _GHashTableIter GHashTableIter;
#line 45 "/usr/include/glib-2.0/glib/ghash.h"
struct _GHashTableIter {
   gpointer dummy1 ;
   gpointer dummy2 ;
   gpointer dummy3 ;
   int dummy4 ;
   gboolean dummy5 ;
   gpointer dummy6 ;
};
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
struct _GHmac ;
#line 40 "/usr/include/glib-2.0/glib/ghmac.h"
typedef struct _GHmac GHmac;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook ;
#line 38 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHook GHook;
#line 39
struct _GHookList ;
#line 39 "/usr/include/glib-2.0/glib/ghook.h"
typedef struct _GHookList GHookList;
#line 41 "/usr/include/glib-2.0/glib/ghook.h"
typedef gint (*GHookCompareFunc)(GHook * , GHook * );
#line 43 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookFindFunc)(GHook * , gpointer  );
#line 45 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookMarshaller)(GHook * , gpointer  );
#line 47 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckMarshaller)(GHook * , gpointer  );
#line 49 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFunc)(gpointer  );
#line 50 "/usr/include/glib-2.0/glib/ghook.h"
typedef gboolean (*GHookCheckFunc)(gpointer  );
#line 51 "/usr/include/glib-2.0/glib/ghook.h"
typedef void (*GHookFinalizeFunc)(GHookList * , GHook * );
#line 53
enum __anonenum__445 {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15
} ;
#line 58 "/usr/include/glib-2.0/glib/ghook.h"
typedef enum __anonenum__445 GHookFlagMask;
#line 63 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHookList {
   gulong seq_id ;
   guint hook_size ;
   guint is_setup ;
   GHook *hooks ;
   gpointer dummy3 ;
   GHookFinalizeFunc finalize_hook ;
   gpointer dummy[2] ;
};
#line 73 "/usr/include/glib-2.0/glib/ghook.h"
struct _GHook {
   gpointer data ;
   GHook *next ;
   GHook *prev ;
   guint ref_count ;
   gulong hook_id ;
   guint flags ;
   gpointer func ;
   GDestroyNotify destroy ;
};
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD ;
#line 59 "/usr/include/glib-2.0/glib/gpoll.h"
typedef struct _GPollFD GPollFD;
#line 74 "/usr/include/glib-2.0/glib/gpoll.h"
typedef gint (*GPollFunc)(GPollFD * , guint  , gint  );
#line 91 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD {
   gint fd ;
   gushort events ;
   gushort revents ;
};
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList ;
#line 37 "/usr/include/glib-2.0/glib/gslist.h"
typedef struct _GSList GSList;
#line 39 "/usr/include/glib-2.0/glib/gslist.h"
struct _GSList {
   gpointer data ;
   GSList *next ;
};
#line 31 "/usr/include/glib-2.0/glib/gmain.h"
enum __anonenum__446 {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32
} ;
#line 39 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__446 GIOCondition;
#line 55
enum __anonenum__447 {
    G_MAIN_CONTEXT_FLAGS_NONE = 0,
    G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING = 1
} ;
#line 59 "/usr/include/glib-2.0/glib/gmain.h"
typedef enum __anonenum__447 GMainContextFlags;
#line 68
struct _GMainContext ;
#line 68 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainContext GMainContext;
#line 76
struct _GMainLoop ;
#line 76 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainLoop GMainLoop;
#line 84
struct _GSource ;
#line 84 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSource GSource;
#line 85
struct _GSourcePrivate ;
#line 85 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourcePrivate GSourcePrivate;
#line 97
struct _GSourceCallbackFuncs ;
#line 97 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
#line 153
struct _GSourceFuncs ;
#line 153 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceFuncs GSourceFuncs;
#line 193 "/usr/include/glib-2.0/glib/gmain.h"
typedef gboolean (*GSourceFunc)(gpointer  );
#line 228 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GChildWatchFunc)(GPid  , gint  , gpointer  );
#line 243 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDisposeFunc)(GSource * );
#line 245 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSource {
   gpointer callback_data ;
   GSourceCallbackFuncs *callback_funcs ;
   GSourceFuncs *source_funcs ;
   guint ref_count ;
   GMainContext *context ;
   gint priority ;
   guint flags ;
   guint source_id ;
   GSList *poll_fds ;
   GSource *prev ;
   GSource *next ;
   char *name ;
   GSourcePrivate *priv ;
};
#line 270 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceCallbackFuncs {
   void (*ref)(gpointer  ) ;
   void (*unref)(gpointer  ) ;
   void (*get)(gpointer  , GSource * , GSourceFunc * , gpointer * ) ;
};
#line 286 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GSourceDummyMarshal)(void);
#line 288 "/usr/include/glib-2.0/glib/gmain.h"
struct _GSourceFuncs {
   gboolean (*prepare)(GSource * , gint * ) ;
   gboolean (*check)(GSource * ) ;
   gboolean (*dispatch)(GSource * , GSourceFunc  , gpointer  ) ;
   void (*finalize)(GSource * ) ;
   GSourceFunc closure_callback ;
   GSourceDummyMarshal closure_marshal ;
};
#line 482 "/usr/include/glib-2.0/glib/gmain.h"
typedef void GMainContextPusher;
#line 741 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GClearHandleFunc)(guint  );
#line 59 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint32 gunichar;
#line 77 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint16 gunichar2;
#line 116
enum __anonenum__448 {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29
} ;
#line 148 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__448 GUnicodeType;
#line 213
enum __anonenum__449 {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CLOSE_PARENTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42
} ;
#line 259 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__449 GUnicodeBreakType;
#line 449
enum __anonenum__450 {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
    G_UNICODE_SCRIPT_ELYMAIC = 149,
    G_UNICODE_SCRIPT_NANDINAGARI = 150,
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151,
    G_UNICODE_SCRIPT_WANCHO = 152,
    G_UNICODE_SCRIPT_CHORASMIAN = 153,
    G_UNICODE_SCRIPT_DIVES_AKURU = 154,
    G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT = 155,
    G_UNICODE_SCRIPT_YEZIDI = 156,
    G_UNICODE_SCRIPT_CYPRO_MINOAN = 157,
    G_UNICODE_SCRIPT_OLD_UYGHUR = 158,
    G_UNICODE_SCRIPT_TANGSA = 159,
    G_UNICODE_SCRIPT_TOTO = 160,
    G_UNICODE_SCRIPT_VITHKUQI = 161,
    G_UNICODE_SCRIPT_MATH = 162
} ;
#line 647 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__450 GUnicodeScript;
#line 930
enum __anonenum__451 {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_NFD = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_NFC = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_NFKD = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
    G_NORMALIZE_NFKC = 3
} ;
#line 939 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum __anonenum__451 GNormalizeMode;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString ;
#line 39 "/usr/include/glib-2.0/glib/gstring.h"
typedef struct _GString GString;
#line 41 "/usr/include/glib-2.0/glib/gstring.h"
struct _GString {
   gchar *str ;
   gsize len ;
   gsize allocated_len ;
};
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel ;
#line 41 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOChannel GIOChannel;
#line 42
struct _GIOFuncs ;
#line 42 "/usr/include/glib-2.0/glib/giochannel.h"
typedef struct _GIOFuncs GIOFuncs;
#line 44
enum __anonenum__452 {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3
} ;
#line 50 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__452 GIOError;
#line 54
enum __anonenum__453 {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8
} ;
#line 67 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__453 GIOChannelError;
#line 69
enum __anonenum__454 {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3
} ;
#line 75 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__454 GIOStatus;
#line 77
enum __anonenum__455 {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2
} ;
#line 82 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__455 GSeekType;
#line 84
enum __anonenum__456 {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_WRITEABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_GET_MASK = 31,
    G_IO_FLAG_SET_MASK = 3
} ;
#line 95 "/usr/include/glib-2.0/glib/giochannel.h"
typedef enum __anonenum__456 GIOFlags;
#line 97 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOChannel {
   gint ref_count ;
   GIOFuncs *funcs ;
   gchar *encoding ;
   GIConv read_cd ;
   GIConv write_cd ;
   gchar *line_term ;
   guint line_term_len ;
   gsize buf_size ;
   GString *read_buf ;
   GString *encoded_read_buf ;
   GString *write_buf ;
   gchar partial_write_buf[6] ;
   guint use_buffer ;
   guint do_encode ;
   guint close_on_unref ;
   guint is_readable ;
   guint is_writeable ;
   guint is_seekable ;
   gpointer reserved1 ;
   gpointer reserved2 ;
};
#line 128 "/usr/include/glib-2.0/glib/giochannel.h"
typedef gboolean (*GIOFunc)(GIOChannel * , GIOCondition  , gpointer  );
#line 131 "/usr/include/glib-2.0/glib/giochannel.h"
struct _GIOFuncs {
   GIOStatus (*io_read)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_write)(GIOChannel * , gchar * , gsize  , gsize * , GError ** ) ;
   GIOStatus (*io_seek)(GIOChannel * , gint64  , GSeekType  , GError ** ) ;
   GIOStatus (*io_close)(GIOChannel * , GError ** ) ;
   GSource *(*io_create_watch)(GIOChannel * , GIOCondition  ) ;
   void (*io_free)(GIOChannel * ) ;
   GIOStatus (*io_set_flags)(GIOChannel * , GIOFlags  , GError ** ) ;
   GIOFlags (*io_get_flags)(GIOChannel * ) ;
};
#line 33 "/usr/include/glib-2.0/glib/gkeyfile.h"
enum __anonenum__457 {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5
} ;
#line 41 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__457 GKeyFileError;
#line 48
struct _GKeyFile ;
#line 48 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef struct _GKeyFile GKeyFile;
#line 50
enum __anonenum__458 {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2
} ;
#line 55 "/usr/include/glib-2.0/glib/gkeyfile.h"
typedef enum __anonenum__458 GKeyFileFlags;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
struct _GMappedFile ;
#line 32 "/usr/include/glib-2.0/glib/gmappedfile.h"
typedef struct _GMappedFile GMappedFile;
#line 49 "/usr/include/glib-2.0/glib/gmarkup.h"
enum __anonenum__459 {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6
} ;
#line 61 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__459 GMarkupError;
#line 95
enum __anonenum__460 {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8
} ;
#line 101 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__460 GMarkupParseFlags;
#line 112
struct _GMarkupParseContext ;
#line 112 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParseContext GMarkupParseContext;
#line 113
struct _GMarkupParser ;
#line 113 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParser GMarkupParser;
#line 143 "/usr/include/glib-2.0/glib/gmarkup.h"
struct _GMarkupParser {
   void (*start_element)(GMarkupParseContext * , gchar * , gchar ** , gchar ** , gpointer  ,
                         GError ** ) ;
   void (*end_element)(GMarkupParseContext * , gchar * , gpointer  , GError ** ) ;
   void (*text)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*passthrough)(GMarkupParseContext * , gchar * , gsize  , gpointer  , GError ** ) ;
   void (*error)(GMarkupParseContext * , GError * , gpointer  ) ;
};
#line 237
enum __anonenum__461 {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536
} ;
#line 246 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum __anonenum__461 GMarkupCollectType;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
struct _GVariantType ;
#line 41 "/usr/include/glib-2.0/glib/gvarianttype.h"
typedef struct _GVariantType GVariantType;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariant ;
#line 34 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariant GVariant;
#line 36
enum __anonenum__462 {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123
} ;
#line 56 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__462 GVariantClass;
#line 268
struct _GVariantIter ;
#line 268 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantIter GVariantIter;
#line 269 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantIter {
   gsize x[16] ;
};
#line 297
struct _GVariantBuilder ;
#line 297 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantBuilder GVariantBuilder;
#line 302 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_464 {
   gsize partial_magic ;
   GVariantType *type ;
   gsize y[14] ;
};
#line 300 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_463 {
   struct __anonstruct_464 s ;
   gsize x[16] ;
};
#line 298 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantBuilder {
   union __anonunion_463 u ;
};
#line 311
enum __anonenum__465 {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
    G_VARIANT_PARSE_ERROR_RECURSION = 18
} ;
#line 332 "/usr/include/glib-2.0/glib/gvariant.h"
typedef enum __anonenum__465 GVariantParseError;
#line 446
struct _GVariantDict ;
#line 446 "/usr/include/glib-2.0/glib/gvariant.h"
typedef struct _GVariantDict GVariantDict;
#line 451 "/usr/include/glib-2.0/glib/gvariant.h"
struct __anonstruct_467 {
   GVariant *asv ;
   gsize partial_magic ;
   gsize y[14] ;
};
#line 449 "/usr/include/glib-2.0/glib/gvariant.h"
union __anonunion_466 {
   struct __anonstruct_467 s ;
   gsize x[16] ;
};
#line 447 "/usr/include/glib-2.0/glib/gvariant.h"
struct _GVariantDict {
   union __anonunion_466 u ;
};
#line 53 "/usr/include/glib-2.0/glib/gmessages.h"
enum __anonenum__468 {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4
} ;
#line 68 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__468 GLogLevelFlags;
#line 73 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GLogFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 134
enum __anonenum__469 {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0
} ;
#line 138 "/usr/include/glib-2.0/glib/gmessages.h"
typedef enum __anonenum__469 GLogWriterOutput;
#line 156
struct _GLogField ;
#line 156 "/usr/include/glib-2.0/glib/gmessages.h"
typedef struct _GLogField GLogField;
#line 157 "/usr/include/glib-2.0/glib/gmessages.h"
struct _GLogField {
   gchar *key ;
   gconstpointer value ;
   gssize length ;
};
#line 195 "/usr/include/glib-2.0/glib/gmessages.h"
typedef GLogWriterOutput (*GLogWriterFunc)(GLogLevelFlags  , GLogField * , gsize  ,
                                           gpointer  );
#line 515 "/usr/include/glib-2.0/glib/gmessages.h"
typedef void (*GPrintFunc)(gchar * );
#line 38 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionContext ;
#line 38 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionContext GOptionContext;
#line 51
struct _GOptionGroup ;
#line 51 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionGroup GOptionGroup;
#line 52
struct _GOptionEntry ;
#line 52 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionEntry GOptionEntry;
#line 81
enum __anonenum__470 {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64
} ;
#line 91 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__470 GOptionFlags;
#line 119
enum __anonenum__471 {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8
} ;
#line 130 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__471 GOptionArg;
#line 149 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionArgFunc)(gchar * , gchar * , gpointer  , GError ** );
#line 167 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionParseFunc)(GOptionContext * , GOptionGroup * , gpointer  ,
                                     GError ** );
#line 182 "/usr/include/glib-2.0/glib/goption.h"
typedef void (*GOptionErrorFunc)(GOptionContext * , GOptionGroup * , gpointer  , GError ** );
#line 206
enum __anonenum__472 {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2
} ;
#line 211 "/usr/include/glib-2.0/glib/goption.h"
typedef enum __anonenum__472 GOptionError;
#line 258 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionEntry {
   gchar *long_name ;
   gchar short_name ;
   gint flags ;
   GOptionArg arg ;
   gpointer arg_data ;
   gchar *description ;
   gchar *arg_description ;
};
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
struct _GPatternSpec ;
#line 30 "/usr/include/glib-2.0/glib/gpattern.h"
typedef struct _GPatternSpec GPatternSpec;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue ;
#line 36 "/usr/include/glib-2.0/glib/gqueue.h"
typedef struct _GQueue GQueue;
#line 47 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue {
   GList *head ;
   GList *tail ;
   guint length ;
};
#line 36 "/usr/include/glib-2.0/glib/grand.h"
struct _GRand ;
#line 36 "/usr/include/glib-2.0/glib/grand.h"
typedef struct _GRand GRand;
#line 55 "/usr/include/glib-2.0/glib/grefstring.h"
typedef char GRefString;
#line 140 "/usr/include/glib-2.0/glib/gregex.h"
enum __anonenum__473 {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} ;
#line 201 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__473 GRegexError;
#line 296
enum __anonenum__474 {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432
} ;
#line 316 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__474 GRegexCompileFlags;
#line 386
enum __anonenum__475 {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_SOFT = 32768,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456
} ;
#line 403 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum __anonenum__475 GRegexMatchFlags;
#line 413
struct _GRegex ;
#line 413 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GRegex GRegex;
#line 422
struct _GMatchInfo ;
#line 422 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GMatchInfo GMatchInfo;
#line 441 "/usr/include/glib-2.0/glib/gregex.h"
typedef gboolean (*GRegexEvalCallback)(GMatchInfo * , GString * , gpointer  );
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner ;
#line 37 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScanner GScanner;
#line 38
struct _GScannerConfig ;
#line 38 "/usr/include/glib-2.0/glib/gscanner.h"
typedef struct _GScannerConfig GScannerConfig;
#line 39
union _GTokenValue ;
#line 39 "/usr/include/glib-2.0/glib/gscanner.h"
typedef union _GTokenValue GTokenValue;
#line 41 "/usr/include/glib-2.0/glib/gscanner.h"
typedef void (*GScannerMsgFunc)(GScanner * , gchar * , gboolean  );
#line 62
enum __anonenum__476 {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7
} ;
#line 72 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__476 GErrorType;
#line 75
enum __anonenum__477 {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270
} ;
#line 109 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum __anonenum__477 GTokenType;
#line 111 "/usr/include/glib-2.0/glib/gscanner.h"
union _GTokenValue {
   gpointer v_symbol ;
   gchar *v_identifier ;
   gulong v_binary ;
   gulong v_octal ;
   gulong v_int ;
   guint64 v_int64 ;
   gdouble v_float ;
   gulong v_hex ;
   gchar *v_string ;
   gchar *v_comment ;
   guchar v_char ;
   guint v_error ;
};
#line 127 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScannerConfig {
   gchar *cset_skip_characters ;
   gchar *cset_identifier_first ;
   gchar *cset_identifier_nth ;
   gchar *cpair_comment_single ;
   guint case_sensitive ;
   guint skip_comment_multi ;
   guint skip_comment_single ;
   guint scan_comment_multi ;
   guint scan_identifier ;
   guint scan_identifier_1char ;
   guint scan_identifier_NULL ;
   guint scan_symbols ;
   guint scan_binary ;
   guint scan_octal ;
   guint scan_float ;
   guint scan_hex ;
   guint scan_hex_dollar ;
   guint scan_string_sq ;
   guint scan_string_dq ;
   guint numbers_2_int ;
   guint int_2_float ;
   guint identifier_2_string ;
   guint char_2_token ;
   guint symbol_2_token ;
   guint scope_0_fallback ;
   guint store_int64 ;
   guint padding_dummy ;
};
#line 169 "/usr/include/glib-2.0/glib/gscanner.h"
struct _GScanner {
   gpointer user_data ;
   guint max_parse_errors ;
   guint parse_errors ;
   gchar *input_name ;
   GData *qdata ;
   GScannerConfig *config ;
   GTokenType token ;
   GTokenValue value ;
   guint line ;
   guint position ;
   GTokenType next_token ;
   GTokenValue next_value ;
   guint next_line ;
   guint next_position ;
   GHashTable *symbol_table ;
   gint input_fd ;
   gchar *text ;
   gchar *text_end ;
   gchar *buffer ;
   guint scope_id ;
   GScannerMsgFunc msg_handler ;
};
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
struct _GSequence ;
#line 30 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequence GSequence;
#line 31
struct _GSequenceNode ;
#line 31 "/usr/include/glib-2.0/glib/gsequence.h"
typedef struct _GSequenceNode GSequenceIter;
#line 33 "/usr/include/glib-2.0/glib/gsequence.h"
typedef gint (*GSequenceIterCompareFunc)(GSequenceIter * , GSequenceIter * , gpointer  );
#line 32 "/usr/include/glib-2.0/glib/gshell.h"
enum __anonenum__478 {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2
} ;
#line 39 "/usr/include/glib-2.0/glib/gshell.h"
typedef enum __anonenum__478 GShellError;
#line 92 "/usr/include/glib-2.0/glib/gslice.h"
enum __anonenum__479 {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6
} ;
#line 99 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum __anonenum__479 GSliceConfig;
#line 68 "/usr/include/glib-2.0/glib/gspawn.h"
enum __anonenum__480 {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_2BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19
} ;
#line 93 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__480 GSpawnError;
#line 138 "/usr/include/glib-2.0/glib/gspawn.h"
typedef void (*GSpawnChildSetupFunc)(gpointer  );
#line 168
enum __anonenum__481 {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256
} ;
#line 182 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum __anonenum__481 GSpawnFlags;
#line 40 "/usr/include/glib-2.0/glib/gstrfuncs.h"
enum __anonenum__482 {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024
} ;
#line 52 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__482 GAsciiType;
#line 273 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef gchar **GStrv;
#line 329
enum __anonenum__483 {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1
} ;
#line 333 "/usr/include/glib-2.0/glib/gstrfuncs.h"
typedef enum __anonenum__483 GNumberParserError;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
struct _GStringChunk ;
#line 36 "/usr/include/glib-2.0/glib/gstringchunk.h"
typedef struct _GStringChunk GStringChunk;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
struct _GStrvBuilder ;
#line 39 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
typedef struct _GStrvBuilder GStrvBuilder;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
struct GTestCase ;
#line 35 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestCase GTestCase;
#line 36
struct GTestSuite ;
#line 36 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct GTestSuite GTestSuite;
#line 37 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFunc)(void);
#line 38 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestDataFunc)(gconstpointer  );
#line 39 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef void (*GTestFixtureFunc)(gpointer  , gconstpointer  );
#line 445
enum __anonenum__484 {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512
} ;
#line 449 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__484 GTestTrapFlags;
#line 459
enum __anonenum__485 {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4
} ;
#line 463 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__485 GTestSubprocessFlags;
#line 590 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_486 {
   gboolean test_initialized ;
   gboolean test_quick ;
   gboolean test_perf ;
   gboolean test_verbose ;
   gboolean test_quiet ;
   gboolean test_undefined ;
};
#line 597 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_486 GTestConfig;
#line 601
enum __anonenum__487 {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3
} ;
#line 606 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__487 GTestResult;
#line 608
enum __anonenum__488 {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11
} ;
#line 621 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__488 GTestLogType;
#line 623 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_489 {
   GTestLogType log_type ;
   guint n_strings ;
   gchar **strings ;
   guint n_nums ;
   long double *nums ;
};
#line 629 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_489 GTestLogMsg;
#line 630 "/usr/include/glib-2.0/glib/gtestutils.h"
struct __anonstruct_490 {
   GString *data ;
   GSList *msgs ;
};
#line 634 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef struct __anonstruct_490 GTestLogBuffer;
#line 664 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef gboolean (*GTestLogFatalFunc)(gchar * , GLogLevelFlags  , gchar * , gpointer  );
#line 683
enum __anonenum__491 {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1
} ;
#line 687 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef enum __anonenum__491 GTestFileType;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool ;
#line 36 "/usr/include/glib-2.0/glib/gthreadpool.h"
typedef struct _GThreadPool GThreadPool;
#line 41 "/usr/include/glib-2.0/glib/gthreadpool.h"
struct _GThreadPool {
   GFunc func ;
   gpointer user_data ;
   gboolean exclusive ;
};
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
struct _GTimer ;
#line 40 "/usr/include/glib-2.0/glib/gtimer.h"
typedef struct _GTimer GTimer;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack ;
#line 38 "/usr/include/glib-2.0/glib/gtrashstack.h"
typedef struct _GTrashStack GTrashStack;
#line 39 "/usr/include/glib-2.0/glib/gtrashstack.h"
struct _GTrashStack {
   GTrashStack *next ;
};
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
struct _GTree ;
#line 38 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTree GTree;
#line 47
struct _GTreeNode ;
#line 47 "/usr/include/glib-2.0/glib/gtree.h"
typedef struct _GTreeNode GTreeNode;
#line 49 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseFunc)(gpointer  , gpointer  , gpointer  );
#line 66 "/usr/include/glib-2.0/glib/gtree.h"
typedef gboolean (*GTraverseNodeFunc)(GTreeNode * , gpointer  );
#line 31 "/usr/include/glib-2.0/glib/guri.h"
struct _GUri ;
#line 31 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUri GUri;
#line 80
enum __anonenum__492 {
    G_URI_FLAGS_NONE = 0,
    G_URI_FLAGS_PARSE_RELAXED = 1,
    G_URI_FLAGS_HAS_PASSWORD = 2,
    G_URI_FLAGS_HAS_AUTH_PARAMS = 4,
    G_URI_FLAGS_ENCODED = 8,
    G_URI_FLAGS_NON_DNS = 16,
    G_URI_FLAGS_ENCODED_QUERY = 32,
    G_URI_FLAGS_ENCODED_PATH = 64,
    G_URI_FLAGS_ENCODED_FRAGMENT = 128,
    G_URI_FLAGS_SCHEME_NORMALIZE = 256
} ;
#line 91 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__492 GUriFlags;
#line 205
enum __anonenum__493 {
    G_URI_HIDE_NONE = 0,
    G_URI_HIDE_USERINFO = 1,
    G_URI_HIDE_PASSWORD = 2,
    G_URI_HIDE_AUTH_PARAMS = 4,
    G_URI_HIDE_QUERY = 8,
    G_URI_HIDE_FRAGMENT = 16
} ;
#line 212 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__493 GUriHideFlags;
#line 257
enum __anonenum__494 {
    G_URI_PARAMS_NONE = 0,
    G_URI_PARAMS_CASE_INSENSITIVE = 1,
    G_URI_PARAMS_WWW_FORM = 2,
    G_URI_PARAMS_PARSE_RELAXED = 4
} ;
#line 262 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__494 GUriParamsFlags;
#line 271
struct _GUriParamsIter ;
#line 271 "/usr/include/glib-2.0/glib/guri.h"
typedef struct _GUriParamsIter GUriParamsIter;
#line 273 "/usr/include/glib-2.0/glib/guri.h"
struct _GUriParamsIter {
   gint dummy0 ;
   gpointer dummy1 ;
   gpointer dummy2 ;
   guint8 dummy3[256] ;
};
#line 326
enum __anonenum__495 {
    G_URI_ERROR_FAILED = 0,
    G_URI_ERROR_BAD_SCHEME = 1,
    G_URI_ERROR_BAD_USER = 2,
    G_URI_ERROR_BAD_PASSWORD = 3,
    G_URI_ERROR_BAD_AUTH_PARAMS = 4,
    G_URI_ERROR_BAD_HOST = 5,
    G_URI_ERROR_BAD_PORT = 6,
    G_URI_ERROR_BAD_PATH = 7,
    G_URI_ERROR_BAD_QUERY = 8,
    G_URI_ERROR_BAD_FRAGMENT = 9
} ;
#line 337 "/usr/include/glib-2.0/glib/guri.h"
typedef enum __anonenum__495 GUriError;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
struct _GAllocator ;
#line 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GAllocator GAllocator;
#line 28
struct _GMemChunk ;
#line 28 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
typedef struct _GMemChunk GMemChunk;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
struct _GCache ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef struct _GCache GCache;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheNewFunc)(gpointer  );
#line 39 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef gpointer (*GCacheDupFunc)(gpointer  );
#line 40 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
typedef void (*GCacheDestroyFunc)(gpointer  );
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef struct _GCompletion GCompletion;
#line 38 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gchar *(*GCompletionFunc)(gpointer  );
#line 43 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
typedef gint (*GCompletionStrncmpFunc)(gchar * , gchar * , gsize  );
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
struct _GCompletion {
   GList *items ;
   GCompletionFunc func ;
   gchar *prefix ;
   GList *cache ;
   GCompletionStrncmpFunc strncmp_func ;
};
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GRelation ;
#line 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GRelation GRelation;
#line 37
struct _GTuples ;
#line 37 "/usr/include/glib-2.0/glib/deprecated/grel.h"
typedef struct _GTuples GTuples;
#line 39 "/usr/include/glib-2.0/glib/deprecated/grel.h"
struct _GTuples {
   guint len ;
};
#line 38 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
enum __anonenum__496 {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3
} ;
#line 44 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef enum __anonenum__496 GThreadPriority;
#line 46 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThread {
   GThreadFunc func ;
   gpointer data ;
   gboolean joinable ;
   GThreadPriority priority ;
};
#line 55
struct _GThreadFunctions ;
#line 55 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GThreadFunctions GThreadFunctions;
#line 56 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GThreadFunctions {
   GMutex *(*mutex_new)(void) ;
   void (*mutex_lock)(GMutex * ) ;
   gboolean (*mutex_trylock)(GMutex * ) ;
   void (*mutex_unlock)(GMutex * ) ;
   void (*mutex_free)(GMutex * ) ;
   GCond *(*cond_new)(void) ;
   void (*cond_signal)(GCond * ) ;
   void (*cond_broadcast)(GCond * ) ;
   void (*cond_wait)(GCond * , GMutex * ) ;
   gboolean (*cond_timed_wait)(GCond * , GMutex * , GTimeVal * ) ;
   void (*cond_free)(GCond * ) ;
   GPrivate *(*private_new)(GDestroyNotify  ) ;
   gpointer (*private_get)(GPrivate * ) ;
   void (*private_set)(GPrivate * , gpointer  ) ;
   void (*thread_create)(GThreadFunc  , gpointer  , gulong  , gboolean  , gboolean  ,
                         GThreadPriority  , gpointer  , GError ** ) ;
   void (*thread_yield)(void) ;
   void (*thread_join)(gpointer  ) ;
   void (*thread_exit)(void) ;
   void (*thread_set_priority)(gpointer  , GThreadPriority  ) ;
   void (*thread_self)(gpointer  ) ;
   gboolean (*thread_equal)(gpointer  , gpointer  ) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 37 "/usr/include/pthread.h"
enum __anonenum__498 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 47
enum __anonenum__499 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
#line 69
enum __anonenum__500 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST = 1,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 81
enum __anonenum__501 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 104
enum __anonenum__502 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 124
enum __anonenum__503 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 134
enum __anonenum__504 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 144
enum __anonenum__505 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 159 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 168
enum __anonenum__506 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 175
enum __anonenum__507 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 538 "/usr/include/pthread.h"
struct __cancel_jmp_buf_tag {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 544 "/usr/include/pthread.h"
struct __anonstruct_508 {
   struct __cancel_jmp_buf_tag __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 548 "/usr/include/pthread.h"
typedef struct __anonstruct_508 __pthread_unwind_buf_t;
#line 557 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 133 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct __anonstruct_509 {
   GMutex *mutex ;
   pthread_mutex_t unused ;
};
#line 140 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct __anonstruct_509 GStaticMutex;
#line 156
struct _GStaticRecMutex ;
#line 156 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRecMutex GStaticRecMutex;
#line 164 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
union __anonunion_510 {
   pthread_t owner ;
   gdouble dummy ;
};
#line 157 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRecMutex {
   GStaticMutex mutex ;
   guint depth ;
   union __anonunion_510 unused ;
};
#line 197
struct _GStaticRWLock ;
#line 197 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticRWLock GStaticRWLock;
#line 198 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticRWLock {
   GStaticMutex mutex ;
   GCond *read_cond ;
   GCond *write_cond ;
   guint read_counter ;
   gboolean have_writer ;
   guint want_to_read ;
   guint want_to_write ;
};
#line 239
struct _GStaticPrivate ;
#line 239 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
typedef struct _GStaticPrivate GStaticPrivate;
#line 240 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
struct _GStaticPrivate {
   guint index ;
};
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GAsyncQueue *GAsyncQueue_autoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GAsyncQueue_listautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GAsyncQueue_slistautoptr;
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GAsyncQueue_queueautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBookmarkFile *GBookmarkFile_autoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBookmarkFile_listautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBookmarkFile_slistautoptr;
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBookmarkFile_queueautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GBytes *GBytes_autoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GBytes_listautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GBytes_slistautoptr;
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GBytes_queueautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GChecksum *GChecksum_autoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GChecksum_listautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GChecksum_slistautoptr;
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GChecksum_queueautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDateTime *GDateTime_autoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDateTime_listautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDateTime_slistautoptr;
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDateTime_queueautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDate *GDate_autoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDate_listautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDate_slistautoptr;
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDate_queueautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GDir *GDir_autoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GDir_listautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GDir_slistautoptr;
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GDir_queueautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GError *GError_autoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GError_listautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GError_slistautoptr;
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GError_queueautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHashTable *GHashTable_autoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHashTable_listautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHashTable_slistautoptr;
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHashTable_queueautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GHmac *GHmac_autoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GHmac_listautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GHmac_slistautoptr;
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GHmac_queueautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GIOChannel *GIOChannel_autoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GIOChannel_listautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GIOChannel_slistautoptr;
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GIOChannel_queueautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GKeyFile *GKeyFile_autoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GKeyFile_listautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GKeyFile_slistautoptr;
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GKeyFile_queueautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_autoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GList_listautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GList_slistautoptr;
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GList_queueautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GArray *GArray_autoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GArray_listautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GArray_slistautoptr;
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GArray_queueautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPtrArray *GPtrArray_autoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPtrArray_listautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPtrArray_slistautoptr;
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPtrArray_queueautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GByteArray *GByteArray_autoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GByteArray_listautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GByteArray_slistautoptr;
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GByteArray_queueautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContext *GMainContext_autoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContext_listautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContext_slistautoptr;
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContext_queueautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainContextPusher *GMainContextPusher_autoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainContextPusher_listautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainContextPusher_slistautoptr;
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainContextPusher_queueautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMainLoop *GMainLoop_autoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMainLoop_listautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMainLoop_slistautoptr;
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMainLoop_queueautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSource *GSource_autoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSource_listautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSource_slistautoptr;
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSource_queueautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMappedFile *GMappedFile_autoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMappedFile_listautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMappedFile_slistautoptr;
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMappedFile_queueautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMarkupParseContext *GMarkupParseContext_autoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMarkupParseContext_listautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMarkupParseContext_slistautoptr;
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMarkupParseContext_queueautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GNode *GNode_autoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GNode_listautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GNode_slistautoptr;
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GNode_queueautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionContext *GOptionContext_autoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionContext_listautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionContext_slistautoptr;
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionContext_queueautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GOptionGroup *GOptionGroup_autoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GOptionGroup_listautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GOptionGroup_slistautoptr;
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GOptionGroup_queueautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GPatternSpec *GPatternSpec_autoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GPatternSpec_listautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GPatternSpec_slistautoptr;
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GPatternSpec_queueautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_autoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GQueue_listautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GQueue_slistautoptr;
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GQueue_queueautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRand *GRand_autoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRand_listautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRand_slistautoptr;
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRand_queueautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRegex *GRegex_autoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRegex_listautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRegex_slistautoptr;
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRegex_queueautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMatchInfo *GMatchInfo_autoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMatchInfo_listautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMatchInfo_slistautoptr;
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMatchInfo_queueautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GScanner *GScanner_autoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GScanner_listautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GScanner_slistautoptr;
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GScanner_queueautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSequence *GSequence_autoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSequence_listautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSequence_slistautoptr;
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSequence_queueautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_autoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GSList_listautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GSList_slistautoptr;
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GSList_queueautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GString *GString_autoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GString_listautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GString_slistautoptr;
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GString_queueautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStringChunk *GStringChunk_autoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStringChunk_listautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStringChunk_slistautoptr;
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStringChunk_queueautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GStrvBuilder *GStrvBuilder_autoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GStrvBuilder_listautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GStrvBuilder_slistautoptr;
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GStrvBuilder_queueautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GThread *GThread_autoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GThread_listautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GThread_slistautoptr;
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GThread_queueautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GMutexLocker *GMutexLocker_autoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GMutexLocker_listautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GMutexLocker_slistautoptr;
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GMutexLocker_queueautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRecMutexLocker *GRecMutexLocker_autoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRecMutexLocker_listautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRecMutexLocker_slistautoptr;
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRecMutexLocker_queueautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockWriterLocker *GRWLockWriterLocker_autoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockWriterLocker_listautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockWriterLocker_slistautoptr;
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockWriterLocker_queueautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRWLockReaderLocker *GRWLockReaderLocker_autoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRWLockReaderLocker_listautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRWLockReaderLocker_slistautoptr;
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRWLockReaderLocker_queueautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimer *GTimer_autoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimer_listautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimer_slistautoptr;
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimer_queueautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTimeZone *GTimeZone_autoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTimeZone_listautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTimeZone_slistautoptr;
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTimeZone_queueautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GTree *GTree_autoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GTree_listautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GTree_slistautoptr;
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GTree_queueautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariant *GVariant_autoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariant_listautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariant_slistautoptr;
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariant_queueautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantBuilder *GVariantBuilder_autoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantBuilder_listautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantBuilder_slistautoptr;
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantBuilder_queueautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantIter *GVariantIter_autoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantIter_listautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantIter_slistautoptr;
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantIter_queueautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantDict *GVariantDict_autoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantDict_listautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantDict_slistautoptr;
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantDict_queueautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GVariantType *GVariantType_autoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GVariantType_listautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GVariantType_slistautoptr;
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GVariantType_queueautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GRefString *GRefString_autoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GRefString_listautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GRefString_slistautoptr;
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GRefString_queueautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GUri *GUri_autoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GList *GUri_listautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GSList *GUri_slistautoptr;
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
typedef GQueue *GUri_queueautoptr;
#line 400 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gsize GType;
#line 404
struct _GValue ;
#line 404 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GValue GValue;
#line 405
union _GTypeCValue ;
#line 405 "/usr/include/glib-2.0/gobject/gtype.h"
typedef union _GTypeCValue GTypeCValue;
#line 406
struct _GTypePlugin ;
#line 406 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypePlugin GTypePlugin;
#line 407
struct _GTypeClass ;
#line 407 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeClass GTypeClass;
#line 408
struct _GTypeInterface ;
#line 408 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInterface GTypeInterface;
#line 409
struct _GTypeInstance ;
#line 409 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInstance GTypeInstance;
#line 410
struct _GTypeInfo ;
#line 410 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeInfo GTypeInfo;
#line 411
struct _GTypeFundamentalInfo ;
#line 411 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
#line 412
struct _GInterfaceInfo ;
#line 412 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GInterfaceInfo GInterfaceInfo;
#line 413
struct _GTypeValueTable ;
#line 413 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeValueTable GTypeValueTable;
#line 414
struct _GTypeQuery ;
#line 414 "/usr/include/glib-2.0/gobject/gtype.h"
typedef struct _GTypeQuery GTypeQuery;
#line 424 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeClass {
   GType g_type ;
};
#line 434 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInstance {
   GTypeClass *g_class ;
};
#line 444 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInterface {
   GType g_type ;
   GType g_instance_type ;
};
#line 461 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeQuery {
   GType type ;
   gchar *type_name ;
   guint class_size ;
   guint instance_size ;
};
#line 697
enum __anonenum__511 {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7
} ;
#line 704 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__511 GTypeDebugFlags;
#line 794 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseInitFunc)(gpointer  );
#line 808 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseFinalizeFunc)(gpointer  );
#line 912 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassInitFunc)(gpointer  , gpointer  );
#line 929 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassFinalizeFunc)(gpointer  , gpointer  );
#line 951 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInstanceInitFunc)(GTypeInstance * , gpointer  );
#line 967 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceInitFunc)(gpointer  , gpointer  );
#line 979 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceFinalizeFunc)(gpointer  , gpointer  );
#line 1001 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gboolean (*GTypeClassCacheFunc)(gpointer  , GTypeClass * );
#line 1015 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GTypeInterfaceCheckFunc)(gpointer  , gpointer  );
#line 1027
enum __anonenum__512 {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8
} ;
#line 1033 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__512 GTypeFundamentalFlags;
#line 1046
enum __anonenum__513 {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
    G_TYPE_FLAG_FINAL = 64
} ;
#line 1051 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum __anonenum__513 GTypeFlags;
#line 1083 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInfo {
   guint16 class_size ;
   GBaseInitFunc base_init ;
   GBaseFinalizeFunc base_finalize ;
   GClassInitFunc class_init ;
   GClassFinalizeFunc class_finalize ;
   gconstpointer class_data ;
   guint16 instance_size ;
   guint16 n_preallocs ;
   GInstanceInitFunc instance_init ;
   GTypeValueTable *value_table ;
};
#line 1111 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeFundamentalInfo {
   GTypeFundamentalFlags type_flags ;
};
#line 1124 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GInterfaceInfo {
   GInterfaceInitFunc interface_init ;
   GInterfaceFinalizeFunc interface_finalize ;
   gpointer interface_data ;
};
#line 1284 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeValueTable {
   void (*value_init)(GValue * ) ;
   void (*value_free)(GValue * ) ;
   void (*value_copy)(GValue * , GValue * ) ;
   gpointer (*value_peek_pointer)(GValue * ) ;
   gchar *collect_format ;
   gchar *(*collect_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
   gchar *lcopy_format ;
   gchar *(*lcopy_value)(GValue * , guint  , GTypeCValue * , guint  ) ;
};
#line 95 "/usr/include/glib-2.0/gobject/gvalue.h"
typedef void (*GValueTransform)(GValue * , GValue * );
#line 117 "/usr/include/glib-2.0/gobject/gvalue.h"
union __anonunion_514 {
   gint v_int ;
   guint v_uint ;
   glong v_long ;
   gulong v_ulong ;
   gint64 v_int64 ;
   guint64 v_uint64 ;
   gfloat v_float ;
   gdouble v_double ;
   gpointer v_pointer ;
};
#line 111 "/usr/include/glib-2.0/gobject/gvalue.h"
struct _GValue {
   GType g_type ;
   union __anonunion_514 data[2] ;
};
#line 152 "/usr/include/glib-2.0/gobject/gparam.h"
enum __anonenum__515 {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_PRIVATE = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = (-0x7FFFFFFF-1)
} ;
#line 168 "/usr/include/glib-2.0/gobject/gparam.h"
typedef enum __anonenum__515 GParamFlags;
#line 194
struct _GParamSpec ;
#line 194 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpec GParamSpec;
#line 195
struct _GParamSpecClass ;
#line 195 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecClass GParamSpecClass;
#line 196
struct _GParameter ;
#line 196 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParameter GParameter;
#line 197
struct _GParamSpecPool ;
#line 197 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecPool GParamSpecPool;
#line 209 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpec {
   GTypeInstance g_type_instance ;
   gchar *name ;
   GParamFlags flags ;
   GType value_type ;
   GType owner_type ;
   gchar *_nick ;
   gchar *_blurb ;
   GData *qdata ;
   guint ref_count ;
   guint param_id ;
};
#line 244 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecClass {
   GTypeClass g_type_class ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
   gpointer dummy[4] ;
};
#line 273 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParameter {
   gchar *name ;
   GValue value ;
};
#line 353
struct _GParamSpecTypeInfo ;
#line 353 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
#line 379 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecTypeInfo {
   guint16 instance_size ;
   guint16 n_preallocs ;
   void (*instance_init)(GParamSpec * ) ;
   GType value_type ;
   void (*finalize)(GParamSpec * ) ;
   void (*value_set_default)(GParamSpec * , GValue * ) ;
   gboolean (*value_validate)(GParamSpec * , GValue * ) ;
   gint (*values_cmp)(GParamSpec * , GValue * , GValue * ) ;
};
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure ;
#line 75 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosure GClosure;
#line 76
struct _GClosureNotifyData ;
#line 76 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosureNotifyData GClosureNotifyData;
#line 90 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GCallback)(void);
#line 99 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureNotify)(gpointer  , GClosure * );
#line 119 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureMarshal)(GClosure * , GValue * , guint  , GValue * , gpointer  ,
                                gpointer  );
#line 146 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GVaClosureMarshal)(GClosure * , GValue * , gpointer  , va_list  , gpointer  ,
                                  int  , GType * );
#line 161
struct _GCClosure ;
#line 161 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GCClosure GCClosure;
#line 165 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosureNotifyData {
   gpointer data ;
   GClosureNotify notify ;
};
#line 179 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure {
   guint ref_count ;
   guint meta_marshal_nouse ;
   guint n_guards ;
   guint n_fnotifiers ;
   guint n_inotifiers ;
   guint in_inotify ;
   guint floating ;
   guint derivative_flag ;
   guint in_marshal ;
   guint is_invalid ;
   void (*marshal)(GClosure * , GValue * , guint  , GValue * , gpointer  , gpointer  ) ;
   gpointer data ;
   GClosureNotifyData *notifiers ;
};
#line 220 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GCClosure {
   GClosure closure ;
   gpointer callback ;
};
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery ;
#line 32 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalQuery GSignalQuery;
#line 33
struct _GSignalInvocationHint ;
#line 33 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef struct _GSignalInvocationHint GSignalInvocationHint;
#line 45 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GClosureMarshal GSignalCMarshaller;
#line 53 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GVaClosureMarshal GSignalCVaMarshaller;
#line 73 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalEmissionHook)(GSignalInvocationHint * , guint  , GValue * ,
                                        gpointer  );
#line 101 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalAccumulator)(GSignalInvocationHint * , GValue * , GValue * ,
                                       gpointer  );
#line 136
enum __anonenum__516 {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
    G_SIGNAL_ACCUMULATOR_FIRST_RUN = 131072
} ;
#line 149 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__516 GSignalFlags;
#line 166
enum __anonenum__517 {
    G_CONNECT_AFTER = 1,
    G_CONNECT_SWAPPED = 2
} ;
#line 170 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__517 GConnectFlags;
#line 184
enum __anonenum__518 {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32
} ;
#line 192 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum __anonenum__518 GSignalMatchType;
#line 236 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalInvocationHint {
   guint signal_id ;
   GQuark detail ;
   GSignalFlags run_type ;
};
#line 263 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery {
   guint signal_id ;
   gchar *signal_name ;
   GType itype ;
   GSignalFlags signal_flags ;
   GType return_type ;
   guint n_params ;
   GType *param_types ;
};
#line 56 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef gpointer (*GBoxedCopyFunc)(gpointer  );
#line 65 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef void (*GBoxedFreeFunc)(gpointer  );
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject ;
#line 190 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GObject;
#line 191
struct _GObjectClass ;
#line 191 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GObjectClass;
#line 192 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GInitiallyUnowned;
#line 193 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectClass GInitiallyUnownedClass;
#line 194
struct _GObjectConstructParam ;
#line 194 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObjectConstructParam GObjectConstructParam;
#line 205 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectGetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 219 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectSetPropertyFunc)(GObject * , guint  , GValue * , GParamSpec * );
#line 229 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectFinalizeFunc)(GObject * );
#line 247 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GWeakNotify)(gpointer  , GObject * );
#line 265 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObject {
   GTypeInstance g_type_instance ;
   guint ref_count ;
   GData *qdata ;
};
#line 335 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectClass {
   GTypeClass g_type_class ;
   GSList *construct_properties ;
   GObject *(*constructor)(GType  , guint  , GObjectConstructParam * ) ;
   void (*set_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*get_property)(GObject * , guint  , GValue * , GParamSpec * ) ;
   void (*dispose)(GObject * ) ;
   void (*finalize)(GObject * ) ;
   void (*dispatch_properties_changed)(GObject * , guint  , GParamSpec ** ) ;
   void (*notify)(GObject * , GParamSpec * ) ;
   void (*constructed)(GObject * ) ;
   gsize flags ;
   gpointer pdummy[6] ;
};
#line 384 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectConstructParam {
   GParamSpec *pspec ;
   GValue *value ;
};
#line 559 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GToggleNotify)(gpointer  , GObject * , gboolean  );
#line 930 "/usr/include/glib-2.0/gobject/gobject.h"
union __anonunion_520 {
   gpointer p ;
};
#line 928 "/usr/include/glib-2.0/gobject/gobject.h"
struct __anonstruct_519 {
   union __anonunion_520 priv ;
};
#line 931 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct __anonstruct_519 GWeakRef;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
struct _GBinding ;
#line 47 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef struct _GBinding GBinding;
#line 69 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef gboolean (*GBindingTransformFunc)(GBinding * , GValue * , GValue * , gpointer  );
#line 97
enum __anonenum__521 {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4
} ;
#line 103 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef enum __anonenum__521 GBindingFlags;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
struct _GBindingGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
typedef struct _GBindingGroup GBindingGroup;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass ;
#line 138 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumClass GEnumClass;
#line 139
struct _GFlagsClass ;
#line 139 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsClass GFlagsClass;
#line 140
struct _GEnumValue ;
#line 140 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumValue GEnumValue;
#line 141
struct _GFlagsValue ;
#line 141 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GFlagsValue GFlagsValue;
#line 155 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass {
   GTypeClass g_type_class ;
   gint minimum ;
   gint maximum ;
   guint n_values ;
   GEnumValue *values ;
};
#line 176 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsClass {
   GTypeClass g_type_class ;
   guint mask ;
   guint n_values ;
   GFlagsValue *values ;
};
#line 194 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumValue {
   gint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 209 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsValue {
   guint value ;
   gchar *value_name ;
   gchar *value_nick ;
};
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar ;
#line 586 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecChar GParamSpecChar;
#line 587
struct _GParamSpecUChar ;
#line 587 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUChar GParamSpecUChar;
#line 588
struct _GParamSpecBoolean ;
#line 588 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoolean GParamSpecBoolean;
#line 589
struct _GParamSpecInt ;
#line 589 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt GParamSpecInt;
#line 590
struct _GParamSpecUInt ;
#line 590 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt GParamSpecUInt;
#line 591
struct _GParamSpecLong ;
#line 591 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecLong GParamSpecLong;
#line 592
struct _GParamSpecULong ;
#line 592 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecULong GParamSpecULong;
#line 593
struct _GParamSpecInt64 ;
#line 593 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecInt64 GParamSpecInt64;
#line 594
struct _GParamSpecUInt64 ;
#line 594 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
#line 595
struct _GParamSpecUnichar ;
#line 595 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecUnichar GParamSpecUnichar;
#line 596
struct _GParamSpecEnum ;
#line 596 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecEnum GParamSpecEnum;
#line 597
struct _GParamSpecFlags ;
#line 597 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFlags GParamSpecFlags;
#line 598
struct _GParamSpecFloat ;
#line 598 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecFloat GParamSpecFloat;
#line 599
struct _GParamSpecDouble ;
#line 599 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecDouble GParamSpecDouble;
#line 600
struct _GParamSpecString ;
#line 600 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecString GParamSpecString;
#line 601
struct _GParamSpecParam ;
#line 601 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecParam GParamSpecParam;
#line 602
struct _GParamSpecBoxed ;
#line 602 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecBoxed GParamSpecBoxed;
#line 603
struct _GParamSpecPointer ;
#line 603 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecPointer GParamSpecPointer;
#line 604
struct _GParamSpecValueArray ;
#line 604 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecValueArray GParamSpecValueArray;
#line 605
struct _GParamSpecObject ;
#line 605 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecObject GParamSpecObject;
#line 606
struct _GParamSpecOverride ;
#line 606 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecOverride GParamSpecOverride;
#line 607
struct _GParamSpecGType ;
#line 607 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecGType GParamSpecGType;
#line 608
struct _GParamSpecVariant ;
#line 608 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecVariant GParamSpecVariant;
#line 619 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar {
   GParamSpec parent_instance ;
   gint8 minimum ;
   gint8 maximum ;
   gint8 default_value ;
};
#line 636 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUChar {
   GParamSpec parent_instance ;
   guint8 minimum ;
   guint8 maximum ;
   guint8 default_value ;
};
#line 651 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoolean {
   GParamSpec parent_instance ;
   gboolean default_value ;
};
#line 666 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt {
   GParamSpec parent_instance ;
   gint minimum ;
   gint maximum ;
   gint default_value ;
};
#line 683 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt {
   GParamSpec parent_instance ;
   guint minimum ;
   guint maximum ;
   guint default_value ;
};
#line 700 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecLong {
   GParamSpec parent_instance ;
   glong minimum ;
   glong maximum ;
   glong default_value ;
};
#line 717 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecULong {
   GParamSpec parent_instance ;
   gulong minimum ;
   gulong maximum ;
   gulong default_value ;
};
#line 734 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt64 {
   GParamSpec parent_instance ;
   gint64 minimum ;
   gint64 maximum ;
   gint64 default_value ;
};
#line 751 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt64 {
   GParamSpec parent_instance ;
   guint64 minimum ;
   guint64 maximum ;
   guint64 default_value ;
};
#line 766 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUnichar {
   GParamSpec parent_instance ;
   gunichar default_value ;
};
#line 781 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecEnum {
   GParamSpec parent_instance ;
   GEnumClass *enum_class ;
   gint default_value ;
};
#line 797 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFlags {
   GParamSpec parent_instance ;
   GFlagsClass *flags_class ;
   guint default_value ;
};
#line 815 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFloat {
   GParamSpec parent_instance ;
   gfloat minimum ;
   gfloat maximum ;
   gfloat default_value ;
   gfloat epsilon ;
};
#line 835 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecDouble {
   GParamSpec parent_instance ;
   gdouble minimum ;
   gdouble maximum ;
   gdouble default_value ;
   gdouble epsilon ;
};
#line 857 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecString {
   GParamSpec parent_instance ;
   gchar *default_value ;
   gchar *cset_first ;
   gchar *cset_nth ;
   gchar substitutor ;
   guint null_fold_if_empty ;
   guint ensure_non_null ;
};
#line 875 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecParam {
   GParamSpec parent_instance ;
};
#line 885 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecBoxed {
   GParamSpec parent_instance ;
};
#line 895 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecPointer {
   GParamSpec parent_instance ;
};
#line 907 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecValueArray {
   GParamSpec parent_instance ;
   GParamSpec *element_spec ;
   guint fixed_n_elements ;
};
#line 919 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecObject {
   GParamSpec parent_instance ;
};
#line 940 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecOverride {
   GParamSpec parent_instance ;
   GParamSpec *overridden ;
};
#line 955 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecGType {
   GParamSpec parent_instance ;
   GType is_a_type ;
};
#line 976 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecVariant {
   GParamSpec parent_instance ;
   GVariantType *type ;
   GVariant *default_value ;
   gpointer padding[4] ;
};
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
struct _GSignalGroup ;
#line 47 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
typedef struct _GSignalGroup GSignalGroup;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule ;
#line 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModule GTypeModule;
#line 30
struct _GTypeModuleClass ;
#line 30 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef struct _GTypeModuleClass GTypeModuleClass;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GTypeModule *GTypeModule_autoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GList *GTypeModule_listautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GSList *GTypeModule_slistautoptr;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
typedef GQueue *GTypeModule_queueautoptr;
#line 48 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule {
   GObject parent_instance ;
   guint use_count ;
   GSList *type_infos ;
   GSList *interface_infos ;
   gchar *name ;
};
#line 70 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModuleClass {
   GObjectClass parent_class ;
   gboolean (*load)(GTypeModule * ) ;
   void (*unload)(GTypeModule * ) ;
   void (*reserved1)(void) ;
   void (*reserved2)(void) ;
   void (*reserved3)(void) ;
   void (*reserved4)(void) ;
};
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass ;
#line 38 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef struct _GTypePluginClass GTypePluginClass;
#line 46 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUse)(GTypePlugin * );
#line 53 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginUnuse)(GTypePlugin * );
#line 63 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteTypeInfo)(GTypePlugin * , GType  , GTypeInfo * ,
                                            GTypeValueTable * );
#line 77 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteInterfaceInfo)(GTypePlugin * , GType  , GType  ,
                                                 GInterfaceInfo * );
#line 101 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass {
   GTypeInterface base_iface ;
   GTypePluginUse use_plugin ;
   GTypePluginUnuse unuse_plugin ;
   GTypePluginCompleteTypeInfo complete_type_info ;
   GTypePluginCompleteInterfaceInfo complete_interface_info ;
};
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray ;
#line 41 "/usr/include/glib-2.0/gobject/gvaluearray.h"
typedef struct _GValueArray GValueArray;
#line 49 "/usr/include/glib-2.0/gobject/gvaluearray.h"
struct _GValueArray {
   guint n_values ;
   GValue *values ;
   guint n_prealloced ;
};
#line 311 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
typedef gchar *gchararray;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GClosure *GClosure_autoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GClosure_listautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GClosure_slistautoptr;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GClosure_queueautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GEnumClass *GEnumClass_autoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GEnumClass_listautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GEnumClass_slistautoptr;
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GEnumClass_queueautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GFlagsClass *GFlagsClass_autoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GFlagsClass_listautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GFlagsClass_slistautoptr;
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GFlagsClass_queueautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GObject *GObject_autoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GObject_listautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GObject_slistautoptr;
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GObject_queueautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GInitiallyUnowned *GInitiallyUnowned_autoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GInitiallyUnowned_listautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GInitiallyUnowned_slistautoptr;
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GInitiallyUnowned_queueautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GParamSpec *GParamSpec_autoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GParamSpec_listautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GParamSpec_slistautoptr;
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GParamSpec_queueautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GTypeClass *GTypeClass_autoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GList *GTypeClass_listautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GSList *GTypeClass_slistautoptr;
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
typedef GQueue *GTypeClass_queueautoptr;
#line 42 "/usr/include/glib-2.0/gio/gioenums.h"
enum __anonenum__522 {
    G_APP_INFO_CREATE_NONE = 0,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 1,
    G_APP_INFO_CREATE_SUPPORTS_URIS = 2,
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4
} ;
#line 47 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__522 GAppInfoCreateFlags;
#line 59
enum __anonenum__523 {
    G_CONVERTER_NO_FLAGS = 0,
    G_CONVERTER_INPUT_AT_END = 1,
    G_CONVERTER_FLUSH = 2
} ;
#line 63 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__523 GConverterFlags;
#line 76
enum __anonenum__524 {
    G_CONVERTER_ERROR = 0,
    G_CONVERTER_CONVERTED = 1,
    G_CONVERTER_FINISHED = 2,
    G_CONVERTER_FLUSHED = 3
} ;
#line 81 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__524 GConverterResult;
#line 94
enum __anonenum__525 {
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2
} ;
#line 98 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__525 GDataStreamByteOrder;
#line 110
enum __anonenum__526 {
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0,
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2,
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3
} ;
#line 115 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__526 GDataStreamNewlineType;
#line 133
enum __anonenum__527 {
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
    G_FILE_ATTRIBUTE_TYPE_STRING = 1,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3,
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4,
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5,
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6,
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7,
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8,
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9
} ;
#line 144 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__527 GFileAttributeType;
#line 155
enum __anonenum__528 {
    G_FILE_ATTRIBUTE_INFO_NONE = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1,
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2
} ;
#line 159 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__528 GFileAttributeInfoFlags;
#line 170
enum __anonenum__529 {
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
    G_FILE_ATTRIBUTE_STATUS_SET = 1,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2
} ;
#line 174 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__529 GFileAttributeStatus;
#line 184
enum __anonenum__530 {
    G_FILE_QUERY_INFO_NONE = 0,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1
} ;
#line 187 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__530 GFileQueryInfoFlags;
#line 208
enum __anonenum__531 {
    G_FILE_CREATE_NONE = 0,
    G_FILE_CREATE_PRIVATE = 1,
    G_FILE_CREATE_REPLACE_DESTINATION = 2
} ;
#line 212 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__531 GFileCreateFlags;
#line 231
enum __anonenum__532 {
    G_FILE_MEASURE_NONE = 0,
    G_FILE_MEASURE_REPORT_ANY_ERROR = 2,
    G_FILE_MEASURE_APPARENT_SIZE = 4,
    G_FILE_MEASURE_NO_XDEV = 8
} ;
#line 236 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__532 GFileMeasureFlags;
#line 244
enum __anonenum__533 {
    G_MOUNT_MOUNT_NONE = 0
} ;
#line 246 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__533 GMountMountFlags;
#line 257
enum __anonenum__534 {
    G_MOUNT_UNMOUNT_NONE = 0,
    G_MOUNT_UNMOUNT_FORCE = 1
} ;
#line 260 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__534 GMountUnmountFlags;
#line 270
enum __anonenum__535 {
    G_DRIVE_START_NONE = 0
} ;
#line 272 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__535 GDriveStartFlags;
#line 294
enum __anonenum__536 {
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1,
    G_DRIVE_START_STOP_TYPE_NETWORK = 2,
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3,
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4
} ;
#line 300 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__536 GDriveStartStopType;
#line 314
enum __anonenum__537 {
    G_FILE_COPY_NONE = 0,
    G_FILE_COPY_OVERWRITE = 1,
    G_FILE_COPY_BACKUP = 2,
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 4,
    G_FILE_COPY_ALL_METADATA = 8,
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16,
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 32
} ;
#line 322 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__537 GFileCopyFlags;
#line 344
enum __anonenum__538 {
    G_FILE_MONITOR_NONE = 0,
    G_FILE_MONITOR_WATCH_MOUNTS = 1,
    G_FILE_MONITOR_SEND_MOVED = 2,
    G_FILE_MONITOR_WATCH_HARD_LINKS = 4,
    G_FILE_MONITOR_WATCH_MOVES = 8
} ;
#line 350 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__538 GFileMonitorFlags;
#line 376
enum __anonenum__539 {
    G_FILE_TYPE_UNKNOWN = 0,
    G_FILE_TYPE_REGULAR = 1,
    G_FILE_TYPE_DIRECTORY = 2,
    G_FILE_TYPE_SYMBOLIC_LINK = 3,
    G_FILE_TYPE_SPECIAL = 4,
    G_FILE_TYPE_SHORTCUT = 5,
    G_FILE_TYPE_MOUNTABLE = 6
} ;
#line 384 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__539 GFileType;
#line 397
enum __anonenum__540 {
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2
} ;
#line 401 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__540 GFilesystemPreviewType;
#line 427
enum __anonenum__541 {
    G_FILE_MONITOR_EVENT_CHANGED = 0,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1,
    G_FILE_MONITOR_EVENT_DELETED = 2,
    G_FILE_MONITOR_EVENT_CREATED = 3,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5,
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6,
    G_FILE_MONITOR_EVENT_MOVED = 7,
    G_FILE_MONITOR_EVENT_RENAMED = 8,
    G_FILE_MONITOR_EVENT_MOVED_IN = 9,
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10
} ;
#line 439 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__541 GFileMonitorEvent;
#line 530
enum __anonenum__542 {
    G_IO_ERROR_FAILED = 0,
    G_IO_ERROR_NOT_FOUND = 1,
    G_IO_ERROR_EXISTS = 2,
    G_IO_ERROR_IS_DIRECTORY = 3,
    G_IO_ERROR_NOT_DIRECTORY = 4,
    G_IO_ERROR_NOT_EMPTY = 5,
    G_IO_ERROR_NOT_REGULAR_FILE = 6,
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7,
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8,
    G_IO_ERROR_FILENAME_TOO_LONG = 9,
    G_IO_ERROR_INVALID_FILENAME = 10,
    G_IO_ERROR_TOO_MANY_LINKS = 11,
    G_IO_ERROR_NO_SPACE = 12,
    G_IO_ERROR_INVALID_ARGUMENT = 13,
    G_IO_ERROR_PERMISSION_DENIED = 14,
    G_IO_ERROR_NOT_SUPPORTED = 15,
    G_IO_ERROR_NOT_MOUNTED = 16,
    G_IO_ERROR_ALREADY_MOUNTED = 17,
    G_IO_ERROR_CLOSED = 18,
    G_IO_ERROR_CANCELLED = 19,
    G_IO_ERROR_PENDING = 20,
    G_IO_ERROR_READ_ONLY = 21,
    G_IO_ERROR_CANT_CREATE_BACKUP = 22,
    G_IO_ERROR_WRONG_ETAG = 23,
    G_IO_ERROR_TIMED_OUT = 24,
    G_IO_ERROR_WOULD_RECURSE = 25,
    G_IO_ERROR_BUSY = 26,
    G_IO_ERROR_WOULD_BLOCK = 27,
    G_IO_ERROR_HOST_NOT_FOUND = 28,
    G_IO_ERROR_WOULD_MERGE = 29,
    G_IO_ERROR_FAILED_HANDLED = 30,
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31,
    G_IO_ERROR_NOT_INITIALIZED = 32,
    G_IO_ERROR_ADDRESS_IN_USE = 33,
    G_IO_ERROR_PARTIAL_INPUT = 34,
    G_IO_ERROR_INVALID_DATA = 35,
    G_IO_ERROR_DBUS_ERROR = 36,
    G_IO_ERROR_HOST_UNREACHABLE = 37,
    G_IO_ERROR_NETWORK_UNREACHABLE = 38,
    G_IO_ERROR_CONNECTION_REFUSED = 39,
    G_IO_ERROR_PROXY_FAILED = 40,
    G_IO_ERROR_PROXY_AUTH_FAILED = 41,
    G_IO_ERROR_PROXY_NEED_AUTH = 42,
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43,
    G_IO_ERROR_BROKEN_PIPE = 44,
    G_IO_ERROR_CONNECTION_CLOSED = 44,
    G_IO_ERROR_NOT_CONNECTED = 45,
    G_IO_ERROR_MESSAGE_TOO_LARGE = 46
} ;
#line 579 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__542 GIOErrorEnum;
#line 595
enum __anonenum__543 {
    G_ASK_PASSWORD_NEED_PASSWORD = 1,
    G_ASK_PASSWORD_NEED_USERNAME = 2,
    G_ASK_PASSWORD_NEED_DOMAIN = 4,
    G_ASK_PASSWORD_SAVING_SUPPORTED = 8,
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16,
    G_ASK_PASSWORD_TCRYPT = 32
} ;
#line 602 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__543 GAskPasswordFlags;
#line 616
enum __anonenum__544 {
    G_PASSWORD_SAVE_NEVER = 0,
    G_PASSWORD_SAVE_FOR_SESSION = 1,
    G_PASSWORD_SAVE_PERMANENTLY = 2
} ;
#line 620 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__544 GPasswordSave;
#line 635
enum __anonenum__545 {
    G_MOUNT_OPERATION_HANDLED = 0,
    G_MOUNT_OPERATION_ABORTED = 1,
    G_MOUNT_OPERATION_UNHANDLED = 2
} ;
#line 639 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__545 GMountOperationResult;
#line 652
enum __anonenum__546 {
    G_OUTPUT_STREAM_SPLICE_NONE = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1,
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2
} ;
#line 656 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__546 GOutputStreamSpliceFlags;
#line 673
enum __anonenum__547 {
    G_IO_STREAM_SPLICE_NONE = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1,
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2,
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4
} ;
#line 678 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__547 GIOStreamSpliceFlags;
#line 692
enum __anonenum__548 {
    G_EMBLEM_ORIGIN_UNKNOWN = 0,
    G_EMBLEM_ORIGIN_DEVICE = 1,
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2,
    G_EMBLEM_ORIGIN_TAG = 3
} ;
#line 697 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__548 GEmblemOrigin;
#line 712
enum __anonenum__549 {
    G_RESOLVER_ERROR_NOT_FOUND = 0,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1,
    G_RESOLVER_ERROR_INTERNAL = 2
} ;
#line 716 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__549 GResolverError;
#line 759
enum __anonenum__550 {
    G_RESOLVER_RECORD_SRV = 1,
    G_RESOLVER_RECORD_MX = 2,
    G_RESOLVER_RECORD_TXT = 3,
    G_RESOLVER_RECORD_SOA = 4,
    G_RESOLVER_RECORD_NS = 5
} ;
#line 765 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__550 GResolverRecordType;
#line 777
enum __anonenum__551 {
    G_RESOURCE_ERROR_NOT_FOUND = 0,
    G_RESOURCE_ERROR_INTERNAL = 1
} ;
#line 780 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__551 GResourceError;
#line 792
enum __anonenum__552 {
    G_RESOURCE_FLAGS_NONE = 0,
    G_RESOURCE_FLAGS_COMPRESSED = 1
} ;
#line 795 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__552 GResourceFlags;
#line 805
enum __anonenum__553 {
    G_RESOURCE_LOOKUP_FLAGS_NONE = 0
} ;
#line 807 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__553 GResourceLookupFlags;
#line 822
enum __anonenum__554 {
    G_SOCKET_FAMILY_INVALID = 0,
    G_SOCKET_FAMILY_UNIX = 1,
    G_SOCKET_FAMILY_IPV4 = 2,
    G_SOCKET_FAMILY_IPV6 = 10
} ;
#line 827 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__554 GSocketFamily;
#line 843
enum __anonenum__555 {
    G_SOCKET_TYPE_INVALID = 0,
    G_SOCKET_TYPE_STREAM = 1,
    G_SOCKET_TYPE_DATAGRAM = 2,
    G_SOCKET_TYPE_SEQPACKET = 3
} ;
#line 849 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__555 GSocketType;
#line 868
enum __anonenum__556 {
    G_SOCKET_MSG_NONE = 0,
    G_SOCKET_MSG_OOB = 1,
    G_SOCKET_MSG_PEEK = 2,
    G_SOCKET_MSG_DONTROUTE = 4
} ;
#line 874 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__556 GSocketMsgFlags;
#line 894
enum __anonenum__557 {
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT = 0,
    G_SOCKET_PROTOCOL_TCP = 6,
    G_SOCKET_PROTOCOL_UDP = 17,
    G_SOCKET_PROTOCOL_SCTP = 132
} ;
#line 900 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__557 GSocketProtocol;
#line 913
enum __anonenum__558 {
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1,
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2
} ;
#line 917 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__558 GZlibCompressorFormat;
#line 944
enum __anonenum__559 {
    G_UNIX_SOCKET_ADDRESS_INVALID = 0,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1,
    G_UNIX_SOCKET_ADDRESS_PATH = 2,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4
} ;
#line 950 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__559 GUnixSocketAddressType;
#line 963
enum __anonenum__560 {
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE = 0,
    G_BUS_TYPE_SYSTEM = 1,
    G_BUS_TYPE_SESSION = 2
} ;
#line 969 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__560 GBusType;
#line 984
enum __anonenum__561 {
    G_BUS_NAME_OWNER_FLAGS_NONE = 0,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1,
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 2,
    G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4
} ;
#line 990 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__561 GBusNameOwnerFlags;
#line 1005
enum __anonenum__562 {
    G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1
} ;
#line 1009 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__562 GBusNameWatcherFlags;
#line 1032
enum __anonenum__563 {
    G_DBUS_PROXY_FLAGS_NONE = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1,
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4,
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
    G_DBUS_PROXY_FLAGS_NO_MATCH_RULE = 32
} ;
#line 1041 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__563 GDBusProxyFlags;
#line 1150
enum __anonenum__564 {
    G_DBUS_ERROR_FAILED = 0,
    G_DBUS_ERROR_NO_MEMORY = 1,
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3,
    G_DBUS_ERROR_NO_REPLY = 4,
    G_DBUS_ERROR_IO_ERROR = 5,
    G_DBUS_ERROR_BAD_ADDRESS = 6,
    G_DBUS_ERROR_NOT_SUPPORTED = 7,
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8,
    G_DBUS_ERROR_ACCESS_DENIED = 9,
    G_DBUS_ERROR_AUTH_FAILED = 10,
    G_DBUS_ERROR_NO_SERVER = 11,
    G_DBUS_ERROR_TIMEOUT = 12,
    G_DBUS_ERROR_NO_NETWORK = 13,
    G_DBUS_ERROR_ADDRESS_IN_USE = 14,
    G_DBUS_ERROR_DISCONNECTED = 15,
    G_DBUS_ERROR_INVALID_ARGS = 16,
    G_DBUS_ERROR_FILE_NOT_FOUND = 17,
    G_DBUS_ERROR_FILE_EXISTS = 18,
    G_DBUS_ERROR_UNKNOWN_METHOD = 19,
    G_DBUS_ERROR_TIMED_OUT = 20,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21,
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23,
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26,
    G_DBUS_ERROR_SPAWN_FAILED = 27,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32,
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33,
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35,
    G_DBUS_ERROR_INVALID_SIGNATURE = 36,
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40,
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41,
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42,
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43,
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44
} ;
#line 1198 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__564 GDBusError;
#line 1220
enum __anonenum__565 {
    G_DBUS_CONNECTION_FLAGS_NONE = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4,
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8,
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 32
} ;
#line 1228 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__565 GDBusConnectionFlags;
#line 1240
enum __anonenum__566 {
    G_DBUS_CAPABILITY_FLAGS_NONE = 0,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1
} ;
#line 1243 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__566 GDBusCapabilityFlags;
#line 1258
enum __anonenum__567 {
    G_DBUS_CALL_FLAGS_NONE = 0,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1,
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2
} ;
#line 1262 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__567 GDBusCallFlags;
#line 1277
enum __anonenum__568 {
    G_DBUS_MESSAGE_TYPE_INVALID = 0,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2,
    G_DBUS_MESSAGE_TYPE_ERROR = 3,
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4
} ;
#line 1283 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__568 GDBusMessageType;
#line 1299
enum __anonenum__569 {
    G_DBUS_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1,
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2,
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4
} ;
#line 1304 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__569 GDBusMessageFlags;
#line 1323
enum __anonenum__570 {
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9
} ;
#line 1334 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__570 GDBusMessageHeaderField;
#line 1346
enum __anonenum__571 {
    G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1,
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2
} ;
#line 1351 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__571 GDBusPropertyInfoFlags;
#line 1364
enum __anonenum__572 {
    G_DBUS_SUBTREE_FLAGS_NONE = 0,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1
} ;
#line 1368 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__572 GDBusSubtreeFlags;
#line 1385
enum __anonenum__573 {
    G_DBUS_SERVER_FLAGS_NONE = 0,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 4
} ;
#line 1391 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__573 GDBusServerFlags;
#line 1409
enum __anonenum__574 {
    G_DBUS_SIGNAL_FLAGS_NONE = 0,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4
} ;
#line 1415 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__574 GDBusSignalFlags;
#line 1428
enum __anonenum__575 {
    G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1
} ;
#line 1432 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__575 GDBusSendMessageFlags;
#line 1450
enum __anonenum__576 {
    G_CREDENTIALS_TYPE_INVALID = 0,
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3,
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4,
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5,
    G_CREDENTIALS_TYPE_APPLE_XUCRED = 6,
    G_CREDENTIALS_TYPE_WIN32_PID = 7
} ;
#line 1460 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__576 GCredentialsType;
#line 1471
enum __anonenum__577 {
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108
} ;
#line 1475 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__577 GDBusMessageByteOrder;
#line 1521
enum __anonenum__578 {
    G_APPLICATION_FLAGS_NONE = 0,
    G_APPLICATION_IS_SERVICE = 1,
    G_APPLICATION_IS_LAUNCHER = 2,
    G_APPLICATION_HANDLES_OPEN = 4,
    G_APPLICATION_HANDLES_COMMAND_LINE = 8,
    G_APPLICATION_SEND_ENVIRONMENT = 16,
    G_APPLICATION_NON_UNIQUE = 32,
    G_APPLICATION_CAN_OVERRIDE_APP_ID = 64,
    G_APPLICATION_ALLOW_REPLACEMENT = 128,
    G_APPLICATION_REPLACE = 256
} ;
#line 1536 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__578 GApplicationFlags;
#line 1565
enum __anonenum__579 {
    G_TLS_ERROR_UNAVAILABLE = 0,
    G_TLS_ERROR_MISC = 1,
    G_TLS_ERROR_BAD_CERTIFICATE = 2,
    G_TLS_ERROR_NOT_TLS = 3,
    G_TLS_ERROR_HANDSHAKE = 4,
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5,
    G_TLS_ERROR_EOF = 6,
    G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7,
    G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD = 8
} ;
#line 1575 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__579 GTlsError;
#line 1609
enum __anonenum__580 {
    G_TLS_CERTIFICATE_UNKNOWN_CA = 1,
    G_TLS_CERTIFICATE_BAD_IDENTITY = 2,
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 4,
    G_TLS_CERTIFICATE_EXPIRED = 8,
    G_TLS_CERTIFICATE_REVOKED = 16,
    G_TLS_CERTIFICATE_INSECURE = 32,
    G_TLS_CERTIFICATE_GENERIC_ERROR = 64,
    G_TLS_CERTIFICATE_VALIDATE_ALL = 127
} ;
#line 1619 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__580 GTlsCertificateFlags;
#line 1631
enum __anonenum__581 {
    G_TLS_AUTHENTICATION_NONE = 0,
    G_TLS_AUTHENTICATION_REQUESTED = 1,
    G_TLS_AUTHENTICATION_REQUIRED = 2
} ;
#line 1635 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__581 GTlsAuthenticationMode;
#line 1654
enum __anonenum__582 {
    G_TLS_CHANNEL_BINDING_TLS_UNIQUE = 0,
    G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT = 1
} ;
#line 1657 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__582 GTlsChannelBindingType;
#line 1684
enum __anonenum__583 {
    G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED = 0,
    G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE = 1,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE = 2,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED = 3,
    G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR = 4
} ;
#line 1690 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__583 GTlsChannelBindingError;
#line 1707
enum __anonenum__584 {
    G_TLS_REHANDSHAKE_NEVER = 0,
    G_TLS_REHANDSHAKE_SAFELY = 1,
    G_TLS_REHANDSHAKE_UNSAFELY = 2
} ;
#line 1711 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__584 GTlsRehandshakeMode;
#line 1733
enum _GTlsPasswordFlags {
    G_TLS_PASSWORD_NONE = 0,
    G_TLS_PASSWORD_RETRY = 2,
    G_TLS_PASSWORD_MANY_TRIES = 4,
    G_TLS_PASSWORD_FINAL_TRY = 8,
    G_TLS_PASSWORD_PKCS11_USER = 16,
    G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 32,
    G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 64
} ;
#line 1742 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum _GTlsPasswordFlags GTlsPasswordFlags;
#line 1758
enum __anonenum__585 {
    G_TLS_INTERACTION_UNHANDLED = 0,
    G_TLS_INTERACTION_HANDLED = 1,
    G_TLS_INTERACTION_FAILED = 2
} ;
#line 1762 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__585 GTlsInteractionResult;
#line 1776
enum __anonenum__586 {
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1
} ;
#line 1780 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__586 GDBusInterfaceSkeletonFlags;
#line 1794
enum __anonenum__587 {
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1
} ;
#line 1798 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__587 GDBusObjectManagerClientFlags;
#line 1808
enum __anonenum__588 {
    G_TLS_DATABASE_VERIFY_NONE = 0
} ;
#line 1810 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__588 GTlsDatabaseVerifyFlags;
#line 1824
enum __anonenum__589 {
    G_TLS_DATABASE_LOOKUP_NONE = 0,
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1
} ;
#line 1827 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__589 GTlsDatabaseLookupFlags;
#line 1839
enum __anonenum__590 {
    G_TLS_CERTIFICATE_REQUEST_NONE = 0
} ;
#line 1841 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__590 GTlsCertificateRequestFlags;
#line 1866
enum __anonenum__591 {
    G_TLS_PROTOCOL_VERSION_UNKNOWN = 0,
    G_TLS_PROTOCOL_VERSION_SSL_3_0 = 1,
    G_TLS_PROTOCOL_VERSION_TLS_1_0 = 2,
    G_TLS_PROTOCOL_VERSION_TLS_1_1 = 3,
    G_TLS_PROTOCOL_VERSION_TLS_1_2 = 4,
    G_TLS_PROTOCOL_VERSION_TLS_1_3 = 5,
    G_TLS_PROTOCOL_VERSION_DTLS_1_0 = 201,
    G_TLS_PROTOCOL_VERSION_DTLS_1_2 = 202
} ;
#line 1875 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__591 GTlsProtocolVersion;
#line 1888
enum __anonenum__592 {
    G_IO_MODULE_SCOPE_NONE = 0,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1
} ;
#line 1891 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__592 GIOModuleScopeFlags;
#line 1919
enum __anonenum__593 {
    G_SOCKET_CLIENT_RESOLVING = 0,
    G_SOCKET_CLIENT_RESOLVED = 1,
    G_SOCKET_CLIENT_CONNECTING = 2,
    G_SOCKET_CLIENT_CONNECTED = 3,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5,
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6,
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7,
    G_SOCKET_CLIENT_COMPLETE = 8
} ;
#line 1929 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__593 GSocketClientEvent;
#line 1947
enum __anonenum__594 {
    G_SOCKET_LISTENER_BINDING = 0,
    G_SOCKET_LISTENER_BOUND = 1,
    G_SOCKET_LISTENER_LISTENING = 2,
    G_SOCKET_LISTENER_LISTENED = 3
} ;
#line 1952 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__594 GSocketListenerEvent;
#line 1962
enum __anonenum__595 {
    G_TEST_DBUS_NONE = 0
} ;
#line 1964 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__595 GTestDBusFlags;
#line 2007
enum __anonenum__596 {
    G_SUBPROCESS_FLAGS_NONE = 0,
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 1,
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2,
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4,
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8,
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 16,
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32,
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 64,
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 128,
    G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = 256
} ;
#line 2018 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__596 GSubprocessFlags;
#line 2039
enum __anonenum__597 {
    G_NOTIFICATION_PRIORITY_NORMAL = 0,
    G_NOTIFICATION_PRIORITY_LOW = 1,
    G_NOTIFICATION_PRIORITY_HIGH = 2,
    G_NOTIFICATION_PRIORITY_URGENT = 3
} ;
#line 2044 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__597 GNotificationPriority;
#line 2063
enum __anonenum__598 {
    G_NETWORK_CONNECTIVITY_LOCAL = 1,
    G_NETWORK_CONNECTIVITY_LIMITED = 2,
    G_NETWORK_CONNECTIVITY_PORTAL = 3,
    G_NETWORK_CONNECTIVITY_FULL = 4
} ;
#line 2068 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__598 GNetworkConnectivity;
#line 2088
enum __anonenum__599 {
    G_POLLABLE_RETURN_FAILED = 0,
    G_POLLABLE_RETURN_OK = 1,
    G_POLLABLE_RETURN_WOULD_BLOCK = -27
} ;
#line 2092 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__599 GPollableReturn;
#line 2117
enum __anonenum__600 {
    G_MEMORY_MONITOR_WARNING_LEVEL_LOW = 50,
    G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM = 100,
    G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255
} ;
#line 2121 "/usr/include/glib-2.0/gio/gioenums.h"
typedef enum __anonenum__600 GMemoryMonitorWarningLevel;
#line 32 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GAppLaunchContext ;
#line 32 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAppLaunchContext GAppLaunchContext;
#line 33
struct _GAppInfo ;
#line 33 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAppInfo GAppInfo;
#line 34
struct _GAsyncResult ;
#line 34 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAsyncResult GAsyncResult;
#line 35
struct _GAsyncInitable ;
#line 35 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAsyncInitable GAsyncInitable;
#line 36
struct _GBufferedInputStream ;
#line 36 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBufferedInputStream GBufferedInputStream;
#line 37
struct _GBufferedOutputStream ;
#line 37 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBufferedOutputStream GBufferedOutputStream;
#line 38
struct _GCancellable ;
#line 38 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCancellable GCancellable;
#line 39
struct _GCharsetConverter ;
#line 39 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCharsetConverter GCharsetConverter;
#line 40
struct _GConverter ;
#line 40 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverter GConverter;
#line 41
struct _GConverterInputStream ;
#line 41 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverterInputStream GConverterInputStream;
#line 42
struct _GConverterOutputStream ;
#line 42 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GConverterOutputStream GConverterOutputStream;
#line 43
struct _GDatagramBased ;
#line 43 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDatagramBased GDatagramBased;
#line 44
struct _GDataInputStream ;
#line 44 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDataInputStream GDataInputStream;
#line 45
struct _GSimplePermission ;
#line 45 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimplePermission GSimplePermission;
#line 46
struct _GZlibCompressor ;
#line 46 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GZlibCompressor GZlibCompressor;
#line 47
struct _GZlibDecompressor ;
#line 47 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GZlibDecompressor GZlibDecompressor;
#line 49
struct _GSimpleActionGroup ;
#line 49 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleActionGroup GSimpleActionGroup;
#line 50
struct _GRemoteActionGroup ;
#line 50 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GRemoteActionGroup GRemoteActionGroup;
#line 51
struct _GDBusActionGroup ;
#line 51 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusActionGroup GDBusActionGroup;
#line 52
struct _GActionMap ;
#line 52 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GActionMap GActionMap;
#line 53
struct _GActionGroup ;
#line 53 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GActionGroup GActionGroup;
#line 54
struct _GPropertyAction ;
#line 54 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPropertyAction GPropertyAction;
#line 55
struct _GSimpleAction ;
#line 55 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleAction GSimpleAction;
#line 56
struct _GAction ;
#line 56 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GAction GAction;
#line 57
struct _GApplication ;
#line 57 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GApplication GApplication;
#line 58
struct _GApplicationCommandLine ;
#line 58 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GApplicationCommandLine GApplicationCommandLine;
#line 59
struct _GSettingsBackend ;
#line 59 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSettingsBackend GSettingsBackend;
#line 60
struct _GSettings ;
#line 60 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSettings GSettings;
#line 61
struct _GPermission ;
#line 61 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPermission GPermission;
#line 63
struct _GMenuModel ;
#line 63 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMenuModel GMenuModel;
#line 64
struct _GNotification ;
#line 64 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNotification GNotification;
#line 71
struct _GDrive ;
#line 71 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDrive GDrive;
#line 72
struct _GFileEnumerator ;
#line 72 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileEnumerator GFileEnumerator;
#line 73
struct _GFileMonitor ;
#line 73 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileMonitor GFileMonitor;
#line 74
struct _GFilterInputStream ;
#line 74 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilterInputStream GFilterInputStream;
#line 75
struct _GFilterOutputStream ;
#line 75 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilterOutputStream GFilterOutputStream;
#line 84
struct _GFile ;
#line 84 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFile GFile;
#line 85
struct _GFileInfo ;
#line 85 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileInfo GFileInfo;
#line 92
struct _GFileAttributeMatcher ;
#line 92 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeMatcher GFileAttributeMatcher;
#line 93
struct _GFileAttributeInfo ;
#line 93 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeInfo GFileAttributeInfo;
#line 94
struct _GFileAttributeInfoList ;
#line 94 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileAttributeInfoList GFileAttributeInfoList;
#line 95
struct _GFileDescriptorBased ;
#line 95 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileDescriptorBased GFileDescriptorBased;
#line 96
struct _GFileInputStream ;
#line 96 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileInputStream GFileInputStream;
#line 97
struct _GFileOutputStream ;
#line 97 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileOutputStream GFileOutputStream;
#line 98
struct _GFileIOStream ;
#line 98 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileIOStream GFileIOStream;
#line 99
struct _GFileIcon ;
#line 99 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFileIcon GFileIcon;
#line 100
struct _GFilenameCompleter ;
#line 100 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GFilenameCompleter GFilenameCompleter;
#line 103
struct _GIcon ;
#line 103 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIcon GIcon;
#line 104
struct _GInetAddress ;
#line 104 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetAddress GInetAddress;
#line 105
struct _GInetAddressMask ;
#line 105 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetAddressMask GInetAddressMask;
#line 106
struct _GInetSocketAddress ;
#line 106 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInetSocketAddress GInetSocketAddress;
#line 107
struct _GNativeSocketAddress ;
#line 107 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNativeSocketAddress GNativeSocketAddress;
#line 108
struct _GInputStream ;
#line 108 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputStream GInputStream;
#line 109
struct _GInitable ;
#line 109 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInitable GInitable;
#line 110
struct _GIOModule ;
#line 110 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOModule GIOModule;
#line 111
struct _GIOExtensionPoint ;
#line 111 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOExtensionPoint GIOExtensionPoint;
#line 112
struct _GIOExtension ;
#line 112 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOExtension GIOExtension;
#line 119
struct _GIOSchedulerJob ;
#line 119 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOSchedulerJob GIOSchedulerJob;
#line 120
struct _GIOStreamAdapter ;
#line 120 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOStreamAdapter GIOStreamAdapter;
#line 121
struct _GLoadableIcon ;
#line 121 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GLoadableIcon GLoadableIcon;
#line 122
struct _GBytesIcon ;
#line 122 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GBytesIcon GBytesIcon;
#line 123
struct _GMemoryInputStream ;
#line 123 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMemoryInputStream GMemoryInputStream;
#line 124
struct _GMemoryOutputStream ;
#line 124 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMemoryOutputStream GMemoryOutputStream;
#line 131
struct _GMount ;
#line 131 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMount GMount;
#line 132
struct _GMountOperation ;
#line 132 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GMountOperation GMountOperation;
#line 133
struct _GNetworkAddress ;
#line 133 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkAddress GNetworkAddress;
#line 134
struct _GNetworkMonitor ;
#line 134 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkMonitor GNetworkMonitor;
#line 135
struct _GNetworkService ;
#line 135 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GNetworkService GNetworkService;
#line 136
struct _GOutputStream ;
#line 136 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputStream GOutputStream;
#line 137
struct _GIOStream ;
#line 137 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GIOStream GIOStream;
#line 138
struct _GSimpleIOStream ;
#line 138 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleIOStream GSimpleIOStream;
#line 139
struct _GPollableInputStream ;
#line 139 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPollableInputStream GPollableInputStream;
#line 140
struct _GPollableOutputStream ;
#line 140 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GPollableOutputStream GPollableOutputStream;
#line 141
struct _GResolver ;
#line 141 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GResolver GResolver;
#line 150
struct _GResource ;
#line 150 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GResource GResource;
#line 151
struct _GSeekable ;
#line 151 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSeekable GSeekable;
#line 152
struct _GSimpleAsyncResult ;
#line 152 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSimpleAsyncResult GSimpleAsyncResult;
#line 161
struct _GSocket ;
#line 161 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocket GSocket;
#line 169
struct _GSocketControlMessage ;
#line 169 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketControlMessage GSocketControlMessage;
#line 177
struct _GSocketClient ;
#line 177 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketClient GSocketClient;
#line 185
struct _GSocketConnection ;
#line 185 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketConnection GSocketConnection;
#line 193
struct _GSocketListener ;
#line 193 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketListener GSocketListener;
#line 202
struct _GSocketService ;
#line 202 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketService GSocketService;
#line 203
struct _GSocketAddress ;
#line 203 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketAddress GSocketAddress;
#line 204
struct _GSocketAddressEnumerator ;
#line 204 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketAddressEnumerator GSocketAddressEnumerator;
#line 205
struct _GSocketConnectable ;
#line 205 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSocketConnectable GSocketConnectable;
#line 206
struct _GSrvTarget ;
#line 206 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSrvTarget GSrvTarget;
#line 207
struct _GTask ;
#line 207 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTask GTask;
#line 215
struct _GTcpConnection ;
#line 215 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTcpConnection GTcpConnection;
#line 216
struct _GTcpWrapperConnection ;
#line 216 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTcpWrapperConnection GTcpWrapperConnection;
#line 225
struct _GThreadedSocketService ;
#line 225 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GThreadedSocketService GThreadedSocketService;
#line 226
struct _GDtlsConnection ;
#line 226 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsConnection GDtlsConnection;
#line 227
struct _GDtlsClientConnection ;
#line 227 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsClientConnection GDtlsClientConnection;
#line 228
struct _GDtlsServerConnection ;
#line 228 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDtlsServerConnection GDtlsServerConnection;
#line 229
struct _GThemedIcon ;
#line 229 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GThemedIcon GThemedIcon;
#line 230
struct _GTlsCertificate ;
#line 230 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsCertificate GTlsCertificate;
#line 231
struct _GTlsClientConnection ;
#line 231 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsClientConnection GTlsClientConnection;
#line 232
struct _GTlsConnection ;
#line 232 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsConnection GTlsConnection;
#line 233
struct _GTlsDatabase ;
#line 233 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsDatabase GTlsDatabase;
#line 234
struct _GTlsFileDatabase ;
#line 234 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsFileDatabase GTlsFileDatabase;
#line 235
struct _GTlsInteraction ;
#line 235 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsInteraction GTlsInteraction;
#line 236
struct _GTlsPassword ;
#line 236 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsPassword GTlsPassword;
#line 237
struct _GTlsServerConnection ;
#line 237 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTlsServerConnection GTlsServerConnection;
#line 238
struct _GVfs ;
#line 238 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVfs GVfs;
#line 247
struct _GProxyResolver ;
#line 247 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyResolver GProxyResolver;
#line 248
struct _GProxy ;
#line 248 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxy GProxy;
#line 249
struct _GProxyAddress ;
#line 249 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyAddress GProxyAddress;
#line 250
struct _GProxyAddressEnumerator ;
#line 250 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GProxyAddressEnumerator GProxyAddressEnumerator;
#line 257
struct _GVolume ;
#line 257 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVolume GVolume;
#line 258
struct _GVolumeMonitor ;
#line 258 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GVolumeMonitor GVolumeMonitor;
#line 279 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GAsyncReadyCallback)(GObject * , GAsyncResult * , gpointer  );
#line 293 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GFileProgressCallback)(goffset  , goffset  , gpointer  );
#line 310 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GFileReadMoreCallback)(char const   * , goffset  , gpointer  );
#line 352 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GFileMeasureProgressCallback)(gboolean  , guint64  , guint64  , guint64  ,
                                             gpointer  );
#line 372 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GIOSchedulerJobFunc)(GIOSchedulerJob * , GCancellable * , gpointer  );
#line 385 "/usr/include/glib-2.0/gio/giotypes.h"
typedef void (*GSimpleAsyncThreadFunc)(GSimpleAsyncResult * , GObject * , GCancellable * );
#line 402 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GSocketSourceFunc)(GSocket * , GIOCondition  , gpointer  );
#line 420 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GDatagramBasedSourceFunc)(GDatagramBased * , GIOCondition  , gpointer  );
#line 436
struct _GInputVector ;
#line 436 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputVector GInputVector;
#line 438 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GInputVector {
   gpointer buffer ;
   gsize size ;
};
#line 482
struct _GInputMessage ;
#line 482 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GInputMessage GInputMessage;
#line 484 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GInputMessage {
   GSocketAddress **address ;
   GInputVector *vectors ;
   guint num_vectors ;
   gsize bytes_received ;
   gint flags ;
   GSocketControlMessage ***control_messages ;
   guint *num_control_messages ;
};
#line 509
struct _GOutputVector ;
#line 509 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputVector GOutputVector;
#line 511 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GOutputVector {
   gconstpointer buffer ;
   gsize size ;
};
#line 537
struct _GOutputMessage ;
#line 537 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GOutputMessage GOutputMessage;
#line 539 "/usr/include/glib-2.0/gio/giotypes.h"
struct _GOutputMessage {
   GSocketAddress *address ;
   GOutputVector *vectors ;
   guint num_vectors ;
   guint bytes_sent ;
   GSocketControlMessage **control_messages ;
   guint num_control_messages ;
};
#line 551
struct _GCredentials ;
#line 551 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GCredentials GCredentials;
#line 552
struct _GUnixCredentialsMessage ;
#line 552 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GUnixCredentialsMessage GUnixCredentialsMessage;
#line 553
struct _GUnixFDList ;
#line 553 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GUnixFDList GUnixFDList;
#line 554
struct _GDBusMessage ;
#line 554 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMessage GDBusMessage;
#line 555
struct _GDBusConnection ;
#line 555 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusConnection GDBusConnection;
#line 556
struct _GDBusProxy ;
#line 556 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusProxy GDBusProxy;
#line 557
struct _GDBusMethodInvocation ;
#line 557 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMethodInvocation GDBusMethodInvocation;
#line 558
struct _GDBusServer ;
#line 558 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusServer GDBusServer;
#line 559
struct _GDBusAuthObserver ;
#line 559 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusAuthObserver GDBusAuthObserver;
#line 560
struct _GDBusErrorEntry ;
#line 560 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusErrorEntry GDBusErrorEntry;
#line 561
struct _GDBusInterfaceVTable ;
#line 561 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceVTable GDBusInterfaceVTable;
#line 562
struct _GDBusSubtreeVTable ;
#line 562 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusSubtreeVTable GDBusSubtreeVTable;
#line 563
struct _GDBusAnnotationInfo ;
#line 563 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusAnnotationInfo GDBusAnnotationInfo;
#line 564
struct _GDBusArgInfo ;
#line 564 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusArgInfo GDBusArgInfo;
#line 565
struct _GDBusMethodInfo ;
#line 565 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusMethodInfo GDBusMethodInfo;
#line 566
struct _GDBusSignalInfo ;
#line 566 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusSignalInfo GDBusSignalInfo;
#line 567
struct _GDBusPropertyInfo ;
#line 567 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusPropertyInfo GDBusPropertyInfo;
#line 568
struct _GDBusInterfaceInfo ;
#line 568 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceInfo GDBusInterfaceInfo;
#line 569
struct _GDBusNodeInfo ;
#line 569 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusNodeInfo GDBusNodeInfo;
#line 583 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GCancellableSourceFunc)(GCancellable * , gpointer  );
#line 599 "/usr/include/glib-2.0/gio/giotypes.h"
typedef gboolean (*GPollableSourceFunc)(GObject * , gpointer  );
#line 602
struct _GDBusInterface ;
#line 602 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterface GDBusInterface;
#line 603
struct _GDBusInterfaceSkeleton ;
#line 603 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusInterfaceSkeleton GDBusInterfaceSkeleton;
#line 604
struct _GDBusObject ;
#line 604 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObject GDBusObject;
#line 605
struct _GDBusObjectSkeleton ;
#line 605 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectSkeleton GDBusObjectSkeleton;
#line 606
struct _GDBusObjectProxy ;
#line 606 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectProxy GDBusObjectProxy;
#line 607
struct _GDBusObjectManager ;
#line 607 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManager GDBusObjectManager;
#line 608
struct _GDBusObjectManagerClient ;
#line 608 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManagerClient GDBusObjectManagerClient;
#line 609
struct _GDBusObjectManagerServer ;
#line 609 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GDBusObjectManagerServer GDBusObjectManagerServer;
#line 632 "/usr/include/glib-2.0/gio/giotypes.h"
typedef GType (*GDBusProxyTypeFunc)(GDBusObjectManagerClient * , gchar * , gchar * ,
                                    gpointer  );
#line 637
struct _GTestDBus ;
#line 637 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GTestDBus GTestDBus;
#line 646
struct _GSubprocess ;
#line 646 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSubprocess GSubprocess;
#line 654
struct _GSubprocessLauncher ;
#line 654 "/usr/include/glib-2.0/gio/giotypes.h"
typedef struct _GSubprocessLauncher GSubprocessLauncher;
#line 38 "/usr/include/glib-2.0/gio/gaction.h"
struct _GActionInterface ;
#line 38 "/usr/include/glib-2.0/gio/gaction.h"
typedef struct _GActionInterface GActionInterface;
#line 40 "/usr/include/glib-2.0/gio/gaction.h"
struct _GActionInterface {
   GTypeInterface g_iface ;
   gchar *(*get_name)(GAction * ) ;
   GVariantType *(*get_parameter_type)(GAction * ) ;
   GVariantType *(*get_state_type)(GAction * ) ;
   GVariant *(*get_state_hint)(GAction * ) ;
   gboolean (*get_enabled)(GAction * ) ;
   GVariant *(*get_state)(GAction * ) ;
   void (*change_state)(GAction * , GVariant * ) ;
   void (*activate)(GAction * , GVariant * ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gactiongroup.h"
struct _GActionGroupInterface ;
#line 40 "/usr/include/glib-2.0/gio/gactiongroup.h"
typedef struct _GActionGroupInterface GActionGroupInterface;
#line 42 "/usr/include/glib-2.0/gio/gactiongroup.h"
struct _GActionGroupInterface {
   GTypeInterface g_iface ;
   gboolean (*has_action)(GActionGroup * , gchar * ) ;
   gchar **(*list_actions)(GActionGroup * ) ;
   gboolean (*get_action_enabled)(GActionGroup * , gchar * ) ;
   GVariantType *(*get_action_parameter_type)(GActionGroup * , gchar * ) ;
   GVariantType *(*get_action_state_type)(GActionGroup * , gchar * ) ;
   GVariant *(*get_action_state_hint)(GActionGroup * , gchar * ) ;
   GVariant *(*get_action_state)(GActionGroup * , gchar * ) ;
   void (*change_action_state)(GActionGroup * , gchar * , GVariant * ) ;
   void (*activate_action)(GActionGroup * , gchar * , GVariant * ) ;
   void (*action_added)(GActionGroup * , gchar * ) ;
   void (*action_removed)(GActionGroup * , gchar * ) ;
   void (*action_enabled_changed)(GActionGroup * , gchar * , gboolean  ) ;
   void (*action_state_changed)(GActionGroup * , gchar * , GVariant * ) ;
   gboolean (*query_action)(GActionGroup * , gchar * , gboolean * , GVariantType ** ,
                            GVariantType ** , GVariant ** , GVariant ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionMapInterface ;
#line 40 "/usr/include/glib-2.0/gio/gactionmap.h"
typedef struct _GActionMapInterface GActionMapInterface;
#line 41
struct _GActionEntry ;
#line 41 "/usr/include/glib-2.0/gio/gactionmap.h"
typedef struct _GActionEntry GActionEntry;
#line 43 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionMapInterface {
   GTypeInterface g_iface ;
   GAction *(*lookup_action)(GActionMap * , gchar * ) ;
   void (*add_action)(GActionMap * , GAction * ) ;
   void (*remove_action)(GActionMap * , gchar * ) ;
};
#line 55 "/usr/include/glib-2.0/gio/gactionmap.h"
struct _GActionEntry {
   gchar *name ;
   void (*activate)(GSimpleAction * , GVariant * , gpointer  ) ;
   gchar *parameter_type ;
   gchar *state ;
   void (*change_state)(GSimpleAction * , GVariant * , gpointer  ) ;
   gsize padding[3] ;
};
#line 44 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContextClass ;
#line 44 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppLaunchContextClass GAppLaunchContextClass;
#line 45
struct _GAppLaunchContextPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppLaunchContextPrivate GAppLaunchContextPrivate;
#line 86
struct _GAppInfoIface ;
#line 86 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppInfoIface GAppInfoIface;
#line 88 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppInfoIface {
   GTypeInterface g_iface ;
   GAppInfo *(*dup)(GAppInfo * ) ;
   gboolean (*equal)(GAppInfo * , GAppInfo * ) ;
   char const   *(*get_id)(GAppInfo * ) ;
   char const   *(*get_name)(GAppInfo * ) ;
   char const   *(*get_description)(GAppInfo * ) ;
   char const   *(*get_executable)(GAppInfo * ) ;
   GIcon *(*get_icon)(GAppInfo * ) ;
   gboolean (*launch)(GAppInfo * , GList * , GAppLaunchContext * , GError ** ) ;
   gboolean (*supports_uris)(GAppInfo * ) ;
   gboolean (*supports_files)(GAppInfo * ) ;
   gboolean (*launch_uris)(GAppInfo * , GList * , GAppLaunchContext * , GError ** ) ;
   gboolean (*should_show)(GAppInfo * ) ;
   gboolean (*set_as_default_for_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*set_as_default_for_extension)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*add_supports_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*can_remove_supports_type)(GAppInfo * ) ;
   gboolean (*remove_supports_type)(GAppInfo * , char const   * , GError ** ) ;
   gboolean (*can_delete)(GAppInfo * ) ;
   gboolean (*do_delete)(GAppInfo * ) ;
   char const   *(*get_commandline)(GAppInfo * ) ;
   char const   *(*get_display_name)(GAppInfo * ) ;
   gboolean (*set_as_last_used_for_type)(GAppInfo * , char const   * , GError ** ) ;
   char const   **(*get_supported_types)(GAppInfo * ) ;
   void (*launch_uris_async)(GAppInfo * , GList * , GAppLaunchContext * , GCancellable * ,
                             GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*launch_uris_finish)(GAppInfo * , GAsyncResult * , GError ** ) ;
};
#line 273 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContext {
   GObject parent_instance ;
   GAppLaunchContextPrivate *priv ;
};
#line 281 "/usr/include/glib-2.0/gio/gappinfo.h"
struct _GAppLaunchContextClass {
   GObjectClass parent_class ;
   char *(*get_display)(GAppLaunchContext * , GAppInfo * , GList * ) ;
   char *(*get_startup_notify_id)(GAppLaunchContext * , GAppInfo * , GList * ) ;
   void (*launch_failed)(GAppLaunchContext * , char const   * ) ;
   void (*launched)(GAppLaunchContext * , GAppInfo * , GVariant * ) ;
   void (*launch_started)(GAppLaunchContext * , GAppInfo * , GVariant * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 339
struct _GAppInfoMonitor ;
#line 339 "/usr/include/glib-2.0/gio/gappinfo.h"
typedef struct _GAppInfoMonitor GAppInfoMonitor;
#line 41 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplicationPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gapplication.h"
typedef struct _GApplicationPrivate GApplicationPrivate;
#line 42
struct _GApplicationClass ;
#line 42 "/usr/include/glib-2.0/gio/gapplication.h"
typedef struct _GApplicationClass GApplicationClass;
#line 44 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplication {
   GObject parent_instance ;
   GApplicationPrivate *priv ;
};
#line 52 "/usr/include/glib-2.0/gio/gapplication.h"
struct _GApplicationClass {
   GObjectClass parent_class ;
   void (*startup)(GApplication * ) ;
   void (*activate)(GApplication * ) ;
   void (*open)(GApplication * , GFile ** , gint  , gchar * ) ;
   int (*command_line)(GApplication * , GApplicationCommandLine * ) ;
   gboolean (*local_command_line)(GApplication * , gchar *** , int * ) ;
   void (*before_emit)(GApplication * , GVariant * ) ;
   void (*after_emit)(GApplication * , GVariant * ) ;
   void (*add_platform_data)(GApplication * , GVariantBuilder * ) ;
   void (*quit_mainloop)(GApplication * ) ;
   void (*run_mainloop)(GApplication * ) ;
   void (*shutdown)(GApplication * ) ;
   gboolean (*dbus_register)(GApplication * , GDBusConnection * , gchar * , GError ** ) ;
   void (*dbus_unregister)(GApplication * , GDBusConnection * , gchar * ) ;
   gint (*handle_local_options)(GApplication * , GVariantDict * ) ;
   gboolean (*name_lost)(GApplication * ) ;
   gpointer padding[7] ;
};
#line 47 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLinePrivate ;
#line 47 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
typedef struct _GApplicationCommandLinePrivate GApplicationCommandLinePrivate;
#line 48
struct _GApplicationCommandLineClass ;
#line 48 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
typedef struct _GApplicationCommandLineClass GApplicationCommandLineClass;
#line 50 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLine {
   GObject parent_instance ;
   GApplicationCommandLinePrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
struct _GApplicationCommandLineClass {
   GObjectClass parent_class ;
   void (*print_literal)(GApplicationCommandLine * , gchar * ) ;
   void (*printerr_literal)(GApplicationCommandLine * , gchar * ) ;
   GInputStream *(*get_stdin)(GApplicationCommandLine * ) ;
   gpointer padding[11] ;
};
#line 45 "/usr/include/glib-2.0/gio/ginitable.h"
struct _GInitableIface ;
#line 45 "/usr/include/glib-2.0/gio/ginitable.h"
typedef struct _GInitableIface GInitableIface;
#line 57 "/usr/include/glib-2.0/gio/ginitable.h"
struct _GInitableIface {
   GTypeInterface g_iface ;
   gboolean (*init)(GInitable * , GCancellable * , GError ** ) ;
};
#line 46 "/usr/include/glib-2.0/gio/gasyncinitable.h"
struct _GAsyncInitableIface ;
#line 46 "/usr/include/glib-2.0/gio/gasyncinitable.h"
typedef struct _GAsyncInitableIface GAsyncInitableIface;
#line 59 "/usr/include/glib-2.0/gio/gasyncinitable.h"
struct _GAsyncInitableIface {
   GTypeInterface g_iface ;
   void (*init_async)(GAsyncInitable * , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*init_finish)(GAsyncInitable * , GAsyncResult * , GError ** ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gasyncresult.h"
struct _GAsyncResultIface ;
#line 43 "/usr/include/glib-2.0/gio/gasyncresult.h"
typedef struct _GAsyncResultIface GAsyncResultIface;
#line 55 "/usr/include/glib-2.0/gio/gasyncresult.h"
struct _GAsyncResultIface {
   GTypeInterface g_iface ;
   gpointer (*get_user_data)(GAsyncResult * ) ;
   GObject *(*get_source_object)(GAsyncResult * ) ;
   gboolean (*is_tagged)(GAsyncResult * , gpointer  ) ;
};
#line 44 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/ginputstream.h"
typedef struct _GInputStreamClass GInputStreamClass;
#line 45
struct _GInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/ginputstream.h"
typedef struct _GInputStreamPrivate GInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStream {
   GObject parent_instance ;
   GInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/ginputstream.h"
struct _GInputStreamClass {
   GObjectClass parent_class ;
   gssize (*read_fn)(GInputStream * , void * , gsize  , GCancellable * , GError ** ) ;
   gssize (*skip)(GInputStream * , gsize  , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GInputStream * , GCancellable * , GError ** ) ;
   void (*read_async)(GInputStream * , void * , gsize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*read_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*skip_async)(GInputStream * , gsize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*skip_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GInputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
typedef struct _GFilterInputStreamClass GFilterInputStreamClass;
#line 46 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStream {
   GInputStream parent_instance ;
   GInputStream *base_stream ;
};
#line 54 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
struct _GFilterInputStreamClass {
   GInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
typedef struct _GBufferedInputStreamClass GBufferedInputStreamClass;
#line 45
struct _GBufferedInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
typedef struct _GBufferedInputStreamPrivate GBufferedInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStream {
   GFilterInputStream parent_instance ;
   GBufferedInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
struct _GBufferedInputStreamClass {
   GFilterInputStreamClass parent_class ;
   gssize (*fill)(GBufferedInputStream * , gssize  , GCancellable * , GError ** ) ;
   void (*fill_async)(GBufferedInputStream * , gssize  , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gssize (*fill_finish)(GBufferedInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 48 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStreamClass ;
#line 48 "/usr/include/glib-2.0/gio/goutputstream.h"
typedef struct _GOutputStreamClass GOutputStreamClass;
#line 49
struct _GOutputStreamPrivate ;
#line 49 "/usr/include/glib-2.0/gio/goutputstream.h"
typedef struct _GOutputStreamPrivate GOutputStreamPrivate;
#line 51 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStream {
   GObject parent_instance ;
   GOutputStreamPrivate *priv ;
};
#line 60 "/usr/include/glib-2.0/gio/goutputstream.h"
struct _GOutputStreamClass {
   GObjectClass parent_class ;
   gssize (*write_fn)(GOutputStream * , void const   * , gsize  , GCancellable * ,
                      GError ** ) ;
   gssize (*splice)(GOutputStream * , GInputStream * , GOutputStreamSpliceFlags  ,
                    GCancellable * , GError ** ) ;
   gboolean (*flush)(GOutputStream * , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GOutputStream * , GCancellable * , GError ** ) ;
   void (*write_async)(GOutputStream * , void const   * , gsize  , int  , GCancellable * ,
                       GAsyncReadyCallback  , gpointer  ) ;
   gssize (*write_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*splice_async)(GOutputStream * , GInputStream * , GOutputStreamSpliceFlags  ,
                        int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gssize (*splice_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*flush_async)(GOutputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*flush_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GOutputStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GOutputStream * , GAsyncResult * , GError ** ) ;
   gboolean (*writev_fn)(GOutputStream * , GOutputVector * , gsize  , gsize * , GCancellable * ,
                         GError ** ) ;
   void (*writev_async)(GOutputStream * , GOutputVector * , gsize  , int  , GCancellable * ,
                        GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*writev_finish)(GOutputStream * , GAsyncResult * , gsize * , GError ** ) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
typedef struct _GFilterOutputStreamClass GFilterOutputStreamClass;
#line 46 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStream {
   GOutputStream parent_instance ;
   GOutputStream *base_stream ;
};
#line 54 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
struct _GFilterOutputStreamClass {
   GOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
typedef struct _GBufferedOutputStreamClass GBufferedOutputStreamClass;
#line 45
struct _GBufferedOutputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
typedef struct _GBufferedOutputStreamPrivate GBufferedOutputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStream {
   GFilterOutputStream parent_instance ;
   GBufferedOutputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
struct _GBufferedOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellableClass ;
#line 44 "/usr/include/glib-2.0/gio/gcancellable.h"
typedef struct _GCancellableClass GCancellableClass;
#line 45
struct _GCancellablePrivate ;
#line 45 "/usr/include/glib-2.0/gio/gcancellable.h"
typedef struct _GCancellablePrivate GCancellablePrivate;
#line 47 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellable {
   GObject parent_instance ;
   GCancellablePrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gcancellable.h"
struct _GCancellableClass {
   GObjectClass parent_class ;
   void (*cancelled)(GCancellable * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gconverter.h"
struct _GConverterIface ;
#line 44 "/usr/include/glib-2.0/gio/gconverter.h"
typedef struct _GConverterIface GConverterIface;
#line 58 "/usr/include/glib-2.0/gio/gconverter.h"
struct _GConverterIface {
   GTypeInterface g_iface ;
   GConverterResult (*convert)(GConverter * , void const   * , gsize  , void * , gsize  ,
                               GConverterFlags  , gsize * , gsize * , GError ** ) ;
   void (*reset)(GConverter * ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
struct _GCharsetConverterClass ;
#line 39 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
typedef struct _GCharsetConverterClass GCharsetConverterClass;
#line 41 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
struct _GCharsetConverterClass {
   GObjectClass parent_class ;
};
#line 46 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
typedef struct _GConverterInputStreamClass GConverterInputStreamClass;
#line 47
struct _GConverterInputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
typedef struct _GConverterInputStreamPrivate GConverterInputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStream {
   GFilterInputStream parent_instance ;
   GConverterInputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
struct _GConverterInputStreamClass {
   GFilterInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 46 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
typedef struct _GConverterOutputStreamClass GConverterOutputStreamClass;
#line 47
struct _GConverterOutputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
typedef struct _GConverterOutputStreamPrivate GConverterOutputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStream {
   GFilterOutputStream parent_instance ;
   GConverterOutputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
struct _GConverterOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gcredentials.h"
struct _GCredentialsClass ;
#line 45 "/usr/include/glib-2.0/gio/gcredentials.h"
typedef struct _GCredentialsClass GCredentialsClass;
#line 49 "/usr/include/glib-2.0/gio/gdatagrambased.h"
struct _GDatagramBasedInterface ;
#line 49 "/usr/include/glib-2.0/gio/gdatagrambased.h"
typedef struct _GDatagramBasedInterface GDatagramBasedInterface;
#line 69 "/usr/include/glib-2.0/gio/gdatagrambased.h"
struct _GDatagramBasedInterface {
   GTypeInterface g_iface ;
   gint (*receive_messages)(GDatagramBased * , GInputMessage * , guint  , gint  ,
                            gint64  , GCancellable * , GError ** ) ;
   gint (*send_messages)(GDatagramBased * , GOutputMessage * , guint  , gint  , gint64  ,
                         GCancellable * , GError ** ) ;
   GSource *(*create_source)(GDatagramBased * , GIOCondition  , GCancellable * ) ;
   GIOCondition (*condition_check)(GDatagramBased * , GIOCondition  ) ;
   gboolean (*condition_wait)(GDatagramBased * , GIOCondition  , gint64  , GCancellable * ,
                              GError ** ) ;
};
#line 45 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStreamClass ;
#line 45 "/usr/include/glib-2.0/gio/gdatainputstream.h"
typedef struct _GDataInputStreamClass GDataInputStreamClass;
#line 46
struct _GDataInputStreamPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gdatainputstream.h"
typedef struct _GDataInputStreamPrivate GDataInputStreamPrivate;
#line 48 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStream {
   GBufferedInputStream parent_instance ;
   GDataInputStreamPrivate *priv ;
};
#line 56 "/usr/include/glib-2.0/gio/gdatainputstream.h"
struct _GDataInputStreamClass {
   GBufferedInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStream ;
#line 45 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStream GDataOutputStream;
#line 46
struct _GDataOutputStreamClass ;
#line 46 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStreamClass GDataOutputStreamClass;
#line 47
struct _GDataOutputStreamPrivate ;
#line 47 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
typedef struct _GDataOutputStreamPrivate GDataOutputStreamPrivate;
#line 49 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStream {
   GFilterOutputStream parent_instance ;
   GDataOutputStreamPrivate *priv ;
};
#line 57 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
struct _GDataOutputStreamClass {
   GFilterOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 273 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef void (*GDBusInterfaceMethodCallFunc)(GDBusConnection * , gchar * , gchar * ,
                                             gchar * , gchar * , GVariant * , GDBusMethodInvocation * ,
                                             gpointer  );
#line 300 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GVariant *(*GDBusInterfaceGetPropertyFunc)(GDBusConnection * , gchar * , gchar * ,
                                                   gchar * , gchar * , GError ** ,
                                                   gpointer  );
#line 325 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef gboolean (*GDBusInterfaceSetPropertyFunc)(GDBusConnection * , gchar * , gchar * ,
                                                  gchar * , gchar * , GVariant * ,
                                                  GError ** , gpointer  );
#line 384 "/usr/include/glib-2.0/gio/gdbusconnection.h"
struct _GDBusInterfaceVTable {
   GDBusInterfaceMethodCallFunc method_call ;
   GDBusInterfaceGetPropertyFunc get_property ;
   GDBusInterfaceSetPropertyFunc set_property ;
   gpointer padding[8] ;
};
#line 443 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef gchar **(*GDBusSubtreeEnumerateFunc)(GDBusConnection * , gchar * , gchar * ,
                                             gpointer  );
#line 479 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusInterfaceInfo **(*GDBusSubtreeIntrospectFunc)(GDBusConnection * , gchar * ,
                                                           gchar * , gchar * , gpointer  );
#line 504 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusInterfaceVTable *(*GDBusSubtreeDispatchFunc)(GDBusConnection * , gchar * ,
                                                          gchar * , gchar * , gchar * ,
                                                          gpointer * , gpointer  );
#line 522 "/usr/include/glib-2.0/gio/gdbusconnection.h"
struct _GDBusSubtreeVTable {
   GDBusSubtreeEnumerateFunc enumerate ;
   GDBusSubtreeIntrospectFunc introspect ;
   GDBusSubtreeDispatchFunc dispatch ;
   gpointer padding[8] ;
};
#line 565 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef void (*GDBusSignalCallback)(GDBusConnection * , gchar * , gchar * , gchar * ,
                                    gchar * , GVariant * , gpointer  );
#line 664 "/usr/include/glib-2.0/gio/gdbusconnection.h"
typedef GDBusMessage *(*GDBusMessageFilterFunction)(GDBusConnection * , GDBusMessage * ,
                                                    gboolean  , gpointer  );
#line 68 "/usr/include/glib-2.0/gio/gdbuserror.h"
struct _GDBusErrorEntry {
   gint error_code ;
   gchar *dbus_error_name ;
};
#line 41 "/usr/include/glib-2.0/gio/gdbusinterface.h"
struct _GDBusInterfaceIface ;
#line 41 "/usr/include/glib-2.0/gio/gdbusinterface.h"
typedef struct _GDBusInterfaceIface GDBusInterfaceIface;
#line 55 "/usr/include/glib-2.0/gio/gdbusinterface.h"
struct _GDBusInterfaceIface {
   GTypeInterface parent_iface ;
   GDBusInterfaceInfo *(*get_info)(GDBusInterface * ) ;
   GDBusObject *(*get_object)(GDBusInterface * ) ;
   void (*set_object)(GDBusInterface * , GDBusObject * ) ;
   GDBusObject *(*dup_object)(GDBusInterface * ) ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeletonClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
typedef struct _GDBusInterfaceSkeletonClass GDBusInterfaceSkeletonClass;
#line 36
struct _GDBusInterfaceSkeletonPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
typedef struct _GDBusInterfaceSkeletonPrivate GDBusInterfaceSkeletonPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeleton {
   GObject parent_instance ;
   GDBusInterfaceSkeletonPrivate *priv ;
};
#line 66 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
struct _GDBusInterfaceSkeletonClass {
   GObjectClass parent_class ;
   GDBusInterfaceInfo *(*get_info)(GDBusInterfaceSkeleton * ) ;
   GDBusInterfaceVTable *(*get_vtable)(GDBusInterfaceSkeleton * ) ;
   GVariant *(*get_properties)(GDBusInterfaceSkeleton * ) ;
   void (*flush)(GDBusInterfaceSkeleton * ) ;
   gpointer vfunc_padding[8] ;
   gboolean (*g_authorize_method)(GDBusInterfaceSkeleton * , GDBusMethodInvocation * ) ;
   gpointer signal_padding[8] ;
};
#line 43 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusAnnotationInfo {
   gint ref_count ;
   gchar *key ;
   gchar *value ;
   GDBusAnnotationInfo **annotations ;
};
#line 63 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusArgInfo {
   gint ref_count ;
   gchar *name ;
   gchar *signature ;
   GDBusAnnotationInfo **annotations ;
};
#line 84 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusMethodInfo {
   gint ref_count ;
   gchar *name ;
   GDBusArgInfo **in_args ;
   GDBusArgInfo **out_args ;
   GDBusAnnotationInfo **annotations ;
};
#line 105 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusSignalInfo {
   gint ref_count ;
   gchar *name ;
   GDBusArgInfo **args ;
   GDBusAnnotationInfo **annotations ;
};
#line 126 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusPropertyInfo {
   gint ref_count ;
   gchar *name ;
   gchar *signature ;
   GDBusPropertyInfoFlags flags ;
   GDBusAnnotationInfo **annotations ;
};
#line 149 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusInterfaceInfo {
   gint ref_count ;
   gchar *name ;
   GDBusMethodInfo **methods ;
   GDBusSignalInfo **signals ;
   GDBusPropertyInfo **properties ;
   GDBusAnnotationInfo **annotations ;
};
#line 172 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
struct _GDBusNodeInfo {
   gint ref_count ;
   gchar *path ;
   GDBusInterfaceInfo **interfaces ;
   GDBusNodeInfo **nodes ;
   GDBusAnnotationInfo **annotations ;
};
#line 33 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
struct _GDBusMenuModel ;
#line 33 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
typedef struct _GDBusMenuModel GDBusMenuModel;
#line 42 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusAcquiredCallback)(GDBusConnection * , gchar * , gpointer  );
#line 56 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusNameAcquiredCallback)(GDBusConnection * , gchar * , gpointer  );
#line 71 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
typedef void (*GBusNameLostCallback)(GDBusConnection * , gchar * , gpointer  );
#line 43 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
typedef void (*GBusNameAppearedCallback)(GDBusConnection * , gchar * , gchar * , gpointer  );
#line 63 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
typedef void (*GBusNameVanishedCallback)(GDBusConnection * , gchar * , gpointer  );
#line 33 "/usr/include/glib-2.0/gio/gdbusobject.h"
struct _GDBusObjectIface ;
#line 33 "/usr/include/glib-2.0/gio/gdbusobject.h"
typedef struct _GDBusObjectIface GDBusObjectIface;
#line 48 "/usr/include/glib-2.0/gio/gdbusobject.h"
struct _GDBusObjectIface {
   GTypeInterface parent_iface ;
   gchar *(*get_object_path)(GDBusObject * ) ;
   GList *(*get_interfaces)(GDBusObject * ) ;
   GDBusInterface *(*get_interface)(GDBusObject * , gchar * ) ;
   void (*interface_added)(GDBusObject * , GDBusInterface * ) ;
   void (*interface_removed)(GDBusObject * , GDBusInterface * ) ;
};
#line 33 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
struct _GDBusObjectManagerIface ;
#line 33 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
typedef struct _GDBusObjectManagerIface GDBusObjectManagerIface;
#line 51 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
struct _GDBusObjectManagerIface {
   GTypeInterface parent_iface ;
   gchar *(*get_object_path)(GDBusObjectManager * ) ;
   GList *(*get_objects)(GDBusObjectManager * ) ;
   GDBusObject *(*get_object)(GDBusObjectManager * , gchar * ) ;
   GDBusInterface *(*get_interface)(GDBusObjectManager * , gchar * , gchar * ) ;
   void (*object_added)(GDBusObjectManager * , GDBusObject * ) ;
   void (*object_removed)(GDBusObjectManager * , GDBusObject * ) ;
   void (*interface_added)(GDBusObjectManager * , GDBusObject * , GDBusInterface * ) ;
   void (*interface_removed)(GDBusObjectManager * , GDBusObject * , GDBusInterface * ) ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClientClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
typedef struct _GDBusObjectManagerClientClass GDBusObjectManagerClientClass;
#line 36
struct _GDBusObjectManagerClientPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
typedef struct _GDBusObjectManagerClientPrivate GDBusObjectManagerClientPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClient {
   GObject parent_instance ;
   GDBusObjectManagerClientPrivate *priv ;
};
#line 63 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
struct _GDBusObjectManagerClientClass {
   GObjectClass parent_class ;
   void (*interface_proxy_signal)(GDBusObjectManagerClient * , GDBusObjectProxy * ,
                                  GDBusProxy * , gchar * , gchar * , GVariant * ) ;
   void (*interface_proxy_properties_changed)(GDBusObjectManagerClient * , GDBusObjectProxy * ,
                                              GDBusProxy * , GVariant * , gchar * const  * ) ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServerClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
typedef struct _GDBusObjectManagerServerClass GDBusObjectManagerServerClass;
#line 36
struct _GDBusObjectManagerServerPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
typedef struct _GDBusObjectManagerServerPrivate GDBusObjectManagerServerPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServer {
   GObject parent_instance ;
   GDBusObjectManagerServerPrivate *priv ;
};
#line 61 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
struct _GDBusObjectManagerServerClass {
   GObjectClass parent_class ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxyClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
typedef struct _GDBusObjectProxyClass GDBusObjectProxyClass;
#line 36
struct _GDBusObjectProxyPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
typedef struct _GDBusObjectProxyPrivate GDBusObjectProxyPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxy {
   GObject parent_instance ;
   GDBusObjectProxyPrivate *priv ;
};
#line 61 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
struct _GDBusObjectProxyClass {
   GObjectClass parent_class ;
   gpointer padding[8] ;
};
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeletonClass ;
#line 35 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
typedef struct _GDBusObjectSkeletonClass GDBusObjectSkeletonClass;
#line 36
struct _GDBusObjectSkeletonPrivate ;
#line 36 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
typedef struct _GDBusObjectSkeletonPrivate GDBusObjectSkeletonPrivate;
#line 46 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeleton {
   GObject parent_instance ;
   GDBusObjectSkeletonPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
struct _GDBusObjectSkeletonClass {
   GObjectClass parent_class ;
   gboolean (*authorize_method)(GDBusObjectSkeleton * , GDBusInterfaceSkeleton * ,
                                GDBusMethodInvocation * ) ;
   gpointer padding[8] ;
};
#line 40 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxyClass ;
#line 40 "/usr/include/glib-2.0/gio/gdbusproxy.h"
typedef struct _GDBusProxyClass GDBusProxyClass;
#line 41
struct _GDBusProxyPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gdbusproxy.h"
typedef struct _GDBusProxyPrivate GDBusProxyPrivate;
#line 51 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxy {
   GObject parent_instance ;
   GDBusProxyPrivate *priv ;
};
#line 67 "/usr/include/glib-2.0/gio/gdbusproxy.h"
struct _GDBusProxyClass {
   GObjectClass parent_class ;
   void (*g_properties_changed)(GDBusProxy * , GVariant * , gchar * const  * ) ;
   void (*g_signal)(GDBusProxy * , gchar * , gchar * , GVariant * ) ;
   gpointer padding[32] ;
};
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
struct _GDebugController ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef struct _GDebugController GDebugController;
#line 52
struct _GDebugControllerInterface ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef struct _GDebugControllerInterface GDebugControllerInterface;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GDebugController *GDebugController_autoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GList *GDebugController_listautoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GSList *GDebugController_slistautoptr;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
typedef GQueue *GDebugController_queueautoptr;
#line 66 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
struct _GDebugControllerInterface {
   GTypeInterface g_iface ;
};
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBus ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef struct _GDebugControllerDBus GDebugControllerDBus;
#line 38
struct _GDebugControllerDBusClass ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef struct _GDebugControllerDBusClass GDebugControllerDBusClass;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBus {
   GObject parent_instance ;
};
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GDebugControllerDBus *GDebugControllerDBus_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GList *GDebugControllerDBus_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GSList *GDebugControllerDBus_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GQueue *GDebugControllerDBus_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GDebugControllerDBusClass *GDebugControllerDBusClass_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GList *GDebugControllerDBusClass_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GSList *GDebugControllerDBusClass_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
typedef GQueue *GDebugControllerDBusClass_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
struct _GDebugControllerDBusClass {
   GObjectClass parent_class ;
   gboolean (*authorize)(GDebugControllerDBus * , GDBusMethodInvocation * ) ;
   gpointer padding[12] ;
};
#line 87 "/usr/include/glib-2.0/gio/gdrive.h"
struct _GDriveIface ;
#line 87 "/usr/include/glib-2.0/gio/gdrive.h"
typedef struct _GDriveIface GDriveIface;
#line 89 "/usr/include/glib-2.0/gio/gdrive.h"
struct _GDriveIface {
   GTypeInterface g_iface ;
   void (*changed)(GDrive * ) ;
   void (*disconnected)(GDrive * ) ;
   void (*eject_button)(GDrive * ) ;
   char *(*get_name)(GDrive * ) ;
   GIcon *(*get_icon)(GDrive * ) ;
   gboolean (*has_volumes)(GDrive * ) ;
   GList *(*get_volumes)(GDrive * ) ;
   gboolean (*is_media_removable)(GDrive * ) ;
   gboolean (*has_media)(GDrive * ) ;
   gboolean (*is_media_check_automatic)(GDrive * ) ;
   gboolean (*can_eject)(GDrive * ) ;
   gboolean (*can_poll_for_media)(GDrive * ) ;
   void (*eject)(GDrive * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   void (*poll_for_media)(GDrive * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*poll_for_media_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   char *(*get_identifier)(GDrive * , char const   * ) ;
   char **(*enumerate_identifiers)(GDrive * ) ;
   GDriveStartStopType (*get_start_stop_type)(GDrive * ) ;
   gboolean (*can_start)(GDrive * ) ;
   gboolean (*can_start_degraded)(GDrive * ) ;
   void (*start)(GDrive * , GDriveStartFlags  , GMountOperation * , GCancellable * ,
                 GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*start_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   gboolean (*can_stop)(GDrive * ) ;
   void (*stop)(GDrive * , GMountUnmountFlags  , GMountOperation * , GCancellable * ,
                GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*stop_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   void (*stop_button)(GDrive * ) ;
   void (*eject_with_operation)(GDrive * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GDrive * , GAsyncResult * , GError ** ) ;
   gchar *(*get_sort_key)(GDrive * ) ;
   GIcon *(*get_symbolic_icon)(GDrive * ) ;
   gboolean (*is_removable)(GDrive * ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
struct _GDtlsConnectionInterface ;
#line 36 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
typedef struct _GDtlsConnectionInterface GDtlsConnectionInterface;
#line 56 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
struct _GDtlsConnectionInterface {
   GTypeInterface g_iface ;
   gboolean (*accept_certificate)(GDtlsConnection * , GTlsCertificate * , GTlsCertificateFlags  ) ;
   gboolean (*handshake)(GDtlsConnection * , GCancellable * , GError ** ) ;
   void (*handshake_async)(GDtlsConnection * , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*handshake_finish)(GDtlsConnection * , GAsyncResult * , GError ** ) ;
   gboolean (*shutdown)(GDtlsConnection * , gboolean  , gboolean  , GCancellable * ,
                        GError ** ) ;
   void (*shutdown_async)(GDtlsConnection * , gboolean  , gboolean  , int  , GCancellable * ,
                          GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*shutdown_finish)(GDtlsConnection * , GAsyncResult * , GError ** ) ;
   void (*set_advertised_protocols)(GDtlsConnection * , gchar * const  * ) ;
   gchar *(*get_negotiated_protocol)(GDtlsConnection * ) ;
   gboolean (*get_binding_data)(GDtlsConnection * , GTlsChannelBindingType  , GByteArray * ,
                                GError ** ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
struct _GDtlsClientConnectionInterface ;
#line 36 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
typedef struct _GDtlsClientConnectionInterface GDtlsClientConnectionInterface;
#line 46 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
struct _GDtlsClientConnectionInterface {
   GTypeInterface g_iface ;
};
#line 44 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
struct _GDtlsServerConnectionInterface ;
#line 44 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
typedef struct _GDtlsServerConnectionInterface GDtlsServerConnectionInterface;
#line 54 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
struct _GDtlsServerConnectionInterface {
   GTypeInterface g_iface ;
};
#line 42 "/usr/include/glib-2.0/gio/gicon.h"
struct _GIconIface ;
#line 42 "/usr/include/glib-2.0/gio/gicon.h"
typedef struct _GIconIface GIconIface;
#line 61 "/usr/include/glib-2.0/gio/gicon.h"
struct _GIconIface {
   GTypeInterface g_iface ;
   guint (*hash)(GIcon * ) ;
   gboolean (*equal)(GIcon * , GIcon * ) ;
   gboolean (*to_tokens)(GIcon * , GPtrArray * , gint * ) ;
   GIcon *(*from_tokens)(gchar ** , gint  , gint  , GError ** ) ;
   GVariant *(*serialize)(GIcon * ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gemblem.h"
struct _GEmblem ;
#line 43 "/usr/include/glib-2.0/gio/gemblem.h"
typedef struct _GEmblem GEmblem;
#line 44
struct _GEmblemClass ;
#line 44 "/usr/include/glib-2.0/gio/gemblem.h"
typedef struct _GEmblemClass GEmblemClass;
#line 46 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIcon ;
#line 46 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIcon GEmblemedIcon;
#line 47
struct _GEmblemedIconClass ;
#line 47 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIconClass GEmblemedIconClass;
#line 48
struct _GEmblemedIconPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gemblemedicon.h"
typedef struct _GEmblemedIconPrivate GEmblemedIconPrivate;
#line 50 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIcon {
   GObject parent_instance ;
   GEmblemedIconPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gemblemedicon.h"
struct _GEmblemedIconClass {
   GObjectClass parent_class ;
};
#line 47 "/usr/include/glib-2.0/gio/gfile.h"
struct _GFileIface ;
#line 47 "/usr/include/glib-2.0/gio/gfile.h"
typedef struct _GFileIface GFileIface;
#line 162 "/usr/include/glib-2.0/gio/gfile.h"
struct _GFileIface {
   GTypeInterface g_iface ;
   GFile *(*dup)(GFile * ) ;
   guint (*hash)(GFile * ) ;
   gboolean (*equal)(GFile * , GFile * ) ;
   gboolean (*is_native)(GFile * ) ;
   gboolean (*has_uri_scheme)(GFile * , char const   * ) ;
   char *(*get_uri_scheme)(GFile * ) ;
   char *(*get_basename)(GFile * ) ;
   char *(*get_path)(GFile * ) ;
   char *(*get_uri)(GFile * ) ;
   char *(*get_parse_name)(GFile * ) ;
   GFile *(*get_parent)(GFile * ) ;
   gboolean (*prefix_matches)(GFile * , GFile * ) ;
   char *(*get_relative_path)(GFile * , GFile * ) ;
   GFile *(*resolve_relative_path)(GFile * , char const   * ) ;
   GFile *(*get_child_for_display_name)(GFile * , char const   * , GError ** ) ;
   GFileEnumerator *(*enumerate_children)(GFile * , char const   * , GFileQueryInfoFlags  ,
                                          GCancellable * , GError ** ) ;
   void (*enumerate_children_async)(GFile * , char const   * , GFileQueryInfoFlags  ,
                                    int  , GCancellable * , GAsyncReadyCallback  ,
                                    gpointer  ) ;
   GFileEnumerator *(*enumerate_children_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileInfo *(*query_info)(GFile * , char const   * , GFileQueryInfoFlags  , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFile * , char const   * , GFileQueryInfoFlags  , int  ,
                            GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileInfo *(*query_filesystem_info)(GFile * , char const   * , GCancellable * ,
                                       GError ** ) ;
   void (*query_filesystem_info_async)(GFile * , char const   * , int  , GCancellable * ,
                                       GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_filesystem_info_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GMount *(*find_enclosing_mount)(GFile * , GCancellable * , GError ** ) ;
   void (*find_enclosing_mount_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                      gpointer  ) ;
   GMount *(*find_enclosing_mount_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFile *(*set_display_name)(GFile * , char const   * , GCancellable * , GError ** ) ;
   void (*set_display_name_async)(GFile * , char const   * , int  , GCancellable * ,
                                  GAsyncReadyCallback  , gpointer  ) ;
   GFile *(*set_display_name_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileAttributeInfoList *(*query_settable_attributes)(GFile * , GCancellable * ,
                                                        GError ** ) ;
   void (*_query_settable_attributes_async)(void) ;
   void (*_query_settable_attributes_finish)(void) ;
   GFileAttributeInfoList *(*query_writable_namespaces)(GFile * , GCancellable * ,
                                                        GError ** ) ;
   void (*_query_writable_namespaces_async)(void) ;
   void (*_query_writable_namespaces_finish)(void) ;
   gboolean (*set_attribute)(GFile * , char const   * , GFileAttributeType  , gpointer  ,
                             GFileQueryInfoFlags  , GCancellable * , GError ** ) ;
   gboolean (*set_attributes_from_info)(GFile * , GFileInfo * , GFileQueryInfoFlags  ,
                                        GCancellable * , GError ** ) ;
   void (*set_attributes_async)(GFile * , GFileInfo * , GFileQueryInfoFlags  , int  ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*set_attributes_finish)(GFile * , GAsyncResult * , GFileInfo ** , GError ** ) ;
   GFileInputStream *(*read_fn)(GFile * , GCancellable * , GError ** ) ;
   void (*read_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileInputStream *(*read_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*append_to)(GFile * , GFileCreateFlags  , GCancellable * ,
                                   GError ** ) ;
   void (*append_to_async)(GFile * , GFileCreateFlags  , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   GFileOutputStream *(*append_to_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*create)(GFile * , GFileCreateFlags  , GCancellable * , GError ** ) ;
   void (*create_async)(GFile * , GFileCreateFlags  , int  , GCancellable * , GAsyncReadyCallback  ,
                        gpointer  ) ;
   GFileOutputStream *(*create_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileOutputStream *(*replace)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                 GCancellable * , GError ** ) ;
   void (*replace_async)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                         int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GFileOutputStream *(*replace_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*delete_file)(GFile * , GCancellable * , GError ** ) ;
   void (*delete_file_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                             gpointer  ) ;
   gboolean (*delete_file_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*trash)(GFile * , GCancellable * , GError ** ) ;
   void (*trash_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*trash_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*make_directory)(GFile * , GCancellable * , GError ** ) ;
   void (*make_directory_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   gboolean (*make_directory_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*make_symbolic_link)(GFile * , char const   * , GCancellable * , GError ** ) ;
   void (*_make_symbolic_link_async)(void) ;
   void (*_make_symbolic_link_finish)(void) ;
   gboolean (*copy)(GFile * , GFile * , GFileCopyFlags  , GCancellable * , GFileProgressCallback  ,
                    gpointer  , GError ** ) ;
   void (*copy_async)(GFile * , GFile * , GFileCopyFlags  , int  , GCancellable * ,
                      GFileProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*copy_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*move)(GFile * , GFile * , GFileCopyFlags  , GCancellable * , GFileProgressCallback  ,
                    gpointer  , GError ** ) ;
   void (*move_async)(GFile * , GFile * , GFileCopyFlags  , int  , GCancellable * ,
                      GFileProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                      gpointer  ) ;
   gboolean (*move_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*mount_mountable)(GFile * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   GFile *(*mount_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*unmount_mountable)(GFile * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                             gpointer  ) ;
   gboolean (*unmount_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*eject_mountable)(GFile * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*eject_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*mount_enclosing_volume)(GFile * , GMountMountFlags  , GMountOperation * ,
                                  GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*mount_enclosing_volume_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileMonitor *(*monitor_dir)(GFile * , GFileMonitorFlags  , GCancellable * , GError ** ) ;
   GFileMonitor *(*monitor_file)(GFile * , GFileMonitorFlags  , GCancellable * , GError ** ) ;
   GFileIOStream *(*open_readwrite)(GFile * , GCancellable * , GError ** ) ;
   void (*open_readwrite_async)(GFile * , int  , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GFileIOStream *(*open_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileIOStream *(*create_readwrite)(GFile * , GFileCreateFlags  , GCancellable * ,
                                      GError ** ) ;
   void (*create_readwrite_async)(GFile * , GFileCreateFlags  , int  , GCancellable * ,
                                  GAsyncReadyCallback  , gpointer  ) ;
   GFileIOStream *(*create_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   GFileIOStream *(*replace_readwrite)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                       GCancellable * , GError ** ) ;
   void (*replace_readwrite_async)(GFile * , char const   * , gboolean  , GFileCreateFlags  ,
                                   int  , GCancellable * , GAsyncReadyCallback  ,
                                   gpointer  ) ;
   GFileIOStream *(*replace_readwrite_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*start_mountable)(GFile * , GDriveStartFlags  , GMountOperation * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*start_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*stop_mountable)(GFile * , GMountUnmountFlags  , GMountOperation * , GCancellable * ,
                          GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*stop_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean supports_thread_contexts ;
   void (*unmount_mountable_with_operation)(GFile * , GMountUnmountFlags  , GMountOperation * ,
                                            GCancellable * , GAsyncReadyCallback  ,
                                            gpointer  ) ;
   gboolean (*unmount_mountable_with_operation_finish)(GFile * , GAsyncResult * ,
                                                       GError ** ) ;
   void (*eject_mountable_with_operation)(GFile * , GMountUnmountFlags  , GMountOperation * ,
                                          GCancellable * , GAsyncReadyCallback  ,
                                          gpointer  ) ;
   gboolean (*eject_mountable_with_operation_finish)(GFile * , GAsyncResult * , GError ** ) ;
   void (*poll_mountable)(GFile * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*poll_mountable_finish)(GFile * , GAsyncResult * , GError ** ) ;
   gboolean (*measure_disk_usage)(GFile * , GFileMeasureFlags  , GCancellable * ,
                                  GFileMeasureProgressCallback  , gpointer  , guint64 * ,
                                  guint64 * , guint64 * , GError ** ) ;
   void (*measure_disk_usage_async)(GFile * , GFileMeasureFlags  , gint  , GCancellable * ,
                                    GFileMeasureProgressCallback  , gpointer  , GAsyncReadyCallback  ,
                                    gpointer  ) ;
   gboolean (*measure_disk_usage_finish)(GFile * , GAsyncResult * , guint64 * , guint64 * ,
                                         guint64 * , GError ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gfileattribute.h"
struct _GFileAttributeInfo {
   char *name ;
   GFileAttributeType type ;
   GFileAttributeInfoFlags flags ;
};
#line 55 "/usr/include/glib-2.0/gio/gfileattribute.h"
struct _GFileAttributeInfoList {
   GFileAttributeInfo *infos ;
   int n_infos ;
};
#line 44 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumeratorClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileenumerator.h"
typedef struct _GFileEnumeratorClass GFileEnumeratorClass;
#line 45
struct _GFileEnumeratorPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gfileenumerator.h"
typedef struct _GFileEnumeratorPrivate GFileEnumeratorPrivate;
#line 47 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumerator {
   GObject parent_instance ;
   GFileEnumeratorPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gfileenumerator.h"
struct _GFileEnumeratorClass {
   GObjectClass parent_class ;
   GFileInfo *(*next_file)(GFileEnumerator * , GCancellable * , GError ** ) ;
   gboolean (*close_fn)(GFileEnumerator * , GCancellable * , GError ** ) ;
   void (*next_files_async)(GFileEnumerator * , int  , int  , GCancellable * , GAsyncReadyCallback  ,
                            gpointer  ) ;
   GList *(*next_files_finish)(GFileEnumerator * , GAsyncResult * , GError ** ) ;
   void (*close_async)(GFileEnumerator * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GFileEnumerator * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfileicon.h"
struct _GFileIconClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileicon.h"
typedef struct _GFileIconClass GFileIconClass;
#line 44 "/usr/include/glib-2.0/gio/gfileinfo.h"
struct _GFileInfoClass ;
#line 44 "/usr/include/glib-2.0/gio/gfileinfo.h"
typedef struct _GFileInfoClass GFileInfoClass;
#line 47 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileinputstream.h"
typedef struct _GFileInputStreamClass GFileInputStreamClass;
#line 48
struct _GFileInputStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileinputstream.h"
typedef struct _GFileInputStreamPrivate GFileInputStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStream {
   GInputStream parent_instance ;
   GFileInputStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileinputstream.h"
struct _GFileInputStreamClass {
   GInputStreamClass parent_class ;
   goffset (*tell)(GFileInputStream * ) ;
   gboolean (*can_seek)(GFileInputStream * ) ;
   gboolean (*seek)(GFileInputStream * , goffset  , GSeekType  , GCancellable * ,
                    GError ** ) ;
   GFileInfo *(*query_info)(GFileInputStream * , char const   * , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFileInputStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileInputStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 38 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStreamPrivate ;
#line 38 "/usr/include/glib-2.0/gio/giostream.h"
typedef struct _GIOStreamPrivate GIOStreamPrivate;
#line 39
struct _GIOStreamClass ;
#line 39 "/usr/include/glib-2.0/gio/giostream.h"
typedef struct _GIOStreamClass GIOStreamClass;
#line 46 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStream {
   GObject parent_instance ;
   GIOStreamPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/giostream.h"
struct _GIOStreamClass {
   GObjectClass parent_class ;
   GInputStream *(*get_input_stream)(GIOStream * ) ;
   GOutputStream *(*get_output_stream)(GIOStream * ) ;
   gboolean (*close_fn)(GIOStream * , GCancellable * , GError ** ) ;
   void (*close_async)(GIOStream * , int  , GCancellable * , GAsyncReadyCallback  ,
                       gpointer  ) ;
   gboolean (*close_finish)(GIOStream * , GAsyncResult * , GError ** ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
   void (*_g_reserved10)(void) ;
};
#line 47 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileiostream.h"
typedef struct _GFileIOStreamClass GFileIOStreamClass;
#line 48
struct _GFileIOStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileiostream.h"
typedef struct _GFileIOStreamPrivate GFileIOStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStream {
   GIOStream parent_instance ;
   GFileIOStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileiostream.h"
struct _GFileIOStreamClass {
   GIOStreamClass parent_class ;
   goffset (*tell)(GFileIOStream * ) ;
   gboolean (*can_seek)(GFileIOStream * ) ;
   gboolean (*seek)(GFileIOStream * , goffset  , GSeekType  , GCancellable * , GError ** ) ;
   gboolean (*can_truncate)(GFileIOStream * ) ;
   gboolean (*truncate_fn)(GFileIOStream * , goffset  , GCancellable * , GError ** ) ;
   GFileInfo *(*query_info)(GFileIOStream * , char const   * , GCancellable * , GError ** ) ;
   void (*query_info_async)(GFileIOStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileIOStream * , GAsyncResult * , GError ** ) ;
   char *(*get_etag)(GFileIOStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 39 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitorClass ;
#line 39 "/usr/include/glib-2.0/gio/gfilemonitor.h"
typedef struct _GFileMonitorClass GFileMonitorClass;
#line 40
struct _GFileMonitorPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gfilemonitor.h"
typedef struct _GFileMonitorPrivate GFileMonitorPrivate;
#line 47 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitor {
   GObject parent_instance ;
   GFileMonitorPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gfilemonitor.h"
struct _GFileMonitorClass {
   GObjectClass parent_class ;
   void (*changed)(GFileMonitor * , GFile * , GFile * , GFileMonitorEvent  ) ;
   gboolean (*cancel)(GFileMonitor * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 44 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
struct _GFilenameCompleterClass ;
#line 44 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
typedef struct _GFilenameCompleterClass GFilenameCompleterClass;
#line 46 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
struct _GFilenameCompleterClass {
   GObjectClass parent_class ;
   void (*got_completion_data)(GFilenameCompleter * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
};
#line 47 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStreamClass ;
#line 47 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
typedef struct _GFileOutputStreamClass GFileOutputStreamClass;
#line 48
struct _GFileOutputStreamPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
typedef struct _GFileOutputStreamPrivate GFileOutputStreamPrivate;
#line 50 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStream {
   GOutputStream parent_instance ;
   GFileOutputStreamPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
struct _GFileOutputStreamClass {
   GOutputStreamClass parent_class ;
   goffset (*tell)(GFileOutputStream * ) ;
   gboolean (*can_seek)(GFileOutputStream * ) ;
   gboolean (*seek)(GFileOutputStream * , goffset  , GSeekType  , GCancellable * ,
                    GError ** ) ;
   gboolean (*can_truncate)(GFileOutputStream * ) ;
   gboolean (*truncate_fn)(GFileOutputStream * , goffset  , GCancellable * , GError ** ) ;
   GFileInfo *(*query_info)(GFileOutputStream * , char const   * , GCancellable * ,
                            GError ** ) ;
   void (*query_info_async)(GFileOutputStream * , char const   * , int  , GCancellable * ,
                            GAsyncReadyCallback  , gpointer  ) ;
   GFileInfo *(*query_info_finish)(GFileOutputStream * , GAsyncResult * , GError ** ) ;
   char *(*get_etag)(GFileOutputStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/ginetaddress.h"
typedef struct _GInetAddressClass GInetAddressClass;
#line 41
struct _GInetAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/ginetaddress.h"
typedef struct _GInetAddressPrivate GInetAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddress {
   GObject parent_instance ;
   GInetAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/ginetaddress.h"
struct _GInetAddressClass {
   GObjectClass parent_class ;
   gchar *(*to_string)(GInetAddress * ) ;
   guint8 *(*to_bytes)(GInetAddress * ) ;
};
#line 37 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMaskClass ;
#line 37 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
typedef struct _GInetAddressMaskClass GInetAddressMaskClass;
#line 38
struct _GInetAddressMaskPrivate ;
#line 38 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
typedef struct _GInetAddressMaskPrivate GInetAddressMaskPrivate;
#line 40 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMask {
   GObject parent_instance ;
   GInetAddressMaskPrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
struct _GInetAddressMaskClass {
   GObjectClass parent_class ;
};
#line 40 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/gsocketaddress.h"
typedef struct _GSocketAddressClass GSocketAddressClass;
#line 42 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddress {
   GObject parent_instance ;
};
#line 47 "/usr/include/glib-2.0/gio/gsocketaddress.h"
struct _GSocketAddressClass {
   GObjectClass parent_class ;
   GSocketFamily (*get_family)(GSocketAddress * ) ;
   gssize (*get_native_size)(GSocketAddress * ) ;
   gboolean (*to_native)(GSocketAddress * , gpointer  , gsize  , GError ** ) ;
};
#line 40 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
typedef struct _GInetSocketAddressClass GInetSocketAddressClass;
#line 41
struct _GInetSocketAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
typedef struct _GInetSocketAddressPrivate GInetSocketAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddress {
   GSocketAddress parent_instance ;
   GInetSocketAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
struct _GInetSocketAddressClass {
   GSocketAddressClass parent_class ;
};
#line 58 "/usr/include/glib-2.0/gmodule.h"
enum __anonenum__601 {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3
} ;
#line 63 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonenum__601 GModuleFlags;
#line 65
struct _GModule ;
#line 65 "/usr/include/glib-2.0/gmodule.h"
typedef struct _GModule GModule;
#line 66 "/usr/include/glib-2.0/gmodule.h"
typedef gchar *(*GModuleCheckInit)(GModule * );
#line 67 "/usr/include/glib-2.0/gmodule.h"
typedef void (*GModuleUnload)(GModule * );
#line 82
enum __anonenum__602 {
    G_MODULE_ERROR_FAILED = 0,
    G_MODULE_ERROR_CHECK_FAILED = 1
} ;
#line 86 "/usr/include/glib-2.0/gmodule.h"
typedef enum __anonenum__602 GModuleError;
#line 33 "/usr/include/glib-2.0/gio/giomodule.h"
struct _GIOModuleScope ;
#line 33 "/usr/include/glib-2.0/gio/giomodule.h"
typedef struct _GIOModuleScope GIOModuleScope;
#line 55
struct _GIOModuleClass ;
#line 55 "/usr/include/glib-2.0/gio/giomodule.h"
typedef struct _GIOModuleClass GIOModuleClass;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
struct _GListModel ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef struct _GListModel GListModel;
#line 36
struct _GListModelInterface ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef struct _GListModelInterface GListModelInterface;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GListModel *GListModel_autoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GList *GListModel_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GSList *GListModel_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
typedef GQueue *GListModel_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/glistmodel.h"
struct _GListModelInterface {
   GTypeInterface g_iface ;
   GType (*get_item_type)(GListModel * ) ;
   guint (*get_n_items)(GListModel * ) ;
   gpointer (*get_item)(GListModel * , guint  ) ;
};
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
struct _GListStore ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef struct _GListStore GListStore;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
struct __anonstruct_603 {
   GObjectClass parent_class ;
};
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef struct __anonstruct_603 GListStoreClass;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GListStore *GListStore_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GList *GListStore_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GSList *GListStore_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GQueue *GListStore_queueautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GListStoreClass *GListStoreClass_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GList *GListStoreClass_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GSList *GListStoreClass_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
typedef GQueue *GListStoreClass_queueautoptr;
#line 43 "/usr/include/glib-2.0/gio/gloadableicon.h"
struct _GLoadableIconIface ;
#line 43 "/usr/include/glib-2.0/gio/gloadableicon.h"
typedef struct _GLoadableIconIface GLoadableIconIface;
#line 54 "/usr/include/glib-2.0/gio/gloadableicon.h"
struct _GLoadableIconIface {
   GTypeInterface g_iface ;
   GInputStream *(*load)(GLoadableIcon * , int  , char ** , GCancellable * , GError ** ) ;
   void (*load_async)(GLoadableIcon * , int  , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   GInputStream *(*load_finish)(GLoadableIcon * , GAsyncResult * , char ** , GError ** ) ;
};
#line 44 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
typedef struct _GMemoryInputStreamClass GMemoryInputStreamClass;
#line 45
struct _GMemoryInputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
typedef struct _GMemoryInputStreamPrivate GMemoryInputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStream {
   GInputStream parent_instance ;
   GMemoryInputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
struct _GMemoryInputStreamClass {
   GInputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
struct _GMemoryMonitor ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef struct _GMemoryMonitor GMemoryMonitor;
#line 42
struct _GMemoryMonitorInterface ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef struct _GMemoryMonitorInterface GMemoryMonitorInterface;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GMemoryMonitor *GMemoryMonitor_autoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GList *GMemoryMonitor_listautoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GSList *GMemoryMonitor_slistautoptr;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
typedef GQueue *GMemoryMonitor_queueautoptr;
#line 48 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
struct _GMemoryMonitorInterface {
   GTypeInterface g_iface ;
   void (*low_memory_warning)(GMemoryMonitor * , GMemoryMonitorWarningLevel  ) ;
};
#line 44 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStreamClass ;
#line 44 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef struct _GMemoryOutputStreamClass GMemoryOutputStreamClass;
#line 45
struct _GMemoryOutputStreamPrivate ;
#line 45 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef struct _GMemoryOutputStreamPrivate GMemoryOutputStreamPrivate;
#line 47 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStream {
   GOutputStream parent_instance ;
   GMemoryOutputStreamPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
struct _GMemoryOutputStreamClass {
   GOutputStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 80 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
typedef gpointer (*GReallocFunc)(gpointer  , gsize  );
#line 125 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModelPrivate ;
#line 125 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuModelPrivate GMenuModelPrivate;
#line 126
struct _GMenuModelClass ;
#line 126 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuModelClass GMenuModelClass;
#line 128
struct _GMenuAttributeIterPrivate ;
#line 128 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIterPrivate GMenuAttributeIterPrivate;
#line 129
struct _GMenuAttributeIterClass ;
#line 129 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIterClass GMenuAttributeIterClass;
#line 130
struct _GMenuAttributeIter ;
#line 130 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuAttributeIter GMenuAttributeIter;
#line 132
struct _GMenuLinkIterPrivate ;
#line 132 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIterPrivate GMenuLinkIterPrivate;
#line 133
struct _GMenuLinkIterClass ;
#line 133 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIterClass GMenuLinkIterClass;
#line 134
struct _GMenuLinkIter ;
#line 134 "/usr/include/glib-2.0/gio/gmenumodel.h"
typedef struct _GMenuLinkIter GMenuLinkIter;
#line 136 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModel {
   GObject parent_instance ;
   GMenuModelPrivate *priv ;
};
#line 158 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuModelClass {
   GObjectClass parent_class ;
   gboolean (*is_mutable)(GMenuModel * ) ;
   gint (*get_n_items)(GMenuModel * ) ;
   void (*get_item_attributes)(GMenuModel * , gint  , GHashTable ** ) ;
   GMenuAttributeIter *(*iterate_item_attributes)(GMenuModel * , gint  ) ;
   GVariant *(*get_item_attribute_value)(GMenuModel * , gint  , gchar * , GVariantType * ) ;
   void (*get_item_links)(GMenuModel * , gint  , GHashTable ** ) ;
   GMenuLinkIter *(*iterate_item_links)(GMenuModel * , gint  ) ;
   GMenuModel *(*get_item_link)(GMenuModel * , gint  , gchar * ) ;
};
#line 232 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuAttributeIter {
   GObject parent_instance ;
   GMenuAttributeIterPrivate *priv ;
};
#line 238 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuAttributeIterClass {
   GObjectClass parent_class ;
   gboolean (*get_next)(GMenuAttributeIter * , gchar ** , GVariant ** ) ;
};
#line 274 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuLinkIter {
   GObject parent_instance ;
   GMenuLinkIterPrivate *priv ;
};
#line 280 "/usr/include/glib-2.0/gio/gmenumodel.h"
struct _GMenuLinkIterClass {
   GObjectClass parent_class ;
   gboolean (*get_next)(GMenuLinkIter * , gchar ** , GMenuModel ** ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gmenu.h"
struct _GMenuItem ;
#line 39 "/usr/include/glib-2.0/gio/gmenu.h"
typedef struct _GMenuItem GMenuItem;
#line 40
struct _GMenu ;
#line 40 "/usr/include/glib-2.0/gio/gmenu.h"
typedef struct _GMenu GMenu;
#line 38 "/usr/include/glib-2.0/gio/gmount.h"
struct _GMountIface ;
#line 38 "/usr/include/glib-2.0/gio/gmount.h"
typedef struct _GMountIface GMountIface;
#line 75 "/usr/include/glib-2.0/gio/gmount.h"
struct _GMountIface {
   GTypeInterface g_iface ;
   void (*changed)(GMount * ) ;
   void (*unmounted)(GMount * ) ;
   GFile *(*get_root)(GMount * ) ;
   char *(*get_name)(GMount * ) ;
   GIcon *(*get_icon)(GMount * ) ;
   char *(*get_uuid)(GMount * ) ;
   GVolume *(*get_volume)(GMount * ) ;
   GDrive *(*get_drive)(GMount * ) ;
   gboolean (*can_unmount)(GMount * ) ;
   gboolean (*can_eject)(GMount * ) ;
   void (*unmount)(GMount * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                   gpointer  ) ;
   gboolean (*unmount_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*eject)(GMount * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*remount)(GMount * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                   GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*remount_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*guess_content_type)(GMount * , gboolean  , GCancellable * , GAsyncReadyCallback  ,
                              gpointer  ) ;
   gchar **(*guess_content_type_finish)(GMount * , GAsyncResult * , GError ** ) ;
   gchar **(*guess_content_type_sync)(GMount * , gboolean  , GCancellable * , GError ** ) ;
   void (*pre_unmount)(GMount * ) ;
   void (*unmount_with_operation)(GMount * , GMountUnmountFlags  , GMountOperation * ,
                                  GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*unmount_with_operation_finish)(GMount * , GAsyncResult * , GError ** ) ;
   void (*eject_with_operation)(GMount * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GMount * , GAsyncResult * , GError ** ) ;
   GFile *(*get_default_location)(GMount * ) ;
   gchar *(*get_sort_key)(GMount * ) ;
   GIcon *(*get_symbolic_icon)(GMount * ) ;
};
#line 45 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperationClass ;
#line 45 "/usr/include/glib-2.0/gio/gmountoperation.h"
typedef struct _GMountOperationClass GMountOperationClass;
#line 46
struct _GMountOperationPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gmountoperation.h"
typedef struct _GMountOperationPrivate GMountOperationPrivate;
#line 48 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperation {
   GObject parent_instance ;
   GMountOperationPrivate *priv ;
};
#line 55 "/usr/include/glib-2.0/gio/gmountoperation.h"
struct _GMountOperationClass {
   GObjectClass parent_class ;
   void (*ask_password)(GMountOperation * , char const   * , char const   * , char const   * ,
                        GAskPasswordFlags  ) ;
   void (*ask_question)(GMountOperation * , char const   * , char const   *[] ) ;
   void (*reply)(GMountOperation * , GMountOperationResult  ) ;
   void (*aborted)(GMountOperation * ) ;
   void (*show_processes)(GMountOperation * , gchar * , GArray * , gchar *[] ) ;
   void (*show_unmount_progress)(GMountOperation * , gchar * , gint64  , gint64  ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddressClass ;
#line 40 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
typedef struct _GNativeSocketAddressClass GNativeSocketAddressClass;
#line 41
struct _GNativeSocketAddressPrivate ;
#line 41 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
typedef struct _GNativeSocketAddressPrivate GNativeSocketAddressPrivate;
#line 43 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddress {
   GSocketAddress parent_instance ;
   GNativeSocketAddressPrivate *priv ;
};
#line 51 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
struct _GNativeSocketAddressClass {
   GSocketAddressClass parent_class ;
};
#line 55 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitorClass ;
#line 55 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
typedef struct _GVolumeMonitorClass GVolumeMonitorClass;
#line 57 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitor {
   GObject parent_instance ;
   gpointer priv ;
};
#line 65 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
struct _GVolumeMonitorClass {
   GObjectClass parent_class ;
   void (*volume_added)(GVolumeMonitor * , GVolume * ) ;
   void (*volume_removed)(GVolumeMonitor * , GVolume * ) ;
   void (*volume_changed)(GVolumeMonitor * , GVolume * ) ;
   void (*mount_added)(GVolumeMonitor * , GMount * ) ;
   void (*mount_removed)(GVolumeMonitor * , GMount * ) ;
   void (*mount_pre_unmount)(GVolumeMonitor * , GMount * ) ;
   void (*mount_changed)(GVolumeMonitor * , GMount * ) ;
   void (*drive_connected)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_disconnected)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_changed)(GVolumeMonitor * , GDrive * ) ;
   gboolean (*is_supported)(void) ;
   GList *(*get_connected_drives)(GVolumeMonitor * ) ;
   GList *(*get_volumes)(GVolumeMonitor * ) ;
   GList *(*get_mounts)(GVolumeMonitor * ) ;
   GVolume *(*get_volume_for_uuid)(GVolumeMonitor * , char const   * ) ;
   GMount *(*get_mount_for_uuid)(GVolumeMonitor * , char const   * ) ;
   GVolume *(*adopt_orphan_mount)(GMount * , GVolumeMonitor * ) ;
   void (*drive_eject_button)(GVolumeMonitor * , GDrive * ) ;
   void (*drive_stop_button)(GVolumeMonitor * , GDrive * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 40 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitor ;
#line 40 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
typedef struct _GNativeVolumeMonitor GNativeVolumeMonitor;
#line 41
struct _GNativeVolumeMonitorClass ;
#line 41 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
typedef struct _GNativeVolumeMonitorClass GNativeVolumeMonitorClass;
#line 43 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitor {
   GVolumeMonitor parent_instance ;
};
#line 48 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
struct _GNativeVolumeMonitorClass {
   GVolumeMonitorClass parent_class ;
   GMount *(*get_mount_for_mount_path)(char const   * , GCancellable * ) ;
};
#line 37 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddressClass ;
#line 37 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
typedef struct _GNetworkAddressClass GNetworkAddressClass;
#line 38
struct _GNetworkAddressPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
typedef struct _GNetworkAddressPrivate GNetworkAddressPrivate;
#line 40 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddress {
   GObject parent_instance ;
   GNetworkAddressPrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
struct _GNetworkAddressClass {
   GObjectClass parent_class ;
};
#line 45 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
struct _GNetworkMonitorInterface ;
#line 45 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
typedef struct _GNetworkMonitorInterface GNetworkMonitorInterface;
#line 47 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
struct _GNetworkMonitorInterface {
   GTypeInterface g_iface ;
   void (*network_changed)(GNetworkMonitor * , gboolean  ) ;
   gboolean (*can_reach)(GNetworkMonitor * , GSocketConnectable * , GCancellable * ,
                         GError ** ) ;
   void (*can_reach_async)(GNetworkMonitor * , GSocketConnectable * , GCancellable * ,
                           GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*can_reach_finish)(GNetworkMonitor * , GAsyncResult * , GError ** ) ;
};
#line 37 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkServiceClass ;
#line 37 "/usr/include/glib-2.0/gio/gnetworkservice.h"
typedef struct _GNetworkServiceClass GNetworkServiceClass;
#line 38
struct _GNetworkServicePrivate ;
#line 38 "/usr/include/glib-2.0/gio/gnetworkservice.h"
typedef struct _GNetworkServicePrivate GNetworkServicePrivate;
#line 40 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkService {
   GObject parent_instance ;
   GNetworkServicePrivate *priv ;
};
#line 48 "/usr/include/glib-2.0/gio/gnetworkservice.h"
struct _GNetworkServiceClass {
   GObjectClass parent_class ;
};
#line 43 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermissionPrivate ;
#line 43 "/usr/include/glib-2.0/gio/gpermission.h"
typedef struct _GPermissionPrivate GPermissionPrivate;
#line 44
struct _GPermissionClass ;
#line 44 "/usr/include/glib-2.0/gio/gpermission.h"
typedef struct _GPermissionClass GPermissionClass;
#line 46 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermission {
   GObject parent_instance ;
   GPermissionPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/gpermission.h"
struct _GPermissionClass {
   GObjectClass parent_class ;
   gboolean (*acquire)(GPermission * , GCancellable * , GError ** ) ;
   void (*acquire_async)(GPermission * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*acquire_finish)(GPermission * , GAsyncResult * , GError ** ) ;
   gboolean (*release)(GPermission * , GCancellable * , GError ** ) ;
   void (*release_async)(GPermission * , GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*release_finish)(GPermission * , GAsyncResult * , GError ** ) ;
   gpointer reserved[16] ;
};
#line 42 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
struct _GPollableInputStreamInterface ;
#line 42 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
typedef struct _GPollableInputStreamInterface GPollableInputStreamInterface;
#line 66 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
struct _GPollableInputStreamInterface {
   GTypeInterface g_iface ;
   gboolean (*can_poll)(GPollableInputStream * ) ;
   gboolean (*is_readable)(GPollableInputStream * ) ;
   GSource *(*create_source)(GPollableInputStream * , GCancellable * ) ;
   gssize (*read_nonblocking)(GPollableInputStream * , void * , gsize  , GError ** ) ;
};
#line 42 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
struct _GPollableOutputStreamInterface ;
#line 42 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
typedef struct _GPollableOutputStreamInterface GPollableOutputStreamInterface;
#line 74 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
struct _GPollableOutputStreamInterface {
   GTypeInterface g_iface ;
   gboolean (*can_poll)(GPollableOutputStream * ) ;
   gboolean (*is_writable)(GPollableOutputStream * ) ;
   GSource *(*create_source)(GPollableOutputStream * , GCancellable * ) ;
   gssize (*write_nonblocking)(GPollableOutputStream * , void const   * , gsize  ,
                               GError ** ) ;
   GPollableReturn (*writev_nonblocking)(GPollableOutputStream * , GOutputVector * ,
                                         gsize  , gsize * , GError ** ) ;
};
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
struct _GPowerProfileMonitor ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef struct _GPowerProfileMonitor GPowerProfileMonitor;
#line 43
struct _GPowerProfileMonitorInterface ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef struct _GPowerProfileMonitorInterface GPowerProfileMonitorInterface;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GPowerProfileMonitor *GPowerProfileMonitor_autoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GList *GPowerProfileMonitor_listautoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GSList *GPowerProfileMonitor_slistautoptr;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
typedef GQueue *GPowerProfileMonitor_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
struct _GPowerProfileMonitorInterface {
   GTypeInterface g_iface ;
};
#line 56 "/usr/include/glib-2.0/gio/gproxy.h"
struct _GProxyInterface ;
#line 56 "/usr/include/glib-2.0/gio/gproxy.h"
typedef struct _GProxyInterface GProxyInterface;
#line 71 "/usr/include/glib-2.0/gio/gproxy.h"
struct _GProxyInterface {
   GTypeInterface g_iface ;
   GIOStream *(*connect)(GProxy * , GIOStream * , GProxyAddress * , GCancellable * ,
                         GError ** ) ;
   void (*connect_async)(GProxy * , GIOStream * , GProxyAddress * , GCancellable * ,
                         GAsyncReadyCallback  , gpointer  ) ;
   GIOStream *(*connect_finish)(GProxy * , GAsyncResult * , GError ** ) ;
   gboolean (*supports_hostname)(GProxy * ) ;
};
#line 39 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddressClass ;
#line 39 "/usr/include/glib-2.0/gio/gproxyaddress.h"
typedef struct _GProxyAddressClass GProxyAddressClass;
#line 40
struct _GProxyAddressPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gproxyaddress.h"
typedef struct _GProxyAddressPrivate GProxyAddressPrivate;
#line 42 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddress {
   GInetSocketAddress parent_instance ;
   GProxyAddressPrivate *priv ;
};
#line 50 "/usr/include/glib-2.0/gio/gproxyaddress.h"
struct _GProxyAddressClass {
   GInetSocketAddressClass parent_class ;
};
#line 43 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumeratorClass ;
#line 43 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
typedef struct _GSocketAddressEnumeratorClass GSocketAddressEnumeratorClass;
#line 45 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumerator {
   GObject parent_instance ;
};
#line 59 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
struct _GSocketAddressEnumeratorClass {
   GObjectClass parent_class ;
   GSocketAddress *(*next)(GSocketAddressEnumerator * , GCancellable * , GError ** ) ;
   void (*next_async)(GSocketAddressEnumerator * , GCancellable * , GAsyncReadyCallback  ,
                      gpointer  ) ;
   GSocketAddress *(*next_finish)(GSocketAddressEnumerator * , GAsyncResult * , GError ** ) ;
};
#line 47 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumeratorClass ;
#line 47 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
typedef struct _GProxyAddressEnumeratorClass GProxyAddressEnumeratorClass;
#line 48
struct _GProxyAddressEnumeratorPrivate ;
#line 48 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
typedef struct _GProxyAddressEnumeratorPrivate GProxyAddressEnumeratorPrivate;
#line 50 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumerator {
   GSocketAddressEnumerator parent_instance ;
   GProxyAddressEnumeratorPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
struct _GProxyAddressEnumeratorClass {
   GSocketAddressEnumeratorClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
};
#line 45 "/usr/include/glib-2.0/gio/gproxyresolver.h"
struct _GProxyResolverInterface ;
#line 45 "/usr/include/glib-2.0/gio/gproxyresolver.h"
typedef struct _GProxyResolverInterface GProxyResolverInterface;
#line 47 "/usr/include/glib-2.0/gio/gproxyresolver.h"
struct _GProxyResolverInterface {
   GTypeInterface g_iface ;
   gboolean (*is_supported)(GProxyResolver * ) ;
   gchar **(*lookup)(GProxyResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_async)(GProxyResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                        gpointer  ) ;
   gchar **(*lookup_finish)(GProxyResolver * , GAsyncResult * , GError ** ) ;
};
#line 41 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
struct _GRemoteActionGroupInterface ;
#line 41 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
typedef struct _GRemoteActionGroupInterface GRemoteActionGroupInterface;
#line 43 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
struct _GRemoteActionGroupInterface {
   GTypeInterface g_iface ;
   void (*activate_action_full)(GRemoteActionGroup * , gchar * , GVariant * , GVariant * ) ;
   void (*change_action_state_full)(GRemoteActionGroup * , gchar * , GVariant * ,
                                    GVariant * ) ;
};
#line 38 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolverPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gresolver.h"
typedef struct _GResolverPrivate GResolverPrivate;
#line 39
struct _GResolverClass ;
#line 39 "/usr/include/glib-2.0/gio/gresolver.h"
typedef struct _GResolverClass GResolverClass;
#line 41 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolver {
   GObject parent_instance ;
   GResolverPrivate *priv ;
};
#line 57
enum __anonenum__604 {
    G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2
} ;
#line 61 "/usr/include/glib-2.0/gio/gresolver.h"
typedef enum __anonenum__604 GResolverNameLookupFlags;
#line 63 "/usr/include/glib-2.0/gio/gresolver.h"
struct _GResolverClass {
   GObjectClass parent_class ;
   void (*reload)(GResolver * ) ;
   GList *(*lookup_by_name)(GResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_by_name_async)(GResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GList *(*lookup_by_name_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   gchar *(*lookup_by_address)(GResolver * , GInetAddress * , GCancellable * , GError ** ) ;
   void (*lookup_by_address_async)(GResolver * , GInetAddress * , GCancellable * ,
                                   GAsyncReadyCallback  , gpointer  ) ;
   gchar *(*lookup_by_address_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_service)(GResolver * , gchar * , GCancellable * , GError ** ) ;
   void (*lookup_service_async)(GResolver * , gchar * , GCancellable * , GAsyncReadyCallback  ,
                                gpointer  ) ;
   GList *(*lookup_service_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_records)(GResolver * , gchar * , GResolverRecordType  , GCancellable * ,
                            GError ** ) ;
   void (*lookup_records_async)(GResolver * , gchar * , GResolverRecordType  , GCancellable * ,
                                GAsyncReadyCallback  , gpointer  ) ;
   GList *(*lookup_records_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   void (*lookup_by_name_with_flags_async)(GResolver * , gchar * , GResolverNameLookupFlags  ,
                                           GCancellable * , GAsyncReadyCallback  ,
                                           gpointer  ) ;
   GList *(*lookup_by_name_with_flags_finish)(GResolver * , GAsyncResult * , GError ** ) ;
   GList *(*lookup_by_name_with_flags)(GResolver * , gchar * , GResolverNameLookupFlags  ,
                                       GCancellable * , GError ** ) ;
};
#line 51 "/usr/include/glib-2.0/gio/gresource.h"
struct _GStaticResource ;
#line 51 "/usr/include/glib-2.0/gio/gresource.h"
typedef struct _GStaticResource GStaticResource;
#line 53 "/usr/include/glib-2.0/gio/gresource.h"
struct _GStaticResource {
   guint8 *data ;
   gsize data_len ;
   GResource *resource ;
   GStaticResource *next ;
   gpointer padding ;
};
#line 42 "/usr/include/glib-2.0/gio/gseekable.h"
struct _GSeekableIface ;
#line 42 "/usr/include/glib-2.0/gio/gseekable.h"
typedef struct _GSeekableIface GSeekableIface;
#line 55 "/usr/include/glib-2.0/gio/gseekable.h"
struct _GSeekableIface {
   GTypeInterface g_iface ;
   goffset (*tell)(GSeekable * ) ;
   gboolean (*can_seek)(GSeekable * ) ;
   gboolean (*seek)(GSeekable * , goffset  , GSeekType  , GCancellable * , GError ** ) ;
   gboolean (*can_truncate)(GSeekable * ) ;
   gboolean (*truncate_fn)(GSeekable * , goffset  , GCancellable * , GError ** ) ;
};
#line 26 "/usr/include/glib-2.0/gio/gsettingsschema.h"
struct _GSettingsSchemaSource ;
#line 26 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchemaSource GSettingsSchemaSource;
#line 27
struct _GSettingsSchema ;
#line 27 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchema GSettingsSchema;
#line 28
struct _GSettingsSchemaKey ;
#line 28 "/usr/include/glib-2.0/gio/gsettingsschema.h"
typedef struct _GSettingsSchemaKey GSettingsSchemaKey;
#line 42 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettingsPrivate ;
#line 42 "/usr/include/glib-2.0/gio/gsettings.h"
typedef struct _GSettingsPrivate GSettingsPrivate;
#line 43
struct _GSettingsClass ;
#line 43 "/usr/include/glib-2.0/gio/gsettings.h"
typedef struct _GSettingsClass GSettingsClass;
#line 45 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettingsClass {
   GObjectClass parent_class ;
   void (*writable_changed)(GSettings * , gchar * ) ;
   void (*changed)(GSettings * , gchar * ) ;
   gboolean (*writable_change_event)(GSettings * , GQuark  ) ;
   gboolean (*change_event)(GSettings * , GQuark * , gint  ) ;
   gpointer padding[20] ;
};
#line 63 "/usr/include/glib-2.0/gio/gsettings.h"
struct _GSettings {
   GObject parent_instance ;
   GSettingsPrivate *priv ;
};
#line 235 "/usr/include/glib-2.0/gio/gsettings.h"
typedef GVariant *(*GSettingsBindSetMapping)(GValue * , GVariantType * , gpointer  );
#line 251 "/usr/include/glib-2.0/gio/gsettings.h"
typedef gboolean (*GSettingsBindGetMapping)(GValue * , GVariant * , gpointer  );
#line 275 "/usr/include/glib-2.0/gio/gsettings.h"
typedef gboolean (*GSettingsGetMapping)(GVariant * , gpointer * , gpointer  );
#line 297
enum __anonenum__605 {
    G_SETTINGS_BIND_DEFAULT = 0,
    G_SETTINGS_BIND_GET = 1,
    G_SETTINGS_BIND_SET = 2,
    G_SETTINGS_BIND_NO_SENSITIVITY = 4,
    G_SETTINGS_BIND_GET_NO_CHANGES = 8,
    G_SETTINGS_BIND_INVERT_BOOLEAN = 16
} ;
#line 305 "/usr/include/glib-2.0/gio/gsettings.h"
typedef enum __anonenum__605 GSettingsBindFlags;
#line 44 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroupPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
typedef struct _GSimpleActionGroupPrivate GSimpleActionGroupPrivate;
#line 45
struct _GSimpleActionGroupClass ;
#line 45 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
typedef struct _GSimpleActionGroupClass GSimpleActionGroupClass;
#line 54 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroup {
   GObject parent_instance ;
   GSimpleActionGroupPrivate *priv ;
};
#line 62 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
struct _GSimpleActionGroupClass {
   GObjectClass parent_class ;
   gpointer padding[12] ;
};
#line 44 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
struct _GSimpleAsyncResultClass ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
typedef struct _GSimpleAsyncResultClass GSimpleAsyncResultClass;
#line 42 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolver ;
#line 42 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolver GSimpleProxyResolver;
#line 43
struct _GSimpleProxyResolverPrivate ;
#line 43 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolverPrivate GSimpleProxyResolverPrivate;
#line 44
struct _GSimpleProxyResolverClass ;
#line 44 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
typedef struct _GSimpleProxyResolverClass GSimpleProxyResolverClass;
#line 46 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolver {
   GObject parent_instance ;
   GSimpleProxyResolverPrivate *priv ;
};
#line 54 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
struct _GSimpleProxyResolverClass {
   GObjectClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocketPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocket.h"
typedef struct _GSocketPrivate GSocketPrivate;
#line 47
struct _GSocketClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocket.h"
typedef struct _GSocketClass GSocketClass;
#line 49 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocketClass {
   GObjectClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
   void (*_g_reserved7)(void) ;
   void (*_g_reserved8)(void) ;
   void (*_g_reserved9)(void) ;
   void (*_g_reserved10)(void) ;
};
#line 68 "/usr/include/glib-2.0/gio/gsocket.h"
struct _GSocket {
   GObject parent_instance ;
   GSocketPrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClientPrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocketclient.h"
typedef struct _GSocketClientPrivate GSocketClientPrivate;
#line 47
struct _GSocketClientClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocketclient.h"
typedef struct _GSocketClientClass GSocketClientClass;
#line 49 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClientClass {
   GObjectClass parent_class ;
   void (*event)(GSocketClient * , GSocketClientEvent  , GSocketConnectable * , GIOStream * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
};
#line 65 "/usr/include/glib-2.0/gio/gsocketclient.h"
struct _GSocketClient {
   GObject parent_instance ;
   GSocketClientPrivate *priv ;
};
#line 40 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
struct _GSocketConnectableIface ;
#line 40 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
typedef struct _GSocketConnectableIface GSocketConnectableIface;
#line 53 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
struct _GSocketConnectableIface {
   GTypeInterface g_iface ;
   GSocketAddressEnumerator *(*enumerate)(GSocketConnectable * ) ;
   GSocketAddressEnumerator *(*proxy_enumerate)(GSocketConnectable * ) ;
   gchar *(*to_string)(GSocketConnectable * ) ;
};
#line 49 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnectionPrivate ;
#line 49 "/usr/include/glib-2.0/gio/gsocketconnection.h"
typedef struct _GSocketConnectionPrivate GSocketConnectionPrivate;
#line 50
struct _GSocketConnectionClass ;
#line 50 "/usr/include/glib-2.0/gio/gsocketconnection.h"
typedef struct _GSocketConnectionClass GSocketConnectionClass;
#line 52 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnectionClass {
   GIOStreamClass parent_class ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 65 "/usr/include/glib-2.0/gio/gsocketconnection.h"
struct _GSocketConnection {
   GIOStream parent_instance ;
   GSocketConnectionPrivate *priv ;
};
#line 47 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessagePrivate ;
#line 47 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
typedef struct _GSocketControlMessagePrivate GSocketControlMessagePrivate;
#line 48
struct _GSocketControlMessageClass ;
#line 48 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
typedef struct _GSocketControlMessageClass GSocketControlMessageClass;
#line 61 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessageClass {
   GObjectClass parent_class ;
   gsize (*get_size)(GSocketControlMessage * ) ;
   int (*get_level)(GSocketControlMessage * ) ;
   int (*get_type)(GSocketControlMessage * ) ;
   void (*serialize)(GSocketControlMessage * , gpointer  ) ;
   GSocketControlMessage *(*deserialize)(int  , int  , gsize  , gpointer  ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 85 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
struct _GSocketControlMessage {
   GObject parent_instance ;
   GSocketControlMessagePrivate *priv ;
};
#line 49 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListenerPrivate ;
#line 49 "/usr/include/glib-2.0/gio/gsocketlistener.h"
typedef struct _GSocketListenerPrivate GSocketListenerPrivate;
#line 50
struct _GSocketListenerClass ;
#line 50 "/usr/include/glib-2.0/gio/gsocketlistener.h"
typedef struct _GSocketListenerClass GSocketListenerClass;
#line 58 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListenerClass {
   GObjectClass parent_class ;
   void (*changed)(GSocketListener * ) ;
   void (*event)(GSocketListener * , GSocketListenerEvent  , GSocket * ) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 76 "/usr/include/glib-2.0/gio/gsocketlistener.h"
struct _GSocketListener {
   GObject parent_instance ;
   GSocketListenerPrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketServicePrivate ;
#line 46 "/usr/include/glib-2.0/gio/gsocketservice.h"
typedef struct _GSocketServicePrivate GSocketServicePrivate;
#line 47
struct _GSocketServiceClass ;
#line 47 "/usr/include/glib-2.0/gio/gsocketservice.h"
typedef struct _GSocketServiceClass GSocketServiceClass;
#line 55 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketServiceClass {
   GSocketListenerClass parent_class ;
   gboolean (*incoming)(GSocketService * , GSocketConnection * , GObject * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 72 "/usr/include/glib-2.0/gio/gsocketservice.h"
struct _GSocketService {
   GSocketListener parent_instance ;
   GSocketServicePrivate *priv ;
};
#line 37 "/usr/include/glib-2.0/gio/gtask.h"
struct _GTaskClass ;
#line 37 "/usr/include/glib-2.0/gio/gtask.h"
typedef struct _GTaskClass GTaskClass;
#line 113 "/usr/include/glib-2.0/gio/gtask.h"
typedef void (*GTaskThreadFunc)(GTask * , gpointer  , gpointer  , GCancellable * );
#line 44 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnectionPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gtcpconnection.h"
typedef struct _GTcpConnectionPrivate GTcpConnectionPrivate;
#line 45
struct _GTcpConnectionClass ;
#line 45 "/usr/include/glib-2.0/gio/gtcpconnection.h"
typedef struct _GTcpConnectionClass GTcpConnectionClass;
#line 47 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnectionClass {
   GSocketConnectionClass parent_class ;
};
#line 52 "/usr/include/glib-2.0/gio/gtcpconnection.h"
struct _GTcpConnection {
   GSocketConnection parent_instance ;
   GTcpConnectionPrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnectionPrivate ;
#line 44 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
typedef struct _GTcpWrapperConnectionPrivate GTcpWrapperConnectionPrivate;
#line 45
struct _GTcpWrapperConnectionClass ;
#line 45 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
typedef struct _GTcpWrapperConnectionClass GTcpWrapperConnectionClass;
#line 47 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnectionClass {
   GTcpConnectionClass parent_class ;
};
#line 52 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
struct _GTcpWrapperConnection {
   GTcpConnection parent_instance ;
   GTcpWrapperConnectionPrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gthemedicon.h"
struct _GThemedIconClass ;
#line 44 "/usr/include/glib-2.0/gio/gthemedicon.h"
typedef struct _GThemedIconClass GThemedIconClass;
#line 49 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketServicePrivate ;
#line 49 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
typedef struct _GThreadedSocketServicePrivate GThreadedSocketServicePrivate;
#line 50
struct _GThreadedSocketServiceClass ;
#line 50 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
typedef struct _GThreadedSocketServiceClass GThreadedSocketServiceClass;
#line 52 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketServiceClass {
   GSocketServiceClass parent_class ;
   gboolean (*run)(GThreadedSocketService * , GSocketConnection * , GObject * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
};
#line 68 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
struct _GThreadedSocketService {
   GSocketService parent_instance ;
   GThreadedSocketServicePrivate *priv ;
};
#line 44 "/usr/include/glib-2.0/gio/gtlsbackend.h"
struct _GTlsBackend ;
#line 44 "/usr/include/glib-2.0/gio/gtlsbackend.h"
typedef struct _GTlsBackend GTlsBackend;
#line 45
struct _GTlsBackendInterface ;
#line 45 "/usr/include/glib-2.0/gio/gtlsbackend.h"
typedef struct _GTlsBackendInterface GTlsBackendInterface;
#line 64 "/usr/include/glib-2.0/gio/gtlsbackend.h"
struct _GTlsBackendInterface {
   GTypeInterface g_iface ;
   gboolean (*supports_tls)(GTlsBackend * ) ;
   GType (*get_certificate_type)(void) ;
   GType (*get_client_connection_type)(void) ;
   GType (*get_server_connection_type)(void) ;
   GType (*get_file_database_type)(void) ;
   GTlsDatabase *(*get_default_database)(GTlsBackend * ) ;
   gboolean (*supports_dtls)(GTlsBackend * ) ;
   GType (*get_dtls_client_connection_type)(void) ;
   GType (*get_dtls_server_connection_type)(void) ;
};
#line 37 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificateClass ;
#line 37 "/usr/include/glib-2.0/gio/gtlscertificate.h"
typedef struct _GTlsCertificateClass GTlsCertificateClass;
#line 38
struct _GTlsCertificatePrivate ;
#line 38 "/usr/include/glib-2.0/gio/gtlscertificate.h"
typedef struct _GTlsCertificatePrivate GTlsCertificatePrivate;
#line 40 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificate {
   GObject parent_instance ;
   GTlsCertificatePrivate *priv ;
};
#line 46 "/usr/include/glib-2.0/gio/gtlscertificate.h"
struct _GTlsCertificateClass {
   GObjectClass parent_class ;
   GTlsCertificateFlags (*verify)(GTlsCertificate * , GSocketConnectable * , GTlsCertificate * ) ;
   gpointer padding[8] ;
};
#line 37 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnectionClass ;
#line 37 "/usr/include/glib-2.0/gio/gtlsconnection.h"
typedef struct _GTlsConnectionClass GTlsConnectionClass;
#line 38
struct _GTlsConnectionPrivate ;
#line 38 "/usr/include/glib-2.0/gio/gtlsconnection.h"
typedef struct _GTlsConnectionPrivate GTlsConnectionPrivate;
#line 40 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnection {
   GIOStream parent_instance ;
   GTlsConnectionPrivate *priv ;
};
#line 60 "/usr/include/glib-2.0/gio/gtlsconnection.h"
struct _GTlsConnectionClass {
   GIOStreamClass parent_class ;
   gboolean (*accept_certificate)(GTlsConnection * , GTlsCertificate * , GTlsCertificateFlags  ) ;
   gboolean (*handshake)(GTlsConnection * , GCancellable * , GError ** ) ;
   void (*handshake_async)(GTlsConnection * , int  , GCancellable * , GAsyncReadyCallback  ,
                           gpointer  ) ;
   gboolean (*handshake_finish)(GTlsConnection * , GAsyncResult * , GError ** ) ;
   gboolean (*get_binding_data)(GTlsConnection * , GTlsChannelBindingType  , GByteArray * ,
                                GError ** ) ;
   gchar *(*get_negotiated_protocol)(GTlsConnection * ) ;
   gpointer padding[6] ;
};
#line 35 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
struct _GTlsClientConnectionInterface ;
#line 35 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
typedef struct _GTlsClientConnectionInterface GTlsClientConnectionInterface;
#line 46 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
struct _GTlsClientConnectionInterface {
   GTypeInterface g_iface ;
   void (*copy_session_state)(GTlsClientConnection * , GTlsClientConnection * ) ;
};
#line 42 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabaseClass ;
#line 42 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
typedef struct _GTlsDatabaseClass GTlsDatabaseClass;
#line 43
struct _GTlsDatabasePrivate ;
#line 43 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
typedef struct _GTlsDatabasePrivate GTlsDatabasePrivate;
#line 45 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabase {
   GObject parent_instance ;
   GTlsDatabasePrivate *priv ;
};
#line 52 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
struct _GTlsDatabaseClass {
   GObjectClass parent_class ;
   GTlsCertificateFlags (*verify_chain)(GTlsDatabase * , GTlsCertificate * , gchar * ,
                                        GSocketConnectable * , GTlsInteraction * ,
                                        GTlsDatabaseVerifyFlags  , GCancellable * ,
                                        GError ** ) ;
   void (*verify_chain_async)(GTlsDatabase * , GTlsCertificate * , gchar * , GSocketConnectable * ,
                              GTlsInteraction * , GTlsDatabaseVerifyFlags  , GCancellable * ,
                              GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificateFlags (*verify_chain_finish)(GTlsDatabase * , GAsyncResult * , GError ** ) ;
   gchar *(*create_certificate_handle)(GTlsDatabase * , GTlsCertificate * ) ;
   GTlsCertificate *(*lookup_certificate_for_handle)(GTlsDatabase * , gchar * , GTlsInteraction * ,
                                                     GTlsDatabaseLookupFlags  , GCancellable * ,
                                                     GError ** ) ;
   void (*lookup_certificate_for_handle_async)(GTlsDatabase * , gchar * , GTlsInteraction * ,
                                               GTlsDatabaseLookupFlags  , GCancellable * ,
                                               GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificate *(*lookup_certificate_for_handle_finish)(GTlsDatabase * , GAsyncResult * ,
                                                            GError ** ) ;
   GTlsCertificate *(*lookup_certificate_issuer)(GTlsDatabase * , GTlsCertificate * ,
                                                 GTlsInteraction * , GTlsDatabaseLookupFlags  ,
                                                 GCancellable * , GError ** ) ;
   void (*lookup_certificate_issuer_async)(GTlsDatabase * , GTlsCertificate * , GTlsInteraction * ,
                                           GTlsDatabaseLookupFlags  , GCancellable * ,
                                           GAsyncReadyCallback  , gpointer  ) ;
   GTlsCertificate *(*lookup_certificate_issuer_finish)(GTlsDatabase * , GAsyncResult * ,
                                                        GError ** ) ;
   GList *(*lookup_certificates_issued_by)(GTlsDatabase * , GByteArray * , GTlsInteraction * ,
                                           GTlsDatabaseLookupFlags  , GCancellable * ,
                                           GError ** ) ;
   void (*lookup_certificates_issued_by_async)(GTlsDatabase * , GByteArray * , GTlsInteraction * ,
                                               GTlsDatabaseLookupFlags  , GCancellable * ,
                                               GAsyncReadyCallback  , gpointer  ) ;
   GList *(*lookup_certificates_issued_by_finish)(GTlsDatabase * , GAsyncResult * ,
                                                  GError ** ) ;
   gpointer padding[16] ;
};
#line 31 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
struct _GTlsFileDatabaseInterface ;
#line 31 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
typedef struct _GTlsFileDatabaseInterface GTlsFileDatabaseInterface;
#line 40 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
struct _GTlsFileDatabaseInterface {
   GTypeInterface g_iface ;
   gpointer padding[8] ;
};
#line 39 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteractionClass ;
#line 39 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
typedef struct _GTlsInteractionClass GTlsInteractionClass;
#line 40
struct _GTlsInteractionPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
typedef struct _GTlsInteractionPrivate GTlsInteractionPrivate;
#line 42 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteraction {
   GObject parent_instance ;
   GTlsInteractionPrivate *priv ;
};
#line 49 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
struct _GTlsInteractionClass {
   GObjectClass parent_class ;
   GTlsInteractionResult (*ask_password)(GTlsInteraction * , GTlsPassword * , GCancellable * ,
                                         GError ** ) ;
   void (*ask_password_async)(GTlsInteraction * , GTlsPassword * , GCancellable * ,
                              GAsyncReadyCallback  , gpointer  ) ;
   GTlsInteractionResult (*ask_password_finish)(GTlsInteraction * , GAsyncResult * ,
                                                GError ** ) ;
   GTlsInteractionResult (*request_certificate)(GTlsInteraction * , GTlsConnection * ,
                                                GTlsCertificateRequestFlags  , GCancellable * ,
                                                GError ** ) ;
   void (*request_certificate_async)(GTlsInteraction * , GTlsConnection * , GTlsCertificateRequestFlags  ,
                                     GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   GTlsInteractionResult (*request_certificate_finish)(GTlsInteraction * , GAsyncResult * ,
                                                       GError ** ) ;
   gpointer padding[21] ;
};
#line 39 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPasswordClass ;
#line 39 "/usr/include/glib-2.0/gio/gtlspassword.h"
typedef struct _GTlsPasswordClass GTlsPasswordClass;
#line 40
struct _GTlsPasswordPrivate ;
#line 40 "/usr/include/glib-2.0/gio/gtlspassword.h"
typedef struct _GTlsPasswordPrivate GTlsPasswordPrivate;
#line 42 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPassword {
   GObject parent_instance ;
   GTlsPasswordPrivate *priv ;
};
#line 58 "/usr/include/glib-2.0/gio/gtlspassword.h"
struct _GTlsPasswordClass {
   GObjectClass parent_class ;
   guchar *(*get_value)(GTlsPassword * , gsize * ) ;
   void (*set_value)(GTlsPassword * , guchar * , gssize  , GDestroyNotify  ) ;
   gchar *(*get_default_warning)(GTlsPassword * ) ;
   gpointer padding[4] ;
};
#line 43 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
struct _GTlsServerConnectionInterface ;
#line 43 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
typedef struct _GTlsServerConnectionInterface GTlsServerConnectionInterface;
#line 53 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
struct _GTlsServerConnectionInterface {
   GTypeInterface g_iface ;
};
#line 57 "/usr/include/glib-2.0/gio/gvfs.h"
typedef GFile *(*GVfsFileLookupFunc)(GVfs * , char const   * , gpointer  );
#line 74
struct _GVfsClass ;
#line 74 "/usr/include/glib-2.0/gio/gvfs.h"
typedef struct _GVfsClass GVfsClass;
#line 76 "/usr/include/glib-2.0/gio/gvfs.h"
struct _GVfs {
   GObject parent_instance ;
};
#line 81 "/usr/include/glib-2.0/gio/gvfs.h"
struct _GVfsClass {
   GObjectClass parent_class ;
   gboolean (*is_active)(GVfs * ) ;
   GFile *(*get_file_for_path)(GVfs * , char const   * ) ;
   GFile *(*get_file_for_uri)(GVfs * , char const   * ) ;
   gchar * const  *(*get_supported_uri_schemes)(GVfs * ) ;
   GFile *(*parse_name)(GVfs * , char const   * ) ;
   void (*local_file_add_info)(GVfs * , char const   * , guint64  , GFileAttributeMatcher * ,
                               GFileInfo * , GCancellable * , gpointer * , GDestroyNotify * ) ;
   void (*add_writable_namespaces)(GVfs * , GFileAttributeInfoList * ) ;
   gboolean (*local_file_set_attributes)(GVfs * , char const   * , GFileInfo * , GFileQueryInfoFlags  ,
                                         GCancellable * , GError ** ) ;
   void (*local_file_removed)(GVfs * , char const   * ) ;
   void (*local_file_moved)(GVfs * , char const   * , char const   * ) ;
   GIcon *(*deserialize_icon)(GVfs * , GVariant * ) ;
   void (*_g_reserved1)(void) ;
   void (*_g_reserved2)(void) ;
   void (*_g_reserved3)(void) ;
   void (*_g_reserved4)(void) ;
   void (*_g_reserved5)(void) ;
   void (*_g_reserved6)(void) ;
};
#line 124 "/usr/include/glib-2.0/gio/gvolume.h"
struct _GVolumeIface ;
#line 124 "/usr/include/glib-2.0/gio/gvolume.h"
typedef struct _GVolumeIface GVolumeIface;
#line 126 "/usr/include/glib-2.0/gio/gvolume.h"
struct _GVolumeIface {
   GTypeInterface g_iface ;
   void (*changed)(GVolume * ) ;
   void (*removed)(GVolume * ) ;
   char *(*get_name)(GVolume * ) ;
   GIcon *(*get_icon)(GVolume * ) ;
   char *(*get_uuid)(GVolume * ) ;
   GDrive *(*get_drive)(GVolume * ) ;
   GMount *(*get_mount)(GVolume * ) ;
   gboolean (*can_mount)(GVolume * ) ;
   gboolean (*can_eject)(GVolume * ) ;
   void (*mount_fn)(GVolume * , GMountMountFlags  , GMountOperation * , GCancellable * ,
                    GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*mount_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   void (*eject)(GVolume * , GMountUnmountFlags  , GCancellable * , GAsyncReadyCallback  ,
                 gpointer  ) ;
   gboolean (*eject_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   char *(*get_identifier)(GVolume * , char const   * ) ;
   char **(*enumerate_identifiers)(GVolume * ) ;
   gboolean (*should_automount)(GVolume * ) ;
   GFile *(*get_activation_root)(GVolume * ) ;
   void (*eject_with_operation)(GVolume * , GMountUnmountFlags  , GMountOperation * ,
                                GCancellable * , GAsyncReadyCallback  , gpointer  ) ;
   gboolean (*eject_with_operation_finish)(GVolume * , GAsyncResult * , GError ** ) ;
   gchar *(*get_sort_key)(GVolume * ) ;
   GIcon *(*get_symbolic_icon)(GVolume * ) ;
};
#line 40 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
struct _GZlibCompressorClass ;
#line 40 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
typedef struct _GZlibCompressorClass GZlibCompressorClass;
#line 42 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
struct _GZlibCompressorClass {
   GObjectClass parent_class ;
};
#line 40 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
struct _GZlibDecompressorClass ;
#line 40 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
typedef struct _GZlibDecompressorClass GZlibDecompressorClass;
#line 42 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
struct _GZlibDecompressorClass {
   GObjectClass parent_class ;
};
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAction *GAction_autoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAction_listautoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAction_slistautoptr;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAction_queueautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GActionMap *GActionMap_autoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GActionMap_listautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GActionMap_slistautoptr;
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GActionMap_queueautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppInfo *GAppInfo_autoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppInfo_listautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppInfo_slistautoptr;
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppInfo_queueautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppLaunchContext *GAppLaunchContext_autoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppLaunchContext_listautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppLaunchContext_slistautoptr;
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppLaunchContext_queueautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAppInfoMonitor *GAppInfoMonitor_autoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAppInfoMonitor_listautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAppInfoMonitor_slistautoptr;
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAppInfoMonitor_queueautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GApplicationCommandLine *GApplicationCommandLine_autoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GApplicationCommandLine_listautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GApplicationCommandLine_slistautoptr;
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GApplicationCommandLine_queueautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GApplication *GApplication_autoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GApplication_listautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GApplication_slistautoptr;
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GApplication_queueautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAsyncInitable *GAsyncInitable_autoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAsyncInitable_listautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAsyncInitable_slistautoptr;
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAsyncInitable_queueautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GAsyncResult *GAsyncResult_autoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GAsyncResult_listautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GAsyncResult_slistautoptr;
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GAsyncResult_queueautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBufferedInputStream *GBufferedInputStream_autoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBufferedInputStream_listautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBufferedInputStream_slistautoptr;
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBufferedInputStream_queueautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBufferedOutputStream *GBufferedOutputStream_autoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBufferedOutputStream_listautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBufferedOutputStream_slistautoptr;
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBufferedOutputStream_queueautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GBytesIcon *GBytesIcon_autoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GBytesIcon_listautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GBytesIcon_slistautoptr;
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GBytesIcon_queueautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCancellable *GCancellable_autoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCancellable_listautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCancellable_slistautoptr;
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCancellable_queueautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCharsetConverter *GCharsetConverter_autoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCharsetConverter_listautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCharsetConverter_slistautoptr;
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCharsetConverter_queueautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverter *GConverter_autoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverter_listautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverter_slistautoptr;
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverter_queueautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverterInputStream *GConverterInputStream_autoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverterInputStream_listautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverterInputStream_slistautoptr;
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverterInputStream_queueautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GConverterOutputStream *GConverterOutputStream_autoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GConverterOutputStream_listautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GConverterOutputStream_slistautoptr;
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GConverterOutputStream_queueautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GCredentials *GCredentials_autoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GCredentials_listautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GCredentials_slistautoptr;
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GCredentials_queueautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDatagramBased *GDatagramBased_autoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDatagramBased_listautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDatagramBased_slistautoptr;
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDatagramBased_queueautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDataInputStream *GDataInputStream_autoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDataInputStream_listautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDataInputStream_slistautoptr;
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDataInputStream_queueautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDataOutputStream *GDataOutputStream_autoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDataOutputStream_listautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDataOutputStream_slistautoptr;
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDataOutputStream_queueautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusActionGroup *GDBusActionGroup_autoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusActionGroup_listautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusActionGroup_slistautoptr;
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusActionGroup_queueautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusAuthObserver *GDBusAuthObserver_autoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusAuthObserver_listautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusAuthObserver_slistautoptr;
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusAuthObserver_queueautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusConnection *GDBusConnection_autoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusConnection_listautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusConnection_slistautoptr;
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusConnection_queueautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusInterface *GDBusInterface_autoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusInterface_listautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusInterface_slistautoptr;
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusInterface_queueautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusInterfaceSkeleton *GDBusInterfaceSkeleton_autoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusInterfaceSkeleton_listautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusInterfaceSkeleton_slistautoptr;
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusInterfaceSkeleton_queueautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMenuModel *GDBusMenuModel_autoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMenuModel_listautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMenuModel_slistautoptr;
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMenuModel_queueautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMessage *GDBusMessage_autoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMessage_listautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMessage_slistautoptr;
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMessage_queueautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusMethodInvocation *GDBusMethodInvocation_autoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusMethodInvocation_listautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusMethodInvocation_slistautoptr;
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusMethodInvocation_queueautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusNodeInfo *GDBusNodeInfo_autoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusNodeInfo_listautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusNodeInfo_slistautoptr;
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusNodeInfo_queueautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObject *GDBusObject_autoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObject_listautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObject_slistautoptr;
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObject_queueautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManagerClient *GDBusObjectManagerClient_autoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManagerClient_listautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManagerClient_slistautoptr;
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManagerClient_queueautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManager *GDBusObjectManager_autoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManager_listautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManager_slistautoptr;
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManager_queueautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectManagerServer *GDBusObjectManagerServer_autoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectManagerServer_listautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectManagerServer_slistautoptr;
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectManagerServer_queueautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectProxy *GDBusObjectProxy_autoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectProxy_listautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectProxy_slistautoptr;
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectProxy_queueautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusObjectSkeleton *GDBusObjectSkeleton_autoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusObjectSkeleton_listautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusObjectSkeleton_slistautoptr;
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusObjectSkeleton_queueautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusProxy *GDBusProxy_autoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusProxy_listautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusProxy_slistautoptr;
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusProxy_queueautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDBusServer *GDBusServer_autoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDBusServer_listautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDBusServer_slistautoptr;
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDBusServer_queueautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GDrive *GDrive_autoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GDrive_listautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GDrive_slistautoptr;
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GDrive_queueautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GEmblemedIcon *GEmblemedIcon_autoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GEmblemedIcon_listautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GEmblemedIcon_slistautoptr;
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GEmblemedIcon_queueautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GEmblem *GEmblem_autoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GEmblem_listautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GEmblem_slistautoptr;
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GEmblem_queueautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileEnumerator *GFileEnumerator_autoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileEnumerator_listautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileEnumerator_slistautoptr;
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileEnumerator_queueautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFile *GFile_autoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFile_listautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFile_slistautoptr;
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFile_queueautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileAttributeInfoList *GFileAttributeInfoList_autoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileAttributeInfoList_listautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileAttributeInfoList_slistautoptr;
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileAttributeInfoList_queueautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileIcon *GFileIcon_autoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileIcon_listautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileIcon_slistautoptr;
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileIcon_queueautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileInfo *GFileInfo_autoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileInfo_listautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileInfo_slistautoptr;
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileInfo_queueautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileInputStream *GFileInputStream_autoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileInputStream_listautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileInputStream_slistautoptr;
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileInputStream_queueautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileIOStream *GFileIOStream_autoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileIOStream_listautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileIOStream_slistautoptr;
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileIOStream_queueautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileMonitor *GFileMonitor_autoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileMonitor_listautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileMonitor_slistautoptr;
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileMonitor_queueautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilenameCompleter *GFilenameCompleter_autoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilenameCompleter_listautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilenameCompleter_slistautoptr;
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilenameCompleter_queueautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFileOutputStream *GFileOutputStream_autoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFileOutputStream_listautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFileOutputStream_slistautoptr;
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFileOutputStream_queueautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilterInputStream *GFilterInputStream_autoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilterInputStream_listautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilterInputStream_slistautoptr;
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilterInputStream_queueautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GFilterOutputStream *GFilterOutputStream_autoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GFilterOutputStream_listautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GFilterOutputStream_slistautoptr;
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GFilterOutputStream_queueautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIcon *GIcon_autoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIcon_listautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIcon_slistautoptr;
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIcon_queueautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetAddress *GInetAddress_autoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetAddress_listautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetAddress_slistautoptr;
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetAddress_queueautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetAddressMask *GInetAddressMask_autoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetAddressMask_listautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetAddressMask_slistautoptr;
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetAddressMask_queueautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInetSocketAddress *GInetSocketAddress_autoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInetSocketAddress_listautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInetSocketAddress_slistautoptr;
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInetSocketAddress_queueautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInitable *GInitable_autoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInitable_listautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInitable_slistautoptr;
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInitable_queueautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GInputStream *GInputStream_autoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GInputStream_listautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GInputStream_slistautoptr;
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GInputStream_queueautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIOModule *GIOModule_autoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIOModule_listautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIOModule_slistautoptr;
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIOModule_queueautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GIOStream *GIOStream_autoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GIOStream_listautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GIOStream_slistautoptr;
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GIOStream_queueautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GLoadableIcon *GLoadableIcon_autoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GLoadableIcon_listautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GLoadableIcon_slistautoptr;
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GLoadableIcon_queueautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMemoryInputStream *GMemoryInputStream_autoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMemoryInputStream_listautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMemoryInputStream_slistautoptr;
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMemoryInputStream_queueautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMemoryOutputStream *GMemoryOutputStream_autoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMemoryOutputStream_listautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMemoryOutputStream_slistautoptr;
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMemoryOutputStream_queueautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenu *GMenu_autoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenu_listautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenu_slistautoptr;
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenu_queueautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuItem *GMenuItem_autoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuItem_listautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuItem_slistautoptr;
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuItem_queueautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuModel *GMenuModel_autoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuModel_listautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuModel_slistautoptr;
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuModel_queueautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuAttributeIter *GMenuAttributeIter_autoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuAttributeIter_listautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuAttributeIter_slistautoptr;
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuAttributeIter_queueautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMenuLinkIter *GMenuLinkIter_autoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMenuLinkIter_listautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMenuLinkIter_slistautoptr;
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMenuLinkIter_queueautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMount *GMount_autoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMount_listautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMount_slistautoptr;
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMount_queueautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GMountOperation *GMountOperation_autoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GMountOperation_listautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GMountOperation_slistautoptr;
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GMountOperation_queueautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNativeVolumeMonitor *GNativeVolumeMonitor_autoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNativeVolumeMonitor_listautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNativeVolumeMonitor_slistautoptr;
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNativeVolumeMonitor_queueautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkAddress *GNetworkAddress_autoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkAddress_listautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkAddress_slistautoptr;
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkAddress_queueautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkMonitor *GNetworkMonitor_autoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkMonitor_listautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkMonitor_slistautoptr;
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkMonitor_queueautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNetworkService *GNetworkService_autoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNetworkService_listautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNetworkService_slistautoptr;
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNetworkService_queueautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GNotification *GNotification_autoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GNotification_listautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GNotification_slistautoptr;
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GNotification_queueautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GOutputStream *GOutputStream_autoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GOutputStream_listautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GOutputStream_slistautoptr;
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GOutputStream_queueautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPermission *GPermission_autoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPermission_listautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPermission_slistautoptr;
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPermission_queueautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPollableInputStream *GPollableInputStream_autoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPollableInputStream_listautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPollableInputStream_slistautoptr;
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPollableInputStream_queueautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPollableOutputStream *GPollableOutputStream_autoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPollableOutputStream_listautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPollableOutputStream_slistautoptr;
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPollableOutputStream_queueautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GPropertyAction *GPropertyAction_autoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GPropertyAction_listautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GPropertyAction_slistautoptr;
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GPropertyAction_queueautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyAddressEnumerator *GProxyAddressEnumerator_autoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyAddressEnumerator_listautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyAddressEnumerator_slistautoptr;
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyAddressEnumerator_queueautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyAddress *GProxyAddress_autoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyAddress_listautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyAddress_slistautoptr;
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyAddress_queueautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxy *GProxy_autoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxy_listautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxy_slistautoptr;
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxy_queueautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GProxyResolver *GProxyResolver_autoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GProxyResolver_listautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GProxyResolver_slistautoptr;
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GProxyResolver_queueautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GRemoteActionGroup *GRemoteActionGroup_autoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GRemoteActionGroup_listautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GRemoteActionGroup_slistautoptr;
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GRemoteActionGroup_queueautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GResolver *GResolver_autoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GResolver_listautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GResolver_slistautoptr;
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GResolver_queueautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GResource *GResource_autoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GResource_listautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GResource_slistautoptr;
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GResource_queueautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSeekable *GSeekable_autoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSeekable_listautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSeekable_slistautoptr;
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSeekable_queueautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsBackend *GSettingsBackend_autoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsBackend_listautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsBackend_slistautoptr;
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsBackend_queueautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchema *GSettingsSchema_autoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchema_listautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchema_slistautoptr;
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchema_queueautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchemaKey *GSettingsSchemaKey_autoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchemaKey_listautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchemaKey_slistautoptr;
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchemaKey_queueautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettingsSchemaSource *GSettingsSchemaSource_autoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettingsSchemaSource_listautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettingsSchemaSource_slistautoptr;
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettingsSchemaSource_queueautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSettings *GSettings_autoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSettings_listautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSettings_slistautoptr;
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSettings_queueautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleActionGroup *GSimpleActionGroup_autoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleActionGroup_listautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleActionGroup_slistautoptr;
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleActionGroup_queueautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleAction *GSimpleAction_autoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleAction_listautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleAction_slistautoptr;
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleAction_queueautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleAsyncResult *GSimpleAsyncResult_autoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleAsyncResult_listautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleAsyncResult_slistautoptr;
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleAsyncResult_queueautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimplePermission *GSimplePermission_autoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimplePermission_listautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimplePermission_slistautoptr;
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimplePermission_queueautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSimpleProxyResolver *GSimpleProxyResolver_autoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSimpleProxyResolver_listautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSimpleProxyResolver_slistautoptr;
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSimpleProxyResolver_queueautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketAddressEnumerator *GSocketAddressEnumerator_autoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketAddressEnumerator_listautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketAddressEnumerator_slistautoptr;
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketAddressEnumerator_queueautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketAddress *GSocketAddress_autoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketAddress_listautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketAddress_slistautoptr;
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketAddress_queueautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketClient *GSocketClient_autoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketClient_listautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketClient_slistautoptr;
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketClient_queueautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketConnectable *GSocketConnectable_autoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketConnectable_listautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketConnectable_slistautoptr;
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketConnectable_queueautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketConnection *GSocketConnection_autoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketConnection_listautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketConnection_slistautoptr;
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketConnection_queueautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketControlMessage *GSocketControlMessage_autoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketControlMessage_listautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketControlMessage_slistautoptr;
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketControlMessage_queueautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocket *GSocket_autoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocket_listautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocket_slistautoptr;
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocket_queueautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketListener *GSocketListener_autoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketListener_listautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketListener_slistautoptr;
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketListener_queueautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSocketService *GSocketService_autoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSocketService_listautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSocketService_slistautoptr;
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSocketService_queueautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSubprocess *GSubprocess_autoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSubprocess_listautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSubprocess_slistautoptr;
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSubprocess_queueautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSubprocessLauncher *GSubprocessLauncher_autoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GSubprocessLauncher_listautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GSubprocessLauncher_slistautoptr;
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GSubprocessLauncher_queueautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTask *GTask_autoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTask_listautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTask_slistautoptr;
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTask_queueautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTcpConnection *GTcpConnection_autoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTcpConnection_listautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTcpConnection_slistautoptr;
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTcpConnection_queueautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTcpWrapperConnection *GTcpWrapperConnection_autoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTcpWrapperConnection_listautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTcpWrapperConnection_slistautoptr;
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTcpWrapperConnection_queueautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTestDBus *GTestDBus_autoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTestDBus_listautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTestDBus_slistautoptr;
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTestDBus_queueautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GThemedIcon *GThemedIcon_autoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GThemedIcon_listautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GThemedIcon_slistautoptr;
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GThemedIcon_queueautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GThreadedSocketService *GThreadedSocketService_autoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GThreadedSocketService_listautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GThreadedSocketService_slistautoptr;
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GThreadedSocketService_queueautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsBackend *GTlsBackend_autoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsBackend_listautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsBackend_slistautoptr;
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsBackend_queueautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsCertificate *GTlsCertificate_autoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsCertificate_listautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsCertificate_slistautoptr;
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsCertificate_queueautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsClientConnection *GTlsClientConnection_autoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsClientConnection_listautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsClientConnection_slistautoptr;
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsClientConnection_queueautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsConnection *GTlsConnection_autoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsConnection_listautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsConnection_slistautoptr;
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsConnection_queueautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsDatabase *GTlsDatabase_autoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsDatabase_listautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsDatabase_slistautoptr;
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsDatabase_queueautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsFileDatabase *GTlsFileDatabase_autoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsFileDatabase_listautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsFileDatabase_slistautoptr;
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsFileDatabase_queueautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsInteraction *GTlsInteraction_autoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsInteraction_listautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsInteraction_slistautoptr;
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsInteraction_queueautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsPassword *GTlsPassword_autoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsPassword_listautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsPassword_slistautoptr;
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsPassword_queueautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GTlsServerConnection *GTlsServerConnection_autoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GTlsServerConnection_listautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GTlsServerConnection_slistautoptr;
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GTlsServerConnection_queueautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVfs *GVfs_autoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVfs_listautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVfs_slistautoptr;
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVfs_queueautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVolume *GVolume_autoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVolume_listautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVolume_slistautoptr;
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVolume_queueautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GVolumeMonitor *GVolumeMonitor_autoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GVolumeMonitor_listautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GVolumeMonitor_slistautoptr;
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GVolumeMonitor_queueautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GZlibCompressor *GZlibCompressor_autoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GZlibCompressor_listautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GZlibCompressor_slistautoptr;
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GZlibCompressor_queueautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GZlibDecompressor *GZlibDecompressor_autoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GList *GZlibDecompressor_listautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GSList *GZlibDecompressor_slistautoptr;
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
typedef GQueue *GZlibDecompressor_queueautoptr;
#line 107 "/usr/include/cairo/cairo.h"
typedef int cairo_bool_t;
#line 124
struct _cairo ;
#line 124 "/usr/include/cairo/cairo.h"
typedef struct _cairo cairo_t;
#line 153
struct _cairo_surface ;
#line 153 "/usr/include/cairo/cairo.h"
typedef struct _cairo_surface cairo_surface_t;
#line 171
struct _cairo_device ;
#line 171 "/usr/include/cairo/cairo.h"
typedef struct _cairo_device cairo_device_t;
#line 192 "/usr/include/cairo/cairo.h"
struct _cairo_matrix {
   double xx ;
   double yx ;
   double xy ;
   double yy ;
   double x0 ;
   double y0 ;
};
#line 196 "/usr/include/cairo/cairo.h"
typedef struct _cairo_matrix cairo_matrix_t;
#line 220
struct _cairo_pattern ;
#line 220 "/usr/include/cairo/cairo.h"
typedef struct _cairo_pattern cairo_pattern_t;
#line 232 "/usr/include/cairo/cairo.h"
typedef void (*cairo_destroy_func_t)(void * );
#line 246 "/usr/include/cairo/cairo.h"
struct _cairo_user_data_key {
   int unused ;
};
#line 248 "/usr/include/cairo/cairo.h"
typedef struct _cairo_user_data_key cairo_user_data_key_t;
#line 314
enum _cairo_status {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY = 1,
    CAIRO_STATUS_INVALID_RESTORE = 2,
    CAIRO_STATUS_INVALID_POP_GROUP = 3,
    CAIRO_STATUS_NO_CURRENT_POINT = 4,
    CAIRO_STATUS_INVALID_MATRIX = 5,
    CAIRO_STATUS_INVALID_STATUS = 6,
    CAIRO_STATUS_NULL_POINTER = 7,
    CAIRO_STATUS_INVALID_STRING = 8,
    CAIRO_STATUS_INVALID_PATH_DATA = 9,
    CAIRO_STATUS_READ_ERROR = 10,
    CAIRO_STATUS_WRITE_ERROR = 11,
    CAIRO_STATUS_SURFACE_FINISHED = 12,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH = 13,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH = 14,
    CAIRO_STATUS_INVALID_CONTENT = 15,
    CAIRO_STATUS_INVALID_FORMAT = 16,
    CAIRO_STATUS_INVALID_VISUAL = 17,
    CAIRO_STATUS_FILE_NOT_FOUND = 18,
    CAIRO_STATUS_INVALID_DASH = 19,
    CAIRO_STATUS_INVALID_DSC_COMMENT = 20,
    CAIRO_STATUS_INVALID_INDEX = 21,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = 22,
    CAIRO_STATUS_TEMP_FILE_ERROR = 23,
    CAIRO_STATUS_INVALID_STRIDE = 24,
    CAIRO_STATUS_FONT_TYPE_MISMATCH = 25,
    CAIRO_STATUS_USER_FONT_IMMUTABLE = 26,
    CAIRO_STATUS_USER_FONT_ERROR = 27,
    CAIRO_STATUS_NEGATIVE_COUNT = 28,
    CAIRO_STATUS_INVALID_CLUSTERS = 29,
    CAIRO_STATUS_INVALID_SLANT = 30,
    CAIRO_STATUS_INVALID_WEIGHT = 31,
    CAIRO_STATUS_INVALID_SIZE = 32,
    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = 33,
    CAIRO_STATUS_DEVICE_TYPE_MISMATCH = 34,
    CAIRO_STATUS_DEVICE_ERROR = 35,
    CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = 36,
    CAIRO_STATUS_DEVICE_FINISHED = 37,
    CAIRO_STATUS_JBIG2_GLOBAL_MISSING = 38,
    CAIRO_STATUS_PNG_ERROR = 39,
    CAIRO_STATUS_FREETYPE_ERROR = 40,
    CAIRO_STATUS_WIN32_GDI_ERROR = 41,
    CAIRO_STATUS_TAG_ERROR = 42,
    CAIRO_STATUS_LAST_STATUS = 43
} ;
#line 361 "/usr/include/cairo/cairo.h"
typedef enum _cairo_status cairo_status_t;
#line 379
enum _cairo_content {
    CAIRO_CONTENT_COLOR = 4096,
    CAIRO_CONTENT_ALPHA = 8192,
    CAIRO_CONTENT_COLOR_ALPHA = 12288
} ;
#line 383 "/usr/include/cairo/cairo.h"
typedef enum _cairo_content cairo_content_t;
#line 416
enum _cairo_format {
    CAIRO_FORMAT_INVALID = -1,
    CAIRO_FORMAT_ARGB32 = 0,
    CAIRO_FORMAT_RGB24 = 1,
    CAIRO_FORMAT_A8 = 2,
    CAIRO_FORMAT_A1 = 3,
    CAIRO_FORMAT_RGB16_565 = 4,
    CAIRO_FORMAT_RGB30 = 5
} ;
#line 424 "/usr/include/cairo/cairo.h"
typedef enum _cairo_format cairo_format_t;
#line 445 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_write_func_t)(void * , unsigned char const   * , unsigned int  );
#line 467 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_read_func_t)(void * , unsigned char * , unsigned int  );
#line 483 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle_int {
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 486 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle_int cairo_rectangle_int_t;
#line 613
enum _cairo_operator {
    CAIRO_OPERATOR_CLEAR = 0,
    CAIRO_OPERATOR_SOURCE = 1,
    CAIRO_OPERATOR_OVER = 2,
    CAIRO_OPERATOR_IN = 3,
    CAIRO_OPERATOR_OUT = 4,
    CAIRO_OPERATOR_ATOP = 5,
    CAIRO_OPERATOR_DEST = 6,
    CAIRO_OPERATOR_DEST_OVER = 7,
    CAIRO_OPERATOR_DEST_IN = 8,
    CAIRO_OPERATOR_DEST_OUT = 9,
    CAIRO_OPERATOR_DEST_ATOP = 10,
    CAIRO_OPERATOR_XOR = 11,
    CAIRO_OPERATOR_ADD = 12,
    CAIRO_OPERATOR_SATURATE = 13,
    CAIRO_OPERATOR_MULTIPLY = 14,
    CAIRO_OPERATOR_SCREEN = 15,
    CAIRO_OPERATOR_OVERLAY = 16,
    CAIRO_OPERATOR_DARKEN = 17,
    CAIRO_OPERATOR_LIGHTEN = 18,
    CAIRO_OPERATOR_COLOR_DODGE = 19,
    CAIRO_OPERATOR_COLOR_BURN = 20,
    CAIRO_OPERATOR_HARD_LIGHT = 21,
    CAIRO_OPERATOR_SOFT_LIGHT = 22,
    CAIRO_OPERATOR_DIFFERENCE = 23,
    CAIRO_OPERATOR_EXCLUSION = 24,
    CAIRO_OPERATOR_HSL_HUE = 25,
    CAIRO_OPERATOR_HSL_SATURATION = 26,
    CAIRO_OPERATOR_HSL_COLOR = 27,
    CAIRO_OPERATOR_HSL_LUMINOSITY = 28
} ;
#line 647 "/usr/include/cairo/cairo.h"
typedef enum _cairo_operator cairo_operator_t;
#line 709
enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT = 0,
    CAIRO_ANTIALIAS_NONE = 1,
    CAIRO_ANTIALIAS_GRAY = 2,
    CAIRO_ANTIALIAS_SUBPIXEL = 3,
    CAIRO_ANTIALIAS_FAST = 4,
    CAIRO_ANTIALIAS_GOOD = 5,
    CAIRO_ANTIALIAS_BEST = 6
} ;
#line 721 "/usr/include/cairo/cairo.h"
typedef enum _cairo_antialias cairo_antialias_t;
#line 753
enum _cairo_fill_rule {
    CAIRO_FILL_RULE_WINDING = 0,
    CAIRO_FILL_RULE_EVEN_ODD = 1
} ;
#line 756 "/usr/include/cairo/cairo.h"
typedef enum _cairo_fill_rule cairo_fill_rule_t;
#line 776
enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT = 0,
    CAIRO_LINE_CAP_ROUND = 1,
    CAIRO_LINE_CAP_SQUARE = 2
} ;
#line 780 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_cap cairo_line_cap_t;
#line 800
enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER = 0,
    CAIRO_LINE_JOIN_ROUND = 1,
    CAIRO_LINE_JOIN_BEVEL = 2
} ;
#line 804 "/usr/include/cairo/cairo.h"
typedef enum _cairo_line_join cairo_line_join_t;
#line 1002 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle {
   double x ;
   double y ;
   double width ;
   double height ;
};
#line 1004 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle cairo_rectangle_t;
#line 1017 "/usr/include/cairo/cairo.h"
struct _cairo_rectangle_list {
   cairo_status_t status ;
   cairo_rectangle_t *rectangles ;
   int num_rectangles ;
};
#line 1021 "/usr/include/cairo/cairo.h"
typedef struct _cairo_rectangle_list cairo_rectangle_list_t;
#line 1059
struct _cairo_scaled_font ;
#line 1059 "/usr/include/cairo/cairo.h"
typedef struct _cairo_scaled_font cairo_scaled_font_t;
#line 1080
struct _cairo_font_face ;
#line 1080 "/usr/include/cairo/cairo.h"
typedef struct _cairo_font_face cairo_font_face_t;
#line 1108 "/usr/include/cairo/cairo.h"
struct __anonstruct_606 {
   unsigned long index ;
   double x ;
   double y ;
};
#line 1112 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_606 cairo_glyph_t;
#line 1140 "/usr/include/cairo/cairo.h"
struct __anonstruct_607 {
   int num_bytes ;
   int num_glyphs ;
};
#line 1143 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_607 cairo_text_cluster_t;
#line 1160
enum _cairo_text_cluster_flags {
    CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 1
} ;
#line 1162 "/usr/include/cairo/cairo.h"
typedef enum _cairo_text_cluster_flags cairo_text_cluster_flags_t;
#line 1193 "/usr/include/cairo/cairo.h"
struct __anonstruct_608 {
   double x_bearing ;
   double y_bearing ;
   double width ;
   double height ;
   double x_advance ;
   double y_advance ;
};
#line 1200 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_608 cairo_text_extents_t;
#line 1245 "/usr/include/cairo/cairo.h"
struct __anonstruct_609 {
   double ascent ;
   double descent ;
   double height ;
   double max_x_advance ;
   double max_y_advance ;
};
#line 1251 "/usr/include/cairo/cairo.h"
typedef struct __anonstruct_609 cairo_font_extents_t;
#line 1263
enum _cairo_font_slant {
    CAIRO_FONT_SLANT_NORMAL = 0,
    CAIRO_FONT_SLANT_ITALIC = 1,
    CAIRO_FONT_SLANT_OBLIQUE = 2
} ;
#line 1267 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_slant cairo_font_slant_t;
#line 1278
enum _cairo_font_weight {
    CAIRO_FONT_WEIGHT_NORMAL = 0,
    CAIRO_FONT_WEIGHT_BOLD = 1
} ;
#line 1281 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_weight cairo_font_weight_t;
#line 1302
enum _cairo_subpixel_order {
    CAIRO_SUBPIXEL_ORDER_DEFAULT = 0,
    CAIRO_SUBPIXEL_ORDER_RGB = 1,
    CAIRO_SUBPIXEL_ORDER_BGR = 2,
    CAIRO_SUBPIXEL_ORDER_VRGB = 3,
    CAIRO_SUBPIXEL_ORDER_VBGR = 4
} ;
#line 1308 "/usr/include/cairo/cairo.h"
typedef enum _cairo_subpixel_order cairo_subpixel_order_t;
#line 1334
enum _cairo_hint_style {
    CAIRO_HINT_STYLE_DEFAULT = 0,
    CAIRO_HINT_STYLE_NONE = 1,
    CAIRO_HINT_STYLE_SLIGHT = 2,
    CAIRO_HINT_STYLE_MEDIUM = 3,
    CAIRO_HINT_STYLE_FULL = 4
} ;
#line 1340 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_style cairo_hint_style_t;
#line 1357
enum _cairo_hint_metrics {
    CAIRO_HINT_METRICS_DEFAULT = 0,
    CAIRO_HINT_METRICS_OFF = 1,
    CAIRO_HINT_METRICS_ON = 2
} ;
#line 1361 "/usr/include/cairo/cairo.h"
typedef enum _cairo_hint_metrics cairo_hint_metrics_t;
#line 1385
struct _cairo_font_options ;
#line 1385 "/usr/include/cairo/cairo.h"
typedef struct _cairo_font_options cairo_font_options_t;
#line 1572
enum _cairo_font_type {
    CAIRO_FONT_TYPE_TOY = 0,
    CAIRO_FONT_TYPE_FT = 1,
    CAIRO_FONT_TYPE_WIN32 = 2,
    CAIRO_FONT_TYPE_QUARTZ = 3,
    CAIRO_FONT_TYPE_USER = 4
} ;
#line 1578 "/usr/include/cairo/cairo.h"
typedef enum _cairo_font_type cairo_font_type_t;
#line 1729 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_init_func_t)(cairo_scaled_font_t * ,
                                                             cairo_t * , cairo_font_extents_t * );
#line 1776 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_render_glyph_func_t)(cairo_scaled_font_t * ,
                                                                     unsigned long  ,
                                                                     cairo_t * , cairo_text_extents_t * );
#line 1846 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_text_to_glyphs_func_t)(cairo_scaled_font_t * ,
                                                                       char const   * ,
                                                                       int  , cairo_glyph_t ** ,
                                                                       int * , cairo_text_cluster_t ** ,
                                                                       int * , cairo_text_cluster_flags_t * );
#line 1893 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_user_scaled_font_unicode_to_glyph_func_t)(cairo_scaled_font_t * ,
                                                                         unsigned long  ,
                                                                         unsigned long * );
#line 1993
enum _cairo_path_data_type {
    CAIRO_PATH_MOVE_TO = 0,
    CAIRO_PATH_LINE_TO = 1,
    CAIRO_PATH_CURVE_TO = 2,
    CAIRO_PATH_CLOSE_PATH = 3
} ;
#line 1998 "/usr/include/cairo/cairo.h"
typedef enum _cairo_path_data_type cairo_path_data_type_t;
#line 2068
union _cairo_path_data_t ;
#line 2068 "/usr/include/cairo/cairo.h"
typedef union _cairo_path_data_t cairo_path_data_t;
#line 2070 "/usr/include/cairo/cairo.h"
struct __anonstruct_610 {
   cairo_path_data_type_t type ;
   int length ;
};
#line 2074 "/usr/include/cairo/cairo.h"
struct __anonstruct_611 {
   double x ;
   double y ;
};
#line 2069 "/usr/include/cairo/cairo.h"
union _cairo_path_data_t {
   struct __anonstruct_610 header ;
   struct __anonstruct_611 point ;
};
#line 2100 "/usr/include/cairo/cairo.h"
struct cairo_path {
   cairo_status_t status ;
   cairo_path_data_t *data ;
   int num_data ;
};
#line 2104 "/usr/include/cairo/cairo.h"
typedef struct cairo_path cairo_path_t;
#line 2163
enum _cairo_device_type {
    CAIRO_DEVICE_TYPE_DRM = 0,
    CAIRO_DEVICE_TYPE_GL = 1,
    CAIRO_DEVICE_TYPE_SCRIPT = 2,
    CAIRO_DEVICE_TYPE_XCB = 3,
    CAIRO_DEVICE_TYPE_XLIB = 4,
    CAIRO_DEVICE_TYPE_XML = 5,
    CAIRO_DEVICE_TYPE_COGL = 6,
    CAIRO_DEVICE_TYPE_WIN32 = 7,
    CAIRO_DEVICE_TYPE_INVALID = -1
} ;
#line 2174 "/usr/include/cairo/cairo.h"
typedef enum _cairo_device_type cairo_device_type_t;
#line 2249
enum __anonenum__612 {
    CAIRO_SURFACE_OBSERVER_NORMAL = 0,
    CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS = 1
} ;
#line 2252 "/usr/include/cairo/cairo.h"
typedef enum __anonenum__612 cairo_surface_observer_mode_t;
#line 2258 "/usr/include/cairo/cairo.h"
typedef void (*cairo_surface_observer_callback_t)(cairo_surface_t * , cairo_surface_t * ,
                                                  void * );
#line 2397
enum _cairo_surface_type {
    CAIRO_SURFACE_TYPE_IMAGE = 0,
    CAIRO_SURFACE_TYPE_PDF = 1,
    CAIRO_SURFACE_TYPE_PS = 2,
    CAIRO_SURFACE_TYPE_XLIB = 3,
    CAIRO_SURFACE_TYPE_XCB = 4,
    CAIRO_SURFACE_TYPE_GLITZ = 5,
    CAIRO_SURFACE_TYPE_QUARTZ = 6,
    CAIRO_SURFACE_TYPE_WIN32 = 7,
    CAIRO_SURFACE_TYPE_BEOS = 8,
    CAIRO_SURFACE_TYPE_DIRECTFB = 9,
    CAIRO_SURFACE_TYPE_SVG = 10,
    CAIRO_SURFACE_TYPE_OS2 = 11,
    CAIRO_SURFACE_TYPE_WIN32_PRINTING = 12,
    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE = 13,
    CAIRO_SURFACE_TYPE_SCRIPT = 14,
    CAIRO_SURFACE_TYPE_QT = 15,
    CAIRO_SURFACE_TYPE_RECORDING = 16,
    CAIRO_SURFACE_TYPE_VG = 17,
    CAIRO_SURFACE_TYPE_GL = 18,
    CAIRO_SURFACE_TYPE_DRM = 19,
    CAIRO_SURFACE_TYPE_TEE = 20,
    CAIRO_SURFACE_TYPE_XML = 21,
    CAIRO_SURFACE_TYPE_SKIA = 22,
    CAIRO_SURFACE_TYPE_SUBSURFACE = 23,
    CAIRO_SURFACE_TYPE_COGL = 24
} ;
#line 2423 "/usr/include/cairo/cairo.h"
typedef enum _cairo_surface_type cairo_surface_type_t;
#line 2629 "/usr/include/cairo/cairo.h"
typedef cairo_surface_t *(*cairo_raster_source_acquire_func_t)(cairo_pattern_t * ,
                                                               void * , cairo_surface_t * ,
                                                               cairo_rectangle_int_t * );
#line 2648 "/usr/include/cairo/cairo.h"
typedef void (*cairo_raster_source_release_func_t)(cairo_pattern_t * , void * , cairo_surface_t * );
#line 2669 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_raster_source_snapshot_func_t)(cairo_pattern_t * ,
                                                              void * );
#line 2687 "/usr/include/cairo/cairo.h"
typedef cairo_status_t (*cairo_raster_source_copy_func_t)(cairo_pattern_t * , void * ,
                                                          cairo_pattern_t * );
#line 2702 "/usr/include/cairo/cairo.h"
typedef void (*cairo_raster_source_finish_func_t)(cairo_pattern_t * , void * );
#line 2824
enum _cairo_pattern_type {
    CAIRO_PATTERN_TYPE_SOLID = 0,
    CAIRO_PATTERN_TYPE_SURFACE = 1,
    CAIRO_PATTERN_TYPE_LINEAR = 2,
    CAIRO_PATTERN_TYPE_RADIAL = 3,
    CAIRO_PATTERN_TYPE_MESH = 4,
    CAIRO_PATTERN_TYPE_RASTER_SOURCE = 5
} ;
#line 2831 "/usr/include/cairo/cairo.h"
typedef enum _cairo_pattern_type cairo_pattern_type_t;
#line 2916
enum _cairo_extend {
    CAIRO_EXTEND_NONE = 0,
    CAIRO_EXTEND_REPEAT = 1,
    CAIRO_EXTEND_REFLECT = 2,
    CAIRO_EXTEND_PAD = 3
} ;
#line 2921 "/usr/include/cairo/cairo.h"
typedef enum _cairo_extend cairo_extend_t;
#line 2949
enum _cairo_filter {
    CAIRO_FILTER_FAST = 0,
    CAIRO_FILTER_GOOD = 1,
    CAIRO_FILTER_BEST = 2,
    CAIRO_FILTER_NEAREST = 3,
    CAIRO_FILTER_BILINEAR = 4,
    CAIRO_FILTER_GAUSSIAN = 5
} ;
#line 2956 "/usr/include/cairo/cairo.h"
typedef enum _cairo_filter cairo_filter_t;
#line 3078
struct _cairo_region ;
#line 3078 "/usr/include/cairo/cairo.h"
typedef struct _cairo_region cairo_region_t;
#line 3091
enum _cairo_region_overlap {
    CAIRO_REGION_OVERLAP_IN = 0,
    CAIRO_REGION_OVERLAP_OUT = 1,
    CAIRO_REGION_OVERLAP_PART = 2
} ;
#line 3095 "/usr/include/cairo/cairo.h"
typedef enum _cairo_region_overlap cairo_region_overlap_t;
#line 65 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
enum __anonenum__613 {
    GDK_PIXBUF_ALPHA_BILEVEL = 0,
    GDK_PIXBUF_ALPHA_FULL = 1
} ;
#line 69 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__613 GdkPixbufAlphaMode;
#line 83
enum __anonenum__614 {
    GDK_COLORSPACE_RGB = 0
} ;
#line 85 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__614 GdkColorspace;
#line 89
struct _GdkPixbuf ;
#line 89 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef struct _GdkPixbuf GdkPixbuf;
#line 110 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef void (*GdkPixbufDestroyNotify)(guchar * , gpointer  );
#line 139
enum __anonenum__615 {
    GDK_PIXBUF_ERROR_CORRUPT_IMAGE = 0,
    GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY = 1,
    GDK_PIXBUF_ERROR_BAD_OPTION = 2,
    GDK_PIXBUF_ERROR_UNKNOWN_TYPE = 3,
    GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION = 4,
    GDK_PIXBUF_ERROR_FAILED = 5,
    GDK_PIXBUF_ERROR_INCOMPLETE_ANIMATION = 6
} ;
#line 152 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef enum __anonenum__615 GdkPixbufError;
#line 367 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
typedef gboolean (*GdkPixbufSaveFunc)(gchar * , gsize  , GError ** , gpointer  );
#line 73 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
enum __anonenum__616 {
    GDK_INTERP_NEAREST = 0,
    GDK_INTERP_TILES = 1,
    GDK_INTERP_BILINEAR = 2,
    GDK_INTERP_HYPER = 3
} ;
#line 78 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
typedef enum __anonenum__616 GdkInterpType;
#line 91
enum __anonenum__617 {
    GDK_PIXBUF_ROTATE_NONE = 0,
    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90,
    GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180,
    GDK_PIXBUF_ROTATE_CLOCKWISE = 270
} ;
#line 96 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
typedef enum __anonenum__617 GdkPixbufRotation;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
struct _GdkPixbufAnimation ;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
typedef struct _GdkPixbufAnimation GdkPixbufAnimation;
#line 42
struct _GdkPixbufAnimationIter ;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
typedef struct _GdkPixbufAnimationIter GdkPixbufAnimationIter;
#line 38 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
struct _GdkPixbufSimpleAnim ;
#line 38 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
typedef struct _GdkPixbufSimpleAnim GdkPixbufSimpleAnim;
#line 39
struct _GdkPixbufSimpleAnimClass ;
#line 39 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
typedef struct _GdkPixbufSimpleAnimClass GdkPixbufSimpleAnimClass;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
struct _GdkPixbufFormat ;
#line 42 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
typedef struct _GdkPixbufFormat GdkPixbufFormat;
#line 46 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoader ;
#line 46 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
typedef struct _GdkPixbufLoader GdkPixbufLoader;
#line 47 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoader {
   GObject parent_instance ;
   gpointer priv ;
};
#line 55
struct _GdkPixbufLoaderClass ;
#line 55 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
typedef struct _GdkPixbufLoaderClass GdkPixbufLoaderClass;
#line 56 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
struct _GdkPixbufLoaderClass {
   GObjectClass parent_class ;
   void (*size_prepared)(GdkPixbufLoader * , int  , int  ) ;
   void (*area_prepared)(GdkPixbufLoader * ) ;
   void (*area_updated)(GdkPixbufLoader * , int  , int  , int  , int  ) ;
   void (*closed)(GdkPixbufLoader * ) ;
};
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbuf *GdkPixbuf_autoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbuf_listautoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbuf_slistautoptr;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbuf_queueautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufAnimation *GdkPixbufAnimation_autoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufAnimation_listautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufAnimation_slistautoptr;
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufAnimation_queueautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufAnimationIter *GdkPixbufAnimationIter_autoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufAnimationIter_listautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufAnimationIter_slistautoptr;
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufAnimationIter_queueautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufLoader *GdkPixbufLoader_autoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufLoader_listautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufLoader_slistautoptr;
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufLoader_queueautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GdkPixbufSimpleAnim *GdkPixbufSimpleAnim_autoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GList *GdkPixbufSimpleAnim_listautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GSList *GdkPixbufSimpleAnim_slistautoptr;
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
typedef GQueue *GdkPixbufSimpleAnim_queueautoptr;
#line 61 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
enum __anonenum__618 {
    RSVG_ERROR_FAILED = 0
} ;
#line 63 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef enum __anonenum__618 RsvgError;
#line 381
struct _RsvgHandle ;
#line 381 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct _RsvgHandle RsvgHandle;
#line 382
struct _RsvgHandleClass ;
#line 382 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct _RsvgHandleClass RsvgHandleClass;
#line 383
struct _RsvgDimensionData ;
#line 383 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct _RsvgDimensionData RsvgDimensionData;
#line 384
struct _RsvgPositionData ;
#line 384 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct _RsvgPositionData RsvgPositionData;
#line 385
struct _RsvgRectangle ;
#line 385 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct _RsvgRectangle RsvgRectangle;
#line 393 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct _RsvgHandleClass {
   GObjectClass parent ;
   gpointer _abi_padding[15] ;
};
#line 405 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct _RsvgHandle {
   GObject parent ;
   gpointer _abi_padding[16] ;
};
#line 427 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct _RsvgDimensionData {
   int width ;
   int height ;
   gdouble em ;
   gdouble ex ;
};
#line 444 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct _RsvgPositionData {
   int x ;
   int y ;
};
#line 460 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct _RsvgRectangle {
   double x ;
   double y ;
   double width ;
   double height ;
};
#line 825
enum __anonenum__619 {
    RSVG_UNIT_PERCENT = 0,
    RSVG_UNIT_PX = 1,
    RSVG_UNIT_EM = 2,
    RSVG_UNIT_EX = 3,
    RSVG_UNIT_IN = 4,
    RSVG_UNIT_CM = 5,
    RSVG_UNIT_MM = 6,
    RSVG_UNIT_PT = 7,
    RSVG_UNIT_PC = 8
} ;
#line 835 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef enum __anonenum__619 RsvgUnit;
#line 856 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
struct __anonstruct_620 {
   double length ;
   RsvgUnit unit ;
};
#line 859 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef struct __anonstruct_620 RsvgLength;
#line 1004
enum __anonenum__621 {
    RSVG_HANDLE_FLAGS_NONE = 0,
    RSVG_HANDLE_FLAG_UNLIMITED = 1,
    RSVG_HANDLE_FLAG_KEEP_IMAGE_DATA = 2
} ;
#line 1009 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef enum __anonenum__621 RsvgHandleFlags;
#line 1258 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
typedef void (*RsvgSizeFunc)(gint * , gint * , gpointer  );
#line 248 "/usr/include/zconf.h"
typedef size_t z_size_t;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 402 "/usr/include/zconf.h"
typedef char charf;
#line 403 "/usr/include/zconf.h"
typedef int intf;
#line 404 "/usr/include/zconf.h"
typedef uInt uIntf;
#line 405 "/usr/include/zconf.h"
typedef uLong uLongf;
#line 408 "/usr/include/zconf.h"
typedef void const   *voidpc;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 410 "/usr/include/zconf.h"
typedef void *voidp;
#line 429 "/usr/include/zconf.h"
typedef unsigned int z_crc_t;
#line 81 "/usr/include/zlib.h"
typedef voidpf (*alloc_func)(voidpf  , uInt  , uInt  );
#line 82 "/usr/include/zlib.h"
typedef void (*free_func)(voidpf  , voidpf  );
#line 84
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   alloc_func zalloc ;
   free_func zfree ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 106 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 114 "/usr/include/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 129 "/usr/include/zlib.h"
typedef struct gz_header_s gz_header;
#line 131 "/usr/include/zlib.h"
typedef gz_header *gz_headerp;
#line 1093 "/usr/include/zlib.h"
typedef unsigned int (*in_func)(void * , unsigned char ** );
#line 1095 "/usr/include/zlib.h"
typedef int (*out_func)(void * , unsigned char * , unsigned int  );
#line 1301
struct gzFile_s ;
#line 1301 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1818 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 32 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 70 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 481 "/usr/include/libpng16/pngconf.h"
typedef unsigned char png_byte;
#line 489 "/usr/include/libpng16/pngconf.h"
typedef short png_int_16;
#line 497 "/usr/include/libpng16/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/usr/include/libpng16/pngconf.h"
typedef int png_int_32;
#line 511 "/usr/include/libpng16/pngconf.h"
typedef unsigned int png_uint_32;
#line 523 "/usr/include/libpng16/pngconf.h"
typedef size_t png_size_t;
#line 524 "/usr/include/libpng16/pngconf.h"
typedef ptrdiff_t png_ptrdiff_t;
#line 557 "/usr/include/libpng16/pngconf.h"
typedef size_t png_alloc_size_t;
#line 574 "/usr/include/libpng16/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 577 "/usr/include/libpng16/pngconf.h"
typedef void *png_voidp;
#line 578 "/usr/include/libpng16/pngconf.h"
typedef void const   *png_const_voidp;
#line 579 "/usr/include/libpng16/pngconf.h"
typedef png_byte *png_bytep;
#line 580 "/usr/include/libpng16/pngconf.h"
typedef png_byte *png_const_bytep;
#line 581 "/usr/include/libpng16/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 582 "/usr/include/libpng16/pngconf.h"
typedef png_uint_32 *png_const_uint_32p;
#line 583 "/usr/include/libpng16/pngconf.h"
typedef png_int_32 *png_int_32p;
#line 584 "/usr/include/libpng16/pngconf.h"
typedef png_int_32 *png_const_int_32p;
#line 585 "/usr/include/libpng16/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 586 "/usr/include/libpng16/pngconf.h"
typedef png_uint_16 *png_const_uint_16p;
#line 587 "/usr/include/libpng16/pngconf.h"
typedef png_int_16 *png_int_16p;
#line 588 "/usr/include/libpng16/pngconf.h"
typedef png_int_16 *png_const_int_16p;
#line 589 "/usr/include/libpng16/pngconf.h"
typedef char *png_charp;
#line 590 "/usr/include/libpng16/pngconf.h"
typedef char const   *png_const_charp;
#line 591 "/usr/include/libpng16/pngconf.h"
typedef png_fixed_point *png_fixed_point_p;
#line 592 "/usr/include/libpng16/pngconf.h"
typedef png_fixed_point *png_const_fixed_point_p;
#line 593 "/usr/include/libpng16/pngconf.h"
typedef size_t *png_size_tp;
#line 594 "/usr/include/libpng16/pngconf.h"
typedef size_t *png_const_size_tp;
#line 597 "/usr/include/libpng16/pngconf.h"
typedef FILE *png_FILE_p;
#line 601 "/usr/include/libpng16/pngconf.h"
typedef double *png_doublep;
#line 602 "/usr/include/libpng16/pngconf.h"
typedef double const   *png_const_doublep;
#line 606 "/usr/include/libpng16/pngconf.h"
typedef png_byte **png_bytepp;
#line 607 "/usr/include/libpng16/pngconf.h"
typedef png_uint_32 **png_uint_32pp;
#line 608 "/usr/include/libpng16/pngconf.h"
typedef png_int_32 **png_int_32pp;
#line 609 "/usr/include/libpng16/pngconf.h"
typedef png_uint_16 **png_uint_16pp;
#line 610 "/usr/include/libpng16/pngconf.h"
typedef png_int_16 **png_int_16pp;
#line 611 "/usr/include/libpng16/pngconf.h"
typedef char const   **png_const_charpp;
#line 612 "/usr/include/libpng16/pngconf.h"
typedef char **png_charpp;
#line 613 "/usr/include/libpng16/pngconf.h"
typedef png_fixed_point **png_fixed_point_pp;
#line 615 "/usr/include/libpng16/pngconf.h"
typedef double **png_doublepp;
#line 619 "/usr/include/libpng16/pngconf.h"
typedef char ***png_charppp;
#line 446 "/usr/include/libpng16/png.h"
typedef char *png_libpng_version_1_6_37;
#line 454
struct png_struct_def ;
#line 454 "/usr/include/libpng16/png.h"
typedef struct png_struct_def png_struct;
#line 455 "/usr/include/libpng16/png.h"
typedef png_struct *png_const_structp;
#line 456 "/usr/include/libpng16/png.h"
typedef png_struct *png_structp;
#line 457 "/usr/include/libpng16/png.h"
typedef png_struct **png_structpp;
#line 468
struct png_info_def ;
#line 468 "/usr/include/libpng16/png.h"
typedef struct png_info_def png_info;
#line 469 "/usr/include/libpng16/png.h"
typedef png_info *png_infop;
#line 470 "/usr/include/libpng16/png.h"
typedef png_info *png_const_infop;
#line 471 "/usr/include/libpng16/png.h"
typedef png_info **png_infopp;
#line 484 "/usr/include/libpng16/png.h"
typedef png_struct *png_structrp;
#line 485 "/usr/include/libpng16/png.h"
typedef png_struct *png_const_structrp;
#line 486 "/usr/include/libpng16/png.h"
typedef png_info *png_inforp;
#line 487 "/usr/include/libpng16/png.h"
typedef png_info *png_const_inforp;
#line 493 "/usr/include/libpng16/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 498 "/usr/include/libpng16/png.h"
typedef struct png_color_struct png_color;
#line 499 "/usr/include/libpng16/png.h"
typedef png_color *png_colorp;
#line 500 "/usr/include/libpng16/png.h"
typedef png_color *png_const_colorp;
#line 501 "/usr/include/libpng16/png.h"
typedef png_color **png_colorpp;
#line 503 "/usr/include/libpng16/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 510 "/usr/include/libpng16/png.h"
typedef struct png_color_16_struct png_color_16;
#line 511 "/usr/include/libpng16/png.h"
typedef png_color_16 *png_color_16p;
#line 512 "/usr/include/libpng16/png.h"
typedef png_color_16 *png_const_color_16p;
#line 513 "/usr/include/libpng16/png.h"
typedef png_color_16 **png_color_16pp;
#line 515 "/usr/include/libpng16/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 522 "/usr/include/libpng16/png.h"
typedef struct png_color_8_struct png_color_8;
#line 523 "/usr/include/libpng16/png.h"
typedef png_color_8 *png_color_8p;
#line 524 "/usr/include/libpng16/png.h"
typedef png_color_8 *png_const_color_8p;
#line 525 "/usr/include/libpng16/png.h"
typedef png_color_8 **png_color_8pp;
#line 531 "/usr/include/libpng16/png.h"
struct png_sPLT_entry_struct {
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 alpha ;
   png_uint_16 frequency ;
};
#line 538 "/usr/include/libpng16/png.h"
typedef struct png_sPLT_entry_struct png_sPLT_entry;
#line 539 "/usr/include/libpng16/png.h"
typedef png_sPLT_entry *png_sPLT_entryp;
#line 540 "/usr/include/libpng16/png.h"
typedef png_sPLT_entry *png_const_sPLT_entryp;
#line 541 "/usr/include/libpng16/png.h"
typedef png_sPLT_entry **png_sPLT_entrypp;
#line 548 "/usr/include/libpng16/png.h"
struct png_sPLT_struct {
   png_charp name ;
   png_byte depth ;
   png_sPLT_entryp entries ;
   png_int_32 nentries ;
};
#line 554 "/usr/include/libpng16/png.h"
typedef struct png_sPLT_struct png_sPLT_t;
#line 555 "/usr/include/libpng16/png.h"
typedef png_sPLT_t *png_sPLT_tp;
#line 556 "/usr/include/libpng16/png.h"
typedef png_sPLT_t *png_const_sPLT_tp;
#line 557 "/usr/include/libpng16/png.h"
typedef png_sPLT_t **png_sPLT_tpp;
#line 577 "/usr/include/libpng16/png.h"
struct png_text_struct {
   int compression ;
   png_charp key ;
   png_charp text ;
   size_t text_length ;
   size_t itxt_length ;
   png_charp lang ;
   png_charp lang_key ;
};
#line 593 "/usr/include/libpng16/png.h"
typedef struct png_text_struct png_text;
#line 594 "/usr/include/libpng16/png.h"
typedef png_text *png_textp;
#line 595 "/usr/include/libpng16/png.h"
typedef png_text *png_const_textp;
#line 596 "/usr/include/libpng16/png.h"
typedef png_text **png_textpp;
#line 615 "/usr/include/libpng16/png.h"
struct png_time_struct {
   png_uint_16 year ;
   png_byte month ;
   png_byte day ;
   png_byte hour ;
   png_byte minute ;
   png_byte second ;
};
#line 623 "/usr/include/libpng16/png.h"
typedef struct png_time_struct png_time;
#line 624 "/usr/include/libpng16/png.h"
typedef png_time *png_timep;
#line 625 "/usr/include/libpng16/png.h"
typedef png_time *png_const_timep;
#line 626 "/usr/include/libpng16/png.h"
typedef png_time **png_timepp;
#line 637 "/usr/include/libpng16/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   size_t size ;
   png_byte location ;
};
#line 651 "/usr/include/libpng16/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 653 "/usr/include/libpng16/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 654 "/usr/include/libpng16/png.h"
typedef png_unknown_chunk *png_const_unknown_chunkp;
#line 655 "/usr/include/libpng16/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 773 "/usr/include/libpng16/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 781 "/usr/include/libpng16/png.h"
typedef struct png_row_info_struct png_row_info;
#line 783 "/usr/include/libpng16/png.h"
typedef png_row_info *png_row_infop;
#line 784 "/usr/include/libpng16/png.h"
typedef png_row_info **png_row_infopp;
#line 794 "/usr/include/libpng16/png.h"
typedef void (*png_error_ptr)(png_structp  , png_const_charp  );
#line 795 "/usr/include/libpng16/png.h"
typedef void (*png_rw_ptr)(png_structp  , png_bytep  , size_t  );
#line 796 "/usr/include/libpng16/png.h"
typedef void (*png_flush_ptr)(png_structp  );
#line 797 "/usr/include/libpng16/png.h"
typedef void (*png_read_status_ptr)(png_structp  , png_uint_32  , int  );
#line 799 "/usr/include/libpng16/png.h"
typedef void (*png_write_status_ptr)(png_structp  , png_uint_32  , int  );
#line 803 "/usr/include/libpng16/png.h"
typedef void (*png_progressive_info_ptr)(png_structp  , png_infop  );
#line 804 "/usr/include/libpng16/png.h"
typedef void (*png_progressive_end_ptr)(png_structp  , png_infop  );
#line 806 "/usr/include/libpng16/png.h"
typedef void (*png_progressive_frame_ptr)(png_structp  , png_uint_32  );
#line 820 "/usr/include/libpng16/png.h"
typedef void (*png_progressive_row_ptr)(png_structp  , png_bytep  , png_uint_32  ,
                                        int  );
#line 826 "/usr/include/libpng16/png.h"
typedef void (*png_user_transform_ptr)(png_structp  , png_row_infop  , png_bytep  );
#line 831 "/usr/include/libpng16/png.h"
typedef int (*png_user_chunk_ptr)(png_structp  , png_unknown_chunkp  );
#line 851 "/usr/include/libpng16/png.h"
typedef void (*png_longjmp_ptr)(jmp_buf  , int  );
#line 890 "/usr/include/libpng16/png.h"
typedef png_voidp (*png_malloc_ptr)(png_structp  , png_alloc_size_t  );
#line 892 "/usr/include/libpng16/png.h"
typedef void (*png_free_ptr)(png_structp  , png_voidp  );
#line 2694
struct png_control ;
#line 2694 "/usr/include/libpng16/png.h"
typedef struct png_control *png_controlp;
#line 2695 "/usr/include/libpng16/png.h"
struct __anonstruct_622 {
   png_controlp opaque ;
   png_uint_32 version ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 format ;
   png_uint_32 flags ;
   png_uint_32 colormap_entries ;
   png_uint_32 warning_or_error ;
   char message[64] ;
};
#line 2731 "/usr/include/libpng16/png.h"
typedef struct __anonstruct_622 png_image;
#line 2731 "/usr/include/libpng16/png.h"
typedef struct __anonstruct_622 *png_imagep;
#line 37 "/usr/include/libimagequant.h"
struct liq_attr ;
#line 37 "/usr/include/libimagequant.h"
typedef struct liq_attr liq_attr;
#line 38
struct liq_image ;
#line 38 "/usr/include/libimagequant.h"
typedef struct liq_image liq_image;
#line 39
struct liq_result ;
#line 39 "/usr/include/libimagequant.h"
typedef struct liq_result liq_result;
#line 40
struct liq_histogram ;
#line 40 "/usr/include/libimagequant.h"
typedef struct liq_histogram liq_histogram;
#line 42 "/usr/include/libimagequant.h"
struct liq_color {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
   unsigned char a ;
};
#line 44 "/usr/include/libimagequant.h"
typedef struct liq_color liq_color;
#line 46 "/usr/include/libimagequant.h"
struct liq_palette {
   unsigned int count ;
   liq_color entries[256] ;
};
#line 49 "/usr/include/libimagequant.h"
typedef struct liq_palette liq_palette;
#line 51
enum liq_error {
    LIQ_OK = 0,
    LIQ_QUALITY_TOO_LOW = 99,
    LIQ_VALUE_OUT_OF_RANGE = 100,
    LIQ_OUT_OF_MEMORY = 101,
    LIQ_ABORTED = 102,
    LIQ_BITMAP_NOT_AVAILABLE = 103,
    LIQ_BUFFER_TOO_SMALL = 104,
    LIQ_INVALID_POINTER = 105,
    LIQ_UNSUPPORTED = 106
} ;
#line 61 "/usr/include/libimagequant.h"
typedef enum liq_error liq_error;
#line 63
enum liq_ownership {
    LIQ_OWN_ROWS = 4,
    LIQ_OWN_PIXELS = 8,
    LIQ_COPY_PIXELS = 16
} ;
#line 69 "/usr/include/libimagequant.h"
struct liq_histogram_entry {
   liq_color color ;
   unsigned int count ;
};
#line 72 "/usr/include/libimagequant.h"
typedef struct liq_histogram_entry liq_histogram_entry;
#line 98 "/usr/include/libimagequant.h"
typedef void liq_log_callback_function(liq_attr * , char const   * , void * );
#line 99 "/usr/include/libimagequant.h"
typedef void liq_log_flush_callback_function(liq_attr * , void * );
#line 103 "/usr/include/libimagequant.h"
typedef int liq_progress_callback_function(float  , void * );
#line 111 "/usr/include/libimagequant.h"
typedef void liq_image_get_rgba_row_callback(liq_color [] , int  , int  , void * );
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
enum __anonenum__623 {
    LANG_ACH___1 = 0,
    LANG_AF___1 = 1,
    LANG_AK___1 = 2,
    LANG_AM___1 = 3,
    LANG_AN___1 = 4,
    LANG_AR___1 = 5,
    LANG_AS___1 = 6,
    LANG_AST___1 = 7,
    LANG_AZ___1 = 8,
    LANG_BE___1 = 9,
    LANG_BG___1 = 10,
    LANG_BM___1 = 11,
    LANG_BN___1 = 12,
    LANG_BO___1 = 13,
    LANG_BR___1 = 14,
    LANG_BRX___1 = 15,
    LANG_BS___1 = 16,
    LANG_CA_VALENCIA___1 = 17,
    LANG_CA___1 = 18,
    LANG_CGG___1 = 19,
    LANG_CS___1 = 20,
    LANG_CY___1 = 21,
    LANG_DA___1 = 22,
    LANG_DE___1 = 23,
    LANG_DOI___1 = 24,
    LANG_EL___1 = 25,
    LANG_EN___1 = 26,
    LANG_EN_AU___1 = 27,
    LANG_EN_CA___1 = 28,
    LANG_EN_GB___1 = 29,
    LANG_EN_ZA___1 = 30,
    LANG_EO___1 = 31,
    LANG_ES_MX___1 = 32,
    LANG_ES___1 = 33,
    LANG_ET___1 = 34,
    LANG_EU___1 = 35,
    LANG_FA___1 = 36,
    LANG_FF___1 = 37,
    LANG_FI___1 = 38,
    LANG_FO___1 = 39,
    LANG_FR___1 = 40,
    LANG_GA___1 = 41,
    LANG_GD___1 = 42,
    LANG_GL___1 = 43,
    LANG_GR___1 = 44,
    LANG_GU___1 = 45,
    LANG_HE___1 = 46,
    LANG_HI___1 = 47,
    LANG_HR___1 = 48,
    LANG_HU___1 = 49,
    LANG_HY___1 = 50,
    LANG_I_KLINGON_ROMANIZED___1 = 51,
    LANG_ID___1 = 52,
    LANG_IS___1 = 53,
    LANG_IT___1 = 54,
    LANG_IU___1 = 55,
    LANG_JA___1 = 56,
    LANG_KA___1 = 57,
    LANG_KAB___1 = 58,
    LANG_KN___1 = 59,
    LANG_KM___1 = 60,
    LANG_KOK_ROMAN___1 = 61,
    LANG_KOK___1 = 62,
    LANG_KO___1 = 63,
    LANG_KS_DEVANAGARI___1 = 64,
    LANG_KS___1 = 65,
    LANG_KU___1 = 66,
    LANG_LB___1 = 67,
    LANG_LG___1 = 68,
    LANG_LT___1 = 69,
    LANG_LV___1 = 70,
    LANG_MAI___1 = 71,
    LANG_ML___1 = 72,
    LANG_MK___1 = 73,
    LANG_MN___1 = 74,
    LANG_MNI_BENGALI___1 = 75,
    LANG_MNI_METEI_MAYEK___1 = 76,
    LANG_MR___1 = 77,
    LANG_MS___1 = 78,
    LANG_NB___1 = 79,
    LANG_NE___1 = 80,
    LANG_NL___1 = 81,
    LANG_NN___1 = 82,
    LANG_NR___1 = 83,
    LANG_NSO___1 = 84,
    LANG_OC___1 = 85,
    LANG_OJ___1 = 86,
    LANG_OR___1 = 87,
    LANG_PA___1 = 88,
    LANG_PL___1 = 89,
    LANG_PT_BR___1 = 90,
    LANG_PT___1 = 91,
    LANG_RO___1 = 92,
    LANG_RU___1 = 93,
    LANG_RW___1 = 94,
    LANG_SAT_OL_CHIKI___1 = 95,
    LANG_SAT___1 = 96,
    LANG_SA___1 = 97,
    LANG_SC___1 = 98,
    LANG_SD___1 = 99,
    LANG_SD_DEVANAGARI___1 = 100,
    LANG_SHS___1 = 101,
    LANG_SI___1 = 102,
    LANG_SK___1 = 103,
    LANG_SL___1 = 104,
    LANG_SON___1 = 105,
    LANG_SQ___1 = 106,
    LANG_SR_LATIN___1 = 107,
    LANG_SR___1 = 108,
    LANG_SU___1 = 109,
    LANG_SV___1 = 110,
    LANG_SW___1 = 111,
    LANG_TA___1 = 112,
    LANG_TE___1 = 113,
    LANG_TH___1 = 114,
    LANG_TL___1 = 115,
    LANG_TR___1 = 116,
    LANG_TW___1 = 117,
    LANG_UK___1 = 118,
    LANG_UR___1 = 119,
    LANG_VEC___1 = 120,
    LANG_VE___1 = 121,
    LANG_VI___1 = 122,
    LANG_WA___1 = 123,
    LANG_WO___1 = 124,
    LANG_XH___1 = 125,
    LANG_ZAM___1 = 126,
    LANG_ZH_CN___1 = 127,
    LANG_ZH_TW___1 = 128,
    LANG_ZU___1 = 129,
    NUM_LANGS___1 = 130
} ;
#line 38 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.h"
enum __anonenum__624 {
    SND_HARP___2 = 0,
    SND_CLICK___2 = 1,
    SND_BLEEP___2 = 2,
    SND_BUBBLE___2 = 3,
    SND_STAMP___2 = 4,
    SND_LINE_START___2 = 5,
    SND_LINE_END___2 = 6,
    SND_SCROLL___2 = 7,
    SND_PAINT1___2 = 8,
    SND_PAINT2___2 = 9,
    SND_PAINT3___2 = 10,
    SND_PAINT4___2 = 11,
    SND_ERASER1___2 = 12,
    SND_ERASER2___2 = 13,
    SND_SAVE___2 = 14,
    SND_PROMPT___2 = 15,
    SND_FLIP___2 = 16,
    SND_MIRROR___2 = 17,
    SND_KEYCLICK___2 = 18,
    SND_KEYCLICKRING___2 = 19,
    SND_RETURN___2 = 20,
    SND_SHRINK___2 = 21,
    SND_GROW___2 = 22,
    SND_ITALIC_ON___2 = 23,
    SND_ITALIC_OFF___2 = 24,
    SND_AREYOUSURE___2 = 25,
    SND_YOUCANNOT___2 = 26,
    SND_TUXOK___2 = 27,
    SND_THICK___2 = 28,
    SND_THIN___2 = 29,
    SND_FILL___2 = 30,
    NUM_SOUNDS___2 = 31
} ;
#line 94 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
enum __anonenum__625 {
    FONT_TYPE_PANGO___1 = 0,
    FONT_TYPE_TTF___1 = 1
} ;
#line 32 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/get_fname.h"
enum __anonenum__626 {
    DIR_SAVE___1 = 0,
    DIR_DATA___1 = 1,
    DIR_EXPORT___1 = 2,
    DIR_EXPORT_PARENT___1 = 3
} ;
#line 27 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_keymap {
   int keycode ;
   int disable_caps ;
   char *plain ;
   char *caps ;
   char *altgr ;
   char *shiftaltgr ;
};
#line 35 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_keymap osk_keymap;
#line 37 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_key {
   int keycode ;
   int row ;
   int x ;
   int y ;
   float width ;
   char *plain_label ;
   char *top_label ;
   char *altgr_label ;
   char *shift_altgr_label ;
   int shiftcaps ;
   int stick ;
};
#line 50 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_key osk_key;
#line 52 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_composenode {
   wchar_t *keysym ;
   wchar_t *result ;
   int size ;
   struct osk_composenode **childs ;
};
#line 59 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_composenode osk_composenode;
#line 61 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct keysymdefs {
   char *mnemo ;
   int keysym ;
   int unicode ;
};
#line 66 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct keysymdefs keysymdefs;
#line 68 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_layout {
   char *name ;
   int *rows ;
   int width ;
   int height ;
   char *fontpath ;
   osk_key **keys ;
   osk_keymap *keymap ;
   osk_composenode *composemap ;
   keysymdefs *keysymdefs ;
   unsigned int sizeofkeysymdefs ;
   SDL_Color bgcolor ;
   SDL_Color fgcolor ;
};
#line 82 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_layout osk_layout;
#line 84 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_keymodifiers {
   osk_key shift ;
   osk_key altgr ;
   osk_key compose ;
   osk_key dead ;
};
#line 90 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_keymodifiers osk_keymodifiers;
#line 92 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_kmdf {
   osk_key *shift ;
   osk_key *altgr ;
   osk_key *compose ;
   osk_key *dead ;
   osk_key *dead2 ;
   osk_key *dead3 ;
   osk_key *dead4 ;
};
#line 101 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_kmdf osk_kmdf;
#line 103 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_keyboard {
   char *name ;
   char *keyboard_list ;
   SDL_Surface *surface ;
   SDL_Surface *button_up ;
   SDL_Surface *button_down ;
   SDL_Surface *button_off ;
   SDL_Surface *button_nav ;
   SDL_Surface *button_hold ;
   SDL_Surface *oskdel ;
   SDL_Surface *osktab ;
   SDL_Surface *oskenter ;
   SDL_Surface *oskcapslock ;
   SDL_Surface *oskshift ;
   int changed ;
   SDL_Rect rect ;
   int recreated ;
   int modifiers ;
   osk_keymodifiers keymodifiers ;
   osk_kmdf kmdf ;
   osk_layout *layout ;
   char *layout_name[256] ;
   TTF_Font *osk_fonty ;
   int disable_change ;
   wchar_t *key[256] ;
   int keycode ;
   wchar_t *composed ;
   int composed_type ;
   osk_composenode *composing ;
   osk_key *last_key_pressed ;
   SDL_Surface *canvas_ptr ;
   SDL_Surface *LG_button_up ;
   SDL_Surface *LG_button_down ;
   SDL_Surface *LG_button_off ;
   SDL_Surface *LG_button_nav ;
   SDL_Surface *LG_button_hold ;
   SDL_Surface *LG_oskdel ;
   SDL_Surface *LG_osktab ;
   SDL_Surface *LG_oskenter ;
   SDL_Surface *LG_oskcapslock ;
   SDL_Surface *LG_oskshift ;
   SDL_Surface *SM_button_up ;
   SDL_Surface *SM_button_down ;
   SDL_Surface *SM_button_off ;
   SDL_Surface *SM_button_nav ;
   SDL_Surface *SM_button_hold ;
   SDL_Surface *SM_oskdel ;
   SDL_Surface *SM_osktab ;
   SDL_Surface *SM_oskenter ;
   SDL_Surface *SM_oskcapslock ;
   SDL_Surface *SM_oskshift ;
};
#line 158 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
typedef struct osk_keyboard on_screen_keyboard;
#line 36 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tip_tux.h"
enum __anonenum__627 {
    TUX_DEFAULT = 0,
    TUX_KISS = 1,
    TUX_BORED = 2,
    TUX_GREAT = 3,
    TUX_OOPS = 4,
    TUX_WAIT = 5,
    NUM_TIP_TUX = 6
} ;
#line 36 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
enum __anonenum__628 {
    TOOL_BRUSH = 0,
    TOOL_STAMP = 1,
    TOOL_LINES = 2,
    TOOL_SHAPES = 3,
    TOOL_TEXT = 4,
    TOOL_LABEL = 5,
    TOOL_FILL = 6,
    TOOL_MAGIC = 7,
    TOOL_UNDO = 8,
    TOOL_REDO = 9,
    TOOL_ERASER = 10,
    TOOL_NEW = 11,
    TOOL_OPEN = 12,
    TOOL_SAVE = 13,
    TOOL_PRINT = 14,
    TOOL_QUIT = 15,
    NUM_TOOLS = 16
} ;
#line 34 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/titles.h"
enum __anonenum__629 {
    TITLE_NONE = 0,
    TITLE_NOCOLORS = 1,
    TITLE_TOOLS = 2,
    TITLE_COLORS = 3,
    TITLE_BRUSHES = 4,
    TITLE_ERASERS = 5,
    TITLE_STAMPS = 6,
    TITLE_SHAPES = 7,
    TITLE_LETTERS = 8,
    TITLE_MAGIC = 9,
    TITLE_FILLS = 10,
    NUM_TITLES = 11
} ;
#line 36 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/colors.h"
enum __anonenum__630 {
    COLOR_BLACK = 0,
    COLOR_DARKGREY = 1,
    COLOR_LIGHTGREY = 2,
    COLOR_WHITE = 3,
    COLOR_RED = 4,
    COLOR_ORANGE = 5,
    COLOR_YELLOW = 6,
    COLOR_LIGHTGREEN = 7,
    COLOR_DARKGREEN = 8,
    COLOR_SKYBLUE = 9,
    COLOR_BLUE = 10,
    COLOR_LAVENDER = 11,
    COLOR_PURPLE = 12,
    COLOR_PINK = 13,
    COLOR_BROWN = 14,
    COLOR_TAN = 15,
    COLOR_BEIGE = 16,
    NUM_DEFAULT_COLORS = 17
} ;
#line 38 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
enum __anonenum__631 {
    SHAPE_SQUARE = 0,
    SHAPE_SQUARE_FILL = 1,
    SHAPE_RECTANGLE = 2,
    SHAPE_RECTANGLE_FILL = 3,
    SHAPE_CIRCLE = 4,
    SHAPE_CIRCLE_FILL = 5,
    SHAPE_ELLIPSE = 6,
    SHAPE_ELLIPSE_FILL = 7,
    SHAPE_TRIANGLE = 8,
    SHAPE_TRIANGLE_FILL = 9,
    SHAPE_PENTAGON = 10,
    SHAPE_PENTAGON_FILL = 11,
    SHAPE_RHOMBUS = 12,
    SHAPE_RHOMBUS_FILL = 13,
    SHAPE_OCTAGON = 14,
    SHAPE_OCTAGON_FILL = 15,
    SHAPE_TRIANGLE_STAR = 16,
    SHAPE_TRIANGLE_STAR_FILL = 17,
    SHAPE_RHOMBUS_STAR = 18,
    SHAPE_RHOMBUS_STAR_FILL = 19,
    SHAPE_PENTAGON_STAR = 20,
    SHAPE_PENTAGON_STAR_FILL = 21,
    NUM_SHAPES = 22
} ;
#line 363
enum __anonenum__632 {
    SHAPEMODE_CENTER = 0,
    SHAPEMODE_CORNER = 1,
    NUM_SHAPEMODES = 2
} ;
#line 378
enum __anonenum__633 {
    SHAPE_COMPLEXITY_NORMAL = 0,
    SHAPE_COMPLEXITY_SIMPLE = 1,
    NUM_SHAPE_COMPLEXITIES = 2
} ;
#line 41 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill_tools.h"
enum __anonenum__634 {
    FILL_FLOOD = 0,
    FILL_BRUSH = 1,
    FILL_GRADIENT_LINEAR = 2,
    FILL_GRADIENT_RADIAL = 3,
    NUM_FILLS = 4
} ;
#line 36 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/im.h"
struct IM_DATA {
   int lang ;
   wchar_t s[16] ;
   char const   *tip_text ;
   wchar_t buf[8] ;
   int redraw ;
   int request ;
};
#line 46 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/im.h"
typedef struct IM_DATA IM_DATA;
#line 654 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
enum __anonenum__635 {
    SAVE_OVER_UNSET = -1,
    SAVE_OVER_PROMPT = 0,
    SAVE_OVER_ALWAYS = 1,
    SAVE_OVER_NO = 2
} ;
#line 662
enum __anonenum__636 {
    ALTPRINT_MOD = 0,
    ALTPRINT_ALWAYS = 1,
    ALTPRINT_NEVER = 2
} ;
#line 670
enum __anonenum__637 {
    STARTER_OUTLINE = 0,
    STARTER_SCENE = 1
} ;
#line 676
enum __anonenum__638 {
    LABEL_OFF = 0,
    LABEL_LABEL = 1,
    LABEL_SELECT = 2
} ;
#line 720 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct __anonstruct_639 {
   Uint8 rows ;
   Uint8 cols ;
};
#line 723 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct __anonstruct_639 grid_dims;
#line 1312 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct label_node {
   unsigned int save_texttool_len ;
   wchar_t save_texttool_str[256] ;
   SDL_Color save_color ;
   int save_width ;
   int save_height ;
   Uint16 save_x ;
   Uint16 save_y ;
   int save_cur_font ;
   char *save_font_type ;
   int save_text_state ;
   unsigned int save_text_size ;
   int save_undoid ;
   int is_enabled ;
   struct label_node *disables ;
   struct label_node *next_to_up_label_node ;
   struct label_node *next_to_down_label_node ;
   SDL_Surface *label_node_surface ;
};
#line 1331 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct label_node label_node;
#line 91 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tp_magic_api.h"
struct magic_api_t {
   char *tp_version ;
   char *data_directory ;
   void (*update_progress_bar)(void) ;
   void (*special_notify)(int  ) ;
   float (*sRGB_to_linear)(Uint8  ) ;
   Uint8 (*linear_to_sRGB)(float  ) ;
   int (*in_circle)(int  , int  , int  ) ;
   Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
   void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
   void (*xorpixel)(SDL_Surface * , int  , int  ) ;
   void (*playsound)(Mix_Chunk * , int  , int  ) ;
   void (*stopsound)(void) ;
   void (*line)(void * , int  , SDL_Surface * , SDL_Surface * , int  , int  , int  ,
                int  , int  , void (*)(void * , int  , SDL_Surface * , SDL_Surface * ,
                                       int  , int  ) ) ;
   int (*button_down)(void) ;
   void (*rgbtohsv)(Uint8  , Uint8  , Uint8  , float * , float * , float * ) ;
   void (*hsvtorgb)(float  , float  , float  , Uint8 * , Uint8 * , Uint8 * ) ;
   int canvas_w ;
   int canvas_h ;
   SDL_Surface *(*scale)(SDL_Surface * , int  , int  , int  ) ;
   Uint8 (*touched)(int  , int  ) ;
};
#line 174 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tp_magic_api.h"
typedef struct magic_api_t magic_api;
#line 189
enum __anonenum__640 {
    MAGIC_TYPE_DISTORTS = 0,
    MAGIC_TYPE_COLOR_FILTERS = 1,
    MAGIC_TYPE_PICTURE_WARPS = 2,
    MAGIC_TYPE_PAINTING = 3,
    MAGIC_TYPE_PATTERN_PAINTING = 4,
    MAGIC_TYPE_PICTURE_DECORATIONS = 5,
    MAGIC_TYPE_ARTISTIC = 6
} ;
#line 1401 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct magic_funcs_s {
   int (*get_tool_count)(magic_api * ) ;
   int (*get_group)(magic_api * , int  ) ;
   char *(*get_name)(magic_api * , int  ) ;
   SDL_Surface *(*get_icon)(magic_api * , int  ) ;
   char *(*get_description)(magic_api * , int  , int  ) ;
   int (*requires_colors)(magic_api * , int  ) ;
   int (*modes)(magic_api * , int  ) ;
   void (*set_color)(magic_api * , Uint8  , Uint8  , Uint8  ) ;
   int (*init)(magic_api * ) ;
   Uint32 (*api_version)(void) ;
   void (*shutdown)(magic_api * ) ;
   void (*click)(magic_api * , int  , int  , SDL_Surface * , SDL_Surface * , int  ,
                 int  , SDL_Rect * ) ;
   void (*drag)(magic_api * , int  , SDL_Surface * , SDL_Surface * , int  , int  ,
                int  , int  , SDL_Rect * ) ;
   void (*release)(magic_api * , int  , SDL_Surface * , SDL_Surface * , int  , int  ,
                   SDL_Rect * ) ;
   void (*switchin)(magic_api * , int  , int  , SDL_Surface * , SDL_Surface * ) ;
   void (*switchout)(magic_api * , int  , int  , SDL_Surface * , SDL_Surface * ) ;
};
#line 1419 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct magic_funcs_s magic_funcs_t;
#line 1422 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct magic_s {
   int place ;
   int handle_idx ;
   int idx ;
   int mode ;
   int avail_modes ;
   int colors ;
   int group ;
   char *name ;
   char *tip[2] ;
   SDL_Surface *img_icon ;
   SDL_Surface *img_name ;
};
#line 1435 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct magic_s magic_t;
#line 1449
enum __anonenum__641 {
    MAGIC_PLACE_GLOBAL = 0,
    MAGIC_PLACE_LOCAL = 1,
    NUM_MAGIC_PLACES = 2
} ;
#line 45 "/usr/include/fribidi/fribidi-types.h"
typedef int fribidi_boolean;
#line 47 "/usr/include/fribidi/fribidi-types.h"
typedef uint32_t FriBidiChar;
#line 48 "/usr/include/fribidi/fribidi-types.h"
typedef int FriBidiStrIndex;
#line 51 "/usr/include/fribidi/fribidi-types.h"
typedef FriBidiChar FriBidiBracketType;
#line 35 "/usr/include/fribidi/fribidi-flags.h"
typedef uint32_t FriBidiFlags;
#line 36 "/usr/include/fribidi/fribidi-bidi-types.h"
typedef signed char FriBidiLevel;
#line 184
enum __anonenum__642 {
    FRIBIDI_TYPE_LTR = 272,
    FRIBIDI_TYPE_RTL = 273,
    FRIBIDI_TYPE_AL = 275,
    FRIBIDI_TYPE_EN = 544,
    FRIBIDI_TYPE_AN = 546,
    FRIBIDI_TYPE_ES = 66592,
    FRIBIDI_TYPE_ET = 132128,
    FRIBIDI_TYPE_CS = 263200,
    FRIBIDI_TYPE_NSM = 524320,
    FRIBIDI_TYPE_BN = 1050656,
    FRIBIDI_TYPE_BS = 2107456,
    FRIBIDI_TYPE_SS = 4204608,
    FRIBIDI_TYPE_WS = 8390720,
    FRIBIDI_TYPE_ON = 64,
    FRIBIDI_TYPE_LRE = 4112,
    FRIBIDI_TYPE_RLE = 4113,
    FRIBIDI_TYPE_LRO = 20496,
    FRIBIDI_TYPE_RLO = 20497,
    FRIBIDI_TYPE_PDF = 4128,
    FRIBIDI_TYPE_LRI = 32832,
    FRIBIDI_TYPE_RLI = 32833,
    FRIBIDI_TYPE_FSI = 33587264,
    FRIBIDI_TYPE_PDI = 32864,
    _FRIBIDI_TYPE_SENTINEL = 128
} ;
#line 191 "/usr/include/fribidi/fribidi-bidi-types.h"
typedef enum __anonenum__642 FriBidiCharType;
#line 193
enum __anonenum__643 {
    FRIBIDI_PAR_LTR = 272,
    FRIBIDI_PAR_RTL = 273,
    FRIBIDI_PAR_ON = 64,
    FRIBIDI_PAR_WLTR = 32,
    FRIBIDI_PAR_WRTL = 33,
    _FRIBIDI_PAR_SENTINEL = 128
} ;
#line 202 "/usr/include/fribidi/fribidi-bidi-types.h"
typedef enum __anonenum__643 FriBidiParType;
#line 80 "/usr/include/fribidi/fribidi-joining-types.h"
enum _FriBidiJoiningTypeEnum {
    FRIBIDI_JOINING_TYPE_U = 0,
    FRIBIDI_JOINING_TYPE_R = 5,
    FRIBIDI_JOINING_TYPE_D = 7,
    FRIBIDI_JOINING_TYPE_C = 3,
    FRIBIDI_JOINING_TYPE_T = 12,
    FRIBIDI_JOINING_TYPE_L = 6,
    FRIBIDI_JOINING_TYPE_G = 16,
    _FRIBIDI_JOINING_TYPE_JUNK = 17
} ;
#line 92 "/usr/include/fribidi/fribidi-joining-types.h"
typedef uint8_t FriBidiJoiningType;
#line 97 "/usr/include/fribidi/fribidi-joining-types.h"
typedef uint8_t FriBidiArabicProp;
#line 38 "/usr/include/fribidi/fribidi-char-sets.h"
enum __anonenum__644 {
    _FRIBIDI_CHAR_SET_NOT_FOUND = 0,
    FRIBIDI_CHAR_SET_UTF8 = 1,
    FRIBIDI_CHAR_SET_CAP_RTL = 2,
    FRIBIDI_CHAR_SET_ISO8859_6 = 3,
    FRIBIDI_CHAR_SET_ISO8859_8 = 4,
    FRIBIDI_CHAR_SET_CP1255 = 5,
    FRIBIDI_CHAR_SET_CP1256 = 6,
    _FRIBIDI_CHAR_SETS_NUM_PLUS_ONE = 7
} ;
#line 46 "/usr/include/fribidi/fribidi-char-sets.h"
typedef enum __anonenum__644 FriBidiCharSet;
#line 1490 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
enum __anonenum__645 {
    UNDO_STARTER_NONE = 0,
    UNDO_STARTER_MIRRORED = 1,
    UNDO_STARTER_FLIPPED = 2
} ;
#line 1767 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct stamp_type {
   char *stampname ;
   char *stxt ;
   Uint8 locale_text ;
   Mix_Chunk *ssnd ;
   Mix_Chunk *sdesc ;
   SDL_Surface *thumbnail ;
   unsigned int thumb_mirrored ;
   unsigned int thumb_flipped ;
   unsigned int thumb_mirrored_flipped ;
   unsigned int no_premirror ;
   unsigned int no_preflip ;
   unsigned int no_premirrorflip ;
   unsigned int processed ;
   unsigned int no_sound ;
   unsigned int no_descsound ;
   unsigned int no_txt ;
   unsigned int tinter ;
   unsigned int colorable ;
   unsigned int tintable ;
   unsigned int mirrorable ;
   unsigned int flipable ;
   unsigned int mirrored ;
   unsigned int flipped ;
   unsigned int min ;
   unsigned int size ;
   unsigned int max ;
   unsigned int is_svg ;
};
#line 1805 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct stamp_type stamp_type;
#line 1872
enum __anonenum__646 {
    BRUSH_DIRECTION_RIGHT = 0,
    BRUSH_DIRECTION_DOWN_RIGHT = 1,
    BRUSH_DIRECTION_DOWN = 2,
    BRUSH_DIRECTION_DOWN_LEFT = 3,
    BRUSH_DIRECTION_LEFT = 4,
    BRUSH_DIRECTION_UP_LEFT = 5,
    BRUSH_DIRECTION_UP = 6,
    BRUSH_DIRECTION_UP_RIGHT = 7,
    BRUSH_DIRECTION_NONE = 8
} ;
#line 1930 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct edge_type {
   int y_upper ;
   float x_intersect ;
   float dx_per_scan ;
   struct edge_type *next ;
};
#line 1935 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct edge_type edge;
#line 1938 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct point_type {
   int x ;
   int y ;
};
#line 1941 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct point_type point_type;
#line 1943 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct fpoint_type {
   float x ;
   float y ;
};
#line 1946 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct fpoint_type fpoint_type;
#line 1948
enum __anonenum__647 {
    Left = 0,
    Right = 1,
    Bottom = 2,
    Top = 3
} ;
#line 1949 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef enum __anonenum__647 an_edge;
#line 1958 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct dirent2 {
   struct dirent f ;
   int place ;
};
#line 1962 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct dirent2 dirent2;
#line 2303
enum __anonenum__648 {
    SHAPE_TOOL_MODE_STRETCH = 0,
    SHAPE_TOOL_MODE_ROTATE = 1,
    SHAPE_TOOL_MODE_DONE = 2
} ;
#line 6278 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
struct multichan {
   double L ;
   double hue ;
   double sat ;
   unsigned char or ;
   unsigned char og ;
   unsigned char ob ;
   unsigned char alpha ;
};
#line 6282 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
typedef struct multichan multichan;
#line 143 "/usr/include/stdio.h"
extern FILE *stdin ;
#line 144
extern FILE *stdout ;
#line 145
extern FILE *stderr ;
#line 152
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 154
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 158
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 170
extern  __attribute__((__nothrow__)) int renameat2(int __oldfd , char const   *__old ,
                                                   int __newfd , char const   *__new ,
                                                   unsigned int __flags ) ;
#line 178
extern int fclose(FILE *__stream ) ;
#line 188
extern FILE *tmpfile(void) ;
#line 200
extern FILE *tmpfile64(void) ;
#line 205
extern  __attribute__((__nothrow__)) char *tmpnam(char [20] ) ;
#line 210
extern  __attribute__((__nothrow__)) char *tmpnam_r(char __s[20] ) ;
#line 222
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx ) ;
#line 230
extern int fflush(FILE *__stream ) ;
#line 239
extern int fflush_unlocked(FILE *__stream ) ;
#line 249
extern int fcloseall(void) ;
#line 258
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 265
extern FILE *freopen(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 283
extern FILE *fopen64(char const   *__filename , char const   *__modes ) ;
#line 286
extern FILE *freopen64(char const   *__filename , char const   *__modes , FILE *__stream ) ;
#line 293
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 300
extern  __attribute__((__nothrow__)) FILE *fopencookie(void *__magic_cookie , char const   *__modes ,
                                                       cookie_io_functions_t __io_funcs ) ;
#line 308
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 314
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 328
extern  __attribute__((__nothrow__)) void setbuf(FILE *__stream , char *__buf ) ;
#line 332
extern  __attribute__((__nothrow__)) int setvbuf(FILE *__stream , char *__buf , int __modes ,
                                                 size_t __n ) ;
#line 338
extern  __attribute__((__nothrow__)) void setbuffer(FILE *__stream , char *__buf ,
                                                    size_t __size ) ;
#line 342
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 350
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 356
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 371
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 378
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 382
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 393
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 396
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 403
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 406
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 415
extern int fscanf(FILE *__stream , char const   *__format  , ...) ;
#line 421
extern int scanf(char const   *__format  , ...) ;
#line 423
extern  __attribute__((__nothrow__)) int sscanf(char const   *__s , char const   *__format 
                                                , ...) ;
#line 459
extern int vfscanf(FILE *__s , char const   *__format , __gnuc_va_list __arg ) ;
#line 467
extern int vscanf(char const   *__format , __gnuc_va_list __arg ) ;
#line 471
extern  __attribute__((__nothrow__)) int vsscanf(char const   *__s , char const   *__format ,
                                                 __gnuc_va_list __arg ) ;
#line 513
extern int fgetc(FILE *__stream ) ;
#line 514
extern int getc(FILE *__stream ) ;
#line 520
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 527
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 538
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 549
extern int fputc(int __c , FILE *__stream ) ;
#line 550
extern int putc(int __c , FILE *__stream ) ;
#line 556
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 565
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 573
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 574
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 581
extern int getw(FILE *__stream ) ;
#line 584
extern int putw(int __w , FILE *__stream ) ;
#line 592
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 615
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 632
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 635
extern __ssize_t getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 645
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 655
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 661
extern int puts(char const   *__s ) ;
#line 668
extern int ungetc(int __c , FILE *__stream ) ;
#line 675
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 681
extern unsigned long fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 691
extern int fputs_unlocked(char const   *__s , FILE *__stream ) ;
#line 702
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 704
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 713
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 718
extern long ftell(FILE *__stream ) ;
#line 723
extern void rewind(FILE *__stream ) ;
#line 736
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 741
extern __off_t ftello(FILE *__stream ) ;
#line 760
extern int fgetpos(FILE *__stream , fpos_t *__pos ) ;
#line 765
extern int fsetpos(FILE *__stream , fpos_t *__pos ) ;
#line 779
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 780
extern __off64_t ftello64(FILE *__stream ) ;
#line 781
extern int fgetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 782
extern int fsetpos64(FILE *__stream , fpos64_t *__pos ) ;
#line 786
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 788
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 790
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 794
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 795
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 804
extern void perror(char const   *__s ) ;
#line 809
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 814
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 823
extern int pclose(FILE *__stream ) ;
#line 829
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 837
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 844
extern char *cuserid(char *__s ) ;
#line 853
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 856
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 867
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 871
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 874
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 885
extern int __uflow(FILE * ) ;
#line 886
extern int __overflow(FILE * , int  ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 49
  __cil_tmp1 = getc(stdin);
  }
#line 49
  return (__cil_tmp1);
}
}
#line 56
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 56 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 58
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 58
  if (__cil_tmp2) {
    {
#line 58
    __cil_tmp3 = __uflow(__fp);
#line 58
    tmp = __cil_tmp3;
    }
  } else {
#line 58
    (__fp->_IO_read_ptr) ++;
#line 58
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 58
  return (tmp);
}
}
#line 73
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int tmp ;

  {
  {
#line 75
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 75
  if (__cil_tmp1) {
    {
#line 75
    __cil_tmp2 = __uflow(stdin);
#line 75
    tmp = __cil_tmp2;
    }
  } else {
#line 75
    (stdin->_IO_read_ptr) ++;
#line 75
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 75
  return (tmp);
}
}
#line 82
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 84
  __cil_tmp2 = putc(__c, stdout);
  }
#line 84
  return (__cil_tmp2);
}
}
#line 91
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 91 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 93
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 93
  if (__cil_tmp3) {
    {
#line 93
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 93
    tmp = __cil_tmp4;
    }
  } else {
#line 93
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 93
    (__stream->_IO_write_ptr) ++;
#line 93
    *__cil_tmp5 = (char )__c;
#line 93
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 93
  return (tmp);
}
}
#line 108
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 110
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 110
  if (__cil_tmp2) {
    {
#line 110
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 110
    tmp = __cil_tmp3;
    }
  } else {
#line 110
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 110
    (stdout->_IO_write_ptr) ++;
#line 110
    *__cil_tmp4 = (char )__c;
#line 110
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 110
  return (tmp);
}
}
#line 118
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 120
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 120
  return (__cil_tmp4);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 130
  return ((__stream->_flags & 16) != 0);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 137
  return ((__stream->_flags & 32) != 0);
}
}
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
extern  __attribute__((__nothrow__)) int __sprintf_chk(char *__s , int __flag , size_t __slen ,
                                                       char const   *__format  , ...) ;
#line 29
extern  __attribute__((__nothrow__)) int __vsprintf_chk(char *__s , int __flag , size_t __slen ,
                                                        char const   *__format , __gnuc_va_list __ap ) ;
#line 36
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 38
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
  {
#line 38
  __cil_tmp4 = __builtin_va_arg_pack();
#line 38
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 38
  return (__cil_tmp5);
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 52
  __cil_tmp4 = __builtin_object_size(__s, 1);
#line 52
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 52
  return (__cil_tmp5);
}
}
#line 58
extern  __attribute__((__nothrow__)) int __snprintf_chk(char *__s , size_t __n , int __flag ,
                                                        size_t __slen , char const   *__format 
                                                        , ...) ;
#line 62
extern  __attribute__((__nothrow__)) int __vsnprintf_chk(char *__s , size_t __n ,
                                                         int __flag , size_t __slen ,
                                                         char const   *__format ,
                                                         __gnuc_va_list __ap ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 71
  __cil_tmp5 = __builtin_va_arg_pack();
#line 71
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 71
  return (__cil_tmp6);
}
}
#line 82
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 85
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 85
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 85
  return (__cil_tmp6);
}
}
#line 93
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 95
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 96
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 98
extern int __vprintf_chk(int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 103
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 105
  __cil_tmp3 = __builtin_va_arg_pack();
#line 105
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 105
  return (__cil_tmp4);
}
}
#line 110
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 110 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 112
  __cil_tmp2 = __builtin_va_arg_pack();
#line 112
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 112
  return (__cil_tmp3);
}
}
#line 122
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 122 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 125
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 125
  return (__cil_tmp3);
}
}
#line 132
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 135
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 135
  return (__cil_tmp4);
}
}
#line 139
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 141
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 147
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 147 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 149
  __cil_tmp3 = __builtin_va_arg_pack();
#line 149
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 149
  return (__cil_tmp4);
}
}
#line 158
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 158 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 160
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 160
  return (__cil_tmp4);
}
}
#line 166
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 169
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 172
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 176
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 184
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 186
  __cil_tmp3 = __builtin_va_arg_pack();
#line 186
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 186
  return (__cil_tmp4);
}
}
#line 199
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_va_arg_pack();
#line 202
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 202
  return (__cil_tmp4);
}
}
#line 215
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 215 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 218
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 218
  return (__cil_tmp4);
}
}
#line 222
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 222 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 225
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 225
  return (__cil_tmp4);
}
}
#line 248
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 251
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 255
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 262
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 264
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 264
  sz = __cil_tmp5;
#line 265
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 265
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 265
  if (__cil_tmp6) {
#line 265
    if (__n > 0) {
#line 265
      if (__cil_tmp7) {
#line 265
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 266
          __cil_tmp8 = __fgets_alias(__s, __n, __stream);
          }
#line 266
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 267
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 267
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 267
  if (__cil_tmp9) {
#line 267
    if (__n > 0) {
#line 267
      if (__cil_tmp10) {
#line 267
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 268
          __cil_tmp11 = __fgets_chk_warn(__s, sz, __n, __stream);
          }
#line 268
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 269
  __cil_tmp12 = __fgets_chk(__s, sz, __n, __stream);
  }
#line 269
  return (__cil_tmp12);
}
}
#line 272
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 275
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 279
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 288
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 288 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern unsigned long fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 291
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 291
  sz = __cil_tmp6;
#line 292
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 292
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 292
  if (__cil_tmp8) {
#line 292
    if ((unsigned long )__n <= sz / __size) {
      {
#line 293
      __cil_tmp9 = __fread_alias(__ptr, __size, __n, __stream);
      }
#line 293
      return (__cil_tmp9);
    }
  }
  {
#line 294
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 294
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 294
  if (__cil_tmp11) {
#line 294
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 295
      __cil_tmp12 = __fread_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 295
      return (__cil_tmp12);
    }
  }
  {
#line 296
  __cil_tmp13 = __fread_chk(__ptr, sz, __size, __n, __stream);
  }
#line 296
  return (__cil_tmp13);
}
}
#line 300
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 307
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 314
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 316
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 316
  sz = __cil_tmp5;
#line 317
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 317
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 317
  if (__cil_tmp6) {
#line 317
    if (__n > 0) {
#line 317
      if (__cil_tmp7) {
#line 317
        if ((unsigned long )__n <= sz / sizeof(char )) {
          {
#line 318
          __cil_tmp8 = __fgets_unlocked_alias(__s, __n, __stream);
          }
#line 318
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 319
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 319
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 319
  if (__cil_tmp9) {
#line 319
    if (__n > 0) {
#line 319
      if (__cil_tmp10) {
#line 319
        if (! ((unsigned long )__n <= sz / sizeof(char ))) {
          {
#line 320
          __cil_tmp11 = __fgets_unlocked_chk_warn(__s, sz, __n, __stream);
          }
#line 320
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 321
  __cil_tmp12 = __fgets_unlocked_chk(__s, sz, __n, __stream);
  }
#line 321
  return (__cil_tmp12);
}
}
#line 327
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 330
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 334
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 343
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  size_t __cil_tmp19 ;
  size_t __cil_tmp20 ;

  {
  {
#line 346
  __cil_tmp6 = __builtin_object_size(__ptr, 0);
#line 346
  sz = __cil_tmp6;
#line 347
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 347
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 347
  if (__cil_tmp8) {
#line 347
    if ((unsigned long )__n <= sz / __size) {
      {
#line 350
      __cil_tmp10 = __builtin_constant_p(__n);
      }
      {
#line 350
      __cil_tmp9 = __builtin_constant_p(__size);
      }
#line 350
      if (__cil_tmp9) {
#line 350
        if (__cil_tmp10) {
#line 350
          if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 350
            if (__size * __n <= 8UL) {
#line 355
              __cnt = __size * __n;
#line 356
              __cptr = (char *)__ptr;
#line 357
              if (__cnt == 0UL) {
#line 358
                return ((size_t )0);
              }
              {
#line 360
              while (1) {
                while_continue: /* CIL Label */ ;
#line 360
                if (! (__cnt > 0UL)) {
#line 360
                  goto while_break;
                }
                {
#line 362
                __cil_tmp14 = getc_unlocked(__stream);
#line 362
                __c = __cil_tmp14;
                }
#line 363
                if (__c == -1) {
#line 364
                  goto while_break;
                }
#line 365
                __cil_tmp15 = __cptr;
#line 365
                __cptr ++;
#line 365
                *__cil_tmp15 = (char )__c;
#line 360
                __cnt --;
              }
              while_break: /* CIL Label */ ;
              }
#line 367
              return ((unsigned long )(__cptr - (char *)__ptr) / __size);
            }
          }
        }
      }
      {
#line 370
      __cil_tmp16 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
      }
#line 370
      return (__cil_tmp16);
    }
  }
  {
#line 372
  __cil_tmp18 = __builtin_constant_p((unsigned long )__n <= sz / __size);
  }
  {
#line 372
  __cil_tmp17 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp18) {
#line 372
    if (! ((unsigned long )__n <= sz / __size)) {
      {
#line 373
      __cil_tmp19 = __fread_unlocked_chk_warn(__ptr, sz, __size, __n, __stream);
      }
#line 373
      return (__cil_tmp19);
    }
  }
  {
#line 374
  __cil_tmp20 = __fread_unlocked_chk(__ptr, sz, __size, __n, __stream);
  }
#line 374
  return (__cil_tmp20);
}
}
#line 77 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 80
extern  __attribute__((__nothrow__)) __sighandler_t sysv_signal(int __sig , __sighandler_t __handler ) ;
#line 88
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , __sighandler_t __handler ) ;
#line 112
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 119
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 123
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 127
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , __sighandler_t __handler ) ;
#line 129
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 134
extern void psignal(int __sig , char const   *__s ) ;
#line 137
extern void psiginfo(siginfo_t *__pinfo , char const   *__s ) ;
#line 151
extern int sigpause(int __sig ) ;
#line 173
extern  __attribute__((__nothrow__)) int sigblock(int __mask ) ;
#line 176
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask ) ;
#line 179
extern  __attribute__((__nothrow__)) int siggetmask(void) ;
#line 199
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set ) ;
#line 205
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo ) ;
#line 208
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo ) ;
#line 211
extern  __attribute__((__nothrow__)) int sigismember(sigset_t *__set , int __signo ) ;
#line 216
extern  __attribute__((__nothrow__)) int sigisemptyset(sigset_t *__set ) ;
#line 219
extern  __attribute__((__nothrow__)) int sigandset(sigset_t *__set , sigset_t *__left ,
                                                   sigset_t *__right ) ;
#line 223
extern  __attribute__((__nothrow__)) int sigorset(sigset_t *__set , sigset_t *__left ,
                                                  sigset_t *__right ) ;
#line 232
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t *__set ,
                                                     sigset_t *__oset ) ;
#line 240
extern int sigsuspend(sigset_t *__set ) ;
#line 243
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction *__act ,
                                                   struct sigaction *__oact ) ;
#line 247
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set ) ;
#line 255
extern int sigwait(sigset_t *__set , int *__sig ) ;
#line 264
extern int sigwaitinfo(sigset_t *__set , siginfo_t *__info ) ;
#line 273
extern int sigtimedwait(sigset_t *__set , siginfo_t *__info , struct timespec *__timeout ) ;
#line 292
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 324
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type ) ;
#line 292
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type ) ;
#line 296
extern  __attribute__((__nothrow__)) int eaccess(char const   *__name , int __type ) ;
#line 300
extern  __attribute__((__nothrow__)) int execveat(int __fd , char const   *__path ,
                                                  char * const  __argv[] , char * const  __envp[] ,
                                                  int __flags ) ;
#line 309
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag ) ;
#line 339
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 350
extern  __attribute__((__nothrow__)) __off64_t lseek64(int __fd , __off64_t __offset ,
                                                       int __whence ) ;
#line 358
extern int close(int __fd ) ;
#line 363
extern  __attribute__((__nothrow__)) void closefrom(int __lowfd ) ;
#line 371
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 378
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 389
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 398
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
#line 422
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 427
extern ssize_t pwrite64(int __fd , void const   *__buf , size_t __n , __off64_t __offset ) ;
#line 437
extern  __attribute__((__nothrow__)) int pipe(int __pipedes[2] ) ;
#line 442
extern  __attribute__((__nothrow__)) int pipe2(int __pipedes[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 464
extern unsigned int sleep(unsigned int __seconds ) ;
#line 472
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 480
extern int usleep(__useconds_t __useconds ) ;
#line 489
extern int pause(void) ;
#line 493
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group ) ;
#line 498
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 503
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group ) ;
#line 511
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag ) ;
#line 517
extern  __attribute__((__nothrow__)) int chdir(char const   *__path ) ;
#line 521
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 531
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 537
extern  __attribute__((__nothrow__)) char *get_current_dir_name(void) ;
#line 545
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 552
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 555
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 560
extern  __attribute__((__nothrow__)) int dup3(int __fd , int __fd2 , int __flags ) ;
#line 564
extern char **__environ ;
#line 566
extern char **environ ;
#line 572
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  __argv[] ,
                                                char * const  __envp[] ) ;
#line 578
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 584
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  __argv[] ) ;
#line 589
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...) ;
#line 594
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...) ;
#line 599
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  __argv[] ) ;
#line 605
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...) ;
#line 611
extern  __attribute__((__nothrow__)) int execvpe(char const   *__file , char * const  __argv[] ,
                                                 char * const  __envp[] ) ;
#line 619
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 624
extern void _exit(int __status ) ;
#line 633
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name ) ;
#line 637
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 640
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 644
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 650
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 653
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 656
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 659
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 661
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 668
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 682
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 689
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 693
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 697
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 700
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 706
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 715
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 722
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 727
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 732
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 739
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 744
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 749
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 755
extern  __attribute__((__nothrow__)) int getresuid(__uid_t *__ruid , __uid_t *__euid ,
                                                   __uid_t *__suid ) ;
#line 760
extern  __attribute__((__nothrow__)) int getresgid(__gid_t *__rgid , __gid_t *__egid ,
                                                   __gid_t *__sgid ) ;
#line 765
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 770
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 778
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 786
extern  __attribute__((__nothrow__)) int vfork(void) ;
#line 793
extern  __attribute__((__nothrow__)) __pid_t _Fork(void) ;
#line 799
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 803
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 809
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 814
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 819
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to ) ;
#line 825
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags ) ;
#line 832
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to ) ;
#line 838
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 847
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to ) ;
#line 851
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 858
extern  __attribute__((__nothrow__)) int unlink(char const   *__name ) ;
#line 862
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag ) ;
#line 867
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path ) ;
#line 871
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 874
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 881
extern char *getlogin(void) ;
#line 889
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 895
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 55
extern int opterr ;
#line 59
extern int optopt ;
#line 91
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 911 "/usr/include/unistd.h"
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 919
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len ) ;
#line 924
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 930
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 933
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len ) ;
#line 939
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 942
extern  __attribute__((__nothrow__)) int revoke(char const   *__file ) ;
#line 950
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale ) ;
#line 958
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 962
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 963
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 964
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 970
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 977
extern  __attribute__((__nothrow__)) int chroot(char const   *__path ) ;
#line 981
extern char *getpass(char const   *__prompt ) ;
#line 989
extern int fsync(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) int syncfs(int __fd ) ;
#line 1002
extern long gethostid(void) ;
#line 1005
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 1011
extern  __attribute__((__nothrow__)) int getpagesize(void) ;
#line 1016
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 1026
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off_t __length ) ;
#line 1038
extern  __attribute__((__nothrow__)) int truncate64(char const   *__file , __off64_t __length ) ;
#line 1049
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 1059
extern  __attribute__((__nothrow__)) int ftruncate64(int __fd , __off64_t __length ) ;
#line 1070
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 1076
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1091
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1114
extern int lockf(int __fd , int __cmd , __off_t __len ) ;
#line 1124
extern int lockf64(int __fd , int __cmd , __off64_t __len ) ;
#line 1142
ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                        size_t __length , unsigned int __flags ) ;
#line 1150
extern int fdatasync(int __fildes ) ;
#line 1159
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt ) ;
#line 1168
extern  __attribute__((__nothrow__)) void swab(void const   *__from , void *__to ,
                                               ssize_t __n ) ;
#line 1198
int getentropy(void *__buffer , size_t __length ) ;
#line 1208
extern  __attribute__((__nothrow__)) int close_range(unsigned int __fd , unsigned int __max_fd ,
                                                     int __flags ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 26
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 29
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 36
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 38
  __cil_tmp7 = __builtin_object_size(__buf, 0);
  }
  {
#line 38
  __cil_tmp5 = __builtin_object_size(__buf, 0);
#line 38
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 38
  __cil_tmp4 = __builtin_constant_p(__nbytes);
  }
#line 38
  if (__cil_tmp6 && (unsigned long )__nbytes <= __cil_tmp7 / sizeof(char )) {
    {
#line 38
    __cil_tmp8 = __read_alias(__fd, __buf, __nbytes);
#line 38
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 38
    __cil_tmp12 = __builtin_object_size(__buf, 0);
    }
    {
#line 38
    __cil_tmp10 = __builtin_object_size(__buf, 0);
#line 38
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 38
    __cil_tmp9 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (__cil_tmp11 && ! ((unsigned long )__nbytes <= __cil_tmp12 / sizeof(char ))) {
      {
#line 38
      __cil_tmp13 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp14 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp13);
#line 38
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 38
      __cil_tmp15 = __builtin_object_size(__buf, 0);
#line 38
      __cil_tmp16 = __read_chk(__fd, __buf, __nbytes, __cil_tmp15);
#line 38
      tmp = __cil_tmp16;
      }
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  return (tmp___0);
}
}
#line 44
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 47
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 50
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 54
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 74
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 74
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 74
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 74
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 74
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 74
    __cil_tmp9 = __pread_alias(__fd, __buf, __nbytes, __offset);
#line 74
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 74
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 74
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 74
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 74
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 74
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 74
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp15 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 74
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 74
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 74
      __cil_tmp17 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 74
      tmp = __cil_tmp17;
      }
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 90
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 90 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 92
  __cil_tmp8 = __builtin_object_size(__buf, 0);
  }
  {
#line 92
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 92
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 92
  __cil_tmp5 = __builtin_constant_p(__nbytes);
  }
#line 92
  if (__cil_tmp7 && (unsigned long )__nbytes <= __cil_tmp8 / sizeof(char )) {
    {
#line 92
    __cil_tmp9 = __pread64_alias(__fd, __buf, __nbytes, __offset);
#line 92
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 92
    __cil_tmp13 = __builtin_object_size(__buf, 0);
    }
    {
#line 92
    __cil_tmp11 = __builtin_object_size(__buf, 0);
#line 92
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nbytes <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 92
    __cil_tmp10 = __builtin_constant_p(__nbytes);
    }
#line 92
    if (__cil_tmp12 && ! ((unsigned long )__nbytes <= __cil_tmp13 / sizeof(char ))) {
      {
#line 92
      __cil_tmp14 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp15 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp14);
#line 92
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 92
      __cil_tmp16 = __builtin_object_size(__buf, 0);
#line 92
      __cil_tmp17 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp16);
#line 92
      tmp = __cil_tmp17;
      }
    }
#line 92
    tmp___0 = tmp;
  }
#line 92
  return (tmp___0);
}
}
#line 100
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 104
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 108
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  ssize_t __cil_tmp16 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 119
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 119
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 119
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 119
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 119
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 119
    __cil_tmp8 = __readlink_alias(__path, __buf, __len);
#line 119
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 119
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 119
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 119
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 119
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 119
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 119
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp14 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp13);
#line 119
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 119
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 119
      __cil_tmp16 = __readlink_chk(__path, __buf, __len, __cil_tmp15);
#line 119
      tmp = __cil_tmp16;
      }
    }
#line 119
    tmp___0 = tmp;
  }
#line 119
  return (tmp___0);
}
}
#line 126
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 130
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 135
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  ssize_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 147
  __cil_tmp8 = __builtin_object_size(__buf, 1);
  }
  {
#line 147
  __cil_tmp6 = __builtin_object_size(__buf, 1);
#line 147
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 147
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 147
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 147
    __cil_tmp9 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 147
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 147
    __cil_tmp13 = __builtin_object_size(__buf, 1);
    }
    {
#line 147
    __cil_tmp11 = __builtin_object_size(__buf, 1);
#line 147
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 147
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 147
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 147
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp15 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp14);
#line 147
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 147
      __cil_tmp16 = __builtin_object_size(__buf, 1);
#line 147
      __cil_tmp17 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp16);
#line 147
      tmp = __cil_tmp17;
      }
    }
#line 147
    tmp___0 = tmp;
  }
#line 147
  return (tmp___0);
}
}
#line 153
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 155
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 157
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 164
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 164 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  char *__cil_tmp15 ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 166
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 166
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 166
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 166
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 166
  if (__cil_tmp5 && (unsigned long )__size <= __cil_tmp6 / sizeof(char )) {
    {
#line 166
    __cil_tmp7 = __getcwd_alias(__buf, __size);
#line 166
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 166
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 166
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 166
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 166
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 166
    if (__cil_tmp10 && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(char ))) {
      {
#line 166
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp13 = __getcwd_chk_warn(__buf, __size, __cil_tmp12);
#line 166
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 166
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 166
      __cil_tmp15 = __getcwd_chk(__buf, __size, __cil_tmp14);
#line 166
      tmp = __cil_tmp15;
      }
    }
#line 166
    tmp___0 = tmp;
  }
#line 166
  return (tmp___0);
}
}
#line 172
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 174
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 179
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 179 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 181
  __cil_tmp2 = __builtin_object_size(__buf, 1);
  }
#line 181
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 182
    __cil_tmp3 = __builtin_object_size(__buf, 1);
#line 182
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 182
    return (__cil_tmp4);
  }
  {
#line 183
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 183
  return (__cil_tmp5);
}
}
#line 187
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 190
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 193
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 202
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 202
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 202
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 202
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 202
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 202
    __cil_tmp8 = __confstr_alias(__name, __buf, __len);
#line 202
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 202
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 202
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 202
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 202
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 202
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 202
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp14 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp13);
#line 202
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 202
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 202
      __cil_tmp16 = __confstr_chk(__name, __buf, __len, __cil_tmp15);
#line 202
      tmp = __cil_tmp16;
      }
    }
#line 202
    tmp___0 = tmp;
  }
#line 202
  return (tmp___0);
}
}
#line 208
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 210
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 212
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 219
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 219 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 221
  __cil_tmp6 = __builtin_object_size(__list, 1);
  }
  {
#line 221
  __cil_tmp4 = __builtin_object_size(__list, 1);
#line 221
  __cil_tmp5 = __builtin_constant_p((unsigned long )__size <= __cil_tmp4 / sizeof(__gid_t ));
  }
  {
#line 221
  __cil_tmp3 = __builtin_constant_p(__size);
  }
#line 221
  if (((__cil_tmp3 && __size > 0) && __cil_tmp5) && (unsigned long )__size <= __cil_tmp6 / sizeof(__gid_t )) {
    {
#line 221
    __cil_tmp7 = __getgroups_alias(__size, __list);
#line 221
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 221
    __cil_tmp11 = __builtin_object_size(__list, 1);
    }
    {
#line 221
    __cil_tmp9 = __builtin_object_size(__list, 1);
#line 221
    __cil_tmp10 = __builtin_constant_p((unsigned long )__size <= __cil_tmp9 / sizeof(__gid_t ));
    }
    {
#line 221
    __cil_tmp8 = __builtin_constant_p(__size);
    }
#line 221
    if (((__cil_tmp8 && __size > 0) && __cil_tmp10) && ! ((unsigned long )__size <= __cil_tmp11 / sizeof(__gid_t ))) {
      {
#line 221
      __cil_tmp12 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp13 = __getgroups_chk_warn(__size, __list, __cil_tmp12);
#line 221
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 221
      __cil_tmp14 = __builtin_object_size(__list, 1);
#line 221
      __cil_tmp15 = __getgroups_chk(__size, __list, __cil_tmp14);
#line 221
      tmp = __cil_tmp15;
      }
    }
#line 221
    tmp___0 = tmp;
  }
#line 221
  return (tmp___0);
}
}
#line 227
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 230
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 233
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 242
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 242
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 242
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 242
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 242
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 242
    __cil_tmp8 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 242
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 242
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 242
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 242
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 242
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 242
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 242
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp14 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 242
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 242
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 242
      __cil_tmp16 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 242
      tmp = __cil_tmp16;
      }
    }
#line 242
    tmp___0 = tmp;
  }
#line 242
  return (tmp___0);
}
}
#line 249
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 251
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 253
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 260
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 260 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 262
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 262
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 262
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 262
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 262
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 262
    __cil_tmp7 = __getlogin_r_alias(__buf, __buflen);
#line 262
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 262
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 262
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 262
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 262
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 262
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 262
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp13 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp12);
#line 262
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 262
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 262
      __cil_tmp15 = __getlogin_r_chk(__buf, __buflen, __cil_tmp14);
#line 262
      tmp = __cil_tmp15;
      }
    }
#line 262
    tmp___0 = tmp;
  }
#line 262
  return (tmp___0);
}
}
#line 270
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 272
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 275
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 282
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 282 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 284
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 284
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 284
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 284
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 284
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 284
    __cil_tmp7 = __gethostname_alias(__buf, __buflen);
#line 284
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 284
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 284
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 284
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 284
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 284
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 284
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp13 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 284
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 284
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 284
      __cil_tmp15 = __gethostname_chk(__buf, __buflen, __cil_tmp14);
#line 284
      tmp = __cil_tmp15;
      }
    }
#line 284
    tmp___0 = tmp;
  }
#line 284
  return (tmp___0);
}
}
#line 292
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 294
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 298
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 306
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 306 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 308
  __cil_tmp6 = __builtin_object_size(__buf, 1);
  }
  {
#line 308
  __cil_tmp4 = __builtin_object_size(__buf, 1);
#line 308
  __cil_tmp5 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp4 / sizeof(char ));
  }
  {
#line 308
  __cil_tmp3 = __builtin_constant_p(__buflen);
  }
#line 308
  if (__cil_tmp5 && (unsigned long )__buflen <= __cil_tmp6 / sizeof(char )) {
    {
#line 308
    __cil_tmp7 = __getdomainname_alias(__buf, __buflen);
#line 308
    tmp___0 = __cil_tmp7;
    }
  } else {
    {
#line 308
    __cil_tmp11 = __builtin_object_size(__buf, 1);
    }
    {
#line 308
    __cil_tmp9 = __builtin_object_size(__buf, 1);
#line 308
    __cil_tmp10 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp9 / sizeof(char ));
    }
    {
#line 308
    __cil_tmp8 = __builtin_constant_p(__buflen);
    }
#line 308
    if (__cil_tmp10 && ! ((unsigned long )__buflen <= __cil_tmp11 / sizeof(char ))) {
      {
#line 308
      __cil_tmp12 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp13 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp12);
#line 308
      tmp = __cil_tmp13;
      }
    } else {
      {
#line 308
      __cil_tmp14 = __builtin_object_size(__buf, 1);
#line 308
      __cil_tmp15 = __getdomainname_chk(__buf, __buflen, __cil_tmp14);
#line 308
      tmp = __cil_tmp15;
      }
    }
#line 308
    tmp___0 = tmp;
  }
#line 308
  return (tmp___0);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h"
extern  __attribute__((__nothrow__)) __pid_t gettid(void) ;
#line 333 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigaltstack(stack_t *__ss , stack_t *__oss ) ;
#line 347
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss ) ;
#line 355
extern  __attribute__((__nothrow__)) int sighold(int __sig ) ;
#line 359
extern  __attribute__((__nothrow__)) int sigrelse(int __sig ) ;
#line 363
extern  __attribute__((__nothrow__)) int sigignore(int __sig ) ;
#line 367
extern  __attribute__((__nothrow__)) __sighandler_t sigset(int __sig , __sighandler_t __disp ) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t *__newmask ,
                                                         __sigset_t *__oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 40
extern  __attribute__((__nothrow__)) int pthread_sigqueue(pthread_t __threadid , int __signo ,
                                                          union sigval __value ) ;
#line 383 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 385
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h"
extern int tgkill(__pid_t __tgid , __pid_t __tid , int __signal ) ;
#line 88 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(int *__stat_loc ) ;
#line 111
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 132
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
#line 148
extern  __attribute__((__nothrow__)) __pid_t wait3(int *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 164
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , int *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 
  short __cil_tmp2 ;

  {
  {
#line 37
  __cil_tmp2 = __builtin_bswap16(__bsx);
  }
#line 37
  return (__cil_tmp2);
}
}
#line 49 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 52
  __cil_tmp2 = __builtin_bswap32(__bsx);
  }
#line 52
  return (__cil_tmp2);
}
}
#line 70 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 73
  __cil_tmp2 = __builtin_bswap64(__bsx);
  }
#line 73
  return (__cil_tmp2);
}
}
#line 33 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint16_t __uint16_identity(__uint16_t __x ) 
{ 


  {
#line 35
  return (__x);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint32_t __uint32_identity(__uint32_t __x ) 
{ 


  {
#line 41
  return (__x);
}
}
#line 45 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__inline static __uint64_t __uint64_identity(__uint64_t __x ) 
{ 


  {
#line 47
  return (__x);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                  struct timeval *__timeout ) ;
#line 127
extern int pselect(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds ,
                   struct timespec *__timeout , __sigset_t *__sigmask ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 25
extern long __fdelt_warn(long __d ) ;
#line 98 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 102
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 105
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 108
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 113
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 118
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 124
extern  __attribute__((__nothrow__)) float strtof(char const   *__nptr , char **__endptr ) ;
#line 127
extern  __attribute__((__nothrow__)) long double strtold(char const   *__nptr , char **__endptr ) ;
#line 141
extern  __attribute__((__nothrow__)) int strtof32(char const   *__nptr , char **__endptr ) ;
#line 147
extern  __attribute__((__nothrow__)) int strtof64(char const   *__nptr , char **__endptr ) ;
#line 153
extern  __attribute__((__nothrow__)) int strtof128(char const   *__nptr , char **__endptr ) ;
#line 159
extern  __attribute__((__nothrow__)) int strtof32x(char const   *__nptr , char **__endptr ) ;
#line 165
extern  __attribute__((__nothrow__)) int strtof64x(char const   *__nptr , char **__endptr ) ;
#line 177
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 181
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 188
extern  __attribute__((__nothrow__)) long long strtoq(char const   *__nptr , char **__endptr ,
                                                      int __base ) ;
#line 193
extern  __attribute__((__nothrow__)) unsigned long long strtouq(char const   *__nptr ,
                                                                char **__endptr ,
                                                                int __base ) ;
#line 201
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 206
extern  __attribute__((__nothrow__)) unsigned long long strtoull(char const   *__nptr ,
                                                                 char **__endptr ,
                                                                 int __base ) ;
#line 213
extern  __attribute__((__nothrow__)) int strfromd(char *__dest , size_t __size , char const   *__format ,
                                                  double __f ) ;
#line 217
extern  __attribute__((__nothrow__)) int strfromf(char *__dest , size_t __size , char const   *__format ,
                                                  float __f ) ;
#line 221
extern  __attribute__((__nothrow__)) int strfroml(char *__dest , size_t __size , char const   *__format ,
                                                  long double __f ) ;
#line 233
extern  __attribute__((__nothrow__)) int strfromf32(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 239
extern  __attribute__((__nothrow__)) int strfromf64(char *__dest , size_t __size ,
                                                    char const   *__format , int __f ) ;
#line 245
extern  __attribute__((__nothrow__)) int strfromf128(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 251
extern  __attribute__((__nothrow__)) int strfromf32x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 257
extern  __attribute__((__nothrow__)) int strfromf64x(char *__dest , size_t __size ,
                                                     char const   *__format , int __f ) ;
#line 275
extern  __attribute__((__nothrow__)) long strtol_l(char const   *__nptr , char **__endptr ,
                                                   int __base , locale_t __loc ) ;
#line 279
extern  __attribute__((__nothrow__)) unsigned long strtoul_l(char const   *__nptr ,
                                                             char **__endptr , int __base ,
                                                             locale_t __loc ) ;
#line 285
extern  __attribute__((__nothrow__)) long long strtoll_l(char const   *__nptr , char **__endptr ,
                                                         int __base , locale_t __loc ) ;
#line 291
extern  __attribute__((__nothrow__)) unsigned long long strtoull_l(char const   *__nptr ,
                                                                   char **__endptr ,
                                                                   int __base , locale_t __loc ) ;
#line 296
extern  __attribute__((__nothrow__)) double strtod_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 300
extern  __attribute__((__nothrow__)) float strtof_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 304
extern  __attribute__((__nothrow__)) long double strtold_l(char const   *__nptr ,
                                                           char **__endptr , locale_t __loc ) ;
#line 317
extern  __attribute__((__nothrow__)) int strtof32_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 324
extern  __attribute__((__nothrow__)) int strtof64_l(char const   *__nptr , char **__endptr ,
                                                    locale_t __loc ) ;
#line 331
extern  __attribute__((__nothrow__)) int strtof128_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 338
extern  __attribute__((__nothrow__)) int strtof32x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 345
extern  __attribute__((__nothrow__)) int strtof64x_l(char const   *__nptr , char **__endptr ,
                                                     locale_t __loc ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 364
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 364
  return ((int )__cil_tmp2);
}
}
#line 367
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 367 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 369
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 369
  return (__cil_tmp2);
}
}
#line 374
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 374 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 376
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 376
  return (__cil_tmp2);
}
}
#line 386
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 389
extern  __attribute__((__nothrow__)) long a64l(char const   *__s ) ;
#line 402
extern  __attribute__((__nothrow__)) long random(void) ;
#line 405
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 411
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen ) ;
#line 416
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf ) ;
#line 435
extern  __attribute__((__nothrow__)) int random_r(struct random_data *__buf , int32_t *__result ) ;
#line 438
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf ) ;
#line 441
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen , struct random_data *__buf ) ;
#line 446
extern  __attribute__((__nothrow__)) int setstate_r(char *__statebuf , struct random_data *__buf ) ;
#line 454
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 456
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 460
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 468
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 469
extern  __attribute__((__nothrow__)) double erand48(unsigned short __xsubi[3] ) ;
#line 472
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 473
extern  __attribute__((__nothrow__)) long nrand48(unsigned short __xsubi[3] ) ;
#line 477
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 478
extern  __attribute__((__nothrow__)) long jrand48(unsigned short __xsubi[3] ) ;
#line 482
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 483
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short __seed16v[3] ) ;
#line 485
extern  __attribute__((__nothrow__)) void lcong48(unsigned short __param[7] ) ;
#line 502
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 504
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   double *__result ) ;
#line 509
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 512
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 518
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 521
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short __xsubi[3] , struct drand48_data *__buffer ,
                                                   long *__result ) ;
#line 527
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer ) ;
#line 530
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short __seed16v[3] , struct drand48_data *__buffer ) ;
#line 533
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short __param[7] , struct drand48_data *__buffer ) ;
#line 540
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 551
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 555
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 563
extern  __attribute__((__nothrow__)) void *reallocarray(void *__ptr , size_t __nmemb ,
                                                        size_t __size ) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 580 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size ) ;
#line 586
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size ) ;
#line 592
extern  __attribute__((__nothrow__)) void *aligned_alloc(size_t __alignment , size_t __size ) ;
#line 598
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 602
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) ) ;
#line 610
extern  __attribute__((__nothrow__)) int at_quick_exit(void (*__func)(void) ) ;
#line 617
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int  , void * ) ,
                                                 void *__arg ) ;
#line 624
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 630
extern  __attribute__((__nothrow__)) void quick_exit(int __status ) ;
#line 636
extern  __attribute__((__nothrow__)) void _Exit(int __status ) ;
#line 641
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 646
extern  __attribute__((__nothrow__)) char *secure_getenv(char const   *__name ) ;
#line 654
extern  __attribute__((__nothrow__)) int putenv(char *__string ) ;
#line 660
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace ) ;
#line 664
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 671
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 682
extern  __attribute__((__nothrow__)) char *mktemp(char *__template ) ;
#line 695
extern int mkstemp(char *__template ) ;
#line 705
extern int mkstemp64(char *__template ) ;
#line 717
extern int mkstemps(char *__template , int __suffixlen ) ;
#line 727
extern int mkstemps64(char *__template , int __suffixlen ) ;
#line 738
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template ) ;
#line 749
extern int mkostemp(char *__template , int __flags ) ;
#line 759
extern int mkostemp64(char *__template , int __flags ) ;
#line 769
extern int mkostemps(char *__template , int __suffixlen , int __flags ) ;
#line 781
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) ;
#line 791
extern int system(char const   *__command ) ;
#line 797
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name ) ;
#line 808
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 828
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;
  int __cil_tmp11 ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((char const   *)__base + __idx * __size);
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 44
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return ((void *)0);
}
}
#line 838 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 841
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar ,
                    void *__arg ) ;
#line 848
extern  __attribute__((__nothrow__)) int abs(int __x ) ;
#line 849
extern  __attribute__((__nothrow__)) long labs(long __x ) ;
#line 852
extern  __attribute__((__nothrow__)) long long llabs(long long __x ) ;
#line 860
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom ) ;
#line 862
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom ) ;
#line 866
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom ) ;
#line 880
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 886
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int *__decpt ,
                                                int *__sign ) ;
#line 892
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf ) ;
#line 898
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 901
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign ) ;
#line 904
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf ) ;
#line 910
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 913
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int *__decpt ,
                                                int *__sign , char *__buf , size_t __len ) ;
#line 917
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 921
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int *__decpt , int *__sign , char *__buf ,
                                                 size_t __len ) ;
#line 930
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t *__pwc , char const   *__s ,
                                                size_t __n ) ;
#line 937
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 941
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 945
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 956
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response ) ;
#line 967
extern  __attribute__((__nothrow__)) int getsubopt(char **__optionp , char * const  *__tokens ,
                                                   char **__valuep ) ;
#line 978
extern int posix_openpt(int __oflag ) ;
#line 986
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 990
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 995
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 1002
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 1006
extern int getpt(void) ;
#line 1013
extern  __attribute__((__nothrow__)) int getloadavg(double __loadavg[] , int __nelem ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 29
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp4 = __builtin_object_size(__resolved, 1);
#line 39
  sz = __cil_tmp4;
  }
#line 41
  if (sz == 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp5 = __realpath_alias(__name, __resolved);
    }
#line 42
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_chk(__name, __resolved, sz);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 55
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 58
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 65
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  __cil_tmp7 = __builtin_object_size(__buf, 1);
  }
  {
#line 67
  __cil_tmp5 = __builtin_object_size(__buf, 1);
#line 67
  __cil_tmp6 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 67
  __cil_tmp4 = __builtin_constant_p(__buflen);
  }
#line 67
  if (__cil_tmp6 && (unsigned long )__buflen <= __cil_tmp7 / sizeof(char )) {
    {
#line 67
    __cil_tmp8 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 67
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 67
    __cil_tmp12 = __builtin_object_size(__buf, 1);
    }
    {
#line 67
    __cil_tmp10 = __builtin_object_size(__buf, 1);
#line 67
    __cil_tmp11 = __builtin_constant_p((unsigned long )__buflen <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 67
    __cil_tmp9 = __builtin_constant_p(__buflen);
    }
#line 67
    if (__cil_tmp11 && ! ((unsigned long )__buflen <= __cil_tmp12 / sizeof(char ))) {
      {
#line 67
      __cil_tmp13 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp14 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp13);
#line 67
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 67
      __cil_tmp15 = __builtin_object_size(__buf, 1);
#line 67
      __cil_tmp16 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp15);
#line 67
      tmp = __cil_tmp16;
      }
    }
#line 67
    tmp___0 = tmp;
  }
#line 67
  return (tmp___0);
}
}
#line 73
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 75
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 79
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
  {
#line 88
  __cil_tmp3 = __builtin_object_size(__s, 1);
  }
#line 88
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 88
    if (16UL > __cil_tmp4) {
      {
#line 90
      __cil_tmp5 = __builtin_object_size(__s, 1);
#line 90
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 90
      return (__cil_tmp6);
    }
  }
  {
#line 91
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 91
  return (__cil_tmp7);
}
}
#line 95
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 99
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 104
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 115
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 115
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 115
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 115
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 115
    __cil_tmp8 = __mbstowcs_alias(__dst, __src, __len);
#line 115
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 115
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 115
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 115
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 115
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 115
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 115
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp14 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp13 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 115
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 115
      __cil_tmp16 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp15 / sizeof(wchar_t ));
#line 115
      tmp = __cil_tmp16;
      }
    }
#line 115
    tmp___0 = tmp;
  }
#line 115
  return (tmp___0);
}
}
#line 121
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 125
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 137
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  size_t __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 140
  __cil_tmp7 = __builtin_object_size(__dst, 1);
  }
  {
#line 140
  __cil_tmp5 = __builtin_object_size(__dst, 1);
#line 140
  __cil_tmp6 = __builtin_constant_p((unsigned long )__len <= __cil_tmp5 / sizeof(char ));
  }
  {
#line 140
  __cil_tmp4 = __builtin_constant_p(__len);
  }
#line 140
  if (__cil_tmp6 && (unsigned long )__len <= __cil_tmp7 / sizeof(char )) {
    {
#line 140
    __cil_tmp8 = __wcstombs_alias(__dst, __src, __len);
#line 140
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 140
    __cil_tmp12 = __builtin_object_size(__dst, 1);
    }
    {
#line 140
    __cil_tmp10 = __builtin_object_size(__dst, 1);
#line 140
    __cil_tmp11 = __builtin_constant_p((unsigned long )__len <= __cil_tmp10 / sizeof(char ));
    }
    {
#line 140
    __cil_tmp9 = __builtin_constant_p(__len);
    }
#line 140
    if (__cil_tmp11 && ! ((unsigned long )__len <= __cil_tmp12 / sizeof(char ))) {
      {
#line 140
      __cil_tmp13 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp14 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp13);
#line 140
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 140
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 140
      __cil_tmp16 = __wcstombs_chk(__dst, __src, __len, __cil_tmp15);
#line 140
      tmp = __cil_tmp16;
      }
    }
#line 140
    tmp___0 = tmp;
  }
#line 140
  return (tmp___0);
}
}
#line 43 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 54
extern  __attribute__((__nothrow__)) void *memccpy(void *__dest , void const   *__src ,
                                                   int __c , size_t __n ) ;
#line 61
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 64
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 80
extern  __attribute__((__nothrow__)) int __memcmpeq(void const   *__s1 , void const   *__s2 ,
                                                    size_t __n ) ;
#line 107
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 120
extern  __attribute__((__nothrow__)) void *rawmemchr(void const   *__s , int __c ) ;
#line 133
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n ) ;
#line 141
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 144
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 149
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 152
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 156
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 159
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 163
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 ) ;
#line 166
extern  __attribute__((__nothrow__)) unsigned long strxfrm(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 175
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   locale_t __l ) ;
#line 179
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , locale_t __l ) ;
#line 187
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 195
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 246
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 273
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 286
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c ) ;
#line 293
extern  __attribute__((__nothrow__)) unsigned long strcspn(char const   *__s , char const   *__reject ) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long strspn(char const   *__s , char const   *__accept ) ;
#line 323
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept ) ;
#line 350
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle ) ;
#line 356
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 361
extern  __attribute__((__nothrow__)) char *__strtok_r(char *__s , char const   *__delim ,
                                                      char **__save_ptr ) ;
#line 366
extern  __attribute__((__nothrow__)) char *strtok_r(char *__s , char const   *__delim ,
                                                    char **__save_ptr ) ;
#line 380
extern  __attribute__((__nothrow__)) char *strcasestr(char const   *__haystack , char const   *__needle ) ;
#line 389
extern  __attribute__((__nothrow__)) void *memmem(void const   *__haystack , size_t __haystacklen ,
                                                  void const   *__needle , size_t __needlelen ) ;
#line 397
extern  __attribute__((__nothrow__)) void *__mempcpy(void *__dest , void const   *__src ,
                                                     size_t __n ) ;
#line 400
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 407
extern  __attribute__((__nothrow__)) unsigned long strlen(char const   *__s ) ;
#line 413
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen ) ;
#line 419
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 444
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen ) ;
#line 450
extern  __attribute__((__nothrow__)) char const   *strerrordesc_np(int __err ) ;
#line 452
extern  __attribute__((__nothrow__)) char const   *strerrorname_np(int __err ) ;
#line 458
extern  __attribute__((__nothrow__)) char *strerror_l(int __errnum , locale_t __l ) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n ) ;
#line 38
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 68
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c ) ;
#line 96
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c ) ;
#line 104
extern  __attribute__((__nothrow__)) int ffs(int __i ) ;
#line 110
extern  __attribute__((__nothrow__)) int ffsl(long __l ) ;
#line 111
extern  __attribute__((__nothrow__)) int ffsll(long long __ll ) ;
#line 116
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 120
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n ) ;
#line 128
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      locale_t __loc ) ;
#line 133
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 25
  __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
  return;
}
}
#line 30
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 32
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 32
  __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
  return;
}
}
#line 466 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 471
extern  __attribute__((__nothrow__)) char *strsep(char **__stringp , char const   *__delim ) ;
#line 478
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 482
extern  __attribute__((__nothrow__)) char const   *sigabbrev_np(int __sig ) ;
#line 485
extern  __attribute__((__nothrow__)) char const   *sigdescr_np(int __sig ) ;
#line 489
extern  __attribute__((__nothrow__)) char *__stpcpy(char *__dest , char const   *__src ) ;
#line 491
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 496
extern  __attribute__((__nothrow__)) char *__stpncpy(char *__dest , char const   *__src ,
                                                     size_t __n ) ;
#line 499
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 506
extern  __attribute__((__nothrow__)) int strverscmp(char const   *__s1 , char const   *__s2 ) ;
#line 510
extern  __attribute__((__nothrow__)) char *strfry(char *__string ) ;
#line 513
extern  __attribute__((__nothrow__)) void *memfrob(void *__s , size_t __n ) ;
#line 527
extern  __attribute__((__nothrow__)) char *basename(char const   *__filename ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 29
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 29
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 29
  return (__cil_tmp5);
}
}
#line 34
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 36
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 36
  return (__cil_tmp5);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 45
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 45
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 45
  return (__cil_tmp5);
}
}
#line 57
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 59
  __cil_tmp4 = __builtin_object_size(__dest, 0);
#line 59
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 59
  return (__cil_tmp5);
}
}
#line 66
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 70
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 72
  __cil_tmp3 = __builtin_object_size(__dest, 0);
#line 72
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
  return;
}
}
#line 77
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 77 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 79
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 79
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 79
  return (__cil_tmp4);
}
}
#line 84
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 86
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 86
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 86
  return (__cil_tmp4);
}
}
#line 92
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 95
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 95
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 95
  return (__cil_tmp5);
}
}
#line 102
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 104
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 104
  __cil_tmp5 = __builtin___stpncpy_chk(__dest, __src, __n, __cil_tmp4);
  }
#line 104
  return (__cil_tmp5);
}
}
#line 128
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 128 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 130
  __cil_tmp3 = __builtin_object_size(__dest, 1);
#line 130
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 130
  return (__cil_tmp4);
}
}
#line 135
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 135 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 138
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 138
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 138
  return (__cil_tmp5);
}
}
#line 290 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t imaxabs(intmax_t __n ) ;
#line 293
extern  __attribute__((__nothrow__)) imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) ;
#line 297
extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *__nptr , char **__endptr ,
                                                        int __base ) ;
#line 301
extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *__nptr , char **__endptr ,
                                                         int __base ) ;
#line 305
extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                        int __base ) ;
#line 310
extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                         int __base ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 108
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 130
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 135
extern  __attribute__((__nothrow__)) int isctype(int __c , int __mask ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 251
extern  __attribute__((__nothrow__)) int isalnum_l(int  , locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isalpha_l(int  , locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int isdigit_l(int  , locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int islower_l(int  , locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isgraph_l(int  , locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isprint_l(int  , locale_t  ) ;
#line 258
extern  __attribute__((__nothrow__)) int ispunct_l(int  , locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isspace_l(int  , locale_t  ) ;
#line 260
extern  __attribute__((__nothrow__)) int isupper_l(int  , locale_t  ) ;
#line 261
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int isblank_l(int  , locale_t  ) ;
#line 267
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int tolower_l(int __c , locale_t __l ) ;
#line 271
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , locale_t __l ) ;
#line 272
extern  __attribute__((__nothrow__)) int toupper_l(int __c , locale_t __l ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char **__inbuf , size_t *__inbytesleft , char **__outbuf ,
                    size_t *__outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 370 "/usr/include/SDL/SDL_stdinc.h"
extern void *SDL_revcpy(void *dst , void const   *src , size_t len ) ;
#line 403
extern size_t SDL_strlcpy(char *dst , char const   *src , size_t maxlen ) ;
#line 409
extern size_t SDL_strlcat(char *dst , char const   *src , size_t maxlen ) ;
#line 421
extern char *SDL_strrev(char *string ) ;
#line 427
extern char *SDL_strupr(char *string ) ;
#line 433
extern char *SDL_strlwr(char *string ) ;
#line 467
extern char *SDL_ltoa(long value , char *string , int radix ) ;
#line 479
extern char *SDL_ultoa(unsigned long value , char *string , int radix ) ;
#line 499
extern char *SDL_lltoa(Sint64 value , char *string , int radix ) ;
#line 505
extern char *SDL_ulltoa(Uint64 value , char *string , int radix ) ;
#line 605
extern size_t SDL_iconv(iconv_t cd , char const   **inbuf , size_t *inbytesleft ,
                        char **outbuf , size_t *outbytesleft ) ;
#line 609
extern char *SDL_iconv_string(char const   *tocode , char const   *fromcode , char const   *inbuf ,
                              size_t inbytesleft ) ;
#line 43 "/usr/include/SDL/SDL_error.h"
extern void SDL_SetError(char const   *fmt  , ...) ;
#line 44
extern char *SDL_GetError(void) ;
#line 45
extern void SDL_ClearError(void) ;
#line 63
extern void SDL_Error(SDL_errorcode code ) ;
#line 81 "/usr/include/SDL/SDL_endian.h"
__inline static Uint16 SDL_Swap16(Uint16 x ) 
{ 


  {
  __asm__  ("asm":);
#line 84
  return (x);
}
}
#line 114 "/usr/include/SDL/SDL_endian.h"
__inline static Uint32 SDL_Swap32(Uint32 x ) 
{ 


  {
  __asm__  ("asm":);
#line 117
  return (x);
}
}
#line 157 "/usr/include/SDL/SDL_endian.h"
__inline static Uint64 SDL_Swap64(Uint64 x ) 
{ 


  {
  __asm__  ("asm":);
#line 160
  return (x);
}
}
#line 59 "/usr/include/SDL/SDL_mutex.h"
extern SDL_mutex *SDL_CreateMutex(void) ;
#line 65
extern int SDL_mutexP(SDL_mutex *mutex ) ;
#line 74
extern int SDL_mutexV(SDL_mutex *mutex ) ;
#line 77
extern void SDL_DestroyMutex(SDL_mutex *mutex ) ;
#line 90
extern SDL_sem *SDL_CreateSemaphore(Uint32 initial_value ) ;
#line 93
extern void SDL_DestroySemaphore(SDL_sem *sem ) ;
#line 100
extern int SDL_SemWait(SDL_sem *sem ) ;
#line 106
extern int SDL_SemTryWait(SDL_sem *sem ) ;
#line 115
extern int SDL_SemWaitTimeout(SDL_sem *sem , Uint32 ms ) ;
#line 120
extern int SDL_SemPost(SDL_sem *sem ) ;
#line 123
extern Uint32 SDL_SemValue(SDL_sem *sem ) ;
#line 138
extern SDL_cond *SDL_CreateCond(void) ;
#line 141
extern void SDL_DestroyCond(SDL_cond *cond ) ;
#line 146
extern int SDL_CondSignal(SDL_cond *cond ) ;
#line 151
extern int SDL_CondBroadcast(SDL_cond *cond ) ;
#line 158
extern int SDL_CondWait(SDL_cond *cond , SDL_mutex *mut ) ;
#line 166
extern int SDL_CondWaitTimeout(SDL_cond *cond , SDL_mutex *mutex , Uint32 ms ) ;
#line 88 "/usr/include/SDL/SDL_thread.h"
extern SDL_Thread *SDL_CreateThread(int (*fn)(void * ) , void *data ) ;
#line 92
extern Uint32 SDL_ThreadID(void) ;
#line 97
extern Uint32 SDL_GetThreadID(SDL_Thread *thread ) ;
#line 103
extern void SDL_WaitThread(SDL_Thread *thread , int *status ) ;
#line 106
extern void SDL_KillThread(SDL_Thread *thread ) ;
#line 99 "/usr/include/SDL/SDL_rwops.h"
extern SDL_RWops *SDL_RWFromFile(char const   *file , char const   *mode ) ;
#line 102
extern SDL_RWops *SDL_RWFromFP(FILE *fp , int autoclose ) ;
#line 105
extern SDL_RWops *SDL_RWFromMem(void *mem , int size ) ;
#line 106
extern SDL_RWops *SDL_RWFromConstMem(void const   *mem , int size ) ;
#line 108
extern SDL_RWops *SDL_AllocRW(void) ;
#line 109
extern void SDL_FreeRW(SDL_RWops *area ) ;
#line 131
extern Uint16 SDL_ReadLE16(SDL_RWops *src ) ;
#line 132
extern Uint16 SDL_ReadBE16(SDL_RWops *src ) ;
#line 133
extern Uint32 SDL_ReadLE32(SDL_RWops *src ) ;
#line 134
extern Uint32 SDL_ReadBE32(SDL_RWops *src ) ;
#line 135
extern Uint64 SDL_ReadLE64(SDL_RWops *src ) ;
#line 136
extern Uint64 SDL_ReadBE64(SDL_RWops *src ) ;
#line 141
extern int SDL_WriteLE16(SDL_RWops *dst , Uint16 value ) ;
#line 142
extern int SDL_WriteBE16(SDL_RWops *dst , Uint16 value ) ;
#line 143
extern int SDL_WriteLE32(SDL_RWops *dst , Uint32 value ) ;
#line 144
extern int SDL_WriteBE32(SDL_RWops *dst , Uint32 value ) ;
#line 145
extern int SDL_WriteLE64(SDL_RWops *dst , Uint64 value ) ;
#line 146
extern int SDL_WriteBE64(SDL_RWops *dst , Uint64 value ) ;
#line 150 "/usr/include/SDL/SDL_audio.h"
extern int SDL_AudioInit(char const   *driver_name ) ;
#line 151
extern void SDL_AudioQuit(void) ;
#line 159
extern char *SDL_AudioDriverName(char *namebuf , int maxlen ) ;
#line 178
extern int SDL_OpenAudio(SDL_AudioSpec *desired , SDL_AudioSpec *obtained ) ;
#line 187
extern SDL_audiostatus SDL_GetAudioStatus(void) ;
#line 196
extern void SDL_PauseAudio(int pause_on ) ;
#line 215
extern SDL_AudioSpec *SDL_LoadWAV_RW(SDL_RWops *src , int freesrc , SDL_AudioSpec *spec ,
                                     Uint8 **audio_buf , Uint32 *audio_len ) ;
#line 224
extern void SDL_FreeWAV(Uint8 *audio_buf ) ;
#line 234
extern int SDL_BuildAudioCVT(SDL_AudioCVT *cvt , Uint16 src_format , Uint8 src_channels ,
                             int src_rate , Uint16 dst_format , Uint8 dst_channels ,
                             int dst_rate ) ;
#line 247
extern int SDL_ConvertAudio(SDL_AudioCVT *cvt ) ;
#line 258
extern void SDL_MixAudio(Uint8 *dst , Uint8 *src , Uint32 len , int volume ) ;
#line 268
extern void SDL_LockAudio(void) ;
#line 269
extern void SDL_UnlockAudio(void) ;
#line 275
extern void SDL_CloseAudio(void) ;
#line 114 "/usr/include/SDL/SDL_cdrom.h"
extern int SDL_CDNumDrives(void) ;
#line 123
extern char const   *SDL_CDName(int drive ) ;
#line 132
extern SDL_CD *SDL_CDOpen(int drive ) ;
#line 139
extern CDstatus SDL_CDStatus(SDL_CD *cdrom ) ;
#line 163
extern int SDL_CDPlayTracks(SDL_CD *cdrom , int start_track , int start_frame , int ntracks ,
                            int nframes ) ;
#line 170
extern int SDL_CDPlay(SDL_CD *cdrom , int start , int length ) ;
#line 175
extern int SDL_CDPause(SDL_CD *cdrom ) ;
#line 180
extern int SDL_CDResume(SDL_CD *cdrom ) ;
#line 185
extern int SDL_CDStop(SDL_CD *cdrom ) ;
#line 190
extern int SDL_CDEject(SDL_CD *cdrom ) ;
#line 193
extern void SDL_CDClose(SDL_CD *cdrom ) ;
#line 40 "/usr/include/SDL/SDL_cpuinfo.h"
extern SDL_bool SDL_HasRDTSC(void) ;
#line 43
extern SDL_bool SDL_HasMMX(void) ;
#line 46
extern SDL_bool SDL_HasMMXExt(void) ;
#line 49
extern SDL_bool SDL_Has3DNow(void) ;
#line 52
extern SDL_bool SDL_Has3DNowExt(void) ;
#line 55
extern SDL_bool SDL_HasSSE(void) ;
#line 58
extern SDL_bool SDL_HasSSE2(void) ;
#line 61
extern SDL_bool SDL_HasAltiVec(void) ;
#line 54 "/usr/include/SDL/SDL_active.h"
extern Uint8 SDL_GetAppState(void) ;
#line 82 "/usr/include/SDL/SDL_keyboard.h"
extern int SDL_EnableUNICODE(int enable ) ;
#line 98
extern int SDL_EnableKeyRepeat(int delay , int interval ) ;
#line 99
extern void SDL_GetKeyRepeat(int *delay , int *interval ) ;
#line 110
extern Uint8 *SDL_GetKeyState(int *numkeys ) ;
#line 115
extern SDLMod SDL_GetModState(void) ;
#line 121
extern void SDL_SetModState(SDLMod modstate ) ;
#line 126
extern char *SDL_GetKeyName(SDLKey key ) ;
#line 275 "/usr/include/SDL/SDL_video.h"
extern int SDL_VideoInit(char const   *driver_name , Uint32 flags ) ;
#line 276
extern void SDL_VideoQuit(void) ;
#line 284
extern char *SDL_VideoDriverName(char *namebuf , int maxlen ) ;
#line 292
extern SDL_Surface *SDL_GetVideoSurface(void) ;
#line 300
extern SDL_VideoInfo *SDL_GetVideoInfo(void) ;
#line 313
extern int SDL_VideoModeOK(int width , int height , int bpp , Uint32 flags ) ;
#line 324
extern SDL_Rect **SDL_ListModes(SDL_PixelFormat *format , Uint32 flags ) ;
#line 384
extern SDL_Surface *SDL_SetVideoMode(int width , int height , int bpp , Uint32 flags ) ;
#line 394
extern void SDL_UpdateRects(SDL_Surface *screen , int numrects , SDL_Rect *rects ) ;
#line 400
extern void SDL_UpdateRect(SDL_Surface *screen , Sint32 x , Sint32 y , Uint32 w ,
                           Uint32 h ) ;
#line 414
extern int SDL_Flip(SDL_Surface *screen ) ;
#line 424
extern int SDL_SetGamma(float red , float green , float blue ) ;
#line 438
extern int SDL_SetGammaRamp(Uint16 *red , Uint16 *green , Uint16 *blue ) ;
#line 449
extern int SDL_GetGammaRamp(Uint16 *red , Uint16 *green , Uint16 *blue ) ;
#line 466
extern int SDL_SetColors(SDL_Surface *surface , SDL_Color *colors , int firstcolor ,
                         int ncolors ) ;
#line 485
extern int SDL_SetPalette(SDL_Surface *surface , int flags , SDL_Color *colors , int firstcolor ,
                          int ncolors ) ;
#line 492
extern Uint32 SDL_MapRGB(SDL_PixelFormat * const  format , Uint8 r , Uint8 g , Uint8 b ) ;
#line 499
extern Uint32 SDL_MapRGBA(SDL_PixelFormat * const  format , Uint8 r , Uint8 g , Uint8 b ,
                          Uint8 a ) ;
#line 506
extern void SDL_GetRGB(Uint32 pixel , SDL_PixelFormat * const  fmt , Uint8 *r , Uint8 *g ,
                       Uint8 *b ) ;
#line 513
extern void SDL_GetRGBA(Uint32 pixel , SDL_PixelFormat * const  fmt , Uint8 *r , Uint8 *g ,
                        Uint8 *b , Uint8 *a ) ;
#line 553
extern SDL_Surface *SDL_CreateRGBSurface(Uint32 flags , int width , int height , int depth ,
                                         Uint32 Rmask , Uint32 Gmask , Uint32 Bmask ,
                                         Uint32 Amask ) ;
#line 557
extern SDL_Surface *SDL_CreateRGBSurfaceFrom(void *pixels , int width , int height ,
                                             int depth , int pitch , Uint32 Rmask ,
                                             Uint32 Gmask , Uint32 Bmask , Uint32 Amask ) ;
#line 560
extern void SDL_FreeSurface(SDL_Surface *surface ) ;
#line 580
extern int SDL_LockSurface(SDL_Surface *surface ) ;
#line 581
extern void SDL_UnlockSurface(SDL_Surface *surface ) ;
#line 589
extern SDL_Surface *SDL_LoadBMP_RW(SDL_RWops *src , int freesrc ) ;
#line 599
extern int SDL_SaveBMP_RW(SDL_Surface *surface , SDL_RWops *dst , int freedst ) ;
#line 615
extern int SDL_SetColorKey(SDL_Surface *surface , Uint32 flag , Uint32 key ) ;
#line 633
extern int SDL_SetAlpha(SDL_Surface *surface , Uint32 flag , Uint8 alpha ) ;
#line 647
extern SDL_bool SDL_SetClipRect(SDL_Surface *surface , SDL_Rect *rect ) ;
#line 654
extern void SDL_GetClipRect(SDL_Surface *surface , SDL_Rect *rect ) ;
#line 668
extern SDL_Surface *SDL_ConvertSurface(SDL_Surface *src , SDL_PixelFormat *fmt , Uint32 flags ) ;
#line 748
extern int SDL_UpperBlit(SDL_Surface *src , SDL_Rect *srcrect , SDL_Surface *dst ,
                         SDL_Rect *dstrect ) ;
#line 754
extern int SDL_LowerBlit(SDL_Surface *src , SDL_Rect *srcrect , SDL_Surface *dst ,
                         SDL_Rect *dstrect ) ;
#line 767
extern int SDL_FillRect(SDL_Surface *dst , SDL_Rect *dstrect , Uint32 color ) ;
#line 781
extern SDL_Surface *SDL_DisplayFormat(SDL_Surface *surface ) ;
#line 795
extern SDL_Surface *SDL_DisplayFormatAlpha(SDL_Surface *surface ) ;
#line 807
extern SDL_Overlay *SDL_CreateYUVOverlay(int width , int height , Uint32 format ,
                                         SDL_Surface *display ) ;
#line 811
extern int SDL_LockYUVOverlay(SDL_Overlay *overlay ) ;
#line 812
extern void SDL_UnlockYUVOverlay(SDL_Overlay *overlay ) ;
#line 820
extern int SDL_DisplayYUVOverlay(SDL_Overlay *overlay , SDL_Rect *dstrect ) ;
#line 823
extern void SDL_FreeYUVOverlay(SDL_Overlay *overlay ) ;
#line 837
extern int SDL_GL_LoadLibrary(char const   *path ) ;
#line 842
extern void *SDL_GL_GetProcAddress(char const   *proc ) ;
#line 847
extern int SDL_GL_SetAttribute(SDL_GLattr attr , int value ) ;
#line 858
extern int SDL_GL_GetAttribute(SDL_GLattr attr , int *value ) ;
#line 863
extern void SDL_GL_SwapBuffers(void) ;
#line 870
extern void SDL_GL_UpdateRects(int numrects , SDL_Rect *rects ) ;
#line 871
extern void SDL_GL_Lock(void) ;
#line 872
extern void SDL_GL_Unlock(void) ;
#line 885
extern void SDL_WM_SetCaption(char const   *title , char const   *icon ) ;
#line 889
extern void SDL_WM_GetCaption(char **title , char **icon ) ;
#line 897
extern void SDL_WM_SetIcon(SDL_Surface *icon , Uint8 *mask ) ;
#line 904
extern int SDL_WM_IconifyWindow(void) ;
#line 921
extern int SDL_WM_ToggleFullScreen(SDL_Surface *surface ) ;
#line 937
extern SDL_GrabMode SDL_WM_GrabInput(SDL_GrabMode mode ) ;
#line 942
extern int SDL_SoftStretch(SDL_Surface *src , SDL_Rect *srcrect , SDL_Surface *dst ,
                           SDL_Rect *dstrect ) ;
#line 57 "/usr/include/SDL/SDL_mouse.h"
extern Uint8 SDL_GetMouseState(int *x , int *y ) ;
#line 65
extern Uint8 SDL_GetRelativeMouseState(int *x , int *y ) ;
#line 70
extern void SDL_WarpMouse(Uint16 x , Uint16 y ) ;
#line 85
extern SDL_Cursor *SDL_CreateCursor(Uint8 *data , Uint8 *mask , int w , int h , int hot_x ,
                                    int hot_y ) ;
#line 93
extern void SDL_SetCursor(SDL_Cursor *cursor ) ;
#line 98
extern SDL_Cursor *SDL_GetCursor(void) ;
#line 103
extern void SDL_FreeCursor(SDL_Cursor *cursor ) ;
#line 112
extern int SDL_ShowCursor(int toggle ) ;
#line 53 "/usr/include/SDL/SDL_joystick.h"
extern int SDL_NumJoysticks(void) ;
#line 61
extern char const   *SDL_JoystickName(int device_index ) ;
#line 73
extern SDL_Joystick *SDL_JoystickOpen(int device_index ) ;
#line 78
extern int SDL_JoystickOpened(int device_index ) ;
#line 83
extern int SDL_JoystickIndex(SDL_Joystick *joystick ) ;
#line 88
extern int SDL_JoystickNumAxes(SDL_Joystick *joystick ) ;
#line 96
extern int SDL_JoystickNumBalls(SDL_Joystick *joystick ) ;
#line 101
extern int SDL_JoystickNumHats(SDL_Joystick *joystick ) ;
#line 106
extern int SDL_JoystickNumButtons(SDL_Joystick *joystick ) ;
#line 114
extern void SDL_JoystickUpdate(void) ;
#line 125
extern int SDL_JoystickEventState(int state ) ;
#line 134
extern Sint16 SDL_JoystickGetAxis(SDL_Joystick *joystick , int axis ) ;
#line 157
extern Uint8 SDL_JoystickGetHat(SDL_Joystick *joystick , int hat ) ;
#line 166
extern int SDL_JoystickGetBall(SDL_Joystick *joystick , int ball , int *dx , int *dy ) ;
#line 173
extern Uint8 SDL_JoystickGetButton(SDL_Joystick *joystick , int button ) ;
#line 178
extern void SDL_JoystickClose(SDL_Joystick *joystick ) ;
#line 251 "/usr/include/SDL/SDL_events.h"
extern void SDL_PumpEvents(void) ;
#line 277
extern int SDL_PeepEvents(SDL_Event *events , int numevents , SDL_eventaction action ,
                          Uint32 mask ) ;
#line 284
extern int SDL_PollEvent(SDL_Event *event ) ;
#line 290
extern int SDL_WaitEvent(SDL_Event *event ) ;
#line 296
extern int SDL_PushEvent(SDL_Event *event ) ;
#line 323
extern void SDL_SetEventFilter(SDL_EventFilter filter ) ;
#line 329
extern SDL_EventFilter SDL_GetEventFilter(void) ;
#line 348
extern Uint8 SDL_EventState(Uint8 type , int state ) ;
#line 60 "/usr/include/SDL/SDL_loadso.h"
extern void *SDL_LoadObject(char const   *sofile ) ;
#line 67
extern void *SDL_LoadFunction(void *handle , char const   *name ) ;
#line 70
extern void SDL_UnloadObject(void *handle ) ;
#line 49 "/usr/include/SDL/SDL_timer.h"
extern Uint32 SDL_GetTicks(void) ;
#line 52
extern void SDL_Delay(Uint32 ms ) ;
#line 86
extern int SDL_SetTimer(Uint32 interval , SDL_TimerCallback callback ) ;
#line 109
extern SDL_TimerID SDL_AddTimer(Uint32 interval , SDL_NewTimerCallback callback ,
                                void *param ) ;
#line 115
extern SDL_bool SDL_RemoveTimer(SDL_TimerID t ) ;
#line 83 "/usr/include/SDL/SDL_version.h"
extern SDL_version *SDL_Linked_Version(void) ;
#line 76 "/usr/include/SDL/SDL.h"
extern int SDL_Init(Uint32 flags ) ;
#line 79
extern int SDL_InitSubSystem(Uint32 flags ) ;
#line 82
extern void SDL_QuitSubSystem(Uint32 flags ) ;
#line 88
extern Uint32 SDL_WasInit(Uint32 flags ) ;
#line 93
extern void SDL_Quit(void) ;
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/postscript_print.h"
int do_ps_save(FILE *fi , char const   *fname , SDL_Surface *surf , char const   *pprsize ,
               int is_pipe ) ;
#line 78 "/usr/include/x86_64-linux-gnu/bits/time.h"
extern  __attribute__((__nothrow__)) int clock_adjtime(__clockid_t __clock_id , struct timex *__utx ) ;
#line 72 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 76
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 79
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 ) ;
#line 83
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 100
extern  __attribute__((__nothrow__)) size_t strftime(char *__s , size_t __maxsize ,
                                                     char const   *__format , struct tm *__tp ) ;
#line 107
extern  __attribute__((__nothrow__)) char *strptime(char const   *__s , char const   *__fmt ,
                                                    struct tm *__tp ) ;
#line 116
extern  __attribute__((__nothrow__)) size_t strftime_l(char *__s , size_t __maxsize ,
                                                       char const   *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 123
extern  __attribute__((__nothrow__)) char *strptime_l(char const   *__s , char const   *__fmt ,
                                                      struct tm *__tp , locale_t __loc ) ;
#line 132
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t *__timer ) ;
#line 136
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t *__timer ) ;
#line 154
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t *__timer , struct tm *__tp ) ;
#line 159
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t *__timer , struct tm *__tp ) ;
#line 179
extern  __attribute__((__nothrow__)) char *asctime(struct tm *__tp ) ;
#line 183
extern  __attribute__((__nothrow__)) char *ctime(time_t *__timer ) ;
#line 197
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm *__tp , char *__buf ) ;
#line 202
extern  __attribute__((__nothrow__)) char *ctime_r(time_t *__timer , char *__buf ) ;
#line 217
extern char *__tzname[2] ;
#line 218
extern int __daylight ;
#line 219
extern long __timezone ;
#line 224
extern char *tzname[2] ;
#line 228
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 232
extern int daylight ;
#line 233
extern long timezone ;
#line 249
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 251
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 262
extern  __attribute__((__nothrow__)) int dysize(int __year ) ;
#line 272
extern int nanosleep(struct timespec *__requested_time , struct timespec *__remaining ) ;
#line 276
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 279
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 282
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 311
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec *__req ,
                           struct timespec *__rem ) ;
#line 326
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 331
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent *__evp ,
                                                      timer_t *__timerid ) ;
#line 336
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 340
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec *__value ,
                                                       struct itimerspec *__ovalue ) ;
#line 345
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 371
extern  __attribute__((__nothrow__)) int timespec_get(struct timespec *__ts , int __base ) ;
#line 387
extern  __attribute__((__nothrow__)) int timespec_getres(struct timespec *__ts , int __base ) ;
#line 413
extern int getdate_err ;
#line 422
extern struct tm *getdate(char const   *__string ) ;
#line 436
extern int getdate_r(char const   *__string , struct tm *__resbufp ) ;
#line 43 "/usr/include/paper.h"
extern int paperinit(void) ;
#line 44
extern int paperdone(void) ;
#line 46
extern char const   *papername(struct paper * ) ;
#line 47
extern double paperpswidth(struct paper * ) ;
#line 48
extern double paperpsheight(struct paper * ) ;
#line 50
extern char const   *defaultpapersizefile(void) ;
#line 51
extern char const   *systempapersizefile(void) ;
#line 52
extern char const   *defaultpapername(void) ;
#line 53
extern char *systempapername(void) ;
#line 54
extern struct paper *paperinfo(char const   * ) ;
#line 55
extern struct paper *paperwithsize(double pswidth , double psheight ) ;
#line 58
extern struct paper *paperfirst(void) ;
#line 59
extern struct paper *paperlast(void) ;
#line 60
extern struct paper *papernext(struct paper * ) ;
#line 62
extern struct paper *paperprev(struct paper * ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbit(double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinf(double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finite(double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnan(double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsig(double __x , double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignaling(double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincos(double __x , double *__sinx , double *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincos(double __x , double *__sinx , double *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) double exp10(double __x ) ;
#line 114
extern  __attribute__((__nothrow__)) double __exp10(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double ceil(double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) double __ceil(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double fabs(double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) double __fabs(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double floor(double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) double __floor(double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinf(double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finite(double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnan(double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 220
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 221
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 222
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 223
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 225
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 231
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 232
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 233
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 244
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) double nextdown(double __x ) ;
#line 269
extern  __attribute__((__nothrow__)) double __nextdown(double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) double nextup(double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) double __nextup(double __x ) ;
#line 275
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogb(double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogb(double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double round(double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) double __round(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double trunc(double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) double __trunc(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 345
extern  __attribute__((__nothrow__)) double roundeven(double __x ) ;
#line 345
extern  __attribute__((__nothrow__)) double __roundeven(double __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfp(double __x , int __round ,
                                                       unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfp(double __x , int __round ,
                                                         unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfp(double __x , int __round ,
                                                         unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfp(double __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpx(double __x , int __round ,
                                                        unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpx(double __x , int __round ,
                                                          unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpx(double __x , int __round ,
                                                          unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpx(double __x , int __round ,
                                                            unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalize(double *__cx , double const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) double fmaxmag(double __x , double __y ) ;
#line 377
extern  __attribute__((__nothrow__)) double __fmaxmag(double __x , double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) double fminmag(double __x , double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) double __fminmag(double __x , double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) double fmaximum(double __x , double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) double __fmaximum(double __x , double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) double fminimum(double __x , double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) double __fminimum(double __x , double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) double fmaximum_num(double __x , double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) double __fmaximum_num(double __x , double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) double fminimum_num(double __x , double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) double __fminimum_num(double __x , double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) double fmaximum_mag(double __x , double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) double __fmaximum_mag(double __x , double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) double fminimum_mag(double __x , double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) double __fminimum_mag(double __x , double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) double fmaximum_mag_num(double __x , double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) double __fmaximum_mag_num(double __x , double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) double fminimum_mag_num(double __x , double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) double __fminimum_mag_num(double __x , double __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorder(double const   *__x , double const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermag(double const   *__x , double const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) double getpayload(double const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) double __getpayload(double const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayload(double *__x , double __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsig(double *__x , double __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf(float __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff(float __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef(float __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf(float __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf(float __x , float __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf(float __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 53
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 62
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 71
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 85
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 87
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 95
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 98
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 107
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) float exp10f(float __x ) ;
#line 114
extern  __attribute__((__nothrow__)) float __exp10f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 119
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 122
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 125
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 130
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 133
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 140
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 140
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 143
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 143
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 147
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 147
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 152
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 152
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float ceilf(float __x ) ;
#line 159
extern  __attribute__((__nothrow__)) float __ceilf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float fabsf(float __x ) ;
#line 162
extern  __attribute__((__nothrow__)) float __fabsf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float floorf(float __x ) ;
#line 165
extern  __attribute__((__nothrow__)) float __floorf(float __x ) ;
#line 168
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 168
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinff(float __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitef(float __value ) ;
#line 187
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 187
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 191
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 191
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 198
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y ) ;
#line 198
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y ) ;
#line 203
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanf(float __value ) ;
#line 220
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 220
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 221
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 222
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 223
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 225
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 231
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 232
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 233
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 244
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 259
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 262
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y ) ;
#line 262
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) float nextdownf(float __x ) ;
#line 269
extern  __attribute__((__nothrow__)) float __nextdownf(float __x ) ;
#line 271
extern  __attribute__((__nothrow__)) float nextupf(float __x ) ;
#line 271
extern  __attribute__((__nothrow__)) float __nextupf(float __x ) ;
#line 275
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 275
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 279
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf(float __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf(float __x ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float roundf(float __x ) ;
#line 301
extern  __attribute__((__nothrow__)) float __roundf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float truncf(float __x ) ;
#line 305
extern  __attribute__((__nothrow__)) float __truncf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 329
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 329
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 333
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 340
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 340
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 345
extern  __attribute__((__nothrow__)) float roundevenf(float __x ) ;
#line 345
extern  __attribute__((__nothrow__)) float __roundevenf(float __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf(float __x , int __round ,
                                                        unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf(float __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf(float __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf(float __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf(float __x , int __round ,
                                                         unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf(float __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf(float __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf(float __x , int __round ,
                                                             unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef(float *__cx , float const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) float fmaxmagf(float __x , float __y ) ;
#line 377
extern  __attribute__((__nothrow__)) float __fmaxmagf(float __x , float __y ) ;
#line 380
extern  __attribute__((__nothrow__)) float fminmagf(float __x , float __y ) ;
#line 380
extern  __attribute__((__nothrow__)) float __fminmagf(float __x , float __y ) ;
#line 385
extern  __attribute__((__nothrow__)) float fmaximumf(float __x , float __y ) ;
#line 385
extern  __attribute__((__nothrow__)) float __fmaximumf(float __x , float __y ) ;
#line 388
extern  __attribute__((__nothrow__)) float fminimumf(float __x , float __y ) ;
#line 388
extern  __attribute__((__nothrow__)) float __fminimumf(float __x , float __y ) ;
#line 391
extern  __attribute__((__nothrow__)) float fmaximum_numf(float __x , float __y ) ;
#line 391
extern  __attribute__((__nothrow__)) float __fmaximum_numf(float __x , float __y ) ;
#line 394
extern  __attribute__((__nothrow__)) float fminimum_numf(float __x , float __y ) ;
#line 394
extern  __attribute__((__nothrow__)) float __fminimum_numf(float __x , float __y ) ;
#line 397
extern  __attribute__((__nothrow__)) float fmaximum_magf(float __x , float __y ) ;
#line 397
extern  __attribute__((__nothrow__)) float __fmaximum_magf(float __x , float __y ) ;
#line 400
extern  __attribute__((__nothrow__)) float fminimum_magf(float __x , float __y ) ;
#line 400
extern  __attribute__((__nothrow__)) float __fminimum_magf(float __x , float __y ) ;
#line 403
extern  __attribute__((__nothrow__)) float fmaximum_mag_numf(float __x , float __y ) ;
#line 403
extern  __attribute__((__nothrow__)) float __fmaximum_mag_numf(float __x , float __y ) ;
#line 406
extern  __attribute__((__nothrow__)) float fminimum_mag_numf(float __x , float __y ) ;
#line 406
extern  __attribute__((__nothrow__)) float __fminimum_mag_numf(float __x , float __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf(float const   *__x , float const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf(float const   *__x , float const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) float getpayloadf(float const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) float __getpayloadf(float const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf(float *__x , float __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf(float *__x , float __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 435
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitl(long double __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinfl(long double __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitel(long double __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanl(long double __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigl(long double __x , long double __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingl(long double __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 53
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 62
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 71
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosl(long double __x , long double *__sinx ,
                                                  long double *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosl(long double __x , long double *__sinx ,
                                                    long double *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 85
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 87
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 95
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 98
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) long double exp10l(long double __x ) ;
#line 114
extern  __attribute__((__nothrow__)) long double __exp10l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 119
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 122
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 125
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 130
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 133
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 140
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 140
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 143
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 143
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 147
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 147
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 152
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 152
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double ceill(long double __x ) ;
#line 159
extern  __attribute__((__nothrow__)) long double __ceill(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double fabsl(long double __x ) ;
#line 162
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double floorl(long double __x ) ;
#line 165
extern  __attribute__((__nothrow__)) long double __floorl(long double __x ) ;
#line 168
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 168
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 177
extern  __attribute__((__nothrow__)) int isinfl(long double __value ) ;
#line 183
extern  __attribute__((__nothrow__)) int finitel(long double __value ) ;
#line 187
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 187
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 191
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 191
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 198
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y ) ;
#line 198
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y ) ;
#line 203
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb ) ;
#line 213
extern  __attribute__((__nothrow__)) int isnanl(long double __value ) ;
#line 220
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 220
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 221
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 222
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 223
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 225
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 231
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 232
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 233
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 244
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 259
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 262
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y ) ;
#line 262
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y ) ;
#line 264
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y ) ;
#line 269
extern  __attribute__((__nothrow__)) long double nextdownl(long double __x ) ;
#line 269
extern  __attribute__((__nothrow__)) long double __nextdownl(long double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) long double nextupl(long double __x ) ;
#line 271
extern  __attribute__((__nothrow__)) long double __nextupl(long double __x ) ;
#line 275
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 275
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 279
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbl(long double __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbl(long double __x ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double roundl(long double __x ) ;
#line 301
extern  __attribute__((__nothrow__)) long double __roundl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double truncl(long double __x ) ;
#line 305
extern  __attribute__((__nothrow__)) long double __truncl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 329
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 329
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 333
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 340
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 340
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 345
extern  __attribute__((__nothrow__)) long double roundevenl(long double __x ) ;
#line 345
extern  __attribute__((__nothrow__)) long double __roundevenl(long double __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpl(long double __x , int __round ,
                                                        unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpl(long double __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpl(long double __x , int __round ,
                                                          unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpl(long double __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxl(long double __x , int __round ,
                                                         unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxl(long double __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxl(long double __x , int __round ,
                                                           unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxl(long double __x , int __round ,
                                                             unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizel(long double *__cx , long double const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) long double fmaxmagl(long double __x , long double __y ) ;
#line 377
extern  __attribute__((__nothrow__)) long double __fmaxmagl(long double __x , long double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) long double fminmagl(long double __x , long double __y ) ;
#line 380
extern  __attribute__((__nothrow__)) long double __fminmagl(long double __x , long double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) long double fmaximuml(long double __x , long double __y ) ;
#line 385
extern  __attribute__((__nothrow__)) long double __fmaximuml(long double __x , long double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) long double fminimuml(long double __x , long double __y ) ;
#line 388
extern  __attribute__((__nothrow__)) long double __fminimuml(long double __x , long double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) long double fmaximum_numl(long double __x , long double __y ) ;
#line 391
extern  __attribute__((__nothrow__)) long double __fmaximum_numl(long double __x ,
                                                                 long double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) long double fminimum_numl(long double __x , long double __y ) ;
#line 394
extern  __attribute__((__nothrow__)) long double __fminimum_numl(long double __x ,
                                                                 long double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) long double fmaximum_magl(long double __x , long double __y ) ;
#line 397
extern  __attribute__((__nothrow__)) long double __fmaximum_magl(long double __x ,
                                                                 long double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) long double fminimum_magl(long double __x , long double __y ) ;
#line 400
extern  __attribute__((__nothrow__)) long double __fminimum_magl(long double __x ,
                                                                 long double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) long double fmaximum_mag_numl(long double __x ,
                                                                   long double __y ) ;
#line 403
extern  __attribute__((__nothrow__)) long double __fmaximum_mag_numl(long double __x ,
                                                                     long double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) long double fminimum_mag_numl(long double __x ,
                                                                   long double __y ) ;
#line 406
extern  __attribute__((__nothrow__)) long double __fminimum_mag_numl(long double __x ,
                                                                     long double __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderl(long double const   *__x , long double const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagl(long double const   *__x ,
                                                        long double const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) long double getpayloadl(long double const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) long double __getpayloadl(long double const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadl(long double *__x , long double __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigl(long double *__x , long double __payload ) ;
#line 435
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 435
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf32(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf32(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf32(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf32(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf32(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf32(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f32(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f32(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf32(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf32(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf32(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf32(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf32(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf32(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf32(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf32(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf32(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf32(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf32(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf32(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf32(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf32(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf32(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf32(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf32(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf32(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf32(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf32(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf32(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf32(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf32(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf32(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf32(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf32(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf32(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf32(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f32(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f32(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff32(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff32(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f32(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f32(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f32(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f32(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf32(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf32(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf32(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf32(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f32(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f32(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f32(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f32(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf32(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf32(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf32(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf32(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf32(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf32(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf32(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf32(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf32(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf32(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf32(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf32(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf32(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf32(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf32(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf32(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf32(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf32(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf32(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf32(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f32() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f32() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f32() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f32() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf32(int  , int _Float32 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf32(int  , int _Float32 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f32() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f32() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f32() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f32() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf32(int  , int _Float32 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf32(int  , int _Float32 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff32() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff32() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf32() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf32() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf32() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf32() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf32() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf32() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf32_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf32_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf32(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf32(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf32(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf32(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf32(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf32(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf32(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf32(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf32(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf32(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf32(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf32(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf32(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf32(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf32(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf32(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf32(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf32(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf32(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf32(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf32(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf32(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf32(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf32(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof32(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof32(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf32(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf32(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf32(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf32(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf32(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf32(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf32(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf32(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf32(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf32(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf32(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf32(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf32(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf32(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf32(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf32(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf32(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf32(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf32(int __x , int __round ,
                                                          unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf32(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf32(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf32(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf32(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf32(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf32(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf32(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef32(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf32(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf32(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf32(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf32(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf32(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf32(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf32(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf32(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf32(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf32(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf32(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf32(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf32(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf32(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf32(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf32(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf32(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf32(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf32(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf32(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf32(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf32(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf32(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf32(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf32(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf32(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf64(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf64(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf64(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf64(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf64(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf64(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f64(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f64(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf64(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf64(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf64(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf64(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf64(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf64(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf64(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf64(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf64(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf64(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf64(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf64(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf64(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf64(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf64(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf64(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf64(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf64(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf64(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf64(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf64(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf64(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf64(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf64(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf64(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf64(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf64(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf64(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f64(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f64(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff64(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff64(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f64(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f64(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f64(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f64(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf64(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf64(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf64(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf64(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f64(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f64(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f64(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f64(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf64(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf64(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf64(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf64(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf64(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf64(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf64(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf64(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf64(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf64(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf64(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf64(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf64(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf64(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf64(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf64(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf64(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf64(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf64(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf64(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f64() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f64() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f64() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f64() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf64(int  , int _Float64 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf64(int  , int _Float64 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f64() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f64() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f64() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f64() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf64(int  , int _Float64 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf64(int  , int _Float64 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff64() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff64() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf64() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf64() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf64() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf64() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf64() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf64() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf64_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf64_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf64(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf64(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf64(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf64(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf64(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf64(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf64(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf64(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf64(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf64(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf64(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf64(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf64(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf64(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf64(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf64(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf64(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf64(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf64(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf64(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf64(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf64(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf64(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf64(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof64(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof64(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf64(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf64(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf64(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf64(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf64(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf64(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf64(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf64(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf64(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf64(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf64(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf64(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf64(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf64(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf64(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf64(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf64(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf64(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf64(int __x , int __round ,
                                                          unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf64(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf64(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf64(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf64(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf64(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf64(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf64(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef64(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf64(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf64(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf64(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf64(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf64(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf64(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf64(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf64(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf64(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf64(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf64(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf64(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf64(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf64(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf64(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf64(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf64(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf64(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf64(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf64(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf64(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf64(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf64(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf64(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf64(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf64(int *__x , int __payload ) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h"
extern  __attribute__((__nothrow__)) int __fpclassifyf128(int __value ) ;
#line 24
extern  __attribute__((__nothrow__)) int __signbitf128(int __value ) ;
#line 29
extern  __attribute__((__nothrow__)) int __isinff128(int __value ) ;
#line 33
extern  __attribute__((__nothrow__)) int __finitef128(int __value ) ;
#line 37
extern  __attribute__((__nothrow__)) int __isnanf128(int __value ) ;
#line 41
extern  __attribute__((__nothrow__)) int __iseqsigf128(int __x , int __y ) ;
#line 44
extern  __attribute__((__nothrow__)) int __issignalingf128(int __value ) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int acosf128(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf128(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf128(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf128(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf128(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf128(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f128(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f128(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf128(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf128(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf128(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf128(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf128(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf128(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf128(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf128(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf128(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf128(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf128(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf128(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf128(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf128(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf128(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf128(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf128(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf128(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf128(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf128(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf128(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf128(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf128(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf128(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf128(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf128(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf128(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf128(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f128(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f128(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff128(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff128(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f128(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f128(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f128(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f128(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf128(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf128(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf128(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf128(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f128(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f128(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f128(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f128(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf128(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf128(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf128(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf128(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf128(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf128(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf128(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf128(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf128(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf128(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf128(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf128(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf128(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf128(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf128(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf128(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf128(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf128(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf128(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf128(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f128() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f128() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f128() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f128() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf128(int  , int _Float128 ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf128(int  , int _Float128 ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f128() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f128() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f128() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f128() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf128(int  , int _Float128 ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf128(int  , int _Float128 ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff128() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff128() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf128() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf128() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf128() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf128() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf128() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf128() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf128_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf128_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf128(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf128(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf128(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf128(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf128(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf128(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf128(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf128(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf128(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf128(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf128(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf128(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf128(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf128(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf128(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf128(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf128(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf128(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf128(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf128(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf128(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf128(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf128(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf128(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof128(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof128(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf128(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf128(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf128(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf128(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf128(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf128(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf128(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf128(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf128(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf128(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf128(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf128(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf128(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf128(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf128(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf128(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf128(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf128(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf128(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf128(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf128(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf128(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf128(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf128(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf128(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf128(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef128(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf128(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf128(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf128(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf128(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf128(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf128(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf128(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf128(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf128(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf128(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf128(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf128(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf128(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf128(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf128(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf128(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf128(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf128(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf128(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf128(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf128(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf128(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf128(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf128(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf128(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf128(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf32x(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf32x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf32x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf32x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf32x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf32x(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f32x(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f32x(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf32x(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf32x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf32x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf32x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf32x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf32x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf32x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf32x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf32x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf32x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf32x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf32x(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf32x(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf32x(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf32x(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf32x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf32x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf32x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf32x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf32x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf32x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf32x(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf32x(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf32x(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf32x(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf32x(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf32x(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf32x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f32x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f32x(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff32x(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff32x(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f32x(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f32x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f32x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f32x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf32x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf32x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf32x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf32x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f32x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f32x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f32x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f32x(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf32x(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf32x(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf32x(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf32x(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf32x(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf32x(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf32x(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf32x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf32x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf32x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf32x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf32x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf32x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf32x(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf32x(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf32x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf32x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf32x(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf32x(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf32x(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f32x() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f32x() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f32x() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f32x() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf32x(int  , int _Float32x ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf32x(int  , int _Float32x ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f32x() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f32x() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf32x(int  , int _Float32x ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf32x(int  , int _Float32x ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff32x() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff32x() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf32x() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf32x() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf32x() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf32x() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf32x() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf32x() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf32x_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf32x_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf32x(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf32x(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf32x(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf32x(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf32x(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf32x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf32x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf32x(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf32x(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf32x(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf32x(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf32x(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf32x(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf32x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf32x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf32x(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf32x(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf32x(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf32x(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf32x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf32x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf32x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf32x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf32x(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof32x(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof32x(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf32x(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf32x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf32x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf32x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf32x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf32x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf32x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf32x(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf32x(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf32x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf32x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf32x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf32x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf32x(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf32x(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf32x(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf32x(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf32x(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf32x(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf32x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf32x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf32x(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf32x(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf32x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf32x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf32x(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef32x(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf32x(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf32x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf32x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf32x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf32x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf32x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf32x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf32x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf32x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf32x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf32x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf32x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf32x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf32x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf32x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf32x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf32x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf32x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf32x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf32x(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf32x(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf32x(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf32x(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf32x(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf32x(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf32x(int *__x , int __payload ) ;
#line 53
extern  __attribute__((__nothrow__)) int acosf64x(int __x ) ;
#line 53
extern  __attribute__((__nothrow__)) int __acosf64x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int asinf64x(int __x ) ;
#line 55
extern  __attribute__((__nothrow__)) int __asinf64x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int atanf64x(int __x ) ;
#line 57
extern  __attribute__((__nothrow__)) int __atanf64x(int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int atan2f64x(int __y , int __x ) ;
#line 59
extern  __attribute__((__nothrow__)) int __atan2f64x(int __y , int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int cosf64x(int __x ) ;
#line 62
extern  __attribute__((__nothrow__)) int __cosf64x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int sinf64x(int __x ) ;
#line 64
extern  __attribute__((__nothrow__)) int __sinf64x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int tanf64x(int __x ) ;
#line 66
extern  __attribute__((__nothrow__)) int __tanf64x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int coshf64x(int __x ) ;
#line 71
extern  __attribute__((__nothrow__)) int __coshf64x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int sinhf64x(int __x ) ;
#line 73
extern  __attribute__((__nothrow__)) int __sinhf64x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int tanhf64x(int __x ) ;
#line 75
extern  __attribute__((__nothrow__)) int __tanhf64x(int __x ) ;
#line 79
extern  __attribute__((__nothrow__)) void sincosf64x(int __x , int *__sinx , int *__cosx ) ;
#line 79
extern  __attribute__((__nothrow__)) void __sincosf64x(int __x , int *__sinx , int *__cosx ) ;
#line 85
extern  __attribute__((__nothrow__)) int acoshf64x(int __x ) ;
#line 85
extern  __attribute__((__nothrow__)) int __acoshf64x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int asinhf64x(int __x ) ;
#line 87
extern  __attribute__((__nothrow__)) int __asinhf64x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int atanhf64x(int __x ) ;
#line 89
extern  __attribute__((__nothrow__)) int __atanhf64x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int expf64x(int __x ) ;
#line 95
extern  __attribute__((__nothrow__)) int __expf64x(int __x ) ;
#line 98
extern  __attribute__((__nothrow__)) int frexpf64x(int __x , int *__exponent ) ;
#line 98
extern  __attribute__((__nothrow__)) int __frexpf64x(int __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int ldexpf64x(int __x , int __exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) int __ldexpf64x(int __x , int __exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) int logf64x(int __x ) ;
#line 104
extern  __attribute__((__nothrow__)) int __logf64x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int log10f64x(int __x ) ;
#line 107
extern  __attribute__((__nothrow__)) int __log10f64x(int __x ) ;
#line 110
extern  __attribute__((__nothrow__)) int modff64x(int __x , int *__iptr ) ;
#line 110
extern  __attribute__((__nothrow__)) int __modff64x(int __x , int *__iptr ) ;
#line 114
extern  __attribute__((__nothrow__)) int exp10f64x(int __x ) ;
#line 114
extern  __attribute__((__nothrow__)) int __exp10f64x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int expm1f64x(int __x ) ;
#line 119
extern  __attribute__((__nothrow__)) int __expm1f64x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int log1pf64x(int __x ) ;
#line 122
extern  __attribute__((__nothrow__)) int __log1pf64x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int logbf64x(int __x ) ;
#line 125
extern  __attribute__((__nothrow__)) int __logbf64x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int exp2f64x(int __x ) ;
#line 130
extern  __attribute__((__nothrow__)) int __exp2f64x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int log2f64x(int __x ) ;
#line 133
extern  __attribute__((__nothrow__)) int __log2f64x(int __x ) ;
#line 140
extern  __attribute__((__nothrow__)) int powf64x(int __x , int __y ) ;
#line 140
extern  __attribute__((__nothrow__)) int __powf64x(int __x , int __y ) ;
#line 143
extern  __attribute__((__nothrow__)) int sqrtf64x(int __x ) ;
#line 143
extern  __attribute__((__nothrow__)) int __sqrtf64x(int __x ) ;
#line 147
extern  __attribute__((__nothrow__)) int hypotf64x(int __x , int __y ) ;
#line 147
extern  __attribute__((__nothrow__)) int __hypotf64x(int __x , int __y ) ;
#line 152
extern  __attribute__((__nothrow__)) int cbrtf64x(int __x ) ;
#line 152
extern  __attribute__((__nothrow__)) int __cbrtf64x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int ceilf64x(int __x ) ;
#line 159
extern  __attribute__((__nothrow__)) int __ceilf64x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int fabsf64x(int __x ) ;
#line 162
extern  __attribute__((__nothrow__)) int __fabsf64x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int floorf64x(int __x ) ;
#line 165
extern  __attribute__((__nothrow__)) int __floorf64x(int __x ) ;
#line 168
extern  __attribute__((__nothrow__)) int fmodf64x(int __x , int __y ) ;
#line 168
extern  __attribute__((__nothrow__)) int __fmodf64x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int copysignf64x(int __x , int __y ) ;
#line 198
extern  __attribute__((__nothrow__)) int __copysignf64x(int __x , int __y ) ;
#line 203
extern  __attribute__((__nothrow__)) int nanf64x(char const   *__tagb ) ;
#line 203
extern  __attribute__((__nothrow__)) int __nanf64x(char const   *__tagb ) ;
#line 220
extern  __attribute__((__nothrow__)) int j0f64x() ;
#line 220
extern  __attribute__((__nothrow__)) int __j0f64x() ;
#line 221
extern  __attribute__((__nothrow__)) int j1f64x() ;
#line 221
extern  __attribute__((__nothrow__)) int __j1f64x() ;
#line 222
extern  __attribute__((__nothrow__)) int jnf64x(int  , int _Float64x ) ;
#line 222
extern  __attribute__((__nothrow__)) int __jnf64x(int  , int _Float64x ) ;
#line 223
extern  __attribute__((__nothrow__)) int y0f64x() ;
#line 223
extern  __attribute__((__nothrow__)) int __y0f64x() ;
#line 224
extern  __attribute__((__nothrow__)) int y1f64x() ;
#line 224
extern  __attribute__((__nothrow__)) int __y1f64x() ;
#line 225
extern  __attribute__((__nothrow__)) int ynf64x(int  , int _Float64x ) ;
#line 225
extern  __attribute__((__nothrow__)) int __ynf64x(int  , int _Float64x ) ;
#line 231
extern  __attribute__((__nothrow__)) int erff64x() ;
#line 231
extern  __attribute__((__nothrow__)) int __erff64x() ;
#line 232
extern  __attribute__((__nothrow__)) int erfcf64x() ;
#line 232
extern  __attribute__((__nothrow__)) int __erfcf64x() ;
#line 233
extern  __attribute__((__nothrow__)) int lgammaf64x() ;
#line 233
extern  __attribute__((__nothrow__)) int __lgammaf64x() ;
#line 238
extern  __attribute__((__nothrow__)) int tgammaf64x() ;
#line 238
extern  __attribute__((__nothrow__)) int __tgammaf64x() ;
#line 252
extern  __attribute__((__nothrow__)) int lgammaf64x_r() ;
#line 252
extern  __attribute__((__nothrow__)) int __lgammaf64x_r() ;
#line 259
extern  __attribute__((__nothrow__)) int rintf64x(int __x ) ;
#line 259
extern  __attribute__((__nothrow__)) int __rintf64x(int __x ) ;
#line 262
extern  __attribute__((__nothrow__)) int nextafterf64x(int __x , int __y ) ;
#line 262
extern  __attribute__((__nothrow__)) int __nextafterf64x(int __x , int __y ) ;
#line 269
extern  __attribute__((__nothrow__)) int nextdownf64x(int __x ) ;
#line 269
extern  __attribute__((__nothrow__)) int __nextdownf64x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int nextupf64x(int __x ) ;
#line 271
extern  __attribute__((__nothrow__)) int __nextupf64x(int __x ) ;
#line 275
extern  __attribute__((__nothrow__)) int remainderf64x(int __x , int __y ) ;
#line 275
extern  __attribute__((__nothrow__)) int __remainderf64x(int __x , int __y ) ;
#line 279
extern  __attribute__((__nothrow__)) int scalbnf64x(int __x , int __n ) ;
#line 279
extern  __attribute__((__nothrow__)) int __scalbnf64x(int __x , int __n ) ;
#line 283
extern  __attribute__((__nothrow__)) int ilogbf64x(int __x ) ;
#line 283
extern  __attribute__((__nothrow__)) int __ilogbf64x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long llogbf64x(int __x ) ;
#line 288
extern  __attribute__((__nothrow__)) long __llogbf64x(int __x ) ;
#line 293
extern  __attribute__((__nothrow__)) int scalblnf64x(int __x , long __n ) ;
#line 293
extern  __attribute__((__nothrow__)) int __scalblnf64x(int __x , long __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int nearbyintf64x(int __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __nearbyintf64x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int roundf64x(int __x ) ;
#line 301
extern  __attribute__((__nothrow__)) int __roundf64x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int truncf64x(int __x ) ;
#line 305
extern  __attribute__((__nothrow__)) int __truncf64x(int __x ) ;
#line 310
extern  __attribute__((__nothrow__)) int remquof64x(int __x , int __y , int *__quo ) ;
#line 310
extern  __attribute__((__nothrow__)) int __remquof64x(int __x , int __y , int *__quo ) ;
#line 317
extern  __attribute__((__nothrow__)) long lrintf64x(int __x ) ;
#line 317
extern  __attribute__((__nothrow__)) long __lrintf64x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long llrintf64x(int __x ) ;
#line 319
extern  __attribute__((__nothrow__)) long long __llrintf64x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long lroundf64x(int __x ) ;
#line 323
extern  __attribute__((__nothrow__)) long __lroundf64x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long llroundf64x(int __x ) ;
#line 325
extern  __attribute__((__nothrow__)) long long __llroundf64x(int __x ) ;
#line 329
extern  __attribute__((__nothrow__)) int fdimf64x(int __x , int __y ) ;
#line 329
extern  __attribute__((__nothrow__)) int __fdimf64x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int fmaxf64x(int __x , int __y ) ;
#line 333
extern  __attribute__((__nothrow__)) int __fmaxf64x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int fminf64x(int __x , int __y ) ;
#line 336
extern  __attribute__((__nothrow__)) int __fminf64x(int __x , int __y ) ;
#line 340
extern  __attribute__((__nothrow__)) int fmaf64x(int __x , int __y , int __z ) ;
#line 340
extern  __attribute__((__nothrow__)) int __fmaf64x(int __x , int __y , int __z ) ;
#line 345
extern  __attribute__((__nothrow__)) int roundevenf64x(int __x ) ;
#line 345
extern  __attribute__((__nothrow__)) int __roundevenf64x(int __x ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t fromfpf64x(int __x , int __round ,
                                                           unsigned int __width ) ;
#line 349
extern  __attribute__((__nothrow__)) __intmax_t __fromfpf64x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpf64x(int __x , int __round ,
                                                             unsigned int __width ) ;
#line 354
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpf64x(int __x , int __round ,
                                                               unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t fromfpxf64x(int __x , int __round ,
                                                            unsigned int __width ) ;
#line 360
extern  __attribute__((__nothrow__)) __intmax_t __fromfpxf64x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t ufromfpxf64x(int __x , int __round ,
                                                              unsigned int __width ) ;
#line 366
extern  __attribute__((__nothrow__)) __uintmax_t __ufromfpxf64x(int __x , int __round ,
                                                                unsigned int __width ) ;
#line 370
extern  __attribute__((__nothrow__)) int canonicalizef64x(int *__cx , int const   *__x ) ;
#line 377
extern  __attribute__((__nothrow__)) int fmaxmagf64x(int __x , int __y ) ;
#line 377
extern  __attribute__((__nothrow__)) int __fmaxmagf64x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int fminmagf64x(int __x , int __y ) ;
#line 380
extern  __attribute__((__nothrow__)) int __fminmagf64x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int fmaximumf64x(int __x , int __y ) ;
#line 385
extern  __attribute__((__nothrow__)) int __fmaximumf64x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int fminimumf64x(int __x , int __y ) ;
#line 388
extern  __attribute__((__nothrow__)) int __fminimumf64x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int fmaximum_numf64x(int __x , int __y ) ;
#line 391
extern  __attribute__((__nothrow__)) int __fmaximum_numf64x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int fminimum_numf64x(int __x , int __y ) ;
#line 394
extern  __attribute__((__nothrow__)) int __fminimum_numf64x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int fmaximum_magf64x(int __x , int __y ) ;
#line 397
extern  __attribute__((__nothrow__)) int __fmaximum_magf64x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int fminimum_magf64x(int __x , int __y ) ;
#line 400
extern  __attribute__((__nothrow__)) int __fminimum_magf64x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int fmaximum_mag_numf64x(int __x , int __y ) ;
#line 403
extern  __attribute__((__nothrow__)) int __fmaximum_mag_numf64x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int fminimum_mag_numf64x(int __x , int __y ) ;
#line 406
extern  __attribute__((__nothrow__)) int __fminimum_mag_numf64x(int __x , int __y ) ;
#line 411
extern  __attribute__((__nothrow__)) int totalorderf64x(int const   *__x , int const   *__y ) ;
#line 416
extern  __attribute__((__nothrow__)) int totalordermagf64x(int const   *__x , int const   *__y ) ;
#line 421
extern  __attribute__((__nothrow__)) int getpayloadf64x(int const   *__x ) ;
#line 421
extern  __attribute__((__nothrow__)) int __getpayloadf64x(int const   *__x ) ;
#line 424
extern  __attribute__((__nothrow__)) int setpayloadf64x(int *__x , int __payload ) ;
#line 427
extern  __attribute__((__nothrow__)) int setpayloadsigf64x(int *__x , int __payload ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h"
extern  __attribute__((__nothrow__)) float fadd(double __x , double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) float fdiv(double __x , double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) float ffma(double __x , double __y , double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) float fmul(double __x , double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) float fsqrt(double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) float fsub(double __x , double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) float faddl(long double __x , long double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) float fdivl(long double __x , long double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) float ffmal(long double __x , long double __y ,
                                                 long double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) float fmull(long double __x , long double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) float fsqrtl(long double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) float fsubl(long double __x , long double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) double daddl(long double __x , long double __y ) ;
#line 27
extern  __attribute__((__nothrow__)) double ddivl(long double __x , long double __y ) ;
#line 30
extern  __attribute__((__nothrow__)) double dfmal(long double __x , long double __y ,
                                                  long double __z ) ;
#line 33
extern  __attribute__((__nothrow__)) double dmull(long double __x , long double __y ) ;
#line 36
extern  __attribute__((__nothrow__)) double dsqrtl(long double __x ) ;
#line 39
extern  __attribute__((__nothrow__)) double dsubl(long double __x , long double __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf32x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf32x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf32x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf32x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf32x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf32x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf64(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf64(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf64(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf64(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf64(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf64(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32addf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32divf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32fmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32mulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32sqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32subf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf64(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf64(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf64(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf64(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf64(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf64(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f32xaddf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f32xdivf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f32xfmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f32xmulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f32xsqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f32xsubf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64addf64x(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64divf64x(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64fmaf64x(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64mulf64x(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64sqrtf64x(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64subf64x(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64addf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64divf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64fmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64mulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64sqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64subf128(int __x , int __y ) ;
#line 24
extern  __attribute__((__nothrow__)) int f64xaddf128(int __x , int __y ) ;
#line 27
extern  __attribute__((__nothrow__)) int f64xdivf128(int __x , int __y ) ;
#line 30
extern  __attribute__((__nothrow__)) int f64xfmaf128(int __x , int __y , int __z ) ;
#line 33
extern  __attribute__((__nothrow__)) int f64xmulf128(int __x , int __y ) ;
#line 36
extern  __attribute__((__nothrow__)) int f64xsqrtf128(int __x ) ;
#line 39
extern  __attribute__((__nothrow__)) int f64xsubf128(int __x , int __y ) ;
#line 854 "/usr/include/math.h"
extern int signgam ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h"
extern  __attribute__((__nothrow__)) int __iscanonicall(long double __x ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 45
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 35 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.h"
void (*putpixels[5])(SDL_Surface * , int  , int  , Uint32  ) ;
#line 36
Uint32 (*getpixels[5])(SDL_Surface * , int  , int  ) ;
#line 70 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/postscript_print.c"
static int f2int(float f ) 
{ 


  {
#line 72
  return ((int )f);
}
}
#line 75 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/postscript_print.c"
static int f2dec(float f ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = f2int(f);
  }
#line 77
  return ((int )((f - (float )__cil_tmp2) * (float )100));
}
}
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/postscript_print.c"
int do_ps_save(FILE *fi , char const   *fname , SDL_Surface *surf , char const   *pprsize ,
               int is_pipe ) 
{ 
  struct paper *ppr ;
  int img_w ;
  int img_h ;
  int r_img_w ;
  int r_img_h ;
  int ppr_w ;
  int ppr_h ;
  int x ;
  int y ;
  float tlate_x ;
  float tlate_y ;
  int cur_line_len ;
  int plane ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  char buf[256] ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  int printed_img_w ;
  int printed_img_h ;
  time_t t ;
  time_t __cil_tmp27 ;
  int rotate ;
  float scale ;
  char *__cil_tmp30 ;
  char const   *__cil_tmp31 ;
  struct paper *__cil_tmp32 ;
  double __cil_tmp33 ;
  double __cil_tmp34 ;
  float tmp ;
  struct tm *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  Uint32 __cil_tmp45 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  pid_t child_pid ;
  pid_t w ;
  int status ;
  int __cil_tmp55 ;
  int *__cil_tmp56 ;
  int *__cil_tmp57 ;
  __pid_t __cil_tmp58 ;

  {
  {
#line 85
  img_w = surf->w;
#line 86
  img_h = surf->h;
#line 96
  getpixel = getpixels[(surf->format)->BytesPerPixel];
#line 98
  __cil_tmp27 = time((time_t *)((void *)0));
#line 98
  t = __cil_tmp27;
#line 105
  paperinit();
  }
#line 107
  if (pprsize == (void *)0) {
    {
#line 113
    __cil_tmp30 = systempapername();
#line 113
    pprsize = (char const   *)__cil_tmp30;
    }
#line 115
    if (pprsize == (void *)0) {
      {
#line 119
      pprsize = defaultpapername();
      }
    }
  }
  {
#line 146
  ppr = paperinfo(pprsize);
#line 148
  __cil_tmp33 = paperpswidth(ppr);
#line 148
  ppr_w = (int )__cil_tmp33;
#line 149
  __cil_tmp34 = paperpsheight(ppr);
#line 149
  ppr_h = (int )__cil_tmp34;
#line 155
  paperdone();
  }
#line 160
  if (ppr_w >= ppr_h) {
#line 160
    if (img_w >= img_h) {
#line 162
      rotate = 0;
#line 163
      r_img_w = img_w;
#line 164
      r_img_h = img_h;
    } else {
#line 160
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 160
  if (ppr_w <= ppr_h) {
#line 160
    if (img_w <= img_h) {
#line 162
      rotate = 0;
#line 163
      r_img_w = img_w;
#line 164
      r_img_h = img_h;
    } else {
#line 168
      rotate = 1;
#line 169
      r_img_w = img_h;
#line 170
      r_img_h = img_w;
    }
  } else {
#line 168
    rotate = 1;
#line 169
    r_img_w = img_h;
#line 170
    r_img_h = img_w;
  }
#line 182
  if ((float )(ppr_w - 72) / (float )r_img_w < (float )(ppr_h - 72) / (float )r_img_h) {
#line 182
    tmp = (float )(ppr_w - 72) / (float )r_img_w;
  } else {
#line 182
    tmp = (float )(ppr_h - 72) / (float )r_img_h;
  }
  {
#line 182
  scale = tmp;
#line 184
  printed_img_w = (int )((float )r_img_w * scale);
#line 185
  printed_img_h = (int )((float )r_img_h * scale);
#line 193
  tlate_x = (float )((ppr_w - printed_img_w) / 2);
#line 194
  tlate_y = (float )((ppr_h - printed_img_h) / 2);
#line 203
  fprintf(fi, "%%!PS-Adobe-2.0 EPSF-2.0\n");
#line 205
  fprintf(fi, "%%%%Title: (%s)\n\230\001", fname);
#line 207
  __cil_tmp36 = localtime(& t);
#line 207
  strftime((char *)buf, sizeof(buf) - 1UL, "%a %b %e %H:%M:%S %Y", __cil_tmp36);
#line 208
  fprintf(fi, "%%%%CreationDate: (%s)\n", (char *)buf);
#line 210
  fprintf(fi, "%%%%Creator: (Tux Paint 0.9.27, 2024-04-18)\n");
#line 212
  fprintf(fi, "%%%%Pages: 1\n");
#line 214
  fprintf(fi, "%%%%BoundingBox: 0 0 %d %d\n", (int )((double )ppr_w + 0.5), (int )((double )ppr_h + 0.5));
#line 216
  fprintf(fi, "%%%%EndComments\n\220");
#line 221
  fprintf(fi, "/readstring {\n");
#line 222
  fprintf(fi, "  currentfile exch readhexstring pop\n");
#line 223
  fprintf(fi, "} bind def\n");
#line 225
  fprintf(fi, "/rpicstr %d string def\n", img_w);
#line 226
  fprintf(fi, "/gpicstr %d string def\n", img_w);
#line 227
  fprintf(fi, "/bpicstr %d string def\n", img_w);
#line 229
  fprintf(fi, "%%%%EndProlog\n");
#line 231
  fprintf(fi, "%%%%Page: 1 1\n");
#line 233
  fprintf(fi, "<< /PageSize [ %d %d ] /ImagingBBox null >> setpagedevice\n", ppr_w,
          ppr_h);
#line 235
  fprintf(fi, "gsave\n");
#line 240
  __cil_tmp37 = f2int(tlate_x);
  }
  {
#line 240
  __cil_tmp38 = f2dec(tlate_x);
  }
  {
#line 240
  __cil_tmp39 = f2int(tlate_y);
  }
  {
#line 240
  __cil_tmp40 = f2dec(tlate_y);
#line 240
  fprintf(fi, "%d.%02d %d.%02d translate\n", __cil_tmp37, __cil_tmp38, __cil_tmp39,
          __cil_tmp40);
#line 245
  __cil_tmp41 = f2int((float )printed_img_w);
  }
  {
#line 245
  __cil_tmp42 = f2dec((float )printed_img_w);
  }
  {
#line 245
  __cil_tmp43 = f2int((float )printed_img_h);
  }
  {
#line 245
  __cil_tmp44 = f2dec((float )printed_img_h);
#line 245
  fprintf(fi, "%d.%02d %d.%02d scale\n", __cil_tmp41, __cil_tmp42, __cil_tmp43, __cil_tmp44);
  }
#line 249
  if (rotate) {
    {
#line 250
    fprintf(fi, "0.5 0.5 translate  90 rotate  -0.5 -0.5 translate\n");
    }
  }
  {
#line 252
  fprintf(fi, "%d %d 8\n\230\001", img_w, img_h);
#line 253
  fprintf(fi, "[ %d 0 0 %d 0 %d ]\n", img_w, - img_h, img_h);
#line 255
  fprintf(fi, "{ rpicstr readstring }\n");
#line 256
  fprintf(fi, "{ gpicstr readstring }\n");
#line 257
  fprintf(fi, "{ bpicstr readstring }\n");
#line 259
  fprintf(fi, "true 3\n");
#line 261
  fprintf(fi, "colorimage\n");
#line 263
  cur_line_len = 0;
#line 265
  y = 0;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (y < img_h)) {
#line 265
      goto while_break;
    }
#line 267
    plane = 0;
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      if (! (plane < 3)) {
#line 267
        goto while_break___0;
      }
#line 269
      x = 0;
      {
#line 269
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 269
        if (! (x < img_w)) {
#line 269
          goto while_break___1;
        }
        {
#line 271
        __cil_tmp45 = (*getpixel)(surf, x, y);
#line 271
        SDL_GetRGB(__cil_tmp45, surf->format, & r, & g, & b);
        }
#line 272
        if (plane == 0) {
#line 272
          tmp___1 = (int )r;
        } else {
#line 272
          if (plane == 1) {
#line 272
            tmp___0 = (int )g;
          } else {
#line 272
            tmp___0 = (int )b;
          }
#line 272
          tmp___1 = tmp___0;
        }
        {
#line 272
        fprintf(fi, "%02x", tmp___1);
#line 274
        cur_line_len ++;
        }
#line 275
        if (cur_line_len >= 30) {
          {
#line 277
          fprintf(fi, "\n");
#line 278
          cur_line_len = 0;
          }
        }
#line 269
        x ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 267
      plane ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 265
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 284
  fprintf(fi, "\n");
#line 285
  fprintf(fi, "grestore\n");
#line 286
  fprintf(fi, "showpage\n");
#line 287
  fprintf(fi, "%%%%Trailer\n");
#line 288
  fprintf(fi, "%%%%EOF\n\220");
  }
#line 290
  if (! is_pipe) {
    {
#line 292
    fclose(fi);
    }
#line 293
    return (1);
  } else {
    {
#line 306
    child_pid = pclose(fi);
#line 315
    __cil_tmp57 = __errno_location();
    }
    {
#line 315
    __cil_tmp56 = __errno_location();
    }
#line 315
    if (child_pid < 0) {
#line 317
      return (0);
    } else
#line 315
    if (*__cil_tmp56 != 0) {
#line 315
      if (*__cil_tmp57 != 11) {
#line 317
        return (0);
      } else {
#line 315
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 319
    if (child_pid == 0) {
#line 321
      return (1);
    }
    {
#line 324
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 326
      w = waitpid(child_pid, & status, 0);
      }
#line 324
      if (! ((w != -1 && ! ((status & 127) == 0)) && ! ((int )((signed char )((status & 127) + 1)) >> 1 > 0))) {
#line 324
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 354
    if ((status & 127) == 0) {
#line 354
      if ((status & 65280) >> 8 != 0) {
#line 355
        return (0);
      }
    }
#line 357
    return (1);
  }
}
}
#line 76 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.h"
char const   *sound_fnames[31] ;
#line 34 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.c"
char const   *sound_fnames[31]  = 
#line 34 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/sounds.c"
  {      "/usr/local/share/tuxpaint/sounds/harp.wav",      "/usr/local/share/tuxpaint/sounds/click.wav",      "/usr/local/share/tuxpaint/sounds/bleep.wav",      "/usr/local/share/tuxpaint/sounds/bubble.wav", 
        "/usr/local/share/tuxpaint/sounds/stamp.wav",      "/usr/local/share/tuxpaint/sounds/line_start.wav",      "/usr/local/share/tuxpaint/sounds/line_end.wav",      "/usr/local/share/tuxpaint/sounds/scroll.wav", 
        "/usr/local/share/tuxpaint/sounds/paint1.wav",      "/usr/local/share/tuxpaint/sounds/paint2.wav",      "/usr/local/share/tuxpaint/sounds/paint3.wav",      "/usr/local/share/tuxpaint/sounds/paint4.wav", 
        "/usr/local/share/tuxpaint/sounds/eraser1.wav\323\001 ",      "/usr/local/share/tuxpaint/sounds/eraser2.wav\323\001 ",      "/usr/local/share/tuxpaint/sounds/save.wav",      "/usr/local/share/tuxpaint/sounds/prompt.wav", 
        "/usr/local/share/tuxpaint/sounds/flip.wav",      "/usr/local/share/tuxpaint/sounds/mirror.wav",      "/usr/local/share/tuxpaint/sounds/keyclick.wav",      "/usr/local/share/tuxpaint/sounds/typewriterbell.wav", 
        "/usr/local/share/tuxpaint/sounds/return.wav",      "/usr/local/share/tuxpaint/sounds/shrink.wav",      "/usr/local/share/tuxpaint/sounds/grow.wav",      "/usr/local/share/tuxpaint/sounds/italic_on.wav", 
        "/usr/local/share/tuxpaint/sounds/italic_off.wav",      "/usr/local/share/tuxpaint/sounds/areyousure.wav",      "/usr/local/share/tuxpaint/sounds/youcannot.wav",      "/usr/local/share/tuxpaint/sounds/tuxok.wav", 
        "/usr/local/share/tuxpaint/sounds/thick.wav",      "/usr/local/share/tuxpaint/sounds/thin.wav",      "/usr/local/share/tuxpaint/sounds/fill.wav"};
#line 17 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.h"
ge_GIF *ge_new_gif(char const   *fname , uint16_t width , uint16_t height , uint8_t *palette ,
                   int depth , int loop ) ;
#line 21
void ge_add_frame(ge_GIF *gif , uint16_t delay ) ;
#line 22
void ge_close_gif(ge_GIF *gif ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat(char const   *__file , struct stat *__buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__buf ) ;
#line 264
extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__file ,
                                                 struct stat *__buf , int __flag ) ;
#line 313
extern  __attribute__((__nothrow__)) int lstat(char const   *__file , struct stat *__buf ) ;
#line 352
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode ) ;
#line 359
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode ) ;
#line 365
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 371
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t __mode , int __flag ) ;
#line 380
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 389
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode ) ;
#line 396
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode ) ;
#line 404
extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                               __dev_t __dev ) ;
#line 411
extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                 __mode_t __mode , __dev_t __dev ) ;
#line 418
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode ) ;
#line 425
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode ) ;
#line 433
extern  __attribute__((__nothrow__)) int utimensat(int __fd , char const   *__path ,
                                                   struct timespec __times[2] , int __flags ) ;
#line 452
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec __times[2] ) ;
#line 149 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 181
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 205
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 227
extern int creat(char const   *__file , mode_t __mode ) ;
#line 273
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off_t __offset ,
                                                       __off_t __len , int __advise ) ;
#line 295
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len ) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open_2(char const   *__path , int __oflag ) ;
#line 27
extern int __open_alias(char const   *__path , int __oflag  , ...) ;
#line 35
extern void __open_too_many_args(void) ;
#line 37
extern void __open_missing_mode(void) ;
#line 41
__inline extern int open(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 43
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 43
  if (__cil_tmp3 > 1) {
    {
#line 44
    __open_too_many_args();
    }
  }
  {
#line 46
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 46
  if (__cil_tmp4) {
    {
#line 48
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 48
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 48
      if (__cil_tmp5 < 1) {
        {
#line 50
        __open_missing_mode();
#line 51
        __cil_tmp6 = __open_2(__path, __oflag);
        }
#line 51
        return (__cil_tmp6);
      }
    } else
#line 48
    if ((__oflag & 4259840) == 4259840) {
#line 48
      goto _L;
    }
    {
#line 53
    __cil_tmp7 = __builtin_va_arg_pack();
#line 53
    __cil_tmp8 = __open_alias(__path, __oflag, __cil_tmp7);
    }
#line 53
    return (__cil_tmp8);
  }
  {
#line 56
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 56
  if (__cil_tmp9 < 1) {
    {
#line 57
    __cil_tmp10 = __open_2(__path, __oflag);
    }
#line 57
    return (__cil_tmp10);
  }
  {
#line 59
  __cil_tmp11 = __builtin_va_arg_pack();
#line 59
  __cil_tmp12 = __open_alias(__path, __oflag, __cil_tmp11);
  }
#line 59
  return (__cil_tmp12);
}
}
#line 98
extern int __openat_2(int __fd , char const   *__path , int __oflag ) ;
#line 100
extern int __openat_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 111
extern void __openat_too_many_args(void) ;
#line 113
extern void __openat_missing_mode(void) ;
#line 117
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 119
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 119
  if (__cil_tmp4 > 1) {
    {
#line 120
    __openat_too_many_args();
    }
  }
  {
#line 122
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 122
  if (__cil_tmp5) {
    {
#line 124
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 124
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 124
      if (__cil_tmp6 < 1) {
        {
#line 126
        __openat_missing_mode();
#line 127
        __cil_tmp7 = __openat_2(__fd, __path, __oflag);
        }
#line 127
        return (__cil_tmp7);
      }
    } else
#line 124
    if ((__oflag & 4259840) == 4259840) {
#line 124
      goto _L;
    }
    {
#line 129
    __cil_tmp8 = __builtin_va_arg_pack();
#line 129
    __cil_tmp9 = __openat_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 129
    return (__cil_tmp9);
  }
  {
#line 132
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 132
  if (__cil_tmp10 < 1) {
    {
#line 133
    __cil_tmp11 = __openat_2(__fd, __path, __oflag);
    }
#line 133
    return (__cil_tmp11);
  }
  {
#line 135
  __cil_tmp12 = __builtin_va_arg_pack();
#line 135
  __cil_tmp13 = __openat_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 135
  return (__cil_tmp13);
}
}
#line 18 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static uint8_t vga[48]  = 
#line 18 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
  {      (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )170, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )0,      (uint8_t )170, 
        (uint8_t )0,      (uint8_t )170,      (uint8_t )85,      (uint8_t )0, 
        (uint8_t )0,      (uint8_t )0,      (uint8_t )170,      (uint8_t )170, 
        (uint8_t )0,      (uint8_t )170,      (uint8_t )0,      (uint8_t )170, 
        (uint8_t )170,      (uint8_t )170,      (uint8_t )170,      (uint8_t )170, 
        (uint8_t )85,      (uint8_t )85,      (uint8_t )85,      (uint8_t )255, 
        (uint8_t )85,      (uint8_t )85,      (uint8_t )85,      (uint8_t )255, 
        (uint8_t )85,      (uint8_t )255,      (uint8_t )255,      (uint8_t )85, 
        (uint8_t )85,      (uint8_t )85,      (uint8_t )255,      (uint8_t )255, 
        (uint8_t )85,      (uint8_t )255,      (uint8_t )85,      (uint8_t )255, 
        (uint8_t )255,      (uint8_t )255,      (uint8_t )255,      (uint8_t )255};
#line 44 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static Node *new_node(uint16_t key , int degree ) 
{ 
  Node *node ;
  void *__cil_tmp4 ;

  {
  {
#line 46
  __cil_tmp4 = calloc((unsigned long )1, sizeof(*node) + (unsigned long )degree * sizeof(Node *));
#line 46
  node = __cil_tmp4;
  }
#line 47
  if (node) {
#line 48
    node->key = key;
  }
#line 49
  return (node);
}
}
#line 53 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static Node *new_trie(int degree , int *nkeys ) 
{ 
  Node *root ;
  Node *__cil_tmp4 ;
  Node *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 55
  __cil_tmp4 = new_node((uint16_t )0, degree);
#line 55
  root = __cil_tmp4;
#line 57
  *nkeys = 0;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (*nkeys < degree)) {
#line 57
      goto while_break;
    }
    {
#line 58
    root->children[*nkeys] = new_node((uint16_t )*nkeys, degree);
    }
#line 57
    (*nkeys) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  *nkeys += 2;
#line 60
  return (root);
}
}
#line 64 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void del_trie(Node *root , int degree ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 68
  if (! root) {
#line 69
    return;
  }
#line 70
  i = 0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! (i < degree)) {
#line 70
      goto while_break;
    }
    {
#line 71
    del_trie(root->children[i], degree);
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  free(root);
  }
  return;
}
}
#line 75
static void put_loop(ge_GIF *gif , uint16_t loop ) ;
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
ge_GIF *ge_new_gif(char const   *fname , uint16_t width , uint16_t height , uint8_t *palette ,
                   int depth , int loop ) 
{ 
  int i ;
  int r ;
  int g ;
  int b ;
  int v ;
  ssize_t res ;
  ge_GIF *gif ;
  void *__cil_tmp14 ;
  int tmp ;
  int __cil_tmp16 ;
  ssize_t __cil_tmp17 ;
  uint8_t tmp___0[2] ;
  ssize_t __cil_tmp19 ;
  uint8_t tmp___1[2] ;
  ssize_t __cil_tmp21 ;
  uint8_t tmp___2[3] ;
  ssize_t __cil_tmp23 ;
  ssize_t __cil_tmp24 ;
  ssize_t __cil_tmp25 ;
  ssize_t __cil_tmp26 ;
  uint8_t tmp___3[3] ;
  ssize_t __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  uint8_t tmp___4[3] ;
  ssize_t __cil_tmp33 ;
  int __cil_tmp34 ;

  {
  {
#line 88
  __cil_tmp14 = calloc((unsigned long )1, sizeof(*gif) + (unsigned long )((2 * (int )width) * (int )height));
#line 88
  gif = __cil_tmp14;
  }
#line 89
  if (! gif) {
#line 90
    goto no_gif;
  }
#line 91
  gif->w = width;
#line 91
  gif->h = height;
#line 92
  if (depth > 1) {
#line 92
    tmp = depth;
  } else {
#line 92
    tmp = 2;
  }
  {
#line 92
  gif->depth = tmp;
#line 93
  gif->frame = (uint8_t *)(gif + 1);
#line 94
  gif->back = gif->frame + (int )width * (int )height;
#line 95
  gif->fd = creat(fname, (mode_t )438);
  }
#line 96
  if (gif->fd == -1) {
#line 97
    goto no_fd;
  }
  {
#line 101
  res = write(gif->fd, "GIF89a", (size_t )6);
  }
#line 101
  if (res == -1L) {
    {
#line 101
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 101
    return ((ge_GIF *)((void *)0));
  }
  {
#line 102
  tmp___0[0] = (uint8_t )((int )width & 255);
#line 102
  tmp___0[1] = (uint8_t )((int )width >> 8);
#line 102
  __cil_tmp19 = write(gif->fd, (uint8_t *)tmp___0, (size_t )2);
#line 102
  res = __cil_tmp19;
  }
#line 102
  if (res == -1L) {
    {
#line 102
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 102
    return ((ge_GIF *)((void *)0));
  }
  {
#line 103
  tmp___1[0] = (uint8_t )((int )height & 255);
#line 103
  tmp___1[1] = (uint8_t )((int )height >> 8);
#line 103
  __cil_tmp21 = write(gif->fd, (uint8_t *)tmp___1, (size_t )2);
#line 103
  res = __cil_tmp21;
  }
#line 103
  if (res == -1L) {
    {
#line 103
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 103
    return ((ge_GIF *)((void *)0));
  }
  {
#line 104
  tmp___2[0] = (uint8_t )(240 | (depth - 1));
#line 104
  tmp___2[1] = (uint8_t )0;
#line 104
  tmp___2[2] = (uint8_t )0;
#line 104
  __cil_tmp23 = write(gif->fd, (uint8_t *)tmp___2, (size_t )3);
#line 104
  res = __cil_tmp23;
  }
#line 104
  if (res == -1L) {
    {
#line 104
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 104
    return ((ge_GIF *)((void *)0));
  }

#line 105
  if (palette) {
    {
#line 106
    res = write(gif->fd, palette, (size_t )(3 << depth));
    }
#line 106
    if (res == -1L) {
      {
#line 106
      fprintf(stderr, "Cannot write to GIF\n");
      }
#line 106
      return ((ge_GIF *)((void *)0));
    }

  } else
#line 107
  if (depth <= 4) {
    {
#line 108
    res = write(gif->fd, (uint8_t *)vga, (size_t )(3 << depth));
    }
#line 108
    if (res == -1L) {
      {
#line 108
      fprintf(stderr, "Cannot write to GIF\n");
      }
#line 108
      return ((ge_GIF *)((void *)0));
    }

  } else {
    {
#line 110
    res = write(gif->fd, (uint8_t *)vga, sizeof(vga));
    }
#line 110
    if (res == -1L) {
      {
#line 110
      fprintf(stderr, "Cannot write to GIF\n");
      }
#line 110
      return ((ge_GIF *)((void *)0));
    }
#line 111
    i = 16;
#line 112
    r = 0;
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      if (! (r < 6)) {
#line 112
        goto while_break;
      }
#line 113
      g = 0;
      {
#line 113
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 113
        if (! (g < 6)) {
#line 113
          goto while_break___0;
        }
#line 114
        b = 0;
        {
#line 114
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 114
          if (! (b < 6)) {
#line 114
            goto while_break___1;
          }
          {
#line 115
          tmp___3[0] = (uint8_t )(r * 51);
#line 115
          tmp___3[1] = (uint8_t )(g * 51);
#line 115
          tmp___3[2] = (uint8_t )(b * 51);
#line 115
          __cil_tmp28 = write(gif->fd, (uint8_t *)tmp___3, (size_t )3);
#line 115
          res = __cil_tmp28;
          }
#line 115
          if (res == -1L) {
            {
#line 115
            fprintf(stderr, "Cannot write to GIF\n");
            }
#line 115
            return ((ge_GIF *)((void *)0));
          }
#line 116
          i ++;
#line 116
          if (i == 1 << depth) {
#line 117
            goto done_gct;
          }
#line 114
          b ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 113
        g ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 112
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 121
    i = 1;
    {
#line 121
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 121
      if (! (i <= 24)) {
#line 121
        goto while_break___2;
      }
      {
#line 122
      v = (i * 255) / 25;
#line 123
      tmp___4[0] = (uint8_t )v;
#line 123
      tmp___4[1] = (uint8_t )v;
#line 123
      tmp___4[2] = (uint8_t )v;
#line 123
      __cil_tmp33 = write(gif->fd, (uint8_t *)tmp___4, (size_t )3);
#line 123
      res = __cil_tmp33;
      }
#line 123
      if (res == -1L) {
        {
#line 123
        fprintf(stderr, "Cannot write to GIF\n");
        }
#line 123
        return ((ge_GIF *)((void *)0));
      }

#line 121
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  done_gct: 
#line 127
  if (loop >= 0) {
#line 127
    if (loop <= 65535) {
      {
#line 128
      put_loop(gif, (uint16_t )loop);
      }
    }
  }
#line 129
  return (gif);
  no_fd: 
  {
#line 131
  free(gif);
  }
  no_gif: 
#line 133
  return ((ge_GIF *)((void *)0));
}
}
#line 137 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void put_loop(ge_GIF *gif , uint16_t loop ) 
{ 
  ssize_t res ;
  uint8_t tmp[3] ;
  ssize_t __cil_tmp5 ;
  ssize_t __cil_tmp6 ;
  uint8_t tmp___0[2] ;
  ssize_t __cil_tmp8 ;
  uint8_t tmp___1[2] ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 141
  tmp[0] = (uint8_t )'!';
#line 141
  tmp[1] = (uint8_t )255;
#line 141
  tmp[2] = (uint8_t )11;
#line 141
  __cil_tmp5 = write(gif->fd, (uint8_t *)tmp, (size_t )3);
#line 141
  res = __cil_tmp5;
  }
#line 141
  if (res == -1L) {
    {
#line 141
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 141
    return;
  }
  {
#line 142
  res = write(gif->fd, "NETSCAPE2.0", (size_t )11);
  }
#line 142
  if (res == -1L) {
    {
#line 142
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 142
    return;
  }
  {
#line 143
  tmp___0[0] = (uint8_t )3;
#line 143
  tmp___0[1] = (uint8_t )1;
#line 143
  __cil_tmp8 = write(gif->fd, (uint8_t *)tmp___0, (size_t )2);
#line 143
  res = __cil_tmp8;
  }
#line 143
  if (res == -1L) {
    {
#line 143
    fprintf(stderr, "Cannot write to GIF\n\324U");
    }
#line 143
    return;
  }
  {
#line 144
  tmp___1[0] = (uint8_t )((int )loop & 255);
#line 144
  tmp___1[1] = (uint8_t )((int )loop >> 8);
#line 144
  __cil_tmp10 = write(gif->fd, (uint8_t *)tmp___1, (size_t )2);
#line 144
  res = __cil_tmp10;
  }
#line 144
  if (res == -1L) {
    {
#line 144
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 144
    return;
  }
  {
#line 145
  res = write(gif->fd, "", (size_t )1);
  }
#line 145
  if (res == -1L) {
    {
#line 145
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 145
    return;
  }

  return;
}
}
#line 152 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void put_key(ge_GIF *gif , uint16_t key , int key_size ) 
{ 
  int byte_offset ;
  int bit_offset ;
  int bits_to_write ;
  ssize_t res ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  ssize_t __cil_tmp10 ;

  {
#line 157
  byte_offset = gif->offset / 8;
#line 158
  bit_offset = gif->offset % 8;
#line 159
  gif->partial |= (uint32_t )key << bit_offset;
#line 160
  bits_to_write = bit_offset + key_size;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (bits_to_write >= 8)) {
#line 161
      goto while_break;
    }
#line 162
    __cil_tmp8 = byte_offset;
#line 162
    byte_offset ++;
#line 162
    gif->buffer[__cil_tmp8] = (uint8_t )(gif->partial & 255U);
#line 163
    if (byte_offset == 255) {
      {
#line 164
      res = write(gif->fd, "\377", (size_t )1);
      }
#line 164
      if (res == -1L) {
        {
#line 164
        fprintf(stderr, "Cannot write to GIF\n");
        }
#line 164
        return;
      }
      {
#line 165
      res = write(gif->fd, (uint8_t *)gif->buffer, (size_t )255);
      }
#line 165
      if (res == -1L) {
        {
#line 165
        fprintf(stderr, "Cannot write to GIF\n\324U");
        }
#line 165
        return;
      }
#line 166
      byte_offset = 0;
    }
#line 168
    gif->partial >>= 8;
#line 169
    bits_to_write -= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  gif->offset = (gif->offset + key_size) % 2040;
  return;
}
}
#line 175 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void end_key(ge_GIF *gif ) 
{ 
  int byte_offset ;
  ssize_t res ;
  int __cil_tmp4 ;
  uint8_t tmp[1] ;
  ssize_t __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  ssize_t __cil_tmp8 ;

  {
#line 180
  byte_offset = gif->offset / 8;
#line 181
  if (gif->offset % 8) {
#line 182
    __cil_tmp4 = byte_offset;
#line 182
    byte_offset ++;
#line 182
    gif->buffer[__cil_tmp4] = (uint8_t )(gif->partial & 255U);
  }
  {
#line 183
  tmp[0] = (uint8_t )byte_offset;
#line 183
  __cil_tmp6 = write(gif->fd, (uint8_t *)tmp, (size_t )1);
#line 183
  res = __cil_tmp6;
  }
#line 183
  if (res == -1L) {
    {
#line 183
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 183
    return;
  }
  {
#line 184
  res = write(gif->fd, (uint8_t *)gif->buffer, (size_t )byte_offset);
  }
#line 184
  if (res == -1L) {
    {
#line 184
    fprintf(stderr, "Cannot write to GIF\n\324U");
    }
#line 184
    return;
  }
  {
#line 185
  res = write(gif->fd, "", (size_t )1);
  }
#line 185
  if (res == -1L) {
    {
#line 185
    fprintf(stderr, "Cannot write to GIF\n\324U");
    }
#line 185
    return;
  }
#line 186
  gif->partial = (uint32_t )0;
#line 186
  gif->offset = (int )gif->partial;
  return;
}
}
#line 190 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void put_image(ge_GIF *gif , uint16_t w , uint16_t h , uint16_t x , uint16_t y ) 
{ 
  int nkeys ;
  int key_size ;
  int i ;
  int j ;
  Node *node ;
  Node *child ;
  Node *root ;
  ssize_t res ;
  int degree ;
  ssize_t __cil_tmp15 ;
  uint8_t tmp[2] ;
  ssize_t __cil_tmp17 ;
  uint8_t tmp___0[2] ;
  ssize_t __cil_tmp19 ;
  uint8_t tmp___1[2] ;
  ssize_t __cil_tmp21 ;
  uint8_t tmp___2[2] ;
  ssize_t __cil_tmp23 ;
  uint8_t tmp___3[2] ;
  ssize_t __cil_tmp25 ;
  Node *__cil_tmp26 ;
  uint8_t pixel ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  Node *__cil_tmp30 ;
  Node *__cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;

  {
  {
#line 195
  degree = 1 << gif->depth;
#line 197
  res = write(gif->fd, ",", (size_t )1);
  }
#line 197
  if (res == -1L) {
    {
#line 197
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 197
    return;
  }
  {
#line 198
  tmp[0] = (uint8_t )((int )x & 255);
#line 198
  tmp[1] = (uint8_t )((int )x >> 8);
#line 198
  __cil_tmp17 = write(gif->fd, (uint8_t *)tmp, (size_t )2);
#line 198
  res = __cil_tmp17;
  }
#line 198
  if (res == -1L) {
    {
#line 198
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 198
    return;
  }
  {
#line 199
  tmp___0[0] = (uint8_t )((int )y & 255);
#line 199
  tmp___0[1] = (uint8_t )((int )y >> 8);
#line 199
  __cil_tmp19 = write(gif->fd, (uint8_t *)tmp___0, (size_t )2);
#line 199
  res = __cil_tmp19;
  }
#line 199
  if (res == -1L) {
    {
#line 199
    fprintf(stderr, "Cannot write to GIF\n\324U");
    }
#line 199
    return;
  }
  {
#line 200
  tmp___1[0] = (uint8_t )((int )w & 255);
#line 200
  tmp___1[1] = (uint8_t )((int )w >> 8);
#line 200
  __cil_tmp21 = write(gif->fd, (uint8_t *)tmp___1, (size_t )2);
#line 200
  res = __cil_tmp21;
  }
#line 200
  if (res == -1L) {
    {
#line 200
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 200
    return;
  }
  {
#line 201
  tmp___2[0] = (uint8_t )((int )h & 255);
#line 201
  tmp___2[1] = (uint8_t )((int )h >> 8);
#line 201
  __cil_tmp23 = write(gif->fd, (uint8_t *)tmp___2, (size_t )2);
#line 201
  res = __cil_tmp23;
  }
#line 201
  if (res == -1L) {
    {
#line 201
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 201
    return;
  }
  {
#line 202
  tmp___3[0] = (uint8_t )0;
#line 202
  tmp___3[1] = (uint8_t )gif->depth;
#line 202
  __cil_tmp25 = write(gif->fd, (uint8_t *)tmp___3, (size_t )2);
#line 202
  res = __cil_tmp25;
  }
#line 202
  if (res == -1L) {
    {
#line 202
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 202
    return;
  }
  {
#line 203
  root = new_trie(degree, & nkeys);
#line 204
  key_size = gif->depth + 1;
#line 205
  put_key(gif, (uint16_t )degree, key_size);
#line 206
  i = (int )y;
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < (int )y + (int )h)) {
#line 206
      goto while_break;
    }
#line 207
    j = (int )x;
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 207
      if (! (j < (int )x + (int )w)) {
#line 207
        goto while_break___0;
      }
#line 208
      pixel = (uint8_t )((int )*(gif->frame + (i * (int )gif->w + j)) & (degree - 1));
#line 209
      child = node->children[pixel];
#line 210
      if (child) {
#line 211
        node = child;
      } else {
        {
#line 213
        put_key(gif, node->key, key_size);
        }
#line 214
        if (nkeys < 4096) {
#line 215
          if (nkeys == 1 << key_size) {
#line 216
            key_size ++;
          }
          {
#line 217
          __cil_tmp29 = nkeys;
#line 217
          nkeys ++;
#line 217
          __cil_tmp30 = new_node((uint16_t )__cil_tmp29, degree);
#line 217
          node->children[pixel] = __cil_tmp30;
          }
        } else {
          {
#line 219
          put_key(gif, (uint16_t )degree, key_size);
#line 220
          del_trie(root, degree);
#line 221
          root = new_trie(degree, & nkeys);
#line 222
          key_size = gif->depth + 1;
          }
        }
#line 224
        node = root->children[pixel];
      }
#line 207
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  put_key(gif, node->key, key_size);
#line 229
  put_key(gif, (uint16_t )(degree + 1), key_size);
#line 230
  end_key(gif);
#line 231
  del_trie(root, degree);
  }
  return;
}
}
#line 235 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static int get_bbox(ge_GIF *gif , uint16_t *w , uint16_t *h , uint16_t *x , uint16_t *y ) 
{ 
  int i ;
  int j ;
  int k ;
  int left ;
  int right ;
  int top ;
  int bottom ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 239
  left = (int )gif->w;
#line 239
  right = 0;
#line 240
  top = (int )gif->h;
#line 240
  bottom = 0;
#line 241
  k = 0;
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < (int )gif->h)) {
#line 242
      goto while_break;
    }
#line 243
    j = 0;
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! (j < (int )gif->w)) {
#line 243
        goto while_break___0;
      }
#line 244
      if ((int )*(gif->frame + k) != (int )*(gif->back + k)) {
#line 245
        if (j < left) {
#line 245
          left = j;
        }
#line 246
        if (j > right) {
#line 246
          right = j;
        }
#line 247
        if (i < top) {
#line 247
          top = i;
        }
#line 248
        if (i > bottom) {
#line 248
          bottom = i;
        }
      }
#line 243
      __cil_tmp14 = k;
#line 243
      k ++;
#line 243
      __cil_tmp13 = j;
#line 243
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 242
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (left != (int )gif->w) {
#line 252
    if (top != (int )gif->h) {
#line 253
      *x = (uint16_t )left;
#line 253
      *y = (uint16_t )top;
#line 254
      *w = (uint16_t )((right - left) + 1);
#line 255
      *h = (uint16_t )((bottom - top) + 1);
#line 256
      return (1);
    } else {
#line 258
      return (0);
    }
  } else {
#line 258
    return (0);
  }
}
}
#line 271 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
static void set_delay(ge_GIF *gif , uint16_t d ) 
{ 
  ssize_t res ;
  uint8_t tmp[4] ;
  ssize_t __cil_tmp5 ;
  uint8_t tmp___0[2] ;
  ssize_t __cil_tmp7 ;
  ssize_t __cil_tmp8 ;

  {
  {
#line 275
  tmp[0] = (uint8_t )'!';
#line 275
  tmp[1] = (uint8_t )249;
#line 275
  tmp[2] = (uint8_t )4;
#line 275
  tmp[3] = (uint8_t )4;
#line 275
  __cil_tmp5 = write(gif->fd, (uint8_t *)tmp, (size_t )4);
#line 275
  res = __cil_tmp5;
  }
#line 275
  if (res == -1L) {
    {
#line 275
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 275
    return;
  }
  {
#line 276
  tmp___0[0] = (uint8_t )((int )d & 255);
#line 276
  tmp___0[1] = (uint8_t )((int )d >> 8);
#line 276
  __cil_tmp7 = write(gif->fd, (uint8_t *)tmp___0, (size_t )2);
#line 276
  res = __cil_tmp7;
  }
#line 276
  if (res == -1L) {
    {
#line 276
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 276
    return;
  }
  {
#line 277
  res = write(gif->fd, "", (size_t )2);
  }
#line 277
  if (res == -1L) {
    {
#line 277
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 277
    return;
  }

  return;
}
}
#line 281 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
void ge_add_frame(ge_GIF *gif , uint16_t delay ) 
{ 
  uint16_t w ;
  uint16_t h ;
  uint16_t x ;
  uint16_t y ;
  uint8_t *tmp ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 286
  if (delay) {
    {
#line 287
    set_delay(gif, delay);
    }
  }
#line 288
  if (gif->nframes == 0) {
#line 289
    w = gif->w;
#line 290
    h = gif->h;
#line 291
    y = (uint16_t )0;
#line 291
    x = y;
  } else {
    {
#line 292
    __cil_tmp8 = get_bbox(gif, & w, & h, & x, & y);
    }
#line 292
    if (! __cil_tmp8) {
#line 294
      h = (uint16_t )1;
#line 294
      w = h;
#line 295
      y = (uint16_t )0;
#line 295
      x = y;
    }
  }
  {
#line 297
  put_image(gif, w, h, x, y);
#line 298
  (gif->nframes) ++;
#line 299
  tmp = gif->back;
#line 300
  gif->back = gif->frame;
#line 301
  gif->frame = tmp;
  }
  return;
}
}
#line 305 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/gifenc.c"
void ge_close_gif(ge_GIF *gif ) 
{ 
  ssize_t res ;
  ssize_t __cil_tmp3 ;

  {
  {
#line 309
  res = write(gif->fd, ";\020", (size_t )1);
  }
#line 309
  if (res == -1L) {
    {
#line 309
    fprintf(stderr, "Cannot write to GIF\n");
    }
#line 309
    return;
  }
  {
#line 310
  close(gif->fd);
#line 311
  free(gif);
  }
  return;
}
}
#line 28 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/get_fname.h"
char const   *savedir ;
#line 29
char const   *datadir ;
#line 30
char const   *exportdir ;
#line 41
char *get_fname(char const   *name , int kind ) ;
#line 86 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/get_fname.c"
char *get_fname(char const   *name , int kind ) 
{ 
  char f[512] ;
  char const   *dir ;
  int tmp ;
  int len ;
  int i ;
  int stop ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 92
  if (kind == 0) {
#line 93
    dir = savedir;
  } else
#line 94
  if (kind == 1) {
#line 95
    dir = datadir;
  } else
#line 96
  if (kind == 2) {
#line 97
    dir = exportdir;
  } else
#line 96
  if (kind == 3) {
#line 97
    dir = exportdir;
  }
#line 100
  if ((int )*name) {
#line 100
    tmp = '/';
  } else {
#line 100
    tmp = '\000';
  }
  {
#line 100
  snprintf((char *)f, sizeof(f), "%s%c%s", dir, tmp, name);
  }
#line 105
  if (kind == 3) {
    {
#line 108
    stop = - 1;
#line 109
    __cil_tmp9 = strlen((char const   *)((char *)f));
#line 109
    len = (int )__cil_tmp9;
#line 110
    i = len - 1;
    }
    {
#line 110
    while (1) {
      while_continue: /* CIL Label */ ;
#line 110
      if (! (i >= 0 && stop == -1)) {
#line 110
        goto while_break;
      }
#line 111
      if ((int )f[i] == 47) {
#line 112
        stop = i;
      }
#line 110
      __cil_tmp10 = i;
#line 110
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 114
    if (stop != -1) {
#line 115
      f[stop] = (char )'\000';
    }
  }
  {
#line 119
  __cil_tmp11 = strdup((char const   *)((char *)f));
  }
#line 119
  return (__cil_tmp11);
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 125
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 141
extern  __attribute__((__nothrow__)) locale_t newlocale(int __category_mask , char const   *__locale ,
                                                        locale_t __base ) ;
#line 176
extern  __attribute__((__nothrow__)) locale_t duplocale(locale_t __dataset ) ;
#line 180
extern  __attribute__((__nothrow__)) void freelocale(locale_t __dataset ) ;
#line 187
extern  __attribute__((__nothrow__)) locale_t uselocale(locale_t __dataset ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid ) ;
#line 44
extern  __attribute__((__nothrow__)) char *dgettext(char const   *__domainname , char const   *__msgid ) ;
#line 46
extern  __attribute__((__nothrow__)) char *__dgettext(char const   *__domainname ,
                                                      char const   *__msgid ) ;
#line 51
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category ) ;
#line 54
extern  __attribute__((__nothrow__)) char *__dcgettext(char const   *__domainname ,
                                                       char const   *__msgid , int __category ) ;
#line 61
extern  __attribute__((__nothrow__)) char *ngettext(char const   *__msgid1 , char const   *__msgid2 ,
                                                    unsigned long __n ) ;
#line 67
extern  __attribute__((__nothrow__)) char *dngettext(char const   *__domainname ,
                                                     char const   *__msgid1 , char const   *__msgid2 ,
                                                     unsigned long __n ) ;
#line 73
extern  __attribute__((__nothrow__)) char *dcngettext(char const   *__domainname ,
                                                      char const   *__msgid1 , char const   *__msgid2 ,
                                                      unsigned long __n , int __category ) ;
#line 82
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 91
extern  __attribute__((__nothrow__)) char *bind_textdomain_codeset(char const   *__domainname ,
                                                                   char const   *__codeset ) ;
#line 240 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int stat64(char const   *__file , struct stat64 *__buf ) ;
#line 242
extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__buf ) ;
#line 291
extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__file ,
                                                   struct stat64 *__buf , int __flag ) ;
#line 338
extern  __attribute__((__nothrow__)) int lstat64(char const   *__file , struct stat64 *__buf ) ;
#line 385
extern  __attribute__((__nothrow__)) __mode_t getumask(void) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h"
 __attribute__((__nothrow__)) int statx(int __dirfd , char const   *__path , int __flags ,
                                        unsigned int __mask , struct statx *__buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int closedir(DIR *__dirp ) ;
#line 162
extern struct dirent *readdir(DIR *__dirp ) ;
#line 173
extern struct dirent64 *readdir64(DIR *__dirp ) ;
#line 183
extern int readdir_r(DIR *__dirp , struct dirent *__entry , struct dirent **__result ) ;
#line 201
extern int readdir64_r(DIR *__dirp , struct dirent64 *__entry , struct dirent64 **__result ) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp ) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos ) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp ) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h"
extern  __attribute__((__nothrow__)) long __sysconf(int __name ) ;
#line 255 "/usr/include/dirent.h"
extern int scandir(char const   *__dir , struct dirent ***__namelist , int (*__selector)(struct dirent * ) ,
                   int (*__cmp)(struct dirent ** , struct dirent ** ) ) ;
#line 278
extern int scandir64(char const   *__dir , struct dirent64 ***__namelist , int (*__selector)(struct dirent64 * ) ,
                     int (*__cmp)(struct dirent64 ** , struct dirent64 ** ) ) ;
#line 293
extern int scandirat(int __dfd , char const   *__dir , struct dirent ***__namelist ,
                     int (*__selector)(struct dirent * ) , int (*__cmp)(struct dirent ** ,
                                                                        struct dirent ** ) ) ;
#line 315
extern int scandirat64(int __dfd , char const   *__dir , struct dirent64 ***__namelist ,
                       int (*__selector)(struct dirent64 * ) , int (*__cmp)(struct dirent64 ** ,
                                                                            struct dirent64 ** ) ) ;
#line 325
extern  __attribute__((__nothrow__)) int alphasort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 340
extern  __attribute__((__nothrow__)) int alphasort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 353
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char *__buf ,
                                                             size_t __nbytes , __off_t *__basep ) ;
#line 370
extern  __attribute__((__nothrow__)) __ssize_t getdirentries64(int __fd , char *__buf ,
                                                               size_t __nbytes , __off64_t *__basep ) ;
#line 380
extern  __attribute__((__nothrow__)) int versionsort(struct dirent **__e1 , struct dirent **__e2 ) ;
#line 396
extern  __attribute__((__nothrow__)) int versionsort64(struct dirent64 **__e1 , struct dirent64 **__e2 ) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h"
extern  __attribute__((__nothrow__)) __ssize_t getdents64(int __fd , void *__buffer ,
                                                          size_t __length ) ;
#line 64 "/usr/include/SDL/SDL_ttf.h"
extern SDL_version *TTF_Linked_Version(void) ;
#line 74
extern void TTF_ByteSwappedUNICODE(int swapped ) ;
#line 80
extern int TTF_Init(void) ;
#line 86
extern TTF_Font *TTF_OpenFont(char const   *file , int ptsize ) ;
#line 87
extern TTF_Font *TTF_OpenFontIndex(char const   *file , int ptsize , long index ) ;
#line 88
extern TTF_Font *TTF_OpenFontRW(SDL_RWops *src , int freesrc , int ptsize ) ;
#line 89
extern TTF_Font *TTF_OpenFontIndexRW(SDL_RWops *src , int freesrc , int ptsize , long index ) ;
#line 97
extern int TTF_GetFontStyle(TTF_Font *font ) ;
#line 98
extern void TTF_SetFontStyle(TTF_Font *font , int style ) ;
#line 99
extern int TTF_GetFontOutline(TTF_Font *font ) ;
#line 100
extern void TTF_SetFontOutline(TTF_Font *font , int outline ) ;
#line 107
extern int TTF_GetFontHinting(TTF_Font *font ) ;
#line 108
extern void TTF_SetFontHinting(TTF_Font *font , int hinting ) ;
#line 111
extern int TTF_FontHeight(TTF_Font *font ) ;
#line 116
extern int TTF_FontAscent(TTF_Font *font ) ;
#line 121
extern int TTF_FontDescent(TTF_Font *font ) ;
#line 124
extern int TTF_FontLineSkip(TTF_Font *font ) ;
#line 127
extern int TTF_GetFontKerning(TTF_Font *font ) ;
#line 128
extern void TTF_SetFontKerning(TTF_Font *font , int allowed ) ;
#line 131
extern long TTF_FontFaces(TTF_Font *font ) ;
#line 134
extern int TTF_FontFaceIsFixedWidth(TTF_Font *font ) ;
#line 135
extern char *TTF_FontFaceFamilyName(TTF_Font *font ) ;
#line 136
extern char *TTF_FontFaceStyleName(TTF_Font *font ) ;
#line 139
extern int TTF_GlyphIsProvided(TTF_Font *font , Uint16 ch ) ;
#line 145
extern int TTF_GlyphMetrics(TTF_Font *font , Uint16 ch , int *minx , int *maxx , int *miny ,
                            int *maxy , int *advance ) ;
#line 150
extern int TTF_SizeText(TTF_Font *font , char const   *text , int *w , int *h ) ;
#line 151
extern int TTF_SizeUTF8(TTF_Font *font , char const   *text , int *w , int *h ) ;
#line 152
extern int TTF_SizeUNICODE(TTF_Font *font , Uint16 *text , int *w , int *h ) ;
#line 160
extern SDL_Surface *TTF_RenderText_Solid(TTF_Font *font , char const   *text , SDL_Color fg ) ;
#line 162
extern SDL_Surface *TTF_RenderUTF8_Solid(TTF_Font *font , char const   *text , SDL_Color fg ) ;
#line 164
extern SDL_Surface *TTF_RenderUNICODE_Solid(TTF_Font *font , Uint16 *text , SDL_Color fg ) ;
#line 174
extern SDL_Surface *TTF_RenderGlyph_Solid(TTF_Font *font , Uint16 ch , SDL_Color fg ) ;
#line 182
extern SDL_Surface *TTF_RenderText_Shaded(TTF_Font *font , char const   *text , SDL_Color fg ,
                                          SDL_Color bg ) ;
#line 184
extern SDL_Surface *TTF_RenderUTF8_Shaded(TTF_Font *font , char const   *text , SDL_Color fg ,
                                          SDL_Color bg ) ;
#line 186
extern SDL_Surface *TTF_RenderUNICODE_Shaded(TTF_Font *font , Uint16 *text , SDL_Color fg ,
                                             SDL_Color bg ) ;
#line 196
extern SDL_Surface *TTF_RenderGlyph_Shaded(TTF_Font *font , Uint16 ch , SDL_Color fg ,
                                           SDL_Color bg ) ;
#line 203
extern SDL_Surface *TTF_RenderText_Blended(TTF_Font *font , char const   *text , SDL_Color fg ) ;
#line 205
extern SDL_Surface *TTF_RenderUTF8_Blended(TTF_Font *font , char const   *text , SDL_Color fg ) ;
#line 207
extern SDL_Surface *TTF_RenderUNICODE_Blended(TTF_Font *font , Uint16 *text , SDL_Color fg ) ;
#line 216
extern SDL_Surface *TTF_RenderGlyph_Blended(TTF_Font *font , Uint16 ch , SDL_Color fg ) ;
#line 228
extern void TTF_CloseFont(TTF_Font *font ) ;
#line 231
extern void TTF_Quit(void) ;
#line 234
extern int TTF_WasInit(void) ;
#line 237
extern int TTF_GetFontKerningSize(TTF_Font *font , int prev_index , int index ) ;
#line 48 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.h"
void loadfont_callback(SDL_Surface *screen___0 , char const   *dir , unsigned int dirlen ,
                       tp_ftw_str *files , unsigned int i , char const   *locale ) ;
#line 50
int compare_ftw_str(void const   *v1 , void const   *v2 ) ;
#line 51
void tp_ftw(SDL_Surface *screen___0 , char *dir , unsigned int dirlen , int rsrc ,
            void (*fn)(SDL_Surface * , char const   * const   , unsigned int  , tp_ftw_str * ,
                       unsigned int  , char const   * const   ) , char const   *locale ) ;
#line 36 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/progressbar.h"
SDL_Surface *img_progress ;
#line 37
int progress_bar_disabled ;
#line 37
int prog_bar_ctr ;
#line 39
void show_progress_bar(SDL_Surface *screen___0 ) ;
#line 53 "/usr/include/SDL_Pango.h"
extern SDLPango_Matrix *MATRIX_WHITE_BACK1 ;
#line 57
extern SDLPango_Matrix *MATRIX_BLACK_BACK1 ;
#line 61
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_BLACK_LETTER1 ;
#line 65
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_WHITE_LETTER1 ;
#line 70
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_TRANSPARENT_LETTER1 ;
#line 92
extern int SDLPango_Init() ;
#line 94
extern int SDLPango_WasInit() ;
#line 96
extern SDLPango_Context *SDLPango_CreateContext_GivenFontDesc(char const   *font_desc ) ;
#line 97
extern SDLPango_Context *SDLPango_CreateContext() ;
#line 99
extern void SDLPango_FreeContext(SDLPango_Context *context ) ;
#line 102
extern void SDLPango_SetSurfaceCreateArgs(SDLPango_Context *context , Uint32 flags ,
                                          int depth , Uint32 Rmask , Uint32 Gmask ,
                                          Uint32 Bmask , Uint32 Amask ) ;
#line 108
extern SDL_Surface *SDLPango_CreateSurfaceDraw(SDLPango_Context *context ) ;
#line 111
extern void SDLPango_Draw(SDLPango_Context *context , SDL_Surface *surface , int x ,
                          int y ) ;
#line 116
extern void SDLPango_SetDpi(SDLPango_Context *context , double dpi_x , double dpi_y ) ;
#line 120
extern void SDLPango_SetMinimumSize(SDLPango_Context *context , int width , int height ) ;
#line 124
extern void SDLPango_SetDefaultColor(SDLPango_Context *context , SDLPango_Matrix *color_matrix ) ;
#line 128
extern int SDLPango_GetLayoutWidth(SDLPango_Context *context ) ;
#line 131
extern int SDLPango_GetLayoutHeight(SDLPango_Context *context ) ;
#line 134
extern void SDLPango_SetMarkup(SDLPango_Context *context , char const   *markup ,
                               int length ) ;
#line 139
extern void SDLPango_SetText_GivenAlignment(SDLPango_Context *context , char const   *text ,
                                            int length , SDLPango_Alignment alignment ) ;
#line 145
extern void SDLPango_SetText(SDLPango_Context *context , char const   *markup , int length ) ;
#line 150
extern void SDLPango_SetLanguage(SDLPango_Context *context , char const   *language_tag ) ;
#line 154
extern void SDLPango_SetBaseDirection(SDLPango_Context *context , SDLPango_Direction direction ) ;
#line 74 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
extern SDL_Thread *font_thread ;
#line 76
long font_thread_done ;
#line 77
long font_thread_aborted ;
#line 78
long waiting_for_fonts ;
#line 79
int font_socket_fd ;
#line 81
int no_system_fonts ;
#line 82
int all_locale_fonts ;
#line 113
int TuxPaint_Font_FontHeight(TuxPaint_Font *tpf ) ;
#line 117
void reliable_write(int fd , void const   *buf , size_t count ) ;
#line 118
void run_font_scanner(SDL_Surface *screen___0 , char const   *locale ) ;
#line 119
void receive_some_font_info(SDL_Surface *screen___0 ) ;
#line 132
int text_state ;
#line 133
unsigned int text_size ;
#line 138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
static int text_sizes[12]  = 
#line 138
  {      9,      12,      18,      24, 
        36,      48,      56,      64, 
        96,      112,      128,      160};
#line 172
TuxPaint_Font *medium_font ;
#line 172
TuxPaint_Font *small_font ;
#line 172
TuxPaint_Font *large_font ;
#line 172
TuxPaint_Font *locale_font ;
#line 174
family_info **user_font_families ;
#line 175
int num_font_families ;
#line 177
style_info **user_font_styles ;
#line 178
int num_font_styles ;
#line 179
int num_font_styles_max ;
#line 181
int button_label_y_nudge ;
#line 183
TuxPaint_Font *getfonthandle(int desire ) ;
#line 185
int charset_works(TuxPaint_Font *font , char const   *s ) ;
#line 187
TuxPaint_Font *TuxPaint_Font_OpenFont(char const   *pangodesc , char const   *ttffilename ,
                                      int size ) ;
#line 188
void TuxPaint_Font_CloseFont(TuxPaint_Font *tpf ) ;
#line 189
char const   *TuxPaint_Font_FontFaceFamilyName(TuxPaint_Font *tpf ) ;
#line 190
char const   *TuxPaint_Font_FontFaceStyleName(TuxPaint_Font *tpf ) ;
#line 195
void sdl_color_to_pango_color(SDL_Color sdl_color , SDLPango_Matrix *pango_color ) ;
#line 198
int load_user_fonts(SDL_Surface *screen___0 , void *vp , char const   *locale ) ;
#line 79 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.c"
void loadfont_callback(SDL_Surface *screen___0 , char const   *dir , unsigned int dirlen ,
                       tp_ftw_str *files , unsigned int i , char const   *locale ) 
{ 
  unsigned int __cil_tmp7 ;
  int loadable ;
  char const   *cp ;
  char *__cil_tmp10 ;
  char const   * const  suffixes[6] ;
  int j ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char fname[512] ;
  TuxPaint_Font *font ;
  char *__cil_tmp19 ;
  char fname_check[512] ;
  int __cil_tmp21 ;
  TuxPaint_Font *__cil_tmp22 ;
  TuxPaint_Font *__cil_tmp23 ;
  char const   *family ;
  char const   *__cil_tmp25 ;
  char const   *style ;
  char const   *__cil_tmp27 ;
  int blacklisted ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  int __cil_tmp32 ;
  char *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  int __cil_tmp41 ;
  char *__cil_tmp42 ;
  int __cil_tmp43 ;
  char *__cil_tmp44 ;
  int __cil_tmp45 ;
  char *__cil_tmp46 ;
  int __cil_tmp47 ;
  char *__cil_tmp48 ;
  int __cil_tmp49 ;
  char *__cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;

  {
#line 82
  dirlen = dirlen;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    __cil_tmp7 = i;
#line 84
    i --;
#line 84
    if (! __cil_tmp7) {
#line 84
      goto while_break;
    }
    {
#line 86
    loadable = 0;
#line 87
    __cil_tmp10 = strchr((char const   *)(files + i)->str, '.');
#line 87
    cp = (char const   *)__cil_tmp10;
#line 89
    show_progress_bar(screen___0);
    }
#line 90
    if (cp) {
#line 93
      suffixes[0] = "ttc";
#line 93
      suffixes[1] = "dfont";
#line 93
      suffixes[2] = "pfa";
#line 93
      suffixes[3] = "pfb";
#line 93
      suffixes[4] = "otf";
#line 93
      suffixes[5] = "ttf";
#line 95
      j = (int )(sizeof(suffixes) / sizeof(suffixes[0]));
      {
#line 97
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 97
        __cil_tmp13 = j;
#line 97
        j --;
#line 97
        if (! __cil_tmp13) {
#line 97
          goto while_break___0;
        }
        {
#line 100
        __cil_tmp14 = strlen(suffixes[j]);
#line 100
        __cil_tmp15 = strncasecmp(cp + 1, suffixes[j], __cil_tmp14);
        }
#line 100
        if (! __cil_tmp15) {
#line 102
          loadable = 1;
#line 103
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 107
    if (! loadable) {
      {
#line 109
      __cil_tmp16 = strcasestr((char const   *)(files + i)->str, "/rsrc");
      }
#line 109
      if (__cil_tmp16) {
#line 110
        loadable = 1;
      }
    }
#line 116
    if (loadable) {
      {
#line 121
      snprintf((char *)fname, sizeof(fname), "%s/%s", dir, (files + i)->str);
#line 126
      __cil_tmp19 = strstr((char const   *)((char *)fname), "locale");
      }
#line 126
      if (locale) {
#line 126
        if (__cil_tmp19) {
#line 126
          if (! all_locale_fonts) {
            {
#line 131
            snprintf((char *)fname_check, sizeof(fname_check), "%s/%s.ttf", dir, locale);
#line 135
            __cil_tmp21 = strcmp((char const   *)((char *)fname), (char const   *)((char *)fname_check));
            }
#line 135
            if (__cil_tmp21 == 0) {
              {
#line 136
              font = TuxPaint_Font_OpenFont("\230\001", (char const   *)((char *)fname),
                                            text_sizes[text_size]);
              }
            } else {
#line 138
              font = (TuxPaint_Font *)((void *)0);
            }
          } else {
            {
            {
            {
#line 142
            font = TuxPaint_Font_OpenFont("\230\001", (char const   *)((char *)fname),
                                          text_sizes[text_size]);
            }
            }
            }
          }
        } else {
          {
          {
          {
#line 142
          font = TuxPaint_Font_OpenFont("\230\001", (char const   *)((char *)fname),
                                        text_sizes[text_size]);
          }
          }
          }
        }
      } else {
        {
        {
        {
#line 142
        font = TuxPaint_Font_OpenFont("\230\001", (char const   *)((char *)fname),
                                      text_sizes[text_size]);
        }
        }
        }
      }
#line 144
      if (font) {
        {
#line 146
        __cil_tmp25 = TuxPaint_Font_FontFaceFamilyName(font);
#line 146
        family = __cil_tmp25;
#line 147
        __cil_tmp27 = TuxPaint_Font_FontFaceStyleName(font);
#line 147
        style = __cil_tmp27;
#line 167
        __cil_tmp30 = strcmp("Elvish Ring NFI", family);
        }
        {
#line 167
        __cil_tmp29 = strcmp("Zapfino", family);
#line 167
        blacklisted = ! __cil_tmp29 || ! __cil_tmp30;
#line 188
        __cil_tmp33 = dcgettext((char const   *)((void *)0), "QX", 5);
#line 188
        __cil_tmp34 = charset_works(font, (char const   *)__cil_tmp33);
        }
        {
#line 188
        __cil_tmp31 = dcgettext((char const   *)((void *)0), "qx", 5);
#line 188
        __cil_tmp32 = charset_works(font, (char const   *)__cil_tmp31);
        }
#line 188
        if (! __cil_tmp32) {
#line 189
          blacklisted = 1;
        } else
#line 188
        if (! __cil_tmp34) {
#line 189
          blacklisted = 1;
        }
#line 191
        if (! blacklisted) {
#line 193
          if (num_font_styles == num_font_styles_max) {
            {
#line 195
            num_font_styles_max = (num_font_styles_max * 5) / 4 + 30;
#line 196
            user_font_styles = (style_info **)realloc(user_font_styles, (unsigned long )num_font_styles_max * sizeof(*user_font_styles));
            }
          }
          {
#line 198
          *(user_font_styles + num_font_styles) = (style_info *)malloc(sizeof(*(*(user_font_styles + num_font_styles))));
#line 199
          (*(user_font_styles + num_font_styles))->directory = strdup(dir);
#line 200
          (*(user_font_styles + num_font_styles))->filename = (files + i)->str;
#line 201
          (*(user_font_styles + num_font_styles))->family = strdup(family);
#line 202
          (*(user_font_styles + num_font_styles))->style = strdup(style);
#line 203
          (*(user_font_styles + num_font_styles))->score = 0;
#line 213
          __cil_tmp40 = dcgettext((char const   *)((void *)0), "oO", 5);
#line 213
          __cil_tmp41 = charset_works(font, (char const   *)__cil_tmp40);
          }
          {
#line 213
          (*(user_font_styles + num_font_styles))->score += __cil_tmp41;
#line 216
          __cil_tmp42 = dcgettext((char const   *)((void *)0), ",.?!", 5);
#line 216
          __cil_tmp43 = charset_works(font, (char const   *)__cil_tmp42);
          }
          {
#line 216
          (*(user_font_styles + num_font_styles))->score += __cil_tmp43;
#line 219
          __cil_tmp44 = dcgettext((char const   *)((void *)0), "`%_@$~#{<(^&*", 5);
#line 219
          __cil_tmp45 = charset_works(font, (char const   *)__cil_tmp44);
          }
          {
#line 219
          (*(user_font_styles + num_font_styles))->score += __cil_tmp45;
#line 222
          __cil_tmp46 = dcgettext((char const   *)((void *)0), "017", 5);
#line 222
          __cil_tmp47 = charset_works(font, (char const   *)__cil_tmp46);
          }
          {
#line 222
          (*(user_font_styles + num_font_styles))->score += __cil_tmp47;
#line 225
          __cil_tmp48 = dcgettext((char const   *)((void *)0), "O0", 5);
#line 225
          __cil_tmp49 = charset_works(font, (char const   *)__cil_tmp48);
          }
          {
#line 225
          (*(user_font_styles + num_font_styles))->score += __cil_tmp49;
#line 228
          __cil_tmp50 = dcgettext((char const   *)((void *)0), "1Il|", 5);
#line 228
          __cil_tmp51 = charset_works(font, (char const   *)__cil_tmp50);
          }
#line 228
          (*(user_font_styles + num_font_styles))->score += __cil_tmp51;
#line 246
          num_font_styles ++;
#line 248
          (files + i)->str = (char *)((void *)0);
        }
        {
#line 256
        TuxPaint_Font_CloseFont(font);
        }
      }
    }
    {
#line 265
    free((files + i)->str);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  free(files);
  }
  return;
}
}
#line 280 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.c"
int compare_ftw_str(void const   *v1 , void const   *v2 ) 
{ 
  char const   *s1 ;
  char const   *s2 ;
  int __cil_tmp5 ;

  {
  {
#line 282
  s1 = (char const   *)((tp_ftw_str *)v1)->str;
#line 283
  s2 = (char const   *)((tp_ftw_str *)v2)->str;
#line 285
  __cil_tmp5 = strcmp(s1, s2);
  }
#line 285
  return (- __cil_tmp5);
}
}
#line 301 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/dirwalk.c"
void tp_ftw(SDL_Surface *screen___0 , char *dir , unsigned int dirlen , int rsrc ,
            void (*fn)(SDL_Surface * , char const   * const   , unsigned int  , tp_ftw_str * ,
                       unsigned int  , char const   * const   ) , char const   *locale ) 
{ 
  DIR *d ;
  unsigned int num_file_names ;
  unsigned int max_file_names ;
  tp_ftw_str *file_names ;
  unsigned int num_dir_names ;
  unsigned int max_dir_names ;
  tp_ftw_str *dir_names ;
  int d_namlen ;
  int add_rsrc ;
  unsigned int __cil_tmp16 ;
  DIR *__cil_tmp17 ;
  struct dirent *f ;
  struct dirent *__cil_tmp19 ;
  int filetype ;
  unsigned long __cil_tmp21 ;
  struct stat sbuf ;
  int __cil_tmp23 ;
  char *cp ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  unsigned int __cil_tmp27 ;
  char *cp___0 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;
  unsigned int __cil_tmp32 ;

  {
  {
#line 308
  num_file_names = (unsigned int )0;
#line 309
  max_file_names = (unsigned int )0;
#line 310
  file_names = (tp_ftw_str *)((void *)0);
#line 311
  num_dir_names = (unsigned int )0;
#line 312
  max_dir_names = (unsigned int )0;
#line 313
  dir_names = (tp_ftw_str *)((void *)0);
#line 317
  __cil_tmp16 = dirlen;
#line 317
  dirlen ++;
#line 317
  *(dir + __cil_tmp16) = (char )'/';
#line 318
  *(dir + dirlen) = (char )'\000';
#line 321
  d = opendir((char const   *)dir);
  }
#line 322
  if (! d) {
#line 323
    return;
  }
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! 1) {
#line 325
      goto while_break;
    }
    {
#line 327
    __cil_tmp19 = readdir(d);
#line 327
    f = __cil_tmp19;
#line 328
    filetype = 1;
    }
#line 330
    if (! f) {
#line 331
      goto while_break;
    }
#line 332
    if ((int )f->d_name[0] == 46) {
#line 333
      goto while_continue;
    }
    {
#line 340
    if ((int )f->d_type == 8) {
#line 340
      goto case_8;
    }
#line 344
    if ((int )f->d_type == 4) {
#line 344
      goto case_4;
    }
#line 348
    if ((int )f->d_type == 10) {
#line 348
      goto case_10;
    }
#line 348
    if ((int )f->d_type == 0) {
#line 348
      goto case_10;
    }
#line 338
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 339
    goto while_continue;
    case_8: /* CIL Label */ 
#line 341
    if (! rsrc) {
#line 342
      filetype = 0;
    }
#line 343
    goto switch_break;
    case_4: /* CIL Label */ 
#line 345
    filetype = 2;
#line 346
    goto switch_break;
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
    {
#line 358
    __cil_tmp21 = strlen((char const   *)((char *)f->d_name));
#line 358
    d_namlen = (int )__cil_tmp21;
#line 360
    add_rsrc = 0;
    }
#line 362
    if (filetype == 1) {
      {
#line 366
      memcpy(dir + dirlen, (char *)f->d_name, (unsigned long )(d_namlen + 1));
#line 367
      __cil_tmp23 = stat((char const   *)dir, & sbuf);
      }
#line 367
      if (__cil_tmp23) {
#line 368
        goto while_continue;
      }
#line 369
      if ((sbuf.st_mode & 61440U) == 16384U) {
#line 370
        filetype = 2;
      } else
#line 371
      if ((sbuf.st_mode & 61440U) == 32768U) {
#line 373
        filetype = 0;
#line 374
        if (rsrc) {
#line 374
          if (! sbuf.st_size) {
#line 375
            add_rsrc = 5;
          }
        }
      } else {
#line 378
        goto while_continue;
      }
    }
#line 380
    if (filetype == 0) {
#line 384
      if (num_file_names == max_file_names) {
        {
#line 386
        max_file_names = (max_file_names * 5U) / 4U + 30U;
#line 387
        file_names = (tp_ftw_str *)realloc(file_names, (unsigned long )max_file_names * sizeof(*file_names));
        }
      }
      {
#line 389
      cp = (char *)malloc((unsigned long )((d_namlen + add_rsrc) + 1));
#line 390
      memcpy(cp, (char *)f->d_name, (unsigned long )d_namlen);
      }
#line 391
      if (add_rsrc) {
        {
#line 392
        memcpy(cp + d_namlen, "/rsrc", (unsigned long )6);
        }
      } else {
#line 394
        *(cp + d_namlen) = (char )'\000';
      }
#line 395
      (file_names + num_file_names)->str = cp;
#line 396
      (file_names + num_file_names)->len = (unsigned char )d_namlen;
#line 397
      num_file_names ++;
    }
#line 399
    if (filetype == 2) {
#line 403
      if (num_dir_names == max_dir_names) {
        {
#line 405
        max_dir_names = (max_dir_names * 5U) / 4U + 3U;
#line 406
        dir_names = (tp_ftw_str *)realloc(dir_names, (unsigned long )max_dir_names * sizeof(*dir_names));
        }
      }
      {
#line 408
      cp___0 = (char *)malloc((unsigned long )(d_namlen + 1));
#line 409
      memcpy(cp___0, (char *)f->d_name, (unsigned long )(d_namlen + 1));
#line 410
      (dir_names + num_dir_names)->str = cp___0;
#line 411
      (dir_names + num_dir_names)->len = (unsigned char )d_namlen;
#line 412
      num_dir_names ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  closedir(d);
#line 417
  show_progress_bar(screen___0);
#line 418
  *(dir + dirlen) = (char )'\000';
  }
#line 420
  if (file_names) {
    {
    {
#line 431
    (*fn)(screen___0, (char const   *)dir, dirlen, file_names, num_file_names, locale);
    }
    }
  } else
#line 420
  if (1) {
    {
    {
#line 431
    (*fn)(screen___0, (char const   *)dir, dirlen, file_names, num_file_names, locale);
    }
    }
  }
#line 435
  if (dir_names) {
    {
#line 437
    qsort(dir_names, (size_t )num_dir_names, sizeof(*dir_names), & compare_ftw_str);
    }
    {
#line 438
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 438
      __cil_tmp32 = num_dir_names;
#line 438
      num_dir_names --;
#line 438
      if (! __cil_tmp32) {
#line 438
        goto while_break___0;
      }
      {
#line 440
      memcpy(dir + dirlen, (dir_names + num_dir_names)->str, (unsigned long )((int )(dir_names + num_dir_names)->len + 1));
#line 441
      tp_ftw(screen___0, dir, dirlen + (unsigned int )(dir_names + num_dir_names)->len,
             rsrc, fn, locale);
#line 442
      free((dir_names + num_dir_names)->str);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 444
    free(dir_names);
    }
  }
  return;
}
}
#line 43 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/progressbar.c"
void show_progress_bar(SDL_Surface *screen___0 ) 
{ 
  SDL_Rect dest ;
  SDL_Rect src ;
  int x ;
  static Uint32 oldtime ;
  Uint32 newtime ;
  Uint32 __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 50
  if (progress_bar_disabled) {
#line 51
    return;
  }
  {
#line 53
  newtime = SDL_GetTicks();
  }
#line 54
  if (newtime > oldtime + 15U) {
#line 56
    x = 0;
    {
#line 56
    while (1) {
      while_continue: /* CIL Label */ ;
#line 56
      if (! (x < screen___0->w)) {
#line 56
        goto while_break;
      }
      {
#line 58
      src.x = (Sint16 )(65 - prog_bar_ctr % 65);
#line 59
      src.y = (Sint16 )0;
#line 60
      src.w = (Uint16 )65;
#line 61
      src.h = (Uint16 )24;
#line 63
      dest.x = (Sint16 )x;
#line 64
      dest.y = (Sint16 )(screen___0->h - 24);
#line 66
      SDL_UpperBlit(img_progress, & src, screen___0, & dest);
      }
#line 56
      x += 65;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 69
    prog_bar_ctr ++;
#line 71
    SDL_UpdateRect(screen___0, 0, screen___0->h - 24, (Uint32 )screen___0->w, (Uint32 )24);
    }
  }
#line 73
  oldtime = newtime;
  return;
}
}
#line 224 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double evil_y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) double __evil_y1(double  ) ;
#line 224
extern  __attribute__((__nothrow__)) float evil_y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) float __evil_y1f(float  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double evil_y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) long double __evil_y1l(long double  ) ;
#line 224
extern  __attribute__((__nothrow__)) int evil_y1f32() ;
#line 224
extern  __attribute__((__nothrow__)) int __evil_y1f32() ;
#line 224
extern  __attribute__((__nothrow__)) int evil_y1f64() ;
#line 224
extern  __attribute__((__nothrow__)) int __evil_y1f64() ;
#line 224
extern  __attribute__((__nothrow__)) int evil_y1f128() ;
#line 224
extern  __attribute__((__nothrow__)) int __evil_y1f128() ;
#line 224
extern  __attribute__((__nothrow__)) int evil_y1f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int __evil_y1f32x() ;
#line 224
extern  __attribute__((__nothrow__)) int evil_y1f64x() ;
#line 224
extern  __attribute__((__nothrow__)) int __evil_y1f64x() ;
#line 39 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.h"
int would_flood_fill(SDL_Surface *canvas___0 , Uint32 cur_colr , Uint32 old_colr ) ;
#line 40
void do_flood_fill(SDL_Surface *screen___0 , SDL_Surface *last , SDL_Surface *canvas___0 ,
                   int x , int y , Uint32 cur_colr , Uint32 old_colr , int *x1 , int *y1___0 ,
                   int *x2 , int *y2 , Uint8 *touched___0 ) ;
#line 41
void simulate_flood_fill(SDL_Surface *screen___0 , SDL_Surface *last , SDL_Surface *canvas___0 ,
                         int x , int y , Uint32 cur_colr , Uint32 old_colr , int *extent_x1 ,
                         int *extent_y1 , int *extent_x2 , int *extent_y2 , Uint8 *touched___0 ) ;
#line 42
void draw_linear_gradient(SDL_Surface *canvas___0 , SDL_Surface *last , int x_left ,
                          int y_top , int x_right , int y_bottom , int x1 , int y1___0 ,
                          int x2 , int y2 , Uint32 draw_color , Uint8 *touched___0 ) ;
#line 45
void draw_radial_gradient(SDL_Surface *canvas___0 , int x_left , int y_top , int x_right ,
                          int y_bottom , int x , int y , Uint32 draw_color , Uint8 *touched___0 ) ;
#line 47
void draw_brush_fill(SDL_Surface *canvas___0 , int x_left , int y_top , int x_right ,
                     int y_bottom , int x1 , int y1___0 , int x2 , int y2 , Uint32 draw_color ,
                     Uint8 *touched___0 , int *up_x1 , int *up_y1 , int *up_x2 , int *up_y2 ) ;
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static float const   sRGB_to_linear_table[256]  = 
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
  {      (float )0.,      (float )0.000304000000001,      (float )0.000607000000001,      (float )0.000911000000001, 
        (float )0.00121400000001,      (float )0.00151800000001,      (float )0.001821,      (float )0.00212500000001, 
        (float )0.00242800000001,      (float )0.00273200000001,      (float )0.003035,      (float )0.00334700000001, 
        (float )0.00367700000001,      (float )0.004025,      (float )0.004391,      (float )0.004777, 
        (float )0.005182,      (float )0.005605,      (float )0.006049,      (float )0.00651200000001, 
        (float )0.00699500000001,      (float )0.007499,      (float )0.00802300000001,      (float )0.008568, 
        (float )0.009134,      (float )0.00972100000001,      (float )0.0103300000001,      (float )0.01096, 
        (float )0.0116120000001,      (float )0.0122860000001,      (float )0.012983,      (float )0.0137020000001, 
        (float )0.0144440000001,      (float )0.0152090000001,      (float )0.015996,      (float )0.016807, 
        (float )0.0176420000001,      (float )0.0185,      (float )0.019382,      (float )0.0202890000001, 
        (float )0.021219,      (float )0.022174,      (float )0.023153,      (float )0.024158, 
        (float )0.0251870000001,      (float )0.0262410000001,      (float )0.0273210000001,      (float )0.028426, 
        (float )0.029557,      (float )0.0307130000001,      (float )0.0318960000001,      (float )0.0331050000001, 
        (float )0.0343400000001,      (float )0.0356010000001,      (float )0.036889,      (float )0.0382040000001, 
        (float )0.039546,      (float )0.040915,      (float )0.0423110000001,      (float )0.0437350000001, 
        (float )0.045186,      (float )0.046665,      (float )0.048172,      (float )0.0497070000001, 
        (float )0.0512690000001,      (float )0.052861,      (float )0.0544800000001,      (float )0.056128, 
        (float )0.0578050000001,      (float )0.0595110000001,      (float )0.0612460000001,      (float )0.06301, 
        (float )0.064803,      (float )0.0666260000001,      (float )0.068478,      (float )0.0703600000001, 
        (float )0.0722720000001,      (float )0.0742140000001,      (float )0.0761850000001,      (float )0.0781870000001, 
        (float )0.08022,      (float )0.082283,      (float )0.0843760000001,      (float )0.0865, 
        (float )0.088656,      (float )0.0908420000001,      (float )0.0930590000001,      (float )0.0953070000001, 
        (float )0.097587,      (float )0.0998990000001,      (float )0.102242,      (float )0.104616000001, 
        (float )0.107023,      (float )0.109462000001,      (float )0.111932000001,      (float )0.114435, 
        (float )0.116971000001,      (float )0.119538000001,      (float )0.122139,      (float )0.124772, 
        (float )0.127438,      (float )0.130136000001,      (float )0.132868000001,      (float )0.135633000001, 
        (float )0.138432,      (float )0.141263,      (float )0.144128000001,      (float )0.147027, 
        (float )0.149960000001,      (float )0.152926000001,      (float )0.155926000001,      (float )0.158961, 
        (float )0.162029000001,      (float )0.165132000001,      (float )0.168269000001,      (float )0.171441000001, 
        (float )0.174647,      (float )0.177888,      (float )0.181164,      (float )0.184475000001, 
        (float )0.187821,      (float )0.191202000001,      (float )0.194618000001,      (float )0.198069, 
        (float )0.201556000001,      (float )0.205079000001,      (float )0.208637,      (float )0.212231000001, 
        (float )0.215861,      (float )0.219526,      (float )0.223228000001,      (float )0.226966000001, 
        (float )0.230740000001,      (float )0.234551000001,      (float )0.238398,      (float )0.242281, 
        (float )0.246201000001,      (float )0.250158,      (float )0.254152,      (float )0.258183, 
        (float )0.262251000001,      (float )0.266356,      (float )0.270498000001,      (float )0.274677000001, 
        (float )0.278894,      (float )0.283149,      (float )0.287441000001,      (float )0.291771000001, 
        (float )0.296138000001,      (float )0.300544,      (float )0.304987000001,      (float )0.309469, 
        (float )0.313989000001,      (float )0.318547000001,      (float )0.323143000001,      (float )0.327778000001, 
        (float )0.332452000001,      (float )0.337164000001,      (float )0.341914,      (float )0.346704000001, 
        (float )0.351533,      (float )0.3564,      (float )0.361307,      (float )0.366253, 
        (float )0.371238000001,      (float )0.376262,      (float )0.381326,      (float )0.386429000001, 
        (float )0.391572,      (float )0.396755000001,      (float )0.401978000001,      (float )0.40724, 
        (float )0.412543,      (float )0.417885000001,      (float )0.423268,      (float )0.428690000001, 
        (float )0.434154,      (float )0.439657000001,      (float )0.445201000001,      (float )0.450786000001, 
        (float )0.456411000001,      (float )0.462077000001,      (float )0.467784,      (float )0.473531, 
        (float )0.479320000001,      (float )0.485150000001,      (float )0.491021,      (float )0.496933000001, 
        (float )0.502886000001,      (float )0.508881000001,      (float )0.514918,      (float )0.520996000001, 
        (float )0.527115000001,      (float )0.533276,      (float )0.539479000001,      (float )0.545724, 
        (float )0.552011000001,      (float )0.55834,      (float )0.564712,      (float )0.571125, 
        (float )0.57758,      (float )0.584078,      (float )0.590619000001,      (float )0.597202000001, 
        (float )0.603827000001,      (float )0.610496000001,      (float )0.617207,      (float )0.62396, 
        (float )0.630757000001,      (float )0.637597,      (float )0.644480000001,      (float )0.651406000001, 
        (float )0.658375000001,      (float )0.665387,      (float )0.672443000001,      (float )0.679542, 
        (float )0.686685,      (float )0.693872000001,      (float )0.701102000001,      (float )0.708376000001, 
        (float )0.715694000001,      (float )0.723055000001,      (float )0.730461000001,      (float )0.73791, 
        (float )0.745404,      (float )0.752942000001,      (float )0.760525000001,      (float )0.768151000001, 
        (float )0.775822000001,      (float )0.783538,      (float )0.791298,      (float )0.799103000001, 
        (float )0.806952000001,      (float )0.814847,      (float )0.822786000001,      (float )0.830770000001, 
        (float )0.838799,      (float )0.846873,      (float )0.854993000001,      (float )0.863157, 
        (float )0.871367000001,      (float )0.879622000001,      (float )0.887923000001,      (float )0.896269, 
        (float )0.904661000001,      (float )0.913099,      (float )0.921582000001,      (float )0.930111000001, 
        (float )0.938686000001,      (float )0.947307000001,      (float )0.955973,      (float )0.964686000001, 
        (float )0.973445000001,      (float )0.982251,      (float )0.991102000001,      (float )1.};
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static unsigned char const   linear_to_sRGB_table[4096]  =    "";
#line 310
unsigned char linear_to_sRGB(float linear ) ;
#line 65 "/usr/include/SDL/SDL_mixer.h"
extern SDL_version *Mix_Linked_Version(void) ;
#line 80
extern int Mix_Init(int flags ) ;
#line 83
extern void Mix_Quit(void) ;
#line 133
extern int Mix_OpenAudio(int frequency , Uint16 format , int channels , int chunksize ) ;
#line 141
extern int Mix_AllocateChannels(int numchans ) ;
#line 146
extern int Mix_QuerySpec(int *frequency , Uint16 *format , int *channels ) ;
#line 149
extern Mix_Chunk *Mix_LoadWAV_RW(SDL_RWops *src , int freesrc ) ;
#line 151
extern Mix_Music *Mix_LoadMUS(char const   *file ) ;
#line 155
extern Mix_Music *Mix_LoadMUS_RW(SDL_RWops *rw ) ;
#line 158
extern Mix_Music *Mix_LoadMUSType_RW(SDL_RWops *rw , Mix_MusicType type , int freesrc ) ;
#line 161
extern Mix_Chunk *Mix_QuickLoad_WAV(Uint8 *mem ) ;
#line 164
extern Mix_Chunk *Mix_QuickLoad_RAW(Uint8 *mem , Uint32 len ) ;
#line 167
extern void Mix_FreeChunk(Mix_Chunk *chunk ) ;
#line 168
extern void Mix_FreeMusic(Mix_Music *music ) ;
#line 189
extern int Mix_GetNumChunkDecoders(void) ;
#line 190
extern char const   *Mix_GetChunkDecoder(int index ) ;
#line 191
extern int Mix_GetNumMusicDecoders(void) ;
#line 192
extern char const   *Mix_GetMusicDecoder(int index ) ;
#line 197
extern Mix_MusicType Mix_GetMusicType(Mix_Music *music ) ;
#line 203
extern void Mix_SetPostMix(void (*mix_func)(void * , Uint8 * , int  ) , void *arg ) ;
#line 209
extern void Mix_HookMusic(void (*mix_func)(void * , Uint8 * , int  ) , void *arg ) ;
#line 215
extern void Mix_HookMusicFinished(void (*music_finished)(void) ) ;
#line 218
extern void *Mix_GetMusicHookData(void) ;
#line 228
extern void Mix_ChannelFinished(void (*channel_finished)(int  ) ) ;
#line 312
extern int Mix_RegisterEffect(int chan , Mix_EffectFunc_t f , Mix_EffectDone_t d ,
                              void *arg ) ;
#line 324
extern int Mix_UnregisterEffect(int channel , Mix_EffectFunc_t f ) ;
#line 338
extern int Mix_UnregisterAllEffects(int channel ) ;
#line 378
extern int Mix_SetPanning(int channel , Uint8 left , Uint8 right ) ;
#line 418
extern int Mix_SetPosition(int channel , Sint16 angle , Uint8 distance ) ;
#line 448
extern int Mix_SetDistance(int channel , Uint8 distance ) ;
#line 495
extern int Mix_SetReverseStereo(int channel , int flip ) ;
#line 504
extern int Mix_ReserveChannels(int num ) ;
#line 514
extern int Mix_GroupChannel(int which , int tag ) ;
#line 516
extern int Mix_GroupChannels(int from , int to , int tag ) ;
#line 520
extern int Mix_GroupAvailable(int tag ) ;
#line 524
extern int Mix_GroupCount(int tag ) ;
#line 526
extern int Mix_GroupOldest(int tag ) ;
#line 528
extern int Mix_GroupNewer(int tag ) ;
#line 538
extern int Mix_PlayChannelTimed(int channel , Mix_Chunk *chunk , int loops , int ticks ) ;
#line 539
extern int Mix_PlayMusic(Mix_Music *music , int loops ) ;
#line 542
extern int Mix_FadeInMusic(Mix_Music *music , int loops , int ms ) ;
#line 543
extern int Mix_FadeInMusicPos(Mix_Music *music , int loops , int ms , double position ) ;
#line 545
extern int Mix_FadeInChannelTimed(int channel , Mix_Chunk *chunk , int loops , int ms ,
                                  int ticks ) ;
#line 552
extern int Mix_Volume(int channel , int volume ) ;
#line 553
extern int Mix_VolumeChunk(Mix_Chunk *chunk , int volume ) ;
#line 554
extern int Mix_VolumeMusic(int volume ) ;
#line 557
extern int Mix_HaltChannel(int channel ) ;
#line 558
extern int Mix_HaltGroup(int tag ) ;
#line 559
extern int Mix_HaltMusic(void) ;
#line 565
extern int Mix_ExpireChannel(int channel , int ticks ) ;
#line 571
extern int Mix_FadeOutChannel(int which , int ms ) ;
#line 572
extern int Mix_FadeOutGroup(int tag , int ms ) ;
#line 573
extern int Mix_FadeOutMusic(int ms ) ;
#line 576
extern Mix_Fading Mix_FadingMusic(void) ;
#line 577
extern Mix_Fading Mix_FadingChannel(int which ) ;
#line 580
extern void Mix_Pause(int channel ) ;
#line 581
extern void Mix_Resume(int channel ) ;
#line 582
extern int Mix_Paused(int channel ) ;
#line 585
extern void Mix_PauseMusic(void) ;
#line 586
extern void Mix_ResumeMusic(void) ;
#line 587
extern void Mix_RewindMusic(void) ;
#line 588
extern int Mix_PausedMusic(void) ;
#line 596
extern int Mix_SetMusicPosition(double position ) ;
#line 601
extern int Mix_Playing(int channel ) ;
#line 602
extern int Mix_PlayingMusic(void) ;
#line 605
extern int Mix_SetMusicCMD(char const   *command ) ;
#line 608
extern int Mix_SetSynchroValue(int value ) ;
#line 609
extern int Mix_GetSynchroValue(void) ;
#line 612
extern int Mix_SetSoundFonts(char const   *paths ) ;
#line 613
extern char const   *Mix_GetSoundFonts(void) ;
#line 614
extern int Mix_EachSoundFont(int (*function)(char const   * , void * ) , void *data ) ;
#line 619
extern Mix_Chunk *Mix_GetChunk(int channel ) ;
#line 622
extern void Mix_CloseAudio(void) ;
#line 37 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/playsound.h"
Mix_Chunk *sounds[31] ;
#line 38
int mute ;
#line 38
int use_sound ;
#line 38
int use_stereo ;
#line 40
void playsound(SDL_Surface *screen___0 , int chan , int s , int override , int x ,
               int y ) ;
#line 71 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
queue_t *queue ;
#line 72 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
int queue_size  =    0;
#line 72 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
int queue_end  =    0;
#line 76
SDL_Surface *global_screen ;
#line 76
SDL_Surface *global_last ;
#line 76
SDL_Surface *global_canvas ;
#line 77
Uint32 global_old_colr ;
#line 77
Uint32 global_cur_colr ;
#line 78
Uint8 *global_touched ;
#line 79
int global_extent_x1 ;
#line 79
int global_extent_y1 ;
#line 79
int global_extent_x2 ;
#line 79
int global_extent_y2 ;
#line 80
int global_prog_anim ;
#line 82
double colors_close(SDL_Surface *canvas___0 , Uint32 c1 , Uint32 c2 ) ;
#line 83
Uint32 blend(SDL_Surface *canvas___0 , Uint32 draw_colr , Uint32 old_colr , double pct ) ;
#line 84
void simulate_flood_fill_outside_check(int x , int y , int y_outside ) ;
#line 85
void draw_brush_fill_single(SDL_Surface *canvas___0 , int x , int y , Uint32 draw_color ,
                            Uint8 *touched___0 ) ;
#line 87
void init_queue(void) ;
#line 88
void add_to_queue(int x , int y , int y_outside ) ;
#line 89
int remove_from_queue(int *x , int *y , int *y_outside ) ;
#line 90
void cleanup_queue(void) ;
#line 92 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void init_queue(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 93
  queue_size = 0;
#line 94
  queue_end = 0;
#line 96
  __cil_tmp1 = malloc(sizeof(queue_t ) * 1024UL);
#line 96
  queue = (queue_t *)__cil_tmp1;
  }
#line 97
  if (queue == (void *)0) {
    {
#line 99
    fprintf(stderr, "Fill queue cannot be malloc()\'d\n\220");
    }
#line 100
    return;
  }
#line 103
  queue_size = 1024;
  return;
}
}
#line 106 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void add_to_queue(int x , int y , int y_outside ) 
{ 
  queue_t *tmp ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 108
  if (queue_end + 1 > queue_size) {
    {
#line 111
    __cil_tmp5 = realloc(queue, sizeof(queue_t ) * (unsigned long )(queue_size + 1024));
#line 111
    tmp = (queue_t *)__cil_tmp5;
    }
#line 112
    if (tmp == (void *)0) {
      {
#line 114
      fprintf(stderr, "Fill queue cannot be realloc()\'d\n");
      }
#line 115
      return;
    }
#line 117
    queue_size += 1024;
#line 122
    queue = tmp;
  }
#line 125
  (queue + queue_end)->x = x;
#line 126
  (queue + queue_end)->y = y;
#line 127
  (queue + queue_end)->y_outside = y_outside;
#line 129
  queue_end ++;
  return;
}
}
#line 140 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
int remove_from_queue(int *x , int *y , int *y_outside ) 
{ 
  int __cil_tmp4 ;

  {
#line 141
  if (queue_end == 0) {
#line 142
    return (0);
  }
#line 144
  __cil_tmp4 = queue_end;
#line 144
  queue_end --;
#line 146
  *x = (queue + queue_end)->x;
#line 147
  *y = (queue + queue_end)->y;
#line 148
  *y_outside = (queue + queue_end)->y_outside;
#line 158
  return (1);
}
}
#line 161 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void cleanup_queue(void) 
{ 


  {
#line 162
  if (queue != (void *)0) {
    {
#line 163
    free(queue);
    }
  }
#line 169
  queue_size = 0;
#line 170
  queue_end = 0;
  return;
}
}
#line 175 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
double colors_close(SDL_Surface *canvas___0 , Uint32 c1 , Uint32 c2 ) 
{ 
  Uint8 r1 ;
  Uint8 g1 ;
  Uint8 b1 ;
  Uint8 r2 ;
  Uint8 g2 ;
  Uint8 b2 ;
  double r ;
  double g ;
  double b ;

  {
#line 179
  if (c1 == c2) {
#line 183
    return (0.);
  } else {
    {
#line 189
    SDL_GetRGB(c1, canvas___0->format, & r1, & g1, & b1);
#line 190
    SDL_GetRGB(c2, canvas___0->format, & r2, & g2, & b2);
#line 193
    r = (double )(sRGB_to_linear_table[r1] - sRGB_to_linear_table[r2]);
#line 194
    r *= r;
#line 195
    g = (double )(sRGB_to_linear_table[g1] - sRGB_to_linear_table[g2]);
#line 196
    g *= g;
#line 197
    b = (double )(sRGB_to_linear_table[b1] - sRGB_to_linear_table[b2]);
#line 198
    b *= b;
    }
#line 204
    return ((r + g) + b);
  }
}
}
#line 208 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
int would_flood_fill(SDL_Surface *canvas___0 , Uint32 cur_colr , Uint32 old_colr ) 
{ 
  double __cil_tmp4 ;

  {
  {
#line 210
  __cil_tmp4 = colors_close(canvas___0, cur_colr, old_colr);
  }
#line 210
  if (__cil_tmp4 < 0.0400000000001) {
#line 212
    return (0);
  } else {
#line 214
    return (1);
  }
}
}
#line 218 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void do_flood_fill(SDL_Surface *screen___0 , SDL_Surface *last , SDL_Surface *canvas___0 ,
                   int x , int y , Uint32 cur_colr , Uint32 old_colr , int *x1 , int *y1___0 ,
                   int *x2 , int *y2 , Uint8 *touched___0 ) 
{ 


  {
  {
#line 220
  simulate_flood_fill(screen___0, last, canvas___0, x, y, cur_colr, old_colr, x1,
                      y1___0, x2, y2, touched___0);
  }
  return;
}
}
#line 224 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
Uint32 blend(SDL_Surface *canvas___0 , Uint32 draw_colr , Uint32 old_colr , double pct ) 
{ 
  Uint8 old_r ;
  Uint8 old_g ;
  Uint8 old_b ;
  Uint8 draw_r ;
  Uint8 draw_g ;
  Uint8 draw_b ;
  Uint8 new_r ;
  Uint8 new_g ;
  Uint8 new_b ;
  Uint32 __cil_tmp14 ;
  Uint32 __cil_tmp15 ;

  {
  {
#line 227
  SDL_GetRGB(draw_colr, canvas___0->format, & draw_r, & draw_g, & draw_b);
#line 228
  SDL_GetRGB(old_colr, canvas___0->format, & old_r, & old_g, & old_b);
#line 230
  new_r = (Uint8 )((double )((float )old_r) * (1. - pct) + (double )((float )draw_r) * pct);
#line 231
  new_g = (Uint8 )((double )((float )old_g) * (1. - pct) + (double )((float )draw_g) * pct);
#line 232
  new_b = (Uint8 )((double )((float )old_b) * (1. - pct) + (double )((float )draw_b) * pct);
#line 234
  __cil_tmp14 = SDL_MapRGB(canvas___0->format, draw_r, draw_g, draw_b);
  }
#line 234
  return (__cil_tmp14);
  {
#line 235
  __cil_tmp15 = SDL_MapRGB(canvas___0->format, new_r, new_g, new_b);
  }
#line 235
  return (__cil_tmp15);
}
}
#line 238 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void simulate_flood_fill(SDL_Surface *screen___0 , SDL_Surface *last , SDL_Surface *canvas___0 ,
                         int x , int y , Uint32 cur_colr , Uint32 old_colr , int *extent_x1 ,
                         int *extent_y1 , int *extent_x2 , int *extent_y2 , Uint8 *touched___0 ) 
{ 
  int y_outside ;
  int __cil_tmp14 ;

  {
  {
#line 242
  global_screen = screen___0;
#line 243
  global_last = last;
#line 244
  global_canvas = canvas___0;
#line 245
  global_old_colr = old_colr;
#line 246
  global_cur_colr = cur_colr;
#line 247
  global_touched = touched___0;
#line 248
  global_extent_x1 = x;
#line 249
  global_extent_y1 = y;
#line 250
  global_extent_x2 = x;
#line 251
  global_extent_y2 = y;
#line 252
  global_prog_anim = 0;
#line 255
  init_queue();
#line 256
  add_to_queue(x, y, 0);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    __cil_tmp14 = remove_from_queue(& x, & y, & y_outside);
    }
#line 259
    if (! __cil_tmp14) {
#line 259
      goto while_break;
    }
    {
#line 261
    simulate_flood_fill_outside_check(x, y, y_outside);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  cleanup_queue();
#line 265
  *extent_x1 = global_extent_x1;
#line 266
  *extent_y1 = global_extent_y1;
#line 267
  *extent_x2 = global_extent_x2;
#line 268
  *extent_y2 = global_extent_y2;
  }
  return;
}
}
#line 271 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void simulate_flood_fill_outside_check(int x , int y , int y_outside ) 
{ 
  int fillL ;
  int fillR ;
  int narrowFillL ;
  int narrowFillR ;
  int i ;
  int outside ;
  int just_queued ;
  double in_line ;
  double closeness ;
  Uint32 px_colr ;
  Uint8 touch_byt ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  Uint32 __cil_tmp17 ;
  double __cil_tmp18 ;
  int __cil_tmp19 ;
  Uint32 __cil_tmp20 ;
  Uint32 __cil_tmp21 ;
  int __cil_tmp22 ;
  Uint32 __cil_tmp23 ;
  double __cil_tmp24 ;
  Uint32 __cil_tmp25 ;
  Uint32 __cil_tmp26 ;
  int __cil_tmp27 ;
  Uint32 __cil_tmp28 ;
  double __cil_tmp29 ;
  int __cil_tmp30 ;
  Uint32 __cil_tmp31 ;
  Uint32 __cil_tmp32 ;
  int __cil_tmp33 ;
  Uint32 __cil_tmp34 ;
  double __cil_tmp35 ;
  Uint32 __cil_tmp36 ;
  Uint32 __cil_tmp37 ;
  int __cil_tmp38 ;
  Uint32 __cil_tmp39 ;
  double __cil_tmp40 ;
  int __cil_tmp41 ;
  Uint32 __cil_tmp42 ;
  double __cil_tmp43 ;
  int __cil_tmp44 ;

  {
  {
#line 279
  __cil_tmp15 = would_flood_fill(global_canvas, global_cur_colr, global_old_colr);
  }
#line 279
  if (! __cil_tmp15) {
#line 280
    return;
  }
#line 282
  if (x < 0) {
#line 283
    return;
  } else
#line 282
  if (x >= global_canvas->w) {
#line 283
    return;
  } else
#line 282
  if (y < 0) {
#line 283
    return;
  } else
#line 282
  if (y >= global_canvas->h) {
#line 283
    return;
  }
#line 286
  if (global_touched) {
#line 286
    if ((int )*(global_touched + (y * global_canvas->w + x))) {
#line 287
      return;
    }
  }
#line 289
  if (y < global_extent_y1) {
#line 291
    global_extent_y1 = y;
  }
#line 293
  if (y > global_extent_y2) {
#line 295
    global_extent_y2 = y;
  }
#line 299
  fillL = x;
#line 300
  fillR = x;
#line 301
  narrowFillL = x;
#line 302
  narrowFillR = x;
#line 304
  global_prog_anim ++;
#line 305
  if (global_prog_anim % 8 == 0) {
    {
#line 307
    show_progress_bar(global_screen);
    }
  }
#line 311
  if (global_prog_anim % 800 == 1) {
    {
#line 312
    playsound(global_canvas, 1, 30, 1, x, - 999);
    }
  }
  {
#line 324
  px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillL,
                                                                 y);
#line 325
  in_line = colors_close(global_canvas, px_colr, global_old_colr);
#line 326
  outside = 0;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (in_line < 0.6 && outside < 3)) {
#line 327
      goto while_break;
    }
#line 329
    if (in_line > 0.0400000000001) {
#line 330
      outside ++;
    } else {
#line 332
      narrowFillL = fillL;
    }
#line 335
    if (global_touched != (void *)0) {
#line 336
      touch_byt = (Uint8 )(255 - (int )((Uint8 )(in_line * (double )85)));
#line 337
      if ((int )touch_byt == 0) {
#line 338
        touch_byt = (Uint8 )1;
      }
#line 340
      *(global_touched + (y * global_canvas->w + fillL)) = touch_byt;
    }
    {
#line 343
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillL,
                                                                   y);
#line 344
    __cil_tmp21 = blend(global_canvas, global_cur_colr, px_colr, 1. - in_line);
#line 344
    (*(putpixels[(global_canvas->format)->BytesPerPixel]))(global_canvas, fillL, y,
                                                           __cil_tmp21);
#line 345
    __cil_tmp22 = fillL;
#line 345
    fillL --;
#line 347
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillL,
                                                                   y);
    }
#line 349
    if (fillL >= 0) {
      {
#line 351
      in_line = colors_close(global_canvas, px_colr, global_old_colr);
      }
    } else {
#line 355
      in_line = 3.;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (fillL >= 0) {
#line 361
    if (global_touched != (void *)0) {
#line 363
      touch_byt = (Uint8 )(255 - (int )((Uint8 )(in_line * (double )85)));
#line 364
      if ((int )touch_byt == 0) {
#line 365
        touch_byt = (Uint8 )1;
      }
#line 367
      *(global_touched + (y * global_canvas->w + fillL)) = touch_byt;
    }
    {
#line 370
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillL,
                                                                   y);
#line 371
    __cil_tmp26 = blend(global_canvas, global_cur_colr, px_colr, 1. - in_line);
#line 371
    (*(putpixels[(global_canvas->format)->BytesPerPixel]))(global_canvas, fillL, y,
                                                           __cil_tmp26);
    }
  }
#line 375
  if (fillL < global_extent_x1) {
#line 377
    global_extent_x1 = fillL;
  }
  {
#line 380
  fillL ++;
#line 385
  px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillR + 1,
                                                                 y);
#line 386
  in_line = colors_close(global_canvas, px_colr, global_old_colr);
#line 387
  outside = 0;
  }
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 388
    if (! (in_line < 0.6 && outside < 3)) {
#line 388
      goto while_break___0;
    }
#line 390
    if (in_line > 0.0400000000001) {
#line 391
      outside ++;
    } else {
#line 393
      narrowFillR = fillR;
    }
#line 396
    if (global_touched != (void *)0) {
#line 397
      touch_byt = (Uint8 )(255 - (int )((Uint8 )(in_line * (double )85)));
#line 398
      if ((int )touch_byt == 0) {
#line 399
        touch_byt = (Uint8 )1;
      }
#line 401
      *(global_touched + (y * global_canvas->w + fillR)) = touch_byt;
    }
    {
#line 404
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillR,
                                                                   y);
#line 405
    __cil_tmp32 = blend(global_canvas, global_cur_colr, px_colr, 1. - in_line);
#line 405
    (*(putpixels[(global_canvas->format)->BytesPerPixel]))(global_canvas, fillR, y,
                                                           __cil_tmp32);
#line 406
    fillR ++;
#line 408
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillR,
                                                                   y);
    }
#line 410
    if (fillR < global_canvas->w) {
      {
#line 412
      in_line = colors_close(global_canvas, px_colr, global_old_colr);
      }
    } else {
#line 416
      in_line = 3.;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  if (fillR < global_canvas->w) {
#line 422
    if (global_touched != (void *)0) {
#line 424
      touch_byt = (Uint8 )(255 - (int )((Uint8 )(in_line * (double )85)));
#line 425
      if ((int )touch_byt == 0) {
#line 426
        touch_byt = (Uint8 )1;
      }
#line 428
      *(global_touched + (y * global_canvas->w + fillR)) = touch_byt;
    }
    {
#line 431
    px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last, fillR,
                                                                   y);
#line 432
    __cil_tmp37 = blend(global_canvas, global_cur_colr, px_colr, 1. - in_line);
#line 432
    (*(putpixels[(global_canvas->format)->BytesPerPixel]))(global_canvas, fillR, y,
                                                           __cil_tmp37);
    }
  }
#line 435
  if (fillR > global_extent_x2) {
#line 437
    global_extent_x2 = fillR;
  }
#line 440
  __cil_tmp38 = fillR;
#line 440
  fillR --;
#line 445
  just_queued = 0;
#line 446
  if (y > 0) {
#line 448
    i = narrowFillL;
    {
#line 448
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 448
      if (! (i <= narrowFillR)) {
#line 448
        goto while_break___1;
      }
      {
#line 450
      px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last,
                                                                     i, y - 1);
#line 451
      closeness = colors_close(global_canvas, px_colr, global_old_colr);
      }
#line 452
      if (closeness < 0.0400000000001) {
        _L___1: /* CIL Label */ 
#line 456
        if (global_touched == (void *)0) {
          _L: /* CIL Label */ 
#line 456
          if (! just_queued) {
            {
#line 458
            add_to_queue(i, y - 1, y_outside + 1);
#line 459
            just_queued = 1;
            }
          } else {
#line 463
            just_queued = 0;
          }
        } else
#line 456
        if (! *(global_touched + ((y - 1) * global_canvas->w + i))) {
#line 456
          goto _L;
        } else {
#line 463
          just_queued = 0;
        }
      } else
#line 452
      if (closeness < 0.6) {
#line 452
        if (y_outside < 3) {
#line 452
          goto _L___1;
        } else {
#line 468
          just_queued = 0;
        }
      } else {
#line 468
        just_queued = 0;
      }
#line 448
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 476
  just_queued = 0;
#line 477
  if (y < global_canvas->h - 1) {
#line 479
    i = narrowFillL;
    {
#line 479
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 479
      if (! (i <= narrowFillR)) {
#line 479
        goto while_break___2;
      }
      {
#line 481
      px_colr = (*(getpixels[(global_last->format)->BytesPerPixel]))(global_last,
                                                                     i, y + 1);
#line 482
      closeness = colors_close(global_canvas, px_colr, global_old_colr);
      }
#line 483
      if (closeness < 0.0400000000001) {
        _L___3: /* CIL Label */ 
#line 487
        if (global_touched == (void *)0) {
          _L___2: /* CIL Label */ 
#line 487
          if (! just_queued) {
            {
#line 489
            add_to_queue(i, y + 1, y_outside + 1);
#line 490
            just_queued = 1;
            }
          } else {
#line 494
            just_queued = 0;
          }
        } else
#line 487
        if (! *(global_touched + ((y + 1) * global_canvas->w + i))) {
#line 487
          goto _L___2;
        } else {
#line 494
          just_queued = 0;
        }
      } else
#line 483
      if (closeness < 0.6) {
#line 483
        if (y_outside < 3) {
#line 483
          goto _L___3;
        } else {
#line 499
          just_queued = 0;
        }
      } else {
#line 499
        just_queued = 0;
      }
#line 479
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 506 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void draw_linear_gradient(SDL_Surface *canvas___0 , SDL_Surface *last , int x_left ,
                          int y_top , int x_right , int y_bottom , int x1 , int y1___0 ,
                          int x2 , int y2 , Uint32 draw_color , Uint8 *touched___0 ) 
{ 
  Uint32 old_colr ;
  Uint32 new_colr ;
  int xx ;
  int yy ;
  Uint8 draw_r ;
  Uint8 draw_g ;
  Uint8 draw_b ;
  Uint8 old_r ;
  Uint8 old_g ;
  Uint8 old_b ;
  Uint8 new_r ;
  Uint8 new_g ;
  Uint8 new_b ;
  float A ;
  float B ;
  float C ;
  float C1 ;
  float C2 ;
  float ratio ;
  Uint32 __cil_tmp32 ;
  Uint32 __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
  {
#line 516
  SDL_GetRGB(draw_color, canvas___0->format, & draw_r, & draw_g, & draw_b);
#line 518
  A = (float )(x2 - x1);
#line 519
  B = (float )(y2 - y1___0);
#line 520
  C1 = A * (float )x1 + B * (float )y1___0;
#line 521
  C2 = A * (float )x2 + B * (float )y2;
#line 524
  yy = y_top;
  }
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! (yy <= y_bottom)) {
#line 524
      goto while_break;
    }
#line 525
    xx = x_left;
    {
#line 525
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 525
      if (! (xx <= x_right)) {
#line 525
        goto while_break___0;
      }
#line 526
      if (*(touched___0 + (yy * canvas___0->w + xx))) {
        {
#line 528
        old_colr = (*(getpixels[(last->format)->BytesPerPixel]))(last, xx, yy);
#line 529
        SDL_GetRGB(old_colr, last->format, & old_r, & old_g, & old_b);
#line 533
        C = A * (float )xx + B * (float )yy;
        }
#line 535
        if (C < C1) {
#line 537
          ratio = (float )0.;
        } else
#line 538
        if (C >= C2) {
#line 540
          ratio = (float )1.;
        } else {
#line 543
          ratio = (C - C1) / (C2 - C1);
        }
        {
#line 547
        ratio = (float )((double )ratio * ((double )((float )*(touched___0 + (yy * canvas___0->w + xx))) / 255.));
#line 549
        new_r = (Uint8 )((double )((float )old_r * ratio) + (double )((float )draw_r) * (1. - (double )ratio));
#line 550
        new_g = (Uint8 )((double )((float )old_g * ratio) + (double )((float )draw_g) * (1. - (double )ratio));
#line 551
        new_b = (Uint8 )((double )((float )old_b * ratio) + (double )((float )draw_b) * (1. - (double )ratio));
#line 553
        new_colr = SDL_MapRGB(canvas___0->format, new_r, new_g, new_b);
#line 554
        (*(putpixels[(canvas___0->format)->BytesPerPixel]))(canvas___0, xx, yy, new_colr);
        }
      }
#line 525
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 524
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 560 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void draw_brush_fill_single(SDL_Surface *canvas___0 , int x , int y , Uint32 draw_color ,
                            Uint8 *touched___0 ) 
{ 
  int xx ;
  int yy ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 563
  yy = - 16;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (yy < 16)) {
#line 563
      goto while_break;
    }
#line 565
    xx = - 16;
    {
#line 565
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 565
      if (! (xx < 16)) {
#line 565
        goto while_break___0;
      }
#line 567
      if (xx * xx + yy * yy < 256) {
#line 567
        if ((int )*(touched___0 + ((y + yy) * canvas___0->w + (x + xx)))) {
          {
#line 570
          (*(putpixels[(canvas___0->format)->BytesPerPixel]))(canvas___0, x + xx,
                                                              y + yy, draw_color);
          }
        }
      }
#line 565
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 563
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 576 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void draw_brush_fill(SDL_Surface *canvas___0 , int x_left , int y_top , int x_right ,
                     int y_bottom , int x1 , int y1___0 , int x2 , int y2 , Uint32 draw_color ,
                     Uint8 *touched___0 , int *up_x1 , int *up_y1 , int *up_x2 , int *up_y2 ) 
{ 
  int dx ;
  int dy ;
  int y ;
  int orig_x1 ;
  int orig_y1 ;
  int orig_x2 ;
  int orig_y2 ;
  int tmp ;
  float m ;
  float b ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 586
  orig_x1 = x1;
#line 587
  orig_y1 = y1___0;
#line 589
  orig_x2 = x2;
#line 590
  orig_y2 = y2;
#line 592
  dx = x2 - x1;
#line 593
  dy = y2 - y1___0;
#line 595
  if (dx != 0) {
#line 597
    m = (float )dy / (float )dx;
#line 598
    b = (float )y1___0 - m * (float )x1;
#line 600
    if (x2 >= x1) {
#line 601
      dx = 1;
    } else {
#line 603
      dx = - 1;
    }
    {
#line 605
    while (1) {
      while_continue: /* CIL Label */ ;
#line 605
      if (! (x1 != x2)) {
#line 605
        goto while_break;
      }
#line 607
      y1___0 = (int )(m * (float )x1 + b);
#line 608
      y2 = (int )(m * (float )(x1 + dx) + b);
#line 610
      if (y1___0 > y2) {
#line 612
        y = y1___0;
        {
#line 612
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 612
          if (! (y >= y2)) {
#line 612
            goto while_break___0;
          }
          {
#line 613
          draw_brush_fill_single(canvas___0, x1, y, draw_color, touched___0);
          }
#line 612
          __cil_tmp26 = y;
#line 612
          y --;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 617
        y = y1___0;
        {
#line 617
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 617
          if (! (y <= y2)) {
#line 617
            goto while_break___1;
          }
          {
#line 618
          draw_brush_fill_single(canvas___0, x1, y, draw_color, touched___0);
          }
#line 617
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 621
      x1 += dx;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 626
    if (y1___0 > y2) {
#line 628
      y = y1___0;
#line 629
      y1___0 = y2;
#line 630
      y2 = y;
    }
#line 633
    y = y1___0;
    {
#line 633
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 633
      if (! (y <= y2)) {
#line 633
        goto while_break___2;
      }
      {
#line 634
      draw_brush_fill_single(canvas___0, x1, y, draw_color, touched___0);
      }
#line 633
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 637
  if (orig_x1 > orig_x2) {
#line 639
    tmp = orig_x1;
#line 640
    orig_x1 = orig_x2;
#line 641
    orig_x2 = tmp;
  }
#line 644
  if (orig_y1 > orig_y2) {
#line 646
    tmp = orig_y1;
#line 647
    orig_y1 = orig_y2;
#line 648
    orig_y2 = tmp;
  }
#line 651
  *up_x1 = orig_x1 - 16;
#line 652
  *up_y1 = orig_y1 - 16;
#line 653
  *up_x2 = orig_x2 + 16;
#line 654
  *up_y2 = orig_y2 + 16;
  return;
}
}
#line 657 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill.c"
void draw_radial_gradient(SDL_Surface *canvas___0 , int x_left , int y_top , int x_right ,
                          int y_bottom , int x , int y , Uint32 draw_color , Uint8 *touched___0 ) 
{ 
  Uint32 old_colr ;
  Uint32 new_colr ;
  int xx ;
  int yy ;
  float xd ;
  float yd ;
  float dist ;
  float rad ;
  float ratio ;
  Uint8 draw_r ;
  Uint8 draw_g ;
  Uint8 draw_b ;
  Uint8 old_r ;
  Uint8 old_g ;
  Uint8 old_b ;
  Uint8 new_r ;
  Uint8 new_g ;
  Uint8 new_b ;
  double __cil_tmp28 ;
  double __cil_tmp29 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  Uint32 __cil_tmp32 ;
  Uint32 __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
  {
#line 666
  xd = (float )0;
#line 667
  yd = (float )0;
#line 668
  __cil_tmp28 = sqrt((double )(xd * xd + yd * yd));
#line 668
  rad = (float )__cil_tmp28;
  }
#line 669
  if (rad == (float )0) {
#line 670
    return;
  }
  {
#line 674
  SDL_GetRGB(draw_color, canvas___0->format, & draw_r, & draw_g, & draw_b);
#line 677
  yy = y_top;
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (yy <= y_bottom)) {
#line 677
      goto while_break;
    }
#line 678
    xx = x_left;
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 678
      if (! (xx <= x_right)) {
#line 678
        goto while_break___0;
      }
#line 680
      if (*(touched___0 + (yy * canvas___0->w + xx))) {
        {
#line 682
        __cil_tmp29 = fabs((double )((float )(xx - x)));
#line 682
        xd = (float )__cil_tmp29;
#line 683
        __cil_tmp30 = fabs((double )((float )(yy - y)));
#line 683
        yd = (float )__cil_tmp30;
#line 684
        __cil_tmp31 = sqrt((double )(xd * xd + yd * yd));
#line 684
        dist = (float )__cil_tmp31;
        }
#line 685
        if (dist < rad) {
          {
#line 686
          ratio = dist / rad;
#line 689
          old_colr = (*(getpixels[(canvas___0->format)->BytesPerPixel]))(canvas___0,
                                                                         xx, yy);
#line 690
          SDL_GetRGB(old_colr, canvas___0->format, & old_r, & old_g, & old_b);
#line 693
          ratio = (float )((double )ratio * ((double )((float )*(touched___0 + (yy * canvas___0->w + xx))) / 255.));
#line 695
          new_r = (Uint8 )((double )((float )old_r * ratio) + (double )((float )draw_r) * (1. - (double )ratio));
#line 696
          new_g = (Uint8 )((double )((float )old_g * ratio) + (double )((float )draw_g) * (1. - (double )ratio));
#line 697
          new_b = (Uint8 )((double )((float )old_b * ratio) + (double )((float )draw_b) * (1. - (double )ratio));
#line 699
          new_colr = SDL_MapRGB(canvas___0->format, new_r, new_g, new_b);
#line 700
          (*(putpixels[(canvas___0->format)->BytesPerPixel]))(canvas___0, xx, yy,
                                                              new_colr);
          }
        }
      }
#line 678
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 677
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 4 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/obj/../src/parse.h"
char const   PARSE_YES[4] ;
#line 5
char const   PARSE_NO[3] ;
#line 6
char const   PARSE_CLOBBER[4] ;
#line 95
void parse_one_option(struct cfginfo *tmpcfg , char const   *str , char const   *opt ,
                      char const   *src ) ;
#line 18 "src/parse.gperf"
char const   PARSE_YES[4]  =    "yes";
#line 19 "src/parse.gperf"
char const   PARSE_NO[3]  =    "no";
#line 20 "src/parse.gperf"
char const   PARSE_CLOBBER[4]  =    ":-(";
#line 41
void show_version(int details ) ;
#line 42
void show_usage(int exitcode ) ;
#line 44 "src/parse.gperf"
static void imm_version(void) 
{ 


  {
  {
#line 46
  show_version(0);
  }
  return;
}
}
#line 49 "src/parse.gperf"
static void imm_verbose_version(void) 
{ 


  {
  {
#line 51
  show_version(1);
  }
  return;
}
}
#line 54 "src/parse.gperf"
static void imm_usage(void) 
{ 


  {
  {
#line 56
  show_usage(0);
  }
  return;
}
}
#line 59 "src/parse.gperf"
static void imm_help(void) 
{ 


  {
  {
#line 61
  show_version(0);
#line 62
  show_usage(0);
  }
  return;
}
}
#line 65 "src/parse.gperf"
static void imm_copying(void) 
{ 


  {
  {
#line 67
  show_version(0);
#line 68
  printf("\nThis program is free software; you can redistribute it\nand/or modify it under the terms of the GNU General Public\nLicense as published by the Free Software Foundation;\neither version 2 of the License, or (at your option) any\nlater version.\n\nThis program is distributed in the hope that it will be\nuseful and entertaining, but WITHOUT ANY WARRANTY; without\neven the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE.  See the GNU General Public\nLicense for more details.\n\nYou should have received a copy of the GNU General Public\nLicense along with this program; if not, write to the Free\nSoftware Foundation, Inc., 59 Temple Place, Suite 330,\nBoston, MA  02111-1307  USA\n\n");
  }
  return;
}
}
#line 112 "src/parse.gperf"
static unsigned int hash(char const   *str , size_t len ) 
{ 
  static unsigned short const   asso_values[128] ;
  register unsigned int hval ;

  {
#line 114
  asso_values[0] = (unsigned short )267;
#line 114
  asso_values[1] = (unsigned short )267;
#line 114
  asso_values[2] = (unsigned short )267;
#line 114
  asso_values[3] = (unsigned short )267;
#line 114
  asso_values[4] = (unsigned short )267;
#line 114
  asso_values[5] = (unsigned short )267;
#line 114
  asso_values[6] = (unsigned short )267;
#line 114
  asso_values[7] = (unsigned short )267;
#line 114
  asso_values[8] = (unsigned short )267;
#line 114
  asso_values[9] = (unsigned short )267;
#line 114
  asso_values[10] = (unsigned short )267;
#line 114
  asso_values[11] = (unsigned short )267;
#line 114
  asso_values[12] = (unsigned short )267;
#line 114
  asso_values[13] = (unsigned short )267;
#line 114
  asso_values[14] = (unsigned short )267;
#line 114
  asso_values[15] = (unsigned short )267;
#line 114
  asso_values[16] = (unsigned short )267;
#line 114
  asso_values[17] = (unsigned short )267;
#line 114
  asso_values[18] = (unsigned short )267;
#line 114
  asso_values[19] = (unsigned short )267;
#line 114
  asso_values[20] = (unsigned short )267;
#line 114
  asso_values[21] = (unsigned short )267;
#line 114
  asso_values[22] = (unsigned short )267;
#line 114
  asso_values[23] = (unsigned short )267;
#line 114
  asso_values[24] = (unsigned short )267;
#line 114
  asso_values[25] = (unsigned short )267;
#line 114
  asso_values[26] = (unsigned short )267;
#line 114
  asso_values[27] = (unsigned short )267;
#line 114
  asso_values[28] = (unsigned short )267;
#line 114
  asso_values[29] = (unsigned short )267;
#line 114
  asso_values[30] = (unsigned short )267;
#line 114
  asso_values[31] = (unsigned short )267;
#line 114
  asso_values[32] = (unsigned short )267;
#line 114
  asso_values[33] = (unsigned short )267;
#line 114
  asso_values[34] = (unsigned short )267;
#line 114
  asso_values[35] = (unsigned short )267;
#line 114
  asso_values[36] = (unsigned short )267;
#line 114
  asso_values[37] = (unsigned short )267;
#line 114
  asso_values[38] = (unsigned short )267;
#line 114
  asso_values[39] = (unsigned short )267;
#line 114
  asso_values[40] = (unsigned short )267;
#line 114
  asso_values[41] = (unsigned short )267;
#line 114
  asso_values[42] = (unsigned short )267;
#line 114
  asso_values[43] = (unsigned short )267;
#line 114
  asso_values[44] = (unsigned short )267;
#line 114
  asso_values[45] = (unsigned short )267;
#line 114
  asso_values[46] = (unsigned short )267;
#line 114
  asso_values[47] = (unsigned short )267;
#line 114
  asso_values[48] = (unsigned short )267;
#line 114
  asso_values[49] = (unsigned short )267;
#line 114
  asso_values[50] = (unsigned short )267;
#line 114
  asso_values[51] = (unsigned short )267;
#line 114
  asso_values[52] = (unsigned short )267;
#line 114
  asso_values[53] = (unsigned short )267;
#line 114
  asso_values[54] = (unsigned short )267;
#line 114
  asso_values[55] = (unsigned short )267;
#line 114
  asso_values[56] = (unsigned short )267;
#line 114
  asso_values[57] = (unsigned short )267;
#line 114
  asso_values[58] = (unsigned short )267;
#line 114
  asso_values[59] = (unsigned short )267;
#line 114
  asso_values[60] = (unsigned short )267;
#line 114
  asso_values[61] = (unsigned short )267;
#line 114
  asso_values[62] = (unsigned short )267;
#line 114
  asso_values[63] = (unsigned short )267;
#line 114
  asso_values[64] = (unsigned short )267;
#line 114
  asso_values[65] = (unsigned short )267;
#line 114
  asso_values[66] = (unsigned short )267;
#line 114
  asso_values[67] = (unsigned short )267;
#line 114
  asso_values[68] = (unsigned short )267;
#line 114
  asso_values[69] = (unsigned short )267;
#line 114
  asso_values[70] = (unsigned short )267;
#line 114
  asso_values[71] = (unsigned short )267;
#line 114
  asso_values[72] = (unsigned short )267;
#line 114
  asso_values[73] = (unsigned short )267;
#line 114
  asso_values[74] = (unsigned short )267;
#line 114
  asso_values[75] = (unsigned short )267;
#line 114
  asso_values[76] = (unsigned short )267;
#line 114
  asso_values[77] = (unsigned short )267;
#line 114
  asso_values[78] = (unsigned short )267;
#line 114
  asso_values[79] = (unsigned short )267;
#line 114
  asso_values[80] = (unsigned short )267;
#line 114
  asso_values[81] = (unsigned short )267;
#line 114
  asso_values[82] = (unsigned short )267;
#line 114
  asso_values[83] = (unsigned short )267;
#line 114
  asso_values[84] = (unsigned short )267;
#line 114
  asso_values[85] = (unsigned short )267;
#line 114
  asso_values[86] = (unsigned short )267;
#line 114
  asso_values[87] = (unsigned short )267;
#line 114
  asso_values[88] = (unsigned short )267;
#line 114
  asso_values[89] = (unsigned short )267;
#line 114
  asso_values[90] = (unsigned short )267;
#line 114
  asso_values[91] = (unsigned short )267;
#line 114
  asso_values[92] = (unsigned short )267;
#line 114
  asso_values[93] = (unsigned short )267;
#line 114
  asso_values[94] = (unsigned short )267;
#line 114
  asso_values[95] = (unsigned short )267;
#line 114
  asso_values[96] = (unsigned short )267;
#line 114
  asso_values[97] = (unsigned short )115;
#line 114
  asso_values[98] = (unsigned short )45;
#line 114
  asso_values[99] = (unsigned short )110;
#line 114
  asso_values[100] = (unsigned short )85;
#line 114
  asso_values[101] = (unsigned short )10;
#line 114
  asso_values[102] = (unsigned short )5;
#line 114
  asso_values[103] = (unsigned short )55;
#line 114
  asso_values[104] = (unsigned short )90;
#line 114
  asso_values[105] = (unsigned short )35;
#line 114
  asso_values[106] = (unsigned short )267;
#line 114
  asso_values[107] = (unsigned short )5;
#line 114
  asso_values[108] = (unsigned short )10;
#line 114
  asso_values[109] = (unsigned short )15;
#line 114
  asso_values[110] = (unsigned short )15;
#line 114
  asso_values[111] = (unsigned short )10;
#line 114
  asso_values[112] = (unsigned short )50;
#line 114
  asso_values[113] = (unsigned short )267;
#line 114
  asso_values[114] = (unsigned short )60;
#line 114
  asso_values[115] = (unsigned short )5;
#line 114
  asso_values[116] = (unsigned short )0;
#line 114
  asso_values[117] = (unsigned short )55;
#line 114
  asso_values[118] = (unsigned short )15;
#line 114
  asso_values[119] = (unsigned short )125;
#line 114
  asso_values[120] = (unsigned short )10;
#line 114
  asso_values[121] = (unsigned short )10;
#line 114
  asso_values[122] = (unsigned short )267;
#line 114
  asso_values[123] = (unsigned short )267;
#line 114
  asso_values[124] = (unsigned short )267;
#line 114
  asso_values[125] = (unsigned short )267;
#line 114
  asso_values[126] = (unsigned short )267;
#line 114
  asso_values[127] = (unsigned short )267;
#line 130
  hval = (unsigned int )len;
  {
#line 147
  if (hval == (unsigned int )3) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )4) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )5) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )6) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )7) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )8) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )9) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )10) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )11) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )12) {
#line 147
    goto case_3;
  }
#line 147
  if (hval == (unsigned int )13) {
#line 147
    goto case_3;
  }
#line 150
  if (hval == (unsigned int )2) {
#line 150
    goto case_2;
  }
#line 134
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 135
  hval += (unsigned int )asso_values[(unsigned char )*(str + 13)];
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 148
  hval += (unsigned int )asso_values[(unsigned char )*(str + 2)];
  case_2: /* CIL Label */ 
#line 151
  hval += (unsigned int )asso_values[(unsigned char )*(str + 1)];
#line 152
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 154
  return (hval + (unsigned int )asso_values[(unsigned char )*(str + (len - 1UL))]);
}
}
#line 158 "src/parse.gperf"
static struct cfg *in_word_set(char const   *str , size_t len ) 
{ 
  static struct cfg wordlist[267] ;
  register unsigned int key ;
  unsigned int __cil_tmp5 ;
  register char const   *s ;
  int __cil_tmp7 ;

  {
#line 160
  wordlist[0].name = "\251";
#line 160
  wordlist[0].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[1].name = "\251";
#line 160
  wordlist[1].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[2].name = "\251";
#line 160
  wordlist[2].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[3].name = "\251";
#line 160
  wordlist[3].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[4].name = "\251";
#line 160
  wordlist[4].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[5].name = "\251";
#line 160
  wordlist[5].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[6].name = "\251";
#line 160
  wordlist[6].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[7].name = "\251";
#line 160
  wordlist[7].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[8].name = "\251";
#line 160
  wordlist[8].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[9].name = "\251";
#line 160
  wordlist[9].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[10].name = "\251";
#line 160
  wordlist[10].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[11].name = "\251";
#line 160
  wordlist[11].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[12].name = "\251";
#line 160
  wordlist[12].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[13].name = "\251";
#line 160
  wordlist[13].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[14].name = "\251";
#line 160
  wordlist[14].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[15].name = "\251";
#line 160
  wordlist[15].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[16].name = "\251";
#line 160
  wordlist[16].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[17].name = "\251";
#line 160
  wordlist[17].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[18].name = "altprint@\225\032s\324U";
#line 160
  wordlist[18].val = (void (*)(void))((void *)0);
#line 160
  wordlist[19].name = "\251";
#line 160
  wordlist[19].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[20].name = "\251";
#line 160
  wordlist[20].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[21].name = "\251";
#line 160
  wordlist[21].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[22].name = "\251";
#line 160
  wordlist[22].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[23].name = "\251";
#line 160
  wordlist[23].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[24].name = "\251";
#line 160
  wordlist[24].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[25].name = "\251";
#line 160
  wordlist[25].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[26].name = "stereo";
#line 160
  wordlist[26].val = (void (*)(void))((void *)1);
#line 160
  wordlist[27].name = "\251";
#line 160
  wordlist[27].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[28].name = "sysfonts@\225\032s\324U";
#line 160
  wordlist[28].val = (void (*)(void))((void *)2);
#line 160
  wordlist[29].name = "\251";
#line 160
  wordlist[29].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[30].name = "\251";
#line 160
  wordlist[30].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[31].name = "\251";
#line 160
  wordlist[31].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[32].name = "\251";
#line 160
  wordlist[32].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[33].name = "\251";
#line 160
  wordlist[33].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[34].name = "altprintalways";
#line 160
  wordlist[34].val = (void (*)(void))((void *)0);
#line 160
  wordlist[35].name = "colorsrows";
#line 160
  wordlist[35].val = (void (*)(void))((void *)0);
#line 160
  wordlist[36].name = "\251";
#line 160
  wordlist[36].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[37].name = "joystick-btn-text\354\032s\324U";
#line 160
  wordlist[37].val = (void (*)(void))((void *)0);
#line 160
  wordlist[38].name = "\251";
#line 160
  wordlist[38].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[39].name = "colorfile\351\032s\324U";
#line 160
  wordlist[39].val = (void (*)(void))((void *)0);
#line 160
  wordlist[40].name = "joystick-hat-timeout\324U";
#line 160
  wordlist[40].val = (void (*)(void))((void *)0);
#line 160
  wordlist[41].name = "\251";
#line 160
  wordlist[41].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[42].name = "joystick-maxsteps";
#line 160
  wordlist[42].val = (void (*)(void))((void *)0);
#line 160
  wordlist[43].name = "complexshapes";
#line 160
  wordlist[43].val = (void (*)(void))((void *)2);
#line 160
  wordlist[44].name = "alllocalefonts";
#line 160
  wordlist[44].val = (void (*)(void))((void *)1);
#line 160
  wordlist[45].name = "\251";
#line 160
  wordlist[45].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[46].name = "\251";
#line 160
  wordlist[46].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[47].name = "joystick-dev";
#line 160
  wordlist[47].val = (void (*)(void))((void *)0);
#line 160
  wordlist[48].name = "\251";
#line 160
  wordlist[48].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[49].name = "joystick-btn-shapes";
#line 160
  wordlist[49].val = (void (*)(void))((void *)0);
#line 160
  wordlist[50].name = "\251";
#line 160
  wordlist[50].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[51].name = "joystick-hat-slowness";
#line 160
  wordlist[51].val = (void (*)(void))((void *)0);
#line 160
  wordlist[52].name = "joystick-btn-save";
#line 160
  wordlist[52].val = (void (*)(void))((void *)0);
#line 160
  wordlist[53].name = "joystick-btn-lines";
#line 160
  wordlist[53].val = (void (*)(void))((void *)0);
#line 160
  wordlist[54].name = "onscreen-keyboard-layout@\225\032s\324U";
#line 160
  wordlist[54].val = (void (*)(void))((void *)0);
#line 160
  wordlist[55].name = "\251";
#line 160
  wordlist[55].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[56].name = "\251";
#line 160
  wordlist[56].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[57].name = "joystick-slowness";
#line 160
  wordlist[57].val = (void (*)(void))((void *)0);
#line 160
  wordlist[58].name = "joystick-btn-label";
#line 160
  wordlist[58].val = (void (*)(void))((void *)0);
#line 160
  wordlist[59].name = "joystick-btn-escape";
#line 160
  wordlist[59].val = (void (*)(void))((void *)0);
#line 160
  wordlist[60].name = "\251";
#line 160
  wordlist[60].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[61].name = "dontmirrorstamps@\225\032s\324U";
#line 160
  wordlist[61].val = (void (*)(void))((void *)2);
#line 160
  wordlist[62].name = "joystick-btn-open\377\377\377";
#line 160
  wordlist[62].val = (void (*)(void))((void *)0);
#line 160
  wordlist[63].name = "joystick-buttons-ignore";
#line 160
  wordlist[63].val = (void (*)(void))((void *)0);
#line 160
  wordlist[64].name = "mixedcase";
#line 160
  wordlist[64].val = (void (*)(void))((void *)2);
#line 160
  wordlist[65].name = "\251";
#line 160
  wordlist[65].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[66].name = "\251";
#line 160
  wordlist[66].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[67].name = "simpleshapes";
#line 160
  wordlist[67].val = (void (*)(void))((void *)1);
#line 160
  wordlist[68].name = "outlines@\225\032s\324U";
#line 160
  wordlist[68].val = (void (*)(void))((void *)2);
#line 160
  wordlist[69].name = "\251";
#line 160
  wordlist[69].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[70].name = "windowsize";
#line 160
  wordlist[70].val = (void (*)(void))((void *)0);
#line 160
  wordlist[71].name = "\251";
#line 160
  wordlist[71].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[72].name = "onscreen-keyboard-disable-change@\225\032s\324U";
#line 160
  wordlist[72].val = (void (*)(void))((void *)1);
#line 160
  wordlist[73].name = "autosave@\225\032s\324U";
#line 160
  wordlist[73].val = (void (*)(void))((void *)1);
#line 160
  wordlist[74].name = "help\365\005";
#line 160
  wordlist[74].val = (void (*)(void))(& imm_help);
#line 160
  wordlist[75].name = "buttonsize";
#line 160
  wordlist[75].val = (void (*)(void))((void *)0);
#line 160
  wordlist[76].name = "\251";
#line 160
  wordlist[76].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[77].name = "\251";
#line 160
  wordlist[77].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[78].name = "dontgrab@\225\032s\324U";
#line 160
  wordlist[78].val = (void (*)(void))((void *)2);
#line 160
  wordlist[79].name = "sysconfigF";
#line 160
  wordlist[79].val = (void (*)(void))((void *)1);
#line 160
  wordlist[80].name = "mouseX";
#line 160
  wordlist[80].val = (void (*)(void))((void *)2);
#line 160
  wordlist[81].name = "\251";
#line 160
  wordlist[81].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[82].name = "\251";
#line 160
  wordlist[82].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[83].name = "altprintnever";
#line 160
  wordlist[83].val = (void (*)(void))((void *)0);
#line 160
  wordlist[84].name = "\251";
#line 160
  wordlist[84].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[85].name = "\251";
#line 160
  wordlist[85].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[86].name = "\251";
#line 160
  wordlist[86].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[87].name = "buttondistinction";
#line 160
  wordlist[87].val = (void (*)(void))((void *)2);
#line 160
  wordlist[88].name = "joystick-btn-print";
#line 160
  wordlist[88].val = (void (*)(void))((void *)0);
#line 160
  wordlist[89].name = "\251";
#line 160
  wordlist[89].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[90].name = "fullscreen";
#line 160
  wordlist[90].val = (void (*)(void))((void *)0);
#line 160
  wordlist[91].name = "\251";
#line 160
  wordlist[91].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[92].name = "version";
#line 160
  wordlist[92].val = (void (*)(void))(& imm_version);
#line 160
  wordlist[93].name = "joystick-btn-stamp";
#line 160
  wordlist[93].val = (void (*)(void))((void *)0);
#line 160
  wordlist[94].name = "quit\002";
#line 160
  wordlist[94].val = (void (*)(void))((void *)2);
#line 160
  wordlist[95].name = "\251";
#line 160
  wordlist[95].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[96].name = "\251";
#line 160
  wordlist[96].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[97].name = "\251";
#line 160
  wordlist[97].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[98].name = "\251";
#line 160
  wordlist[98].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[99].name = "\251";
#line 160
  wordlist[99].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[100].name = "print";
#line 160
  wordlist[100].val = (void (*)(void))((void *)2);
#line 160
  wordlist[101].name = "orient";
#line 160
  wordlist[101].val = (void (*)(void))((void *)0);
#line 160
  wordlist[102].name = "joystick-btn-undo";
#line 160
  wordlist[102].val = (void (*)(void))((void *)0);
#line 160
  wordlist[103].name = "\251";
#line 160
  wordlist[103].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[104].name = "\251";
#line 160
  wordlist[104].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[105].name = "\251";
#line 160
  wordlist[105].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[106].name = "altprintmod";
#line 160
  wordlist[106].val = (void (*)(void))((void *)0);
#line 160
  wordlist[107].name = "joystick-btn-redo";
#line 160
  wordlist[107].val = (void (*)(void))((void *)0);
#line 160
  wordlist[108].name = "\251";
#line 160
  wordlist[108].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[109].name = "joystick-btn-eraser";
#line 160
  wordlist[109].val = (void (*)(void))((void *)0);
#line 160
  wordlist[110].name = "verbose-version";
#line 160
  wordlist[110].val = (void (*)(void))(& imm_verbose_version);
#line 160
  wordlist[111].name = "allowscreensaver@\225\032s\324U";
#line 160
  wordlist[111].val = (void (*)(void))((void *)2);
#line 160
  wordlist[112].name = "mirrorstamps";
#line 160
  wordlist[112].val = (void (*)(void))((void *)1);
#line 160
  wordlist[113].name = "keyboard@\225\032s\324U";
#line 160
  wordlist[113].val = (void (*)(void))((void *)1);
#line 160
  wordlist[114].name = "shortcuts";
#line 160
  wordlist[114].val = (void (*)(void))((void *)2);
#line 160
  wordlist[115].name = "printdelay";
#line 160
  wordlist[115].val = (void (*)(void))((void *)0);
#line 160
  wordlist[116].name = "\251";
#line 160
  wordlist[116].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[117].name = "\251";
#line 160
  wordlist[117].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[118].name = "\251";
#line 160
  wordlist[118].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[119].name = "uppercase";
#line 160
  wordlist[119].val = (void (*)(void))((void *)1);
#line 160
  wordlist[120].name = "wheelmouse";
#line 160
  wordlist[120].val = (void (*)(void))((void *)1);
#line 160
  wordlist[121].name = "\251";
#line 160
  wordlist[121].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[122].name = "copying";
#line 160
  wordlist[122].val = (void (*)(void))(& imm_copying);
#line 160
  wordlist[123].name = "disablescreensaver";
#line 160
  wordlist[123].val = (void (*)(void))((void *)1);
#line 160
  wordlist[124].name = "startlast";
#line 160
  wordlist[124].val = (void (*)(void))((void *)2);
#line 160
  wordlist[125].name = "altprintcommand";
#line 160
  wordlist[125].val = (void (*)(void))((void *)0);
#line 160
  wordlist[126].name = "stamps";
#line 160
  wordlist[126].val = (void (*)(void))((void *)2);
#line 160
  wordlist[127].name = "\251";
#line 160
  wordlist[127].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[128].name = "joystick-threshold";
#line 160
  wordlist[128].val = (void (*)(void))((void *)0);
#line 160
  wordlist[129].name = "exportdir";
#line 160
  wordlist[129].val = (void (*)(void))((void *)0);
#line 160
  wordlist[130].name = "startblank";
#line 160
  wordlist[130].val = (void (*)(void))((void *)1);
#line 160
  wordlist[131].name = "native";
#line 160
  wordlist[131].val = (void (*)(void))((void *)1);
#line 160
  wordlist[132].name = "onscreen-keyboard";
#line 160
  wordlist[132].val = (void (*)(void))((void *)1);
#line 160
  wordlist[133].name = "stampcontrols";
#line 160
  wordlist[133].val = (void (*)(void))((void *)2);
#line 160
  wordlist[134].name = "stampsize";
#line 160
  wordlist[134].val = (void (*)(void))((void *)0);
#line 160
  wordlist[135].name = "usage";
#line 160
  wordlist[135].val = (void (*)(void))(& imm_usage);
#line 160
  wordlist[136].name = "locale";
#line 160
  wordlist[136].val = (void (*)(void))((void *)0);
#line 160
  wordlist[137].name = "currentlocalefont";
#line 160
  wordlist[137].val = (void (*)(void))((void *)2);
#line 160
  wordlist[138].name = "lockfile@\225\032s\324U";
#line 160
  wordlist[138].val = (void (*)(void))((void *)1);
#line 160
  wordlist[139].name = "mouse-accessibility";
#line 160
  wordlist[139].val = (void (*)(void))((void *)1);
#line 160
  wordlist[140].name = "joystick-btn-pgsetup";
#line 160
  wordlist[140].val = (void (*)(void))((void *)0);
#line 160
  wordlist[141].name = "\251";
#line 160
  wordlist[141].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[142].name = "\251";
#line 160
  wordlist[142].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[143].name = "windowed@\225\032s\324U";
#line 160
  wordlist[143].val = (void (*)(void))((void *)2);
#line 160
  wordlist[144].name = "save";
#line 160
  wordlist[144].val = (void (*)(void))((void *)2);
#line 160
  wordlist[145].name = "\251";
#line 160
  wordlist[145].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[146].name = "saveoverask";
#line 160
  wordlist[146].val = (void (*)(void))((void *)1);
#line 160
  wordlist[147].name = "fancycursors";
#line 160
  wordlist[147].val = (void (*)(void))((void *)2);
#line 160
  wordlist[148].name = "newcolorslast";
#line 160
  wordlist[148].val = (void (*)(void))((void *)1);
#line 160
  wordlist[149].name = "newcolorsfirst";
#line 160
  wordlist[149].val = (void (*)(void))((void *)2);
#line 160
  wordlist[150].name = "\251";
#line 160
  wordlist[150].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[151].name = "\251";
#line 160
  wordlist[151].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[152].name = "\251";
#line 160
  wordlist[152].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[153].name = "\251";
#line 160
  wordlist[153].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[154].name = "";
#line 160
  wordlist[154].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[155].name = "sound";
#line 160
  wordlist[155].val = (void (*)(void))((void *)1);
#line 160
  wordlist[156].name = "\251";
#line 160
  wordlist[156].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[157].name = "\251";
#line 160
  wordlist[157].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[158].name = "printcfg@\225\032s\324U";
#line 160
  wordlist[158].val = (void (*)(void))((void *)1);
#line 160
  wordlist[159].name = "\251";
#line 160
  wordlist[159].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[160].name = "\251";
#line 160
  wordlist[160].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[161].name = "\251";
#line 160
  wordlist[161].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[162].name = "\251";
#line 160
  wordlist[162].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[163].name = "joystick-btn-magic";
#line 160
  wordlist[163].val = (void (*)(void))((void *)0);
#line 160
  wordlist[164].name = "\251";
#line 160
  wordlist[164].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[165].name = "\251";
#line 160
  wordlist[165].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[166].name = "\251";
#line 160
  wordlist[166].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[167].name = "\251";
#line 160
  wordlist[167].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[168].name = "\251";
#line 160
  wordlist[168].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[169].name = "\251";
#line 160
  wordlist[169].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[170].name = "showcursor";
#line 160
  wordlist[170].val = (void (*)(void))((void *)2);
#line 160
  wordlist[171].name = "\251";
#line 160
  wordlist[171].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[172].name = "\251";
#line 160
  wordlist[172].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[173].name = "joystick-btn-brush";
#line 160
  wordlist[173].val = (void (*)(void))((void *)0);
#line 160
  wordlist[174].name = "\251";
#line 160
  wordlist[174].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[175].name = "label";
#line 160
  wordlist[175].val = (void (*)(void))((void *)2);
#line 160
  wordlist[176].name = "joystick-btn-new@\225\032s\324U";
#line 160
  wordlist[176].val = (void (*)(void))((void *)0);
#line 160
  wordlist[177].name = "\251";
#line 160
  wordlist[177].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[178].name = "\251";
#line 160
  wordlist[178].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[179].name = "\251";
#line 160
  wordlist[179].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[180].name = "\251";
#line 160
  wordlist[180].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[181].name = "\251";
#line 160
  wordlist[181].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[182].name = "datadir";
#line 160
  wordlist[182].val = (void (*)(void))((void *)0);
#line 160
  wordlist[183].name = "\251";
#line 160
  wordlist[183].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[184].name = "papersize";
#line 160
  wordlist[184].val = (void (*)(void))((void *)0);
#line 160
  wordlist[185].name = "\251";
#line 160
  wordlist[185].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[186].name = "\251";
#line 160
  wordlist[186].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[187].name = "\251";
#line 160
  wordlist[187].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[188].name = "magiccontrols";
#line 160
  wordlist[188].val = (void (*)(void))((void *)2);
#line 160
  wordlist[189].name = "lang";
#line 160
  wordlist[189].val = (void (*)(void))((void *)0);
#line 160
  wordlist[190].name = "hidecursor";
#line 160
  wordlist[190].val = (void (*)(void))((void *)1);
#line 160
  wordlist[191].name = "\251";
#line 160
  wordlist[191].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[192].name = "printcommand";
#line 160
  wordlist[192].val = (void (*)(void))((void *)0);
#line 160
  wordlist[193].name = "\251";
#line 160
  wordlist[193].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[194].name = "\251";
#line 160
  wordlist[194].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[195].name = "\251";
#line 160
  wordlist[195].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[196].name = "\251";
#line 160
  wordlist[196].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[197].name = "savedir";
#line 160
  wordlist[197].val = (void (*)(void))((void *)0);
#line 160
  wordlist[198].name = "saveover@\225\032s\324U";
#line 160
  wordlist[198].val = (void (*)(void))((void *)1);
#line 160
  wordlist[199].name = "\251";
#line 160
  wordlist[199].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[200].name = "\251";
#line 160
  wordlist[200].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[201].name = "\251";
#line 160
  wordlist[201].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[202].name = "\251";
#line 160
  wordlist[202].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[203].name = "\251";
#line 160
  wordlist[203].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[204].name = "\251";
#line 160
  wordlist[204].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[205].name = "\251";
#line 160
  wordlist[205].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[206].name = "\251";
#line 160
  wordlist[206].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[207].name = "\251";
#line 160
  wordlist[207].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[208].name = "\251";
#line 160
  wordlist[208].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[209].name = "\251";
#line 160
  wordlist[209].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[210].name = "\251";
#line 160
  wordlist[210].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[211].name = "\251";
#line 160
  wordlist[211].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[212].name = "\251";
#line 160
  wordlist[212].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[213].name = "\251";
#line 160
  wordlist[213].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[214].name = "\251";
#line 160
  wordlist[214].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[215].name = "\251";
#line 160
  wordlist[215].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[216].name = "\251";
#line 160
  wordlist[216].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[217].name = "\251";
#line 160
  wordlist[217].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[218].name = "\251";
#line 160
  wordlist[218].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[219].name = "\251";
#line 160
  wordlist[219].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[220].name = "\251";
#line 160
  wordlist[220].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[221].name = "\251";
#line 160
  wordlist[221].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[222].name = "\251";
#line 160
  wordlist[222].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[223].name = "shapecontrols";
#line 160
  wordlist[223].val = (void (*)(void))((void *)2);
#line 160
  wordlist[224].name = "grab";
#line 160
  wordlist[224].val = (void (*)(void))((void *)1);
#line 160
  wordlist[225].name = "\251";
#line 160
  wordlist[225].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[226].name = "\251";
#line 160
  wordlist[226].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[227].name = "\251";
#line 160
  wordlist[227].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[228].name = "\251";
#line 160
  wordlist[228].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[229].name = "\251";
#line 160
  wordlist[229].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[230].name = "\251";
#line 160
  wordlist[230].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[231].name = "\251";
#line 160
  wordlist[231].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[232].name = "\251";
#line 160
  wordlist[232].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[233].name = "\251";
#line 160
  wordlist[233].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[234].name = "\251";
#line 160
  wordlist[234].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[235].name = "\251";
#line 160
  wordlist[235].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[236].name = "\251";
#line 160
  wordlist[236].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[237].name = "\251";
#line 160
  wordlist[237].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[238].name = "\251";
#line 160
  wordlist[238].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[239].name = "\251";
#line 160
  wordlist[239].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[240].name = "\251";
#line 160
  wordlist[240].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[241].name = "\251";
#line 160
  wordlist[241].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[242].name = "\251";
#line 160
  wordlist[242].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[243].name = "\251";
#line 160
  wordlist[243].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[244].name = "\251";
#line 160
  wordlist[244].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[245].name = "\251";
#line 160
  wordlist[245].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[246].name = "\251";
#line 160
  wordlist[246].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[247].name = "\251";
#line 160
  wordlist[247].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[248].name = "\251";
#line 160
  wordlist[248].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[249].name = "\251";
#line 160
  wordlist[249].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[250].name = "\251";
#line 160
  wordlist[250].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[251].name = "\251";
#line 160
  wordlist[251].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[252].name = "\251";
#line 160
  wordlist[252].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[253].name = "\251";
#line 160
  wordlist[253].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[254].name = "\251";
#line 160
  wordlist[254].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[255].name = "\251";
#line 160
  wordlist[255].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[256].name = "\251";
#line 160
  wordlist[256].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[257].name = "\251";
#line 160
  wordlist[257].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[258].name = "\251";
#line 160
  wordlist[258].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[259].name = "\251";
#line 160
  wordlist[259].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[260].name = "\251";
#line 160
  wordlist[260].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[261].name = "\251";
#line 160
  wordlist[261].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[262].name = "\251";
#line 160
  wordlist[262].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[263].name = "\251";
#line 160
  wordlist[263].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[264].name = "\251";
#line 160
  wordlist[264].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[265].name = "\251";
#line 160
  wordlist[265].val = (void (*)(void))((void (*)(void))0);
#line 160
  wordlist[266].name = "saveovernew";
#line 160
  wordlist[266].val = (void (*)(void))((void *)1);
#line 149
  if (len <= 32UL) {
#line 149
    if (len >= 4UL) {
      {
#line 151
      __cil_tmp5 = hash(str, len);
#line 151
      key = __cil_tmp5;
      }
#line 153
      if (key <= 266U) {
        {
#line 155
        s = wordlist[key].name;
#line 157
        __cil_tmp7 = strcmp(str + 1, s + 1);
        }
#line 157
        if ((int )*str == (int )*s) {
#line 157
          if (! __cil_tmp7) {
#line 158
            return (& wordlist[key]);
          }
        }
      }
    }
  }
#line 161
  return ((struct cfg *)0);
}
}
#line 197 "src/parse.gperf"
void parse_one_option(struct cfginfo *tmpcfg , char const   *str , char const   *opt ,
                      char const   *src ) 
{ 
  int noflag ;
  uintptr_t uintptr ;
  unsigned int flags ;
  unsigned int offset ;
  char *dupecheck ;
  struct cfg *cfg ;
  unsigned short const   **__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  struct cfg *__cil_tmp18 ;
  uintptr_t tmp ;
  uintptr_t tmp___0 ;
  long __cil_tmp21 ;
  int flip ;
  char const   *tmp___1 ;
  int __cil_tmp24 ;
  char const   *tmp___2 ;
  int __cil_tmp26 ;
  char const   *tmp___3 ;

  {
  {
#line 210
  __cil_tmp11 = __ctype_b_loc();
  }
#line 210
  if ((int )*(*__cil_tmp11 + (int )*str) & 2048) {
    {
#line 212
    __cil_tmp12 = strcmp(opt, "no\002");
    }
#line 212
    if (opt) {
#line 212
      if (! __cil_tmp12) {
#line 213
        str = "640x480";
      }
    }
#line 214
    opt = str;
#line 215
    str = "windowsize\002";
  }
  {
#line 218
  __cil_tmp13 = strcmp(str, "saveover\220");
  }
#line 218
  if (! __cil_tmp13) {
    {
#line 220
    __cil_tmp14 = strcmp(opt, "new");
    }
#line 220
    if (! __cil_tmp14) {
#line 221
      str = "saveovernew";
#line 222
      opt = "yes";
    } else {
      {
#line 223
      __cil_tmp15 = strcmp(opt, "ask");
      }
#line 223
      if (! __cil_tmp15) {
#line 224
        str = "saveoverask";
#line 225
        opt = "yes";
      } else {
        {
#line 226
        __cil_tmp16 = strcmp(opt, "yes");
        }
#line 226
        if (__cil_tmp16) {
#line 227
          if (src) {
            {
#line 228
            fprintf(stderr, "Option \'%s\' in config file \'%s\' is yes/ask/new only, but got \'%s\'\n",
                    str, src, opt);
            }
          } else {
            {
#line 230
            fprintf(stderr, "Command line option \'--%s\' is yes/ask/new only, but got \'%s\'\n",
                    str, opt);
            }
          }
          {
#line 231
          exit(51);
          }
        }
      }
    }
  }
  {
#line 235
  noflag = 2 * (((int )*(str + 0) == 110 && (int )*(str + 1) == 111) && (int )*(str + 2));
#line 236
  __cil_tmp17 = strlen(str + noflag);
#line 236
  __cil_tmp18 = in_word_set(str + noflag, __cil_tmp17);
#line 236
  cfg = __cil_tmp18;
  }
#line 238
  if (cfg) {
#line 238
    tmp = (uintptr_t )cfg->val;
  } else {
#line 238
    tmp = (unsigned long )0;
  }
#line 238
  uintptr = tmp;
#line 239
  if (uintptr < sizeof(struct cfginfo )) {
#line 239
    tmp___0 = uintptr & (unsigned long )((1 << 2) - 1);
  } else {
#line 239
    tmp___0 = (unsigned long )0;
  }
#line 239
  flags = (unsigned int )tmp___0;
#line 241
  if (! cfg) {
    _L: /* CIL Label */ 
#line 243
    if (src) {
      {
#line 244
      fprintf(stderr, "Unknown option \'%s\' in config file \'%s\'\n\230\001", str,
              src);
      }
    } else {
      {
#line 246
      fprintf(stderr, "Unknown command line option \'--%s\'\n", str);
      }
    }
    {
#line 247
    exit(47);
    }
  } else
#line 241
  if (! (flags & 3U)) {
#line 241
    if (noflag) {
#line 241
      goto _L;
    }
  }
  {
#line 250
  __cil_tmp21 = __builtin_expect((long )(! (! (uintptr >= sizeof(struct cfginfo )))),
                                 (long )0);
  }
#line 250
  if (__cil_tmp21) {
#line 252
    if (src) {
      {
#line 255
      fprintf(stderr, "Unknown option \'%s\' in config file \'%s\'\n\230\001", str,
              src);
#line 256
      exit(49);
      }
    }
#line 258
    if (opt) {
      {
#line 260
      fprintf(stderr, "Command line option \'--%s\' doesn\'t take a value.\n", str);
#line 261
      exit(50);
      }
    }
    {
#line 263
    (*(cfg->val))();
#line 264
    exit(0);
    }
  }
#line 267
  if (flags & 3U) {
#line 269
    flip = ! (! noflag) ^ ! (! (flags & 2U));
#line 270
    if (! opt) {
#line 271
      if (flip) {
#line 271
        tmp___1 = (char const   *)PARSE_NO;
      } else {
#line 271
        tmp___1 = (char const   *)PARSE_YES;
      }
#line 271
      opt = tmp___1;
    } else {
      {
#line 272
      __cil_tmp24 = strcmp("yess\324U", opt);
      }
#line 272
      if (! __cil_tmp24) {
#line 273
        if (flip) {
#line 273
          tmp___2 = (char const   *)PARSE_NO;
        } else {
#line 273
          tmp___2 = (char const   *)PARSE_YES;
        }
#line 273
        opt = tmp___2;
      } else {
        {
#line 274
        __cil_tmp26 = strcmp("no", opt);
        }
#line 274
        if (! __cil_tmp26) {
#line 275
          if (flip) {
#line 275
            tmp___3 = (char const   *)PARSE_YES;
          } else {
#line 275
            tmp___3 = (char const   *)PARSE_NO;
          }
#line 275
          opt = tmp___3;
        } else {
#line 278
          if (src) {
            {
#line 279
            fprintf(stderr, "Option \'%s\' in config file \'%s\' is yes/no only, but got \'%s\'\n",
                    str, src, opt);
            }
          } else {
            {
#line 281
            fprintf(stderr, "Command line option \'--%s\' is yes/no only, but got \'%s\'\n\230\001",
                    str, opt);
            }
          }
          {
#line 282
          exit(51);
          }
        }
      }
    }
  } else
#line 285
  if (! opt) {
    _L___4: /* CIL Label */ 
#line 287
    if (src) {
      {
#line 288
      fprintf(stderr, "Option \'%s\' in config file \'%s\' needs a value\n", str,
              src);
      }
    } else {
      {
#line 290
      fprintf(stderr, "Command line option \'--%s\' needs a value\n", str);
      }
    }
    {
#line 291
    exit(52);
    }
  } else
#line 285
  if (! *opt) {
#line 285
    goto _L___4;
  }
  {
#line 294
  offset = (unsigned int )(uintptr & (unsigned long )(~ ((1 << 2) - 1)));
#line 296
  memcpy(& dupecheck, (char *)tmpcfg + offset, sizeof(char *));
  }
#line 297
  if (dupecheck) {
#line 299
    if (src) {
      {
#line 300
      fprintf(stderr, "Option \'%s\' in config file \'%s\' sets \'%s\' again.\n\037\035s\324U",
              str, src, cfg->name);
      }
    } else {
      {
#line 302
      fprintf(stderr, "Command line option \'--%s\' sets \'%s\' again.\n", str, cfg->name);
      }
    }
    {
#line 303
    exit(53);
    }
  }
  {
#line 306
  memcpy((char *)tmpcfg + offset, & opt, sizeof(char *));
  }
  return;
}
}
#line 53 "/usr/include/SDL_Pango.h"
extern SDLPango_Matrix *MATRIX_WHITE_BACK2 ;
#line 57
extern SDLPango_Matrix *MATRIX_BLACK_BACK2 ;
#line 61
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_BLACK_LETTER2 ;
#line 65
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_WHITE_LETTER2 ;
#line 70
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_TRANSPARENT_LETTER2 ;
#line 138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
static int text_sizes___0[12]  = 
#line 138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
  {      9,      12,      18,      24, 
        36,      48,      56,      64, 
        96,      112,      128,      160};
#line 187 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.h"
char const   *lang_prefixes[130] ;
#line 188
int need_own_font ;
#line 189
int need_right_to_left ;
#line 190
int need_right_to_left_word ;
#line 191
char const   *lang_prefix ;
#line 191
char const   *short_lang_prefix ;
#line 204
w_langs wished_langs[255] ;
#line 208
int get_current_language(void) ;
#line 209
int setup_i18n(char const   *lang , char const   *locale , int *num_wished_langs___0 ) ;
#line 84 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static char const   *problemFonts[2]  = {      "/Library/Fonts//AppleMyungjo.ttf\251",      (char const   *)((void *)0)};
#line 90 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static char const   *problemFontExtensions[2]  = {      ".pfb\376\177",      (char const   *)((void *)0)};
#line 307 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 314 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 


  {
#line 316
  if ((size_t )__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 318
    return ((struct cmsghdr *)0);
  }
#line 320
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))));
#line 322
  if ((unsigned char *)(__cmsg + 1) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  } else
#line 322
  if ((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & (size_t )(~ (sizeof(size_t ) - 1UL))) > (unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen) {
#line 327
    return ((struct cmsghdr *)0);
  }
#line 328
  return (__cmsg);
}
}
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 108
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int __fds[2] ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , __CONST_SOCKADDR_ARG __addr ,
                                              socklen_t __len ) ;
#line 116
extern  __attribute__((__nothrow__)) int getsockname(int __fd , __SOCKADDR_ARG __addr ,
                                                     socklen_t *__len ) ;
#line 126
extern int connect(int __fd , __CONST_SOCKADDR_ARG __addr , socklen_t __len ) ;
#line 130
extern  __attribute__((__nothrow__)) int getpeername(int __fd , __SOCKADDR_ARG __addr ,
                                                     socklen_t *__len ) ;
#line 138
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 145
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 152
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      __CONST_SOCKADDR_ARG __addr , socklen_t __addr_len ) ;
#line 163
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 174
extern ssize_t sendmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 195
extern int sendmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags ) ;
#line 216
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 235
extern int recvmmsg(int __fd , struct mmsghdr *__vmessages , unsigned int __vlen ,
                    int __flags , struct timespec *__tmo ) ;
#line 255
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void *__optval , socklen_t *__optlen ) ;
#line 277
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 296
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 306
extern int accept(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 314
extern int accept4(int __fd , __SOCKADDR_ARG __addr , socklen_t *__addr_len , int __flags ) ;
#line 324
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 329
extern  __attribute__((__nothrow__)) int sockatmark(int __fd ) ;
#line 337
extern  __attribute__((__nothrow__)) int isfdtype(int __fd , int __fdtype ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags ) ;
#line 34
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  ssize_t __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  ssize_t __cil_tmp13 ;

  {
  {
#line 36
  __cil_tmp6 = __builtin_object_size(__buf, 0);
#line 36
  sz = __cil_tmp6;
#line 37
  __cil_tmp8 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 37
  __cil_tmp7 = __builtin_constant_p(__n);
  }
#line 37
  if (__cil_tmp8) {
#line 37
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 38
      __cil_tmp9 = __recv_alias(__fd, __buf, __n, __flags);
      }
#line 38
      return (__cil_tmp9);
    }
  }
  {
#line 39
  __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 39
  __cil_tmp10 = __builtin_constant_p(__n);
  }
#line 39
  if (__cil_tmp11) {
#line 39
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 40
      __cil_tmp12 = __recv_chk_warn(__fd, __buf, __n, sz, __flags);
      }
#line 40
      return (__cil_tmp12);
    }
  }
  {
#line 41
  __cil_tmp13 = __recv_chk(__fd, __buf, __n, sz, __flags);
  }
#line 41
  return (__cil_tmp13);
}
}
#line 44
extern ssize_t __recvfrom_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                              int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 48
extern ssize_t __recvfrom_alias(int __fd , void *__buf , size_t __n , int __flags ,
                                __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 52
extern ssize_t __recvfrom_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                                   int __flags , __SOCKADDR_ARG __addr , socklen_t *__addr_len ) ;
#line 61
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t recvfrom(int __fd , void *__buf , size_t __n , int __flags ,
                                 __SOCKADDR_ARG __addr , socklen_t *__addr_len ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  ssize_t __cil_tmp14 ;
  ssize_t __cil_tmp15 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__buf, 0);
#line 64
  sz = __cil_tmp8;
#line 65
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 65
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 65
  if (__cil_tmp10) {
#line 65
    if ((unsigned long )__n <= sz / sizeof(char )) {
      {
#line 66
      __cil_tmp11 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
      }
#line 66
      return (__cil_tmp11);
    }
  }
  {
#line 67
  __cil_tmp13 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(char ));
  }
  {
#line 67
  __cil_tmp12 = __builtin_constant_p(__n);
  }
#line 67
  if (__cil_tmp13) {
#line 67
    if (! ((unsigned long )__n <= sz / sizeof(char ))) {
      {
#line 68
      __cil_tmp14 = __recvfrom_chk_warn(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
      }
#line 68
      return (__cil_tmp14);
    }
  }
  {
#line 70
  __cil_tmp15 = __recvfrom_chk(__fd, __buf, __n, sz, __flags, __addr, __addr_len);
  }
#line 70
  return (__cil_tmp15);
}
}
#line 398 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h"
extern  __attribute__((__nothrow__)) __ssize_t readahead(int __fd , __off64_t __offset ,
                                                         size_t __count ) ;
#line 406
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned int __flags ) ;
#line 414
extern __ssize_t vmsplice(int __fdout , struct iovec *__iov , size_t __count , unsigned int __flags ) ;
#line 421
extern __ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout ,
                        size_t __len , unsigned int __flags ) ;
#line 429
extern __ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned int __flags ) ;
#line 437
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len ) ;
#line 448
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len ) ;
#line 454
extern  __attribute__((__nothrow__)) int name_to_handle_at(int __dfd , char const   *__name ,
                                                           struct file_handle *__handle ,
                                                           int *__mnt_id , int __flags ) ;
#line 462
extern int open_by_handle_at(int __mountdirfd , struct file_handle *__handle , int __flags ) ;
#line 158 "/usr/include/fcntl.h"
extern int fcntl64(int __fd , int __cmd  , ...) ;
#line 191
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 216
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 237
extern int creat64(char const   *__file , mode_t __mode ) ;
#line 285
extern  __attribute__((__nothrow__)) int posix_fadvise64(int __fd , off64_t __offset ,
                                                         off64_t __len , int __advise ) ;
#line 306
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int __open64_2(char const   *__path , int __oflag ) ;
#line 65
extern int __open64_alias(char const   *__path , int __oflag  , ...) ;
#line 67
extern void __open64_too_many_args(void) ;
#line 69
extern void __open64_missing_mode(void) ;
#line 73
__inline extern int open64(char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int open64(char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
  {
#line 75
  __cil_tmp3 = __builtin_va_arg_pack_len();
  }
#line 75
  if (__cil_tmp3 > 1) {
    {
#line 76
    __open64_too_many_args();
    }
  }
  {
#line 78
  __cil_tmp4 = __builtin_constant_p(__oflag);
  }
#line 78
  if (__cil_tmp4) {
    {
#line 80
    __cil_tmp5 = __builtin_va_arg_pack_len();
    }
#line 80
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 80
      if (__cil_tmp5 < 1) {
        {
#line 82
        __open64_missing_mode();
#line 83
        __cil_tmp6 = __open64_2(__path, __oflag);
        }
#line 83
        return (__cil_tmp6);
      }
    } else
#line 80
    if ((__oflag & 4259840) == 4259840) {
#line 80
      goto _L;
    }
    {
#line 85
    __cil_tmp7 = __builtin_va_arg_pack();
#line 85
    __cil_tmp8 = __open64_alias(__path, __oflag, __cil_tmp7);
    }
#line 85
    return (__cil_tmp8);
  }
  {
#line 88
  __cil_tmp9 = __builtin_va_arg_pack_len();
  }
#line 88
  if (__cil_tmp9 < 1) {
    {
#line 89
    __cil_tmp10 = __open64_2(__path, __oflag);
    }
#line 89
    return (__cil_tmp10);
  }
  {
#line 91
  __cil_tmp11 = __builtin_va_arg_pack();
#line 91
  __cil_tmp12 = __open64_alias(__path, __oflag, __cil_tmp11);
  }
#line 91
  return (__cil_tmp12);
}
}
#line 140
extern int __openat64_2(int __fd , char const   *__path , int __oflag ) ;
#line 142
extern int __openat64_alias(int __fd , char const   *__path , int __oflag  , ...) ;
#line 145
extern void __openat64_too_many_args(void) ;
#line 147
extern void __openat64_missing_mode(void) ;
#line 151
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...)  __attribute__((__gnu_inline__)) ;
#line 151 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int openat64(int __fd , char const   *__path , int __oflag  , ...) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 153
  __cil_tmp4 = __builtin_va_arg_pack_len();
  }
#line 153
  if (__cil_tmp4 > 1) {
    {
#line 154
    __openat64_too_many_args();
    }
  }
  {
#line 156
  __cil_tmp5 = __builtin_constant_p(__oflag);
  }
#line 156
  if (__cil_tmp5) {
    {
#line 158
    __cil_tmp6 = __builtin_va_arg_pack_len();
    }
#line 158
    if ((__oflag & 64) != 0) {
      _L: /* CIL Label */ 
#line 158
      if (__cil_tmp6 < 1) {
        {
#line 160
        __openat64_missing_mode();
#line 161
        __cil_tmp7 = __openat64_2(__fd, __path, __oflag);
        }
#line 161
        return (__cil_tmp7);
      }
    } else
#line 158
    if ((__oflag & 4259840) == 4259840) {
#line 158
      goto _L;
    }
    {
#line 163
    __cil_tmp8 = __builtin_va_arg_pack();
#line 163
    __cil_tmp9 = __openat64_alias(__fd, __path, __oflag, __cil_tmp8);
    }
#line 163
    return (__cil_tmp9);
  }
  {
#line 166
  __cil_tmp10 = __builtin_va_arg_pack_len();
  }
#line 166
  if (__cil_tmp10 < 1) {
    {
#line 167
    __cil_tmp11 = __openat64_2(__fd, __path, __oflag);
    }
#line 167
    return (__cil_tmp11);
  }
  {
#line 169
  __cil_tmp12 = __builtin_va_arg_pack();
#line 169
  __cil_tmp13 = __openat64_alias(__fd, __path, __oflag, __cil_tmp12);
  }
#line 169
  return (__cil_tmp13);
}
}
#line 54 "/usr/include/x86_64-linux-gnu/sys/poll.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 64
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
extern int __poll_alias(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 28
extern int __poll_chk(struct pollfd *__fds , nfds_t __nfds , int __timeout , unsigned long __fdslen ) ;
#line 31
extern int __poll_chk_warn(struct pollfd *__fds , nfds_t __nfds , int __timeout ,
                           unsigned long __fdslen ) ;
#line 37
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  int __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 39
  __cil_tmp7 = __builtin_object_size(__fds, 1);
  }
  {
#line 39
  __cil_tmp5 = __builtin_object_size(__fds, 1);
#line 39
  __cil_tmp6 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp5 / sizeof(*__fds));
  }
  {
#line 39
  __cil_tmp4 = __builtin_constant_p(__nfds);
  }
#line 39
  if (__cil_tmp6 && (unsigned long )__nfds <= __cil_tmp7 / sizeof(*__fds)) {
    {
#line 39
    __cil_tmp8 = __poll_alias(__fds, __nfds, __timeout);
#line 39
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 39
    __cil_tmp12 = __builtin_object_size(__fds, 1);
    }
    {
#line 39
    __cil_tmp10 = __builtin_object_size(__fds, 1);
#line 39
    __cil_tmp11 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp10 / sizeof(*__fds));
    }
    {
#line 39
    __cil_tmp9 = __builtin_constant_p(__nfds);
    }
#line 39
    if (__cil_tmp11 && ! ((unsigned long )__nfds <= __cil_tmp12 / sizeof(*__fds))) {
      {
#line 39
      __cil_tmp13 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp14 = __poll_chk_warn(__fds, __nfds, __timeout, __cil_tmp13);
#line 39
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 39
      __cil_tmp15 = __builtin_object_size(__fds, 1);
#line 39
      __cil_tmp16 = __poll_chk(__fds, __nfds, __timeout, __cil_tmp15);
#line 39
      tmp = __cil_tmp16;
      }
    }
#line 39
    tmp___0 = tmp;
  }
#line 39
  return (tmp___0);
}
}
#line 46
extern int __ppoll_alias(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                         __sigset_t *__ss ) ;
#line 49
extern int __ppoll_chk(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                       __sigset_t *__ss , unsigned long __fdslen ) ;
#line 53
extern int __ppoll_chk_warn(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                            __sigset_t *__ss , unsigned long __fdslen ) ;
#line 61
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss )  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/poll2.h"
__inline extern int ppoll(struct pollfd *__fds , nfds_t __nfds , struct timespec *__timeout ,
                          __sigset_t *__ss ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  int __cil_tmp17 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  __cil_tmp8 = __builtin_object_size(__fds, 1);
  }
  {
#line 64
  __cil_tmp6 = __builtin_object_size(__fds, 1);
#line 64
  __cil_tmp7 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp6 / sizeof(*__fds));
  }
  {
#line 64
  __cil_tmp5 = __builtin_constant_p(__nfds);
  }
#line 64
  if (__cil_tmp7 && (unsigned long )__nfds <= __cil_tmp8 / sizeof(*__fds)) {
    {
#line 64
    __cil_tmp9 = __ppoll_alias(__fds, __nfds, __timeout, __ss);
#line 64
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 64
    __cil_tmp13 = __builtin_object_size(__fds, 1);
    }
    {
#line 64
    __cil_tmp11 = __builtin_object_size(__fds, 1);
#line 64
    __cil_tmp12 = __builtin_constant_p((unsigned long )__nfds <= __cil_tmp11 / sizeof(*__fds));
    }
    {
#line 64
    __cil_tmp10 = __builtin_constant_p(__nfds);
    }
#line 64
    if (__cil_tmp12 && ! ((unsigned long )__nfds <= __cil_tmp13 / sizeof(*__fds))) {
      {
#line 64
      __cil_tmp14 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp15 = __ppoll_chk_warn(__fds, __nfds, __timeout, __ss, __cil_tmp14);
#line 64
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 64
      __cil_tmp16 = __builtin_object_size(__fds, 1);
#line 64
      __cil_tmp17 = __ppoll_chk(__fds, __nfds, __timeout, __ss, __cil_tmp16);
#line 64
      tmp = __cil_tmp17;
      }
    }
#line 64
    tmp___0 = tmp;
  }
#line 64
  return (tmp___0);
}
}
#line 82 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern  __attribute__((__nothrow__)) int clone(int (*__fn)(void * ) , void *__child_stack ,
                                               int __flags , void *__arg  , ...) ;
#line 86
extern  __attribute__((__nothrow__)) int unshare(int __flags ) ;
#line 89
extern  __attribute__((__nothrow__)) int sched_getcpu(void) ;
#line 92
extern  __attribute__((__nothrow__)) int getcpu(unsigned int * , unsigned int * ) ;
#line 95
extern  __attribute__((__nothrow__)) int setns(int __fd , int __nstype ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
extern  __attribute__((__nothrow__)) int __sched_cpucount(size_t __setsize , cpu_set_t *__setp ) ;
#line 119
extern  __attribute__((__nothrow__)) cpu_set_t *__sched_cpualloc(size_t __count ) ;
#line 120
extern  __attribute__((__nothrow__)) void __sched_cpufree(cpu_set_t *__set ) ;
#line 54 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param *__param ) ;
#line 58
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 61
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param *__param ) ;
#line 65
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 68
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 71
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 74
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 78
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 130
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 134
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int prctl(int __option  , ...) ;
#line 146 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int font_scanner_pid ;
#line 154
static int num_font_families_max ;
#line 161 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
unsigned int text_size  =    (unsigned int )4;
#line 166
static void reliable_read(int fd , void *buf , size_t count ) ;
#line 213 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
void TuxPaint_Font_CloseFont(TuxPaint_Font *tpf ) 
{ 


  {
#line 218
  if (! tpf) {
#line 219
    return;
  }
#line 225
  if (tpf->typ == 0) {
#line 226
    if (tpf->pango_context) {
      {
#line 229
      SDLPango_FreeContext(tpf->pango_context);
#line 231
      tpf->pango_context = (SDLPango_Context *)((void *)0);
      }
    }
  }
#line 239
  if (tpf->typ == 1) {
#line 240
    if (tpf->ttf_font) {
      {
#line 242
      TTF_CloseFont(tpf->ttf_font);
#line 243
      tpf->ttf_font = (TTF_Font *)((void *)0);
      }
    }
  }
#line 246
  if (tpf->desc != (void *)0) {
    {
#line 248
    free(tpf->desc);
#line 249
    tpf->desc = (char *)((void *)0);
    }
  }
  {
#line 252
  free(tpf);
  }
  return;
}
}
#line 255 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
TuxPaint_Font *TuxPaint_Font_OpenFont(char const   *pangodesc , char const   *ttffilename ,
                                      int size ) 
{ 
  TTF_Font *ttf_font ;
  TuxPaint_Font *tpf ;
  char *familyname ;
  int i ;
  char desc[1024] ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  SDLPango_Context *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;
  TTF_Font *__cil_tmp16 ;
  char *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 258
  tpf = (TuxPaint_Font *)((void *)0);
#line 271
  if (pangodesc != (void *)0) {
#line 271
    if ((int )*(pangodesc + 0) != 0) {
      {
#line 273
      __cil_tmp9 = malloc(sizeof(TuxPaint_Font ));
#line 273
      tpf = (TuxPaint_Font *)__cil_tmp9;
#line 274
      tpf->typ = 0;
#line 275
      snprintf((char *)desc, sizeof(desc), "%s %dR\002", pangodesc, (size * 3) / 4);
#line 276
      tpf->desc = strdup((char const   *)((char *)desc));
#line 282
      tpf->pango_context = SDLPango_CreateContext_GivenFontDesc((char const   *)((char *)desc));
      }
#line 283
      if (tpf->pango_context == (void *)0) {
        {
#line 288
        free(tpf);
#line 289
        tpf = (TuxPaint_Font *)((void *)0);
        }
      } else {
#line 292
        tpf->height = size;
      }
#line 299
      return (tpf);
    }
  }
#line 306
  if (ttffilename != (void *)0) {
#line 306
    if ((int )*(ttffilename + 0) != 0) {
#line 313
      i = 0;
      {
#line 314
      while (1) {
        while_continue: /* CIL Label */ ;
#line 314
        if (! (problemFonts[i] != (void *)0)) {
#line 314
          goto while_break;
        }
        {
#line 316
        __cil_tmp12 = i;
#line 316
        i ++;
#line 316
        __cil_tmp13 = strcmp(ttffilename, problemFonts[__cil_tmp12]);
        }
#line 316
        if (! __cil_tmp13) {
#line 321
          return ((TuxPaint_Font *)((void *)0));
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 325
      i = 0;
      {
#line 326
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 326
        if (! (problemFontExtensions[i] != (void *)0)) {
#line 326
          goto while_break___0;
        }
        {
#line 328
        __cil_tmp14 = i;
#line 328
        i ++;
#line 328
        __cil_tmp15 = strstr(ttffilename, problemFontExtensions[__cil_tmp14]);
        }
#line 328
        if (__cil_tmp15) {
#line 333
          return ((TuxPaint_Font *)((void *)0));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 337
      ttf_font = TTF_OpenFont(ttffilename, size);
      }
#line 339
      if (ttf_font == (void *)0) {
        {
#line 340
        fprintf(stderr, "Cannot open TTF font \'%s\' (size %d)\n", ttffilename, size);
        }
#line 341
        return ((TuxPaint_Font *)((void *)0));
      }
      {
#line 344
      familyname = TTF_FontFaceFamilyName(ttf_font);
#line 374
      __cil_tmp18 = malloc(sizeof(TuxPaint_Font ));
#line 374
      tpf = (TuxPaint_Font *)__cil_tmp18;
#line 375
      tpf->typ = 1;
#line 376
      tpf->ttf_font = ttf_font;
#line 377
      tpf->desc = strdup(ttffilename);
#line 382
      tpf->height = TTF_FontHeight(tpf->ttf_font);
      }
#line 389
      return (tpf);
    }
  }
  {
#line 392
  fprintf(stderr, "TuxPaint_Font_OpenFont() called with no loadable font\n");
  }
#line 393
  return ((TuxPaint_Font *)((void *)0));
}
}
#line 399 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
void reliable_write(int fd , void const   *buf , size_t count ) 
{ 
  struct pollfd p ;
  ssize_t rc ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  struct pollfd tmp ;

  {
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    __cil_tmp6 = write(fd, buf, count);
#line 405
    rc = __cil_tmp6;
    }
#line 407
    if (rc == -1L) {
      {
#line 409
      __cil_tmp7 = __errno_location();
      }
      {
#line 414
      if (*__cil_tmp7 == 28) {
#line 414
        goto case_28;
      }
#line 414
      if (*__cil_tmp7 == 11) {
#line 414
        goto case_28;
      }
#line 421
      if (*__cil_tmp7 == 4) {
#line 421
        goto case_4;
      }
#line 411
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 412
      return;
      case_28: /* CIL Label */ 
      case_11: /* CIL Label */ ;
#line 416
      tmp.fd = fd;
#line 416
      tmp.events = (short )4;
      {
#line 416
      tmp.revents = (short )0;
#line 416
      p = tmp;
#line 419
      poll(& p, (nfds_t )1, - 1);
      }
      case_4: /* CIL Label */ 
#line 422
      goto while_continue;
      switch_break: /* CIL Label */ ;
      }
    }
#line 425
    buf += rc;
#line 426
    count -= (unsigned long )rc;
#line 403
    if (! count) {
#line 403
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 432 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void reliable_read(int fd , void *buf , size_t count ) 
{ 
  struct pollfd p ;
  ssize_t rc ;
  ssize_t __cil_tmp6 ;
  int *__cil_tmp7 ;
  struct pollfd tmp ;

  {
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 438
    __cil_tmp6 = read(fd, buf, count);
#line 438
    rc = __cil_tmp6;
    }
#line 440
    if (rc == -1L) {
      {
#line 442
      __cil_tmp7 = __errno_location();
      }
      {
#line 446
      if (*__cil_tmp7 == 11) {
#line 446
        goto case_11;
      }
#line 453
      if (*__cil_tmp7 == 4) {
#line 453
        goto case_4;
      }
#line 444
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 445
      return;
      case_11: /* CIL Label */ ;
#line 448
      tmp.fd = fd;
#line 448
      tmp.events = (short )1;
      {
#line 448
      tmp.revents = (short )0;
#line 448
      p = tmp;
#line 451
      poll(& p, (nfds_t )1, - 1);
      }
      case_4: /* CIL Label */ 
#line 454
      goto while_continue;
      switch_break: /* CIL Label */ ;
      }
    }
#line 457
    if (rc == 0L) {
#line 458
      goto while_break;
    }
#line 459
    buf += rc;
#line 460
    count -= (unsigned long )rc;
#line 436
    if (! count) {
#line 436
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 467 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void groupfonts_range(style_info **base , int count ) 
{ 
  int boldcounts[4] ;
  int boldmap[4] ;
  int i ;
  int boldmax ;
  int boldmin ;
  int bolduse ;
  int spot ;
  family_info *fi ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  long __cil_tmp15 ;
  int boldmid ;
  int zmin ;
  int zmid ;
  int zmax ;
  int tmp ;
  int __cil_tmp21 ;
  int claimed_bold ;
  int claimed_norm ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  int __cil_tmp29 ;
  int b ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 469
  boldcounts[0] = 0;
#line 469
  boldcounts[1] = 0;
#line 469
  boldcounts[2] = 0;
#line 469
  boldcounts[3] = 0;
#line 470
  boldmap[0] = - 1;
#line 470
  boldmap[1] = - 1;
#line 470
  boldmap[2] = - 1;
#line 470
  boldmap[3] = - 1;
#line 491
  i = count;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    __cil_tmp11 = i;
#line 492
    i --;
#line 492
    if (! __cil_tmp11) {
#line 492
      goto while_break;
    }
#line 493
    (boldcounts[(*(base + i))->boldness]) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  boldmax = (*(base + 0))->boldness;
#line 496
  boldmin = (*(base + 0))->boldness;
#line 497
  bolduse = 0;
#line 499
  i = 4;
  {
#line 500
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 500
    __cil_tmp13 = i;
#line 500
    i --;
#line 500
    if (! __cil_tmp13) {
#line 500
      goto while_break___0;
    }
#line 502
    if (! boldcounts[i]) {
#line 503
      goto while_continue___0;
    }
#line 504
    if (i > boldmax) {
#line 505
      boldmax = i;
    }
#line 506
    if (i < boldmin) {
#line 507
      boldmin = i;
    }
#line 508
    bolduse ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 510
  __cil_tmp15 = __builtin_expect((long )(! (! (bolduse <= 2))), (long )1);
  }
#line 510
  if (__cil_tmp15) {
#line 514
    boldmap[boldmax] = 1;
#line 515
    boldmap[boldmin] = 0;
  } else
#line 517
  if (count == 3) {
#line 520
    zmin = 0;
#line 520
    zmid = 0;
#line 520
    zmax = 0;
#line 522
    boldmap[boldmax] = 1;
#line 523
    boldmap[boldmin] = 0;
#line 524
    if (boldcounts[boldmin + 1]) {
#line 524
      tmp = boldmin + 1;
    } else {
#line 524
      tmp = boldmin + 2;
    }
#line 524
    boldmid = tmp;
#line 526
    i = 3;
    {
#line 527
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 527
      __cil_tmp21 = i;
#line 527
      i --;
#line 527
      if (! __cil_tmp21) {
#line 527
        goto while_break___1;
      }
#line 529
      if ((*(base + i))->boldness == boldmin) {
#line 530
        zmin = (*(base + i))->italic;
      }
#line 531
      if ((*(base + i))->boldness == boldmid) {
#line 532
        zmid = (*(base + i))->italic;
      }
#line 533
      if ((*(base + i))->boldness == boldmax) {
#line 534
        zmax = (*(base + i))->italic;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 536
    if (zmin != zmid) {
#line 537
      boldmap[boldmid] = 0;
    } else
#line 538
    if (zmid != zmax) {
#line 539
      boldmap[boldmid] = 1;
    } else
#line 540
    if (boldmin == 0) {
#line 540
      if (boldmid == 1) {
#line 542
        boldmap[0] = - 1;
#line 543
        boldmap[1] = 0;
      }
    }
  } else {
#line 548
    claimed_bold = boldcounts[3];
#line 549
    claimed_norm = boldcounts[1];
#line 555
    boldmap[3] = 1;
#line 558
    boldmap[1] = 0;
#line 561
    if (claimed_bold < 2) {
#line 563
      boldmap[2] = 1;
#line 564
      claimed_bold += boldcounts[2];
    } else
#line 566
    if (claimed_norm < 2) {
#line 568
      boldmap[2] = 0;
#line 569
      claimed_norm += boldcounts[2];
    }
#line 573
    if (claimed_norm < 2) {
#line 575
      boldmap[0] = 0;
    }
  }
#line 580
  if (num_font_families == num_font_families_max) {
    {
#line 582
    num_font_families_max = (num_font_families_max * 5) / 4 + 30;
#line 583
    user_font_families = (family_info **)realloc(user_font_families, (unsigned long )num_font_families_max * sizeof(*user_font_families));
    }
  }
  {
#line 586
  fi = (family_info *)calloc((unsigned long )1, sizeof(*fi));
#line 587
  __cil_tmp26 = num_font_families;
#line 587
  num_font_families ++;
#line 587
  *(user_font_families + __cil_tmp26) = fi;
#line 588
  fi->directory = strdup((char const   *)(*(base + 0))->directory);
#line 589
  fi->family = strdup((char const   *)(*(base + 0))->family);
#line 590
  fi->score = (*(base + 0))->truetype + (*(base + 0))->score;
#line 591
  i = count;
  }
  {
#line 592
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 592
    __cil_tmp29 = i;
#line 592
    i --;
#line 592
    if (! __cil_tmp29) {
#line 592
      goto while_break___2;
    }
#line 594
    b = boldmap[(*(base + i))->boldness];
#line 596
    if (b == -1) {
#line 602
      goto while_continue___2;
    }
#line 604
    if (b) {
#line 604
      tmp___0 = 1;
    } else {
#line 604
      tmp___0 = 0;
    }
#line 604
    spot = tmp___0;
#line 605
    if ((*(base + i))->italic) {
#line 605
      tmp___1 = 2;
    } else {
#line 605
      tmp___1 = 0;
    }
#line 605
    spot += tmp___1;
#line 606
    if (fi->filename[spot]) {
#line 614
      goto while_continue___2;
    }
    {
#line 616
    fi->filename[spot] = strdup((char const   *)(*(base + i))->filename);
#line 617
    fi->score += 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 619
  if (! fi->filename[0]) {
#line 619
    if (! fi->filename[1]) {
#line 621
      fi->filename[0] = fi->filename[2];
#line 622
      fi->filename[2] = (char *)((void *)0);
#line 623
      fi->filename[1] = fi->filename[3];
#line 624
      fi->filename[3] = (char *)((void *)0);
    }
  }
#line 626
  if (! fi->filename[0]) {
#line 626
    if (! fi->filename[2]) {
#line 628
      fi->filename[0] = fi->filename[1];
#line 629
      fi->filename[1] = (char *)((void *)0);
#line 630
      fi->filename[2] = fi->filename[3];
#line 631
      fi->filename[3] = (char *)((void *)0);
    }
  }
#line 633
  if (! fi->filename[0]) {
    {
#line 635
    fi->filename[0] = strdup((char const   *)fi->filename[1]);
    }
  }
  return;
}
}
#line 645 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int compar_fontgroup(void const   *v1 , void const   *v2 ) 
{ 
  style_info *s1 ;
  style_info *s2 ;
  int rc ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 647
  s1 = *((style_info **)v1);
#line 648
  s2 = *((style_info **)v2);
#line 651
  rc = strcmp((char const   *)s1->directory, (char const   *)s2->directory);
  }
#line 652
  if (rc) {
#line 653
    return (rc);
  }
#line 655
  rc = s1->truetype - s2->truetype;
#line 656
  if (rc) {
#line 657
    return (rc);
  }
  {
#line 659
  __cil_tmp7 = strcmp((char const   *)s1->family, (char const   *)s2->family);
  }
#line 659
  return (__cil_tmp7);
}
}
#line 664 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int compar_fontkiller(void const   *v1 , void const   *v2 ) 
{ 
  family_info *f1 ;
  family_info *f2 ;
  int rc ;
  int __cil_tmp6 ;

  {
  {
#line 666
  f1 = *((family_info **)v1);
#line 667
  f2 = *((family_info **)v2);
#line 670
  rc = strcmp((char const   *)f1->family, (char const   *)f2->family);
  }
#line 671
  if (rc) {
#line 672
    return (rc);
  }
#line 674
  return (f1->score - f2->score);
}
}
#line 679 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int compar_fontscore(void const   *v1 , void const   *v2 ) 
{ 
  family_info *f1 ;
  family_info *f2 ;

  {
#line 681
  f1 = *((family_info **)v1);
#line 682
  f2 = *((family_info **)v2);
#line 684
  return (f2->score - f1->score);
}
}
#line 693 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void parse_font_style(style_info *si ) 
{ 
  int have_light ;
  int have_demi ;
  int have_bold ;
  int have_medium ;
  int have_black ;
  int have_heavy ;
  int stumped ;
  char *sp ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  int __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  int __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  size_t len ;
  unsigned long __cil_tmp26 ;
  char *name ;
  unsigned long __cil_tmp28 ;
  void *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  unsigned long __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  unsigned long __cil_tmp40 ;
  int __cil_tmp41 ;
  unsigned long __cil_tmp42 ;
  unsigned long __cil_tmp43 ;
  int __cil_tmp44 ;
  unsigned long __cil_tmp45 ;
  unsigned long __cil_tmp46 ;
  int __cil_tmp47 ;
  unsigned long __cil_tmp48 ;
  unsigned long __cil_tmp49 ;
  int __cil_tmp50 ;
  unsigned long __cil_tmp51 ;
  unsigned long __cil_tmp52 ;
  int __cil_tmp53 ;
  unsigned long __cil_tmp54 ;
  unsigned long __cil_tmp55 ;
  int __cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  unsigned long __cil_tmp58 ;
  int __cil_tmp59 ;
  unsigned long __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  int __cil_tmp62 ;
  unsigned long __cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
#line 695
  have_light = 0;
#line 696
  have_demi = 0;
#line 697
  have_bold = 0;
#line 698
  have_medium = 0;
#line 699
  have_black = 0;
#line 700
  have_heavy = 0;
#line 702
  stumped = 0;
#line 703
  sp = si->style;
#line 705
  si->italic = 0;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! *sp) {
#line 708
      goto while_break;
    }
#line 710
    if ((int )*sp == 32) {
#line 712
      sp ++;
#line 713
      goto while_continue;
    }
    {
#line 715
    __cil_tmp11 = strlen("Bold");
#line 715
    __cil_tmp12 = strncasecmp((char const   *)sp, "Bold", __cil_tmp11);
    }
#line 715
    if (! __cil_tmp12) {
      {
#line 717
      __cil_tmp13 = strlen("Bold");
      }
#line 717
      sp += __cil_tmp13;
#line 718
      have_bold = 1;
#line 719
      goto while_continue;
    }
    {
#line 721
    __cil_tmp14 = strlen("Regular");
#line 721
    __cil_tmp15 = strncasecmp((char const   *)sp, "Regular", __cil_tmp14);
    }
#line 721
    if (! __cil_tmp15) {
      {
#line 723
      __cil_tmp16 = strlen("Regular");
      }
#line 723
      sp += __cil_tmp16;
#line 724
      goto while_continue;
    }
    {
#line 726
    __cil_tmp17 = strlen("Italic");
#line 726
    __cil_tmp18 = strncasecmp((char const   *)sp, "Italic", __cil_tmp17);
    }
#line 726
    if (! __cil_tmp18) {
      {
#line 728
      __cil_tmp19 = strlen("Italic");
      }
#line 728
      sp += __cil_tmp19;
#line 729
      si->italic = 1;
#line 730
      goto while_continue;
    }
    {
#line 732
    __cil_tmp20 = strlen("Oblique");
#line 732
    __cil_tmp21 = strncasecmp((char const   *)sp, "Oblique", __cil_tmp20);
    }
#line 732
    if (! __cil_tmp21) {
      {
#line 734
      __cil_tmp22 = strlen("Oblique");
      }
#line 734
      sp += __cil_tmp22;
#line 735
      si->italic = 1;
#line 736
      goto while_continue;
    }
    {
#line 739
    __cil_tmp23 = strlen("Condensed");
#line 739
    __cil_tmp24 = strncasecmp((char const   *)sp, "Condensed", __cil_tmp23);
    }
#line 739
    if (! __cil_tmp24) {
      {
#line 741
      __cil_tmp26 = strlen((char const   *)si->family);
#line 741
      len = __cil_tmp26;
#line 742
      __cil_tmp28 = strlen(" Condensed");
#line 742
      __cil_tmp29 = malloc((len + __cil_tmp28) + 1UL);
#line 742
      name = __cil_tmp29;
#line 744
      __cil_tmp30 = strlen("Condensed");
      }
      {
#line 744
      sp += __cil_tmp30;
#line 745
      memcpy(name, si->family, len);
#line 746
      strcpy(name + len, " Condensed");
#line 747
      free(si->family);
#line 748
      si->family = name;
      }
#line 749
      goto while_continue;
    }
    {
#line 751
    __cil_tmp31 = strlen("Light");
#line 751
    __cil_tmp32 = strncasecmp((char const   *)sp, "Light", __cil_tmp31);
    }
#line 751
    if (! __cil_tmp32) {
      {
#line 753
      __cil_tmp33 = strlen("Light");
      }
#line 753
      sp += __cil_tmp33;
#line 754
      have_light = 1;
#line 755
      goto while_continue;
    }
    {
#line 757
    __cil_tmp34 = strlen("Medium");
#line 757
    __cil_tmp35 = strncasecmp((char const   *)sp, "Medium", __cil_tmp34);
    }
#line 757
    if (! __cil_tmp35) {
      {
#line 759
      __cil_tmp36 = strlen("Medium");
      }
#line 759
      sp += __cil_tmp36;
#line 760
      have_medium = 1;
#line 761
      goto while_continue;
    }
    {
#line 763
    __cil_tmp37 = strlen("Demi");
#line 763
    __cil_tmp38 = strncasecmp((char const   *)sp, "Demi", __cil_tmp37);
    }
#line 763
    if (! __cil_tmp38) {
      {
#line 765
      __cil_tmp39 = strlen("Demi");
      }
#line 765
      sp += __cil_tmp39;
#line 766
      have_demi = 1;
#line 767
      goto while_continue;
    }
    {
#line 769
    __cil_tmp40 = strlen("Heavy");
#line 769
    __cil_tmp41 = strncasecmp((char const   *)sp, "Heavy", __cil_tmp40);
    }
#line 769
    if (! __cil_tmp41) {
      {
#line 771
      __cil_tmp42 = strlen("Heavy");
      }
#line 771
      sp += __cil_tmp42;
#line 772
      have_heavy = 1;
#line 773
      goto while_continue;
    }
    {
#line 775
    __cil_tmp43 = strlen("Normal");
#line 775
    __cil_tmp44 = strncasecmp((char const   *)sp, "Normal", __cil_tmp43);
    }
#line 775
    if (! __cil_tmp44) {
      {
#line 777
      __cil_tmp45 = strlen("Normal");
      }
#line 777
      sp += __cil_tmp45;
#line 778
      goto while_continue;
    }
    {
#line 780
    __cil_tmp46 = strlen("Black");
#line 780
    __cil_tmp47 = strncasecmp((char const   *)sp, "Black", __cil_tmp46);
    }
#line 780
    if (! __cil_tmp47) {
      {
#line 782
      __cil_tmp48 = strlen("Black");
      }
#line 782
      sp += __cil_tmp48;
#line 783
      have_black = 1;
#line 784
      goto while_continue;
    }
    {
#line 786
    __cil_tmp49 = strlen("Roman");
#line 786
    __cil_tmp50 = strncasecmp((char const   *)sp, "Roman", __cil_tmp49);
    }
#line 786
    if (! __cil_tmp50) {
      {
#line 788
      __cil_tmp51 = strlen("Roman");
      }
#line 788
      sp += __cil_tmp51;
#line 789
      goto while_continue;
    }
    {
#line 791
    __cil_tmp52 = strlen("Book");
#line 791
    __cil_tmp53 = strncasecmp((char const   *)sp, "Book", __cil_tmp52);
    }
#line 791
    if (! __cil_tmp53) {
      {
#line 793
      __cil_tmp54 = strlen("Book");
      }
#line 793
      sp += __cil_tmp54;
#line 794
      goto while_continue;
    }
    {
#line 796
    __cil_tmp55 = strlen("Chancery\220");
#line 796
    __cil_tmp56 = strncasecmp((char const   *)sp, "Chancery\230", __cil_tmp55);
    }
#line 796
    if (! __cil_tmp56) {
      {
#line 798
      __cil_tmp57 = strlen("Chancery\220");
      }
#line 798
      sp += __cil_tmp57;
#line 799
      si->italic = 1;
#line 800
      goto while_continue;
    }
    {
#line 802
    __cil_tmp58 = strlen("Thin");
#line 802
    __cil_tmp59 = strncasecmp((char const   *)sp, "Thin", __cil_tmp58);
    }
#line 802
    if (! __cil_tmp59) {
      {
#line 804
      __cil_tmp60 = strlen("Thin");
      }
#line 804
      sp += __cil_tmp60;
#line 805
      have_light = 1;
#line 806
      goto while_continue;
    }
    {
#line 808
    __cil_tmp61 = strlen("LR");
#line 808
    __cil_tmp62 = strncmp((char const   *)sp, "LR", __cil_tmp61);
    }
#line 808
    if (! __cil_tmp62) {
      {
#line 810
      __cil_tmp63 = strlen("LR");
      }
#line 810
      sp += __cil_tmp63;
#line 811
      goto while_continue;
    }
#line 814
    if (! stumped) {
#line 816
      stumped = 1;
    }
#line 822
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 826
  if (have_demi) {
#line 827
    si->boldness = 2;
  } else
#line 826
  if (have_medium) {
#line 827
    si->boldness = 2;
  } else
#line 828
  if (have_bold) {
#line 829
    si->boldness = 3;
  } else
#line 828
  if (have_black) {
#line 829
    si->boldness = 3;
  } else
#line 828
  if (have_heavy) {
#line 829
    si->boldness = 3;
  } else
#line 830
  if (have_light) {
#line 831
    si->boldness = 0;
  } else {
#line 833
    si->boldness = 1;
  }
  {
#line 836
  __cil_tmp66 = strcasestr((char const   *)si->filename, ".otf");
  }
  {
#line 836
  __cil_tmp65 = strcasestr((char const   *)si->filename, ".ttf");
#line 836
  si->truetype = ! (! __cil_tmp65) || ! (! __cil_tmp66);
  }
  return;
}
}
#line 840 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void dupe_markdown_range(family_info **base , int count ) 
{ 
  int bestscore ;
  int bestslot ;
  int i ;
  int __cil_tmp6 ;
  int score ;
  int __cil_tmp8 ;

  {
#line 842
  bestscore = - 999;
#line 843
  bestslot = 0;
#line 844
  i = count;
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    __cil_tmp6 = i;
#line 846
    i --;
#line 846
    if (! __cil_tmp6) {
#line 846
      goto while_break;
    }
#line 848
    score = (*(base + i))->score;
#line 850
    if (score <= bestscore) {
#line 851
      goto while_continue;
    }
#line 852
    bestscore = score;
#line 853
    bestslot = i;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  i = count;
  {
#line 856
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 856
    __cil_tmp8 = i;
#line 856
    i --;
#line 856
    if (! __cil_tmp8) {
#line 856
      goto while_break___0;
    }
#line 858
    if (i == bestslot) {
#line 859
      goto while_continue___0;
    }
#line 860
    (*(base + i))->score = - 999;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 865 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void groupfonts(void) 
{ 
  char **cpp ;
  int i ;
  int low ;
  int __cil_tmp4 ;
  int high ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int high___0 ;
  int __cil_tmp9 ;

  {
#line 868
  i = num_font_styles;
#line 869
  low = 0;
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
#line 871
    __cil_tmp4 = i;
#line 871
    i --;
#line 871
    if (! __cil_tmp4) {
#line 871
      goto while_break;
    }
    {
#line 872
    parse_font_style(*(user_font_styles + i));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 874
  qsort(user_font_styles, (size_t )num_font_styles, sizeof(*(user_font_styles + 0)),
        & compar_fontgroup);
  }
  {
#line 878
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 878
    if (! 1) {
#line 878
      goto while_break___0;
    }
#line 880
    high = low;
#line 882
    if (low >= num_font_styles) {
#line 883
      goto while_break___0;
    }
    {
#line 884
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 884
      if (! 1) {
#line 884
        goto while_break___1;
      }
#line 886
      high ++;
#line 886
      if (high >= num_font_styles) {
#line 887
        goto while_break___1;
      }
      {
#line 888
      __cil_tmp6 = compar_fontgroup(user_font_styles + low, user_font_styles + high);
      }
#line 888
      if (__cil_tmp6) {
#line 889
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 891
    groupfonts_range(user_font_styles + low, high - low);
#line 892
    low = high;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 895
  i = num_font_styles;
  {
#line 896
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 896
    __cil_tmp7 = i;
#line 896
    i --;
#line 896
    if (! __cil_tmp7) {
#line 896
      goto while_break___2;
    }
    {
#line 898
    free((*(user_font_styles + i))->filename);
#line 899
    free((*(user_font_styles + i))->directory);
#line 900
    free((*(user_font_styles + i))->family);
#line 901
    free((*(user_font_styles + i))->style);
#line 902
    free(*(user_font_styles + i));
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 904
  free(user_font_styles);
#line 905
  user_font_styles = (style_info **)((void *)0);
#line 907
  qsort(user_font_families, (size_t )num_font_families, sizeof(*(user_font_families + 0)),
        & compar_fontkiller);
#line 908
  low = 0;
  }
  {
#line 909
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 909
    if (! 1) {
#line 909
      goto while_break___3;
    }
#line 911
    high___0 = low;
#line 913
    if (low >= num_font_families) {
#line 914
      goto while_break___3;
    }
    {
#line 915
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 915
      if (! 1) {
#line 915
        goto while_break___4;
      }
#line 917
      high___0 ++;
#line 917
      if (high___0 >= num_font_families) {
#line 918
        goto while_break___4;
      }
      {
#line 919
      __cil_tmp9 = strcmp((char const   *)(*(user_font_families + low))->family, (char const   *)(*(user_font_families + high___0))->family);
      }
#line 919
      if (__cil_tmp9) {
#line 920
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 922
    dupe_markdown_range(user_font_families + low, high___0 - low);
#line 923
    low = high___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 925
  qsort(user_font_families, (size_t )num_font_families, sizeof(*(user_font_families + 0)),
        & compar_fontscore);
  }
#line 928
  if (num_font_families > 0) {
#line 928
    if ((*(user_font_families + 0))->score < 0) {
      {
#line 929
      fprintf(stderr, "sorted the wrong way, or all fonts were unusable\n");
      }
    }
  }
  {
#line 934
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 934
    if (! (num_font_families > 1 && (*(user_font_families + (num_font_families - 1)))->score < 0)) {
#line 934
      goto while_break___5;
    }
    {
#line 936
    num_font_families --;
#line 936
    i = num_font_families;
#line 937
    free((*(user_font_families + i))->directory);
#line 938
    free((*(user_font_families + i))->family);
#line 939
    cpp = (char **)(*(user_font_families + i))->filename;
    }
#line 940
    if (*(cpp + 0)) {
      {
#line 941
      free(*(cpp + 0));
      }
    }
#line 942
    if (*(cpp + 1)) {
      {
#line 943
      free(*(cpp + 1));
      }
    }
#line 944
    if (*(cpp + 2)) {
      {
#line 945
      free(*(cpp + 2));
      }
    }
#line 946
    if (*(cpp + 3)) {
      {
#line 947
      free(*(cpp + 3));
      }
    }
    {
#line 948
    free(*(user_font_families + i));
#line 949
    *(user_font_families + i) = (family_info *)((void *)0);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  return;
}
}
#line 958 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void loadfonts_locale_filter(SDL_Surface *screen___0 , char const   *dir ,
                                    char const   *locale ) 
{ 
  char buf[400] ;
  unsigned int dirlen ;
  unsigned long __cil_tmp6 ;

  {
  {
#line 961
  __cil_tmp6 = strlen(dir);
#line 961
  dirlen = (unsigned int )__cil_tmp6;
#line 963
  memcpy((char *)buf, dir, (unsigned long )dirlen);
#line 964
  tp_ftw(screen___0, (char *)buf, dirlen, 1, & loadfont_callback, locale);
  }
  return;
}
}
#line 967 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static void loadfonts(SDL_Surface *screen___0 , char const   *dir ) 
{ 


  {
  {
#line 969
  loadfonts_locale_filter(screen___0, dir, (char const   *)((void *)0));
  }
  return;
}
}
#line 973 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
int load_user_fonts(SDL_Surface *screen___0 , void *vp , char const   *locale ) 
{ 
  char *homedirdir ;
  char *__cil_tmp5 ;

  {
  {
#line 979
  loadfonts_locale_filter(screen___0, "/usr/local/share/tuxpaint/fonts", locale);
  }
#line 981
  if (! no_system_fonts) {
    {
#line 1015
    loadfonts(screen___0, "/usr/share/feh/fonts");
#line 1016
    loadfonts(screen___0, "/usr/share/fonts\220");
#line 1017
    loadfonts(screen___0, "/usr/X11R6/lib/X11/fonts\220");
#line 1018
    loadfonts(screen___0, "/usr/share/texmf/fonts");
#line 1019
    loadfonts(screen___0, "/usr/share/grace/fonts/type1");
#line 1020
    loadfonts(screen___0, "/usr/share/hatman/fonts");
#line 1021
    loadfonts(screen___0, "/usr/share/icewm/themes/jim-mac");
#line 1022
    loadfonts(screen___0, "/usr/share/vlc/skins2/fonts");
#line 1023
    loadfonts(screen___0, "/usr/share/xplanet/fonts\220");
    }
  }
  {
#line 1027
  homedirdir = get_fname("fonts", 1);
#line 1028
  loadfonts(screen___0, (char const   *)homedirdir);
#line 1029
  free(homedirdir);
#line 1042
  groupfonts();
#line 1049
  font_thread_done = (long )1;
#line 1050
  waiting_for_fonts = (long )0;
  }
#line 1052
  return (0);
}
}
#line 1058 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
void run_font_scanner(SDL_Surface *screen___0 , char const   *locale ) 
{ 
  int sv[2] ;
  int size ;
  int i ;
  char *buf ;
  char *walk ;
  int __cil_tmp8 ;
  __pid_t __cil_tmp9 ;
  int __cil_tmp10 ;
  __pid_t __cil_tmp11 ;
  int __cil_tmp12 ;
  char *s ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int len ;
  char *s___0 ;
  unsigned long __cil_tmp26 ;
  char *__cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  char *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  char *__cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  char *__cil_tmp33 ;
  unsigned long __cil_tmp34 ;
  char *__cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 1064
  __cil_tmp8 = socketpair(1, 1, 0, (int *)sv);
  }
#line 1064
  if (__cil_tmp8) {
    {
#line 1065
    exit(42);
    }
  }
  {
#line 1066
  font_scanner_pid = fork();
  }
#line 1067
  if (font_scanner_pid) {
    {
#line 1070
    font_socket_fd = sv[0];
#line 1071
    close(sv[1]);
    }
#line 1072
    return;
  }
  {
#line 1076
  __cil_tmp10 = nice(42);
  }
#line 1076
  if (__cil_tmp10 == -1) {
    {
#line 1078
    fprintf(stderr, "Font scanner thread can\'t nice() itself\n\220");
    }
  }
  {
#line 1081
  sched_yield();
#line 1082
  prctl(1, 9);
#line 1083
  __cil_tmp11 = getppid();
  }
#line 1083
  if (__cil_tmp11 == 1) {
    {
#line 1084
    _exit(99);
    }
  }
  {
#line 1085
  font_socket_fd = sv[1];
#line 1086
  close(sv[0]);
#line 1087
  progress_bar_disabled = 1;
#line 1088
  reliable_read(font_socket_fd, & no_system_fonts, sizeof(no_system_fonts));
#line 1089
  sched_yield();
#line 1090
  SDL_Init((Uint32 )1048576);
#line 1091
  TTF_Init();
#line 1092
  load_user_fonts(screen___0, (void *)0, locale);
#line 1094
  size = 0;
#line 1095
  i = num_font_families;
  }
  {
#line 1096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1096
    __cil_tmp12 = i;
#line 1096
    i --;
#line 1096
    if (! __cil_tmp12) {
#line 1096
      goto while_break;
    }
#line 1100
    s = (*(user_font_families + i))->directory;
#line 1101
    if (s) {
      {
#line 1102
      __cil_tmp14 = strlen((char const   *)s);
      }
#line 1102
      size += __cil_tmp14;
    }
#line 1103
    s = (*(user_font_families + i))->family;
#line 1104
    if (s) {
      {
#line 1105
      __cil_tmp15 = strlen((char const   *)s);
      }
#line 1105
      size += __cil_tmp15;
    }
#line 1106
    s = (*(user_font_families + i))->filename[0];
#line 1107
    if (s) {
      {
#line 1108
      __cil_tmp16 = strlen((char const   *)s);
      }
#line 1108
      size += __cil_tmp16;
    }
#line 1109
    s = (*(user_font_families + i))->filename[1];
#line 1110
    if (s) {
      {
#line 1111
      __cil_tmp17 = strlen((char const   *)s);
      }
#line 1111
      size += __cil_tmp17;
    }
#line 1112
    s = (*(user_font_families + i))->filename[2];
#line 1113
    if (s) {
      {
#line 1114
      __cil_tmp18 = strlen((char const   *)s);
      }
#line 1114
      size += __cil_tmp18;
    }
#line 1115
    s = (*(user_font_families + i))->filename[3];
#line 1116
    if (s) {
      {
#line 1117
      __cil_tmp19 = strlen((char const   *)s);
      }
#line 1117
      size += __cil_tmp19;
    }
#line 1118
    size += 6;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1120
  size += 2;
#line 1121
  buf = (char *)malloc((unsigned long )size);
#line 1122
  walk = buf;
#line 1126
  __cil_tmp21 = walk;
#line 1126
  walk ++;
#line 1126
  *__cil_tmp21 = (char )((unsigned int )num_font_families & 255U);
#line 1127
  __cil_tmp22 = walk;
#line 1127
  walk ++;
#line 1127
  *__cil_tmp22 = (char )(num_font_families >> 8U);
#line 1128
  i = num_font_families;
  }
  {
#line 1129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1129
    __cil_tmp23 = i;
#line 1129
    i --;
#line 1129
    if (! __cil_tmp23) {
#line 1129
      goto while_break___0;
    }
#line 1134
    s___0 = (*(user_font_families + i))->directory;
#line 1135
    if (s___0) {
      {
#line 1137
      __cil_tmp26 = strlen((char const   *)s___0);
#line 1137
      len = (int )__cil_tmp26;
#line 1138
      memcpy(walk, s___0, (unsigned long )len);
#line 1139
      walk += len;
      }
    }
#line 1141
    __cil_tmp27 = walk;
#line 1141
    walk ++;
#line 1141
    *__cil_tmp27 = (char )'\000';
#line 1143
    s___0 = (*(user_font_families + i))->family;
#line 1144
    if (s___0) {
      {
#line 1146
      __cil_tmp28 = strlen((char const   *)s___0);
#line 1146
      len = (int )__cil_tmp28;
#line 1147
      memcpy(walk, s___0, (unsigned long )len);
#line 1148
      walk += len;
      }
    }
#line 1150
    __cil_tmp29 = walk;
#line 1150
    walk ++;
#line 1150
    *__cil_tmp29 = (char )'\000';
#line 1152
    s___0 = (*(user_font_families + i))->filename[0];
#line 1153
    if (s___0) {
      {
#line 1155
      __cil_tmp30 = strlen((char const   *)s___0);
#line 1155
      len = (int )__cil_tmp30;
#line 1156
      memcpy(walk, s___0, (unsigned long )len);
#line 1157
      walk += len;
      }
    }
#line 1159
    __cil_tmp31 = walk;
#line 1159
    walk ++;
#line 1159
    *__cil_tmp31 = (char )'\000';
#line 1161
    s___0 = (*(user_font_families + i))->filename[1];
#line 1162
    if (s___0) {
      {
#line 1164
      __cil_tmp32 = strlen((char const   *)s___0);
#line 1164
      len = (int )__cil_tmp32;
#line 1165
      memcpy(walk, s___0, (unsigned long )len);
#line 1166
      walk += len;
      }
    }
#line 1168
    __cil_tmp33 = walk;
#line 1168
    walk ++;
#line 1168
    *__cil_tmp33 = (char )'\000';
#line 1170
    s___0 = (*(user_font_families + i))->filename[2];
#line 1171
    if (s___0) {
      {
#line 1173
      __cil_tmp34 = strlen((char const   *)s___0);
#line 1173
      len = (int )__cil_tmp34;
#line 1174
      memcpy(walk, s___0, (unsigned long )len);
#line 1175
      walk += len;
      }
    }
#line 1177
    __cil_tmp35 = walk;
#line 1177
    walk ++;
#line 1177
    *__cil_tmp35 = (char )'\000';
#line 1179
    s___0 = (*(user_font_families + i))->filename[3];
#line 1180
    if (s___0) {
      {
#line 1182
      __cil_tmp36 = strlen((char const   *)s___0);
#line 1182
      len = (int )__cil_tmp36;
#line 1183
      memcpy(walk, s___0, (unsigned long )len);
#line 1184
      walk += len;
      }
    }
#line 1186
    __cil_tmp37 = walk;
#line 1186
    walk ++;
#line 1186
    *__cil_tmp37 = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1188
  reliable_write(font_socket_fd, buf, (size_t )size);
#line 1189
  exit(0);
  }
}
}
#line 1193 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
void receive_some_font_info(SDL_Surface *screen___0 ) 
{ 
  char *buf ;
  unsigned int buf_size ;
  unsigned int buf_fill ;
  ssize_t rc ;
  struct pollfd p ;
  int status ;
  char *walk ;
  unsigned int i ;
  family_info *fip ;
  void *__cil_tmp11 ;
  ssize_t __cil_tmp12 ;
  int *__cil_tmp13 ;
  struct pollfd tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int len ;
  unsigned long __cil_tmp21 ;
  char *tmp___0 ;
  unsigned long __cil_tmp23 ;
  char *tmp___1 ;
  unsigned long __cil_tmp25 ;
  char *tmp___2 ;
  unsigned long __cil_tmp27 ;
  char *tmp___3 ;
  unsigned long __cil_tmp29 ;
  char *tmp___4 ;
  unsigned long __cil_tmp31 ;
  char *tmp___5 ;

  {
  {
#line 1195
  buf = (char *)((void *)0);
#line 1196
  buf_size = (unsigned int )0;
#line 1197
  buf_fill = (unsigned int )0;
#line 1205
  fcntl(font_socket_fd, 4, 2048);
  }
  {
#line 1206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1206
    if (! 1) {
#line 1206
      goto while_break;
    }
#line 1208
    if (buf_size <= (buf_fill * 9U) / 8U + 128U) {
      {
#line 1210
      buf_size = (buf_size * 5U) / 4U + 256U;
#line 1213
      buf = (char *)realloc(buf, (unsigned long )buf_size);
      }
    }
    {
#line 1215
    rc = read(font_socket_fd, buf + buf_fill, (size_t )(buf_size - buf_fill));
    }
#line 1220
    if (rc == -1L) {
      {
#line 1222
      __cil_tmp13 = __errno_location();
      }
      {
#line 1226
      if (*__cil_tmp13 == 11) {
#line 1226
        goto case_11;
      }
#line 1234
      if (*__cil_tmp13 == 4) {
#line 1234
        goto case_4;
      }
#line 1224
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 1225
      return;
      case_11: /* CIL Label */ ;
#line 1228
      tmp.fd = font_socket_fd;
#line 1228
      tmp.events = (short )1;
      {
#line 1228
      tmp.revents = (short )0;
#line 1228
      p = tmp;
#line 1231
      show_progress_bar(screen___0);
#line 1232
      poll(& p, (nfds_t )1, 29);
      }
#line 1233
      goto while_continue;
      case_4: /* CIL Label */ 
#line 1235
      goto while_continue;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1238
    buf_fill += rc;
#line 1239
    if (! rc) {
#line 1240
      goto while_break;
    } else
#line 1239
    if (font_thread_aborted) {
#line 1240
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1242
  close(font_socket_fd);
#line 1244
  waitpid(font_scanner_pid, & status, 0);
  }
#line 1245
  if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
    {
    {
#line 1247
    fprintf(stderr, "child killed by signal %u\n\275r\324U", status & 127);
    }
#line 1248
    user_font_families = (family_info **)((void *)0);
#line 1249
    num_font_families = 0;
#line 1250
    font_thread_done = (long )1;
    }
#line 1252
    return;
  } else
#line 1245
  if (font_thread_aborted) {
    {
    {
#line 1247
    fprintf(stderr, "child killed by signal %u\n\275r\324U", status & 127);
    }
#line 1248
    user_font_families = (family_info **)((void *)0);
#line 1249
    num_font_families = 0;
#line 1250
    font_thread_done = (long )1;
    }
#line 1252
    return;
  }
  {
#line 1255
  show_progress_bar(screen___0);
#line 1256
  walk = buf;
#line 1257
  __cil_tmp15 = walk;
#line 1257
  walk ++;
#line 1257
  num_font_families = (int )*((unsigned char *)__cil_tmp15);
#line 1258
  __cil_tmp16 = walk;
#line 1258
  walk ++;
  }
  {
#line 1258
  num_font_families += (int )*((unsigned char *)__cil_tmp16) << 8U;
#line 1262
  user_font_families = (family_info **)malloc((unsigned long )num_font_families * sizeof(*user_font_families));
#line 1265
  fip = (family_info *)malloc((unsigned long )num_font_families * sizeof(*(*user_font_families)));
#line 1267
  i = (unsigned int )num_font_families;
  }
  {
#line 1268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1268
    __cil_tmp19 = i;
#line 1268
    i --;
#line 1268
    if (! __cil_tmp19) {
#line 1268
      goto while_break___0;
    }
    {
#line 1272
    *(user_font_families + i) = fip + i;
#line 1274
    __cil_tmp21 = strlen((char const   *)walk);
#line 1274
    len = (unsigned int )__cil_tmp21;
    }
#line 1275
    if (len) {
#line 1275
      tmp___0 = walk;
    } else {
#line 1275
      tmp___0 = (char *)((void *)0);
    }
    {
#line 1275
    (*(user_font_families + i))->directory = tmp___0;
#line 1276
    walk += len + 1U;
#line 1278
    __cil_tmp23 = strlen((char const   *)walk);
#line 1278
    len = (unsigned int )__cil_tmp23;
    }
#line 1279
    if (len) {
#line 1279
      tmp___1 = walk;
    } else {
#line 1279
      tmp___1 = (char *)((void *)0);
    }
    {
#line 1279
    (*(user_font_families + i))->family = tmp___1;
#line 1280
    walk += len + 1U;
#line 1282
    __cil_tmp25 = strlen((char const   *)walk);
#line 1282
    len = (unsigned int )__cil_tmp25;
    }
#line 1283
    if (len) {
#line 1283
      tmp___2 = walk;
    } else {
#line 1283
      tmp___2 = (char *)((void *)0);
    }
    {
#line 1283
    (*(user_font_families + i))->filename[0] = tmp___2;
#line 1284
    walk += len + 1U;
#line 1286
    __cil_tmp27 = strlen((char const   *)walk);
#line 1286
    len = (unsigned int )__cil_tmp27;
    }
#line 1287
    if (len) {
#line 1287
      tmp___3 = walk;
    } else {
#line 1287
      tmp___3 = (char *)((void *)0);
    }
    {
#line 1287
    (*(user_font_families + i))->filename[1] = tmp___3;
#line 1288
    walk += len + 1U;
#line 1290
    __cil_tmp29 = strlen((char const   *)walk);
#line 1290
    len = (unsigned int )__cil_tmp29;
    }
#line 1291
    if (len) {
#line 1291
      tmp___4 = walk;
    } else {
#line 1291
      tmp___4 = (char *)((void *)0);
    }
    {
#line 1291
    (*(user_font_families + i))->filename[2] = tmp___4;
#line 1292
    walk += len + 1U;
#line 1294
    __cil_tmp31 = strlen((char const   *)walk);
#line 1294
    len = (unsigned int )__cil_tmp31;
    }
#line 1295
    if (len) {
#line 1295
      tmp___5 = walk;
    } else {
#line 1295
      tmp___5 = (char *)((void *)0);
    }
#line 1295
    (*(user_font_families + i))->filename[3] = tmp___5;
#line 1296
    walk += len + 1U;
#line 1298
    (*(user_font_families + i))->handle = (TuxPaint_Font *)((void *)0);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1302
  font_thread_done = (long )1;
  return;
}
}
#line 1310 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
TuxPaint_Font *getfonthandle(int desire ) 
{ 
  int missing ;
  family_info *fi ;
  char *name ;
  char *pathname ;
  char description[1024] ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  void *__cil_tmp9 ;
  TuxPaint_Font *__cil_tmp10 ;

  {
#line 1312
  missing = 0;
#line 1313
  fi = *(user_font_families + desire);
#line 1323
  if (fi == (void *)0) {
#line 1329
    return ((TuxPaint_Font *)((void *)0));
  }
#line 1332
  if ((char **)fi->filename != (void *)0) {
#line 1339
    name = fi->filename[text_state];
  } else {
#line 1353
    name = (char *)((void *)0);
  }
#line 1356
  if (fi->handle) {
#line 1363
    return (fi->handle);
  }
#line 1395
  if (! name) {
#line 1397
    name = fi->filename[text_state ^ 2];
#line 1398
    missing = text_state & 2;
  }
#line 1400
  if (! name) {
#line 1402
    name = fi->filename[text_state ^ 1];
#line 1403
    missing = text_state & 1;
  }
#line 1405
  if (! name) {
#line 1407
    name = fi->filename[text_state ^ 3];
#line 1408
    missing = text_state & 3;
  }
#line 1410
  if (! name) {
#line 1416
    return ((TuxPaint_Font *)((void *)0));
  }
  {
#line 1419
  __cil_tmp8 = strlen((char const   *)name);
  }
  {
#line 1419
  __cil_tmp7 = strlen((char const   *)fi->directory);
#line 1419
  __cil_tmp9 = __builtin_alloca(((__cil_tmp7 + 1UL) + __cil_tmp8) + 1UL);
#line 1419
  pathname = __cil_tmp9;
#line 1420
  sprintf(pathname, "%s/%sU", fi->directory, name);
#line 1422
  strcpy((char *)description, "\220");
#line 1425
  fi->handle = TuxPaint_Font_OpenFont((char const   *)((char *)description), (char const   *)pathname,
                                      text_sizes___0[text_size]);
  }
#line 1428
  if (fi->handle == (void *)0) {
#line 1434
    return ((TuxPaint_Font *)((void *)0));
  }
#line 1437
  if ((fi->handle)->typ == 1) {
#line 1439
    if ((fi->handle)->ttf_font == (void *)0) {
#line 1445
      return ((TuxPaint_Font *)((void *)0));
    }
    {
#line 1453
    TTF_SetFontStyle((fi->handle)->ttf_font, missing);
    }
  }
#line 1457
  if ((fi->handle)->typ == 0) {
    {
#line 1458
    printf("%s:%d - It\'s a Pango context...\n", "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c",
           1458);
    }
  }
#line 1461
  return (fi->handle);
}
}
#line 1466
static int was_bad_font ;
#line 1469 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int do_surfcmp(SDL_Surface * const  *v1 , SDL_Surface * const  *v2 ) 
{ 
  SDL_Surface *s1 ;
  SDL_Surface *s2 ;
  int width ;
  int cmp ;
  int i ;
  char const   *c1 ;
  char const   *c2 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 1471
  s1 = *v1;
#line 1472
  s2 = *v2;
#line 1477
  if (s1 == s2) {
    {
#line 1479
    fprintf(stderr, "s1==s2?\n\220");
    }
#line 1480
    return (0);
  }
#line 1482
  if (! s1) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s2) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s1->w) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s2->w) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s1->h) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s2->h) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s1->format) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  } else
#line 1482
  if (! s2->format) {
#line 1484
    was_bad_font = 1;
#line 1485
    return (0);
  }
#line 1487
  if ((int )(s1->format)->BytesPerPixel != (int )(s2->format)->BytesPerPixel) {
#line 1490
    was_bad_font = 1;
#line 1491
    return ((int )(s1->format)->BytesPerPixel - (int )(s2->format)->BytesPerPixel);
  }
#line 1495
  if (s1->w != s2->w) {
#line 1496
    return (s1->w - s2->w);
  }
#line 1497
  if (s1->h != s2->h) {
#line 1498
    return (s1->h - s2->h);
  }
#line 1501
  c1 = (char const   *)((char *)s1->pixels);
#line 1502
  c2 = (char const   *)((char *)s2->pixels);
#line 1504
  width = (int )(s1->format)->BytesPerPixel * s1->w;
#line 1505
  if (width == (int )s1->pitch) {
    {
#line 1506
    __cil_tmp10 = memcmp(c1, c2, (unsigned long )(width * s1->h));
    }
#line 1506
    return (__cil_tmp10);
  }
#line 1507
  cmp = 0;
#line 1508
  i = s1->h;
  {
#line 1509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1509
    __cil_tmp11 = i;
#line 1509
    i --;
#line 1509
    if (! __cil_tmp11) {
#line 1509
      goto while_break;
    }
    {
#line 1511
    cmp = memcmp(c1 + i * (int )s1->pitch, c2 + i * (int )s2->pitch, (unsigned long )width);
    }
#line 1512
    if (cmp) {
#line 1513
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1517
  return (cmp);
}
}
#line 1521 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
static int surfcmp(void const   *s1 , void const   *s2 ) 
{ 
  int diff ;
  int __cil_tmp4 ;

  {
  {
#line 1523
  __cil_tmp4 = do_surfcmp(s1, s2);
#line 1523
  diff = __cil_tmp4;
  }
#line 1525
  if (! diff) {
#line 1526
    was_bad_font = 1;
  }
#line 1527
  return (diff);
}
}
#line 1531 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
int charset_works(TuxPaint_Font *font , char const   *s ) 
{ 
  SDL_Color black ;
  SDLPango_Matrix pango_color ;
  SDL_Surface **surfs ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  unsigned int count ;
  int ret ;
  char c[8] ;
  unsigned int offset ;
  SDL_Surface *tmp_surf ;
  unsigned int __cil_tmp13 ;
  char const   *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  SDL_Surface *__cil_tmp16 ;
  SDL_Surface *__cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;

  {
#line 1533
  black.r = (Uint8 )0;
#line 1533
  black.g = (Uint8 )0;
#line 1533
  black.b = (Uint8 )0;
  {
#line 1533
  black.unused = (Uint8 )0;
#line 1537
  __cil_tmp6 = strlen(s);
#line 1537
  __cil_tmp7 = malloc(__cil_tmp6 * sizeof(*(surfs + 0)));
#line 1537
  surfs = __cil_tmp7;
#line 1538
  count = (unsigned int )0;
#line 1539
  ret = 0;
  }
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    if (! *s) {
#line 1541
      goto while_break;
    }
#line 1544
    offset = (unsigned int )0;
#line 1545
    tmp_surf = (SDL_Surface *)((void *)0);
    {
#line 1547
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1548
      __cil_tmp14 = s;
#line 1548
      s ++;
#line 1548
      __cil_tmp13 = offset;
#line 1548
      offset ++;
#line 1548
      c[__cil_tmp13] = *__cil_tmp14;
#line 1547
      if (! (((unsigned int )*s & 192U) == 128U)) {
#line 1547
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1550
    __cil_tmp15 = offset;
#line 1550
    offset ++;
#line 1550
    c[__cil_tmp15] = (char )'\000';
#line 1553
    if (font->typ == 0) {
      {
#line 1555
      sdl_color_to_pango_color(black, & pango_color);
#line 1556
      SDLPango_SetDefaultColor(font->pango_context, & pango_color);
#line 1557
      SDLPango_SetText(font->pango_context, (char const   *)((char *)c), - 1);
#line 1558
      tmp_surf = SDLPango_CreateSurfaceDraw(font->pango_context);
      }
    }
#line 1563
    if (font->typ == 1) {
      {
#line 1565
      tmp_surf = TTF_RenderUTF8_Blended(font->ttf_font, (char const   *)((char *)c),
                                        black);
      }
    }
#line 1568
    if (! tmp_surf) {
#line 1574
      goto out;
    }
#line 1576
    __cil_tmp18 = count;
#line 1576
    count ++;
#line 1576
    *(surfs + __cil_tmp18) = tmp_surf;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1578
  was_bad_font = 0;
#line 1579
  qsort(surfs, (size_t )count, sizeof(*(surfs + 0)), & surfcmp);
#line 1580
  ret = ! was_bad_font;
  }
  out: 
  {
#line 1582
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1582
    __cil_tmp19 = count;
#line 1582
    count --;
#line 1582
    if (! __cil_tmp19) {
#line 1582
      goto while_break___1;
    }
#line 1584
    if (*(surfs + count) == (void *)0) {
      {
#line 1585
      fprintf(stderr, "TRYING TO RE-FREE!Fs\324U");
      }
    } else {
      {
#line 1588
      SDL_FreeSurface(*(surfs + count));
#line 1589
      *(surfs + count) = (SDL_Surface *)((void *)0);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1592
  free(surfs);
  }
#line 1593
  return (ret);
}
}
#line 1596 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
int TuxPaint_Font_FontHeight(TuxPaint_Font *tpf ) 
{ 


  {
#line 1598
  if (tpf == (void *)0) {
#line 1604
    return (1);
  }
#line 1607
  return (tpf->height);
}
}
#line 1610 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
char const   *TuxPaint_Font_FontFaceFamilyName(TuxPaint_Font *tpf ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1612
  if (tpf == (void *)0) {
#line 1618
    return ("\310\001Ds\324U");
  }
#line 1622
  if (tpf->typ == 0) {
#line 1627
    return ("\310\001Ds\324U");
  }
#line 1631
  if (tpf->typ == 1) {
    {
#line 1632
    __cil_tmp2 = TTF_FontFaceFamilyName(tpf->ttf_font);
    }
#line 1632
    return ((char const   *)__cil_tmp2);
  }
#line 1638
  return ("\310\001Ds\324U");
}
}
#line 1641 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
char const   *TuxPaint_Font_FontFaceStyleName(TuxPaint_Font *tpf ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1643
  if (tpf == (void *)0) {
#line 1649
    return ("\310\001");
  }
#line 1653
  if (tpf->typ == 0) {
#line 1658
    return ("\310\001Ds\324U");
  }
#line 1662
  if (tpf->typ == 1) {
    {
#line 1663
    __cil_tmp2 = TTF_FontFaceStyleName(tpf->ttf_font);
    }
#line 1663
    return ((char const   *)__cil_tmp2);
  }
#line 1669
  return ("\310\001Ds\324U");
}
}
#line 1675 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.c"
void sdl_color_to_pango_color(SDL_Color sdl_color , SDLPango_Matrix *pango_color ) 
{ 
  Uint8 pc[4][4] ;

  {
  {
#line 1679
  pc[0][0] = (Uint8 )0;
#line 1680
  pc[1][0] = (Uint8 )0;
#line 1681
  pc[2][0] = (Uint8 )0;
#line 1682
  pc[3][0] = (Uint8 )0;
#line 1684
  pc[0][1] = sdl_color.r;
#line 1685
  pc[1][1] = sdl_color.g;
#line 1686
  pc[2][1] = sdl_color.b;
#line 1687
  pc[3][1] = (Uint8 )255;
#line 1689
  pc[0][2] = (Uint8 )0;
#line 1690
  pc[1][2] = (Uint8 )0;
#line 1691
  pc[2][2] = (Uint8 )0;
#line 1692
  pc[3][2] = (Uint8 )0;
#line 1694
  pc[0][3] = (Uint8 )0;
#line 1695
  pc[1][3] = (Uint8 )0;
#line 1696
  pc[2][3] = (Uint8 )0;
#line 1697
  pc[3][3] = (Uint8 )0;
#line 1699
  memcpy(pango_color, (Uint8 (*)[4])pc, (unsigned long )16);
  }
  return;
}
}
#line 33 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/playsound.c"
int use_sound  =    1;
#line 34 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/playsound.c"
int use_stereo  =    1;
#line 35 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/playsound.c"
static int old_sound[4]  = {      - 1,      - 1,      - 1,      - 1};
#line 51 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/playsound.c"
void playsound(SDL_Surface *screen___0 , int chan , int s , int override , int x ,
               int y ) 
{ 
  int left ;
  int dist ;
  int __cil_tmp9 ;

  {
#line 56
  if (! mute) {
#line 56
    if (use_sound) {
#line 56
      if (s != -1) {
        {
#line 63
        __cil_tmp9 = Mix_Playing(chan);
        }
#line 63
        if (override) {
          {
          {
#line 65
          Mix_PlayChannelTimed(chan, sounds[s], 0, - 1);
          }
#line 67
          old_sound[chan] = s;
          }
        } else
#line 63
        if (! __cil_tmp9) {
          {
          {
#line 65
          Mix_PlayChannelTimed(chan, sounds[s], 0, - 1);
          }
#line 67
          old_sound[chan] = s;
          }
        }
#line 70
        if (old_sound[chan] == s) {
#line 72
          if (y == -999) {
#line 73
            dist = 0;
          } else {
#line 76
            if (y < 0) {
#line 77
              y = 0;
            } else
#line 78
            if (y >= screen___0->h - 1) {
#line 79
              y = screen___0->h - 1;
            }
#line 81
            dist = (255 * ((screen___0->h - 1) - y)) / (screen___0->h - 1);
          }
#line 85
          if (use_stereo) {
#line 87
            if (x == -997) {
#line 88
              left = 255 - dist;
            } else
#line 89
            if (x == -998) {
#line 90
              left = (255 - dist) / 2;
            } else
#line 91
            if (x == -999) {
#line 92
              left = 0;
            } else {
#line 95
              if (x < 0) {
#line 96
                x = 0;
              } else
#line 97
              if (x >= screen___0->w) {
#line 98
                x = screen___0->w - 1;
              }
#line 100
              left = ((255 - dist) * ((screen___0->w - 1) - x)) / (screen___0->w - 1);
            }
          } else {
#line 107
            left = (255 - dist) / 2;
          }
          {
#line 113
          Mix_SetPanning(chan, (Uint8 )left, (Uint8 )((255 - dist) - left));
          }
        }
      }
    }
  }
  return;
}
}
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static float const   sRGB_to_linear_table___0[256]  = 
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
  {      (float )0.,      (float )0.000304000000001,      (float )0.000607000000001,      (float )0.000911000000001, 
        (float )0.00121400000001,      (float )0.00151800000001,      (float )0.001821,      (float )0.00212500000001, 
        (float )0.00242800000001,      (float )0.00273200000001,      (float )0.003035,      (float )0.00334700000001, 
        (float )0.00367700000001,      (float )0.004025,      (float )0.004391,      (float )0.004777, 
        (float )0.005182,      (float )0.005605,      (float )0.006049,      (float )0.00651200000001, 
        (float )0.00699500000001,      (float )0.007499,      (float )0.00802300000001,      (float )0.008568, 
        (float )0.009134,      (float )0.00972100000001,      (float )0.0103300000001,      (float )0.01096, 
        (float )0.0116120000001,      (float )0.0122860000001,      (float )0.012983,      (float )0.0137020000001, 
        (float )0.0144440000001,      (float )0.0152090000001,      (float )0.015996,      (float )0.016807, 
        (float )0.0176420000001,      (float )0.0185,      (float )0.019382,      (float )0.0202890000001, 
        (float )0.021219,      (float )0.022174,      (float )0.023153,      (float )0.024158, 
        (float )0.0251870000001,      (float )0.0262410000001,      (float )0.0273210000001,      (float )0.028426, 
        (float )0.029557,      (float )0.0307130000001,      (float )0.0318960000001,      (float )0.0331050000001, 
        (float )0.0343400000001,      (float )0.0356010000001,      (float )0.036889,      (float )0.0382040000001, 
        (float )0.039546,      (float )0.040915,      (float )0.0423110000001,      (float )0.0437350000001, 
        (float )0.045186,      (float )0.046665,      (float )0.048172,      (float )0.0497070000001, 
        (float )0.0512690000001,      (float )0.052861,      (float )0.0544800000001,      (float )0.056128, 
        (float )0.0578050000001,      (float )0.0595110000001,      (float )0.0612460000001,      (float )0.06301, 
        (float )0.064803,      (float )0.0666260000001,      (float )0.068478,      (float )0.0703600000001, 
        (float )0.0722720000001,      (float )0.0742140000001,      (float )0.0761850000001,      (float )0.0781870000001, 
        (float )0.08022,      (float )0.082283,      (float )0.0843760000001,      (float )0.0865, 
        (float )0.088656,      (float )0.0908420000001,      (float )0.0930590000001,      (float )0.0953070000001, 
        (float )0.097587,      (float )0.0998990000001,      (float )0.102242,      (float )0.104616000001, 
        (float )0.107023,      (float )0.109462000001,      (float )0.111932000001,      (float )0.114435, 
        (float )0.116971000001,      (float )0.119538000001,      (float )0.122139,      (float )0.124772, 
        (float )0.127438,      (float )0.130136000001,      (float )0.132868000001,      (float )0.135633000001, 
        (float )0.138432,      (float )0.141263,      (float )0.144128000001,      (float )0.147027, 
        (float )0.149960000001,      (float )0.152926000001,      (float )0.155926000001,      (float )0.158961, 
        (float )0.162029000001,      (float )0.165132000001,      (float )0.168269000001,      (float )0.171441000001, 
        (float )0.174647,      (float )0.177888,      (float )0.181164,      (float )0.184475000001, 
        (float )0.187821,      (float )0.191202000001,      (float )0.194618000001,      (float )0.198069, 
        (float )0.201556000001,      (float )0.205079000001,      (float )0.208637,      (float )0.212231000001, 
        (float )0.215861,      (float )0.219526,      (float )0.223228000001,      (float )0.226966000001, 
        (float )0.230740000001,      (float )0.234551000001,      (float )0.238398,      (float )0.242281, 
        (float )0.246201000001,      (float )0.250158,      (float )0.254152,      (float )0.258183, 
        (float )0.262251000001,      (float )0.266356,      (float )0.270498000001,      (float )0.274677000001, 
        (float )0.278894,      (float )0.283149,      (float )0.287441000001,      (float )0.291771000001, 
        (float )0.296138000001,      (float )0.300544,      (float )0.304987000001,      (float )0.309469, 
        (float )0.313989000001,      (float )0.318547000001,      (float )0.323143000001,      (float )0.327778000001, 
        (float )0.332452000001,      (float )0.337164000001,      (float )0.341914,      (float )0.346704000001, 
        (float )0.351533,      (float )0.3564,      (float )0.361307,      (float )0.366253, 
        (float )0.371238000001,      (float )0.376262,      (float )0.381326,      (float )0.386429000001, 
        (float )0.391572,      (float )0.396755000001,      (float )0.401978000001,      (float )0.40724, 
        (float )0.412543,      (float )0.417885000001,      (float )0.423268,      (float )0.428690000001, 
        (float )0.434154,      (float )0.439657000001,      (float )0.445201000001,      (float )0.450786000001, 
        (float )0.456411000001,      (float )0.462077000001,      (float )0.467784,      (float )0.473531, 
        (float )0.479320000001,      (float )0.485150000001,      (float )0.491021,      (float )0.496933000001, 
        (float )0.502886000001,      (float )0.508881000001,      (float )0.514918,      (float )0.520996000001, 
        (float )0.527115000001,      (float )0.533276,      (float )0.539479000001,      (float )0.545724, 
        (float )0.552011000001,      (float )0.55834,      (float )0.564712,      (float )0.571125, 
        (float )0.57758,      (float )0.584078,      (float )0.590619000001,      (float )0.597202000001, 
        (float )0.603827000001,      (float )0.610496000001,      (float )0.617207,      (float )0.62396, 
        (float )0.630757000001,      (float )0.637597,      (float )0.644480000001,      (float )0.651406000001, 
        (float )0.658375000001,      (float )0.665387,      (float )0.672443000001,      (float )0.679542, 
        (float )0.686685,      (float )0.693872000001,      (float )0.701102000001,      (float )0.708376000001, 
        (float )0.715694000001,      (float )0.723055000001,      (float )0.730461000001,      (float )0.73791, 
        (float )0.745404,      (float )0.752942000001,      (float )0.760525000001,      (float )0.768151000001, 
        (float )0.775822000001,      (float )0.783538,      (float )0.791298,      (float )0.799103000001, 
        (float )0.806952000001,      (float )0.814847,      (float )0.822786000001,      (float )0.830770000001, 
        (float )0.838799,      (float )0.846873,      (float )0.854993000001,      (float )0.863157, 
        (float )0.871367000001,      (float )0.879622000001,      (float )0.887923000001,      (float )0.896269, 
        (float )0.904661000001,      (float )0.913099,      (float )0.921582000001,      (float )0.930111000001, 
        (float )0.938686000001,      (float )0.947307000001,      (float )0.955973,      (float )0.964686000001, 
        (float )0.973445000001,      (float )0.982251,      (float )0.991102000001,      (float )1.};
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static unsigned char const   linear_to_sRGB_table___0[4096]  =    "";
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.c"
unsigned char linear_to_sRGB(float linear ) 
{ 
  unsigned int slot ;

  {
#line 44
  slot = (unsigned int )((double )linear * 4096. + 0.5);
#line 45
  if (slot > 4095U) {
#line 47
    if ((double )linear > 0.5) {
#line 48
      slot = (unsigned int )4095;
    } else {
#line 50
      slot = (unsigned int )0;
    }
  }
#line 52
  return (linear_to_sRGB_table___0[slot]);
}
}
#line 35 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static void putpixel8(SDL_Surface *surface , int x , int y , Uint32 pixel ) 
{ 
  Uint8 *p ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;

  {
  {
#line 40
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y < (unsigned int )surface->h))),
                                (long )1);
  }
  {
#line 40
  __cil_tmp6 = __builtin_expect((long )(! (! ((unsigned int )x < (unsigned int )surface->w))),
                                (long )1);
#line 40
  __cil_tmp8 = __builtin_expect(! (! (__cil_tmp6 && __cil_tmp7)), (long )1);
  }
#line 40
  if (__cil_tmp8) {
#line 43
    p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x);
#line 51
    *p = (Uint8 )pixel;
  }
  return;
}
}
#line 56 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static void putpixel16(SDL_Surface *surface , int x , int y , Uint32 pixel ) 
{ 
  Uint8 *p ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;

  {
  {
#line 61
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y < (unsigned int )surface->h))),
                                (long )1);
  }
  {
#line 61
  __cil_tmp6 = __builtin_expect((long )(! (! ((unsigned int )x < (unsigned int )surface->w))),
                                (long )1);
#line 61
  __cil_tmp8 = __builtin_expect(! (! (__cil_tmp6 && __cil_tmp7)), (long )1);
  }
#line 61
  if (__cil_tmp8) {
#line 64
    p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 2);
#line 72
    *((Uint16 *)p) = (Uint16 )pixel;
  }
  return;
}
}
#line 77 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static void putpixel24(SDL_Surface *surface , int x , int y , Uint32 pixel ) 
{ 
  Uint8 *p ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;

  {
  {
#line 82
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y < (unsigned int )surface->h))),
                                (long )1);
  }
  {
#line 82
  __cil_tmp6 = __builtin_expect((long )(! (! ((unsigned int )x < (unsigned int )surface->w))),
                                (long )1);
#line 82
  __cil_tmp8 = __builtin_expect(! (! (__cil_tmp6 && __cil_tmp7)), (long )1);
  }
#line 82
  if (__cil_tmp8) {
#line 85
    p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 3);
#line 93
    if (0) {
#line 95
      *(p + 0) = (Uint8 )((pixel >> 16) & 255U);
#line 96
      *(p + 1) = (Uint8 )((pixel >> 8) & 255U);
#line 97
      *(p + 2) = (Uint8 )(pixel & 255U);
    } else {
#line 101
      *(p + 0) = (Uint8 )(pixel & 255U);
#line 102
      *(p + 1) = (Uint8 )((pixel >> 8) & 255U);
#line 103
      *(p + 2) = (Uint8 )((pixel >> 16) & 255U);
    }
  }
  return;
}
}
#line 110 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static void putpixel32(SDL_Surface *surface , int x , int y , Uint32 pixel ) 
{ 
  Uint8 *p ;
  long __cil_tmp6 ;
  long __cil_tmp7 ;
  long __cil_tmp8 ;

  {
  {
#line 115
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y < (unsigned int )surface->h))),
                                (long )1);
  }
  {
#line 115
  __cil_tmp6 = __builtin_expect((long )(! (! ((unsigned int )x < (unsigned int )surface->w))),
                                (long )1);
#line 115
  __cil_tmp8 = __builtin_expect(! (! (__cil_tmp6 && __cil_tmp7)), (long )1);
  }
#line 115
  if (__cil_tmp8) {
#line 118
    p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 4);
#line 126
    *((Uint32 *)p) = pixel;
  }
  return;
}
}
#line 131 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static Uint32 getpixel8(SDL_Surface *surface , int x , int y ) 
{ 
  Uint8 *p ;
  long __cil_tmp5 ;
  int tmp ;
  long __cil_tmp7 ;
  int tmp___0 ;

  {
  {
#line 136
  __cil_tmp5 = __builtin_expect((long )(! (! ((unsigned int )x > (unsigned int )surface->w - 1U))),
                                (long )0);
  }
#line 136
  if (__cil_tmp5) {
#line 137
    if (x < 0) {
#line 137
      tmp = 0;
    } else {
#line 137
      tmp = surface->w - 1;
    }
#line 137
    x = tmp;
  }
  {
#line 138
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y > (unsigned int )surface->h - 1U))),
                                (long )0);
  }
#line 138
  if (__cil_tmp7) {
#line 139
    if (y < 0) {
#line 139
      tmp___0 = 0;
    } else {
#line 139
      tmp___0 = surface->h - 1;
    }
#line 139
    y = tmp___0;
  }
#line 144
  p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x);
#line 153
  return ((Uint32 )*p);
}
}
#line 157 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static Uint32 getpixel16(SDL_Surface *surface , int x , int y ) 
{ 
  Uint8 *p ;
  long __cil_tmp5 ;
  int tmp ;
  long __cil_tmp7 ;
  int tmp___0 ;

  {
  {
#line 162
  __cil_tmp5 = __builtin_expect((long )(! (! ((unsigned int )x > (unsigned int )surface->w - 1U))),
                                (long )0);
  }
#line 162
  if (__cil_tmp5) {
#line 163
    if (x < 0) {
#line 163
      tmp = 0;
    } else {
#line 163
      tmp = surface->w - 1;
    }
#line 163
    x = tmp;
  }
  {
#line 164
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y > (unsigned int )surface->h - 1U))),
                                (long )0);
  }
#line 164
  if (__cil_tmp7) {
#line 165
    if (y < 0) {
#line 165
      tmp___0 = 0;
    } else {
#line 165
      tmp___0 = surface->h - 1;
    }
#line 165
    y = tmp___0;
  }
#line 170
  p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 2);
#line 179
  return ((Uint32 )*((Uint16 *)p));
}
}
#line 183 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static Uint32 getpixel24(SDL_Surface *surface , int x , int y ) 
{ 
  Uint8 *p ;
  Uint32 pixel ;
  long __cil_tmp6 ;
  int tmp ;
  long __cil_tmp8 ;
  int tmp___0 ;

  {
  {
#line 189
  __cil_tmp6 = __builtin_expect((long )(! (! ((unsigned int )x > (unsigned int )surface->w - 1U))),
                                (long )0);
  }
#line 189
  if (__cil_tmp6) {
#line 190
    if (x < 0) {
#line 190
      tmp = 0;
    } else {
#line 190
      tmp = surface->w - 1;
    }
#line 190
    x = tmp;
  }
  {
#line 191
  __cil_tmp8 = __builtin_expect((long )(! (! ((unsigned int )y > (unsigned int )surface->h - 1U))),
                                (long )0);
  }
#line 191
  if (__cil_tmp8) {
#line 192
    if (y < 0) {
#line 192
      tmp___0 = 0;
    } else {
#line 192
      tmp___0 = surface->h - 1;
    }
#line 192
    y = tmp___0;
  }
#line 197
  p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 3);
#line 208
  if (0) {
#line 209
    pixel = (Uint32 )((((int )*(p + 0) << 16) | ((int )*(p + 1) << 8)) | (int )*(p + 2));
  } else {
#line 211
    pixel = (Uint32 )(((int )*(p + 0) | ((int )*(p + 1) << 8)) | ((int )*(p + 2) << 16));
  }
#line 213
  return (pixel);
}
}
#line 217 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
static Uint32 getpixel32(SDL_Surface *surface , int x , int y ) 
{ 
  Uint8 *p ;
  long __cil_tmp5 ;
  int tmp ;
  long __cil_tmp7 ;
  int tmp___0 ;

  {
  {
#line 222
  __cil_tmp5 = __builtin_expect((long )(! (! ((unsigned int )x > (unsigned int )surface->w - 1U))),
                                (long )0);
  }
#line 222
  if (__cil_tmp5) {
#line 223
    if (x < 0) {
#line 223
      tmp = 0;
    } else {
#line 223
      tmp = surface->w - 1;
    }
#line 223
    x = tmp;
  }
  {
#line 224
  __cil_tmp7 = __builtin_expect((long )(! (! ((unsigned int )y > (unsigned int )surface->h - 1U))),
                                (long )0);
  }
#line 224
  if (__cil_tmp7) {
#line 225
    if (y < 0) {
#line 225
      tmp___0 = 0;
    } else {
#line 225
      tmp___0 = surface->h - 1;
    }
#line 225
    y = tmp___0;
  }
#line 230
  p = (Uint8 *)(((Uint8 *)surface->pixels + y * (int )surface->pitch) + x * 4);
#line 239
  return (*((Uint32 *)p));
}
}
#line 242 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
void (*putpixels[5])(SDL_Surface * , int  , int  , Uint32  )  = {      & putpixel8,      & putpixel8,      & putpixel16,      & putpixel24, 
        & putpixel32};
#line 247 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/pixels.c"
Uint32 (*getpixels[5])(SDL_Surface * , int  , int  )  = {      & getpixel8,      & getpixel8,      & getpixel16,      & getpixel24, 
        & getpixel32};
#line 4 "src/mouse/watch.xbm"
static unsigned char watch_bits[128]  = 
#line 4 "src/mouse/watch.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )14,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )28,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )199,      (unsigned char )56,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )195,      (unsigned char )48,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )227,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )227,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )3,      (unsigned char )48,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )7,      (unsigned char )56,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )28,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )14,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/watch-mask.xbm"
static unsigned char watch_mask_bits[128]  = 
#line 4 "src/mouse/watch-mask.xbm"
  {      (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0};
#line 4 "src/mouse/hand.xbm"
static unsigned char hand_bits[128]  = 
#line 4 "src/mouse/hand.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )76,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )112,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )248,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )220,      (unsigned char )13,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )140,      (unsigned char )15,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )12,      (unsigned char )7,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )28,      (unsigned char )2,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )224,      (unsigned char )0,      (unsigned char )0,      (unsigned char )6, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )0,      (unsigned char )6, 
        (unsigned char )128,      (unsigned char )3,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )7,      (unsigned char )0,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )0,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/hand-mask.xbm"
static unsigned char hand_mask_bits[128]  = 
#line 4 "src/mouse/hand-mask.xbm"
  {      (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )112,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )248,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )252,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )252,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )248,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )240,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )255,      (unsigned char )0};
#line 4 "src/mouse/wand.xbm"
static unsigned char wand_bits[128]  = 
#line 4 "src/mouse/wand.xbm"
  {      (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )67,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )160,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )2,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )28,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )132,      (unsigned char )62,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/wand-mask.xbm"
static unsigned char wand_mask_bits[128]  = 
#line 4 "src/mouse/wand-mask.xbm"
  {      (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )227,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )252,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )196,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )130,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )127, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/insertion.xbm"
static unsigned char insertion_bits[64]  = 
#line 4 "src/mouse/insertion.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )56,      (unsigned char )48,      (unsigned char )6, 
        (unsigned char )64,      (unsigned char )1,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )1,      (unsigned char )48,      (unsigned char )6, 
        (unsigned char )14,      (unsigned char )56,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/insertion-mask.xbm"
static unsigned char insertion_mask_bits[64]  = 
#line 4 "src/mouse/insertion-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )14,      (unsigned char )56, 
        (unsigned char )63,      (unsigned char )126,      (unsigned char )126,      (unsigned char )63, 
        (unsigned char )240,      (unsigned char )7,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )240,      (unsigned char )7,      (unsigned char )126,      (unsigned char )63, 
        (unsigned char )63,      (unsigned char )126,      (unsigned char )14,      (unsigned char )56};
#line 4 "src/mouse/brush.xbm"
static unsigned char brush_bits[128]  = 
#line 4 "src/mouse/brush.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )6, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )96,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )32,      (unsigned char )6, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )48,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )24,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )136,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )204,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )102,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )34,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )25,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )12,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )6,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )96,      (unsigned char )2,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )56,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )236,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )196,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )198,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )195,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )195,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )97,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )112,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/brush-mask.xbm"
static unsigned char brush_mask_bits[128]  = 
#line 4 "src/mouse/brush-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/crosshair.xbm"
static unsigned char crosshair_bits[128]  = 
#line 4 "src/mouse/crosshair.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/crosshair-mask.xbm"
static unsigned char crosshair_mask_bits[128]  = 
#line 4 "src/mouse/crosshair-mask.xbm"
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )255,      (unsigned char )63,      (unsigned char )254,      (unsigned char )127, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/rotate.xbm"
static unsigned char rotate_bits[128]  = 
#line 4 "src/mouse/rotate.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )6,      (unsigned char )6,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )24,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )0,      (unsigned char )32,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )0,      (unsigned char )64,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )1, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )1, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )2, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )64,      (unsigned char )68, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )128,      (unsigned char )36, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )21, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )6,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/rotate-mask.xbm"
static unsigned char rotate_mask_bits[128]  = 
#line 4 "src/mouse/rotate-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )7,      (unsigned char )62,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )1,      (unsigned char )120,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )224,      (unsigned char )0, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )64,      (unsigned char )78, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )224,      (unsigned char )238, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )192,      (unsigned char )127, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/up.xbm"
static unsigned char up_bits[128]  = 
#line 4 "src/mouse/up.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/up-mask.xbm"
static unsigned char up_mask_bits[128]  = 
#line 4 "src/mouse/up-mask.xbm"
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0};
#line 4 "src/mouse/down.xbm"
static unsigned char down_bits[128]  = 
#line 4 "src/mouse/down.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/down-mask.xbm"
static unsigned char down_mask_bits[128]  = 
#line 4 "src/mouse/down-mask.xbm"
  {      (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/tiny.xbm"
static unsigned char tiny_bits[7]  = {      (unsigned char )0,      (unsigned char )8,      (unsigned char )8,      (unsigned char )62, 
        (unsigned char )8,      (unsigned char )8,      (unsigned char )0};
#line 4 "src/mouse/tiny-mask.xbm"
static unsigned char tiny_mask_bits[7]  = {      (unsigned char )0,      (unsigned char )8,      (unsigned char )8,      (unsigned char )62, 
        (unsigned char )8,      (unsigned char )8,      (unsigned char )0};
#line 4 "src/mouse/arrow.xbm"
static unsigned char arrow_bits[128]  = 
#line 4 "src/mouse/arrow.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )6,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )30,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )62,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )126,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )158,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )6,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )30,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )62,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )60,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )124,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/arrow-mask.xbm"
static unsigned char arrow_mask_bits[128]  = 
#line 4 "src/mouse/arrow-mask.xbm"
  {      (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )15,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )31,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )63,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )127,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )159,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )143,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )7,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )126,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 68 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/cursor.h"
SDL_Cursor *cursor_hand ;
#line 68
SDL_Cursor *cursor_arrow ;
#line 68
SDL_Cursor *cursor_watch ;
#line 69
SDL_Cursor *cursor_up ;
#line 69
SDL_Cursor *cursor_down ;
#line 69
SDL_Cursor *cursor_tiny ;
#line 69
SDL_Cursor *cursor_crosshair ;
#line 70
SDL_Cursor *cursor_brush ;
#line 70
SDL_Cursor *cursor_wand ;
#line 70
SDL_Cursor *cursor_insertion ;
#line 70
SDL_Cursor *cursor_rotate ;
#line 72
int no_fancy_cursors ;
#line 72
int hide_cursor ;
#line 74
void do_setcursor(SDL_Cursor *c ) ;
#line 75
void free_cursor(SDL_Cursor **cursor ) ;
#line 57 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/cursor.c"
void do_setcursor(SDL_Cursor *c ) 
{ 


  {
#line 85
  if (! hide_cursor) {
#line 85
    if (! no_fancy_cursors) {
      {
#line 86
      SDL_SetCursor(c);
      }
    }
  }
  return;
}
}
#line 94 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/cursor.c"
void free_cursor(SDL_Cursor **cursor ) 
{ 


  {
#line 96
  if (*cursor) {
    {
#line 98
    SDL_FreeCursor(*cursor);
#line 99
    *cursor = (SDL_Cursor *)((void *)0);
    }
  }
  return;
}
}
#line 87 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 92
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 97
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscat(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 101
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 106
extern  __attribute__((__nothrow__)) int wcscmp(wchar_t *__s1 , wchar_t *__s2 ) ;
#line 109
extern  __attribute__((__nothrow__)) int wcsncmp(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) ;
#line 114
extern  __attribute__((__nothrow__)) int wcscasecmp(wchar_t *__s1 , wchar_t *__s2 ) ;
#line 117
extern  __attribute__((__nothrow__)) int wcsncasecmp(wchar_t *__s1 , wchar_t *__s2 ,
                                                     size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) int wcscasecmp_l(wchar_t *__s1 , wchar_t *__s2 ,
                                                      locale_t __loc ) ;
#line 125
extern  __attribute__((__nothrow__)) int wcsncasecmp_l(wchar_t *__s1 , wchar_t *__s2 ,
                                                       size_t __n , locale_t __loc ) ;
#line 131
extern  __attribute__((__nothrow__)) int wcscoll(wchar_t *__s1 , wchar_t *__s2 ) ;
#line 135
extern  __attribute__((__nothrow__)) size_t wcsxfrm(wchar_t *__s1 , wchar_t *__s2 ,
                                                    size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int wcscoll_l(wchar_t *__s1 , wchar_t *__s2 ,
                                                   locale_t __loc ) ;
#line 150
extern  __attribute__((__nothrow__)) size_t wcsxfrm_l(wchar_t *__s1 , wchar_t *__s2 ,
                                                      size_t __n , locale_t __loc ) ;
#line 154
extern  __attribute__((__nothrow__)) wchar_t *wcsdup(wchar_t *__s ) ;
#line 165
extern  __attribute__((__nothrow__)) int *wcschr(wchar_t *__wcs , wchar_t __wc ) ;
#line 175
extern  __attribute__((__nothrow__)) wchar_t *wcsrchr(wchar_t *__wcs , wchar_t __wc ) ;
#line 188
extern  __attribute__((__nothrow__)) size_t wcscspn(wchar_t *__wcs , wchar_t *__reject ) ;
#line 192
extern  __attribute__((__nothrow__)) size_t wcsspn(wchar_t *__wcs , wchar_t *__accept ) ;
#line 202
extern  __attribute__((__nothrow__)) wchar_t *wcspbrk(wchar_t *__wcs , wchar_t *__accept ) ;
#line 213
extern  __attribute__((__nothrow__)) wchar_t *wcsstr(wchar_t *__haystack , wchar_t *__needle ) ;
#line 218
extern  __attribute__((__nothrow__)) wchar_t *wcstok(wchar_t *__s , wchar_t *__delim ,
                                                     wchar_t **__ptr ) ;
#line 223
extern  __attribute__((__nothrow__)) unsigned long wcslen(wchar_t *__s ) ;
#line 241
extern  __attribute__((__nothrow__)) size_t wcsnlen(wchar_t *__s , size_t __maxlen ) ;
#line 254
extern  __attribute__((__nothrow__)) int *wmemchr(wchar_t *__s , wchar_t __c , size_t __n ) ;
#line 259
extern  __attribute__((__nothrow__)) int wmemcmp(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) ;
#line 263
__inline extern  __attribute__((__nothrow__)) int *wmemcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                           size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 268
__inline extern  __attribute__((__nothrow__)) int *wmemmove(wchar_t *__s1 , wchar_t *__s2 ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 272
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemset(wchar_t *__s , wchar_t __c ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 285
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 289
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 293
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t *__ps ) ;
#line 297
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t *__pwc , char const   *__s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 302
__inline extern  __attribute__((__nothrow__)) size_t wcrtomb(char *__s , wchar_t __wchar ,
                                                             mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 306
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   *__s , size_t __n ,
                                                     mbstate_t *__ps ) ;
#line 308
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 317
extern wint_t __btowc_alias(int __c ) ;
#line 319
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 319 "/usr/include/wchar.h"
__inline extern wint_t btowc(int __c ) 
{ 
  int __cil_tmp2 ;
  wint_t __cil_tmp3 ;
  wint_t tmp ;

  {
  {
#line 320
  __cil_tmp2 = __builtin_constant_p(__c);
  }
#line 320
  if ((__cil_tmp2 && __c >= 0) && __c <= 127) {
#line 320
    tmp = (wint_t )__c;
  } else {
    {
#line 320
    __cil_tmp3 = __btowc_alias(__c);
#line 320
    tmp = __cil_tmp3;
    }
  }
#line 320
  return (tmp);
}
}
#line 323
extern int __wctob_alias(wint_t __c ) ;
#line 325
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 325 "/usr/include/wchar.h"
__inline extern int wctob(wint_t __wc ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 326
  __cil_tmp2 = __builtin_constant_p(__wc);
  }
#line 326
  if ((__cil_tmp2 && __wc >= 0U) && __wc <= 127U) {
#line 326
    tmp = (int )__wc;
  } else {
    {
#line 326
    __cil_tmp3 = __wctob_alias(__wc);
#line 326
    tmp = __cil_tmp3;
    }
  }
#line 326
  return (tmp);
}
}
#line 330
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 330 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   *__s , size_t __n , mbstate_t *__ps ) 
{ 
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  size_t tmp ;

  {
#line 332
  if (__ps != (void *)0) {
    {
#line 332
    __cil_tmp4 = mbrtowc((wchar_t *)((void *)0), __s, __n, __ps);
#line 332
    tmp = __cil_tmp4;
    }
  } else {
    {
#line 332
    __cil_tmp5 = __mbrlen(__s, __n, (mbstate_t *)((void *)0));
#line 332
    tmp = __cil_tmp5;
    }
  }
#line 332
  return (tmp);
}
}
#line 338
__inline extern  __attribute__((__nothrow__)) size_t mbsrtowcs(wchar_t *__dst , char const   **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 344
__inline extern  __attribute__((__nothrow__)) size_t wcsrtombs(char *__dst , wchar_t **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 352
__inline extern  __attribute__((__nothrow__)) size_t mbsnrtowcs(wchar_t *__dst , char const   **__src ,
                                                                size_t __nmc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) size_t wcsnrtombs(char *__dst , wchar_t **__src ,
                                                                size_t __nwc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 378
extern  __attribute__((__nothrow__)) double wcstod(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 383
extern  __attribute__((__nothrow__)) float wcstof(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 385
extern  __attribute__((__nothrow__)) long double wcstold(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 429
extern  __attribute__((__nothrow__)) long wcstol(wchar_t *__nptr , wchar_t **__endptr ,
                                                 int __base ) ;
#line 434
extern  __attribute__((__nothrow__)) unsigned long wcstoul(wchar_t *__nptr , wchar_t **__endptr ,
                                                           int __base ) ;
#line 442
extern  __attribute__((__nothrow__)) long long wcstoll(wchar_t *__nptr , wchar_t **__endptr ,
                                                       int __base ) ;
#line 449
extern  __attribute__((__nothrow__)) unsigned long long wcstoull(wchar_t *__nptr ,
                                                                 wchar_t **__endptr ,
                                                                 int __base ) ;
#line 552
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 557
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 581
extern  __attribute__((__nothrow__)) __FILE *open_wmemstream(wchar_t **__bufloc ,
                                                             size_t *__sizeloc ) ;
#line 588
extern  __attribute__((__nothrow__)) int fwide(__FILE *__fp , int __mode ) ;
#line 595
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 602
__inline extern int wprintf(wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 605
__inline extern  __attribute__((__nothrow__)) int swprintf(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 613
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 621
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 626
__inline extern  __attribute__((__nothrow__)) int vswprintf(wchar_t *__s , size_t __n ,
                                                            wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 636
extern int fwscanf(__FILE *__stream , wchar_t *__format  , ...) ;
#line 643
extern int wscanf(wchar_t *__format  , ...) ;
#line 646
extern  __attribute__((__nothrow__)) int swscanf(wchar_t *__s , wchar_t *__format 
                                                 , ...) ;
#line 688
extern int vfwscanf(__FILE *__s , wchar_t *__format , __gnuc_va_list __arg ) ;
#line 696
extern int vwscanf(wchar_t *__format , __gnuc_va_list __arg ) ;
#line 700
extern  __attribute__((__nothrow__)) int vswscanf(wchar_t *__s , wchar_t *__format ,
                                                  __gnuc_va_list __arg ) ;
#line 744
extern wint_t fgetwc(__FILE *__stream ) ;
#line 745
extern wint_t getwc(__FILE *__stream ) ;
#line 751
extern wint_t getwchar(void) ;
#line 758
extern wint_t fputwc(wchar_t __wc , __FILE *__stream ) ;
#line 759
extern wint_t putwc(wchar_t __wc , __FILE *__stream ) ;
#line 765
extern wint_t putwchar(wchar_t __wc ) ;
#line 773
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 780
extern int fputws(wchar_t *__ws , __FILE *__stream ) ;
#line 788
extern wint_t ungetwc(wint_t __wc , __FILE *__stream ) ;
#line 852
extern  __attribute__((__nothrow__)) size_t wcsftime(wchar_t *__s , size_t __maxsize ,
                                                     wchar_t *__format , struct tm *__tp ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                            size_t __n , size_t __ns1 ) ;
#line 27
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                              size_t __n ) ;
#line 31
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk_warn(wchar_t *__s1 , wchar_t *__s2 ,
                                                                 size_t __n , size_t __ns1 ) ;
#line 39
__inline extern  __attribute__((__nothrow__)) int *wmemcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                           size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int *wmemcpy(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 42
  __cil_tmp7 = __builtin_object_size(__s1, 0);
  }
  {
#line 42
  __cil_tmp5 = __builtin_object_size(__s1, 0);
#line 42
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 42
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 42
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 42
    __cil_tmp8 = __wmemcpy_alias(__s1, __s2, __n);
#line 42
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 42
    __cil_tmp12 = __builtin_object_size(__s1, 0);
    }
    {
#line 42
    __cil_tmp10 = __builtin_object_size(__s1, 0);
#line 42
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 42
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 42
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 42
      __cil_tmp13 = __builtin_object_size(__s1, 0);
#line 42
      __cil_tmp14 = __wmemcpy_chk_warn(__s1, __s2, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 42
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 42
      __cil_tmp15 = __builtin_object_size(__s1, 0);
#line 42
      __cil_tmp16 = __wmemcpy_chk(__s1, __s2, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 42
      tmp = __cil_tmp16;
      }
    }
#line 42
    tmp___0 = tmp;
  }
#line 42
  return (tmp___0);
}
}
#line 48
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 50
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n ) ;
#line 53
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t *__s2 ,
                                                                  size_t __n , size_t __ns1 ) ;
#line 60
__inline extern  __attribute__((__nothrow__)) int *wmemmove(wchar_t *__s1 , wchar_t *__s2 ,
                                                            size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int *wmemmove(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 62
  __cil_tmp7 = __builtin_object_size(__s1, 0);
  }
  {
#line 62
  __cil_tmp5 = __builtin_object_size(__s1, 0);
#line 62
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 62
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 62
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 62
    __cil_tmp8 = __wmemmove_alias(__s1, __s2, __n);
#line 62
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 62
    __cil_tmp12 = __builtin_object_size(__s1, 0);
    }
    {
#line 62
    __cil_tmp10 = __builtin_object_size(__s1, 0);
#line 62
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 62
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 62
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 62
      __cil_tmp13 = __builtin_object_size(__s1, 0);
#line 62
      __cil_tmp14 = __wmemmove_chk_warn(__s1, __s2, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 62
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 62
      __cil_tmp15 = __builtin_object_size(__s1, 0);
#line 62
      __cil_tmp16 = __wmemmove_chk(__s1, __s2, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 62
      tmp = __cil_tmp16;
      }
    }
#line 62
    tmp___0 = tmp;
  }
#line 62
  return (tmp___0);
}
}
#line 94
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk(wchar_t *__s , wchar_t __c ,
                                                            size_t __n , size_t __ns ) ;
#line 96
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_alias(wchar_t *__s , wchar_t __c ,
                                                              size_t __n ) ;
#line 98
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk_warn(wchar_t *__s , wchar_t __c ,
                                                                 size_t __n , size_t __ns ) ;
#line 105
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemset(wchar_t *__s , wchar_t __c ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmemset(wchar_t *__s , wchar_t __c , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 107
  __cil_tmp7 = __builtin_object_size(__s, 0);
  }
  {
#line 107
  __cil_tmp5 = __builtin_object_size(__s, 0);
#line 107
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 107
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 107
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 107
    __cil_tmp8 = __wmemset_alias(__s, __c, __n);
#line 107
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 107
    __cil_tmp12 = __builtin_object_size(__s, 0);
    }
    {
#line 107
    __cil_tmp10 = __builtin_object_size(__s, 0);
#line 107
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 107
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 107
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 107
      __cil_tmp13 = __builtin_object_size(__s, 0);
#line 107
      __cil_tmp14 = __wmemset_chk_warn(__s, __c, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 107
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 107
      __cil_tmp15 = __builtin_object_size(__s, 0);
#line 107
      __cil_tmp16 = __wmemset_chk(__s, __c, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 107
      tmp = __cil_tmp16;
      }
    }
#line 107
    tmp___0 = tmp;
  }
#line 107
  return (tmp___0);
}
}
#line 113
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __n ) ;
#line 116
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 121
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 121 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 123
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 123
  sz = __cil_tmp4;
  }
#line 124
  if (sz != 0xffffffffffffffffUL) {
    {
#line 125
    __cil_tmp5 = __wcscpy_chk(__dest, __src, sz / sizeof(wchar_t ));
    }
#line 125
    return (__cil_tmp5);
  }
  {
#line 126
  __cil_tmp6 = __wcscpy_alias(__dest, __src);
  }
#line 126
  return (__cil_tmp6);
}
}
#line 130
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __destlen ) ;
#line 133
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 138
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 140
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 140
  sz = __cil_tmp4;
  }
#line 141
  if (sz != 0xffffffffffffffffUL) {
    {
#line 142
    __cil_tmp5 = __wcpcpy_chk(__dest, __src, sz / sizeof(wchar_t ));
    }
#line 142
    return (__cil_tmp5);
  }
  {
#line 143
  __cil_tmp6 = __wcpcpy_alias(__dest, __src);
  }
#line 143
  return (__cil_tmp6);
}
}
#line 147
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 150
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 154
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk_warn(wchar_t *__dest ,
                                                                 wchar_t *__src ,
                                                                 size_t __n , size_t __destlen ) ;
#line 162
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 162 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 165
  __cil_tmp7 = __builtin_object_size(__dest, 1);
  }
  {
#line 165
  __cil_tmp5 = __builtin_object_size(__dest, 1);
#line 165
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 165
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 165
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 165
    __cil_tmp8 = __wcsncpy_alias(__dest, __src, __n);
#line 165
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 165
    __cil_tmp12 = __builtin_object_size(__dest, 1);
    }
    {
#line 165
    __cil_tmp10 = __builtin_object_size(__dest, 1);
#line 165
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 165
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 165
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 165
      __cil_tmp13 = __builtin_object_size(__dest, 1);
#line 165
      __cil_tmp14 = __wcsncpy_chk_warn(__dest, __src, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 165
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 165
      __cil_tmp15 = __builtin_object_size(__dest, 1);
#line 165
      __cil_tmp16 = __wcsncpy_chk(__dest, __src, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 165
      tmp = __cil_tmp16;
      }
    }
#line 165
    tmp___0 = tmp;
  }
#line 165
  return (tmp___0);
}
}
#line 171
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 174
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 178
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk_warn(wchar_t *__dest ,
                                                                 wchar_t *__src ,
                                                                 size_t __n , size_t __destlen ) ;
#line 186
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 186 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 189
  __cil_tmp7 = __builtin_object_size(__dest, 1);
  }
  {
#line 189
  __cil_tmp5 = __builtin_object_size(__dest, 1);
#line 189
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 189
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 189
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 189
    __cil_tmp8 = __wcpncpy_alias(__dest, __src, __n);
#line 189
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 189
    __cil_tmp12 = __builtin_object_size(__dest, 1);
    }
    {
#line 189
    __cil_tmp10 = __builtin_object_size(__dest, 1);
#line 189
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 189
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 189
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 189
      __cil_tmp13 = __builtin_object_size(__dest, 1);
#line 189
      __cil_tmp14 = __wcpncpy_chk_warn(__dest, __src, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 189
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 189
      __cil_tmp15 = __builtin_object_size(__dest, 1);
#line 189
      __cil_tmp16 = __wcpncpy_chk(__dest, __src, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 189
      tmp = __cil_tmp16;
      }
    }
#line 189
    tmp___0 = tmp;
  }
#line 189
  return (tmp___0);
}
}
#line 195
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __destlen ) ;
#line 198
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 203
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscat(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 203 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcscat(wchar_t *__dest , wchar_t *__src ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 205
  __cil_tmp4 = __builtin_object_size(__dest, 1);
#line 205
  sz = __cil_tmp4;
  }
#line 206
  if (sz != 0xffffffffffffffffUL) {
    {
#line 207
    __cil_tmp5 = __wcscat_chk(__dest, __src, sz / sizeof(wchar_t ));
    }
#line 207
    return (__cil_tmp5);
  }
  {
#line 208
  __cil_tmp6 = __wcscat_alias(__dest, __src);
  }
#line 208
  return (__cil_tmp6);
}
}
#line 212
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 215
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  wchar_t *__cil_tmp6 ;
  wchar_t *__cil_tmp7 ;

  {
  {
#line 224
  __cil_tmp5 = __builtin_object_size(__dest, 1);
#line 224
  sz = __cil_tmp5;
  }
#line 225
  if (sz != 0xffffffffffffffffUL) {
    {
#line 226
    __cil_tmp6 = __wcsncat_chk(__dest, __src, __n, sz / sizeof(wchar_t ));
    }
#line 226
    return (__cil_tmp6);
  }
  {
#line 227
  __cil_tmp7 = __wcsncat_alias(__dest, __src, __n);
  }
#line 227
  return (__cil_tmp7);
}
}
#line 231
extern  __attribute__((__nothrow__)) int __swprintf_chk(wchar_t *__s , size_t __n ,
                                                        int __flag , size_t __s_len ,
                                                        wchar_t *__format  , ...) ;
#line 236
extern  __attribute__((__nothrow__)) int __swprintf_alias(wchar_t *__s , size_t __n ,
                                                          wchar_t *__fmt  , ...) ;
#line 243
__inline extern  __attribute__((__nothrow__)) int swprintf(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 243 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int swprintf(wchar_t *__s , size_t __n , wchar_t *__fmt  , ...) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 246
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 246
  sz = __cil_tmp5;
  }
#line 247
  if (1) {
    {
#line 248
    __cil_tmp6 = __builtin_va_arg_pack();
#line 248
    __cil_tmp7 = __swprintf_chk(__s, __n, 1, sz / sizeof(wchar_t ), __fmt, __cil_tmp6);
    }
#line 248
    return (__cil_tmp7);
  }
  {
#line 250
  __cil_tmp8 = __builtin_va_arg_pack();
#line 250
  __cil_tmp9 = __swprintf_alias(__s, __n, __fmt, __cil_tmp8);
  }
#line 250
  return (__cil_tmp9);
}
}
#line 261
extern  __attribute__((__nothrow__)) int __vswprintf_chk(wchar_t *__s , size_t __n ,
                                                         int __flag , size_t __s_len ,
                                                         wchar_t *__format , __gnuc_va_list __arg ) ;
#line 267
extern  __attribute__((__nothrow__)) int __vswprintf_alias(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt , __gnuc_va_list __ap ) ;
#line 273
__inline extern  __attribute__((__nothrow__)) int vswprintf(wchar_t *__s , size_t __n ,
                                                            wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 273 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vswprintf(wchar_t *__s , size_t __n , wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 276
  __cil_tmp6 = __builtin_object_size(__s, 1);
#line 276
  sz = __cil_tmp6;
  }
#line 277
  if (1) {
    {
#line 278
    __cil_tmp7 = __vswprintf_chk(__s, __n, 1, sz / sizeof(wchar_t ), __fmt, __ap);
    }
#line 278
    return (__cil_tmp7);
  }
  {
#line 280
  __cil_tmp8 = __vswprintf_alias(__s, __n, __fmt, __ap);
  }
#line 280
  return (__cil_tmp8);
}
}
#line 286
extern int __fwprintf_chk(__FILE *__stream , int __flag , wchar_t *__format  , ...) ;
#line 288
extern int __wprintf_chk(int __flag , wchar_t *__format  , ...) ;
#line 290
extern int __vfwprintf_chk(__FILE *__stream , int __flag , wchar_t *__format , __gnuc_va_list __ap ) ;
#line 293
extern int __vwprintf_chk(int __flag , wchar_t *__format , __gnuc_va_list __ap ) ;
#line 298
__inline extern int wprintf(wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 298 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int wprintf(wchar_t *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 300
  __cil_tmp2 = __builtin_va_arg_pack();
#line 300
  __cil_tmp3 = __wprintf_chk(1, __fmt, __cil_tmp2);
  }
#line 300
  return (__cil_tmp3);
}
}
#line 304
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 304 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 306
  __cil_tmp3 = __builtin_va_arg_pack();
#line 306
  __cil_tmp4 = __fwprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 306
  return (__cil_tmp4);
}
}
#line 317
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 319
  __cil_tmp3 = __vwprintf_chk(1, __fmt, __ap);
  }
#line 319
  return (__cil_tmp3);
}
}
#line 323
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 323 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 326
  __cil_tmp4 = __vfwprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 326
  return (__cil_tmp4);
}
}
#line 331
extern wchar_t *__fgetws_chk(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 333
extern wchar_t *__fgetws_alias(wchar_t *__s , int __n , __FILE *__stream ) ;
#line 336
extern wchar_t *__fgetws_chk_warn(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 343
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  wchar_t *__cil_tmp11 ;
  wchar_t *__cil_tmp12 ;

  {
  {
#line 345
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 345
  sz = __cil_tmp5;
#line 346
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(wchar_t ));
  }
  {
#line 346
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 346
  if (__cil_tmp6) {
#line 346
    if (__n > 0) {
#line 346
      if (__cil_tmp7) {
#line 346
        if ((unsigned long )__n <= sz / sizeof(wchar_t )) {
          {
#line 347
          __cil_tmp8 = __fgetws_alias(__s, __n, __stream);
          }
#line 347
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 348
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(wchar_t ));
  }
  {
#line 348
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 348
  if (__cil_tmp9) {
#line 348
    if (__n > 0) {
#line 348
      if (__cil_tmp10) {
#line 348
        if (! ((unsigned long )__n <= sz / sizeof(wchar_t ))) {
          {
#line 349
          __cil_tmp11 = __fgetws_chk_warn(__s, sz / sizeof(wchar_t ), __n, __stream);
          }
#line 349
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 350
  __cil_tmp12 = __fgetws_chk(__s, sz / sizeof(wchar_t ), __n, __stream);
  }
#line 350
  return (__cil_tmp12);
}
}
#line 382
extern  __attribute__((__nothrow__)) size_t __wcrtomb_chk(char *__s , wchar_t __wchar ,
                                                          mbstate_t *__p , size_t __buflen ) ;
#line 385
extern  __attribute__((__nothrow__)) size_t __wcrtomb_alias(char *__s , wchar_t __wchar ,
                                                            mbstate_t *__ps ) ;
#line 390
__inline extern  __attribute__((__nothrow__)) size_t wcrtomb(char *__s , wchar_t __wchar ,
                                                             mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 390 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcrtomb(char *__s , wchar_t __wchar , mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 400
  __cil_tmp5 = __builtin_object_size(__s, 1);
  }
  {
#line 400
  __cil_tmp4 = __builtin_object_size(__s, 1);
  }
#line 400
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 400
    if (16UL > __cil_tmp5) {
      {
#line 402
      __cil_tmp6 = __builtin_object_size(__s, 1);
#line 402
      __cil_tmp7 = __wcrtomb_chk(__s, __wchar, __ps, __cil_tmp6);
      }
#line 402
      return (__cil_tmp7);
    }
  }
  {
#line 403
  __cil_tmp8 = __wcrtomb_alias(__s, __wchar, __ps);
  }
#line 403
  return (__cil_tmp8);
}
}
#line 407
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk(wchar_t *__dst , char const   **__src ,
                                                            size_t __len , mbstate_t *__ps ,
                                                            size_t __dstlen ) ;
#line 411
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_alias(wchar_t *__dst , char const   **__src ,
                                                              size_t __len , mbstate_t *__ps ) ;
#line 416
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk_warn(wchar_t *__dst ,
                                                                 char const   **__src ,
                                                                 size_t __len , mbstate_t *__ps ,
                                                                 size_t __dstlen ) ;
#line 425
__inline extern  __attribute__((__nothrow__)) size_t mbsrtowcs(wchar_t *__dst , char const   **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 425 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t mbsrtowcs(wchar_t *__dst , char const   **__src , size_t __len ,
                                 mbstate_t *__ps ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  size_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 428
  __cil_tmp8 = __builtin_object_size(__dst, 1);
  }
  {
#line 428
  __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 428
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(wchar_t ));
  }
  {
#line 428
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 428
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(wchar_t )) {
    {
#line 428
    __cil_tmp9 = __mbsrtowcs_alias(__dst, __src, __len, __ps);
#line 428
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 428
    __cil_tmp13 = __builtin_object_size(__dst, 1);
    }
    {
#line 428
    __cil_tmp11 = __builtin_object_size(__dst, 1);
#line 428
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(wchar_t ));
    }
    {
#line 428
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 428
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(wchar_t ))) {
      {
#line 428
      __cil_tmp14 = __builtin_object_size(__dst, 1);
#line 428
      __cil_tmp15 = __mbsrtowcs_chk_warn(__dst, __src, __len, __ps, __cil_tmp14 / sizeof(wchar_t ));
#line 428
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 428
      __cil_tmp16 = __builtin_object_size(__dst, 1);
#line 428
      __cil_tmp17 = __mbsrtowcs_chk(__dst, __src, __len, __ps, __cil_tmp16 / sizeof(wchar_t ));
#line 428
      tmp = __cil_tmp17;
      }
    }
#line 428
    tmp___0 = tmp;
  }
#line 428
  return (tmp___0);
}
}
#line 434
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk(char *__dst , wchar_t **__src ,
                                                            size_t __len , mbstate_t *__ps ,
                                                            size_t __dstlen ) ;
#line 438
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_alias(char *__dst , wchar_t **__src ,
                                                              size_t __len , mbstate_t *__ps ) ;
#line 443
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk_warn(char *__dst , wchar_t **__src ,
                                                                 size_t __len , mbstate_t *__ps ,
                                                                 size_t __dstlen ) ;
#line 451
__inline extern  __attribute__((__nothrow__)) size_t wcsrtombs(char *__dst , wchar_t **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 451 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcsrtombs(char *__dst , wchar_t **__src , size_t __len , mbstate_t *__ps ) 
{ 
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  int __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  size_t __cil_tmp15 ;
  unsigned long __cil_tmp16 ;
  size_t __cil_tmp17 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 454
  __cil_tmp8 = __builtin_object_size(__dst, 1);
  }
  {
#line 454
  __cil_tmp6 = __builtin_object_size(__dst, 1);
#line 454
  __cil_tmp7 = __builtin_constant_p((unsigned long )__len <= __cil_tmp6 / sizeof(char ));
  }
  {
#line 454
  __cil_tmp5 = __builtin_constant_p(__len);
  }
#line 454
  if (__cil_tmp7 && (unsigned long )__len <= __cil_tmp8 / sizeof(char )) {
    {
#line 454
    __cil_tmp9 = __wcsrtombs_alias(__dst, __src, __len, __ps);
#line 454
    tmp___0 = __cil_tmp9;
    }
  } else {
    {
#line 454
    __cil_tmp13 = __builtin_object_size(__dst, 1);
    }
    {
#line 454
    __cil_tmp11 = __builtin_object_size(__dst, 1);
#line 454
    __cil_tmp12 = __builtin_constant_p((unsigned long )__len <= __cil_tmp11 / sizeof(char ));
    }
    {
#line 454
    __cil_tmp10 = __builtin_constant_p(__len);
    }
#line 454
    if (__cil_tmp12 && ! ((unsigned long )__len <= __cil_tmp13 / sizeof(char ))) {
      {
#line 454
      __cil_tmp14 = __builtin_object_size(__dst, 1);
#line 454
      __cil_tmp15 = __wcsrtombs_chk_warn(__dst, __src, __len, __ps, __cil_tmp14);
#line 454
      tmp = __cil_tmp15;
      }
    } else {
      {
#line 454
      __cil_tmp16 = __builtin_object_size(__dst, 1);
#line 454
      __cil_tmp17 = __wcsrtombs_chk(__dst, __src, __len, __ps, __cil_tmp16);
#line 454
      tmp = __cil_tmp17;
      }
    }
#line 454
    tmp___0 = tmp;
  }
#line 454
  return (tmp___0);
}
}
#line 461
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk(wchar_t *__dst , char const   **__src ,
                                                             size_t __nmc , size_t __len ,
                                                             mbstate_t *__ps , size_t __dstlen ) ;
#line 465
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_alias(wchar_t *__dst , char const   **__src ,
                                                               size_t __nmc , size_t __len ,
                                                               mbstate_t *__ps ) ;
#line 470
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk_warn(wchar_t *__dst ,
                                                                  char const   **__src ,
                                                                  size_t __nmc , size_t __len ,
                                                                  mbstate_t *__ps ,
                                                                  size_t __dstlen ) ;
#line 479
__inline extern  __attribute__((__nothrow__)) size_t mbsnrtowcs(wchar_t *__dst , char const   **__src ,
                                                                size_t __nmc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 479 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t mbsnrtowcs(wchar_t *__dst , char const   **__src , size_t __nmc ,
                                  size_t __len , mbstate_t *__ps ) 
{ 
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 482
  __cil_tmp9 = __builtin_object_size(__dst, 1);
  }
  {
#line 482
  __cil_tmp7 = __builtin_object_size(__dst, 1);
#line 482
  __cil_tmp8 = __builtin_constant_p((unsigned long )__len <= __cil_tmp7 / sizeof(wchar_t ));
  }
  {
#line 482
  __cil_tmp6 = __builtin_constant_p(__len);
  }
#line 482
  if (__cil_tmp8 && (unsigned long )__len <= __cil_tmp9 / sizeof(wchar_t )) {
    {
#line 482
    __cil_tmp10 = __mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps);
#line 482
    tmp___0 = __cil_tmp10;
    }
  } else {
    {
#line 482
    __cil_tmp14 = __builtin_object_size(__dst, 1);
    }
    {
#line 482
    __cil_tmp12 = __builtin_object_size(__dst, 1);
#line 482
    __cil_tmp13 = __builtin_constant_p((unsigned long )__len <= __cil_tmp12 / sizeof(wchar_t ));
    }
    {
#line 482
    __cil_tmp11 = __builtin_constant_p(__len);
    }
#line 482
    if (__cil_tmp13 && ! ((unsigned long )__len <= __cil_tmp14 / sizeof(wchar_t ))) {
      {
#line 482
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 482
      __cil_tmp16 = __mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, __cil_tmp15 / sizeof(wchar_t ));
#line 482
      tmp = __cil_tmp16;
      }
    } else {
      {
#line 482
      __cil_tmp17 = __builtin_object_size(__dst, 1);
#line 482
      __cil_tmp18 = __mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, __cil_tmp17 / sizeof(wchar_t ));
#line 482
      tmp = __cil_tmp18;
      }
    }
#line 482
    tmp___0 = tmp;
  }
#line 482
  return (tmp___0);
}
}
#line 488
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk(char *__dst , wchar_t **__src ,
                                                             size_t __nwc , size_t __len ,
                                                             mbstate_t *__ps , size_t __dstlen ) ;
#line 493
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_alias(char *__dst , wchar_t **__src ,
                                                               size_t __nwc , size_t __len ,
                                                               mbstate_t *__ps ) ;
#line 498
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk_warn(char *__dst , wchar_t **__src ,
                                                                  size_t __nwc , size_t __len ,
                                                                  mbstate_t *__ps ,
                                                                  size_t __dstlen ) ;
#line 507
__inline extern  __attribute__((__nothrow__)) size_t wcsnrtombs(char *__dst , wchar_t **__src ,
                                                                size_t __nwc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 507 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcsnrtombs(char *__dst , wchar_t **__src , size_t __nwc , size_t __len ,
                                  mbstate_t *__ps ) 
{ 
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  size_t __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  size_t __cil_tmp18 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 510
  __cil_tmp9 = __builtin_object_size(__dst, 1);
  }
  {
#line 510
  __cil_tmp7 = __builtin_object_size(__dst, 1);
#line 510
  __cil_tmp8 = __builtin_constant_p((unsigned long )__len <= __cil_tmp7 / sizeof(char ));
  }
  {
#line 510
  __cil_tmp6 = __builtin_constant_p(__len);
  }
#line 510
  if (__cil_tmp8 && (unsigned long )__len <= __cil_tmp9 / sizeof(char )) {
    {
#line 510
    __cil_tmp10 = __wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps);
#line 510
    tmp___0 = __cil_tmp10;
    }
  } else {
    {
#line 510
    __cil_tmp14 = __builtin_object_size(__dst, 1);
    }
    {
#line 510
    __cil_tmp12 = __builtin_object_size(__dst, 1);
#line 510
    __cil_tmp13 = __builtin_constant_p((unsigned long )__len <= __cil_tmp12 / sizeof(char ));
    }
    {
#line 510
    __cil_tmp11 = __builtin_constant_p(__len);
    }
#line 510
    if (__cil_tmp13 && ! ((unsigned long )__len <= __cil_tmp14 / sizeof(char ))) {
      {
#line 510
      __cil_tmp15 = __builtin_object_size(__dst, 1);
#line 510
      __cil_tmp16 = __wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, __cil_tmp15);
#line 510
      tmp = __cil_tmp16;
      }
    } else {
      {
#line 510
      __cil_tmp17 = __builtin_object_size(__dst, 1);
#line 510
      __cil_tmp18 = __wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, __cil_tmp17);
#line 510
      tmp = __cil_tmp18;
      }
    }
#line 510
    tmp___0 = tmp;
  }
#line 510
  return (tmp___0);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 101
extern  __attribute__((__nothrow__)) int iswalpha(wint_t __wc ) ;
#line 104
extern  __attribute__((__nothrow__)) int iswcntrl(wint_t __wc ) ;
#line 108
extern  __attribute__((__nothrow__)) int iswdigit(wint_t __wc ) ;
#line 112
extern  __attribute__((__nothrow__)) int iswgraph(wint_t __wc ) ;
#line 117
extern  __attribute__((__nothrow__)) int iswlower(wint_t __wc ) ;
#line 120
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 125
extern  __attribute__((__nothrow__)) int iswpunct(wint_t __wc ) ;
#line 130
extern  __attribute__((__nothrow__)) int iswspace(wint_t __wc ) ;
#line 135
extern  __attribute__((__nothrow__)) int iswupper(wint_t __wc ) ;
#line 140
extern  __attribute__((__nothrow__)) int iswxdigit(wint_t __wc ) ;
#line 146
extern  __attribute__((__nothrow__)) int iswblank(wint_t __wc ) ;
#line 155
extern  __attribute__((__nothrow__)) wctype_t wctype(char const   *__property ) ;
#line 159
extern  __attribute__((__nothrow__)) int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 166
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t towupper(wint_t __wc ) ;
#line 52 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wctrans_t wctrans(char const   *__property ) ;
#line 55
extern  __attribute__((__nothrow__)) wint_t towctrans(wint_t __wc , wctrans_t __desc ) ;
#line 63
extern  __attribute__((__nothrow__)) int iswalnum_l(wint_t __wc , locale_t __locale ) ;
#line 69
extern  __attribute__((__nothrow__)) int iswalpha_l(wint_t __wc , locale_t __locale ) ;
#line 72
extern  __attribute__((__nothrow__)) int iswcntrl_l(wint_t __wc , locale_t __locale ) ;
#line 76
extern  __attribute__((__nothrow__)) int iswdigit_l(wint_t __wc , locale_t __locale ) ;
#line 80
extern  __attribute__((__nothrow__)) int iswgraph_l(wint_t __wc , locale_t __locale ) ;
#line 85
extern  __attribute__((__nothrow__)) int iswlower_l(wint_t __wc , locale_t __locale ) ;
#line 88
extern  __attribute__((__nothrow__)) int iswprint_l(wint_t __wc , locale_t __locale ) ;
#line 93
extern  __attribute__((__nothrow__)) int iswpunct_l(wint_t __wc , locale_t __locale ) ;
#line 98
extern  __attribute__((__nothrow__)) int iswspace_l(wint_t __wc , locale_t __locale ) ;
#line 103
extern  __attribute__((__nothrow__)) int iswupper_l(wint_t __wc , locale_t __locale ) ;
#line 108
extern  __attribute__((__nothrow__)) int iswxdigit_l(wint_t __wc , locale_t __locale ) ;
#line 113
extern  __attribute__((__nothrow__)) int iswblank_l(wint_t __wc , locale_t __locale ) ;
#line 117
extern  __attribute__((__nothrow__)) wctype_t wctype_l(char const   *__property ,
                                                       locale_t __locale ) ;
#line 122
extern  __attribute__((__nothrow__)) int iswctype_l(wint_t __wc , wctype_t __desc ,
                                                    locale_t __locale ) ;
#line 130
extern  __attribute__((__nothrow__)) wint_t towlower_l(wint_t __wc , locale_t __locale ) ;
#line 133
extern  __attribute__((__nothrow__)) wint_t towupper_l(wint_t __wc , locale_t __locale ) ;
#line 137
extern  __attribute__((__nothrow__)) wctrans_t wctrans_l(char const   *__property ,
                                                         locale_t __locale ) ;
#line 141
extern  __attribute__((__nothrow__)) wint_t towctrans_l(wint_t __wc , wctrans_t __desc ,
                                                        locale_t __locale ) ;
#line 53 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int langint  =    26;
#line 59 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
char const   *lang_prefixes[130]  = 
#line 59
  {      "ach",      "af",      "ak",      "am", 
        "an",      "ar",      "as",      "ast", 
        "az",      "be",      "bg",      "bm", 
        "bn",      "bo",      "br",      "brx", 
        "bs",      "ca@valencia",      "ca",      "cgg", 
        "cs",      "cy",      "da",      "de", 
        "doi",      "el",      "en",      "en_AU", 
        "en_CA",      "en_GB",      "en_ZA",      "eo", 
        "es_MX",      "es",      "et",      "eu", 
        "fa",      "ff",      "fi",      "fo", 
        "fr",      "ga",      "gd",      "gl", 
        "gos",      "gu",      "he",      "hi", 
        "hr",      "hu",      "hy",      "tlh", 
        "id",      "is",      "it",      "iu", 
        "ja",      "ka",      "kab",      "kn", 
        "km",      "kok@roman",      "kok",      "ko", 
        "ks@devanagari",      "ks",      "ku",      "lb", 
        "lg",      "lt",      "lv",      "mai", 
        "ml",      "mk",      "mn",      "mni", 
        "mni@meiteimayek",      "mr",      "ms",      "nb", 
        "ne",      "nl",      "nn",      "nr", 
        "nso",      "oc",      "oj",      "or", 
        "pa",      "pl",      "pt_BR",      "pt", 
        "ro",      "ru",      "rw",      "sat@olchiki", 
        "sat",      "sa",      "sc",      "sd", 
        "sd@devanagari",      "shs",      "si",      "sk", 
        "sl",      "son",      "sq",      "sr@latin\323\001 ", 
        "sr",      "su",      "sv",      "sw", 
        "ta",      "te",      "th",      "tl", 
        "tr",      "tw",      "uk",      "ur", 
        "vec",      "ve",      "vi",      "wa", 
        "wo",      "xh",      "zam",      "zh_CN", 
        "zh_TW",      "zu"};
#line 194 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int lang_use_own_font[14]  = 
#line 194
  {      5,      13,      45,      47, 
        56,      57,      63,      72, 
        112,      113,      114,      127, 
        128,      - 1};
#line 212 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int lang_use_right_to_left[7]  = {      5,      36,      46,      65, 
        99,      119,      - 1};
#line 223 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int lang_use_right_to_left_word[1]  = {      - 1};
#line 232 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int lang_y_nudge[2][2]  = { {        60,        4}, 
   {        - 1,        - 1}};
#line 252 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static language_to_locale_struct language_to_locale_array[187]  = 
#line 252
  {      {"english", "C"}, 
        {"american-english", "C"}, 
        {"acholi", "ach_UG.UTF-8"}, 
        {"acoli", "ach_UG.UTF-8"}, 
        {"akan", "ak_GH.UTF-8"}, 
        {"twi-fante", "ak_GH.UTF-8"}, 
        {"amharic", "am_ET.UTF-8"}, 
        {"arabic", "ar_SA.UTF-8"}, 
        {"aragones\323\001 ", "an_ES.UTF-8"}, 
        {"armenian\323\001 ", "hy_AM.UTF-8"}, 
        {"hayeren", "hy_AM.UTF-8"}, 
        {"assamese\323\001 ", "as_IN.UTF-8"}, 
        {"asturian\323\001 ", "ast_ES.UTF-8"}, 
        {"azerbaijani", "az_AZ.UTF-8"}, 
        {"bambara", "bm_ML.UTF-8"}, 
        {"bengali", "bn_IN.UTF-8"}, 
        {"bodo", "brx_IN.UTF-8"}, 
        {"bosnian", "bs_BA.UTF-8"}, 
        {"croatian\323\001 ", "hr_HR.UTF-8"}, 
        {"hrvatski\323\001 ", "hr_HR.UTF-8"}, 
        {"catalan", "ca_ES.UTF-8"}, 
        {"catala", "ca_ES.UTF-8"}, 
        {"valencian", "ca_ES.UTF-8@valencia"}, 
        {"valencia\323\001 ", "ca_ES.UTF-8@valencia"}, 
        {"kiga", "cgg_UG.UTF-8"}, 
        {"chiga", "cgg_UG.UTF-8"}, 
        {"belarusian", "be_BY.UTF-8"}, 
        {"bielaruskaja", "be_BY.UTF-8"}, 
        {"czech", "cs_CZ.UTF-8"}, 
        {"cesky", "cs_CZ.UTF-8"}, 
        {"danish", "da_DK.UTF-8"}, 
        {"dansk", "da_DK.UTF-8"}, 
        {"dogri", "doi_IN.UTF-8"}, 
        {"german", "de_DE.UTF-8"}, 
        {"deutsch", "de_DE.UTF-8"}, 
        {"estonian\323\001 ", "et_EE.UTF-8"}, 
        {"greek", "el_GR.UTF-8"}, 
        {"gronings\323\001 ", "gos_NL.UTF-8"}, 
        {"zudelk-veenkelonioals", "gos_NL.UTF-8"}, 
        {"gujarati\323\001 ", "gu_IN.UTF-8"}, 
        {"british-english", "en_GB.UTF-8"}, 
        {"british", "en_GB.UTF-8"}, 
        {"australian-english", "en_AU.UTF-8"}, 
        {"canadian-english\323\001 ", "en_CA.UTF-8"}, 
        {"southafrican-english", "en_ZA.UTF-8"}, 
        {"esperanto", "eo.UTF-8\250"}, 
        {"spanish", "es_ES.UTF-8"}, 
        {"mexican", "es_MX.UTF-8"}, 
        {"mexican-spanish", "es_MX.UTF-8"}, 
        {"espanol-mejicano\323\001 ", "es_MX.UTF-8"}, 
        {"espanol", "es_ES.UTF-8"}, 
        {"persian", "fa_IR.UTF-8"}, 
        {"fula", "ff_SN.UTF-8"}, 
        {"fulah", "ff_SN.UTF-8"}, 
        {"pulaar-fulfulde", "ff_SN.UTF-8"}, 
        {"finnish", "fi_FI.UTF-8"}, 
        {"suomi", "fi_FI.UTF-8"}, 
        {"faroese", "fo_FO.UTF-8"}, 
        {"french", "fr_FR.UTF-8"}, 
        {"francais\323\001 ", "fr_FR.UTF-8"}, 
        {"gaelic", "ga_IE.UTF-8"}, 
        {"irish-gaelic", "ga_IE.UTF-8"}, 
        {"gaidhlig\323\001 ", "ga_IE.UTF-8"}, 
        {"scottish\323\001 ", "gd_GB.UTF-8"}, 
        {"ghaidhlig", "gd_GB.UTF-8"}, 
        {"scottish-gaelic", "gd_GB.UTF-8"}, 
        {"galician\323\001 ", "gl_ES.UTF-8"}, 
        {"galego", "gl_ES.UTF-8"}, 
        {"hebrew", "he_IL.UTF-8"}, 
        {"hindi", "hi_IN.UTF-8"}, 
        {"hungarian", "hu_HU.UTF-8"}, 
        {"magyar", "hu_HU.UTF-8"}, 
        {"indonesian", "id_ID.UTF-8"}, 
        {"bahasa-indonesia\323\001 ", "id_ID.UTF-8"}, 
        {"icelandic", "is_IS.UTF-8"}, 
        {"islenska\323\001 ", "is_IS.UTF-8"}, 
        {"italian", "it_IT.UTF-8"}, 
        {"italiano\323\001 ", "it_IT.UTF-8"}, 
        {"inuktitut", "iu_CA.UTF-8"}, 
        {"japanese\323\001 ", "ja_JP.UTF-8"}, 
        {"venda", "ve_ZA.UTF-8"}, 
        {"venetian\323\001 ", "vec.UTF-8"}, 
        {"veneto", "vec.UTF-8"}, 
        {"vietnamese", "vi_VN.UTF-8"}, 
        {"afrikaans", "af_ZA.UTF-8"}, 
        {"albanian\323\001 ", "sq_AL.UTF-8"}, 
        {"breton", "br_FR.UTF-8"}, 
        {"brezhoneg", "br_FR.UTF-8"}, 
        {"bulgarian", "bg_BG.UTF-8"}, 
        {"welsh", "cy_GB.UTF-8"}, 
        {"cymraeg", "cy_GB.UTF-8"}, 
        {"bokmal", "nb_NO.UTF-8"}, 
        {"basque", "eu_ES.UTF-8"}, 
        {"euskara", "eu_ES.UTF-8"}, 
        {"georgian\323\001 ", "ka_GE"}, 
        {"kabyle", "kab"}, 
        {"kabylian\323\001 ", "kab"}, 
        {"kinyarwanda", "rw_RW.UTF-8"}, 
        {"klingon", "tlh.UTF-8"}, 
        {"tlhIngan\323\001 ", "tlh.UTF-8"}, 
        {"kannada", "kn_IN.UTF-8"}, 
        {"korean", "ko_KR.UTF-8"}, 
        {"kashmiri-devanagari", "ks_IN.UTF-8@devanagari"}, 
        {"kashmiri-perso-arabic", "ks_IN.UTF-8"}, 
        {"kurdish", "ku_TR.UTF-8"}, 
        {"tamil", "ta_IN.UTF-8"}, 
        {"telugu", "te_IN.UTF-8"}, 
        {"lithuanian", "lt_LT.UTF-8"}, 
        {"lietuviu\323\001 ", "lt_LT.UTF-8"}, 
        {"latvian", "lv_LV.UTF-8"}, 
        {"luganda", "lg_UG.UTF-8"}, 
        {"luxembourgish", "lb_LU.UTF-8"}, 
        {"letzebuergesch", "lb_LU.UTF-8"}, 
        {"konkani-devanagari", "kok_IN.UTF-8"}, 
        {"konkani-roman", "kok@roman"}, 
        {"maithili\323\001 ", "mai_IN.UTF-8"}, 
        {"macedonian", "mk_MK.UTF-8"}, 
        {"mongolian", "mn_MN.UTF-8"}, 
        {"manipuri-bengali\323\001 ", "mni_IN.UTF-8"}, 
        {"manipuri-meitei-mayek", "mni@meiteimayek"}, 
        {"marathi", "mr_IN.UTF-8"}, 
        {"malay", "ms_MY.UTF-8"}, 
        {"nepali", "ne_NP.UTF-8"}, 
        {"dutch", "nl_NL.UTF-8"}, 
        {"nederlands", "nl_NL.UTF-8"}, 
        {"norwegian", "nn_NO.UTF-8"}, 
        {"nynorsk", "nn_NO.UTF-8"}, 
        {"norsk", "nn_NO.UTF-8"}, 
        {"ndebele", "nr_ZA.UTF-8"}, 
        {"northern-sotho", "nso_ZA.UTF-8"}, 
        {"sesotho-sa-leboa\323\001 ", "nso_ZA.UTF-8"}, 
        {"occitan", "oc_FR.UTF-8"}, 
        {"odia", "or_IN.UTF-8"}, 
        {"oriya", "or_IN.UTF-8"}, 
        {"ojibwe", "oj_CA.UTF-8"}, 
        {"ojibway", "oj_CA.UTF-8"}, 
        {"punjabi", "pa_IN.UTF-8"}, 
        {"panjabi", "pa_IN.UTF-8"}, 
        {"polish", "pl_PL.UTF-8"}, 
        {"polski", "pl_PL.UTF-8"}, 
        {"brazilian-portuguese", "pt_BR.UTF-8"}, 
        {"portugues-brazilian", "pt_BR.UTF-8"}, 
        {"brazilian", "pt_BR.UTF-8"}, 
        {"portuguese", "pt_PT.UTF-8"}, 
        {"portugues", "pt_PT.UTF-8"}, 
        {"romanian\323\001 ", "ro_RO.UTF-8"}, 
        {"russian", "ru_RU.UTF-8"}, 
        {"russkiy", "ru_RU.UTF-8"}, 
        {"sanskrit\323\001 ", "sa_IN.UTF-8"}, 
        {"santali-devanagari", "sat_IN.UTF-8"}, 
        {"santali-ol-chiki\323\001 ", "sat@olchiki"}, 
        {"sardinian", "sc_IT"}, 
        {"sardu", "sc_IT"}, 
        {"serbian", "sr_RS.UTF-8"}, 
        {"serbian-latin", "sr_RS@latin"}, 
        {"shuswap", "shs_CA.UTF-8"}, 
        {"secwepemctin", "shs_CA.UTF-8"}, 
        {"sindhi-perso-arabic", "sd_IN.UTF-8"}, 
        {"sindhi-devanagari", "sd_IN.UTF-8@devanagari"}, 
        {"sinhala", "si_LK.UTF-8"}, 
        {"slovak", "sk_SK.UTF-8"}, 
        {"slovenian", "sl_SI.UTF-8"}, 
        {"slovensko", "sl_SI.UTF-8"}, 
        {"songhay", "son.UTF-8"}, 
        {"sundanese", "su_ID.UTF-8"}, 
        {"swedish", "sv_SE.UTF-8"}, 
        {"svenska", "sv_SE.UTF-8"}, 
        {"swahili", "sw_TZ.UTF-8"}, 
        {"tagalog", "tl_PH.UTF-8"}, 
        {"thai", "th_TH.UTF-8"}, 
        {"tibetan", "bo_CN.UTF-8"}, 
        {"turkish", "tr_TR.UTF-8"}, 
        {"twi", "tw_GH.UTF-8"}, 
        {"ukrainian", "uk_UA.UTF-8"}, 
        {"urdu", "ur_IN.UTF-8"}, 
        {"walloon", "wa_BE.UTF-8"}, 
        {"walon", "wa_BE.UTF-8"}, 
        {"wolof", "wo_SN.UTF-8"}, 
        {"xhosa", "xh_ZA.UTF-8"}, 
        {"chinese", "zh_CN.UTF-8"}, 
        {"simplified-chinese", "zh_CN.UTF-8"}, 
        {"traditional-chinese", "zh_TW.UTF-8"}, 
        {"zapotec", "zam.UTF-8"}, 
        {"miahuatlan-zapotec", "zam.UTF-8"}, 
        {"khmer", "km_KH.UTF-8"}, 
        {"malayalam", "ml_IN.UTF-8"}, 
        {"zulu", "zu_ZA.UTF-8"}};
#line 450 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static void show_lang_usage(int exitcode ) 
{ 
  FILE *f ;
  FILE *tmp ;
  char const   *prg ;

  {
#line 452
  if (exitcode) {
#line 452
    tmp = stderr;
  } else {
#line 452
    tmp = stdout;
  }
  {
#line 452
  f = tmp;
#line 453
  prg = "tuxpaint\220";
#line 456
  fprintf(f, "\nUsage: %s [--lang LANGUAGE]\n\nLANGUAGE may be one of:\n  english      american-english\n  acholi       acoli\n  afrikaans\n  akan         twi-fante\n  albanian\n  amharic\n  arabic\n  aragones\n  armenian     hayeren\n  assamese\n  asturian\n  australian-english\n  azerbaijani\n  bambara\n  basque       euskara\n  belarusian   bielaruskaja\n  bengali\n  bodo\n  bokmal\n  bosnian\n  brazilian    brazilian-portuguese   portugues-brazilian\n  breton       brezhoneg\n  british      british-english\n  bulgarian\n  canadian-english\n  catalan      catala\n  chinese      simplified-chinese\n               traditional-chinese\n  croatian     hrvatski\n  czech        cesky\n  danish       dansk\n  dogri\n  dutch        nederlands\n  esperanto\n  estonian\n  faroese\n  finnish      suomi\n  french       francais\n  fula         fulah                  pulaar-fulfulde\n  gaelic       irish-gaelic           gaidhlig\n  galician     galego\n  georgian\n  german       deutsch\n  greek\n  gronings     zudelk-veenkelonioals\n  gujarati\n  hebrew\n  hindi\n  hungarian    magyar\n  icelandic    islenska\n  indonesian   bahasa-indonesia\n  inuktitut\n  italian      italiano\n  japanese\n  kabyle       kabylian\n  kannada\n  kashmiri-devanagari\n  kashmiri-perso-arabic\n  khmer\n  kiga         chiga\n  kinyarwanda\n  klingon      tlhIngan\n  konkani-devanagari\n  konkani-roman\n  korean\n  kurdish\n  latvian\n  lithuanian   lietuviu\n  luganda\n  luxembourgish letzebuergesch\n  maithili\n  macedonian\n  malay\n  malayalam\n  manipuri-bengali\n  manipuri-meitei-mayek\n  marathi\n  mexican      mexican-spanish        espanol-mejicano\n  mongolian\n  ndebele\n  nepali\n  northern-sotho                      sesotho-sa-leboa\n  norwegian    nynorsk                norsk\n  occitan\n  odia         oriya\n  ojibwe       ojibway\n  persian\n  polish       polski\n  portuguese   portugues\n  punjabi      panjabi\n  romanian\n  russian      russkiy\n  sanskrit\n  santali-devanagari\n  santali-ol-chiki\n  sardinian    sardu\n  scottish     scottish-gaelic        ghaidhlig\n  serbian\n  serbian-latin\n  shuswap      secwepemctin\n  sindhi-devanagari\n  sindhi-perso-arabic\n  sinhala\n  slovak\n  slovenian    slovensko\n  southafrican-english\n  songhay\n  spanish      espanol\n  sundanese\n  swahili\n  swedish      svenska\n  tagalog\n  tamil\n  telugu\n  thai\n  twi\n  tibetan\n  turkish\n  ukrainian\n  urdu\n  valencian    valencia\n  venda\n  venetian     veneto\n  vietnamese\n  walloon      walon\n  wolof\n  welsh        cymraeg\n  xhosa\n  zapotec      miahuatlan-zapotec\n  zulu\n\n",
          prg);
#line 588
  exit(exitcode);
  }
}
}
#line 598 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static void show_locale_usage(FILE *f , char const   *prg ) 
{ 


  {
  {
#line 601
  fprintf(f, "\nUsage: %s [--locale LOCALE]\n\nLOCALE may be one of:\n  C       (English      American English)\n  ach_UG  (Acholi       Acoli)\n  af_ZA   (Afrikaans)\n  ak_GH   (Akan         Twi-Fante)\n  am_ET   (Amharic)\n  ar_SA   (Arabic)\n  an_ES   (Aragones)\n  hy_AM   (Armenian)\n  as_IN   (Assamese)\n  ast_ES  (Asturian)\n  az_AZ   (Azerbaijani)\n  bm_ML   (Bambara)\n  eu_ES   (Basque       Euskara)\n  be_BY   (Belarusian   Bielaruskaja)\n  bn_IN   (Bengali)\n  brx_IN  (Bodo)\n  bs_BA   (Bosnian)\n  nb_NO   (Bokmal)\n  pt_BR   (Brazilian    Brazilian Portuguese   Portugues Brazilian)\n  br_FR   (Breton       Brezhoneg)\n  en_AU   (Australian English)\n  en_CA   (Canadian English)\n  en_GB   (British      British English)\n  en_ZA   (South African English)\n  bg_BG   (Bulgarian)\n  ca_ES   (Catalan      Catala)\n  ca_ES@valencia   (Valencian    Valencia)n  zh_CN   (Chinese-Simplified)\n  zh_TW   (Chinese-Traditional)\n  cs_CZ   (Czech        Cesky)\n  da_DK   (Danish       Dansk)\n  doi_IN   (Dogri)\n  nl_NL   (Dutch)\n  fa_IR   (Persian)\n  ff_SN   (Fulah)\n  fi_FI   (Finnish      Suomi)\n  fo_FO   (Faroese)\n  fr_FR   (French       Francais)\n  ga_IE   (Irish Gaelic Gaidhlig)\n  gd_GB   (Scottish Gaelic  Ghaidhlig)\n  gl_ES   (Galician     Galego)\n  gos_NL  (Gronings     Zudelk Veenkelonioals)\n  gu_IN   (Gujarati)\n  de_DE   (German       Deutsch)\n  eo      (Esperanto)\n  et_EE   (Estonian)\n  el_GR   (Greek)\n  he_IL   (Hebrew)\n  hi_IN   (Hindi)\n  hr_HR   (Croatian     Hrvatski)\n  hu_HU   (Hungarian    Magyar)\n  cgg_UG  (Kiga         Chiga)\n  tlh     (Klingon      tlhIngan)\n  is_IS   (Icelandic    Islenska)\n  id_ID   (Indonesian   Bahasa Indonesia)\n  it_IT   (Italian      Italiano)\n  iu_CA   (Inuktitut)\n  ja_JP   (Japanese)\n  ka_GE   (Georgian)\n  kn_IN   (Kannada)\n  km_KH   (Khmer)\n  ko_KR   (Korean)\n  ks_IN@devanagari   (Kashmiri (Devanagari))\n  ks_IN   (Kashmiri (Perso-Arabic))\n  ku_TR   (Kurdish)\n  ms_MY   (Malay)\n  ml_IN   (Malayalam)\n  lg_UG   (Luganda)\n  lb_LU   (Luxembourgish Letzebuergesch)\n  lv_LV   (Latvian)\n  lt_LT   (Lithuanian   Lietuviu)\n  kok_IN  (Konkani (Devanagari))\n  kok@roman  (Konkani (Roman))\n  mai_IN  (Maithili)\n  mk_MK   (Macedonian)\n  mni_IN  (Manipuri (Bengali))\n  mni@meiteimayek (Manipuri(Meitei Mayek))\n  mn_MN   (Mongolian)\n  mr_IN   (Marathi)\n  nr_ZA   (Ndebele)\n  ne_NP   (Nepali)\n  nso_ZA  (Northern Sotho                      Sotho sa Leboa)\n  nn_NO   (Norwegian    Nynorsk                Norsk)\n  oc_FR   (Occitan)\n  oj_CA   (Ojibway)\n  or_IN   (Odia         Oriya)\n  pa_IN   (Punjabi      Panjabi)\n  pl_PL   (Polish       Polski)\n  pt_PT   (Portuguese   Portugues)\n  ro_RO   (Romanian)\n  ru_RU   (Russian      Russkiy)\n  rw_RW   (Kinyarwanda)\n  sa_IN   (Sanskrit)\n  sat_IN  (Santali)\n  sat@olchiki  (Santali (Ol-Chiki))\n  sc_IT   (Sardinian)\n  sd_IN@devanagari  (Sindhi (Devanagari))\n  sd_IN  (Sindhii (Perso-Arabic))\n  shs_CA  (Shuswap      Secwepemctin)\n  si_LK   (Sinhala)\n  sk_SK   (Slovak)\n  sl_SI   (Slovenian)\n  son     (Songhay)\n  sq_AL   (Albanian)\n  sr_YU   (Serbian (cyrillic))\n  sr_RS@latin  (Serbian (latin))\n  es_ES   (Spanish      Espanol)\n  su_ID   (Sundanese)\n  es_MX   (Mexican      Mexican Spanish       Espanol Mejicano)\n  sw_TZ   (Swahili)\n  sv_SE   (Swedish      Svenska)\n  ta_IN   (Tamil)\n  te_IN   (Telugu)\n  tl_PH   (Tagalog)\n  bo_CN   (Tibetan)\n  th_TH   (Thai)\n  tr_TR   (Turkish)\n  tw_GH  (Twi)\n  uk_UA   (Ukrainian)\n  ur_IN   (Urdu)\n  ve_ZA   (Venda)\n  vec     (Venetian)\n  vi_VN   (Vietnamese)\n  wa_BE   (Walloon)\n  wo_SN   (Wolof)\n  cy_GB   (Welsh        Cymraeg)\n  xh_ZA   (Xhosa)\n  zam     (Zapoteco-Miahuatlan)\n  zu_ZA   (Zulu)\n\n",
          prg);
  }
  return;
}
}
#line 740 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
int get_current_language(void) 
{ 


  {
#line 742
  return (langint);
}
}
#line 752 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int search_int_array(int l , int *array ) 
{ 
  int i ;
  int __cil_tmp4 ;

  {
#line 756
  i = 0;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (*(array + i) != -1)) {
#line 756
      goto while_break;
    }
#line 758
    if (*(array + i) == l) {
#line 759
      return (1);
    }
#line 756
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  return (0);
}
}
#line 771 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static void ctype_utf8(void) 
{ 
  char const   *names[5] ;
  int i ;
  int __cil_tmp3 ;

  {
#line 776
  names[0] = "en_US.UTF8\270s\324U";
#line 776
  names[1] = "en_US.UTF-8";
#line 776
  names[2] = "UTF8";
#line 776
  names[3] = "UTF-8";
#line 776
  names[4] = "C.UTF-8";
#line 777
  i = (int )(sizeof(names) / sizeof(names[0]));
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! 1) {
#line 779
      goto while_break;
    }
    {
#line 781
    __cil_tmp3 = iswprint((wint_t )((wchar_t )247));
    }
#line 781
    if (__cil_tmp3) {
#line 782
      return;
    }
#line 783
    i --;
#line 783
    if (i < 0) {
#line 784
      goto while_break;
    }
    {
#line 785
    setlocale(0, names[i]);
#line 786
    setlocale(5, names[i]);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 788
  fprintf(stderr, "Failed to find a locale with iswprint() working!\n");
  }
  return;
}
}
#line 798 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static char const   *language_to_locale(char const   *langstr ) 
{ 
  int i ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 800
  i = (int )(sizeof(language_to_locale_array) / sizeof(language_to_locale_array[0]));
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    __cil_tmp3 = i;
#line 802
    i --;
#line 802
    if (! __cil_tmp3) {
#line 802
      goto while_break;
    }
    {
#line 804
    __cil_tmp4 = strcmp(langstr, language_to_locale_array[i].language);
    }
#line 804
    if (! __cil_tmp4) {
#line 805
      return (language_to_locale_array[i].locale);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 807
  __cil_tmp6 = strcmp(langstr, "list");
  }
  {
#line 807
  __cil_tmp5 = strcmp(langstr, "help");
  }
#line 807
  if (__cil_tmp5 == 0) {
    {
    {
#line 808
    show_lang_usage(0);
    }
    }
  } else
#line 807
  if (__cil_tmp6 == 0) {
    {
    {
#line 808
    show_lang_usage(0);
    }
    }
  }
  {
#line 809
  fprintf(stderr, "%s is an invalid language\n", langstr);
#line 810
  show_lang_usage(59);
  }
#line 811
  return ((char const   *)((void *)0));
}
}
#line 820 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static void set_langint_from_locale_string(char const   *loc ) 
{ 
  char *baseloc ;
  char *__cil_tmp3 ;
  char *dot ;
  char *__cil_tmp5 ;
  char *at ;
  char *__cil_tmp7 ;
  char *cntrycode ;
  char *__cil_tmp9 ;
  char straux[255] ;
  char *ataux ;
  char *ccodeaux ;
  size_t len_baseloc ;
  int found ;
  int i ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  unsigned long __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  unsigned long __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  unsigned long __cil_tmp32 ;
  unsigned long __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  unsigned long __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;

  {
  {
#line 822
  __cil_tmp3 = strdup(loc);
#line 822
  baseloc = __cil_tmp3;
#line 823
  __cil_tmp5 = strchr((char const   *)baseloc, '.');
#line 823
  dot = __cil_tmp5;
#line 824
  __cil_tmp7 = strchr((char const   *)baseloc, '@');
#line 824
  at = __cil_tmp7;
#line 825
  __cil_tmp9 = strchr((char const   *)baseloc, '_');
#line 825
  cntrycode = __cil_tmp9;
#line 827
  ataux = (char *)((void *)0);
#line 828
  ccodeaux = (char *)((void *)0);
#line 830
  found = 0;
  }
#line 835
  if (! loc) {
#line 836
    return;
  }
#line 846
  if (dot) {
#line 847
    *dot = (char )'\000';
  }
#line 849
  if (cntrycode) {
    {
#line 851
    ccodeaux = strdup((char const   *)cntrycode);
#line 852
    *cntrycode = (char )'\000';
    }
  }
#line 855
  if (at) {
    {
#line 857
    ataux = strdup((char const   *)at);
#line 858
    *at = (char )'\000';
    }
#line 860
    if (cntrycode) {
      {
#line 864
      snprintf((char *)straux, (unsigned long )255, "%s%s%s", baseloc, ccodeaux, ataux);
#line 865
      len_baseloc = strlen((char const   *)((char *)straux));
#line 866
      i = 0;
      }
      {
#line 866
      while (1) {
        while_continue: /* CIL Label */ ;
#line 866
        if (! (i < 130 && found == 0)) {
#line 866
          goto while_break;
        }
        {
#line 869
        __cil_tmp20 = strncasecmp((char const   *)((char *)straux), lang_prefixes[i],
                                  len_baseloc);
        }
        {
#line 869
        __cil_tmp19 = strlen(lang_prefixes[i]);
        }
#line 869
        if (len_baseloc == __cil_tmp19) {
#line 869
          if (! __cil_tmp20) {
#line 871
            langint = i;
#line 872
            found = 1;
          }
        }
#line 866
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 879
    snprintf((char *)straux, (unsigned long )255, "%s%s", baseloc, ataux);
#line 880
    len_baseloc = strlen((char const   *)((char *)straux));
#line 881
    i = 0;
    }
    {
#line 881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 881
      if (! (i < 130 && found == 0)) {
#line 881
        goto while_break___0;
      }
      {
#line 884
      __cil_tmp24 = strncasecmp((char const   *)((char *)straux), lang_prefixes[i],
                                len_baseloc);
      }
      {
#line 884
      __cil_tmp23 = strlen(lang_prefixes[i]);
      }
#line 884
      if (len_baseloc == __cil_tmp23) {
#line 884
        if (! __cil_tmp24) {
#line 886
          langint = i;
#line 887
          found = 1;
        }
      }
#line 881
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 892
  if (cntrycode) {
    {
#line 896
    snprintf((char *)straux, (unsigned long )255, "%s%s", baseloc, ccodeaux);
#line 897
    len_baseloc = strlen((char const   *)((char *)straux));
#line 901
    i = 0;
    }
    {
#line 901
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 901
      if (! (i < 130 && found == 0)) {
#line 901
        goto while_break___1;
      }
      {
#line 904
      __cil_tmp28 = strlen(lang_prefixes[i]);
#line 904
      __cil_tmp29 = strncasecmp((char const   *)((char *)straux), lang_prefixes[i],
                                __cil_tmp28);
      }
      {
#line 904
      __cil_tmp27 = strlen(lang_prefixes[i]);
      }
#line 904
      if (len_baseloc == __cil_tmp27) {
#line 904
        if (! __cil_tmp29) {
#line 907
          langint = i;
#line 908
          found = 1;
        }
      }
#line 901
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 915
  len_baseloc = strlen((char const   *)baseloc);
#line 918
  i = 0;
  }
  {
#line 918
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 918
    if (! (i < 130 && found == 0)) {
#line 918
      goto while_break___2;
    }
    {
#line 921
    __cil_tmp33 = strlen(lang_prefixes[i]);
#line 921
    __cil_tmp34 = strncasecmp((char const   *)baseloc, lang_prefixes[i], __cil_tmp33);
    }
    {
#line 921
    __cil_tmp32 = strlen(lang_prefixes[i]);
    }
#line 921
    if (len_baseloc == __cil_tmp32) {
#line 921
      if (! __cil_tmp34) {
#line 923
        langint = i;
#line 924
        found = 1;
      }
    }
#line 918
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 935
  i = 0;
  {
#line 935
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 935
    if (! (i < 130 && found == 0)) {
#line 935
      goto while_break___3;
    }
    {
#line 938
    __cil_tmp36 = strlen(lang_prefixes[i]);
#line 938
    __cil_tmp37 = strncasecmp(loc, lang_prefixes[i], __cil_tmp36);
    }
#line 938
    if (! __cil_tmp37) {
#line 940
      langint = i;
#line 941
      found = 1;
    }
#line 935
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 946
  free(baseloc);
  }
#line 947
  if (ataux) {
    {
#line 948
    free(ataux);
    }
  }
#line 949
  if (ccodeaux) {
    {
#line 950
    free(ccodeaux);
    }
  }
  return;
}
}
#line 966 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static void mysetenv(char const   *name , char const   *value ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 973
  if (name != (void *)0) {
#line 973
    if (value != (void *)0) {
      {
#line 975
      setenv(name, value, 1);
      }
    } else {
#line 973
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 984
    if (name == (void *)0) {
#line 984
      tmp = "NULL";
    } else {
#line 984
      tmp = name;
    }
#line 984
    if (value == (void *)0) {
#line 984
      tmp___0 = "NULL";
    } else {
#line 984
      tmp___0 = value;
    }
    {
#line 984
    fprintf(stderr, "WARNING: mysetenv() received a null pointer. name=%s, value=%s\n",
            tmp, tmp___0);
    }
  }
  return;
}
}
#line 999 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
static int set_current_language(char const   *loc , int *ptr_num_wished_langs ) 
{ 
  int i ;
  int j ;
  char *oldloc ;
  char *env_language ;
  char *env_language_lang ;
  char *env ;
  int num_wished_langs___0 ;
  unsigned long __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 1002
  j = 0;
#line 1007
  num_wished_langs___0 = 0;
#line 1009
  *ptr_num_wished_langs = 0;
#line 1011
  __cil_tmp10 = strlen(loc);
  }
#line 1011
  if (__cil_tmp10 > 0UL) {
    {
#line 1015
    mysetenv("LANGUAGE\230\001", loc);
    }
  } else {
    {
#line 1022
    env = getenv("LANGUAGE\220");
    }
#line 1023
    if (env == (void *)0) {
      _L___6: /* CIL Label */ 
      {
#line 1025
      env = getenv("LC_ALL");
      }
#line 1026
      if (env != (void *)0) {
#line 1026
        if ((int )*(env + 0) != 0) {
          {
#line 1029
          __cil_tmp13 = getenv("LC_ALL");
#line 1029
          mysetenv("LANGUAGE\230", (char const   *)__cil_tmp13);
          }
        } else {
#line 1026
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        {
#line 1033
        env = getenv("LC_MESSAGES");
        }
#line 1034
        if (env != (void *)0) {
#line 1034
          if ((int )*(env + 0) != 0) {
            {
#line 1037
            __cil_tmp15 = getenv("LC_MESSAGES");
#line 1037
            mysetenv("LANGUAGE\230", (char const   *)__cil_tmp15);
            }
          } else {
#line 1034
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1041
          env = getenv("LANG");
          }
#line 1042
          if (env != (void *)0) {
#line 1042
            if ((int )*(env + 0) != 0) {
              {
#line 1045
              __cil_tmp17 = getenv("LANG");
#line 1045
              mysetenv("LANGUAGE\230", (char const   *)__cil_tmp17);
              }
            } else {

            }
          } else {

          }
        }
      }
    } else
#line 1023
    if ((int )*(env + 0) == 0) {
#line 1023
      goto _L___6;
    } else {

    }
  }
  {
#line 1060
  oldloc = strdup(loc);
#line 1067
  setlocale(6, "\220");
#line 1068
  setlocale(6, loc);
#line 1069
  ctype_utf8();
#line 1073
  bindtextdomain("tuxpaintpG\271s\324U", "/usr/local/share/locale/");
#line 1076
  bind_textdomain_codeset("tuxpaint\323\001 ", "UTF-8");
#line 1078
  textdomain("tuxpaint\220");
#line 1082
  __cil_tmp19 = setlocale(5, (char const   *)((void *)0));
#line 1082
  loc = (char const   *)__cil_tmp19;
#line 1084
  __cil_tmp21 = strcmp(loc, (char const   *)oldloc);
  }
  {
#line 1084
  __cil_tmp20 = strcmp((char const   *)oldloc, "\220");
  }
#line 1084
  if (__cil_tmp20 != 0) {
#line 1084
    if (__cil_tmp21 != 0) {
      {
#line 1112
      mysetenv("LANGUAGE\230\001", (char const   *)oldloc);
#line 1113
      set_langint_from_locale_string((char const   *)oldloc);
      }
    } else {
#line 1084
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
    {
#line 1122
    __cil_tmp22 = getenv("LANGUAGE\220");
    }
#line 1122
    if (__cil_tmp22 == (void *)0) {
      {
#line 1123
      mysetenv("LANGUAGE\323\001 ", "C");
      }
    }
  }
  {
#line 1125
  __cil_tmp23 = getenv("LANGUAGE\220");
#line 1125
  __cil_tmp24 = strdup((char const   *)__cil_tmp23);
#line 1125
  env_language = __cil_tmp24;
  }
#line 1127
  if (*env_language) {
    {
#line 1129
    env_language_lang = strtok(env_language, ":");
    }
    {
#line 1130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1130
      if (! (env_language_lang != (void *)0)) {
#line 1130
        goto while_break;
      }
      {
#line 1132
      num_wished_langs___0 ++;
#line 1133
      set_langint_from_locale_string((char const   *)env_language_lang);
#line 1134
      wished_langs[j].langint = langint;
#line 1135
      wished_langs[j].lang_prefix = lang_prefixes[langint];
#line 1136
      wished_langs[j].need_own_font = search_int_array(langint, (int *)lang_use_own_font);
#line 1137
      wished_langs[j].need_right_to_left = search_int_array(langint, (int *)lang_use_right_to_left);
#line 1138
      wished_langs[j].need_right_to_left_word = search_int_array(langint, (int *)lang_use_right_to_left_word);
#line 1139
      i = 0;
      }
      {
#line 1139
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1139
        if (! (lang_y_nudge[i][0] != -1)) {
#line 1139
          goto while_break___0;
        }
#line 1142
        if (lang_y_nudge[i][0] == langint) {
#line 1144
          wished_langs[j].lang_y_nudge = lang_y_nudge[i][1];
#line 1145
          goto while_break___0;
        }
#line 1139
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1150
      j ++;
#line 1151
      env_language_lang = strtok((char *)((void *)0), ":");
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1153
    if (*env_language) {
      {
#line 1154
      free(env_language);
      }
    }
  }
  {
#line 1159
  lang_prefix = lang_prefixes[wished_langs[0].langint];
#line 1161
  __cil_tmp33 = strdup(lang_prefix);
#line 1161
  short_lang_prefix = (char const   *)__cil_tmp33;
#line 1163
  __cil_tmp34 = strchr(short_lang_prefix, '_');
  }
#line 1163
  if (__cil_tmp34) {
    {
#line 1164
    __cil_tmp35 = strchr(short_lang_prefix, '_');
#line 1164
    *__cil_tmp35 = (char )'\000';
    }
  }
  {
#line 1166
  need_own_font = wished_langs[0].need_own_font;
#line 1167
  need_right_to_left = wished_langs[0].need_right_to_left;
#line 1168
  need_right_to_left_word = wished_langs[0].need_right_to_left_word;
#line 1176
  free(oldloc);
#line 1180
  *ptr_num_wished_langs = num_wished_langs___0;
  }
#line 1182
  return (wished_langs[0].lang_y_nudge);
}
}
#line 1197 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/i18n.c"
int setup_i18n(char const   *lang , char const   *locale , int *num_wished_langs___0 ) 
{ 
  int __cil_tmp4 ;
  char const   *__cil_tmp5 ;
  int __cil_tmp6 ;

  {

#line 1202
  if (locale) {
    {
#line 1204
    __cil_tmp4 = strcmp(locale, "help");
    }
#line 1204
    if (! __cil_tmp4) {
      {
#line 1206
      show_locale_usage(stdout, "tuxpaint");
#line 1207
      exit(0);
      }
    }
  } else {
#line 1211
    locale = "\220";
  }
#line 1213
  if (lang) {
    {
#line 1214
    locale = language_to_locale(lang);
    }
  }
  {
#line 1215
  __cil_tmp6 = set_current_language(locale, num_wished_langs___0);
  }
#line 1215
  return (__cil_tmp6);
}
}
#line 115 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static unsigned int draw_colors(unsigned int action ) ;
#line 124 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static scaleparams scaletable[28]  = 
#line 124
  {      {(unsigned int )1, (unsigned int )256}, 
        {(unsigned int )3, (unsigned int )512}, 
        {(unsigned int )1, (unsigned int )128}, 
        {(unsigned int )3, (unsigned int )256}, 
        {(unsigned int )1, (unsigned int )64}, 
        {(unsigned int )3, (unsigned int )128}, 
        {(unsigned int )1, (unsigned int )32}, 
        {(unsigned int )3, (unsigned int )64}, 
        {(unsigned int )1, (unsigned int )16}, 
        {(unsigned int )3, (unsigned int )32}, 
        {(unsigned int )1, (unsigned int )8}, 
        {(unsigned int )3, (unsigned int )16}, 
        {(unsigned int )1, (unsigned int )4}, 
        {(unsigned int )3, (unsigned int )8}, 
        {(unsigned int )1, (unsigned int )2}, 
        {(unsigned int )3, (unsigned int )4}, 
        {(unsigned int )1, (unsigned int )1}, 
        {(unsigned int )3, (unsigned int )2}, 
        {(unsigned int )2, (unsigned int )1}, 
        {(unsigned int )3, (unsigned int )1}, 
        {(unsigned int )4, (unsigned int )1}, 
        {(unsigned int )6, (unsigned int )1}, 
        {(unsigned int )8, (unsigned int )1}, 
        {(unsigned int )12, (unsigned int )1}, 
        {(unsigned int )16, (unsigned int )1}, 
        {(unsigned int )24, (unsigned int )1}, 
        {(unsigned int )32, (unsigned int )1}, 
        {(unsigned int )48, (unsigned int )1}};
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
#line 34
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
#line 62 "/usr/include/wordexp.h"
extern int wordexp(char const   *__words , wordexp_t *__pwordexp , int __flags ) ;
#line 66
extern  __attribute__((__nothrow__)) void wordfree(wordexp_t *__wordexp ) ;
#line 182 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *wcschrnul(wchar_t *__s , wchar_t __wc ) ;
#line 234
extern  __attribute__((__nothrow__)) wchar_t *wcswcs(wchar_t *__haystack , wchar_t *__needle ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 368
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
#line 372
extern  __attribute__((__nothrow__)) int wcswidth(wchar_t *__s , size_t __n ) ;
#line 397
extern  __attribute__((__nothrow__)) int wcstof32(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 402
extern  __attribute__((__nothrow__)) int wcstof64(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 407
extern  __attribute__((__nothrow__)) int wcstof128(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 412
extern  __attribute__((__nothrow__)) int wcstof32x(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 417
extern  __attribute__((__nothrow__)) int wcstof64x(wchar_t *__nptr , wchar_t **__endptr ) ;
#line 458
extern  __attribute__((__nothrow__)) long long wcstoq(wchar_t *__nptr , wchar_t **__endptr ,
                                                      int __base ) ;
#line 465
extern  __attribute__((__nothrow__)) unsigned long long wcstouq(wchar_t *__nptr ,
                                                                wchar_t **__endptr ,
                                                                int __base ) ;
#line 474
extern  __attribute__((__nothrow__)) long wcstol_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                   int __base , locale_t __loc ) ;
#line 478
extern  __attribute__((__nothrow__)) unsigned long wcstoul_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                             int __base , locale_t __loc ) ;
#line 483
extern  __attribute__((__nothrow__)) long long wcstoll_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                         int __base , locale_t __loc ) ;
#line 488
extern  __attribute__((__nothrow__)) unsigned long long wcstoull_l(wchar_t *__nptr ,
                                                                   wchar_t **__endptr ,
                                                                   int __base , locale_t __loc ) ;
#line 493
extern  __attribute__((__nothrow__)) double wcstod_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                     locale_t __loc ) ;
#line 497
extern  __attribute__((__nothrow__)) float wcstof_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                    locale_t __loc ) ;
#line 501
extern  __attribute__((__nothrow__)) long double wcstold_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                           locale_t __loc ) ;
#line 512
extern  __attribute__((__nothrow__)) int wcstof32_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                    locale_t __loc ) ;
#line 518
extern  __attribute__((__nothrow__)) int wcstof64_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                    locale_t __loc ) ;
#line 524
extern  __attribute__((__nothrow__)) int wcstof128_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                     locale_t __loc ) ;
#line 530
extern  __attribute__((__nothrow__)) int wcstof32x_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                     locale_t __loc ) ;
#line 536
extern  __attribute__((__nothrow__)) int wcstof64x_l(wchar_t *__nptr , wchar_t **__endptr ,
                                                     locale_t __loc ) ;
#line 799
extern wint_t getwc_unlocked(__FILE *__stream ) ;
#line 800
extern wint_t getwchar_unlocked(void) ;
#line 808
extern wint_t fgetwc_unlocked(__FILE *__stream ) ;
#line 816
extern wint_t fputwc_unlocked(wchar_t __wc , __FILE *__stream ) ;
#line 825
extern wint_t putwc_unlocked(wchar_t __wc , __FILE *__stream ) ;
#line 826
extern wint_t putwchar_unlocked(wchar_t __wc ) ;
#line 835
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 844
extern int fputws_unlocked(wchar_t *__ws , __FILE *__stream ) ;
#line 859
extern  __attribute__((__nothrow__)) size_t wcsftime_l(wchar_t *__s , size_t __maxsize ,
                                                       wchar_t *__format , struct tm *__tp ,
                                                       locale_t __loc ) ;
#line 69 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 72
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n ) ;
#line 76
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t *__s2 ,
                                                                  size_t __n , size_t __ns1 ) ;
#line 84
__inline extern  __attribute__((__nothrow__)) wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__,
__gnu_inline__)) ;
#line 84 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  int __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  wchar_t *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  wchar_t *__cil_tmp16 ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;

  {
  {
#line 87
  __cil_tmp7 = __builtin_object_size(__s1, 0);
  }
  {
#line 87
  __cil_tmp5 = __builtin_object_size(__s1, 0);
#line 87
  __cil_tmp6 = __builtin_constant_p((unsigned long )__n <= __cil_tmp5 / sizeof(wchar_t ));
  }
  {
#line 87
  __cil_tmp4 = __builtin_constant_p(__n);
  }
#line 87
  if (__cil_tmp6 && (unsigned long )__n <= __cil_tmp7 / sizeof(wchar_t )) {
    {
#line 87
    __cil_tmp8 = __wmempcpy_alias(__s1, __s2, __n);
#line 87
    tmp___0 = __cil_tmp8;
    }
  } else {
    {
#line 87
    __cil_tmp12 = __builtin_object_size(__s1, 0);
    }
    {
#line 87
    __cil_tmp10 = __builtin_object_size(__s1, 0);
#line 87
    __cil_tmp11 = __builtin_constant_p((unsigned long )__n <= __cil_tmp10 / sizeof(wchar_t ));
    }
    {
#line 87
    __cil_tmp9 = __builtin_constant_p(__n);
    }
#line 87
    if (__cil_tmp11 && ! ((unsigned long )__n <= __cil_tmp12 / sizeof(wchar_t ))) {
      {
#line 87
      __cil_tmp13 = __builtin_object_size(__s1, 0);
#line 87
      __cil_tmp14 = __wmempcpy_chk_warn(__s1, __s2, __n, __cil_tmp13 / sizeof(wchar_t ));
#line 87
      tmp = __cil_tmp14;
      }
    } else {
      {
#line 87
      __cil_tmp15 = __builtin_object_size(__s1, 0);
#line 87
      __cil_tmp16 = __wmempcpy_chk(__s1, __s2, __n, __cil_tmp15 / sizeof(wchar_t ));
#line 87
      tmp = __cil_tmp16;
      }
    }
#line 87
    tmp___0 = tmp;
  }
#line 87
  return (tmp___0);
}
}
#line 354
extern wchar_t *__fgetws_unlocked_chk(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 357
extern wchar_t *__fgetws_unlocked_alias(wchar_t *__s , int __n , __FILE *__stream ) ;
#line 361
extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t *__s , size_t __size , int __n ,
                                           __FILE *__stream ) ;
#line 369
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 369 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream ) 
{ 
  size_t sz ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  wchar_t *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  wchar_t *__cil_tmp11 ;
  wchar_t *__cil_tmp12 ;

  {
  {
#line 371
  __cil_tmp5 = __builtin_object_size(__s, 1);
#line 371
  sz = __cil_tmp5;
#line 372
  __cil_tmp7 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(wchar_t ));
  }
  {
#line 372
  __cil_tmp6 = __builtin_constant_p(__n);
  }
#line 372
  if (__cil_tmp6) {
#line 372
    if (__n > 0) {
#line 372
      if (__cil_tmp7) {
#line 372
        if ((unsigned long )__n <= sz / sizeof(wchar_t )) {
          {
#line 373
          __cil_tmp8 = __fgetws_unlocked_alias(__s, __n, __stream);
          }
#line 373
          return (__cil_tmp8);
        }
      }
    }
  }
  {
#line 374
  __cil_tmp10 = __builtin_constant_p((unsigned long )__n <= sz / sizeof(wchar_t ));
  }
  {
#line 374
  __cil_tmp9 = __builtin_constant_p(__n);
  }
#line 374
  if (__cil_tmp9) {
#line 374
    if (__n > 0) {
#line 374
      if (__cil_tmp10) {
#line 374
        if (! ((unsigned long )__n <= sz / sizeof(wchar_t ))) {
          {
#line 375
          __cil_tmp11 = __fgetws_unlocked_chk_warn(__s, sz / sizeof(wchar_t ), __n,
                                                   __stream);
          }
#line 375
          return (__cil_tmp11);
        }
      }
    }
  }
  {
#line 377
  __cil_tmp12 = __fgetws_unlocked_chk(__s, sz / sizeof(wchar_t ), __n, __stream);
  }
#line 377
  return (__cil_tmp12);
}
}
#line 56 "/usr/include/SDL/SDL_image.h"
extern SDL_version *IMG_Linked_Version(void) ;
#line 70
extern int IMG_Init(int flags ) ;
#line 73
extern void IMG_Quit(void) ;
#line 83
extern SDL_Surface *IMG_LoadTyped_RW(SDL_RWops *src , int freesrc , char *type ) ;
#line 85
extern SDL_Surface *IMG_Load(char const   *file ) ;
#line 86
extern SDL_Surface *IMG_Load_RW(SDL_RWops *src , int freesrc ) ;
#line 91
extern int IMG_InvertAlpha(int on ) ;
#line 94
extern int IMG_isICO(SDL_RWops *src ) ;
#line 95
extern int IMG_isCUR(SDL_RWops *src ) ;
#line 96
extern int IMG_isBMP(SDL_RWops *src ) ;
#line 97
extern int IMG_isGIF(SDL_RWops *src ) ;
#line 98
extern int IMG_isJPG(SDL_RWops *src ) ;
#line 99
extern int IMG_isLBM(SDL_RWops *src ) ;
#line 100
extern int IMG_isPCX(SDL_RWops *src ) ;
#line 101
extern int IMG_isPNG(SDL_RWops *src ) ;
#line 102
extern int IMG_isPNM(SDL_RWops *src ) ;
#line 103
extern int IMG_isTIF(SDL_RWops *src ) ;
#line 104
extern int IMG_isXCF(SDL_RWops *src ) ;
#line 105
extern int IMG_isXPM(SDL_RWops *src ) ;
#line 106
extern int IMG_isXV(SDL_RWops *src ) ;
#line 107
extern int IMG_isWEBP(SDL_RWops *src ) ;
#line 110
extern SDL_Surface *IMG_LoadICO_RW(SDL_RWops *src ) ;
#line 111
extern SDL_Surface *IMG_LoadCUR_RW(SDL_RWops *src ) ;
#line 112
extern SDL_Surface *IMG_LoadBMP_RW(SDL_RWops *src ) ;
#line 113
extern SDL_Surface *IMG_LoadGIF_RW(SDL_RWops *src ) ;
#line 114
extern SDL_Surface *IMG_LoadJPG_RW(SDL_RWops *src ) ;
#line 115
extern SDL_Surface *IMG_LoadLBM_RW(SDL_RWops *src ) ;
#line 116
extern SDL_Surface *IMG_LoadPCX_RW(SDL_RWops *src ) ;
#line 117
extern SDL_Surface *IMG_LoadPNG_RW(SDL_RWops *src ) ;
#line 118
extern SDL_Surface *IMG_LoadPNM_RW(SDL_RWops *src ) ;
#line 119
extern SDL_Surface *IMG_LoadTGA_RW(SDL_RWops *src ) ;
#line 120
extern SDL_Surface *IMG_LoadTIF_RW(SDL_RWops *src ) ;
#line 121
extern SDL_Surface *IMG_LoadXCF_RW(SDL_RWops *src ) ;
#line 122
extern SDL_Surface *IMG_LoadXPM_RW(SDL_RWops *src ) ;
#line 123
extern SDL_Surface *IMG_LoadXV_RW(SDL_RWops *src ) ;
#line 124
extern SDL_Surface *IMG_LoadWEBP_RW(SDL_RWops *src ) ;
#line 126
extern SDL_Surface *IMG_ReadXPMFromArray(char **xpm ) ;
#line 79 "/usr/include/SDL/SDL_rotozoom.h"
extern SDL_Surface *rotozoomSurface(SDL_Surface *src , double angle , double zoom ,
                                    int smooth ) ;
#line 81
extern SDL_Surface *rotozoomSurfaceXY(SDL_Surface *src , double angle , double zoomx ,
                                      double zoomy , int smooth ) ;
#line 85
extern void rotozoomSurfaceSize(int width , int height , double angle , double zoom ,
                                int *dstwidth , int *dstheight ) ;
#line 88
extern void rotozoomSurfaceSizeXY(int width , int height , double angle , double zoomx ,
                                  double zoomy , int *dstwidth , int *dstheight ) ;
#line 98
extern SDL_Surface *zoomSurface(SDL_Surface *src , double zoomx , double zoomy , int smooth ) ;
#line 100
extern void zoomSurfaceSize(int width , int height , double zoomx , double zoomy ,
                            int *dstwidth , int *dstheight ) ;
#line 108
extern SDL_Surface *shrinkSurface(SDL_Surface *src , int factorx , int factory ) ;
#line 116
extern SDL_Surface *rotateSurface90Degrees(SDL_Surface *src , int numClockwiseTurns ) ;
#line 45 "/usr/include/SDL/SDL_gfxBlitFunc.h"
extern unsigned int const   GFX_ALPHA_ADJUST_ARRAY[256] ;
#line 63
extern int SDL_gfxBlitRGBA(SDL_Surface *src , SDL_Rect *srcrect , SDL_Surface *dst ,
                           SDL_Rect *dstrect ) ;
#line 65
extern int SDL_gfxSetAlpha(SDL_Surface *src , Uint8 a ) ;
#line 67
extern int SDL_gfxMultiplyAlpha(SDL_Surface *src , Uint8 a ) ;
#line 53 "/usr/include/SDL_Pango.h"
extern SDLPango_Matrix *MATRIX_WHITE_BACK0 ;
#line 57
extern SDLPango_Matrix *MATRIX_BLACK_BACK0 ;
#line 61
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_BLACK_LETTER0 ;
#line 65
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_WHITE_LETTER0 ;
#line 70
extern SDLPango_Matrix *MATRIX_TRANSPARENT_BACK_TRANSPARENT_LETTER0 ;
#line 70 "/usr/include/glib-2.0/glib/garray.h"
extern GArray *g_array_new(gboolean zero_terminated , gboolean clear_ , guint element_size ) ;
#line 74
extern gpointer g_array_steal(GArray *array , gsize *len ) ;
#line 77
extern GArray *g_array_sized_new(gboolean zero_terminated , gboolean clear_ , guint element_size ,
                                 guint reserved_size ) ;
#line 82
extern GArray *g_array_copy(GArray *array ) ;
#line 84
extern gchar *g_array_free(GArray *array , gboolean free_segment ) ;
#line 87
extern GArray *g_array_ref(GArray *array ) ;
#line 89
extern void g_array_unref(GArray *array ) ;
#line 91
extern guint g_array_get_element_size(GArray *array ) ;
#line 93
extern GArray *g_array_append_vals(GArray *array , gconstpointer data , guint len ) ;
#line 97
extern GArray *g_array_prepend_vals(GArray *array , gconstpointer data , guint len ) ;
#line 101
extern GArray *g_array_insert_vals(GArray *array , guint index_ , gconstpointer data ,
                                   guint len ) ;
#line 106
extern GArray *g_array_set_size(GArray *array , guint length ) ;
#line 109
extern GArray *g_array_remove_index(GArray *array , guint index_ ) ;
#line 112
extern GArray *g_array_remove_index_fast(GArray *array , guint index_ ) ;
#line 115
extern GArray *g_array_remove_range(GArray *array , guint index_ , guint length ) ;
#line 119
extern void g_array_sort(GArray *array , GCompareFunc compare_func ) ;
#line 122
extern void g_array_sort_with_data(GArray *array , GCompareDataFunc compare_func ,
                                   gpointer user_data ) ;
#line 126
extern gboolean g_array_binary_search(GArray *array , gconstpointer target , GCompareFunc compare_func ,
                                      guint *out_match_index ) ;
#line 131
extern void g_array_set_clear_func(GArray *array , GDestroyNotify clear_func ) ;
#line 140
extern GPtrArray *g_ptr_array_new(void) ;
#line 142
extern GPtrArray *g_ptr_array_new_with_free_func(GDestroyNotify element_free_func ) ;
#line 144
extern gpointer *g_ptr_array_steal(GPtrArray *array , gsize *len ) ;
#line 147
extern GPtrArray *g_ptr_array_copy(GPtrArray *array , GCopyFunc func , gpointer user_data ) ;
#line 151
extern GPtrArray *g_ptr_array_sized_new(guint reserved_size ) ;
#line 153
extern GPtrArray *g_ptr_array_new_full(guint reserved_size , GDestroyNotify element_free_func ) ;
#line 156
extern gpointer *g_ptr_array_free(GPtrArray *array , gboolean free_seg ) ;
#line 159
extern GPtrArray *g_ptr_array_ref(GPtrArray *array ) ;
#line 161
extern void g_ptr_array_unref(GPtrArray *array ) ;
#line 163
extern void g_ptr_array_set_free_func(GPtrArray *array , GDestroyNotify element_free_func ) ;
#line 166
extern void g_ptr_array_set_size(GPtrArray *array , gint length ) ;
#line 169
extern gpointer g_ptr_array_remove_index(GPtrArray *array , guint index_ ) ;
#line 172
extern gpointer g_ptr_array_remove_index_fast(GPtrArray *array , guint index_ ) ;
#line 175
extern gpointer g_ptr_array_steal_index(GPtrArray *array , guint index_ ) ;
#line 178
extern gpointer g_ptr_array_steal_index_fast(GPtrArray *array , guint index_ ) ;
#line 181
extern gboolean g_ptr_array_remove(GPtrArray *array , gpointer data ) ;
#line 184
extern gboolean g_ptr_array_remove_fast(GPtrArray *array , gpointer data ) ;
#line 187
extern GPtrArray *g_ptr_array_remove_range(GPtrArray *array , guint index_ , guint length ) ;
#line 191
extern void g_ptr_array_add(GPtrArray *array , gpointer data ) ;
#line 194
extern void g_ptr_array_extend(GPtrArray *array_to_extend , GPtrArray *array , GCopyFunc func ,
                               gpointer user_data ) ;
#line 199
extern void g_ptr_array_extend_and_steal(GPtrArray *array_to_extend , GPtrArray *array ) ;
#line 202
extern void g_ptr_array_insert(GPtrArray *array , gint index_ , gpointer data ) ;
#line 206
extern void g_ptr_array_sort(GPtrArray *array , GCompareFunc compare_func ) ;
#line 209
extern void g_ptr_array_sort_with_data(GPtrArray *array , GCompareDataFunc compare_func ,
                                       gpointer user_data ) ;
#line 213
extern void g_ptr_array_foreach(GPtrArray *array , GFunc func , gpointer user_data ) ;
#line 217
extern gboolean g_ptr_array_find(GPtrArray *haystack , gconstpointer needle , guint *index_ ) ;
#line 221
extern gboolean g_ptr_array_find_with_equal_func(GPtrArray *haystack , gconstpointer needle ,
                                                 GEqualFunc equal_func , guint *index_ ) ;
#line 232
extern GByteArray *g_byte_array_new(void) ;
#line 234
extern GByteArray *g_byte_array_new_take(guint8 *data , gsize len ) ;
#line 237
extern guint8 *g_byte_array_steal(GByteArray *array , gsize *len ) ;
#line 240
extern GByteArray *g_byte_array_sized_new(guint reserved_size ) ;
#line 242
extern guint8 *g_byte_array_free(GByteArray *array , gboolean free_segment ) ;
#line 245
extern GBytes *g_byte_array_free_to_bytes(GByteArray *array ) ;
#line 247
extern GByteArray *g_byte_array_ref(GByteArray *array ) ;
#line 249
extern void g_byte_array_unref(GByteArray *array ) ;
#line 251
extern GByteArray *g_byte_array_append(GByteArray *array , guint8 *data , guint len ) ;
#line 255
extern GByteArray *g_byte_array_prepend(GByteArray *array , guint8 *data , guint len ) ;
#line 259
extern GByteArray *g_byte_array_set_size(GByteArray *array , guint length ) ;
#line 262
extern GByteArray *g_byte_array_remove_index(GByteArray *array , guint index_ ) ;
#line 265
extern GByteArray *g_byte_array_remove_index_fast(GByteArray *array , guint index_ ) ;
#line 268
extern GByteArray *g_byte_array_remove_range(GByteArray *array , guint index_ , guint length ) ;
#line 272
extern void g_byte_array_sort(GByteArray *array , GCompareFunc compare_func ) ;
#line 275
extern void g_byte_array_sort_with_data(GByteArray *array , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 33 "/usr/include/glib-2.0/glib/gatomic.h"
extern gint g_atomic_int_get(gint *atomic ) ;
#line 35
extern void g_atomic_int_set(gint *atomic , gint newval ) ;
#line 38
extern void g_atomic_int_inc(gint *atomic ) ;
#line 40
extern gboolean g_atomic_int_dec_and_test(gint *atomic ) ;
#line 42
extern gboolean g_atomic_int_compare_and_exchange(gint *atomic , gint oldval , gint newval ) ;
#line 46
extern gint g_atomic_int_add(gint *atomic , gint val ) ;
#line 49
extern guint g_atomic_int_and(guint *atomic , guint val ) ;
#line 52
extern guint g_atomic_int_or(guint *atomic , guint val ) ;
#line 55
extern guint g_atomic_int_xor(guint *atomic , guint val ) ;
#line 59
extern gpointer g_atomic_pointer_get(void const   *atomic ) ;
#line 61
extern void g_atomic_pointer_set(void *atomic , gpointer newval ) ;
#line 64
extern gboolean g_atomic_pointer_compare_and_exchange(void *atomic , gpointer oldval ,
                                                      gpointer newval ) ;
#line 68
extern gssize g_atomic_pointer_add(void *atomic , gssize val ) ;
#line 71
extern gsize g_atomic_pointer_and(void *atomic , gsize val ) ;
#line 74
extern gsize g_atomic_pointer_or(void *atomic , gsize val ) ;
#line 77
extern gsize g_atomic_pointer_xor(void *atomic , gsize val ) ;
#line 81
extern gint g_atomic_int_exchange_and_add(gint *atomic , gint val ) ;
#line 41 "/usr/include/glib-2.0/glib/gquark.h"
extern GQuark g_quark_try_string(gchar *string ) ;
#line 43
extern GQuark g_quark_from_static_string(gchar *string ) ;
#line 45
extern GQuark g_quark_from_string(gchar *string ) ;
#line 47
extern gchar *g_quark_to_string(GQuark quark ) ;
#line 62
extern gchar *g_intern_string(gchar *string ) ;
#line 64
extern gchar *g_intern_static_string(gchar *string ) ;
#line 176 "/usr/include/glib-2.0/glib/gerror.h"
extern GQuark g_error_domain_register_static(char const   *error_type_name , gsize error_type_private_size ,
                                             GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                             GErrorClearFunc error_type_clear ) ;
#line 183
extern GQuark g_error_domain_register(char const   *error_type_name , gsize error_type_private_size ,
                                      GErrorInitFunc error_type_init , GErrorCopyFunc error_type_copy ,
                                      GErrorClearFunc error_type_clear ) ;
#line 190
extern GError *g_error_new(GQuark domain , gint code , gchar *format  , ...) ;
#line 196
extern GError *g_error_new_literal(GQuark domain , gint code , gchar *message ) ;
#line 200
extern GError *g_error_new_valist(GQuark domain , gint code , gchar *format , va_list args ) ;
#line 206
extern void g_error_free(GError *error ) ;
#line 208
extern GError *g_error_copy(GError *error ) ;
#line 211
extern gboolean g_error_matches(GError *error , GQuark domain , gint code ) ;
#line 219
extern void g_set_error(GError **err , GQuark domain , gint code , gchar *format 
                        , ...) ;
#line 226
extern void g_set_error_literal(GError **err , GQuark domain , gint code , gchar *message ) ;
#line 234
extern void g_propagate_error(GError **dest , GError *src ) ;
#line 239
extern void g_clear_error(GError **err ) ;
#line 243
extern void g_prefix_error(GError **err , gchar *format  , ...) ;
#line 249
extern void g_prefix_error_literal(GError **err , gchar *prefix ) ;
#line 254
extern void g_propagate_prefixed_error(GError **dest , GError *src , gchar *format 
                                       , ...) ;
#line 51 "/usr/include/glib-2.0/glib/gutils.h"
extern gchar *g_get_user_name(void) ;
#line 53
extern gchar *g_get_real_name(void) ;
#line 55
extern gchar *g_get_home_dir(void) ;
#line 57
extern gchar *g_get_tmp_dir(void) ;
#line 59
extern gchar *g_get_host_name(void) ;
#line 61
extern gchar *g_get_prgname(void) ;
#line 63
extern void g_set_prgname(gchar *prgname ) ;
#line 65
extern gchar *g_get_application_name(void) ;
#line 67
extern void g_set_application_name(gchar *application_name ) ;
#line 69
extern gchar *g_get_os_info(gchar *key_name ) ;
#line 193
extern void g_reload_user_special_dirs_cache(void) ;
#line 195
extern gchar *g_get_user_data_dir(void) ;
#line 197
extern gchar *g_get_user_config_dir(void) ;
#line 199
extern gchar *g_get_user_cache_dir(void) ;
#line 201
extern gchar *g_get_user_state_dir(void) ;
#line 203
extern gchar * const  *g_get_system_data_dirs(void) ;
#line 225
extern gchar * const  *g_get_system_config_dirs(void) ;
#line 228
extern gchar *g_get_user_runtime_dir(void) ;
#line 266
extern gchar *g_get_user_special_dir(GUserDirectory directory ) ;
#line 286
extern guint g_parse_debug_string(gchar *string , GDebugKey *keys , guint nkeys ) ;
#line 291
extern gint g_snprintf(gchar *string , gulong n , gchar *format  , ...) ;
#line 296
extern gint g_vsnprintf(gchar *string , gulong n , gchar *format , va_list args ) ;
#line 303
extern void g_nullify_pointer(gpointer *nullify_location ) ;
#line 314
extern gchar *g_format_size_full(guint64 size , GFormatSizeFlags flags ) ;
#line 317
extern gchar *g_format_size(guint64 size ) ;
#line 320
extern gchar *g_format_size_for_display(goffset size ) ;
#line 338
extern void g_atexit(GVoidFunc func ) ;
#line 357
extern gchar *g_find_program_in_path(gchar *program ) ;
#line 375
extern gint g_bit_nth_lsf(gulong mask , gint nth_bit ) ;
#line 378
extern gint g_bit_nth_msf(gulong mask , gint nth_bit ) ;
#line 381
extern guint g_bit_storage(gulong number ) ;
#line 384 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_lsf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 387
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 387
  if (__cil_tmp3) {
#line 388
    nth_bit = - 1;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (nth_bit < 63)) {
#line 389
      goto while_break;
    }
#line 391
    nth_bit ++;
#line 392
    if (mask & (1UL << nth_bit)) {
#line 393
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return (- 1);
}
}
#line 399 "/usr/include/glib-2.0/glib/gutils.h"
__inline static gint g_bit_nth_msf_impl(gulong mask , gint nth_bit ) 
{ 
  long __cil_tmp3 ;
  gint __cil_tmp4 ;

  {
  {
#line 402
  __cil_tmp3 = __builtin_expect((long )0, (long )0);
  }
#line 402
  if (nth_bit < 0) {
#line 403
    nth_bit = 64;
  } else
#line 402
  if (__cil_tmp3) {
#line 403
    nth_bit = 64;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! (nth_bit > 0)) {
#line 404
      goto while_break;
    }
#line 406
    __cil_tmp4 = nth_bit;
#line 406
    nth_bit --;
#line 407
    if (mask & (1UL << nth_bit)) {
#line 408
      return (nth_bit);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (- 1);
}
}
#line 414 "/usr/include/glib-2.0/glib/gutils.h"
__inline static guint g_bit_storage_impl(gulong number ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  unsigned int tmp ;

  {
  {
#line 417
  __cil_tmp2 = __builtin_expect((long )0, (long )1);
  }
#line 417
  if (__cil_tmp2) {
    {
#line 417
    __cil_tmp3 = __builtin_clzl(number);
#line 417
    tmp = (63U ^ (guint )__cil_tmp3) + 1U;
    }
  } else {
#line 417
    tmp = (unsigned int )1;
  }
#line 417
  return (tmp);
}
}
#line 40 "/usr/include/glib-2.0/glib/gthread.h"
extern GQuark g_thread_error_quark(void) ;
#line 141
extern GThread *g_thread_ref(GThread *thread ) ;
#line 143
extern void g_thread_unref(GThread *thread ) ;
#line 145
extern GThread *g_thread_new(gchar *name , GThreadFunc func , gpointer data ) ;
#line 149
extern GThread *g_thread_try_new(gchar *name , GThreadFunc func , gpointer data ,
                                 GError **error ) ;
#line 154
extern GThread *g_thread_self(void) ;
#line 156
extern void g_thread_exit(gpointer retval ) ;
#line 158
extern gpointer g_thread_join(GThread *thread ) ;
#line 160
extern void g_thread_yield(void) ;
#line 164
extern void g_mutex_init(GMutex *mutex ) ;
#line 166
extern void g_mutex_clear(GMutex *mutex ) ;
#line 168
extern void g_mutex_lock(GMutex *mutex ) ;
#line 170
extern gboolean g_mutex_trylock(GMutex *mutex ) ;
#line 172
extern void g_mutex_unlock(GMutex *mutex ) ;
#line 175
extern void g_rw_lock_init(GRWLock *rw_lock ) ;
#line 177
extern void g_rw_lock_clear(GRWLock *rw_lock ) ;
#line 179
extern void g_rw_lock_writer_lock(GRWLock *rw_lock ) ;
#line 181
extern gboolean g_rw_lock_writer_trylock(GRWLock *rw_lock ) ;
#line 183
extern void g_rw_lock_writer_unlock(GRWLock *rw_lock ) ;
#line 185
extern void g_rw_lock_reader_lock(GRWLock *rw_lock ) ;
#line 187
extern gboolean g_rw_lock_reader_trylock(GRWLock *rw_lock ) ;
#line 189
extern void g_rw_lock_reader_unlock(GRWLock *rw_lock ) ;
#line 192
extern void g_rec_mutex_init(GRecMutex *rec_mutex ) ;
#line 194
extern void g_rec_mutex_clear(GRecMutex *rec_mutex ) ;
#line 196
extern void g_rec_mutex_lock(GRecMutex *rec_mutex ) ;
#line 198
extern gboolean g_rec_mutex_trylock(GRecMutex *rec_mutex ) ;
#line 200
extern void g_rec_mutex_unlock(GRecMutex *rec_mutex ) ;
#line 203
extern void g_cond_init(GCond *cond ) ;
#line 205
extern void g_cond_clear(GCond *cond ) ;
#line 207
extern void g_cond_wait(GCond *cond , GMutex *mutex ) ;
#line 210
extern void g_cond_signal(GCond *cond ) ;
#line 212
extern void g_cond_broadcast(GCond *cond ) ;
#line 214
extern gboolean g_cond_wait_until(GCond *cond , GMutex *mutex , gint64 end_time ) ;
#line 219
extern gpointer g_private_get(GPrivate *key ) ;
#line 221
extern void g_private_set(GPrivate *key , gpointer value ) ;
#line 224
extern void g_private_replace(GPrivate *key , gpointer value ) ;
#line 228
extern gpointer g_once_impl(GOnce *once , GThreadFunc func , gpointer arg ) ;
#line 232
extern gboolean g_once_init_enter(void *location ) ;
#line 234
extern void g_once_init_leave(void *location , gsize result ) ;
#line 277
extern guint g_get_num_processors(void) ;
#line 331 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GMutexLocker *g_mutex_locker_new(GMutex *mutex ) 
{ 


  {
  {
#line 333
  g_mutex_lock(mutex);
  }
#line 334
  return ((GMutexLocker *)mutex);
}
}
#line 349 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_mutex_locker_free(GMutexLocker *locker ) 
{ 


  {
  {
#line 351
  g_mutex_unlock((GMutex *)locker);
  }
  return;
}
}
#line 407 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRecMutexLocker *g_rec_mutex_locker_new(GRecMutex *rec_mutex ) 
{ 


  {
  {
#line 409
  g_rec_mutex_lock(rec_mutex);
  }
#line 410
  return ((GRecMutexLocker *)rec_mutex);
}
}
#line 427 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rec_mutex_locker_free(GRecMutexLocker *locker ) 
{ 


  {
  {
#line 429
  g_rec_mutex_unlock((GRecMutex *)locker);
  }
  return;
}
}
#line 517 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockWriterLocker *g_rw_lock_writer_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 519
  g_rw_lock_writer_lock(rw_lock);
  }
#line 520
  return ((GRWLockWriterLocker *)rw_lock);
}
}
#line 538 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_writer_locker_free(GRWLockWriterLocker *locker ) 
{ 


  {
  {
#line 540
  g_rw_lock_writer_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 572 "/usr/include/glib-2.0/glib/gthread.h"
__inline static GRWLockReaderLocker *g_rw_lock_reader_locker_new(GRWLock *rw_lock ) 
{ 


  {
  {
#line 574
  g_rw_lock_reader_lock(rw_lock);
  }
#line 575
  return ((GRWLockReaderLocker *)rw_lock);
}
}
#line 593 "/usr/include/glib-2.0/glib/gthread.h"
__inline static void g_rw_lock_reader_locker_free(GRWLockReaderLocker *locker ) 
{ 


  {
  {
#line 595
  g_rw_lock_reader_unlock((GRWLock *)locker);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/glib/gasyncqueue.h"
extern GAsyncQueue *g_async_queue_new(void) ;
#line 41
extern GAsyncQueue *g_async_queue_new_full(GDestroyNotify item_free_func ) ;
#line 43
extern void g_async_queue_lock(GAsyncQueue *queue ) ;
#line 45
extern void g_async_queue_unlock(GAsyncQueue *queue ) ;
#line 47
extern GAsyncQueue *g_async_queue_ref(GAsyncQueue *queue ) ;
#line 49
extern void g_async_queue_unref(GAsyncQueue *queue ) ;
#line 52
extern void g_async_queue_ref_unlocked(GAsyncQueue *queue ) ;
#line 55
extern void g_async_queue_unref_and_unlock(GAsyncQueue *queue ) ;
#line 58
extern void g_async_queue_push(GAsyncQueue *queue , gpointer data ) ;
#line 61
extern void g_async_queue_push_unlocked(GAsyncQueue *queue , gpointer data ) ;
#line 64
extern void g_async_queue_push_sorted(GAsyncQueue *queue , gpointer data , GCompareDataFunc func ,
                                      gpointer user_data ) ;
#line 69
extern void g_async_queue_push_sorted_unlocked(GAsyncQueue *queue , gpointer data ,
                                               GCompareDataFunc func , gpointer user_data ) ;
#line 74
extern gpointer g_async_queue_pop(GAsyncQueue *queue ) ;
#line 76
extern gpointer g_async_queue_pop_unlocked(GAsyncQueue *queue ) ;
#line 78
extern gpointer g_async_queue_try_pop(GAsyncQueue *queue ) ;
#line 80
extern gpointer g_async_queue_try_pop_unlocked(GAsyncQueue *queue ) ;
#line 82
extern gpointer g_async_queue_timeout_pop(GAsyncQueue *queue , guint64 timeout ) ;
#line 85
extern gpointer g_async_queue_timeout_pop_unlocked(GAsyncQueue *queue , guint64 timeout ) ;
#line 88
extern gint g_async_queue_length(GAsyncQueue *queue ) ;
#line 90
extern gint g_async_queue_length_unlocked(GAsyncQueue *queue ) ;
#line 92
extern void g_async_queue_sort(GAsyncQueue *queue , GCompareDataFunc func , gpointer user_data ) ;
#line 96
extern void g_async_queue_sort_unlocked(GAsyncQueue *queue , GCompareDataFunc func ,
                                        gpointer user_data ) ;
#line 101
extern gboolean g_async_queue_remove(GAsyncQueue *queue , gpointer item ) ;
#line 104
extern gboolean g_async_queue_remove_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 107
extern void g_async_queue_push_front(GAsyncQueue *queue , gpointer item ) ;
#line 110
extern void g_async_queue_push_front_unlocked(GAsyncQueue *queue , gpointer item ) ;
#line 115
extern gpointer g_async_queue_timed_pop(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 118
extern gpointer g_async_queue_timed_pop_unlocked(GAsyncQueue *queue , GTimeVal *end_time ) ;
#line 41 "/usr/include/glib-2.0/glib/gbacktrace.h"
extern void g_on_error_query(gchar *prg_name ) ;
#line 43
extern void g_on_error_stack_trace(gchar *prg_name ) ;
#line 31 "/usr/include/glib-2.0/glib/gbase64.h"
extern gsize g_base64_encode_step(guchar *in , gsize len , gboolean break_lines ,
                                  gchar *out , gint *state , gint *save ) ;
#line 38
extern gsize g_base64_encode_close(gboolean break_lines , gchar *out , gint *state ,
                                   gint *save ) ;
#line 43
extern gchar *g_base64_encode(guchar *data , gsize len ) ;
#line 46
extern gsize g_base64_decode_step(gchar *in , gsize len , guchar *out , gint *state ,
                                  guint *save ) ;
#line 52
extern guchar *g_base64_decode(gchar *text , gsize *out_len ) ;
#line 55
extern guchar *g_base64_decode_inplace(gchar *text , gsize *out_len ) ;
#line 33 "/usr/include/glib-2.0/glib/gbitlock.h"
extern void g_bit_lock(gint *address , gint lock_bit ) ;
#line 36
extern gboolean g_bit_trylock(gint *address , gint lock_bit ) ;
#line 39
extern void g_bit_unlock(gint *address , gint lock_bit ) ;
#line 43
extern void g_pointer_bit_lock(void *address , gint lock_bit ) ;
#line 46
extern gboolean g_pointer_bit_trylock(void *address , gint lock_bit ) ;
#line 49
extern void g_pointer_bit_unlock(void *address , gint lock_bit ) ;
#line 57 "/usr/include/glib-2.0/glib/gtimezone.h"
extern GTimeZone *g_time_zone_new(gchar *identifier ) ;
#line 59
extern GTimeZone *g_time_zone_new_identifier(gchar *identifier ) ;
#line 61
extern GTimeZone *g_time_zone_new_utc(void) ;
#line 63
extern GTimeZone *g_time_zone_new_local(void) ;
#line 65
extern GTimeZone *g_time_zone_new_offset(gint32 seconds ) ;
#line 68
extern GTimeZone *g_time_zone_ref(GTimeZone *tz ) ;
#line 70
extern void g_time_zone_unref(GTimeZone *tz ) ;
#line 73
extern gint g_time_zone_find_interval(GTimeZone *tz , GTimeType type , gint64 time_ ) ;
#line 78
extern gint g_time_zone_adjust_time(GTimeZone *tz , GTimeType type , gint64 *time_ ) ;
#line 83
extern gchar *g_time_zone_get_abbreviation(GTimeZone *tz , gint interval ) ;
#line 86
extern gint32 g_time_zone_get_offset(GTimeZone *tz , gint interval ) ;
#line 89
extern gboolean g_time_zone_is_dst(GTimeZone *tz , gint interval ) ;
#line 92
extern gchar *g_time_zone_get_identifier(GTimeZone *tz ) ;
#line 99 "/usr/include/glib-2.0/glib/gdatetime.h"
extern void g_date_time_unref(GDateTime *datetime ) ;
#line 101
extern GDateTime *g_date_time_ref(GDateTime *datetime ) ;
#line 104
extern GDateTime *g_date_time_new_now(GTimeZone *tz ) ;
#line 106
extern GDateTime *g_date_time_new_now_local(void) ;
#line 108
extern GDateTime *g_date_time_new_now_utc(void) ;
#line 111
extern GDateTime *g_date_time_new_from_unix_local(gint64 t ) ;
#line 113
extern GDateTime *g_date_time_new_from_unix_utc(gint64 t ) ;
#line 117
extern GDateTime *g_date_time_new_from_timeval_local(GTimeVal *tv ) ;
#line 119
extern GDateTime *g_date_time_new_from_timeval_utc(GTimeVal *tv ) ;
#line 123
extern GDateTime *g_date_time_new_from_iso8601(gchar *text , GTimeZone *default_tz ) ;
#line 127
extern GDateTime *g_date_time_new(GTimeZone *tz , gint year , gint month , gint day ,
                                  gint hour , gint minute , gdouble seconds ) ;
#line 135
extern GDateTime *g_date_time_new_local(gint year , gint month , gint day , gint hour ,
                                        gint minute , gdouble seconds ) ;
#line 142
extern GDateTime *g_date_time_new_utc(gint year , gint month , gint day , gint hour ,
                                      gint minute , gdouble seconds ) ;
#line 151
extern GDateTime *g_date_time_add(GDateTime *datetime , GTimeSpan timespan ) ;
#line 156
extern GDateTime *g_date_time_add_years(GDateTime *datetime , gint years ) ;
#line 160
extern GDateTime *g_date_time_add_months(GDateTime *datetime , gint months ) ;
#line 164
extern GDateTime *g_date_time_add_weeks(GDateTime *datetime , gint weeks ) ;
#line 168
extern GDateTime *g_date_time_add_days(GDateTime *datetime , gint days ) ;
#line 173
extern GDateTime *g_date_time_add_hours(GDateTime *datetime , gint hours ) ;
#line 177
extern GDateTime *g_date_time_add_minutes(GDateTime *datetime , gint minutes ) ;
#line 181
extern GDateTime *g_date_time_add_seconds(GDateTime *datetime , gdouble seconds ) ;
#line 186
extern GDateTime *g_date_time_add_full(GDateTime *datetime , gint years , gint months ,
                                       gint days , gint hours , gint minutes , gdouble seconds ) ;
#line 195
extern gint g_date_time_compare(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 198
extern GTimeSpan g_date_time_difference(GDateTime *end , GDateTime *begin ) ;
#line 201
extern guint g_date_time_hash(gconstpointer datetime ) ;
#line 203
extern gboolean g_date_time_equal(gconstpointer dt1 , gconstpointer dt2 ) ;
#line 207
extern void g_date_time_get_ymd(GDateTime *datetime , gint *year , gint *month , gint *day ) ;
#line 213
extern gint g_date_time_get_year(GDateTime *datetime ) ;
#line 215
extern gint g_date_time_get_month(GDateTime *datetime ) ;
#line 217
extern gint g_date_time_get_day_of_month(GDateTime *datetime ) ;
#line 220
extern gint g_date_time_get_week_numbering_year(GDateTime *datetime ) ;
#line 222
extern gint g_date_time_get_week_of_year(GDateTime *datetime ) ;
#line 224
extern gint g_date_time_get_day_of_week(GDateTime *datetime ) ;
#line 227
extern gint g_date_time_get_day_of_year(GDateTime *datetime ) ;
#line 230
extern gint g_date_time_get_hour(GDateTime *datetime ) ;
#line 232
extern gint g_date_time_get_minute(GDateTime *datetime ) ;
#line 234
extern gint g_date_time_get_second(GDateTime *datetime ) ;
#line 236
extern gint g_date_time_get_microsecond(GDateTime *datetime ) ;
#line 238
extern gdouble g_date_time_get_seconds(GDateTime *datetime ) ;
#line 241
extern gint64 g_date_time_to_unix(GDateTime *datetime ) ;
#line 244
extern gboolean g_date_time_to_timeval(GDateTime *datetime , GTimeVal *tv ) ;
#line 249
extern GTimeSpan g_date_time_get_utc_offset(GDateTime *datetime ) ;
#line 251
extern GTimeZone *g_date_time_get_timezone(GDateTime *datetime ) ;
#line 253
extern gchar *g_date_time_get_timezone_abbreviation(GDateTime *datetime ) ;
#line 255
extern gboolean g_date_time_is_daylight_savings(GDateTime *datetime ) ;
#line 258
extern GDateTime *g_date_time_to_timezone(GDateTime *datetime , GTimeZone *tz ) ;
#line 261
extern GDateTime *g_date_time_to_local(GDateTime *datetime ) ;
#line 263
extern GDateTime *g_date_time_to_utc(GDateTime *datetime ) ;
#line 266
extern gchar *g_date_time_format(GDateTime *datetime , gchar *format ) ;
#line 269
extern gchar *g_date_time_format_iso8601(GDateTime *datetime ) ;
#line 71 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
extern GQuark g_bookmark_file_error_quark(void) ;
#line 81
extern GBookmarkFile *g_bookmark_file_new(void) ;
#line 83
extern void g_bookmark_file_free(GBookmarkFile *bookmark ) ;
#line 86
extern gboolean g_bookmark_file_load_from_file(GBookmarkFile *bookmark , gchar *filename ,
                                               GError **error ) ;
#line 90
extern gboolean g_bookmark_file_load_from_data(GBookmarkFile *bookmark , gchar *data ,
                                               gsize length , GError **error ) ;
#line 95
extern gboolean g_bookmark_file_load_from_data_dirs(GBookmarkFile *bookmark , gchar *file ,
                                                    gchar **full_path , GError **error ) ;
#line 100
extern gchar *g_bookmark_file_to_data(GBookmarkFile *bookmark , gsize *length , GError **error ) ;
#line 104
extern gboolean g_bookmark_file_to_file(GBookmarkFile *bookmark , gchar *filename ,
                                        GError **error ) ;
#line 109
extern void g_bookmark_file_set_title(GBookmarkFile *bookmark , gchar *uri , gchar *title ) ;
#line 113
extern gchar *g_bookmark_file_get_title(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 117
extern void g_bookmark_file_set_description(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *description ) ;
#line 121
extern gchar *g_bookmark_file_get_description(GBookmarkFile *bookmark , gchar *uri ,
                                              GError **error ) ;
#line 125
extern void g_bookmark_file_set_mime_type(GBookmarkFile *bookmark , gchar *uri , gchar *mime_type ) ;
#line 129
extern gchar *g_bookmark_file_get_mime_type(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 133
extern void g_bookmark_file_set_groups(GBookmarkFile *bookmark , gchar *uri , gchar **groups ,
                                       gsize length ) ;
#line 138
extern void g_bookmark_file_add_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ) ;
#line 142
extern gboolean g_bookmark_file_has_group(GBookmarkFile *bookmark , gchar *uri , gchar *group ,
                                          GError **error ) ;
#line 147
extern gchar **g_bookmark_file_get_groups(GBookmarkFile *bookmark , gchar *uri , gsize *length ,
                                          GError **error ) ;
#line 152
extern void g_bookmark_file_add_application(GBookmarkFile *bookmark , gchar *uri ,
                                            gchar *name , gchar *exec ) ;
#line 157
extern gboolean g_bookmark_file_has_application(GBookmarkFile *bookmark , gchar *uri ,
                                                gchar *name , GError **error ) ;
#line 162
extern gchar **g_bookmark_file_get_applications(GBookmarkFile *bookmark , gchar *uri ,
                                                gsize *length , GError **error ) ;
#line 167
extern gboolean g_bookmark_file_set_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar *exec , gint count ,
                                             time_t stamp , GError **error ) ;
#line 175
extern gboolean g_bookmark_file_set_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char const   *exec ,
                                                     int count , GDateTime *stamp ,
                                                     GError **error ) ;
#line 183
extern gboolean g_bookmark_file_get_app_info(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *name , gchar **exec , guint *count ,
                                             time_t *stamp , GError **error ) ;
#line 191
extern gboolean g_bookmark_file_get_application_info(GBookmarkFile *bookmark , char const   *uri ,
                                                     char const   *name , char **exec ,
                                                     unsigned int *count , GDateTime **stamp ,
                                                     GError **error ) ;
#line 199
extern void g_bookmark_file_set_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                           gboolean is_private ) ;
#line 203
extern gboolean g_bookmark_file_get_is_private(GBookmarkFile *bookmark , gchar *uri ,
                                               GError **error ) ;
#line 207
extern void g_bookmark_file_set_icon(GBookmarkFile *bookmark , gchar *uri , gchar *href ,
                                     gchar *mime_type ) ;
#line 212
extern gboolean g_bookmark_file_get_icon(GBookmarkFile *bookmark , gchar *uri , gchar **href ,
                                         gchar **mime_type , GError **error ) ;
#line 218
extern void g_bookmark_file_set_added(GBookmarkFile *bookmark , gchar *uri , time_t added ) ;
#line 222
extern void g_bookmark_file_set_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                GDateTime *added ) ;
#line 226
extern time_t g_bookmark_file_get_added(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 230
extern GDateTime *g_bookmark_file_get_added_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                      GError **error ) ;
#line 234
extern void g_bookmark_file_set_modified(GBookmarkFile *bookmark , gchar *uri , time_t modified ) ;
#line 238
extern void g_bookmark_file_set_modified_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                   GDateTime *modified ) ;
#line 242
extern time_t g_bookmark_file_get_modified(GBookmarkFile *bookmark , gchar *uri ,
                                           GError **error ) ;
#line 246
extern GDateTime *g_bookmark_file_get_modified_date_time(GBookmarkFile *bookmark ,
                                                         char const   *uri , GError **error ) ;
#line 250
extern void g_bookmark_file_set_visited(GBookmarkFile *bookmark , gchar *uri , time_t visited ) ;
#line 254
extern void g_bookmark_file_set_visited_date_time(GBookmarkFile *bookmark , char const   *uri ,
                                                  GDateTime *visited ) ;
#line 258
extern time_t g_bookmark_file_get_visited(GBookmarkFile *bookmark , gchar *uri , GError **error ) ;
#line 262
extern GDateTime *g_bookmark_file_get_visited_date_time(GBookmarkFile *bookmark ,
                                                        char const   *uri , GError **error ) ;
#line 266
extern gboolean g_bookmark_file_has_item(GBookmarkFile *bookmark , gchar *uri ) ;
#line 269
extern gint g_bookmark_file_get_size(GBookmarkFile *bookmark ) ;
#line 271
extern gchar **g_bookmark_file_get_uris(GBookmarkFile *bookmark , gsize *length ) ;
#line 274
extern gboolean g_bookmark_file_remove_group(GBookmarkFile *bookmark , gchar *uri ,
                                             gchar *group , GError **error ) ;
#line 279
extern gboolean g_bookmark_file_remove_application(GBookmarkFile *bookmark , gchar *uri ,
                                                   gchar *name , GError **error ) ;
#line 284
extern gboolean g_bookmark_file_remove_item(GBookmarkFile *bookmark , gchar *uri ,
                                            GError **error ) ;
#line 288
extern gboolean g_bookmark_file_move_item(GBookmarkFile *bookmark , gchar *old_uri ,
                                          gchar *new_uri , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gbytes.h"
extern GBytes *g_bytes_new(gconstpointer data , gsize size ) ;
#line 39
extern GBytes *g_bytes_new_take(gpointer data , gsize size ) ;
#line 43
extern GBytes *g_bytes_new_static(gconstpointer data , gsize size ) ;
#line 47
extern GBytes *g_bytes_new_with_free_func(gconstpointer data , gsize size , GDestroyNotify free_func ,
                                          gpointer user_data ) ;
#line 53
extern GBytes *g_bytes_new_from_bytes(GBytes *bytes , gsize offset , gsize length ) ;
#line 58
extern gconstpointer g_bytes_get_data(GBytes *bytes , gsize *size ) ;
#line 62
extern gsize g_bytes_get_size(GBytes *bytes ) ;
#line 65
extern GBytes *g_bytes_ref(GBytes *bytes ) ;
#line 68
extern void g_bytes_unref(GBytes *bytes ) ;
#line 71
extern gpointer g_bytes_unref_to_data(GBytes *bytes , gsize *size ) ;
#line 75
extern GByteArray *g_bytes_unref_to_array(GBytes *bytes ) ;
#line 78
extern guint g_bytes_hash(gconstpointer bytes ) ;
#line 81
extern gboolean g_bytes_equal(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 85
extern gint g_bytes_compare(gconstpointer bytes1 , gconstpointer bytes2 ) ;
#line 89
extern gconstpointer g_bytes_get_region(GBytes *bytes , gsize element_size , gsize offset ,
                                        gsize n_elements ) ;
#line 31 "/usr/include/glib-2.0/glib/gcharset.h"
extern gboolean g_get_charset(char const   **charset ) ;
#line 33
extern gchar *g_get_codeset(void) ;
#line 35
extern gboolean g_get_console_charset(char const   **charset ) ;
#line 38
extern gchar * const  *g_get_language_names(void) ;
#line 40
extern gchar * const  *g_get_language_names_with_category(gchar *category_name ) ;
#line 43
extern gchar **g_get_locale_variants(gchar *locale ) ;
#line 68 "/usr/include/glib-2.0/glib/gchecksum.h"
extern gssize g_checksum_type_get_length(GChecksumType checksum_type ) ;
#line 71
extern GChecksum *g_checksum_new(GChecksumType checksum_type ) ;
#line 73
extern void g_checksum_reset(GChecksum *checksum ) ;
#line 75
extern GChecksum *g_checksum_copy(GChecksum *checksum ) ;
#line 77
extern void g_checksum_free(GChecksum *checksum ) ;
#line 79
extern void g_checksum_update(GChecksum *checksum , guchar *data , gssize length ) ;
#line 83
extern gchar *g_checksum_get_string(GChecksum *checksum ) ;
#line 85
extern void g_checksum_get_digest(GChecksum *checksum , guint8 *buffer , gsize *digest_len ) ;
#line 90
extern gchar *g_compute_checksum_for_data(GChecksumType checksum_type , guchar *data ,
                                          gsize length ) ;
#line 94
extern gchar *g_compute_checksum_for_string(GChecksumType checksum_type , gchar *str ,
                                            gssize length ) ;
#line 99
extern gchar *g_compute_checksum_for_bytes(GChecksumType checksum_type , GBytes *data ) ;
#line 75 "/usr/include/glib-2.0/glib/gconvert.h"
extern GQuark g_convert_error_quark(void) ;
#line 86
extern GIConv g_iconv_open(gchar *to_codeset , gchar *from_codeset ) ;
#line 89
extern gsize g_iconv(GIConv converter , gchar **inbuf , gsize *inbytes_left , gchar **outbuf ,
                     gsize *outbytes_left ) ;
#line 95
extern gint g_iconv_close(GIConv converter ) ;
#line 99
extern gchar *g_convert(gchar *str , gssize len , gchar *to_codeset , gchar *from_codeset ,
                        gsize *bytes_read , gsize *bytes_written , GError **error ) ;
#line 107
extern gchar *g_convert_with_iconv(gchar *str , gssize len , GIConv converter , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 114
extern gchar *g_convert_with_fallback(gchar *str , gssize len , gchar *to_codeset ,
                                      gchar *from_codeset , gchar *fallback , gsize *bytes_read ,
                                      gsize *bytes_written , GError **error ) ;
#line 127
extern gchar *g_locale_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                               gsize *bytes_written , GError **error ) ;
#line 133
extern gchar *g_locale_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 143
extern gchar *g_filename_to_utf8(gchar *opsysstring , gssize len , gsize *bytes_read ,
                                 gsize *bytes_written , GError **error ) ;
#line 149
extern gchar *g_filename_from_utf8(gchar *utf8string , gssize len , gsize *bytes_read ,
                                   gsize *bytes_written , GError **error ) ;
#line 156
extern gchar *g_filename_from_uri(gchar *uri , gchar **hostname , GError **error ) ;
#line 161
extern gchar *g_filename_to_uri(gchar *filename , gchar *hostname , GError **error ) ;
#line 165
extern gchar *g_filename_display_name(gchar *filename ) ;
#line 167
extern gboolean g_get_filename_charsets(gchar ***filename_charsets ) ;
#line 170
extern gchar *g_filename_display_basename(gchar *filename ) ;
#line 173
extern gchar **g_uri_list_extract_uris(gchar *uri_list ) ;
#line 45 "/usr/include/glib-2.0/glib/gdataset.h"
extern void g_datalist_init(GData **datalist ) ;
#line 47
extern void g_datalist_clear(GData **datalist ) ;
#line 49
extern gpointer g_datalist_id_get_data(GData **datalist , GQuark key_id ) ;
#line 52
extern void g_datalist_id_set_data_full(GData **datalist , GQuark key_id , gpointer data ,
                                        GDestroyNotify destroy_func ) ;
#line 60
extern gpointer g_datalist_id_dup_data(GData **datalist , GQuark key_id , GDuplicateFunc dup_func ,
                                       gpointer user_data ) ;
#line 65
extern gboolean g_datalist_id_replace_data(GData **datalist , GQuark key_id , gpointer oldval ,
                                           gpointer newval , GDestroyNotify destroy ,
                                           GDestroyNotify *old_destroy ) ;
#line 73
extern gpointer g_datalist_id_remove_no_notify(GData **datalist , GQuark key_id ) ;
#line 76
extern void g_datalist_foreach(GData **datalist , GDataForeachFunc func , gpointer user_data ) ;
#line 90
extern void g_datalist_set_flags(GData **datalist , guint flags ) ;
#line 93
extern void g_datalist_unset_flags(GData **datalist , guint flags ) ;
#line 96
extern guint g_datalist_get_flags(GData **datalist ) ;
#line 114
extern void g_dataset_destroy(gconstpointer dataset_location ) ;
#line 116
extern gpointer g_dataset_id_get_data(gconstpointer dataset_location , GQuark key_id ) ;
#line 119
extern gpointer g_datalist_get_data(GData **datalist , gchar *key ) ;
#line 122
extern void g_dataset_id_set_data_full(gconstpointer dataset_location , GQuark key_id ,
                                       gpointer data , GDestroyNotify destroy_func ) ;
#line 127
extern gpointer g_dataset_id_remove_no_notify(gconstpointer dataset_location , GQuark key_id ) ;
#line 130
extern void g_dataset_foreach(gconstpointer dataset_location , GDataForeachFunc func ,
                              gpointer user_data ) ;
#line 121 "/usr/include/glib-2.0/glib/gdate.h"
extern GDate *g_date_new(void) ;
#line 123
extern GDate *g_date_new_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 127
extern GDate *g_date_new_julian(guint32 julian_day ) ;
#line 129
extern void g_date_free(GDate *date ) ;
#line 131
extern GDate *g_date_copy(GDate *date ) ;
#line 139
extern gboolean g_date_valid(GDate *date ) ;
#line 141
extern gboolean g_date_valid_day(GDateDay day ) ;
#line 143
extern gboolean g_date_valid_month(GDateMonth month ) ;
#line 145
extern gboolean g_date_valid_year(GDateYear year ) ;
#line 147
extern gboolean g_date_valid_weekday(GDateWeekday weekday ) ;
#line 149
extern gboolean g_date_valid_julian(guint32 julian_date ) ;
#line 151
extern gboolean g_date_valid_dmy(GDateDay day , GDateMonth month , GDateYear year ) ;
#line 156
extern GDateWeekday g_date_get_weekday(GDate *date ) ;
#line 158
extern GDateMonth g_date_get_month(GDate *date ) ;
#line 160
extern GDateYear g_date_get_year(GDate *date ) ;
#line 162
extern GDateDay g_date_get_day(GDate *date ) ;
#line 164
extern guint32 g_date_get_julian(GDate *date ) ;
#line 166
extern guint g_date_get_day_of_year(GDate *date ) ;
#line 174
extern guint g_date_get_monday_week_of_year(GDate *date ) ;
#line 176
extern guint g_date_get_sunday_week_of_year(GDate *date ) ;
#line 178
extern guint g_date_get_iso8601_week_of_year(GDate *date ) ;
#line 185
extern void g_date_clear(GDate *date , guint n_dates ) ;
#line 193
extern void g_date_set_parse(GDate *date , gchar *str ) ;
#line 196
extern void g_date_set_time_t(GDate *date , time_t timet ) ;
#line 200
extern void g_date_set_time_val(GDate *date , GTimeVal *timeval ) ;
#line 203
extern void g_date_set_time(GDate *date , GTime time_ ) ;
#line 207
extern void g_date_set_month(GDate *date , GDateMonth month ) ;
#line 210
extern void g_date_set_day(GDate *date , GDateDay day ) ;
#line 213
extern void g_date_set_year(GDate *date , GDateYear year ) ;
#line 216
extern void g_date_set_dmy(GDate *date , GDateDay day , GDateMonth month , GDateYear y ) ;
#line 221
extern void g_date_set_julian(GDate *date , guint32 julian_date ) ;
#line 224
extern gboolean g_date_is_first_of_month(GDate *date ) ;
#line 226
extern gboolean g_date_is_last_of_month(GDate *date ) ;
#line 230
extern void g_date_add_days(GDate *date , guint n_days ) ;
#line 233
extern void g_date_subtract_days(GDate *date , guint n_days ) ;
#line 238
extern void g_date_add_months(GDate *date , guint n_months ) ;
#line 241
extern void g_date_subtract_months(GDate *date , guint n_months ) ;
#line 246
extern void g_date_add_years(GDate *date , guint n_years ) ;
#line 249
extern void g_date_subtract_years(GDate *date , guint n_years ) ;
#line 252
extern gboolean g_date_is_leap_year(GDateYear year ) ;
#line 254
extern guint8 g_date_get_days_in_month(GDateMonth month , GDateYear year ) ;
#line 257
extern guint8 g_date_get_monday_weeks_in_year(GDateYear year ) ;
#line 259
extern guint8 g_date_get_sunday_weeks_in_year(GDateYear year ) ;
#line 264
extern gint g_date_days_between(GDate *date1 , GDate *date2 ) ;
#line 269
extern gint g_date_compare(GDate *lhs , GDate *rhs ) ;
#line 272
extern void g_date_to_struct_tm(GDate *date , struct tm *tm ) ;
#line 276
extern void g_date_clamp(GDate *date , GDate *min_date , GDate *max_date ) ;
#line 282
extern void g_date_order(GDate *date1 , GDate *date2 ) ;
#line 288
extern gsize g_date_strftime(gchar *s , gsize slen , gchar *format , GDate *date ) ;
#line 40 "/usr/include/glib-2.0/glib/gdir.h"
extern GDir *g_dir_open(gchar *path , guint flags , GError **error ) ;
#line 44
extern gchar *g_dir_read_name(GDir *dir ) ;
#line 46
extern void g_dir_rewind(GDir *dir ) ;
#line 48
extern void g_dir_close(GDir *dir ) ;
#line 37 "/usr/include/glib-2.0/glib/genviron.h"
extern gchar *g_getenv(gchar *variable ) ;
#line 39
extern gboolean g_setenv(gchar *variable , gchar *value , gboolean overwrite ) ;
#line 43
extern void g_unsetenv(gchar *variable ) ;
#line 45
extern gchar **g_listenv(void) ;
#line 48
extern gchar **g_get_environ(void) ;
#line 50
extern gchar *g_environ_getenv(gchar **envp , gchar *variable ) ;
#line 53
extern gchar **g_environ_setenv(gchar **envp , gchar *variable , gchar *value , gboolean overwrite ) ;
#line 58
extern gchar **g_environ_unsetenv(gchar **envp , gchar *variable ) ;
#line 109 "/usr/include/glib-2.0/glib/gfileutils.h"
extern GQuark g_file_error_quark(void) ;
#line 112
extern GFileError g_file_error_from_errno(gint err_no ) ;
#line 115
extern gboolean g_file_test(gchar *filename , GFileTest test ) ;
#line 118
extern gboolean g_file_get_contents(gchar *filename , gchar **contents , gsize *length ,
                                    GError **error ) ;
#line 123
extern gboolean g_file_set_contents(gchar *filename , gchar *contents , gssize length ,
                                    GError **error ) ;
#line 129
extern gboolean g_file_set_contents_full(gchar *filename , gchar *contents , gssize length ,
                                         GFileSetContentsFlags flags , int mode ,
                                         GError **error ) ;
#line 137
extern gchar *g_file_read_link(gchar *filename , GError **error ) ;
#line 142
extern gchar *g_mkdtemp(gchar *tmpl ) ;
#line 144
extern gchar *g_mkdtemp_full(gchar *tmpl , gint mode ) ;
#line 149
extern gint g_mkstemp(gchar *tmpl ) ;
#line 151
extern gint g_mkstemp_full(gchar *tmpl , gint flags , gint mode ) ;
#line 157
extern gint g_file_open_tmp(gchar *tmpl , gchar **name_used , GError **error ) ;
#line 161
extern gchar *g_dir_make_tmp(gchar *tmpl , GError **error ) ;
#line 165
extern gchar *g_build_path(gchar *separator , gchar *first_element  , ...) ;
#line 169
extern gchar *g_build_pathv(gchar *separator , gchar **args ) ;
#line 173
extern gchar *g_build_filename(gchar *first_element  , ...) ;
#line 176
extern gchar *g_build_filenamev(gchar **args ) ;
#line 178
extern gchar *g_build_filename_valist(gchar *first_element , va_list *args ) ;
#line 182
extern gint g_mkdir_with_parents(gchar *pathname , gint mode ) ;
#line 200
extern gboolean g_path_is_absolute(gchar *file_name ) ;
#line 202
extern gchar *g_path_skip_root(gchar *file_name ) ;
#line 205
extern gchar *g_basename(gchar *file_name ) ;
#line 209
extern gchar *g_get_current_dir(void) ;
#line 211
extern gchar *g_path_get_basename(gchar *file_name ) ;
#line 213
extern gchar *g_path_get_dirname(gchar *file_name ) ;
#line 216
extern gchar *g_canonicalize_filename(gchar *filename , gchar *relative_to ) ;
#line 37 "/usr/include/glib-2.0/glib/ggettext.h"
extern gchar *g_strip_context(gchar *msgid , gchar *msgval ) ;
#line 41
extern gchar *g_dgettext(gchar *domain , gchar *msgid ) ;
#line 44
extern gchar *g_dcgettext(gchar *domain , gchar *msgid , gint category ) ;
#line 48
extern gchar *g_dngettext(gchar *domain , gchar *msgid , gchar *msgid_plural , gulong n ) ;
#line 53
extern gchar *g_dpgettext(gchar *domain , gchar *msgctxtid , gsize msgidoffset ) ;
#line 57
extern gchar *g_dpgettext2(gchar *domain , gchar *context , gchar *msgid ) ;
#line 72 "/usr/include/glib-2.0/glib/gmem.h"
extern void g_free(gpointer mem ) ;
#line 75
extern void g_clear_pointer(gpointer *pp , GDestroyNotify destroy ) ;
#line 79
extern gpointer g_malloc(gsize n_bytes ) ;
#line 81
extern gpointer g_malloc0(gsize n_bytes ) ;
#line 83
extern gpointer g_realloc(gpointer mem , gsize n_bytes ) ;
#line 86
extern gpointer g_try_malloc(gsize n_bytes ) ;
#line 88
extern gpointer g_try_malloc0(gsize n_bytes ) ;
#line 90
extern gpointer g_try_realloc(gpointer mem , gsize n_bytes ) ;
#line 94
extern gpointer g_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 97
extern gpointer g_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 100
extern gpointer g_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 104
extern gpointer g_try_malloc_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 107
extern gpointer g_try_malloc0_n(gsize n_blocks , gsize n_block_bytes ) ;
#line 110
extern gpointer g_try_realloc_n(gpointer mem , gsize n_blocks , gsize n_block_bytes ) ;
#line 115
extern gpointer g_aligned_alloc(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 119
extern gpointer g_aligned_alloc0(gsize n_blocks , gsize n_block_bytes , gsize alignment ) ;
#line 123
extern void g_aligned_free(gpointer mem ) ;
#line 216 "/usr/include/glib-2.0/glib/gmem.h"
__inline static gpointer g_steal_pointer(gpointer pp ) 
{ 
  gpointer *ptr ;
  gpointer ref ;

  {
#line 218
  ptr = (gpointer *)pp;
#line 221
  ref = *ptr;
#line 222
  *ptr = (void *)0;
#line 224
  return (ref);
}
}
#line 393
extern void g_mem_set_vtable(GMemVTable *vtable ) ;
#line 395
extern gboolean g_mem_is_system_malloc(void) ;
#line 397
extern gboolean g_mem_gc_friendly ;
#line 401
extern GMemVTable *glib_mem_profiler_table ;
#line 403
extern void g_mem_profile(void) ;
#line 99 "/usr/include/glib-2.0/glib/gnode.h"
extern GNode *g_node_new(gpointer data ) ;
#line 101
extern void g_node_destroy(GNode *root ) ;
#line 103
extern void g_node_unlink(GNode *node ) ;
#line 105
extern GNode *g_node_copy_deep(GNode *node , GCopyFunc copy_func , gpointer data ) ;
#line 109
extern GNode *g_node_copy(GNode *node ) ;
#line 111
extern GNode *g_node_insert(GNode *parent , gint position , GNode *node ) ;
#line 115
extern GNode *g_node_insert_before(GNode *parent , GNode *sibling , GNode *node ) ;
#line 119
extern GNode *g_node_insert_after(GNode *parent , GNode *sibling , GNode *node ) ;
#line 123
extern GNode *g_node_prepend(GNode *parent , GNode *node ) ;
#line 126
extern guint g_node_n_nodes(GNode *root , GTraverseFlags flags ) ;
#line 129
extern GNode *g_node_get_root(GNode *node ) ;
#line 131
extern gboolean g_node_is_ancestor(GNode *node , GNode *descendant ) ;
#line 134
extern guint g_node_depth(GNode *node ) ;
#line 136
extern GNode *g_node_find(GNode *root , GTraverseType order , GTraverseFlags flags ,
                          gpointer data ) ;
#line 224
extern void g_node_traverse(GNode *root , GTraverseType order , GTraverseFlags flags ,
                            gint max_depth , GNodeTraverseFunc func , gpointer data ) ;
#line 237
extern guint g_node_max_height(GNode *root ) ;
#line 240
extern void g_node_children_foreach(GNode *node , GTraverseFlags flags , GNodeForeachFunc func ,
                                    gpointer data ) ;
#line 245
extern void g_node_reverse_children(GNode *node ) ;
#line 247
extern guint g_node_n_children(GNode *node ) ;
#line 249
extern GNode *g_node_nth_child(GNode *node , guint n ) ;
#line 252
extern GNode *g_node_last_child(GNode *node ) ;
#line 254
extern GNode *g_node_find_child(GNode *node , GTraverseFlags flags , gpointer data ) ;
#line 258
extern gint g_node_child_position(GNode *node , GNode *child ) ;
#line 261
extern gint g_node_child_index(GNode *node , gpointer data ) ;
#line 265
extern GNode *g_node_first_sibling(GNode *node ) ;
#line 267
extern GNode *g_node_last_sibling(GNode *node ) ;
#line 49 "/usr/include/glib-2.0/glib/glist.h"
extern GList *g_list_alloc(void) ;
#line 51
extern void g_list_free(GList *list ) ;
#line 53
extern void g_list_free_1(GList *list ) ;
#line 56
extern void g_list_free_full(GList *list , GDestroyNotify free_func ) ;
#line 59
extern GList *g_list_append(GList *list , gpointer data ) ;
#line 62
extern GList *g_list_prepend(GList *list , gpointer data ) ;
#line 65
extern GList *g_list_insert(GList *list , gpointer data , gint position ) ;
#line 69
extern GList *g_list_insert_sorted(GList *list , gpointer data , GCompareFunc func ) ;
#line 73
extern GList *g_list_insert_sorted_with_data(GList *list , gpointer data , GCompareDataFunc func ,
                                             gpointer user_data ) ;
#line 78
extern GList *g_list_insert_before(GList *list , GList *sibling , gpointer data ) ;
#line 82
extern GList *g_list_insert_before_link(GList *list , GList *sibling , GList *link_ ) ;
#line 86
extern GList *g_list_concat(GList *list1 , GList *list2 ) ;
#line 89
extern GList *g_list_remove(GList *list , gconstpointer data ) ;
#line 92
extern GList *g_list_remove_all(GList *list , gconstpointer data ) ;
#line 95
extern GList *g_list_remove_link(GList *list , GList *llink ) ;
#line 98
extern GList *g_list_delete_link(GList *list , GList *link_ ) ;
#line 101
extern GList *g_list_reverse(GList *list ) ;
#line 103
extern GList *g_list_copy(GList *list ) ;
#line 106
extern GList *g_list_copy_deep(GList *list , GCopyFunc func , gpointer user_data ) ;
#line 111
extern GList *g_list_nth(GList *list , guint n ) ;
#line 114
extern GList *g_list_nth_prev(GList *list , guint n ) ;
#line 117
extern GList *g_list_find(GList *list , gconstpointer data ) ;
#line 120
extern GList *g_list_find_custom(GList *list , gconstpointer data , GCompareFunc func ) ;
#line 124
extern gint g_list_position(GList *list , GList *llink ) ;
#line 127
extern gint g_list_index(GList *list , gconstpointer data ) ;
#line 130
extern GList *g_list_last(GList *list ) ;
#line 132
extern GList *g_list_first(GList *list ) ;
#line 134
extern guint g_list_length(GList *list ) ;
#line 136
extern void g_list_foreach(GList *list , GFunc func , gpointer user_data ) ;
#line 140
extern GList *g_list_sort(GList *list , GCompareFunc compare_func ) ;
#line 143
extern GList *g_list_sort_with_data(GList *list , GCompareDataFunc compare_func ,
                                    gpointer user_data ) ;
#line 147
extern gpointer g_list_nth_data(GList *list , guint n ) ;
#line 151
extern void g_clear_list(GList **list_ptr , GDestroyNotify destroy ) ;
#line 57 "/usr/include/glib-2.0/glib/ghash.h"
extern GHashTable *g_hash_table_new(GHashFunc hash_func , GEqualFunc key_equal_func ) ;
#line 60
extern GHashTable *g_hash_table_new_full(GHashFunc hash_func , GEqualFunc key_equal_func ,
                                         GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 65
extern GHashTable *g_hash_table_new_similar(GHashTable *other_hash_table ) ;
#line 67
extern void g_hash_table_destroy(GHashTable *hash_table ) ;
#line 69
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 73
extern gboolean g_hash_table_replace(GHashTable *hash_table , gpointer key , gpointer value ) ;
#line 77
extern gboolean g_hash_table_add(GHashTable *hash_table , gpointer key ) ;
#line 80
extern gboolean g_hash_table_remove(GHashTable *hash_table , gconstpointer key ) ;
#line 83
extern void g_hash_table_remove_all(GHashTable *hash_table ) ;
#line 85
extern gboolean g_hash_table_steal(GHashTable *hash_table , gconstpointer key ) ;
#line 88
extern gboolean g_hash_table_steal_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                            gpointer *stolen_key , gpointer *stolen_value ) ;
#line 93
extern void g_hash_table_steal_all(GHashTable *hash_table ) ;
#line 95
extern gpointer g_hash_table_lookup(GHashTable *hash_table , gconstpointer key ) ;
#line 98
extern gboolean g_hash_table_contains(GHashTable *hash_table , gconstpointer key ) ;
#line 101
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
#line 106
extern void g_hash_table_foreach(GHashTable *hash_table , GHFunc func , gpointer user_data ) ;
#line 110
extern gpointer g_hash_table_find(GHashTable *hash_table , GHRFunc predicate , gpointer user_data ) ;
#line 114
extern guint g_hash_table_foreach_remove(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 118
extern guint g_hash_table_foreach_steal(GHashTable *hash_table , GHRFunc func , gpointer user_data ) ;
#line 122
extern guint g_hash_table_size(GHashTable *hash_table ) ;
#line 124
extern GList *g_hash_table_get_keys(GHashTable *hash_table ) ;
#line 126
extern GList *g_hash_table_get_values(GHashTable *hash_table ) ;
#line 128
extern gpointer *g_hash_table_get_keys_as_array(GHashTable *hash_table , guint *length ) ;
#line 132
extern void g_hash_table_iter_init(GHashTableIter *iter , GHashTable *hash_table ) ;
#line 135
extern gboolean g_hash_table_iter_next(GHashTableIter *iter , gpointer *key , gpointer *value ) ;
#line 139
extern GHashTable *g_hash_table_iter_get_hash_table(GHashTableIter *iter ) ;
#line 141
extern void g_hash_table_iter_remove(GHashTableIter *iter ) ;
#line 143
extern void g_hash_table_iter_replace(GHashTableIter *iter , gpointer value ) ;
#line 146
extern void g_hash_table_iter_steal(GHashTableIter *iter ) ;
#line 149
extern GHashTable *g_hash_table_ref(GHashTable *hash_table ) ;
#line 151
extern void g_hash_table_unref(GHashTable *hash_table ) ;
#line 159
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 162
extern guint g_str_hash(gconstpointer v ) ;
#line 165
extern gboolean g_int_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 168
extern guint g_int_hash(gconstpointer v ) ;
#line 171
extern gboolean g_int64_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 174
extern guint g_int64_hash(gconstpointer v ) ;
#line 177
extern gboolean g_double_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 180
extern guint g_double_hash(gconstpointer v ) ;
#line 183
extern guint g_direct_hash(gconstpointer v ) ;
#line 185
extern gboolean g_direct_equal(gconstpointer v1 , gconstpointer v2 ) ;
#line 43 "/usr/include/glib-2.0/glib/ghmac.h"
extern GHmac *g_hmac_new(GChecksumType digest_type , guchar *key , gsize key_len ) ;
#line 47
extern GHmac *g_hmac_copy(GHmac *hmac ) ;
#line 49
extern GHmac *g_hmac_ref(GHmac *hmac ) ;
#line 51
extern void g_hmac_unref(GHmac *hmac ) ;
#line 53
extern void g_hmac_update(GHmac *hmac , guchar *data , gssize length ) ;
#line 57
extern gchar *g_hmac_get_string(GHmac *hmac ) ;
#line 59
extern void g_hmac_get_digest(GHmac *hmac , guint8 *buffer , gsize *digest_len ) ;
#line 64
extern gchar *g_compute_hmac_for_data(GChecksumType digest_type , guchar *key , gsize key_len ,
                                      guchar *data , gsize length ) ;
#line 70
extern gchar *g_compute_hmac_for_string(GChecksumType digest_type , guchar *key ,
                                        gsize key_len , gchar *str , gssize length ) ;
#line 76
extern gchar *g_compute_hmac_for_bytes(GChecksumType digest_type , GBytes *key , GBytes *data ) ;
#line 105 "/usr/include/glib-2.0/glib/ghook.h"
extern void g_hook_list_init(GHookList *hook_list , guint hook_size ) ;
#line 108
extern void g_hook_list_clear(GHookList *hook_list ) ;
#line 110
extern GHook *g_hook_alloc(GHookList *hook_list ) ;
#line 112
extern void g_hook_free(GHookList *hook_list , GHook *hook ) ;
#line 115
extern GHook *g_hook_ref(GHookList *hook_list , GHook *hook ) ;
#line 118
extern void g_hook_unref(GHookList *hook_list , GHook *hook ) ;
#line 121
extern gboolean g_hook_destroy(GHookList *hook_list , gulong hook_id ) ;
#line 124
extern void g_hook_destroy_link(GHookList *hook_list , GHook *hook ) ;
#line 127
extern void g_hook_prepend(GHookList *hook_list , GHook *hook ) ;
#line 130
extern void g_hook_insert_before(GHookList *hook_list , GHook *sibling , GHook *hook ) ;
#line 134
extern void g_hook_insert_sorted(GHookList *hook_list , GHook *hook , GHookCompareFunc func ) ;
#line 138
extern GHook *g_hook_get(GHookList *hook_list , gulong hook_id ) ;
#line 141
extern GHook *g_hook_find(GHookList *hook_list , gboolean need_valids , GHookFindFunc func ,
                          gpointer data ) ;
#line 146
extern GHook *g_hook_find_data(GHookList *hook_list , gboolean need_valids , gpointer data ) ;
#line 150
extern GHook *g_hook_find_func(GHookList *hook_list , gboolean need_valids , gpointer func ) ;
#line 154
extern GHook *g_hook_find_func_data(GHookList *hook_list , gboolean need_valids ,
                                    gpointer func , gpointer data ) ;
#line 160
extern GHook *g_hook_first_valid(GHookList *hook_list , gboolean may_be_in_call ) ;
#line 166
extern GHook *g_hook_next_valid(GHookList *hook_list , GHook *hook , gboolean may_be_in_call ) ;
#line 171
extern gint g_hook_compare_ids(GHook *new_hook , GHook *sibling ) ;
#line 179
extern void g_hook_list_invoke(GHookList *hook_list , gboolean may_recurse ) ;
#line 185
extern void g_hook_list_invoke_check(GHookList *hook_list , gboolean may_recurse ) ;
#line 190
extern void g_hook_list_marshal(GHookList *hook_list , gboolean may_recurse , GHookMarshaller marshaller ,
                                gpointer marshal_data ) ;
#line 195
extern void g_hook_list_marshal_check(GHookList *hook_list , gboolean may_recurse ,
                                      GHookCheckMarshaller marshaller , gpointer marshal_data ) ;
#line 30 "/usr/include/glib-2.0/glib/ghostutils.h"
extern gboolean g_hostname_is_non_ascii(gchar *hostname ) ;
#line 32
extern gboolean g_hostname_is_ascii_encoded(gchar *hostname ) ;
#line 34
extern gboolean g_hostname_is_ip_address(gchar *hostname ) ;
#line 37
extern gchar *g_hostname_to_ascii(gchar *hostname ) ;
#line 39
extern gchar *g_hostname_to_unicode(gchar *hostname ) ;
#line 114 "/usr/include/glib-2.0/glib/gpoll.h"
extern gint g_poll(GPollFD *fds , guint nfds , gint timeout ) ;
#line 48 "/usr/include/glib-2.0/glib/gslist.h"
extern GSList *g_slist_alloc(void) ;
#line 50
extern void g_slist_free(GSList *list ) ;
#line 52
extern void g_slist_free_1(GSList *list ) ;
#line 55
extern void g_slist_free_full(GSList *list , GDestroyNotify free_func ) ;
#line 58
extern GSList *g_slist_append(GSList *list , gpointer data ) ;
#line 61
extern GSList *g_slist_prepend(GSList *list , gpointer data ) ;
#line 64
extern GSList *g_slist_insert(GSList *list , gpointer data , gint position ) ;
#line 68
extern GSList *g_slist_insert_sorted(GSList *list , gpointer data , GCompareFunc func ) ;
#line 72
extern GSList *g_slist_insert_sorted_with_data(GSList *list , gpointer data , GCompareDataFunc func ,
                                               gpointer user_data ) ;
#line 77
extern GSList *g_slist_insert_before(GSList *slist , GSList *sibling , gpointer data ) ;
#line 81
extern GSList *g_slist_concat(GSList *list1 , GSList *list2 ) ;
#line 84
extern GSList *g_slist_remove(GSList *list , gconstpointer data ) ;
#line 87
extern GSList *g_slist_remove_all(GSList *list , gconstpointer data ) ;
#line 90
extern GSList *g_slist_remove_link(GSList *list , GSList *link_ ) ;
#line 93
extern GSList *g_slist_delete_link(GSList *list , GSList *link_ ) ;
#line 96
extern GSList *g_slist_reverse(GSList *list ) ;
#line 98
extern GSList *g_slist_copy(GSList *list ) ;
#line 101
extern GSList *g_slist_copy_deep(GSList *list , GCopyFunc func , gpointer user_data ) ;
#line 105
extern GSList *g_slist_nth(GSList *list , guint n ) ;
#line 108
extern GSList *g_slist_find(GSList *list , gconstpointer data ) ;
#line 111
extern GSList *g_slist_find_custom(GSList *list , gconstpointer data , GCompareFunc func ) ;
#line 115
extern gint g_slist_position(GSList *list , GSList *llink ) ;
#line 118
extern gint g_slist_index(GSList *list , gconstpointer data ) ;
#line 121
extern GSList *g_slist_last(GSList *list ) ;
#line 123
extern guint g_slist_length(GSList *list ) ;
#line 125
extern void g_slist_foreach(GSList *list , GFunc func , gpointer user_data ) ;
#line 129
extern GSList *g_slist_sort(GSList *list , GCompareFunc compare_func ) ;
#line 132
extern GSList *g_slist_sort_with_data(GSList *list , GCompareDataFunc compare_func ,
                                      gpointer user_data ) ;
#line 136
extern gpointer g_slist_nth_data(GSList *list , guint n ) ;
#line 140
extern void g_clear_slist(GSList **slist_ptr , GDestroyNotify destroy ) ;
#line 380 "/usr/include/glib-2.0/glib/gmain.h"
extern GMainContext *g_main_context_new(void) ;
#line 383
extern GMainContext *g_main_context_new_with_flags(GMainContextFlags flags ) ;
#line 386
extern GMainContext *g_main_context_ref(GMainContext *context ) ;
#line 388
extern void g_main_context_unref(GMainContext *context ) ;
#line 390
extern GMainContext *g_main_context_default(void) ;
#line 393
extern gboolean g_main_context_iteration(GMainContext *context , gboolean may_block ) ;
#line 396
extern gboolean g_main_context_pending(GMainContext *context ) ;
#line 401
extern GSource *g_main_context_find_source_by_id(GMainContext *context , guint source_id ) ;
#line 404
extern GSource *g_main_context_find_source_by_user_data(GMainContext *context , gpointer user_data ) ;
#line 407
extern GSource *g_main_context_find_source_by_funcs_user_data(GMainContext *context ,
                                                              GSourceFuncs *funcs ,
                                                              gpointer user_data ) ;
#line 414
extern void g_main_context_wakeup(GMainContext *context ) ;
#line 416
extern gboolean g_main_context_acquire(GMainContext *context ) ;
#line 418
extern void g_main_context_release(GMainContext *context ) ;
#line 420
extern gboolean g_main_context_is_owner(GMainContext *context ) ;
#line 422
extern gboolean g_main_context_wait(GMainContext *context , GCond *cond , GMutex *mutex ) ;
#line 427
extern gboolean g_main_context_prepare(GMainContext *context , gint *priority ) ;
#line 430
extern gint g_main_context_query(GMainContext *context , gint max_priority , gint *timeout_ ,
                                 GPollFD *fds , gint n_fds ) ;
#line 436
extern gboolean g_main_context_check(GMainContext *context , gint max_priority , GPollFD *fds ,
                                     gint n_fds ) ;
#line 441
extern void g_main_context_dispatch(GMainContext *context ) ;
#line 444
extern void g_main_context_set_poll_func(GMainContext *context , GPollFunc func ) ;
#line 447
extern GPollFunc g_main_context_get_poll_func(GMainContext *context ) ;
#line 452
extern void g_main_context_add_poll(GMainContext *context , GPollFD *fd , gint priority ) ;
#line 456
extern void g_main_context_remove_poll(GMainContext *context , GPollFD *fd ) ;
#line 460
extern gint g_main_depth(void) ;
#line 462
extern GSource *g_main_current_source(void) ;
#line 467
extern void g_main_context_push_thread_default(GMainContext *context ) ;
#line 469
extern void g_main_context_pop_thread_default(GMainContext *context ) ;
#line 471
extern GMainContext *g_main_context_get_thread_default(void) ;
#line 473
extern GMainContext *g_main_context_ref_thread_default(void) ;
#line 532 "/usr/include/glib-2.0/glib/gmain.h"
__inline static GMainContextPusher *g_main_context_pusher_new(GMainContext *main_context ) 
{ 


  {
  {
#line 534
  g_main_context_push_thread_default(main_context);
  }
#line 535
  return ((GMainContextPusher *)main_context);
}
}
#line 554 "/usr/include/glib-2.0/glib/gmain.h"
__inline static void g_main_context_pusher_free(GMainContextPusher *pusher ) 
{ 


  {
  {
#line 556
  g_main_context_pop_thread_default((GMainContext *)pusher);
  }
  return;
}
}
#line 563
extern GMainLoop *g_main_loop_new(GMainContext *context , gboolean is_running ) ;
#line 566
extern void g_main_loop_run(GMainLoop *loop ) ;
#line 568
extern void g_main_loop_quit(GMainLoop *loop ) ;
#line 570
extern GMainLoop *g_main_loop_ref(GMainLoop *loop ) ;
#line 572
extern void g_main_loop_unref(GMainLoop *loop ) ;
#line 574
extern gboolean g_main_loop_is_running(GMainLoop *loop ) ;
#line 576
extern GMainContext *g_main_loop_get_context(GMainLoop *loop ) ;
#line 581
extern GSource *g_source_new(GSourceFuncs *source_funcs , guint struct_size ) ;
#line 586
extern void g_source_set_dispose_function(GSource *source , GSourceDisposeFunc dispose ) ;
#line 591
extern GSource *g_source_ref(GSource *source ) ;
#line 593
extern void g_source_unref(GSource *source ) ;
#line 596
extern guint g_source_attach(GSource *source , GMainContext *context ) ;
#line 599
extern void g_source_destroy(GSource *source ) ;
#line 602
extern void g_source_set_priority(GSource *source , gint priority ) ;
#line 605
extern gint g_source_get_priority(GSource *source ) ;
#line 607
extern void g_source_set_can_recurse(GSource *source , gboolean can_recurse ) ;
#line 610
extern gboolean g_source_get_can_recurse(GSource *source ) ;
#line 612
extern guint g_source_get_id(GSource *source ) ;
#line 615
extern GMainContext *g_source_get_context(GSource *source ) ;
#line 618
extern void g_source_set_callback(GSource *source , GSourceFunc func , gpointer data ,
                                  GDestroyNotify notify ) ;
#line 624
extern void g_source_set_funcs(GSource *source , GSourceFuncs *funcs ) ;
#line 627
extern gboolean g_source_is_destroyed(GSource *source ) ;
#line 630
extern void g_source_set_name(GSource *source , char const   *name ) ;
#line 633
extern void g_source_set_static_name(GSource *source , char const   *name ) ;
#line 636
extern char const   *g_source_get_name(GSource *source ) ;
#line 638
extern void g_source_set_name_by_id(guint tag , char const   *name ) ;
#line 642
extern void g_source_set_ready_time(GSource *source , gint64 ready_time ) ;
#line 645
extern gint64 g_source_get_ready_time(GSource *source ) ;
#line 649
extern gpointer g_source_add_unix_fd(GSource *source , gint fd , GIOCondition events ) ;
#line 653
extern void g_source_modify_unix_fd(GSource *source , gpointer tag , GIOCondition new_events ) ;
#line 657
extern void g_source_remove_unix_fd(GSource *source , gpointer tag ) ;
#line 660
extern GIOCondition g_source_query_unix_fd(GSource *source , gpointer tag ) ;
#line 666
extern void g_source_set_callback_indirect(GSource *source , gpointer callback_data ,
                                           GSourceCallbackFuncs *callback_funcs ) ;
#line 671
extern void g_source_add_poll(GSource *source , GPollFD *fd ) ;
#line 674
extern void g_source_remove_poll(GSource *source , GPollFD *fd ) ;
#line 678
extern void g_source_add_child_source(GSource *source , GSource *child_source ) ;
#line 681
extern void g_source_remove_child_source(GSource *source , GSource *child_source ) ;
#line 686
extern void g_source_get_current_time(GSource *source , GTimeVal *timeval ) ;
#line 691
extern gint64 g_source_get_time(GSource *source ) ;
#line 700
extern GSource *g_idle_source_new(void) ;
#line 702
extern GSource *g_child_watch_source_new(GPid pid ) ;
#line 704
extern GSource *g_timeout_source_new(guint interval ) ;
#line 706
extern GSource *g_timeout_source_new_seconds(guint interval ) ;
#line 712
extern void g_get_current_time(GTimeVal *result ) ;
#line 716
extern gint64 g_get_monotonic_time(void) ;
#line 718
extern gint64 g_get_real_time(void) ;
#line 723
extern gboolean g_source_remove(guint tag ) ;
#line 725
extern gboolean g_source_remove_by_user_data(gpointer user_data ) ;
#line 727
extern gboolean g_source_remove_by_funcs_user_data(GSourceFuncs *funcs , gpointer user_data ) ;
#line 744
extern void g_clear_handle_id(guint *tag_ptr , GClearHandleFunc clear_func ) ;
#line 764
extern guint g_timeout_add_full(gint priority , guint interval , GSourceFunc function ,
                                gpointer data , GDestroyNotify notify ) ;
#line 770
extern guint g_timeout_add(guint interval , GSourceFunc function , gpointer data ) ;
#line 774
extern guint g_timeout_add_seconds_full(gint priority , guint interval , GSourceFunc function ,
                                        gpointer data , GDestroyNotify notify ) ;
#line 780
extern guint g_timeout_add_seconds(guint interval , GSourceFunc function , gpointer data ) ;
#line 784
extern guint g_child_watch_add_full(gint priority , GPid pid , GChildWatchFunc function ,
                                    gpointer data , GDestroyNotify notify ) ;
#line 790
extern guint g_child_watch_add(GPid pid , GChildWatchFunc function , gpointer data ) ;
#line 794
extern guint g_idle_add(GSourceFunc function , gpointer data ) ;
#line 797
extern guint g_idle_add_full(gint priority , GSourceFunc function , gpointer data ,
                             GDestroyNotify notify ) ;
#line 802
extern gboolean g_idle_remove_by_data(gpointer data ) ;
#line 805
extern void g_main_context_invoke_full(GMainContext *context , gint priority , GSourceFunc function ,
                                       gpointer data , GDestroyNotify notify ) ;
#line 811
extern void g_main_context_invoke(GMainContext *context , GSourceFunc function , gpointer data ) ;
#line 817 "/usr/include/glib-2.0/glib/gmain.h"
__inline static int g_steal_fd(int *fd_ptr ) 
{ 
  int fd ;

  {
#line 819
  fd = *fd_ptr;
#line 820
  *fd_ptr = - 1;
#line 821
  return (fd);
}
}
#line 825
extern GSourceFuncs g_timeout_funcs ;
#line 826
extern GSourceFuncs g_child_watch_funcs ;
#line 827
extern GSourceFuncs g_idle_funcs ;
#line 829
extern GSourceFuncs g_unix_signal_funcs ;
#line 830
extern GSourceFuncs g_unix_fd_source_funcs ;
#line 650 "/usr/include/glib-2.0/glib/gunicode.h"
extern guint32 g_unicode_script_to_iso15924(GUnicodeScript script ) ;
#line 652
extern GUnicodeScript g_unicode_script_from_iso15924(guint32 iso15924 ) ;
#line 657
extern gboolean g_unichar_isalnum(gunichar c ) ;
#line 659
extern gboolean g_unichar_isalpha(gunichar c ) ;
#line 661
extern gboolean g_unichar_iscntrl(gunichar c ) ;
#line 663
extern gboolean g_unichar_isdigit(gunichar c ) ;
#line 665
extern gboolean g_unichar_isgraph(gunichar c ) ;
#line 667
extern gboolean g_unichar_islower(gunichar c ) ;
#line 669
extern gboolean g_unichar_isprint(gunichar c ) ;
#line 671
extern gboolean g_unichar_ispunct(gunichar c ) ;
#line 673
extern gboolean g_unichar_isspace(gunichar c ) ;
#line 675
extern gboolean g_unichar_isupper(gunichar c ) ;
#line 677
extern gboolean g_unichar_isxdigit(gunichar c ) ;
#line 679
extern gboolean g_unichar_istitle(gunichar c ) ;
#line 681
extern gboolean g_unichar_isdefined(gunichar c ) ;
#line 683
extern gboolean g_unichar_iswide(gunichar c ) ;
#line 685
extern gboolean g_unichar_iswide_cjk(gunichar c ) ;
#line 687
extern gboolean g_unichar_iszerowidth(gunichar c ) ;
#line 689
extern gboolean g_unichar_ismark(gunichar c ) ;
#line 694
extern gunichar g_unichar_toupper(gunichar c ) ;
#line 696
extern gunichar g_unichar_tolower(gunichar c ) ;
#line 698
extern gunichar g_unichar_totitle(gunichar c ) ;
#line 703
extern gint g_unichar_digit_value(gunichar c ) ;
#line 706
extern gint g_unichar_xdigit_value(gunichar c ) ;
#line 710
extern GUnicodeType g_unichar_type(gunichar c ) ;
#line 714
extern GUnicodeBreakType g_unichar_break_type(gunichar c ) ;
#line 718
extern gint g_unichar_combining_class(gunichar uc ) ;
#line 721
extern gboolean g_unichar_get_mirror_char(gunichar ch , gunichar *mirrored_ch ) ;
#line 725
extern GUnicodeScript g_unichar_get_script(gunichar ch ) ;
#line 729
extern gboolean g_unichar_validate(gunichar ch ) ;
#line 733
extern gboolean g_unichar_compose(gunichar a , gunichar b , gunichar *ch ) ;
#line 737
extern gboolean g_unichar_decompose(gunichar ch , gunichar *a , gunichar *b ) ;
#line 742
extern gsize g_unichar_fully_decompose(gunichar ch , gboolean compat , gunichar *result ,
                                       gsize result_len ) ;
#line 763
extern void g_unicode_canonical_ordering(gunichar *string , gsize len ) ;
#line 768
extern gunichar *g_unicode_canonical_decomposition(gunichar ch , gsize *result_len ) ;
#line 773
extern gchar * const  g_utf8_skip ;
#line 794
extern gunichar g_utf8_get_char(gchar *p ) ;
#line 796
extern gunichar g_utf8_get_char_validated(gchar *p , gssize max_len ) ;
#line 800
extern gchar *g_utf8_offset_to_pointer(gchar *str , glong offset ) ;
#line 803
extern glong g_utf8_pointer_to_offset(gchar *str , gchar *pos ) ;
#line 806
extern gchar *g_utf8_prev_char(gchar *p ) ;
#line 808
extern gchar *g_utf8_find_next_char(gchar *p , gchar *end ) ;
#line 811
extern gchar *g_utf8_find_prev_char(gchar *str , gchar *p ) ;
#line 815
extern glong g_utf8_strlen(gchar *p , gssize max ) ;
#line 819
extern gchar *g_utf8_substring(gchar *str , glong start_pos , glong end_pos ) ;
#line 824
extern gchar *g_utf8_strncpy(gchar *dest , gchar *src , gsize n ) ;
#line 831
extern gchar *g_utf8_strchr(gchar *p , gssize len , gunichar c ) ;
#line 835
extern gchar *g_utf8_strrchr(gchar *p , gssize len , gunichar c ) ;
#line 839
extern gchar *g_utf8_strreverse(gchar *str , gssize len ) ;
#line 843
extern gunichar2 *g_utf8_to_utf16(gchar *str , glong len , glong *items_read , glong *items_written ,
                                  GError **error ) ;
#line 849
extern gunichar *g_utf8_to_ucs4(gchar *str , glong len , glong *items_read , glong *items_written ,
                                GError **error ) ;
#line 855
extern gunichar *g_utf8_to_ucs4_fast(gchar *str , glong len , glong *items_written ) ;
#line 859
extern gunichar *g_utf16_to_ucs4(gunichar2 *str , glong len , glong *items_read ,
                                 glong *items_written , GError **error ) ;
#line 865
extern gchar *g_utf16_to_utf8(gunichar2 *str , glong len , glong *items_read , glong *items_written ,
                              GError **error ) ;
#line 871
extern gunichar2 *g_ucs4_to_utf16(gunichar *str , glong len , glong *items_read ,
                                  glong *items_written , GError **error ) ;
#line 877
extern gchar *g_ucs4_to_utf8(gunichar *str , glong len , glong *items_read , glong *items_written ,
                             GError **error ) ;
#line 884
extern gint g_unichar_to_utf8(gunichar c , gchar *outbuf ) ;
#line 888
extern gboolean g_utf8_validate(gchar *str , gssize max_len , gchar **end ) ;
#line 892
extern gboolean g_utf8_validate_len(gchar *str , gsize max_len , gchar **end ) ;
#line 897
extern gchar *g_utf8_strup(gchar *str , gssize len ) ;
#line 900
extern gchar *g_utf8_strdown(gchar *str , gssize len ) ;
#line 903
extern gchar *g_utf8_casefold(gchar *str , gssize len ) ;
#line 942
extern gchar *g_utf8_normalize(gchar *str , gssize len , GNormalizeMode mode ) ;
#line 947
extern gint g_utf8_collate(gchar *str1 , gchar *str2 ) ;
#line 950
extern gchar *g_utf8_collate_key(gchar *str , gssize len ) ;
#line 953
extern gchar *g_utf8_collate_key_for_filename(gchar *str , gssize len ) ;
#line 957
extern gchar *g_utf8_make_valid(gchar *str , gssize len ) ;
#line 49 "/usr/include/glib-2.0/glib/gstring.h"
extern GString *g_string_new(gchar *init ) ;
#line 51
extern GString *g_string_new_len(gchar *init , gssize len ) ;
#line 54
extern GString *g_string_sized_new(gsize dfl_size ) ;
#line 56
extern gchar *g_string_free(GString *string , gboolean free_segment ) ;
#line 59
extern GBytes *g_string_free_to_bytes(GString *string ) ;
#line 61
extern gboolean g_string_equal(GString *v , GString *v2 ) ;
#line 64
extern guint g_string_hash(GString *str ) ;
#line 66
extern GString *g_string_assign(GString *string , gchar *rval ) ;
#line 69
extern GString *g_string_truncate(GString *string , gsize len ) ;
#line 72
extern GString *g_string_set_size(GString *string , gsize len ) ;
#line 75
extern GString *g_string_insert_len(GString *string , gssize pos , gchar *val , gssize len ) ;
#line 80
extern GString *g_string_append(GString *string , gchar *val ) ;
#line 83
extern GString *g_string_append_len(GString *string , gchar *val , gssize len ) ;
#line 87
extern GString *g_string_append_c(GString *string , gchar c ) ;
#line 90
extern GString *g_string_append_unichar(GString *string , gunichar wc ) ;
#line 93
extern GString *g_string_prepend(GString *string , gchar *val ) ;
#line 96
extern GString *g_string_prepend_c(GString *string , gchar c ) ;
#line 99
extern GString *g_string_prepend_unichar(GString *string , gunichar wc ) ;
#line 102
extern GString *g_string_prepend_len(GString *string , gchar *val , gssize len ) ;
#line 106
extern GString *g_string_insert(GString *string , gssize pos , gchar *val ) ;
#line 110
extern GString *g_string_insert_c(GString *string , gssize pos , gchar c ) ;
#line 114
extern GString *g_string_insert_unichar(GString *string , gssize pos , gunichar wc ) ;
#line 118
extern GString *g_string_overwrite(GString *string , gsize pos , gchar *val ) ;
#line 122
extern GString *g_string_overwrite_len(GString *string , gsize pos , gchar *val ,
                                       gssize len ) ;
#line 127
extern GString *g_string_erase(GString *string , gssize pos , gssize len ) ;
#line 131
extern guint g_string_replace(GString *string , gchar *find , gchar *replace , guint limit ) ;
#line 136
extern GString *g_string_ascii_down(GString *string ) ;
#line 138
extern GString *g_string_ascii_up(GString *string ) ;
#line 140
extern void g_string_vprintf(GString *string , gchar *format , va_list args ) ;
#line 145
extern void g_string_printf(GString *string , gchar *format  , ...) ;
#line 149
extern void g_string_append_vprintf(GString *string , gchar *format , va_list args ) ;
#line 154
extern void g_string_append_printf(GString *string , gchar *format  , ...) ;
#line 158
extern GString *g_string_append_uri_escaped(GString *string , gchar *unescaped , gchar *reserved_chars_allowed ,
                                            gboolean allow_utf8 ) ;
#line 166 "/usr/include/glib-2.0/glib/gstring.h"
__inline static GString *g_string_append_c_inline(GString *gstring , gchar c ) 
{ 
  gsize __cil_tmp3 ;

  {
#line 169
  if (gstring->len + 1UL < gstring->allocated_len) {
#line 171
    __cil_tmp3 = gstring->len;
#line 171
    (gstring->len) ++;
#line 171
    *(gstring->str + __cil_tmp3) = c;
#line 172
    *(gstring->str + gstring->len) = (gchar )0;
  } else {
    {
#line 175
    g_string_insert_c(gstring, (gssize )(- 1), c);
    }
  }
#line 176
  return (gstring);
}
}
#line 183
extern GString *g_string_down(GString *string ) ;
#line 185
extern GString *g_string_up(GString *string ) ;
#line 159 "/usr/include/glib-2.0/glib/giochannel.h"
extern void g_io_channel_init(GIOChannel *channel ) ;
#line 161
extern GIOChannel *g_io_channel_ref(GIOChannel *channel ) ;
#line 163
extern void g_io_channel_unref(GIOChannel *channel ) ;
#line 166
extern GIOError g_io_channel_read(GIOChannel *channel , gchar *buf , gsize count ,
                                  gsize *bytes_read ) ;
#line 172
extern GIOError g_io_channel_write(GIOChannel *channel , gchar *buf , gsize count ,
                                   gsize *bytes_written ) ;
#line 178
extern GIOError g_io_channel_seek(GIOChannel *channel , gint64 offset , GSeekType type ) ;
#line 183
extern void g_io_channel_close(GIOChannel *channel ) ;
#line 186
extern GIOStatus g_io_channel_shutdown(GIOChannel *channel , gboolean flush , GError **err ) ;
#line 190
extern guint g_io_add_watch_full(GIOChannel *channel , gint priority , GIOCondition condition ,
                                 GIOFunc func , gpointer user_data , GDestroyNotify notify ) ;
#line 197
extern GSource *g_io_create_watch(GIOChannel *channel , GIOCondition condition ) ;
#line 200
extern guint g_io_add_watch(GIOChannel *channel , GIOCondition condition , GIOFunc func ,
                            gpointer user_data ) ;
#line 209
extern void g_io_channel_set_buffer_size(GIOChannel *channel , gsize size ) ;
#line 212
extern gsize g_io_channel_get_buffer_size(GIOChannel *channel ) ;
#line 214
extern GIOCondition g_io_channel_get_buffer_condition(GIOChannel *channel ) ;
#line 216
extern GIOStatus g_io_channel_set_flags(GIOChannel *channel , GIOFlags flags , GError **error ) ;
#line 220
extern GIOFlags g_io_channel_get_flags(GIOChannel *channel ) ;
#line 222
extern void g_io_channel_set_line_term(GIOChannel *channel , gchar *line_term , gint length ) ;
#line 226
extern gchar *g_io_channel_get_line_term(GIOChannel *channel , gint *length ) ;
#line 229
extern void g_io_channel_set_buffered(GIOChannel *channel , gboolean buffered ) ;
#line 232
extern gboolean g_io_channel_get_buffered(GIOChannel *channel ) ;
#line 234
extern GIOStatus g_io_channel_set_encoding(GIOChannel *channel , gchar *encoding ,
                                           GError **error ) ;
#line 238
extern gchar *g_io_channel_get_encoding(GIOChannel *channel ) ;
#line 240
extern void g_io_channel_set_close_on_unref(GIOChannel *channel , gboolean do_close ) ;
#line 243
extern gboolean g_io_channel_get_close_on_unref(GIOChannel *channel ) ;
#line 247
extern GIOStatus g_io_channel_flush(GIOChannel *channel , GError **error ) ;
#line 250
extern GIOStatus g_io_channel_read_line(GIOChannel *channel , gchar **str_return ,
                                        gsize *length , gsize *terminator_pos , GError **error ) ;
#line 256
extern GIOStatus g_io_channel_read_line_string(GIOChannel *channel , GString *buffer ,
                                               gsize *terminator_pos , GError **error ) ;
#line 261
extern GIOStatus g_io_channel_read_to_end(GIOChannel *channel , gchar **str_return ,
                                          gsize *length , GError **error ) ;
#line 266
extern GIOStatus g_io_channel_read_chars(GIOChannel *channel , gchar *buf , gsize count ,
                                         gsize *bytes_read , GError **error ) ;
#line 272
extern GIOStatus g_io_channel_read_unichar(GIOChannel *channel , gunichar *thechar ,
                                           GError **error ) ;
#line 276
extern GIOStatus g_io_channel_write_chars(GIOChannel *channel , gchar *buf , gssize count ,
                                          gsize *bytes_written , GError **error ) ;
#line 282
extern GIOStatus g_io_channel_write_unichar(GIOChannel *channel , gunichar thechar ,
                                            GError **error ) ;
#line 286
extern GIOStatus g_io_channel_seek_position(GIOChannel *channel , gint64 offset ,
                                            GSeekType type , GError **error ) ;
#line 291
extern GIOChannel *g_io_channel_new_file(gchar *filename , gchar *mode , GError **error ) ;
#line 298
extern GQuark g_io_channel_error_quark(void) ;
#line 300
extern GIOChannelError g_io_channel_error_from_errno(gint en ) ;
#line 321
extern GIOChannel *g_io_channel_unix_new(int fd ) ;
#line 323
extern gint g_io_channel_unix_get_fd(GIOChannel *channel ) ;
#line 327
extern GSourceFuncs g_io_watch_funcs ;
#line 46 "/usr/include/glib-2.0/glib/gkeyfile.h"
extern GQuark g_key_file_error_quark(void) ;
#line 58
extern GKeyFile *g_key_file_new(void) ;
#line 60
extern GKeyFile *g_key_file_ref(GKeyFile *key_file ) ;
#line 62
extern void g_key_file_unref(GKeyFile *key_file ) ;
#line 64
extern void g_key_file_free(GKeyFile *key_file ) ;
#line 66
extern void g_key_file_set_list_separator(GKeyFile *key_file , gchar separator ) ;
#line 69
extern gboolean g_key_file_load_from_file(GKeyFile *key_file , gchar *file , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 74
extern gboolean g_key_file_load_from_data(GKeyFile *key_file , gchar *data , gsize length ,
                                          GKeyFileFlags flags , GError **error ) ;
#line 80
extern gboolean g_key_file_load_from_bytes(GKeyFile *key_file , GBytes *bytes , GKeyFileFlags flags ,
                                           GError **error ) ;
#line 85
extern gboolean g_key_file_load_from_dirs(GKeyFile *key_file , gchar *file , gchar **search_dirs ,
                                          gchar **full_path , GKeyFileFlags flags ,
                                          GError **error ) ;
#line 92
extern gboolean g_key_file_load_from_data_dirs(GKeyFile *key_file , gchar *file ,
                                               gchar **full_path , GKeyFileFlags flags ,
                                               GError **error ) ;
#line 98
extern gchar *g_key_file_to_data(GKeyFile *key_file , gsize *length , GError **error ) ;
#line 102
extern gboolean g_key_file_save_to_file(GKeyFile *key_file , gchar *filename , GError **error ) ;
#line 106
extern gchar *g_key_file_get_start_group(GKeyFile *key_file ) ;
#line 108
extern gchar **g_key_file_get_groups(GKeyFile *key_file , gsize *length ) ;
#line 111
extern gchar **g_key_file_get_keys(GKeyFile *key_file , gchar *group_name , gsize *length ,
                                   GError **error ) ;
#line 116
extern gboolean g_key_file_has_group(GKeyFile *key_file , gchar *group_name ) ;
#line 119
extern gboolean g_key_file_has_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 124
extern gchar *g_key_file_get_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 129
extern void g_key_file_set_value(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gchar *value ) ;
#line 134
extern gchar *g_key_file_get_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                    GError **error ) ;
#line 139
extern void g_key_file_set_string(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gchar *string ) ;
#line 144
extern gchar *g_key_file_get_locale_string(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gchar *locale , GError **error ) ;
#line 150
extern gchar *g_key_file_get_locale_for_key(GKeyFile *key_file , gchar *group_name ,
                                            gchar *key , gchar *locale ) ;
#line 155
extern void g_key_file_set_locale_string(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gchar *locale , gchar *string ) ;
#line 161
extern gboolean g_key_file_get_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       GError **error ) ;
#line 166
extern void g_key_file_set_boolean(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gboolean value ) ;
#line 171
extern gint g_key_file_get_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 176
extern void g_key_file_set_integer(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   gint value ) ;
#line 181
extern gint64 g_key_file_get_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                   GError **error ) ;
#line 186
extern void g_key_file_set_int64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                 gint64 value ) ;
#line 191
extern guint64 g_key_file_get_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 196
extern void g_key_file_set_uint64(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  guint64 value ) ;
#line 201
extern gdouble g_key_file_get_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 206
extern void g_key_file_set_double(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                  gdouble value ) ;
#line 211
extern gchar **g_key_file_get_string_list(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , gsize *length , GError **error ) ;
#line 217
extern void g_key_file_set_string_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar * const  list[] , gsize length ) ;
#line 223
extern gchar **g_key_file_get_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                                 gchar *key , gchar *locale , gsize *length ,
                                                 GError **error ) ;
#line 230
extern void g_key_file_set_locale_string_list(GKeyFile *key_file , gchar *group_name ,
                                              gchar *key , gchar *locale , gchar * const  list[] ,
                                              gsize length ) ;
#line 237
extern gboolean *g_key_file_get_boolean_list(GKeyFile *key_file , gchar *group_name ,
                                             gchar *key , gsize *length , GError **error ) ;
#line 243
extern void g_key_file_set_boolean_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gboolean list[] , gsize length ) ;
#line 249
extern gint *g_key_file_get_integer_list(GKeyFile *key_file , gchar *group_name ,
                                         gchar *key , gsize *length , GError **error ) ;
#line 255
extern void g_key_file_set_double_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gdouble list[] , gsize length ) ;
#line 261
extern gdouble *g_key_file_get_double_list(GKeyFile *key_file , gchar *group_name ,
                                           gchar *key , gsize *length , GError **error ) ;
#line 267
extern void g_key_file_set_integer_list(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                        gint list[] , gsize length ) ;
#line 273
extern gboolean g_key_file_set_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                       gchar *comment , GError **error ) ;
#line 279
extern gchar *g_key_file_get_comment(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                     GError **error ) ;
#line 285
extern gboolean g_key_file_remove_comment(GKeyFile *key_file , gchar *group_name ,
                                          gchar *key , GError **error ) ;
#line 290
extern gboolean g_key_file_remove_key(GKeyFile *key_file , gchar *group_name , gchar *key ,
                                      GError **error ) ;
#line 295
extern gboolean g_key_file_remove_group(GKeyFile *key_file , gchar *group_name , GError **error ) ;
#line 35 "/usr/include/glib-2.0/glib/gmappedfile.h"
extern GMappedFile *g_mapped_file_new(gchar *filename , gboolean writable , GError **error ) ;
#line 39
extern GMappedFile *g_mapped_file_new_from_fd(gint fd , gboolean writable , GError **error ) ;
#line 43
extern gsize g_mapped_file_get_length(GMappedFile *file ) ;
#line 45
extern gchar *g_mapped_file_get_contents(GMappedFile *file ) ;
#line 47
extern GBytes *g_mapped_file_get_bytes(GMappedFile *file ) ;
#line 49
extern GMappedFile *g_mapped_file_ref(GMappedFile *file ) ;
#line 51
extern void g_mapped_file_unref(GMappedFile *file ) ;
#line 54
extern void g_mapped_file_free(GMappedFile *file ) ;
#line 73 "/usr/include/glib-2.0/glib/gmarkup.h"
extern GQuark g_markup_error_quark(void) ;
#line 187
extern GMarkupParseContext *g_markup_parse_context_new(GMarkupParser *parser , GMarkupParseFlags flags ,
                                                       gpointer user_data , GDestroyNotify user_data_dnotify ) ;
#line 192
extern GMarkupParseContext *g_markup_parse_context_ref(GMarkupParseContext *context ) ;
#line 194
extern void g_markup_parse_context_unref(GMarkupParseContext *context ) ;
#line 196
extern void g_markup_parse_context_free(GMarkupParseContext *context ) ;
#line 198
extern gboolean g_markup_parse_context_parse(GMarkupParseContext *context , gchar *text ,
                                             gssize text_len , GError **error ) ;
#line 203
extern void g_markup_parse_context_push(GMarkupParseContext *context , GMarkupParser *parser ,
                                        gpointer user_data ) ;
#line 207
extern gpointer g_markup_parse_context_pop(GMarkupParseContext *context ) ;
#line 210
extern gboolean g_markup_parse_context_end_parse(GMarkupParseContext *context , GError **error ) ;
#line 213
extern gchar *g_markup_parse_context_get_element(GMarkupParseContext *context ) ;
#line 215
extern GSList *g_markup_parse_context_get_element_stack(GMarkupParseContext *context ) ;
#line 219
extern void g_markup_parse_context_get_position(GMarkupParseContext *context , gint *line_number ,
                                                gint *char_number ) ;
#line 223
extern gpointer g_markup_parse_context_get_user_data(GMarkupParseContext *context ) ;
#line 227
extern gchar *g_markup_escape_text(gchar *text , gssize length ) ;
#line 231
extern gchar *g_markup_printf_escaped(char const   *format  , ...) ;
#line 234
extern gchar *g_markup_vprintf_escaped(char const   *format , va_list args ) ;
#line 251
extern gboolean g_markup_collect_attributes(gchar *element_name , gchar **attribute_names ,
                                            gchar **attribute_values , GError **error ,
                                            GMarkupCollectType first_type , gchar *first_attr 
                                            , ...) ;
#line 296 "/usr/include/glib-2.0/glib/gvarianttype.h"
extern gboolean g_variant_type_string_is_valid(gchar *type_string ) ;
#line 298
extern gboolean g_variant_type_string_scan(gchar *string , gchar *limit , gchar **endptr ) ;
#line 304
extern void g_variant_type_free(GVariantType *type ) ;
#line 306
extern GVariantType *g_variant_type_copy(GVariantType *type ) ;
#line 308
extern GVariantType *g_variant_type_new(gchar *type_string ) ;
#line 312
extern gsize g_variant_type_get_string_length(GVariantType *type ) ;
#line 314
extern gchar *g_variant_type_peek_string(GVariantType *type ) ;
#line 316
extern gchar *g_variant_type_dup_string(GVariantType *type ) ;
#line 320
extern gboolean g_variant_type_is_definite(GVariantType *type ) ;
#line 322
extern gboolean g_variant_type_is_container(GVariantType *type ) ;
#line 324
extern gboolean g_variant_type_is_basic(GVariantType *type ) ;
#line 326
extern gboolean g_variant_type_is_maybe(GVariantType *type ) ;
#line 328
extern gboolean g_variant_type_is_array(GVariantType *type ) ;
#line 330
extern gboolean g_variant_type_is_tuple(GVariantType *type ) ;
#line 332
extern gboolean g_variant_type_is_dict_entry(GVariantType *type ) ;
#line 334
extern gboolean g_variant_type_is_variant(GVariantType *type ) ;
#line 338
extern guint g_variant_type_hash(gconstpointer type ) ;
#line 340
extern gboolean g_variant_type_equal(gconstpointer type1 , gconstpointer type2 ) ;
#line 345
extern gboolean g_variant_type_is_subtype_of(GVariantType *type , GVariantType *supertype ) ;
#line 350
extern GVariantType *g_variant_type_element(GVariantType *type ) ;
#line 352
extern GVariantType *g_variant_type_first(GVariantType *type ) ;
#line 354
extern GVariantType *g_variant_type_next(GVariantType *type ) ;
#line 356
extern gsize g_variant_type_n_items(GVariantType *type ) ;
#line 358
extern GVariantType *g_variant_type_key(GVariantType *type ) ;
#line 360
extern GVariantType *g_variant_type_value(GVariantType *type ) ;
#line 364
extern GVariantType *g_variant_type_new_array(GVariantType *element ) ;
#line 366
extern GVariantType *g_variant_type_new_maybe(GVariantType *element ) ;
#line 368
extern GVariantType *g_variant_type_new_tuple(GVariantType * const  *items , gint length ) ;
#line 371
extern GVariantType *g_variant_type_new_dict_entry(GVariantType *key , GVariantType *value ) ;
#line 376
extern GVariantType *g_variant_type_checked_(gchar * ) ;
#line 378
extern gsize g_variant_type_string_get_depth_(gchar *type_string ) ;
#line 59 "/usr/include/glib-2.0/glib/gvariant.h"
extern void g_variant_unref(GVariant *value ) ;
#line 61
extern GVariant *g_variant_ref(GVariant *value ) ;
#line 63
extern GVariant *g_variant_ref_sink(GVariant *value ) ;
#line 65
extern gboolean g_variant_is_floating(GVariant *value ) ;
#line 67
extern GVariant *g_variant_take_ref(GVariant *value ) ;
#line 70
extern GVariantType *g_variant_get_type(GVariant *value ) ;
#line 72
extern gchar *g_variant_get_type_string(GVariant *value ) ;
#line 74
extern gboolean g_variant_is_of_type(GVariant *value , GVariantType *type ) ;
#line 77
extern gboolean g_variant_is_container(GVariant *value ) ;
#line 79
extern GVariantClass g_variant_classify(GVariant *value ) ;
#line 81
extern GVariant *g_variant_new_boolean(gboolean value ) ;
#line 83
extern GVariant *g_variant_new_byte(guint8 value ) ;
#line 85
extern GVariant *g_variant_new_int16(gint16 value ) ;
#line 87
extern GVariant *g_variant_new_uint16(guint16 value ) ;
#line 89
extern GVariant *g_variant_new_int32(gint32 value ) ;
#line 91
extern GVariant *g_variant_new_uint32(guint32 value ) ;
#line 93
extern GVariant *g_variant_new_int64(gint64 value ) ;
#line 95
extern GVariant *g_variant_new_uint64(guint64 value ) ;
#line 97
extern GVariant *g_variant_new_handle(gint32 value ) ;
#line 99
extern GVariant *g_variant_new_double(gdouble value ) ;
#line 101
extern GVariant *g_variant_new_string(gchar *string ) ;
#line 103
extern GVariant *g_variant_new_take_string(gchar *string ) ;
#line 105
extern GVariant *g_variant_new_printf(gchar *format_string  , ...) ;
#line 108
extern GVariant *g_variant_new_object_path(gchar *object_path ) ;
#line 110
extern gboolean g_variant_is_object_path(gchar *string ) ;
#line 112
extern GVariant *g_variant_new_signature(gchar *signature ) ;
#line 114
extern gboolean g_variant_is_signature(gchar *string ) ;
#line 116
extern GVariant *g_variant_new_variant(GVariant *value ) ;
#line 118
extern GVariant *g_variant_new_strv(gchar * const  *strv , gssize length ) ;
#line 121
extern GVariant *g_variant_new_objv(gchar * const  *strv , gssize length ) ;
#line 124
extern GVariant *g_variant_new_bytestring(gchar *string ) ;
#line 126
extern GVariant *g_variant_new_bytestring_array(gchar * const  *strv , gssize length ) ;
#line 129
extern GVariant *g_variant_new_fixed_array(GVariantType *element_type , gconstpointer elements ,
                                           gsize n_elements , gsize element_size ) ;
#line 134
extern gboolean g_variant_get_boolean(GVariant *value ) ;
#line 136
extern guint8 g_variant_get_byte(GVariant *value ) ;
#line 138
extern gint16 g_variant_get_int16(GVariant *value ) ;
#line 140
extern guint16 g_variant_get_uint16(GVariant *value ) ;
#line 142
extern gint32 g_variant_get_int32(GVariant *value ) ;
#line 144
extern guint32 g_variant_get_uint32(GVariant *value ) ;
#line 146
extern gint64 g_variant_get_int64(GVariant *value ) ;
#line 148
extern guint64 g_variant_get_uint64(GVariant *value ) ;
#line 150
extern gint32 g_variant_get_handle(GVariant *value ) ;
#line 152
extern gdouble g_variant_get_double(GVariant *value ) ;
#line 154
extern GVariant *g_variant_get_variant(GVariant *value ) ;
#line 156
extern gchar *g_variant_get_string(GVariant *value , gsize *length ) ;
#line 159
extern gchar *g_variant_dup_string(GVariant *value , gsize *length ) ;
#line 162
extern gchar **g_variant_get_strv(GVariant *value , gsize *length ) ;
#line 165
extern gchar **g_variant_dup_strv(GVariant *value , gsize *length ) ;
#line 168
extern gchar **g_variant_get_objv(GVariant *value , gsize *length ) ;
#line 171
extern gchar **g_variant_dup_objv(GVariant *value , gsize *length ) ;
#line 174
extern gchar *g_variant_get_bytestring(GVariant *value ) ;
#line 176
extern gchar *g_variant_dup_bytestring(GVariant *value , gsize *length ) ;
#line 179
extern gchar **g_variant_get_bytestring_array(GVariant *value , gsize *length ) ;
#line 182
extern gchar **g_variant_dup_bytestring_array(GVariant *value , gsize *length ) ;
#line 186
extern GVariant *g_variant_new_maybe(GVariantType *child_type , GVariant *child ) ;
#line 189
extern GVariant *g_variant_new_array(GVariantType *child_type , GVariant * const  *children ,
                                     gsize n_children ) ;
#line 193
extern GVariant *g_variant_new_tuple(GVariant * const  *children , gsize n_children ) ;
#line 196
extern GVariant *g_variant_new_dict_entry(GVariant *key , GVariant *value ) ;
#line 200
extern GVariant *g_variant_get_maybe(GVariant *value ) ;
#line 202
extern gsize g_variant_n_children(GVariant *value ) ;
#line 204
extern void g_variant_get_child(GVariant *value , gsize index_ , gchar *format_string 
                                , ...) ;
#line 209
extern GVariant *g_variant_get_child_value(GVariant *value , gsize index_ ) ;
#line 212
extern gboolean g_variant_lookup(GVariant *dictionary , gchar *key , gchar *format_string 
                                 , ...) ;
#line 217
extern GVariant *g_variant_lookup_value(GVariant *dictionary , gchar *key , GVariantType *expected_type ) ;
#line 221
extern gconstpointer g_variant_get_fixed_array(GVariant *value , gsize *n_elements ,
                                               gsize element_size ) ;
#line 226
extern gsize g_variant_get_size(GVariant *value ) ;
#line 228
extern gconstpointer g_variant_get_data(GVariant *value ) ;
#line 230
extern GBytes *g_variant_get_data_as_bytes(GVariant *value ) ;
#line 232
extern void g_variant_store(GVariant *value , gpointer data ) ;
#line 236
extern gchar *g_variant_print(GVariant *value , gboolean type_annotate ) ;
#line 239
extern GString *g_variant_print_string(GVariant *value , GString *string , gboolean type_annotate ) ;
#line 244
extern guint g_variant_hash(gconstpointer value ) ;
#line 246
extern gboolean g_variant_equal(gconstpointer one , gconstpointer two ) ;
#line 250
extern GVariant *g_variant_get_normal_form(GVariant *value ) ;
#line 252
extern gboolean g_variant_is_normal_form(GVariant *value ) ;
#line 254
extern GVariant *g_variant_byteswap(GVariant *value ) ;
#line 257
extern GVariant *g_variant_new_from_bytes(GVariantType *type , GBytes *bytes , gboolean trusted ) ;
#line 261
extern GVariant *g_variant_new_from_data(GVariantType *type , gconstpointer data ,
                                         gsize size , gboolean trusted , GDestroyNotify notify ,
                                         gpointer user_data ) ;
#line 275
extern GVariantIter *g_variant_iter_new(GVariant *value ) ;
#line 277
extern gsize g_variant_iter_init(GVariantIter *iter , GVariant *value ) ;
#line 280
extern GVariantIter *g_variant_iter_copy(GVariantIter *iter ) ;
#line 282
extern gsize g_variant_iter_n_children(GVariantIter *iter ) ;
#line 284
extern void g_variant_iter_free(GVariantIter *iter ) ;
#line 286
extern GVariant *g_variant_iter_next_value(GVariantIter *iter ) ;
#line 288
extern gboolean g_variant_iter_next(GVariantIter *iter , gchar *format_string  , ...) ;
#line 292
extern gboolean g_variant_iter_loop(GVariantIter *iter , gchar *format_string  , ...) ;
#line 336
extern GQuark g_variant_parser_get_error_quark(void) ;
#line 339
extern GQuark g_variant_parse_error_quark(void) ;
#line 375
extern GVariantBuilder *g_variant_builder_new(GVariantType *type ) ;
#line 377
extern void g_variant_builder_unref(GVariantBuilder *builder ) ;
#line 379
extern GVariantBuilder *g_variant_builder_ref(GVariantBuilder *builder ) ;
#line 381
extern void g_variant_builder_init(GVariantBuilder *builder , GVariantType *type ) ;
#line 384
extern GVariant *g_variant_builder_end(GVariantBuilder *builder ) ;
#line 386
extern void g_variant_builder_clear(GVariantBuilder *builder ) ;
#line 388
extern void g_variant_builder_open(GVariantBuilder *builder , GVariantType *type ) ;
#line 391
extern void g_variant_builder_close(GVariantBuilder *builder ) ;
#line 393
extern void g_variant_builder_add_value(GVariantBuilder *builder , GVariant *value ) ;
#line 396
extern void g_variant_builder_add(GVariantBuilder *builder , gchar *format_string 
                                  , ...) ;
#line 400
extern void g_variant_builder_add_parsed(GVariantBuilder *builder , gchar *format 
                                         , ...) ;
#line 405
extern GVariant *g_variant_new(gchar *format_string  , ...) ;
#line 408
extern void g_variant_get(GVariant *value , gchar *format_string  , ...) ;
#line 412
extern GVariant *g_variant_new_va(gchar *format_string , gchar **endptr , va_list *app ) ;
#line 416
extern void g_variant_get_va(GVariant *value , gchar *format_string , gchar **endptr ,
                             va_list *app ) ;
#line 421
extern gboolean g_variant_check_format_string(GVariant *value , gchar *format_string ,
                                              gboolean copy_only ) ;
#line 426
extern GVariant *g_variant_parse(GVariantType *type , gchar *text , gchar *limit ,
                                 gchar **endptr , GError **error ) ;
#line 432
extern GVariant *g_variant_new_parsed(gchar *format  , ...) ;
#line 435
extern GVariant *g_variant_new_parsed_va(gchar *format , va_list *app ) ;
#line 439
extern gchar *g_variant_parse_error_print_context(GError *error , gchar *source_str ) ;
#line 443
extern gint g_variant_compare(gconstpointer one , gconstpointer two ) ;
#line 498
extern GVariantDict *g_variant_dict_new(GVariant *from_asv ) ;
#line 501
extern void g_variant_dict_init(GVariantDict *dict , GVariant *from_asv ) ;
#line 505
extern gboolean g_variant_dict_lookup(GVariantDict *dict , gchar *key , gchar *format_string 
                                      , ...) ;
#line 510
extern GVariant *g_variant_dict_lookup_value(GVariantDict *dict , gchar *key , GVariantType *expected_type ) ;
#line 514
extern gboolean g_variant_dict_contains(GVariantDict *dict , gchar *key ) ;
#line 517
extern void g_variant_dict_insert(GVariantDict *dict , gchar *key , gchar *format_string 
                                  , ...) ;
#line 522
extern void g_variant_dict_insert_value(GVariantDict *dict , gchar *key , GVariant *value ) ;
#line 526
extern gboolean g_variant_dict_remove(GVariantDict *dict , gchar *key ) ;
#line 529
extern void g_variant_dict_clear(GVariantDict *dict ) ;
#line 531
extern GVariant *g_variant_dict_end(GVariantDict *dict ) ;
#line 533
extern GVariantDict *g_variant_dict_ref(GVariantDict *dict ) ;
#line 535
extern void g_variant_dict_unref(GVariantDict *dict ) ;
#line 43 "/usr/include/glib-2.0/glib/gmessages.h"
extern gsize g_printf_string_upper_bound(gchar *format , va_list args ) ;
#line 81
extern guint g_log_set_handler(gchar *log_domain , GLogLevelFlags log_levels , GLogFunc log_func ,
                               gpointer user_data ) ;
#line 86
extern guint g_log_set_handler_full(gchar *log_domain , GLogLevelFlags log_levels ,
                                    GLogFunc log_func , gpointer user_data , GDestroyNotify destroy ) ;
#line 92
extern void g_log_remove_handler(gchar *log_domain , guint handler_id ) ;
#line 95
extern void g_log_default_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                                  gpointer unused_data ) ;
#line 100
extern GLogFunc g_log_set_default_handler(GLogFunc log_func , gpointer user_data ) ;
#line 103
extern void g_log(gchar *log_domain , GLogLevelFlags log_level , gchar *format  , ...) ;
#line 108
extern void g_logv(gchar *log_domain , GLogLevelFlags log_level , gchar *format ,
                   va_list args ) ;
#line 113
extern GLogLevelFlags g_log_set_fatal_mask(gchar *log_domain , GLogLevelFlags fatal_mask ) ;
#line 116
extern GLogLevelFlags g_log_set_always_fatal(GLogLevelFlags fatal_mask ) ;
#line 201
extern void g_log_structured(gchar *log_domain , GLogLevelFlags log_level  , ...) ;
#line 205
extern void g_log_structured_array(GLogLevelFlags log_level , GLogField *fields ,
                                   gsize n_fields ) ;
#line 210
extern void g_log_variant(gchar *log_domain , GLogLevelFlags log_level , GVariant *fields ) ;
#line 215
extern void g_log_set_writer_func(GLogWriterFunc func , gpointer user_data , GDestroyNotify user_data_free ) ;
#line 220
extern gboolean g_log_writer_supports_color(gint output_fd ) ;
#line 222
extern gboolean g_log_writer_is_journald(gint output_fd ) ;
#line 225
extern gchar *g_log_writer_format_fields(GLogLevelFlags log_level , GLogField *fields ,
                                         gsize n_fields , gboolean use_color ) ;
#line 231
extern GLogWriterOutput g_log_writer_journald(GLogLevelFlags log_level , GLogField *fields ,
                                              gsize n_fields , gpointer user_data ) ;
#line 236
extern GLogWriterOutput g_log_writer_standard_streams(GLogLevelFlags log_level , GLogField *fields ,
                                                      gsize n_fields , gpointer user_data ) ;
#line 241
extern GLogWriterOutput g_log_writer_default(GLogLevelFlags log_level , GLogField *fields ,
                                             gsize n_fields , gpointer user_data ) ;
#line 247
extern void g_log_writer_default_set_use_stderr(gboolean use_stderr ) ;
#line 249
extern gboolean g_log_writer_default_would_drop(GLogLevelFlags log_level , char const   *log_domain ) ;
#line 254
extern gboolean g_log_get_debug_enabled(void) ;
#line 256
extern void g_log_set_debug_enabled(gboolean enabled ) ;
#line 276
void _g_log_fallback_handler(gchar *log_domain , GLogLevelFlags log_level , gchar *message ,
                             gpointer unused_data ) ;
#line 283
extern void g_return_if_fail_warning(char const   *log_domain , char const   *pretty_function ,
                                     char const   *expression ) ;
#line 287
extern void g_warn_message(char const   *domain , char const   *file , int line ,
                           char const   *func , char const   *warnexpr ) ;
#line 294
extern void g_assert_warning(char const   *log_domain , char const   *file , int const   line ,
                             char const   *pretty_function , char const   *expression ) ;
#line 301
extern void g_log_structured_standard(gchar *log_domain , GLogLevelFlags log_level ,
                                      gchar *file , gchar *line , gchar *func , gchar *message_format 
                                      , ...) ;
#line 517
extern void g_print(gchar *format  , ...) ;
#line 520
extern GPrintFunc g_set_print_handler(GPrintFunc func ) ;
#line 522
extern void g_printerr(gchar *format  , ...) ;
#line 525
extern GPrintFunc g_set_printerr_handler(GPrintFunc func ) ;
#line 214 "/usr/include/glib-2.0/glib/goption.h"
extern GQuark g_option_error_quark(void) ;
#line 308
extern GOptionContext *g_option_context_new(gchar *parameter_string ) ;
#line 310
extern void g_option_context_set_summary(GOptionContext *context , gchar *summary ) ;
#line 313
extern gchar *g_option_context_get_summary(GOptionContext *context ) ;
#line 315
extern void g_option_context_set_description(GOptionContext *context , gchar *description ) ;
#line 318
extern gchar *g_option_context_get_description(GOptionContext *context ) ;
#line 320
extern void g_option_context_free(GOptionContext *context ) ;
#line 322
extern void g_option_context_set_help_enabled(GOptionContext *context , gboolean help_enabled ) ;
#line 325
extern gboolean g_option_context_get_help_enabled(GOptionContext *context ) ;
#line 327
extern void g_option_context_set_ignore_unknown_options(GOptionContext *context ,
                                                        gboolean ignore_unknown ) ;
#line 330
extern gboolean g_option_context_get_ignore_unknown_options(GOptionContext *context ) ;
#line 333
extern void g_option_context_set_strict_posix(GOptionContext *context , gboolean strict_posix ) ;
#line 336
extern gboolean g_option_context_get_strict_posix(GOptionContext *context ) ;
#line 339
extern void g_option_context_add_main_entries(GOptionContext *context , GOptionEntry *entries ,
                                              gchar *translation_domain ) ;
#line 343
extern gboolean g_option_context_parse(GOptionContext *context , gint *argc , gchar ***argv ,
                                       GError **error ) ;
#line 348
extern gboolean g_option_context_parse_strv(GOptionContext *context , gchar ***arguments ,
                                            GError **error ) ;
#line 352
extern void g_option_context_set_translate_func(GOptionContext *context , GTranslateFunc func ,
                                                gpointer data , GDestroyNotify destroy_notify ) ;
#line 357
extern void g_option_context_set_translation_domain(GOptionContext *context , gchar *domain ) ;
#line 361
extern void g_option_context_add_group(GOptionContext *context , GOptionGroup *group ) ;
#line 364
extern void g_option_context_set_main_group(GOptionContext *context , GOptionGroup *group ) ;
#line 367
extern GOptionGroup *g_option_context_get_main_group(GOptionContext *context ) ;
#line 369
extern gchar *g_option_context_get_help(GOptionContext *context , gboolean main_help ,
                                        GOptionGroup *group ) ;
#line 374
extern GOptionGroup *g_option_group_new(gchar *name , gchar *description , gchar *help_description ,
                                        gpointer user_data , GDestroyNotify destroy ) ;
#line 380
extern void g_option_group_set_parse_hooks(GOptionGroup *group , GOptionParseFunc pre_parse_func ,
                                           GOptionParseFunc post_parse_func ) ;
#line 384
extern void g_option_group_set_error_hook(GOptionGroup *group , GOptionErrorFunc error_func ) ;
#line 387
extern void g_option_group_free(GOptionGroup *group ) ;
#line 389
extern GOptionGroup *g_option_group_ref(GOptionGroup *group ) ;
#line 391
extern void g_option_group_unref(GOptionGroup *group ) ;
#line 393
extern void g_option_group_add_entries(GOptionGroup *group , GOptionEntry *entries ) ;
#line 396
extern void g_option_group_set_translate_func(GOptionGroup *group , GTranslateFunc func ,
                                              gpointer data , GDestroyNotify destroy_notify ) ;
#line 401
extern void g_option_group_set_translation_domain(GOptionGroup *group , gchar *domain ) ;
#line 33 "/usr/include/glib-2.0/glib/gpattern.h"
extern GPatternSpec *g_pattern_spec_new(gchar *pattern ) ;
#line 35
extern void g_pattern_spec_free(GPatternSpec *pspec ) ;
#line 37
extern GPatternSpec *g_pattern_spec_copy(GPatternSpec *pspec ) ;
#line 39
extern gboolean g_pattern_spec_equal(GPatternSpec *pspec1 , GPatternSpec *pspec2 ) ;
#line 42
extern gboolean g_pattern_spec_match(GPatternSpec *pspec , gsize string_length , gchar *string ,
                                     gchar *string_reversed ) ;
#line 47
extern gboolean g_pattern_spec_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 50
extern gboolean g_pattern_match(GPatternSpec *pspec , guint string_length , gchar *string ,
                                gchar *string_reversed ) ;
#line 55
extern gboolean g_pattern_match_string(GPatternSpec *pspec , gchar *string ) ;
#line 58
extern gboolean g_pattern_match_simple(gchar *pattern , gchar *string ) ;
#line 46 "/usr/include/glib-2.0/glib/gprimes.h"
extern guint g_spaced_primes_closest(guint num ) ;
#line 37 "/usr/include/glib-2.0/glib/gqsort.h"
extern void g_qsort_with_data(gconstpointer pbase , gint total_elems , gsize size ,
                              GCompareDataFunc compare_func , gpointer user_data ) ;
#line 73 "/usr/include/glib-2.0/glib/gqueue.h"
extern GQueue *g_queue_new(void) ;
#line 75
extern void g_queue_free(GQueue *queue ) ;
#line 77
extern void g_queue_free_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 80
extern void g_queue_init(GQueue *queue ) ;
#line 82
extern void g_queue_clear(GQueue *queue ) ;
#line 84
extern gboolean g_queue_is_empty(GQueue *queue ) ;
#line 86
extern void g_queue_clear_full(GQueue *queue , GDestroyNotify free_func ) ;
#line 89
extern guint g_queue_get_length(GQueue *queue ) ;
#line 91
extern void g_queue_reverse(GQueue *queue ) ;
#line 93
extern GQueue *g_queue_copy(GQueue *queue ) ;
#line 95
extern void g_queue_foreach(GQueue *queue , GFunc func , gpointer user_data ) ;
#line 99
extern GList *g_queue_find(GQueue *queue , gconstpointer data ) ;
#line 102
extern GList *g_queue_find_custom(GQueue *queue , gconstpointer data , GCompareFunc func ) ;
#line 106
extern void g_queue_sort(GQueue *queue , GCompareDataFunc compare_func , gpointer user_data ) ;
#line 111
extern void g_queue_push_head(GQueue *queue , gpointer data ) ;
#line 114
extern void g_queue_push_tail(GQueue *queue , gpointer data ) ;
#line 117
extern void g_queue_push_nth(GQueue *queue , gpointer data , gint n ) ;
#line 121
extern gpointer g_queue_pop_head(GQueue *queue ) ;
#line 123
extern gpointer g_queue_pop_tail(GQueue *queue ) ;
#line 125
extern gpointer g_queue_pop_nth(GQueue *queue , guint n ) ;
#line 128
extern gpointer g_queue_peek_head(GQueue *queue ) ;
#line 130
extern gpointer g_queue_peek_tail(GQueue *queue ) ;
#line 132
extern gpointer g_queue_peek_nth(GQueue *queue , guint n ) ;
#line 135
extern gint g_queue_index(GQueue *queue , gconstpointer data ) ;
#line 138
extern gboolean g_queue_remove(GQueue *queue , gconstpointer data ) ;
#line 141
extern guint g_queue_remove_all(GQueue *queue , gconstpointer data ) ;
#line 144
extern void g_queue_insert_before(GQueue *queue , GList *sibling , gpointer data ) ;
#line 148
extern void g_queue_insert_before_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 153
extern void g_queue_insert_after(GQueue *queue , GList *sibling , gpointer data ) ;
#line 157
extern void g_queue_insert_after_link(GQueue *queue , GList *sibling , GList *link_ ) ;
#line 162
extern void g_queue_insert_sorted(GQueue *queue , gpointer data , GCompareDataFunc func ,
                                  gpointer user_data ) ;
#line 168
extern void g_queue_push_head_link(GQueue *queue , GList *link_ ) ;
#line 171
extern void g_queue_push_tail_link(GQueue *queue , GList *link_ ) ;
#line 174
extern void g_queue_push_nth_link(GQueue *queue , gint n , GList *link_ ) ;
#line 178
extern GList *g_queue_pop_head_link(GQueue *queue ) ;
#line 180
extern GList *g_queue_pop_tail_link(GQueue *queue ) ;
#line 182
extern GList *g_queue_pop_nth_link(GQueue *queue , guint n ) ;
#line 185
extern GList *g_queue_peek_head_link(GQueue *queue ) ;
#line 187
extern GList *g_queue_peek_tail_link(GQueue *queue ) ;
#line 189
extern GList *g_queue_peek_nth_link(GQueue *queue , guint n ) ;
#line 192
extern gint g_queue_link_index(GQueue *queue , GList *link_ ) ;
#line 195
extern void g_queue_unlink(GQueue *queue , GList *link_ ) ;
#line 198
extern void g_queue_delete_link(GQueue *queue , GList *link_ ) ;
#line 48 "/usr/include/glib-2.0/glib/grand.h"
extern GRand *g_rand_new_with_seed(guint32 seed ) ;
#line 50
extern GRand *g_rand_new_with_seed_array(guint32 *seed , guint seed_length ) ;
#line 53
extern GRand *g_rand_new(void) ;
#line 55
extern void g_rand_free(GRand *rand_ ) ;
#line 57
extern GRand *g_rand_copy(GRand *rand_ ) ;
#line 59
extern void g_rand_set_seed(GRand *rand_ , guint32 seed ) ;
#line 62
extern void g_rand_set_seed_array(GRand *rand_ , guint32 *seed , guint seed_length ) ;
#line 69
extern guint32 g_rand_int(GRand *rand_ ) ;
#line 71
extern gint32 g_rand_int_range(GRand *rand_ , gint32 begin , gint32 end ) ;
#line 75
extern gdouble g_rand_double(GRand *rand_ ) ;
#line 77
extern gdouble g_rand_double_range(GRand *rand_ , gdouble begin , gdouble end ) ;
#line 81
extern void g_random_set_seed(guint32 seed ) ;
#line 86
extern guint32 g_random_int(void) ;
#line 88
extern gint32 g_random_int_range(gint32 begin , gint32 end ) ;
#line 91
extern gdouble g_random_double(void) ;
#line 93
extern gdouble g_random_double_range(gdouble begin , gdouble end ) ;
#line 31 "/usr/include/glib-2.0/glib/grcbox.h"
extern gpointer g_rc_box_alloc(gsize block_size ) ;
#line 33
extern gpointer g_rc_box_alloc0(gsize block_size ) ;
#line 35
extern gpointer g_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 38
extern gpointer g_rc_box_acquire(gpointer mem_block ) ;
#line 40
extern void g_rc_box_release(gpointer mem_block ) ;
#line 42
extern void g_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 46
extern gsize g_rc_box_get_size(gpointer mem_block ) ;
#line 49
extern gpointer g_atomic_rc_box_alloc(gsize block_size ) ;
#line 51
extern gpointer g_atomic_rc_box_alloc0(gsize block_size ) ;
#line 53
extern gpointer g_atomic_rc_box_dup(gsize block_size , gconstpointer mem_block ) ;
#line 56
extern gpointer g_atomic_rc_box_acquire(gpointer mem_block ) ;
#line 58
extern void g_atomic_rc_box_release(gpointer mem_block ) ;
#line 60
extern void g_atomic_rc_box_release_full(gpointer mem_block , GDestroyNotify clear_func ) ;
#line 64
extern gsize g_atomic_rc_box_get_size(gpointer mem_block ) ;
#line 32 "/usr/include/glib-2.0/glib/grefcount.h"
extern void g_ref_count_init(grefcount *rc ) ;
#line 34
extern void g_ref_count_inc(grefcount *rc ) ;
#line 36
extern gboolean g_ref_count_dec(grefcount *rc ) ;
#line 38
extern gboolean g_ref_count_compare(grefcount *rc , gint val ) ;
#line 42
extern void g_atomic_ref_count_init(gatomicrefcount *arc ) ;
#line 44
extern void g_atomic_ref_count_inc(gatomicrefcount *arc ) ;
#line 46
extern gboolean g_atomic_ref_count_dec(gatomicrefcount *arc ) ;
#line 48
extern gboolean g_atomic_ref_count_compare(gatomicrefcount *arc , gint val ) ;
#line 27 "/usr/include/glib-2.0/glib/grefstring.h"
extern char *g_ref_string_new(char const   *str ) ;
#line 29
extern char *g_ref_string_new_len(char const   *str , gssize len ) ;
#line 32
extern char *g_ref_string_new_intern(char const   *str ) ;
#line 35
extern char *g_ref_string_acquire(char *str ) ;
#line 37
extern void g_ref_string_release(char *str ) ;
#line 40
extern gsize g_ref_string_length(char *str ) ;
#line 215 "/usr/include/glib-2.0/glib/gregex.h"
extern GQuark g_regex_error_quark(void) ;
#line 447
extern GRegex *g_regex_new(gchar *pattern , GRegexCompileFlags compile_options , GRegexMatchFlags match_options ,
                           GError **error ) ;
#line 452
extern GRegex *g_regex_ref(GRegex *regex ) ;
#line 454
extern void g_regex_unref(GRegex *regex ) ;
#line 456
extern gchar *g_regex_get_pattern(GRegex *regex ) ;
#line 458
extern gint g_regex_get_max_backref(GRegex *regex ) ;
#line 460
extern gint g_regex_get_capture_count(GRegex *regex ) ;
#line 462
extern gboolean g_regex_get_has_cr_or_lf(GRegex *regex ) ;
#line 464
extern gint g_regex_get_max_lookbehind(GRegex *regex ) ;
#line 466
extern gint g_regex_get_string_number(GRegex *regex , gchar *name ) ;
#line 469
extern gchar *g_regex_escape_string(gchar *string , gint length ) ;
#line 472
extern gchar *g_regex_escape_nul(gchar *string , gint length ) ;
#line 476
extern GRegexCompileFlags g_regex_get_compile_flags(GRegex *regex ) ;
#line 478
extern GRegexMatchFlags g_regex_get_match_flags(GRegex *regex ) ;
#line 482
extern gboolean g_regex_match_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                     GRegexMatchFlags match_options ) ;
#line 487
extern gboolean g_regex_match(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                              GMatchInfo **match_info ) ;
#line 492
extern gboolean g_regex_match_full(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GMatchInfo **match_info , GError **error ) ;
#line 500
extern gboolean g_regex_match_all(GRegex *regex , gchar *string , GRegexMatchFlags match_options ,
                                  GMatchInfo **match_info ) ;
#line 505
extern gboolean g_regex_match_all_full(GRegex *regex , gchar *string , gssize string_len ,
                                       gint start_position , GRegexMatchFlags match_options ,
                                       GMatchInfo **match_info , GError **error ) ;
#line 515
extern gchar **g_regex_split_simple(gchar *pattern , gchar *string , GRegexCompileFlags compile_options ,
                                    GRegexMatchFlags match_options ) ;
#line 520
extern gchar **g_regex_split(GRegex *regex , gchar *string , GRegexMatchFlags match_options ) ;
#line 524
extern gchar **g_regex_split_full(GRegex *regex , gchar *string , gssize string_len ,
                                  gint start_position , GRegexMatchFlags match_options ,
                                  gint max_tokens , GError **error ) ;
#line 534
extern gchar *g_regex_replace(GRegex *regex , gchar *string , gssize string_len ,
                              gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                              GError **error ) ;
#line 542
extern gchar *g_regex_replace_literal(GRegex *regex , gchar *string , gssize string_len ,
                                      gint start_position , gchar *replacement , GRegexMatchFlags match_options ,
                                      GError **error ) ;
#line 550
extern gchar *g_regex_replace_eval(GRegex *regex , gchar *string , gssize string_len ,
                                   gint start_position , GRegexMatchFlags match_options ,
                                   GRegexEvalCallback eval , gpointer user_data ,
                                   GError **error ) ;
#line 559
extern gboolean g_regex_check_replacement(gchar *replacement , gboolean *has_references ,
                                          GError **error ) ;
#line 565
extern GRegex *g_match_info_get_regex(GMatchInfo *match_info ) ;
#line 567
extern gchar *g_match_info_get_string(GMatchInfo *match_info ) ;
#line 570
extern GMatchInfo *g_match_info_ref(GMatchInfo *match_info ) ;
#line 572
extern void g_match_info_unref(GMatchInfo *match_info ) ;
#line 574
extern void g_match_info_free(GMatchInfo *match_info ) ;
#line 576
extern gboolean g_match_info_next(GMatchInfo *match_info , GError **error ) ;
#line 579
extern gboolean g_match_info_matches(GMatchInfo *match_info ) ;
#line 581
extern gint g_match_info_get_match_count(GMatchInfo *match_info ) ;
#line 583
extern gboolean g_match_info_is_partial_match(GMatchInfo *match_info ) ;
#line 585
extern gchar *g_match_info_expand_references(GMatchInfo *match_info , gchar *string_to_expand ,
                                             GError **error ) ;
#line 589
extern gchar *g_match_info_fetch(GMatchInfo *match_info , gint match_num ) ;
#line 592
extern gboolean g_match_info_fetch_pos(GMatchInfo *match_info , gint match_num , gint *start_pos ,
                                       gint *end_pos ) ;
#line 597
extern gchar *g_match_info_fetch_named(GMatchInfo *match_info , gchar *name ) ;
#line 600
extern gboolean g_match_info_fetch_named_pos(GMatchInfo *match_info , gchar *name ,
                                             gint *start_pos , gint *end_pos ) ;
#line 605
extern gchar **g_match_info_fetch_all(GMatchInfo *match_info ) ;
#line 214 "/usr/include/glib-2.0/glib/gscanner.h"
extern GScanner *g_scanner_new(GScannerConfig *config_templ ) ;
#line 216
extern void g_scanner_destroy(GScanner *scanner ) ;
#line 218
extern void g_scanner_input_file(GScanner *scanner , gint input_fd ) ;
#line 221
extern void g_scanner_sync_file_offset(GScanner *scanner ) ;
#line 223
extern void g_scanner_input_text(GScanner *scanner , gchar *text , guint text_len ) ;
#line 227
extern GTokenType g_scanner_get_next_token(GScanner *scanner ) ;
#line 229
extern GTokenType g_scanner_peek_next_token(GScanner *scanner ) ;
#line 231
extern GTokenType g_scanner_cur_token(GScanner *scanner ) ;
#line 233
extern GTokenValue g_scanner_cur_value(GScanner *scanner ) ;
#line 235
extern guint g_scanner_cur_line(GScanner *scanner ) ;
#line 237
extern guint g_scanner_cur_position(GScanner *scanner ) ;
#line 239
extern gboolean g_scanner_eof(GScanner *scanner ) ;
#line 241
extern guint g_scanner_set_scope(GScanner *scanner , guint scope_id ) ;
#line 244
extern void g_scanner_scope_add_symbol(GScanner *scanner , guint scope_id , gchar *symbol ,
                                       gpointer value ) ;
#line 249
extern void g_scanner_scope_remove_symbol(GScanner *scanner , guint scope_id , gchar *symbol ) ;
#line 253
extern gpointer g_scanner_scope_lookup_symbol(GScanner *scanner , guint scope_id ,
                                              gchar *symbol ) ;
#line 257
extern void g_scanner_scope_foreach_symbol(GScanner *scanner , guint scope_id , GHFunc func ,
                                           gpointer user_data ) ;
#line 262
extern gpointer g_scanner_lookup_symbol(GScanner *scanner , gchar *symbol ) ;
#line 265
extern void g_scanner_unexp_token(GScanner *scanner , GTokenType expected_token ,
                                  gchar *identifier_spec , gchar *symbol_spec , gchar *symbol_name ,
                                  gchar *message , gint is_error ) ;
#line 273
extern void g_scanner_error(GScanner *scanner , gchar *format  , ...) ;
#line 277
extern void g_scanner_warn(GScanner *scanner , gchar *format  , ...) ;
#line 40 "/usr/include/glib-2.0/glib/gsequence.h"
extern GSequence *g_sequence_new(GDestroyNotify data_destroy ) ;
#line 42
extern void g_sequence_free(GSequence *seq ) ;
#line 44
extern gint g_sequence_get_length(GSequence *seq ) ;
#line 46
extern void g_sequence_foreach(GSequence *seq , GFunc func , gpointer user_data ) ;
#line 50
extern void g_sequence_foreach_range(GSequenceIter *begin , GSequenceIter *end , GFunc func ,
                                     gpointer user_data ) ;
#line 55
extern void g_sequence_sort(GSequence *seq , GCompareDataFunc cmp_func , gpointer cmp_data ) ;
#line 59
extern void g_sequence_sort_iter(GSequence *seq , GSequenceIterCompareFunc cmp_func ,
                                 gpointer cmp_data ) ;
#line 63
extern gboolean g_sequence_is_empty(GSequence *seq ) ;
#line 68
extern GSequenceIter *g_sequence_get_begin_iter(GSequence *seq ) ;
#line 70
extern GSequenceIter *g_sequence_get_end_iter(GSequence *seq ) ;
#line 72
extern GSequenceIter *g_sequence_get_iter_at_pos(GSequence *seq , gint pos ) ;
#line 75
extern GSequenceIter *g_sequence_append(GSequence *seq , gpointer data ) ;
#line 78
extern GSequenceIter *g_sequence_prepend(GSequence *seq , gpointer data ) ;
#line 81
extern GSequenceIter *g_sequence_insert_before(GSequenceIter *iter , gpointer data ) ;
#line 84
extern void g_sequence_move(GSequenceIter *src , GSequenceIter *dest ) ;
#line 87
extern void g_sequence_swap(GSequenceIter *a , GSequenceIter *b ) ;
#line 90
extern GSequenceIter *g_sequence_insert_sorted(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                               gpointer cmp_data ) ;
#line 95
extern GSequenceIter *g_sequence_insert_sorted_iter(GSequence *seq , gpointer data ,
                                                    GSequenceIterCompareFunc iter_cmp ,
                                                    gpointer cmp_data ) ;
#line 100
extern void g_sequence_sort_changed(GSequenceIter *iter , GCompareDataFunc cmp_func ,
                                    gpointer cmp_data ) ;
#line 104
extern void g_sequence_sort_changed_iter(GSequenceIter *iter , GSequenceIterCompareFunc iter_cmp ,
                                         gpointer cmp_data ) ;
#line 108
extern void g_sequence_remove(GSequenceIter *iter ) ;
#line 110
extern void g_sequence_remove_range(GSequenceIter *begin , GSequenceIter *end ) ;
#line 113
extern void g_sequence_move_range(GSequenceIter *dest , GSequenceIter *begin , GSequenceIter *end ) ;
#line 117
extern GSequenceIter *g_sequence_search(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 122
extern GSequenceIter *g_sequence_search_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 127
extern GSequenceIter *g_sequence_lookup(GSequence *seq , gpointer data , GCompareDataFunc cmp_func ,
                                        gpointer cmp_data ) ;
#line 132
extern GSequenceIter *g_sequence_lookup_iter(GSequence *seq , gpointer data , GSequenceIterCompareFunc iter_cmp ,
                                             gpointer cmp_data ) ;
#line 140
extern gpointer g_sequence_get(GSequenceIter *iter ) ;
#line 142
extern void g_sequence_set(GSequenceIter *iter , gpointer data ) ;
#line 147
extern gboolean g_sequence_iter_is_begin(GSequenceIter *iter ) ;
#line 149
extern gboolean g_sequence_iter_is_end(GSequenceIter *iter ) ;
#line 151
extern GSequenceIter *g_sequence_iter_next(GSequenceIter *iter ) ;
#line 153
extern GSequenceIter *g_sequence_iter_prev(GSequenceIter *iter ) ;
#line 155
extern gint g_sequence_iter_get_position(GSequenceIter *iter ) ;
#line 157
extern GSequenceIter *g_sequence_iter_move(GSequenceIter *iter , gint delta ) ;
#line 160
extern GSequence *g_sequence_iter_get_sequence(GSequenceIter *iter ) ;
#line 165
extern gint g_sequence_iter_compare(GSequenceIter *a , GSequenceIter *b ) ;
#line 168
extern GSequenceIter *g_sequence_range_get_midpoint(GSequenceIter *begin , GSequenceIter *end ) ;
#line 42 "/usr/include/glib-2.0/glib/gshell.h"
extern GQuark g_shell_error_quark(void) ;
#line 45
extern gchar *g_shell_quote(gchar *unquoted_string ) ;
#line 47
extern gchar *g_shell_unquote(gchar *quoted_string , GError **error ) ;
#line 50
extern gboolean g_shell_parse_argv(gchar *command_line , gint *argcp , gchar ***argvp ,
                                   GError **error ) ;
#line 33 "/usr/include/glib-2.0/glib/gslice.h"
extern gpointer g_slice_alloc(gsize block_size ) ;
#line 35
extern gpointer g_slice_alloc0(gsize block_size ) ;
#line 37
extern gpointer g_slice_copy(gsize block_size , gconstpointer mem_block ) ;
#line 40
extern void g_slice_free1(gsize block_size , gpointer mem_block ) ;
#line 43
extern void g_slice_free_chain_with_offset(gsize block_size , gpointer mem_chain ,
                                           gsize next_offset ) ;
#line 102
extern void g_slice_set_config(GSliceConfig ckey , gint64 value ) ;
#line 104
extern gint64 g_slice_get_config(GSliceConfig ckey ) ;
#line 106
extern gint64 *g_slice_get_config_state(GSliceConfig ckey , gint64 address , guint *n_values ) ;
#line 185 "/usr/include/glib-2.0/glib/gspawn.h"
extern GQuark g_spawn_error_quark(void) ;
#line 187
extern GQuark g_spawn_exit_error_quark(void) ;
#line 190
extern gboolean g_spawn_async(gchar *working_directory , gchar **argv , gchar **envp ,
                              GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                              gpointer user_data , GPid *child_pid , GError **error ) ;
#line 204
extern gboolean g_spawn_async_with_pipes(gchar *working_directory , gchar **argv ,
                                         gchar **envp , GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                         gpointer user_data , GPid *child_pid , gint *standard_input ,
                                         gint *standard_output , gint *standard_error ,
                                         GError **error ) ;
#line 217
extern gboolean g_spawn_async_with_pipes_and_fds(gchar *working_directory , gchar * const  *argv ,
                                                 gchar * const  *envp , GSpawnFlags flags ,
                                                 GSpawnChildSetupFunc child_setup ,
                                                 gpointer user_data , gint stdin_fd ,
                                                 gint stdout_fd , gint stderr_fd ,
                                                 gint *source_fds , gint *target_fds ,
                                                 gsize n_fds , GPid *child_pid_out ,
                                                 gint *stdin_pipe_out , gint *stdout_pipe_out ,
                                                 gint *stderr_pipe_out , GError **error ) ;
#line 237
extern gboolean g_spawn_async_with_fds(gchar *working_directory , gchar **argv , gchar **envp ,
                                       GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                                       gpointer user_data , GPid *child_pid , gint stdin_fd ,
                                       gint stdout_fd , gint stderr_fd , GError **error ) ;
#line 254
extern gboolean g_spawn_sync(gchar *working_directory , gchar **argv , gchar **envp ,
                             GSpawnFlags flags , GSpawnChildSetupFunc child_setup ,
                             gpointer user_data , gchar **standard_output , gchar **standard_error ,
                             gint *wait_status , GError **error ) ;
#line 266
extern gboolean g_spawn_command_line_sync(gchar *command_line , gchar **standard_output ,
                                          gchar **standard_error , gint *wait_status ,
                                          GError **error ) ;
#line 272
extern gboolean g_spawn_command_line_async(gchar *command_line , GError **error ) ;
#line 276
extern gboolean g_spawn_check_wait_status(gint wait_status , GError **error ) ;
#line 280
extern gboolean g_spawn_check_exit_status(gint wait_status , GError **error ) ;
#line 284
extern void g_spawn_close_pid(GPid pid ) ;
#line 54 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern guint16 * const  g_ascii_table ;
#line 90
extern gchar g_ascii_tolower(gchar c ) ;
#line 92
extern gchar g_ascii_toupper(gchar c ) ;
#line 95
extern gint g_ascii_digit_value(gchar c ) ;
#line 97
extern gint g_ascii_xdigit_value(gchar c ) ;
#line 104
extern gchar *g_strdelimit(gchar *string , gchar *delimiters , gchar new_delimiter ) ;
#line 108
extern gchar *g_strcanon(gchar *string , gchar *valid_chars , gchar substitutor ) ;
#line 112
extern gchar *g_strerror(gint errnum ) ;
#line 114
extern gchar *g_strsignal(gint signum ) ;
#line 116
extern gchar *g_strreverse(gchar *string ) ;
#line 118
extern gsize g_strlcpy(gchar *dest , gchar *src , gsize dest_size ) ;
#line 122
extern gsize g_strlcat(gchar *dest , gchar *src , gsize dest_size ) ;
#line 126
extern gchar *g_strstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 130
extern gchar *g_strrstr(gchar *haystack , gchar *needle ) ;
#line 133
extern gchar *g_strrstr_len(gchar *haystack , gssize haystack_len , gchar *needle ) ;
#line 138
extern gboolean g_str_has_suffix(gchar *str , gchar *suffix ) ;
#line 141
extern gboolean g_str_has_prefix(gchar *str , gchar *prefix ) ;
#line 147
extern gdouble g_strtod(gchar *nptr , gchar **endptr ) ;
#line 150
extern gdouble g_ascii_strtod(gchar *nptr , gchar **endptr ) ;
#line 153
extern guint64 g_ascii_strtoull(gchar *nptr , gchar **endptr , guint base ) ;
#line 157
extern gint64 g_ascii_strtoll(gchar *nptr , gchar **endptr , guint base ) ;
#line 165
extern gchar *g_ascii_dtostr(gchar *buffer , gint buf_len , gdouble d ) ;
#line 169
extern gchar *g_ascii_formatd(gchar *buffer , gint buf_len , gchar *format , gdouble d ) ;
#line 176
extern gchar *g_strchug(gchar *string ) ;
#line 179
extern gchar *g_strchomp(gchar *string ) ;
#line 184
extern gint g_ascii_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 187
extern gint g_ascii_strncasecmp(gchar *s1 , gchar *s2 , gsize n ) ;
#line 191
extern gchar *g_ascii_strdown(gchar *str , gssize len ) ;
#line 194
extern gchar *g_ascii_strup(gchar *str , gssize len ) ;
#line 198
extern gboolean g_str_is_ascii(gchar *str ) ;
#line 201
extern gint g_strcasecmp(gchar *s1 , gchar *s2 ) ;
#line 204
extern gint g_strncasecmp(gchar *s1 , gchar *s2 , guint n ) ;
#line 208
extern gchar *g_strdown(gchar *string ) ;
#line 210
extern gchar *g_strup(gchar *string ) ;
#line 217
extern gchar *g_strdup(gchar *str ) ;
#line 219
extern gchar *g_strdup_printf(gchar *format  , ...) ;
#line 222
extern gchar *g_strdup_vprintf(gchar *format , va_list args ) ;
#line 225
extern gchar *g_strndup(gchar *str , gsize n ) ;
#line 228
extern gchar *g_strnfill(gsize length , gchar fill_char ) ;
#line 231
extern gchar *g_strconcat(gchar *string1  , ...) ;
#line 234
extern gchar *g_strjoin(gchar *separator  , ...) ;
#line 242
extern gchar *g_strcompress(gchar *source ) ;
#line 253
extern gchar *g_strescape(gchar *source , gchar *exceptions ) ;
#line 257
extern gpointer g_memdup(gconstpointer mem , guint byte_size ) ;
#line 261
extern gpointer g_memdup2(gconstpointer mem , gsize byte_size ) ;
#line 275
extern gchar **g_strsplit(gchar *string , gchar *delimiter , gint max_tokens ) ;
#line 279
extern gchar **g_strsplit_set(gchar *string , gchar *delimiters , gint max_tokens ) ;
#line 283
extern gchar *g_strjoinv(gchar *separator , gchar **str_array ) ;
#line 286
extern void g_strfreev(gchar **str_array ) ;
#line 288
extern gchar **g_strdupv(gchar **str_array ) ;
#line 290
extern guint g_strv_length(gchar **str_array ) ;
#line 293
extern gchar *g_stpcpy(gchar *dest , char const   *src ) ;
#line 297
extern gchar *g_str_to_ascii(gchar *str , gchar *from_locale ) ;
#line 301
extern gchar **g_str_tokenize_and_fold(gchar *string , gchar *translit_locale , gchar ***ascii_alternates ) ;
#line 306
extern gboolean g_str_match_string(gchar *search_term , gchar *potential_hit , gboolean accept_alternates ) ;
#line 311
extern gboolean g_strv_contains(gchar * const  *strv , gchar *str ) ;
#line 315
extern gboolean g_strv_equal(gchar * const  *strv1 , gchar * const  *strv2 ) ;
#line 346
extern GQuark g_number_parser_error_quark(void) ;
#line 349
extern gboolean g_ascii_string_to_signed(gchar *str , guint base , gint64 min , gint64 max ,
                                         gint64 *out_num , GError **error ) ;
#line 357
extern gboolean g_ascii_string_to_unsigned(gchar *str , guint base , guint64 min ,
                                           guint64 max , guint64 *out_num , GError **error ) ;
#line 39 "/usr/include/glib-2.0/glib/gstringchunk.h"
extern GStringChunk *g_string_chunk_new(gsize size ) ;
#line 41
extern void g_string_chunk_free(GStringChunk *chunk ) ;
#line 43
extern void g_string_chunk_clear(GStringChunk *chunk ) ;
#line 45
extern gchar *g_string_chunk_insert(GStringChunk *chunk , gchar *string ) ;
#line 48
extern gchar *g_string_chunk_insert_len(GStringChunk *chunk , gchar *string , gssize len ) ;
#line 52
extern gchar *g_string_chunk_insert_const(GStringChunk *chunk , gchar *string ) ;
#line 42 "/usr/include/glib-2.0/glib/gstrvbuilder.h"
extern GStrvBuilder *g_strv_builder_new(void) ;
#line 45
extern void g_strv_builder_unref(GStrvBuilder *builder ) ;
#line 48
extern GStrvBuilder *g_strv_builder_ref(GStrvBuilder *builder ) ;
#line 51
extern void g_strv_builder_add(GStrvBuilder *builder , char const   *value ) ;
#line 55
extern void g_strv_builder_addv(GStrvBuilder *builder , char const   **value ) ;
#line 59
extern void g_strv_builder_add_many(GStrvBuilder *builder  , ...) ;
#line 63
extern GStrv g_strv_builder_end(GStrvBuilder *builder ) ;
#line 239 "/usr/include/glib-2.0/glib/gtestutils.h"
extern int g_strcmp0(char const   *str1 , char const   *str2 ) ;
#line 244
extern void g_test_minimized_result(double minimized_quantity , char const   *format 
                                    , ...) ;
#line 248
extern void g_test_maximized_result(double maximized_quantity , char const   *format 
                                    , ...) ;
#line 254
extern void g_test_init(int *argc , char ***argv  , ...) ;
#line 321
extern gboolean g_test_subprocess(void) ;
#line 325
extern int g_test_run(void) ;
#line 328
extern void g_test_add_func(char const   *testpath , GTestFunc test_func ) ;
#line 332
extern void g_test_add_data_func(char const   *testpath , gconstpointer test_data ,
                                 GTestDataFunc test_func ) ;
#line 337
extern void g_test_add_data_func_full(char const   *testpath , gpointer test_data ,
                                      GTestDataFunc test_func , GDestroyNotify data_free_func ) ;
#line 344
extern char const   *g_test_get_path(void) ;
#line 348
extern void g_test_fail(void) ;
#line 350
extern void g_test_fail_printf(char const   *format  , ...) ;
#line 353
extern void g_test_incomplete(gchar *msg ) ;
#line 355
extern void g_test_incomplete_printf(char const   *format  , ...) ;
#line 358
extern void g_test_skip(gchar *msg ) ;
#line 360
extern void g_test_skip_printf(char const   *format  , ...) ;
#line 363
extern gboolean g_test_failed(void) ;
#line 365
extern void g_test_set_nonfatal_assertions(void) ;
#line 400
extern void g_test_message(char const   *format  , ...) ;
#line 403
extern void g_test_bug_base(char const   *uri_pattern ) ;
#line 405
extern void g_test_bug(char const   *bug_uri_snippet ) ;
#line 407
extern void g_test_summary(char const   *summary ) ;
#line 410
extern void g_test_timer_start(void) ;
#line 412
extern double g_test_timer_elapsed(void) ;
#line 414
extern double g_test_timer_last(void) ;
#line 418
extern void g_test_queue_free(gpointer gfree_pointer ) ;
#line 420
extern void g_test_queue_destroy(GDestroyNotify destroy_func , gpointer destroy_data ) ;
#line 454
extern gboolean g_test_trap_fork(guint64 usec_timeout , GTestTrapFlags test_trap_flags ) ;
#line 466
extern void g_test_trap_subprocess(char const   *test_path , guint64 usec_timeout ,
                                   GTestSubprocessFlags test_flags ) ;
#line 471
extern gboolean g_test_trap_has_passed(void) ;
#line 473
extern gboolean g_test_trap_reached_timeout(void) ;
#line 484
extern gint32 g_test_rand_int(void) ;
#line 486
extern gint32 g_test_rand_int_range(gint32 begin , gint32 end ) ;
#line 489
extern double g_test_rand_double(void) ;
#line 491
extern double g_test_rand_double_range(double range_start , double range_end ) ;
#line 500
extern GTestCase *g_test_create_case(char const   *test_name , gsize data_size , gconstpointer test_data ,
                                     GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                                     GTestFixtureFunc data_teardown ) ;
#line 507
extern GTestSuite *g_test_create_suite(char const   *suite_name ) ;
#line 509
extern GTestSuite *g_test_get_root(void) ;
#line 511
extern void g_test_suite_add(GTestSuite *suite , GTestCase *test_case ) ;
#line 514
extern void g_test_suite_add_suite(GTestSuite *suite , GTestSuite *nestedsuite ) ;
#line 517
extern int g_test_run_suite(GTestSuite *suite ) ;
#line 520
extern void g_test_case_free(GTestCase *test_case ) ;
#line 523
extern void g_test_suite_free(GTestSuite *suite ) ;
#line 526
extern void g_test_trap_assertions(char const   *domain , char const   *file , int line ,
                                   char const   *func , guint64 assertion_flags ,
                                   char const   *pattern ) ;
#line 533
extern void g_assertion_message(char const   *domain , char const   *file , int line ,
                                char const   *func , char const   *message ) ;
#line 540
extern void g_assertion_message_expr(char const   *domain , char const   *file , int line ,
                                     char const   *func , char const   *expr ) ;
#line 546
extern void g_assertion_message_cmpstr(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       char const   *arg1 , char const   *cmp , char const   *arg2 ) ;
#line 556
extern void g_assertion_message_cmpstrv(char const   *domain , char const   *file ,
                                        int line , char const   *func , char const   *expr ,
                                        char const   * const  *arg1 , char const   * const  *arg2 ,
                                        gsize first_wrong_idx ) ;
#line 565
extern void g_assertion_message_cmpnum(char const   *domain , char const   *file ,
                                       int line , char const   *func , char const   *expr ,
                                       long double arg1 , char const   *cmp , long double arg2 ,
                                       char numtype ) ;
#line 575
extern void g_assertion_message_error(char const   *domain , char const   *file ,
                                      int line , char const   *func , char const   *expr ,
                                      GError *error , GQuark error_domain , int error_code ) ;
#line 584
extern void g_test_add_vtable(char const   *testpath , gsize data_size , gconstpointer test_data ,
                              GTestFixtureFunc data_setup , GTestFixtureFunc data_test ,
                              GTestFixtureFunc data_teardown ) ;
#line 598
extern GTestConfig * const  g_test_config_vars ;
#line 637
extern char const   *g_test_log_type_name(GTestLogType log_type ) ;
#line 639
extern GTestLogBuffer *g_test_log_buffer_new(void) ;
#line 641
extern void g_test_log_buffer_free(GTestLogBuffer *tbuffer ) ;
#line 643
extern void g_test_log_buffer_push(GTestLogBuffer *tbuffer , guint n_bytes , guint8 *bytes ) ;
#line 647
extern GTestLogMsg *g_test_log_buffer_pop(GTestLogBuffer *tbuffer ) ;
#line 649
extern void g_test_log_msg_free(GTestLogMsg *tmsg ) ;
#line 670
extern void g_test_log_set_fatal_handler(GTestLogFatalFunc log_func , gpointer user_data ) ;
#line 674
extern void g_test_expect_message(gchar *log_domain , GLogLevelFlags log_level , gchar *pattern ) ;
#line 678
extern void g_test_assert_expected_messages_internal(char const   *domain , char const   *file ,
                                                     int line , char const   *func ) ;
#line 690
extern gchar *g_test_build_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 694
extern gchar *g_test_get_dir(GTestFileType file_type ) ;
#line 696
extern gchar *g_test_get_filename(GTestFileType file_type , gchar *first_path  , ...) ;
#line 49 "/usr/include/glib-2.0/glib/gthreadpool.h"
extern GThreadPool *g_thread_pool_new(GFunc func , gpointer user_data , gint max_threads ,
                                      gboolean exclusive , GError **error ) ;
#line 55
extern GThreadPool *g_thread_pool_new_full(GFunc func , gpointer user_data , GDestroyNotify item_free_func ,
                                           gint max_threads , gboolean exclusive ,
                                           GError **error ) ;
#line 62
extern void g_thread_pool_free(GThreadPool *pool , gboolean immediate , gboolean wait_ ) ;
#line 66
extern gboolean g_thread_pool_push(GThreadPool *pool , gpointer data , GError **error ) ;
#line 70
extern guint g_thread_pool_unprocessed(GThreadPool *pool ) ;
#line 72
extern void g_thread_pool_set_sort_function(GThreadPool *pool , GCompareDataFunc func ,
                                            gpointer user_data ) ;
#line 76
extern gboolean g_thread_pool_move_to_front(GThreadPool *pool , gpointer data ) ;
#line 80
extern gboolean g_thread_pool_set_max_threads(GThreadPool *pool , gint max_threads ,
                                              GError **error ) ;
#line 84
extern gint g_thread_pool_get_max_threads(GThreadPool *pool ) ;
#line 86
extern guint g_thread_pool_get_num_threads(GThreadPool *pool ) ;
#line 89
extern void g_thread_pool_set_max_unused_threads(gint max_threads ) ;
#line 91
extern gint g_thread_pool_get_max_unused_threads(void) ;
#line 93
extern guint g_thread_pool_get_num_unused_threads(void) ;
#line 95
extern void g_thread_pool_stop_unused_threads(void) ;
#line 97
extern void g_thread_pool_set_max_idle_time(guint interval ) ;
#line 99
extern guint g_thread_pool_get_max_idle_time(void) ;
#line 45 "/usr/include/glib-2.0/glib/gtimer.h"
extern GTimer *g_timer_new(void) ;
#line 47
extern void g_timer_destroy(GTimer *timer ) ;
#line 49
extern void g_timer_start(GTimer *timer ) ;
#line 51
extern void g_timer_stop(GTimer *timer ) ;
#line 53
extern void g_timer_reset(GTimer *timer ) ;
#line 55
extern void g_timer_continue(GTimer *timer ) ;
#line 57
extern gdouble g_timer_elapsed(GTimer *timer , gulong *microseconds ) ;
#line 60
extern gboolean g_timer_is_active(GTimer *timer ) ;
#line 63
extern void g_usleep(gulong microseconds ) ;
#line 67
extern void g_time_val_add(GTimeVal *time_ , glong microseconds ) ;
#line 70
extern gboolean g_time_val_from_iso8601(gchar *iso_date , GTimeVal *time_ ) ;
#line 73
extern gchar *g_time_val_to_iso8601(GTimeVal *time_ ) ;
#line 45 "/usr/include/glib-2.0/glib/gtrashstack.h"
extern void g_trash_stack_push(GTrashStack **stack_p , gpointer data_p ) ;
#line 48
extern gpointer g_trash_stack_pop(GTrashStack **stack_p ) ;
#line 50
extern gpointer g_trash_stack_peek(GTrashStack **stack_p ) ;
#line 52
extern guint g_trash_stack_height(GTrashStack **stack_p ) ;
#line 72 "/usr/include/glib-2.0/glib/gtree.h"
extern GTree *g_tree_new(GCompareFunc key_compare_func ) ;
#line 74
extern GTree *g_tree_new_with_data(GCompareDataFunc key_compare_func , gpointer key_compare_data ) ;
#line 77
extern GTree *g_tree_new_full(GCompareDataFunc key_compare_func , gpointer key_compare_data ,
                              GDestroyNotify key_destroy_func , GDestroyNotify value_destroy_func ) ;
#line 82
extern GTreeNode *g_tree_node_first(GTree *tree ) ;
#line 84
extern GTreeNode *g_tree_node_last(GTree *tree ) ;
#line 86
extern GTreeNode *g_tree_node_previous(GTreeNode *node ) ;
#line 88
extern GTreeNode *g_tree_node_next(GTreeNode *node ) ;
#line 90
extern GTree *g_tree_ref(GTree *tree ) ;
#line 92
extern void g_tree_unref(GTree *tree ) ;
#line 94
extern void g_tree_destroy(GTree *tree ) ;
#line 96
extern GTreeNode *g_tree_insert_node(GTree *tree , gpointer key , gpointer value ) ;
#line 100
extern void g_tree_insert(GTree *tree , gpointer key , gpointer value ) ;
#line 104
extern GTreeNode *g_tree_replace_node(GTree *tree , gpointer key , gpointer value ) ;
#line 108
extern void g_tree_replace(GTree *tree , gpointer key , gpointer value ) ;
#line 112
extern gboolean g_tree_remove(GTree *tree , gconstpointer key ) ;
#line 116
extern void g_tree_remove_all(GTree *tree ) ;
#line 119
extern gboolean g_tree_steal(GTree *tree , gconstpointer key ) ;
#line 122
extern gpointer g_tree_node_key(GTreeNode *node ) ;
#line 124
extern gpointer g_tree_node_value(GTreeNode *node ) ;
#line 126
extern GTreeNode *g_tree_lookup_node(GTree *tree , gconstpointer key ) ;
#line 129
extern gpointer g_tree_lookup(GTree *tree , gconstpointer key ) ;
#line 132
extern gboolean g_tree_lookup_extended(GTree *tree , gconstpointer lookup_key , gpointer *orig_key ,
                                       gpointer *value ) ;
#line 137
extern void g_tree_foreach(GTree *tree , GTraverseFunc func , gpointer user_data ) ;
#line 141
extern void g_tree_foreach_node(GTree *tree , GTraverseNodeFunc func , gpointer user_data ) ;
#line 146
extern void g_tree_traverse(GTree *tree , GTraverseFunc traverse_func , GTraverseType traverse_type ,
                            gpointer user_data ) ;
#line 152
extern GTreeNode *g_tree_search_node(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 156
extern gpointer g_tree_search(GTree *tree , GCompareFunc search_func , gconstpointer user_data ) ;
#line 160
extern GTreeNode *g_tree_lower_bound(GTree *tree , gconstpointer key ) ;
#line 163
extern GTreeNode *g_tree_upper_bound(GTree *tree , gconstpointer key ) ;
#line 166
extern gint g_tree_height(GTree *tree ) ;
#line 168
extern gint g_tree_nnodes(GTree *tree ) ;
#line 34 "/usr/include/glib-2.0/glib/guri.h"
extern GUri *g_uri_ref(GUri *uri ) ;
#line 36
extern void g_uri_unref(GUri *uri ) ;
#line 94
extern gboolean g_uri_split(gchar *uri_ref , GUriFlags flags , gchar **scheme , gchar **userinfo ,
                            gchar **host , gint *port , gchar **path , gchar **query ,
                            gchar **fragment , GError **error ) ;
#line 105
extern gboolean g_uri_split_with_user(gchar *uri_ref , GUriFlags flags , gchar **scheme ,
                                      gchar **user , gchar **password , gchar **auth_params ,
                                      gchar **host , gint *port , gchar **path , gchar **query ,
                                      gchar **fragment , GError **error ) ;
#line 118
extern gboolean g_uri_split_network(gchar *uri_string , GUriFlags flags , gchar **scheme ,
                                    gchar **host , gint *port , GError **error ) ;
#line 126
extern gboolean g_uri_is_valid(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 131
extern gchar *g_uri_join(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 140
extern gchar *g_uri_join_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 152
extern GUri *g_uri_parse(gchar *uri_string , GUriFlags flags , GError **error ) ;
#line 156
extern GUri *g_uri_parse_relative(GUri *base_uri , gchar *uri_ref , GUriFlags flags ,
                                  GError **error ) ;
#line 162
extern gchar *g_uri_resolve_relative(gchar *base_uri_string , gchar *uri_ref , GUriFlags flags ,
                                     GError **error ) ;
#line 168
extern GUri *g_uri_build(GUriFlags flags , gchar *scheme , gchar *userinfo , gchar *host ,
                         gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 177
extern GUri *g_uri_build_with_user(GUriFlags flags , gchar *scheme , gchar *user ,
                                   gchar *password , gchar *auth_params , gchar *host ,
                                   gint port , gchar *path , gchar *query , gchar *fragment ) ;
#line 215
extern char *g_uri_to_string(GUri *uri ) ;
#line 217
extern char *g_uri_to_string_partial(GUri *uri , GUriHideFlags flags ) ;
#line 221
extern gchar *g_uri_get_scheme(GUri *uri ) ;
#line 223
extern gchar *g_uri_get_userinfo(GUri *uri ) ;
#line 225
extern gchar *g_uri_get_user(GUri *uri ) ;
#line 227
extern gchar *g_uri_get_password(GUri *uri ) ;
#line 229
extern gchar *g_uri_get_auth_params(GUri *uri ) ;
#line 231
extern gchar *g_uri_get_host(GUri *uri ) ;
#line 233
extern gint g_uri_get_port(GUri *uri ) ;
#line 235
extern gchar *g_uri_get_path(GUri *uri ) ;
#line 237
extern gchar *g_uri_get_query(GUri *uri ) ;
#line 239
extern gchar *g_uri_get_fragment(GUri *uri ) ;
#line 241
extern GUriFlags g_uri_get_flags(GUri *uri ) ;
#line 265
extern GHashTable *g_uri_parse_params(gchar *params , gssize length , gchar *separators ,
                                      GUriParamsFlags flags , GError **error ) ;
#line 283
extern void g_uri_params_iter_init(GUriParamsIter *iter , gchar *params , gssize length ,
                                   gchar *separators , GUriParamsFlags flags ) ;
#line 290
extern gboolean g_uri_params_iter_next(GUriParamsIter *iter , gchar **attribute ,
                                       gchar **value , GError **error ) ;
#line 306
extern GQuark g_uri_error_quark(void) ;
#line 388
extern char *g_uri_unescape_string(char const   *escaped_string , char const   *illegal_characters ) ;
#line 391
extern char *g_uri_unescape_segment(char const   *escaped_string , char const   *escaped_string_end ,
                                    char const   *illegal_characters ) ;
#line 396
extern char *g_uri_parse_scheme(char const   *uri ) ;
#line 398
extern char const   *g_uri_peek_scheme(char const   *uri ) ;
#line 401
extern char *g_uri_escape_string(char const   *unescaped , char const   *reserved_chars_allowed ,
                                 gboolean allow_utf8 ) ;
#line 406
extern GBytes *g_uri_unescape_bytes(char const   *escaped_string , gssize length ,
                                    char const   *illegal_characters , GError **error ) ;
#line 412
extern char *g_uri_escape_bytes(guint8 *unescaped , gsize length , char const   *reserved_chars_allowed ) ;
#line 35 "/usr/include/glib-2.0/glib/guuid.h"
extern gboolean g_uuid_string_is_valid(gchar *str ) ;
#line 38
extern gchar *g_uuid_string_random(void) ;
#line 36 "/usr/include/glib-2.0/glib/gversion.h"
extern guint glib_major_version ;
#line 37
extern guint glib_minor_version ;
#line 38
extern guint glib_micro_version ;
#line 39
extern guint glib_interface_age ;
#line 40
extern guint glib_binary_age ;
#line 43
extern gchar *glib_check_version(guint required_major , guint required_minor , guint required_micro ) ;
#line 43 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
extern GMemChunk *g_mem_chunk_new(gchar *name , gint atom_size , gsize area_size ,
                                  gint type ) ;
#line 48
extern void g_mem_chunk_destroy(GMemChunk *mem_chunk ) ;
#line 50
extern gpointer g_mem_chunk_alloc(GMemChunk *mem_chunk ) ;
#line 52
extern gpointer g_mem_chunk_alloc0(GMemChunk *mem_chunk ) ;
#line 54
extern void g_mem_chunk_free(GMemChunk *mem_chunk , gpointer mem ) ;
#line 57
extern void g_mem_chunk_clean(GMemChunk *mem_chunk ) ;
#line 59
extern void g_mem_chunk_reset(GMemChunk *mem_chunk ) ;
#line 61
extern void g_mem_chunk_print(GMemChunk *mem_chunk ) ;
#line 63
extern void g_mem_chunk_info(void) ;
#line 65
extern void g_blow_chunks(void) ;
#line 69
extern GAllocator *g_allocator_new(gchar *name , guint n_preallocs ) ;
#line 72
extern void g_allocator_free(GAllocator *allocator ) ;
#line 74
extern void g_list_push_allocator(GAllocator *allocator ) ;
#line 76
extern void g_list_pop_allocator(void) ;
#line 78
extern void g_slist_push_allocator(GAllocator *allocator ) ;
#line 80
extern void g_slist_pop_allocator(void) ;
#line 82
extern void g_node_push_allocator(GAllocator *allocator ) ;
#line 84
extern void g_node_pop_allocator(void) ;
#line 47 "/usr/include/glib-2.0/glib/deprecated/gcache.h"
extern GCache *g_cache_new(GCacheNewFunc value_new_func , GCacheDestroyFunc value_destroy_func ,
                           GCacheDupFunc key_dup_func , GCacheDestroyFunc key_destroy_func ,
                           GHashFunc hash_key_func , GHashFunc hash_value_func , GEqualFunc key_equal_func ) ;
#line 55
extern void g_cache_destroy(GCache *cache ) ;
#line 57
extern gpointer g_cache_insert(GCache *cache , gpointer key ) ;
#line 60
extern void g_cache_remove(GCache *cache , gconstpointer value ) ;
#line 63
extern void g_cache_key_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 67
extern void g_cache_value_foreach(GCache *cache , GHFunc func , gpointer user_data ) ;
#line 58 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"
extern GCompletion *g_completion_new(GCompletionFunc func ) ;
#line 60
extern void g_completion_add_items(GCompletion *cmp , GList *items ) ;
#line 63
extern void g_completion_remove_items(GCompletion *cmp , GList *items ) ;
#line 66
extern void g_completion_clear_items(GCompletion *cmp ) ;
#line 68
extern GList *g_completion_complete(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 72
extern GList *g_completion_complete_utf8(GCompletion *cmp , gchar *prefix , gchar **new_prefix ) ;
#line 76
extern void g_completion_set_compare(GCompletion *cmp , GCompletionStrncmpFunc strncmp_func ) ;
#line 79
extern void g_completion_free(GCompletion *cmp ) ;
#line 68 "/usr/include/glib-2.0/glib/deprecated/grel.h"
extern GRelation *g_relation_new(gint fields ) ;
#line 70
extern void g_relation_destroy(GRelation *relation ) ;
#line 72
extern void g_relation_index(GRelation *relation , gint field , GHashFunc hash_func ,
                             GEqualFunc key_equal_func ) ;
#line 77
extern void g_relation_insert(GRelation *relation  , ...) ;
#line 80
extern gint g_relation_delete(GRelation *relation , gconstpointer key , gint field ) ;
#line 84
extern GTuples *g_relation_select(GRelation *relation , gconstpointer key , gint field ) ;
#line 88
extern gint g_relation_count(GRelation *relation , gconstpointer key , gint field ) ;
#line 92
extern gboolean g_relation_exists(GRelation *relation  , ...) ;
#line 95
extern void g_relation_print(GRelation *relation ) ;
#line 97
extern void g_tuples_destroy(GTuples *tuples ) ;
#line 99
extern gpointer g_tuples_index(GTuples *tuples , gint index_ , gint field ) ;
#line 94 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern GThreadFunctions g_thread_functions_for_glib_use ;
#line 95
extern gboolean g_thread_use_default_impl ;
#line 97
extern guint64 (*g_thread_gettime)(void) ;
#line 100
extern GThread *g_thread_create(GThreadFunc func , gpointer data , gboolean joinable ,
                                GError **error ) ;
#line 106
extern GThread *g_thread_create_full(GThreadFunc func , gpointer data , gulong stack_size ,
                                     gboolean joinable , gboolean bound , GThreadPriority priority ,
                                     GError **error ) ;
#line 115
extern void g_thread_set_priority(GThread *thread , GThreadPriority priority ) ;
#line 119
extern void g_thread_foreach(GFunc thread_func , gpointer user_data ) ;
#line 202 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t *__newthread , pthread_attr_t *__attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void *__arg ) ;
#line 211
extern void pthread_exit(void *__retval ) ;
#line 219
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 224
extern  __attribute__((__nothrow__)) int pthread_tryjoin_np(pthread_t __th , void **__thread_return ) ;
#line 233
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec *__abstime ) ;
#line 243
extern int pthread_clockjoin_np(pthread_t __th , void **__thread_return , clockid_t __clockid ,
                                struct timespec *__abstime ) ;
#line 269
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 273
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void) ;
#line 276
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 285
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr ) ;
#line 288
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t *__attr ,
                                                                     int *__detachstate ) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate ) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t *__attr ,
                                                                   size_t *__guardsize ) ;
#line 308
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize ) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t *__attr ,
                                                                    struct sched_param *__param ) ;
#line 324
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t *__attr ,
                                                                     int *__policy ) ;
#line 329
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy ) ;
#line 333
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t *__attr ,
                                                                      int *__inherit ) ;
#line 338
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit ) ;
#line 344
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t *__attr ,
                                                               int *__scope ) ;
#line 349
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope ) ;
#line 353
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t *__attr ,
                                                                   void **__stackaddr ) ;
#line 361
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr ) ;
#line 366
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t *__attr ,
                                                                   size_t *__stacksize ) ;
#line 373
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize ) ;
#line 379
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t *__attr ,
                                                               void **__stackaddr ,
                                                               size_t *__stacksize ) ;
#line 387
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize ) ;
#line 394
extern  __attribute__((__nothrow__)) int pthread_attr_setaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 401
extern  __attribute__((__nothrow__)) int pthread_attr_getaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset ) ;
#line 407
extern  __attribute__((__nothrow__)) int pthread_getattr_default_np(pthread_attr_t *__attr ) ;
#line 411
extern int pthread_attr_setsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 417
extern int pthread_attr_getsigmask_np(pthread_attr_t *__attr , __sigset_t *sigmask ) ;
#line 426
extern  __attribute__((__nothrow__)) int pthread_setattr_default_np(pthread_attr_t *__attr ) ;
#line 432
extern  __attribute__((__nothrow__)) int pthread_getattr_np(pthread_t __th , pthread_attr_t *__attr ) ;
#line 441
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param *__param ) ;
#line 446
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int *__policy , struct sched_param *__param ) ;
#line 452
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 458
extern  __attribute__((__nothrow__)) int pthread_getname_np(pthread_t __target_thread ,
                                                            char *__buf , size_t __buflen ) ;
#line 463
extern  __attribute__((__nothrow__)) int pthread_setname_np(pthread_t __target_thread ,
                                                            char const   *__name ) ;
#line 470
extern  __attribute__((__nothrow__)) int pthread_getconcurrency(void) ;
#line 473
extern  __attribute__((__nothrow__)) int pthread_setconcurrency(int __level ) ;
#line 477
extern  __attribute__((__nothrow__)) int pthread_yield(void) ;
#line 489
extern  __attribute__((__nothrow__)) int pthread_setaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 494
extern  __attribute__((__nothrow__)) int pthread_getaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset ) ;
#line 509
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) ) ;
#line 521
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 525
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 528
extern int pthread_cancel(pthread_t __th ) ;
#line 533
extern void pthread_testcancel(void) ;
#line 697
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 709
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 732
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 745
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 750
extern void __pthread_unwind_next(__pthread_unwind_buf_t *__buf ) ;
#line 766
extern  __attribute__((__nothrow__)) int __sigsetjmp_cancel(struct __cancel_jmp_buf_tag __env[1] ,
                                                            int __savemask ) ;
#line 781
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t *__mutexattr ) ;
#line 786
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex ) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex ) ;
#line 794
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex ) ;
#line 800
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t *__mutex ,
                                                                 struct timespec *__abstime ) ;
#line 817
extern  __attribute__((__nothrow__)) int pthread_mutex_clocklock(pthread_mutex_t *__mutex ,
                                                                 clockid_t __clockid ,
                                                                 struct timespec *__abstime ) ;
#line 835
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex ) ;
#line 840
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t *__mutex ,
                                                                      int *__prioceiling ) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t *__mutex ,
                                                                      int __prioceiling ,
                                                                      int *__old_ceiling ) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent(pthread_mutex_t *__mutex ) ;
#line 859
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent_np(pthread_mutex_t * ) ;
#line 874
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr ) ;
#line 878
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr ) ;
#line 882
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t *__attr ,
                                                                      int *__pshared ) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared ) ;
#line 894
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t *__attr ,
                                                                   int *__kind ) ;
#line 901
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind ) ;
#line 906
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t *__attr ,
                                                                       int *__protocol ) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol ) ;
#line 918
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int *__prioceiling ) ;
#line 924
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling ) ;
#line 930
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust(pthread_mutexattr_t *__attr ,
                                                                     int *__robustness ) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust_np(pthread_mutexattr_t * ,
                                                                        int * ) ;
#line 946
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr ,
                                                                     int __robustness ) ;
#line 951
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust_np(pthread_mutexattr_t * ,
                                                                        int  ) ;
#line 967
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t *__rwlock ,
                                                             pthread_rwlockattr_t *__attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock ) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock ) ;
#line 980
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock ) ;
#line 986
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1004
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockrdlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1023
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock ) ;
#line 1027
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock ) ;
#line 1033
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t *__rwlock ,
                                                                    struct timespec *__abstime ) ;
#line 1051
extern  __attribute__((__nothrow__)) int pthread_rwlock_clockwrlock(pthread_rwlock_t *__rwlock ,
                                                                    clockid_t __clockid ,
                                                                    struct timespec *__abstime ) ;
#line 1071
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock ) ;
#line 1078
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr ) ;
#line 1086
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *__attr ,
                                                                       int *__pshared ) ;
#line 1092
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared ) ;
#line 1097
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int *__pref ) ;
#line 1103
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref ) ;
#line 1112
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t *__cond ,
                                                           pthread_condattr_t *__cond_attr ) ;
#line 1117
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond ) ;
#line 1121
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond ) ;
#line 1125
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond ) ;
#line 1133
extern int pthread_cond_wait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ) ;
#line 1145
extern int pthread_cond_timedwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  struct timespec *__abstime ) ;
#line 1171
extern int pthread_cond_clockwait(pthread_cond_t *__cond , pthread_mutex_t *__mutex ,
                                  __clockid_t __clock_id , struct timespec *__abstime ) ;
#line 1194
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr ) ;
#line 1198
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr ) ;
#line 1202
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t *__attr ,
                                                                     int *__pshared ) ;
#line 1208
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared ) ;
#line 1213
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t *__clock_id ) ;
#line 1219
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id ) ;
#line 1230
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared ) ;
#line 1234
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock ) ;
#line 1238
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock ) ;
#line 1242
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock ) ;
#line 1246
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock ) ;
#line 1254
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t *__barrier ,
                                                              pthread_barrierattr_t *__attr ,
                                                              unsigned int __count ) ;
#line 1260
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier ) ;
#line 1264
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier ) ;
#line 1269
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr ) ;
#line 1273
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr ) ;
#line 1277
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t *__attr ,
                                                                        int *__pshared ) ;
#line 1283
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared ) ;
#line 1297
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) ) ;
#line 1302
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1305
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1308
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1315
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id ) ;
#line 1332
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1340
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__gnu_inline__)) ;
#line 1340 "/usr/include/pthread.h"
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
#line 1342
  return (__thread1 == __thread2);
}
}
#line 150 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
extern void g_static_mutex_init(GStaticMutex *mutex ) ;
#line 152
extern void g_static_mutex_free(GStaticMutex *mutex ) ;
#line 154
extern GMutex *g_static_mutex_get_mutex_impl(GStaticMutex *mutex ) ;
#line 176
extern void g_static_rec_mutex_init(GStaticRecMutex *mutex ) ;
#line 179
extern void g_static_rec_mutex_lock(GStaticRecMutex *mutex ) ;
#line 182
extern gboolean g_static_rec_mutex_trylock(GStaticRecMutex *mutex ) ;
#line 185
extern void g_static_rec_mutex_unlock(GStaticRecMutex *mutex ) ;
#line 188
extern void g_static_rec_mutex_lock_full(GStaticRecMutex *mutex , guint depth ) ;
#line 192
extern guint g_static_rec_mutex_unlock_full(GStaticRecMutex *mutex ) ;
#line 195
extern void g_static_rec_mutex_free(GStaticRecMutex *mutex ) ;
#line 213
extern void g_static_rw_lock_init(GStaticRWLock *lock ) ;
#line 216
extern void g_static_rw_lock_reader_lock(GStaticRWLock *lock ) ;
#line 219
extern gboolean g_static_rw_lock_reader_trylock(GStaticRWLock *lock ) ;
#line 222
extern void g_static_rw_lock_reader_unlock(GStaticRWLock *lock ) ;
#line 225
extern void g_static_rw_lock_writer_lock(GStaticRWLock *lock ) ;
#line 228
extern gboolean g_static_rw_lock_writer_trylock(GStaticRWLock *lock ) ;
#line 231
extern void g_static_rw_lock_writer_unlock(GStaticRWLock *lock ) ;
#line 234
extern void g_static_rw_lock_free(GStaticRWLock *lock ) ;
#line 237
extern GPrivate *g_private_new(GDestroyNotify notify ) ;
#line 248
extern void g_static_private_init(GStaticPrivate *private_key ) ;
#line 251
extern gpointer g_static_private_get(GStaticPrivate *private_key ) ;
#line 254
extern void g_static_private_set(GStaticPrivate *private_key , gpointer data , GDestroyNotify notify ) ;
#line 259
extern void g_static_private_free(GStaticPrivate *private_key ) ;
#line 262
extern gboolean g_once_init_enter_impl(gsize *location ) ;
#line 265
extern void g_thread_init(gpointer vtable ) ;
#line 267
extern void g_thread_init_with_errorcheck_mutexes(gpointer vtable ) ;
#line 270
extern gboolean g_thread_get_initialized(void) ;
#line 272
extern gboolean g_threads_got_initialized ;
#line 277
extern GMutex *g_mutex_new(void) ;
#line 279
extern void g_mutex_free(GMutex *mutex ) ;
#line 281
extern GCond *g_cond_new(void) ;
#line 283
extern void g_cond_free(GCond *cond ) ;
#line 285
extern gboolean g_cond_timed_wait(GCond *cond , GMutex *mutex , GTimeVal *timeval ) ;
#line 25 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_generic_gfree(void *p ) 
{ 
  void **pp ;

  {
  {
#line 27
  pp = (void **)p;
#line 28
  g_free(*pp);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void g_autoptr_cleanup_gstring_free(GString *string ) 
{ 


  {
#line 34
  if (string) {
    {
#line 35
    g_string_free(string, ! 0);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncQueue(GAsyncQueue *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_async_queue_unref((GAsyncQueue *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncQueue(GAsyncQueue **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GAsyncQueue(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GAsyncQueue(GList **_l ) 
{ 


  {
  {
#line 45
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GAsyncQueue(GSList **_l ) 
{ 


  {
  {
#line 45
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GAsyncQueue(GQueue **_q ) 
{ 


  {
#line 45
  if (*_q) {
    {
#line 45
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_async_queue_unref)));
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBookmarkFile(GBookmarkFile *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_bookmark_file_free((GBookmarkFile *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBookmarkFile(GBookmarkFile **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GBookmarkFile(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBookmarkFile(GList **_l ) 
{ 


  {
  {
#line 46
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBookmarkFile(GSList **_l ) 
{ 


  {
  {
#line 46
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBookmarkFile(GQueue **_q ) 
{ 


  {
#line 46
  if (*_q) {
    {
#line 46
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bookmark_file_free)));
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GBytes(GBytes *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_bytes_unref((GBytes *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytes(GBytes **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GBytes(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GBytes(GList **_l ) 
{ 


  {
  {
#line 47
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GBytes(GSList **_l ) 
{ 


  {
  {
#line 47
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GBytes(GQueue **_q ) 
{ 


  {
#line 47
  if (*_q) {
    {
#line 47
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_bytes_unref)));
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GChecksum(GChecksum *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_checksum_free((GChecksum *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GChecksum(GChecksum **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GChecksum(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GChecksum(GList **_l ) 
{ 


  {
  {
#line 48
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GChecksum(GSList **_l ) 
{ 


  {
  {
#line 48
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GChecksum(GQueue **_q ) 
{ 


  {
#line 48
  if (*_q) {
    {
#line 48
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_checksum_free)));
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDateTime(GDateTime *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_date_time_unref((GDateTime *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDateTime(GDateTime **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDateTime(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDateTime(GList **_l ) 
{ 


  {
  {
#line 49
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDateTime(GSList **_l ) 
{ 


  {
  {
#line 49
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDateTime(GQueue **_q ) 
{ 


  {
#line 49
  if (*_q) {
    {
#line 49
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_time_unref)));
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDate(GDate *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_date_free((GDate *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDate(GDate **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDate(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDate(GList **_l ) 
{ 


  {
  {
#line 50
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDate(GSList **_l ) 
{ 


  {
  {
#line 50
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_date_free)));
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDate(GQueue **_q ) 
{ 


  {
#line 50
  if (*_q) {
    {
#line 50
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_date_free)));
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GDir(GDir *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_dir_close((GDir *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDir(GDir **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDir(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDir(GList **_l ) 
{ 


  {
  {
#line 51
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDir(GSList **_l ) 
{ 


  {
  {
#line 51
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDir(GQueue **_q ) 
{ 


  {
#line 51
  if (*_q) {
    {
#line 51
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dir_close)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GError(GError *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_error_free((GError *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GError(GError **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GError(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GError(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GError(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_error_free)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GError(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_error_free)));
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHashTable(GHashTable *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_hash_table_unref((GHashTable *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHashTable(GHashTable **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GHashTable(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHashTable(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHashTable(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHashTable(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hash_table_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GHmac(GHmac *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_hmac_unref((GHmac *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GHmac(GHmac **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GHmac(*_ptr);
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GHmac(GList **_l ) 
{ 


  {
  {
#line 54
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GHmac(GSList **_l ) 
{ 


  {
  {
#line 54
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GHmac(GQueue **_q ) 
{ 


  {
#line 54
  if (*_q) {
    {
#line 54
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_hmac_unref)));
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GIOChannel(GIOChannel *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_io_channel_unref((GIOChannel *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOChannel(GIOChannel **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GIOChannel(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GIOChannel(GList **_l ) 
{ 


  {
  {
#line 55
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GIOChannel(GSList **_l ) 
{ 


  {
  {
#line 55
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GIOChannel(GQueue **_q ) 
{ 


  {
#line 55
  if (*_q) {
    {
#line 55
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_io_channel_unref)));
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GKeyFile(GKeyFile *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_key_file_unref((GKeyFile *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GKeyFile(GKeyFile **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GKeyFile(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GKeyFile(GList **_l ) 
{ 


  {
  {
#line 56
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GKeyFile(GSList **_l ) 
{ 


  {
  {
#line 56
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GKeyFile(GQueue **_q ) 
{ 


  {
#line 56
  if (*_q) {
    {
#line 56
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_key_file_unref)));
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GList(GList *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_list_free((GList *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GList(GList **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GList(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GList(GList **_l ) 
{ 


  {
  {
#line 57
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GList(GSList **_l ) 
{ 


  {
  {
#line 57
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_list_free)));
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GList(GQueue **_q ) 
{ 


  {
#line 57
  if (*_q) {
    {
#line 57
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_list_free)));
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GArray(GArray *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_array_unref((GArray *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GArray(GArray **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GArray(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GArray(GList **_l ) 
{ 


  {
  {
#line 58
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GArray(GSList **_l ) 
{ 


  {
  {
#line 58
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GArray(GQueue **_q ) 
{ 


  {
#line 58
  if (*_q) {
    {
#line 58
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_array_unref)));
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPtrArray(GPtrArray *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_ptr_array_unref((GPtrArray *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPtrArray(GPtrArray **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GPtrArray(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPtrArray(GList **_l ) 
{ 


  {
  {
#line 59
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPtrArray(GSList **_l ) 
{ 


  {
  {
#line 59
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPtrArray(GQueue **_q ) 
{ 


  {
#line 59
  if (*_q) {
    {
#line 59
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ptr_array_unref)));
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GByteArray(GByteArray *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_byte_array_unref((GByteArray *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GByteArray(GByteArray **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GByteArray(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GByteArray(GList **_l ) 
{ 


  {
  {
#line 60
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GByteArray(GSList **_l ) 
{ 


  {
  {
#line 60
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GByteArray(GQueue **_q ) 
{ 


  {
#line 60
  if (*_q) {
    {
#line 60
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_byte_array_unref)));
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContext(GMainContext *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_main_context_unref((GMainContext *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContext(GMainContext **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GMainContext(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContext(GList **_l ) 
{ 


  {
  {
#line 61
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContext(GSList **_l ) 
{ 


  {
  {
#line 61
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContext(GQueue **_q ) 
{ 


  {
#line 61
  if (*_q) {
    {
#line 61
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_unref)));
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainContextPusher(GMainContextPusher *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_main_context_pusher_free((GMainContextPusher *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainContextPusher(GMainContextPusher **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GMainContextPusher(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainContextPusher(GList **_l ) 
{ 


  {
  {
#line 62
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainContextPusher(GSList **_l ) 
{ 


  {
  {
#line 62
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainContextPusher(GQueue **_q ) 
{ 


  {
#line 62
  if (*_q) {
    {
#line 62
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_context_pusher_free)));
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMainLoop(GMainLoop *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_main_loop_unref((GMainLoop *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMainLoop(GMainLoop **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GMainLoop(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMainLoop(GList **_l ) 
{ 


  {
  {
#line 63
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMainLoop(GSList **_l ) 
{ 


  {
  {
#line 63
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMainLoop(GQueue **_q ) 
{ 


  {
#line 63
  if (*_q) {
    {
#line 63
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_main_loop_unref)));
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSource(GSource *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_source_unref((GSource *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSource(GSource **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GSource(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSource(GList **_l ) 
{ 


  {
  {
#line 64
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSource(GSList **_l ) 
{ 


  {
  {
#line 64
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSource(GQueue **_q ) 
{ 


  {
#line 64
  if (*_q) {
    {
#line 64
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_source_unref)));
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMappedFile(GMappedFile *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_mapped_file_unref((GMappedFile *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMappedFile(GMappedFile **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GMappedFile(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMappedFile(GList **_l ) 
{ 


  {
  {
#line 65
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMappedFile(GSList **_l ) 
{ 


  {
  {
#line 65
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMappedFile(GQueue **_q ) 
{ 


  {
#line 65
  if (*_q) {
    {
#line 65
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mapped_file_unref)));
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMarkupParseContext(GMarkupParseContext *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_markup_parse_context_unref((GMarkupParseContext *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMarkupParseContext(GMarkupParseContext **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GMarkupParseContext(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMarkupParseContext(GList **_l ) 
{ 


  {
  {
#line 66
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMarkupParseContext(GSList **_l ) 
{ 


  {
  {
#line 66
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMarkupParseContext(GQueue **_q ) 
{ 


  {
#line 66
  if (*_q) {
    {
#line 66
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_markup_parse_context_unref)));
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GNode(GNode *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_node_destroy((GNode *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNode(GNode **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GNode(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GNode(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GNode(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GNode(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_node_destroy)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionContext(GOptionContext *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_option_context_free((GOptionContext *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionContext(GOptionContext **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GOptionContext(*_ptr);
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionContext(GList **_l ) 
{ 


  {
  {
#line 68
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionContext(GSList **_l ) 
{ 


  {
  {
#line 68
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionContext(GQueue **_q ) 
{ 


  {
#line 68
  if (*_q) {
    {
#line 68
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_context_free)));
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GOptionGroup(GOptionGroup *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_option_group_unref((GOptionGroup *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOptionGroup(GOptionGroup **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GOptionGroup(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GOptionGroup(GList **_l ) 
{ 


  {
  {
#line 69
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GOptionGroup(GSList **_l ) 
{ 


  {
  {
#line 69
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GOptionGroup(GQueue **_q ) 
{ 


  {
#line 69
  if (*_q) {
    {
#line 69
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_option_group_unref)));
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GPatternSpec(GPatternSpec *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_pattern_spec_free((GPatternSpec *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPatternSpec(GPatternSpec **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GPatternSpec(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GPatternSpec(GList **_l ) 
{ 


  {
  {
#line 70
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GPatternSpec(GSList **_l ) 
{ 


  {
  {
#line 70
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GPatternSpec(GQueue **_q ) 
{ 


  {
#line 70
  if (*_q) {
    {
#line 70
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_pattern_spec_free)));
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GQueue(GQueue *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_queue_free((GQueue *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GQueue(GQueue **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GQueue(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GQueue(GList **_l ) 
{ 


  {
  {
#line 71
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GQueue(GSList **_l ) 
{ 


  {
  {
#line 71
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GQueue(GQueue **_q ) 
{ 


  {
#line 71
  if (*_q) {
    {
#line 71
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_queue_free)));
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GQueue(GQueue *_ptr ) 
{ 


  {
  {
#line 72
  g_queue_clear(_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRand(GRand *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_rand_free((GRand *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRand(GRand **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GRand(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRand(GList **_l ) 
{ 


  {
  {
#line 73
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRand(GSList **_l ) 
{ 


  {
  {
#line 73
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRand(GQueue **_q ) 
{ 


  {
#line 73
  if (*_q) {
    {
#line 73
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rand_free)));
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRegex(GRegex *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_regex_unref((GRegex *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRegex(GRegex **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GRegex(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRegex(GList **_l ) 
{ 


  {
  {
#line 74
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRegex(GSList **_l ) 
{ 


  {
  {
#line 74
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRegex(GQueue **_q ) 
{ 


  {
#line 74
  if (*_q) {
    {
#line 74
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_regex_unref)));
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMatchInfo(GMatchInfo *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_match_info_unref((GMatchInfo *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMatchInfo(GMatchInfo **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GMatchInfo(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMatchInfo(GList **_l ) 
{ 


  {
  {
#line 75
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMatchInfo(GSList **_l ) 
{ 


  {
  {
#line 75
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMatchInfo(GQueue **_q ) 
{ 


  {
#line 75
  if (*_q) {
    {
#line 75
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_match_info_unref)));
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GScanner(GScanner *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_scanner_destroy((GScanner *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GScanner(GScanner **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GScanner(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GScanner(GList **_l ) 
{ 


  {
  {
#line 76
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GScanner(GSList **_l ) 
{ 


  {
  {
#line 76
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GScanner(GQueue **_q ) 
{ 


  {
#line 76
  if (*_q) {
    {
#line 76
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_scanner_destroy)));
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSequence(GSequence *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_sequence_free((GSequence *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSequence(GSequence **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GSequence(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSequence(GList **_l ) 
{ 


  {
  {
#line 77
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSequence(GSList **_l ) 
{ 


  {
  {
#line 77
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSequence(GQueue **_q ) 
{ 


  {
#line 77
  if (*_q) {
    {
#line 77
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_sequence_free)));
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GSList(GSList *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_slist_free((GSList *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSList(GSList **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GSList(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSList(GList **_l ) 
{ 


  {
  {
#line 78
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSList(GSList **_l ) 
{ 


  {
  {
#line 78
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSList(GQueue **_q ) 
{ 


  {
#line 78
  if (*_q) {
    {
#line 78
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_slist_free)));
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GString(GString *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_autoptr_cleanup_gstring_free((GString *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GString(GString **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GString(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GString(GList **_l ) 
{ 


  {
  {
#line 79
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GString(GSList **_l ) 
{ 


  {
  {
#line 79
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GString(GQueue **_q ) 
{ 


  {
#line 79
  if (*_q) {
    {
#line 79
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_autoptr_cleanup_gstring_free)));
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStringChunk(GStringChunk *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_string_chunk_free((GStringChunk *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStringChunk(GStringChunk **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GStringChunk(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStringChunk(GList **_l ) 
{ 


  {
  {
#line 80
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStringChunk(GSList **_l ) 
{ 


  {
  {
#line 80
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStringChunk(GQueue **_q ) 
{ 


  {
#line 80
  if (*_q) {
    {
#line 80
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_string_chunk_free)));
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GStrvBuilder(GStrvBuilder *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_strv_builder_unref((GStrvBuilder *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GStrvBuilder(GStrvBuilder **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GStrvBuilder(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GStrvBuilder(GList **_l ) 
{ 


  {
  {
#line 81
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GStrvBuilder(GSList **_l ) 
{ 


  {
  {
#line 81
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GStrvBuilder(GQueue **_q ) 
{ 


  {
#line 81
  if (*_q) {
    {
#line 81
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_strv_builder_unref)));
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GThread(GThread *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_thread_unref((GThread *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThread(GThread **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GThread(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GThread(GList **_l ) 
{ 


  {
  {
#line 82
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GThread(GSList **_l ) 
{ 


  {
  {
#line 82
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GThread(GQueue **_q ) 
{ 


  {
#line 82
  if (*_q) {
    {
#line 82
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_thread_unref)));
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GMutex(GMutex *_ptr ) 
{ 


  {
  {
#line 83
  g_mutex_clear(_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GMutexLocker(GMutexLocker *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_mutex_locker_free((GMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMutexLocker(GMutexLocker **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GMutexLocker(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GMutexLocker(GList **_l ) 
{ 


  {
  {
#line 84
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 84
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GMutexLocker(GQueue **_q ) 
{ 


  {
#line 84
  if (*_q) {
    {
#line 84
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_mutex_locker_free)));
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRecMutexLocker(GRecMutexLocker *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_rec_mutex_locker_free((GRecMutexLocker *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRecMutexLocker(GRecMutexLocker **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GRecMutexLocker(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRecMutexLocker(GList **_l ) 
{ 


  {
  {
#line 85
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRecMutexLocker(GSList **_l ) 
{ 


  {
  {
#line 85
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRecMutexLocker(GQueue **_q ) 
{ 


  {
#line 85
  if (*_q) {
    {
#line 85
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rec_mutex_locker_free)));
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockWriterLocker(GRWLockWriterLocker *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_rw_lock_writer_locker_free((GRWLockWriterLocker *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockWriterLocker(GRWLockWriterLocker **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GRWLockWriterLocker(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockWriterLocker(GList **_l ) 
{ 


  {
  {
#line 86
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockWriterLocker(GSList **_l ) 
{ 


  {
  {
#line 86
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockWriterLocker(GQueue **_q ) 
{ 


  {
#line 86
  if (*_q) {
    {
#line 86
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_writer_locker_free)));
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRWLockReaderLocker(GRWLockReaderLocker *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_rw_lock_reader_locker_free((GRWLockReaderLocker *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRWLockReaderLocker(GRWLockReaderLocker **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GRWLockReaderLocker(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRWLockReaderLocker(GList **_l ) 
{ 


  {
  {
#line 87
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRWLockReaderLocker(GSList **_l ) 
{ 


  {
  {
#line 87
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRWLockReaderLocker(GQueue **_q ) 
{ 


  {
#line 87
  if (*_q) {
    {
#line 87
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_rw_lock_reader_locker_free)));
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GCond(GCond *_ptr ) 
{ 


  {
  {
#line 88
  g_cond_clear(_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimer(GTimer *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_timer_destroy((GTimer *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimer(GTimer **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GTimer(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimer(GList **_l ) 
{ 


  {
  {
#line 89
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimer(GSList **_l ) 
{ 


  {
  {
#line 89
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimer(GQueue **_q ) 
{ 


  {
#line 89
  if (*_q) {
    {
#line 89
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_timer_destroy)));
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTimeZone(GTimeZone *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_time_zone_unref((GTimeZone *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTimeZone(GTimeZone **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GTimeZone(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTimeZone(GList **_l ) 
{ 


  {
  {
#line 90
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTimeZone(GSList **_l ) 
{ 


  {
  {
#line 90
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTimeZone(GQueue **_q ) 
{ 


  {
#line 90
  if (*_q) {
    {
#line 90
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_time_zone_unref)));
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GTree(GTree *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_tree_unref((GTree *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTree(GTree **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GTree(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GTree(GList **_l ) 
{ 


  {
  {
#line 91
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GTree(GSList **_l ) 
{ 


  {
  {
#line 91
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GTree(GQueue **_q ) 
{ 


  {
#line 91
  if (*_q) {
    {
#line 91
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_tree_unref)));
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariant(GVariant *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_variant_unref((GVariant *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariant(GVariant **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GVariant(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariant(GList **_l ) 
{ 


  {
  {
#line 92
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariant(GSList **_l ) 
{ 


  {
  {
#line 92
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariant(GQueue **_q ) 
{ 


  {
#line 92
  if (*_q) {
    {
#line 92
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_unref)));
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_variant_builder_unref((GVariantBuilder *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantBuilder(GVariantBuilder **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GVariantBuilder(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantBuilder(GList **_l ) 
{ 


  {
  {
#line 93
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantBuilder(GSList **_l ) 
{ 


  {
  {
#line 93
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantBuilder(GQueue **_q ) 
{ 


  {
#line 93
  if (*_q) {
    {
#line 93
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_builder_unref)));
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantBuilder(GVariantBuilder *_ptr ) 
{ 


  {
  {
#line 94
  g_variant_builder_clear(_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantIter(GVariantIter *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_variant_iter_free((GVariantIter *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantIter(GVariantIter **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GVariantIter(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantIter(GList **_l ) 
{ 


  {
  {
#line 95
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantIter(GSList **_l ) 
{ 


  {
  {
#line 95
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantIter(GQueue **_q ) 
{ 


  {
#line 95
  if (*_q) {
    {
#line 95
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_iter_free)));
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_variant_dict_unref((GVariantDict *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantDict(GVariantDict **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GVariantDict(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantDict(GList **_l ) 
{ 


  {
  {
#line 96
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantDict(GSList **_l ) 
{ 


  {
  {
#line 96
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantDict(GQueue **_q ) 
{ 


  {
#line 96
  if (*_q) {
    {
#line 96
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_dict_unref)));
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GVariantDict(GVariantDict *_ptr ) 
{ 


  {
  {
#line 97
  g_variant_dict_clear(_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GVariantType(GVariantType *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_variant_type_free((GVariantType *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVariantType(GVariantType **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GVariantType(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GVariantType(GList **_l ) 
{ 


  {
  {
#line 98
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GVariantType(GSList **_l ) 
{ 


  {
  {
#line 98
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GVariantType(GQueue **_q ) 
{ 


  {
#line 98
  if (*_q) {
    {
#line 98
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_variant_type_free)));
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_auto_cleanup_GStrv(GStrv *_ptr ) 
{ 


  {
#line 99
  if (*_ptr != (void *)0) {
    {
#line 99
    g_strfreev(*_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GRefString(GRefString *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_ref_string_release((GRefString *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRefString(GRefString **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GRefString(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GRefString(GList **_l ) 
{ 


  {
  {
#line 100
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GRefString(GSList **_l ) 
{ 


  {
  {
#line 100
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GRefString(GQueue **_q ) 
{ 


  {
#line 100
  if (*_q) {
    {
#line 100
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_ref_string_release)));
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_clear_GUri(GUri *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_uri_unref((GUri *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_autoptr_cleanup_GUri(GUri **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GUri(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GUri(GList **_l ) 
{ 


  {
  {
#line 101
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GUri(GSList **_l ) 
{ 


  {
  {
#line 101
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/glib/glib-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GUri(GQueue **_q ) 
{ 


  {
#line 101
  if (*_q) {
    {
#line 101
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_uri_unref)));
    }
  }
  return;
}
}
#line 710 "/usr/include/glib-2.0/gobject/gtype.h"
extern void g_type_init(void) ;
#line 712
extern void g_type_init_with_debug_flags(GTypeDebugFlags debug_flags ) ;
#line 716
extern gchar *g_type_name(GType type ) ;
#line 718
extern GQuark g_type_qname(GType type ) ;
#line 720
extern GType g_type_from_name(gchar *name ) ;
#line 722
extern GType g_type_parent(GType type ) ;
#line 724
extern guint g_type_depth(GType type ) ;
#line 726
extern GType g_type_next_base(GType leaf_type , GType root_type ) ;
#line 729
extern gboolean g_type_is_a(GType type , GType is_a_type ) ;
#line 732
extern gpointer g_type_class_ref(GType type ) ;
#line 734
extern gpointer g_type_class_peek(GType type ) ;
#line 736
extern gpointer g_type_class_peek_static(GType type ) ;
#line 738
extern void g_type_class_unref(gpointer g_class ) ;
#line 740
extern gpointer g_type_class_peek_parent(gpointer g_class ) ;
#line 742
extern gpointer g_type_interface_peek(gpointer instance_class , GType iface_type ) ;
#line 745
extern gpointer g_type_interface_peek_parent(gpointer g_iface ) ;
#line 748
extern gpointer g_type_default_interface_ref(GType g_type ) ;
#line 750
extern gpointer g_type_default_interface_peek(GType g_type ) ;
#line 752
extern void g_type_default_interface_unref(gpointer g_iface ) ;
#line 756
extern GType *g_type_children(GType type , guint *n_children ) ;
#line 759
extern GType *g_type_interfaces(GType type , guint *n_interfaces ) ;
#line 764
extern void g_type_set_qdata(GType type , GQuark quark , gpointer data ) ;
#line 768
extern gpointer g_type_get_qdata(GType type , GQuark quark ) ;
#line 771
extern void g_type_query(GType type , GTypeQuery *query ) ;
#line 775
extern int g_type_get_instance_count(GType type ) ;
#line 1304
extern GType g_type_register_static(GType parent_type , gchar *type_name , GTypeInfo *info ,
                                    GTypeFlags flags ) ;
#line 1309
extern GType g_type_register_static_simple(GType parent_type , gchar *type_name ,
                                           guint class_size , GClassInitFunc class_init ,
                                           guint instance_size , GInstanceInitFunc instance_init ,
                                           GTypeFlags flags ) ;
#line 1318
extern GType g_type_register_dynamic(GType parent_type , gchar *type_name , GTypePlugin *plugin ,
                                     GTypeFlags flags ) ;
#line 1323
extern GType g_type_register_fundamental(GType type_id , gchar *type_name , GTypeInfo *info ,
                                         GTypeFundamentalInfo *finfo , GTypeFlags flags ) ;
#line 1329
extern void g_type_add_interface_static(GType instance_type , GType interface_type ,
                                        GInterfaceInfo *info ) ;
#line 1333
extern void g_type_add_interface_dynamic(GType instance_type , GType interface_type ,
                                         GTypePlugin *plugin ) ;
#line 1337
extern void g_type_interface_add_prerequisite(GType interface_type , GType prerequisite_type ) ;
#line 1340
extern GType *g_type_interface_prerequisites(GType interface_type , guint *n_prerequisites ) ;
#line 1343
extern GType g_type_interface_instantiatable_prerequisite(GType interface_type ) ;
#line 1346
extern void g_type_class_add_private(gpointer g_class , gsize private_size ) ;
#line 1349
extern gint g_type_add_instance_private(GType class_type , gsize private_size ) ;
#line 1352
extern gpointer g_type_instance_get_private(GTypeInstance *instance , GType private_type ) ;
#line 1355
extern void g_type_class_adjust_private_offset(gpointer g_class , gint *private_size_or_offset ) ;
#line 1359
extern void g_type_add_class_private(GType class_type , gsize private_size ) ;
#line 1362
extern gpointer g_type_class_get_private(GTypeClass *klass , GType private_type ) ;
#line 1365
extern gint g_type_class_get_instance_private_offset(gpointer g_class ) ;
#line 1368
extern void g_type_ensure(GType type ) ;
#line 1370
extern guint g_type_get_type_registration_serial(void) ;
#line 2385
extern GTypePlugin *g_type_get_plugin(GType type ) ;
#line 2387
extern GTypePlugin *g_type_interface_get_plugin(GType instance_type , GType interface_type ) ;
#line 2390
extern GType g_type_fundamental_next(void) ;
#line 2392
extern GType g_type_fundamental(GType type_id ) ;
#line 2394
extern GTypeInstance *g_type_create_instance(GType type ) ;
#line 2396
extern void g_type_free_instance(GTypeInstance *instance ) ;
#line 2399
extern void g_type_add_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2402
extern void g_type_remove_class_cache_func(gpointer cache_data , GTypeClassCacheFunc cache_func ) ;
#line 2405
extern void g_type_class_unref_uncached(gpointer g_class ) ;
#line 2408
extern void g_type_add_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2411
extern void g_type_remove_interface_check(gpointer check_data , GTypeInterfaceCheckFunc check_func ) ;
#line 2415
extern GTypeValueTable *g_type_value_table_peek(GType type ) ;
#line 2420
extern gboolean g_type_check_instance(GTypeInstance *instance ) ;
#line 2422
extern GTypeInstance *g_type_check_instance_cast(GTypeInstance *instance , GType iface_type ) ;
#line 2425
extern gboolean g_type_check_instance_is_a(GTypeInstance *instance , GType iface_type ) ;
#line 2428
extern gboolean g_type_check_instance_is_fundamentally_a(GTypeInstance *instance ,
                                                         GType fundamental_type ) ;
#line 2431
extern GTypeClass *g_type_check_class_cast(GTypeClass *g_class , GType is_a_type ) ;
#line 2434
extern gboolean g_type_check_class_is_a(GTypeClass *g_class , GType is_a_type ) ;
#line 2437
extern gboolean g_type_check_is_value_type(GType type ) ;
#line 2439
extern gboolean g_type_check_value(GValue *value ) ;
#line 2441
extern gboolean g_type_check_value_holds(GValue *value , GType type ) ;
#line 2444
extern gboolean g_type_test_flags(GType type , guint flags ) ;
#line 2450
extern gchar *g_type_name_from_instance(GTypeInstance *instance ) ;
#line 2452
extern gchar *g_type_name_from_class(GTypeClass *g_class ) ;
#line 133 "/usr/include/glib-2.0/gobject/gvalue.h"
extern GValue *g_value_init(GValue *value , GType g_type ) ;
#line 136
extern void g_value_copy(GValue *src_value , GValue *dest_value ) ;
#line 139
extern GValue *g_value_reset(GValue *value ) ;
#line 141
extern void g_value_unset(GValue *value ) ;
#line 143
extern void g_value_set_instance(GValue *value , gpointer instance ) ;
#line 146
extern void g_value_init_from_instance(GValue *value , gpointer instance ) ;
#line 152
extern gboolean g_value_fits_pointer(GValue *value ) ;
#line 154
extern gpointer g_value_peek_pointer(GValue *value ) ;
#line 159
extern gboolean g_value_type_compatible(GType src_type , GType dest_type ) ;
#line 162
extern gboolean g_value_type_transformable(GType src_type , GType dest_type ) ;
#line 165
extern gboolean g_value_transform(GValue *src_value , GValue *dest_value ) ;
#line 168
extern void g_value_register_transform_func(GType src_type , GType dest_type , GValueTransform transform_func ) ;
#line 282 "/usr/include/glib-2.0/gobject/gparam.h"
extern GParamSpec *g_param_spec_ref(GParamSpec *pspec ) ;
#line 284
extern void g_param_spec_unref(GParamSpec *pspec ) ;
#line 286
extern void g_param_spec_sink(GParamSpec *pspec ) ;
#line 288
extern GParamSpec *g_param_spec_ref_sink(GParamSpec *pspec ) ;
#line 290
extern gpointer g_param_spec_get_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 293
extern void g_param_spec_set_qdata(GParamSpec *pspec , GQuark quark , gpointer data ) ;
#line 297
extern void g_param_spec_set_qdata_full(GParamSpec *pspec , GQuark quark , gpointer data ,
                                        GDestroyNotify destroy ) ;
#line 302
extern gpointer g_param_spec_steal_qdata(GParamSpec *pspec , GQuark quark ) ;
#line 305
extern GParamSpec *g_param_spec_get_redirect_target(GParamSpec *pspec ) ;
#line 308
extern void g_param_value_set_default(GParamSpec *pspec , GValue *value ) ;
#line 311
extern gboolean g_param_value_defaults(GParamSpec *pspec , GValue *value ) ;
#line 314
extern gboolean g_param_value_validate(GParamSpec *pspec , GValue *value ) ;
#line 317
extern gboolean g_param_value_convert(GParamSpec *pspec , GValue *src_value , GValue *dest_value ,
                                      gboolean strict_validation ) ;
#line 322
extern gint g_param_values_cmp(GParamSpec *pspec , GValue *value1 , GValue *value2 ) ;
#line 326
extern gchar *g_param_spec_get_name(GParamSpec *pspec ) ;
#line 328
extern gchar *g_param_spec_get_nick(GParamSpec *pspec ) ;
#line 330
extern gchar *g_param_spec_get_blurb(GParamSpec *pspec ) ;
#line 332
extern void g_value_set_param(GValue *value , GParamSpec *param ) ;
#line 335
extern GParamSpec *g_value_get_param(GValue *value ) ;
#line 337
extern GParamSpec *g_value_dup_param(GValue *value ) ;
#line 341
extern void g_value_take_param(GValue *value , GParamSpec *param ) ;
#line 344
extern void g_value_set_param_take_ownership(GValue *value , GParamSpec *param ) ;
#line 347
extern GValue *g_param_spec_get_default_value(GParamSpec *pspec ) ;
#line 350
extern GQuark g_param_spec_get_name_quark(GParamSpec *pspec ) ;
#line 398
extern GType g_param_type_register_static(gchar *name , GParamSpecTypeInfo *pspec_info ) ;
#line 402
extern gboolean g_param_spec_is_valid_name(gchar *name ) ;
#line 405
GType _g_param_type_register_static_constant(gchar *name , GParamSpecTypeInfo *pspec_info ,
                                             GType opt_type ) ;
#line 412
extern gpointer g_param_spec_internal(GType param_type , gchar *name , gchar *nick ,
                                      gchar *blurb , GParamFlags flags ) ;
#line 418
extern GParamSpecPool *g_param_spec_pool_new(gboolean type_prefixing ) ;
#line 420
extern void g_param_spec_pool_insert(GParamSpecPool *pool , GParamSpec *pspec , GType owner_type ) ;
#line 424
extern void g_param_spec_pool_remove(GParamSpecPool *pool , GParamSpec *pspec ) ;
#line 427
extern GParamSpec *g_param_spec_pool_lookup(GParamSpecPool *pool , gchar *param_name ,
                                            GType owner_type , gboolean walk_ancestors ) ;
#line 432
extern GList *g_param_spec_pool_list_owned(GParamSpecPool *pool , GType owner_type ) ;
#line 435
extern GParamSpec **g_param_spec_pool_list(GParamSpecPool *pool , GType owner_type ,
                                           guint *n_pspecs_p ) ;
#line 229 "/usr/include/glib-2.0/gobject/gclosure.h"
extern GClosure *g_cclosure_new(GCallback callback_func , gpointer user_data , GClosureNotify destroy_data ) ;
#line 233
extern GClosure *g_cclosure_new_swap(GCallback callback_func , gpointer user_data ,
                                     GClosureNotify destroy_data ) ;
#line 237
extern GClosure *g_signal_type_cclosure_new(GType itype , guint struct_offset ) ;
#line 243
extern GClosure *g_closure_ref(GClosure *closure ) ;
#line 245
extern void g_closure_sink(GClosure *closure ) ;
#line 247
extern void g_closure_unref(GClosure *closure ) ;
#line 250
extern GClosure *g_closure_new_simple(guint sizeof_closure , gpointer data ) ;
#line 253
extern void g_closure_add_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                            GClosureNotify notify_func ) ;
#line 257
extern void g_closure_remove_finalize_notifier(GClosure *closure , gpointer notify_data ,
                                               GClosureNotify notify_func ) ;
#line 261
extern void g_closure_add_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                              GClosureNotify notify_func ) ;
#line 265
extern void g_closure_remove_invalidate_notifier(GClosure *closure , gpointer notify_data ,
                                                 GClosureNotify notify_func ) ;
#line 269
extern void g_closure_add_marshal_guards(GClosure *closure , gpointer pre_marshal_data ,
                                         GClosureNotify pre_marshal_notify , gpointer post_marshal_data ,
                                         GClosureNotify post_marshal_notify ) ;
#line 275
extern void g_closure_set_marshal(GClosure *closure , GClosureMarshal marshal ) ;
#line 278
extern void g_closure_set_meta_marshal(GClosure *closure , gpointer marshal_data ,
                                       GClosureMarshal meta_marshal ) ;
#line 282
extern void g_closure_invalidate(GClosure *closure ) ;
#line 284
extern void g_closure_invoke(GClosure *closure , GValue *return_value , guint n_param_values ,
                             GValue *param_values , gpointer invocation_hint ) ;
#line 302
extern void g_cclosure_marshal_generic(GClosure *closure , GValue *return_gvalue ,
                                       guint n_param_values , GValue *param_values ,
                                       gpointer invocation_hint , gpointer marshal_data ) ;
#line 310
extern void g_cclosure_marshal_generic_va(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args_list ,
                                          gpointer marshal_data , int n_params , GType *param_types ) ;
#line 24 "/usr/include/glib-2.0/gobject/gmarshal.h"
extern void g_cclosure_marshal_VOID__VOID(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 31
extern void g_cclosure_marshal_VOID__VOIDv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 41
extern void g_cclosure_marshal_VOID__BOOLEAN(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 48
extern void g_cclosure_marshal_VOID__BOOLEANv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 58
extern void g_cclosure_marshal_VOID__CHAR(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 65
extern void g_cclosure_marshal_VOID__CHARv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 75
extern void g_cclosure_marshal_VOID__UCHAR(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 82
extern void g_cclosure_marshal_VOID__UCHARv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 92
extern void g_cclosure_marshal_VOID__INT(GClosure *closure , GValue *return_value ,
                                         guint n_param_values , GValue *param_values ,
                                         gpointer invocation_hint , gpointer marshal_data ) ;
#line 99
extern void g_cclosure_marshal_VOID__INTv(GClosure *closure , GValue *return_value ,
                                          gpointer instance , va_list args , gpointer marshal_data ,
                                          int n_params , GType *param_types ) ;
#line 109
extern void g_cclosure_marshal_VOID__UINT(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 116
extern void g_cclosure_marshal_VOID__UINTv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 126
extern void g_cclosure_marshal_VOID__LONG(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 133
extern void g_cclosure_marshal_VOID__LONGv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 143
extern void g_cclosure_marshal_VOID__ULONG(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 150
extern void g_cclosure_marshal_VOID__ULONGv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 160
extern void g_cclosure_marshal_VOID__ENUM(GClosure *closure , GValue *return_value ,
                                          guint n_param_values , GValue *param_values ,
                                          gpointer invocation_hint , gpointer marshal_data ) ;
#line 167
extern void g_cclosure_marshal_VOID__ENUMv(GClosure *closure , GValue *return_value ,
                                           gpointer instance , va_list args , gpointer marshal_data ,
                                           int n_params , GType *param_types ) ;
#line 177
extern void g_cclosure_marshal_VOID__FLAGS(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 184
extern void g_cclosure_marshal_VOID__FLAGSv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 194
extern void g_cclosure_marshal_VOID__FLOAT(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 201
extern void g_cclosure_marshal_VOID__FLOATv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 211
extern void g_cclosure_marshal_VOID__DOUBLE(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 218
extern void g_cclosure_marshal_VOID__DOUBLEv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 228
extern void g_cclosure_marshal_VOID__STRING(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 235
extern void g_cclosure_marshal_VOID__STRINGv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 245
extern void g_cclosure_marshal_VOID__PARAM(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 252
extern void g_cclosure_marshal_VOID__PARAMv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 262
extern void g_cclosure_marshal_VOID__BOXED(GClosure *closure , GValue *return_value ,
                                           guint n_param_values , GValue *param_values ,
                                           gpointer invocation_hint , gpointer marshal_data ) ;
#line 269
extern void g_cclosure_marshal_VOID__BOXEDv(GClosure *closure , GValue *return_value ,
                                            gpointer instance , va_list args , gpointer marshal_data ,
                                            int n_params , GType *param_types ) ;
#line 279
extern void g_cclosure_marshal_VOID__POINTER(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 286
extern void g_cclosure_marshal_VOID__POINTERv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 296
extern void g_cclosure_marshal_VOID__OBJECT(GClosure *closure , GValue *return_value ,
                                            guint n_param_values , GValue *param_values ,
                                            gpointer invocation_hint , gpointer marshal_data ) ;
#line 303
extern void g_cclosure_marshal_VOID__OBJECTv(GClosure *closure , GValue *return_value ,
                                             gpointer instance , va_list args , gpointer marshal_data ,
                                             int n_params , GType *param_types ) ;
#line 313
extern void g_cclosure_marshal_VOID__VARIANT(GClosure *closure , GValue *return_value ,
                                             guint n_param_values , GValue *param_values ,
                                             gpointer invocation_hint , gpointer marshal_data ) ;
#line 320
extern void g_cclosure_marshal_VOID__VARIANTv(GClosure *closure , GValue *return_value ,
                                              gpointer instance , va_list args , gpointer marshal_data ,
                                              int n_params , GType *param_types ) ;
#line 330
extern void g_cclosure_marshal_VOID__UINT_POINTER(GClosure *closure , GValue *return_value ,
                                                  guint n_param_values , GValue *param_values ,
                                                  gpointer invocation_hint , gpointer marshal_data ) ;
#line 337
extern void g_cclosure_marshal_VOID__UINT_POINTERv(GClosure *closure , GValue *return_value ,
                                                   gpointer instance , va_list args ,
                                                   gpointer marshal_data , int n_params ,
                                                   GType *param_types ) ;
#line 347
extern void g_cclosure_marshal_BOOLEAN__FLAGS(GClosure *closure , GValue *return_value ,
                                              guint n_param_values , GValue *param_values ,
                                              gpointer invocation_hint , gpointer marshal_data ) ;
#line 354
extern void g_cclosure_marshal_BOOLEAN__FLAGSv(GClosure *closure , GValue *return_value ,
                                               gpointer instance , va_list args ,
                                               gpointer marshal_data , int n_params ,
                                               GType *param_types ) ;
#line 382
extern void g_cclosure_marshal_STRING__OBJECT_POINTER(GClosure *closure , GValue *return_value ,
                                                      guint n_param_values , GValue *param_values ,
                                                      gpointer invocation_hint , gpointer marshal_data ) ;
#line 389
extern void g_cclosure_marshal_STRING__OBJECT_POINTERv(GClosure *closure , GValue *return_value ,
                                                       gpointer instance , va_list args ,
                                                       gpointer marshal_data , int n_params ,
                                                       GType *param_types ) ;
#line 399
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED(GClosure *closure , GValue *return_value ,
                                                    guint n_param_values , GValue *param_values ,
                                                    gpointer invocation_hint , gpointer marshal_data ) ;
#line 406
extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(GClosure *closure , GValue *return_value ,
                                                     gpointer instance , va_list args ,
                                                     gpointer marshal_data , int n_params ,
                                                     GType *param_types ) ;
#line 277 "/usr/include/glib-2.0/gobject/gsignal.h"
extern guint g_signal_newv(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                           GClosure *class_closure , GSignalAccumulator accumulator ,
                           gpointer accu_data , GSignalCMarshaller c_marshaller ,
                           GType return_type , guint n_params , GType *param_types ) ;
#line 288
extern guint g_signal_new_valist(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                 GClosure *class_closure , GSignalAccumulator accumulator ,
                                 gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                 GType return_type , guint n_params , va_list args ) ;
#line 299
extern guint g_signal_new(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                          guint class_offset , GSignalAccumulator accumulator , gpointer accu_data ,
                          GSignalCMarshaller c_marshaller , GType return_type , guint n_params 
                          , ...) ;
#line 310
extern guint g_signal_new_class_handler(gchar *signal_name , GType itype , GSignalFlags signal_flags ,
                                        GCallback class_handler , GSignalAccumulator accumulator ,
                                        gpointer accu_data , GSignalCMarshaller c_marshaller ,
                                        GType return_type , guint n_params  , ...) ;
#line 321
extern void g_signal_set_va_marshaller(guint signal_id , GType instance_type , GSignalCVaMarshaller va_marshaller ) ;
#line 326
extern void g_signal_emitv(GValue *instance_and_params , guint signal_id , GQuark detail ,
                           GValue *return_value ) ;
#line 331
extern void g_signal_emit_valist(gpointer instance , guint signal_id , GQuark detail ,
                                 va_list var_args ) ;
#line 336
extern void g_signal_emit(gpointer instance , guint signal_id , GQuark detail  , ...) ;
#line 341
extern void g_signal_emit_by_name(gpointer instance , gchar *detailed_signal  , ...) ;
#line 345
extern guint g_signal_lookup(gchar *name , GType itype ) ;
#line 348
extern gchar *g_signal_name(guint signal_id ) ;
#line 350
extern void g_signal_query(guint signal_id , GSignalQuery *query ) ;
#line 353
extern guint *g_signal_list_ids(GType itype , guint *n_ids ) ;
#line 356
extern gboolean g_signal_is_valid_name(gchar *name ) ;
#line 358
extern gboolean g_signal_parse_name(gchar *detailed_signal , GType itype , guint *signal_id_p ,
                                    GQuark *detail_p , gboolean force_detail_quark ) ;
#line 364
extern GSignalInvocationHint *g_signal_get_invocation_hint(gpointer instance ) ;
#line 369
extern void g_signal_stop_emission(gpointer instance , guint signal_id , GQuark detail ) ;
#line 373
extern void g_signal_stop_emission_by_name(gpointer instance , gchar *detailed_signal ) ;
#line 376
extern gulong g_signal_add_emission_hook(guint signal_id , GQuark detail , GSignalEmissionHook hook_func ,
                                         gpointer hook_data , GDestroyNotify data_destroy ) ;
#line 382
extern void g_signal_remove_emission_hook(guint signal_id , gulong hook_id ) ;
#line 388
extern gboolean g_signal_has_handler_pending(gpointer instance , guint signal_id ,
                                             GQuark detail , gboolean may_be_blocked ) ;
#line 393
extern gulong g_signal_connect_closure_by_id(gpointer instance , guint signal_id ,
                                             GQuark detail , GClosure *closure , gboolean after ) ;
#line 399
extern gulong g_signal_connect_closure(gpointer instance , gchar *detailed_signal ,
                                       GClosure *closure , gboolean after ) ;
#line 404
extern gulong g_signal_connect_data(gpointer instance , gchar *detailed_signal , GCallback c_handler ,
                                    gpointer data , GClosureNotify destroy_data ,
                                    GConnectFlags connect_flags ) ;
#line 411
extern void g_signal_handler_block(gpointer instance , gulong handler_id ) ;
#line 414
extern void g_signal_handler_unblock(gpointer instance , gulong handler_id ) ;
#line 417
extern void g_signal_handler_disconnect(gpointer instance , gulong handler_id ) ;
#line 420
extern gboolean g_signal_handler_is_connected(gpointer instance , gulong handler_id ) ;
#line 423
extern gulong g_signal_handler_find(gpointer instance , GSignalMatchType mask , guint signal_id ,
                                    GQuark detail , GClosure *closure , gpointer func ,
                                    gpointer data ) ;
#line 431
extern guint g_signal_handlers_block_matched(gpointer instance , GSignalMatchType mask ,
                                             guint signal_id , GQuark detail , GClosure *closure ,
                                             gpointer func , gpointer data ) ;
#line 439
extern guint g_signal_handlers_unblock_matched(gpointer instance , GSignalMatchType mask ,
                                               guint signal_id , GQuark detail , GClosure *closure ,
                                               gpointer func , gpointer data ) ;
#line 447
extern guint g_signal_handlers_disconnect_matched(gpointer instance , GSignalMatchType mask ,
                                                  guint signal_id , GQuark detail ,
                                                  GClosure *closure , gpointer func ,
                                                  gpointer data ) ;
#line 456
extern void g_clear_signal_handler(gulong *handler_id_ptr , gpointer instance ) ;
#line 475
extern void g_signal_override_class_closure(guint signal_id , GType instance_type ,
                                            GClosure *class_closure ) ;
#line 479
extern void g_signal_override_class_handler(gchar *signal_name , GType instance_type ,
                                            GCallback class_handler ) ;
#line 483
extern void g_signal_chain_from_overridden(GValue *instance_and_params , GValue *return_value ) ;
#line 486
extern void g_signal_chain_from_overridden_handler(gpointer instance  , ...) ;
#line 622
extern gboolean g_signal_accumulator_true_handled(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                  GValue *handler_return , gpointer dummy ) ;
#line 628
extern gboolean g_signal_accumulator_first_wins(GSignalInvocationHint *ihint , GValue *return_accu ,
                                                GValue *handler_return , gpointer dummy ) ;
#line 635
extern void g_signal_handlers_destroy(gpointer instance ) ;
#line 636
void _g_signals_destroy(GType itype ) ;
#line 328 "/usr/include/glib-2.0/gobject/glib-types.h"
extern GType g_date_get_type(void) ;
#line 330
extern GType g_strv_get_type(void) ;
#line 332
extern GType g_gstring_get_type(void) ;
#line 334
extern GType g_hash_table_get_type(void) ;
#line 336
extern GType g_array_get_type(void) ;
#line 338
extern GType g_byte_array_get_type(void) ;
#line 340
extern GType g_ptr_array_get_type(void) ;
#line 342
extern GType g_bytes_get_type(void) ;
#line 344
extern GType g_variant_type_get_gtype(void) ;
#line 346
extern GType g_regex_get_type(void) ;
#line 348
extern GType g_match_info_get_type(void) ;
#line 350
extern GType g_error_get_type(void) ;
#line 352
extern GType g_date_time_get_type(void) ;
#line 354
extern GType g_time_zone_get_type(void) ;
#line 356
extern GType g_io_channel_get_type(void) ;
#line 358
extern GType g_io_condition_get_type(void) ;
#line 360
extern GType g_variant_builder_get_type(void) ;
#line 362
extern GType g_variant_dict_get_type(void) ;
#line 364
extern GType g_key_file_get_type(void) ;
#line 366
extern GType g_main_loop_get_type(void) ;
#line 368
extern GType g_main_context_get_type(void) ;
#line 370
extern GType g_source_get_type(void) ;
#line 372
extern GType g_pollfd_get_type(void) ;
#line 374
extern GType g_thread_get_type(void) ;
#line 376
extern GType g_checksum_get_type(void) ;
#line 378
extern GType g_markup_parse_context_get_type(void) ;
#line 380
extern GType g_mapped_file_get_type(void) ;
#line 382
extern GType g_option_group_get_type(void) ;
#line 384
extern GType g_uri_get_type(void) ;
#line 386
extern GType g_tree_get_type(void) ;
#line 388
extern GType g_pattern_spec_get_type(void) ;
#line 391
extern GType g_variant_get_gtype(void) ;
#line 70 "/usr/include/glib-2.0/gobject/gboxed.h"
extern gpointer g_boxed_copy(GType boxed_type , gconstpointer src_boxed ) ;
#line 73
extern void g_boxed_free(GType boxed_type , gpointer boxed ) ;
#line 76
extern void g_value_set_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 79
extern void g_value_set_static_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 82
extern void g_value_take_boxed(GValue *value , gconstpointer v_boxed ) ;
#line 85
extern void g_value_set_boxed_take_ownership(GValue *value , gconstpointer v_boxed ) ;
#line 88
extern gpointer g_value_get_boxed(GValue *value ) ;
#line 90
extern gpointer g_value_dup_boxed(GValue *value ) ;
#line 95
extern GType g_boxed_type_register_static(gchar *name , GBoxedCopyFunc boxed_copy ,
                                          GBoxedFreeFunc boxed_free ) ;
#line 116
extern GType g_closure_get_type(void) ;
#line 118
extern GType g_value_get_type(void) ;
#line 407 "/usr/include/glib-2.0/gobject/gobject.h"
extern GType g_initially_unowned_get_type(void) ;
#line 409
extern void g_object_class_install_property(GObjectClass *oclass , guint property_id ,
                                            GParamSpec *pspec ) ;
#line 413
extern GParamSpec *g_object_class_find_property(GObjectClass *oclass , gchar *property_name ) ;
#line 416
extern GParamSpec **g_object_class_list_properties(GObjectClass *oclass , guint *n_properties ) ;
#line 419
extern void g_object_class_override_property(GObjectClass *oclass , guint property_id ,
                                             gchar *name ) ;
#line 423
extern void g_object_class_install_properties(GObjectClass *oclass , guint n_pspecs ,
                                              GParamSpec **pspecs ) ;
#line 428
extern void g_object_interface_install_property(gpointer g_iface , GParamSpec *pspec ) ;
#line 431
extern GParamSpec *g_object_interface_find_property(gpointer g_iface , gchar *property_name ) ;
#line 434
extern GParamSpec **g_object_interface_list_properties(gpointer g_iface , guint *n_properties_p ) ;
#line 438
extern GType g_object_get_type(void) ;
#line 440
extern gpointer g_object_new(GType object_type , gchar *first_property_name  , ...) ;
#line 444
extern GObject *g_object_new_with_properties(GType object_type , guint n_properties ,
                                             char const   *names[] , GValue values[] ) ;
#line 452
extern gpointer g_object_newv(GType object_type , guint n_parameters , GParameter *parameters ) ;
#line 459
extern GObject *g_object_new_valist(GType object_type , gchar *first_property_name ,
                                    va_list var_args ) ;
#line 463
extern void g_object_set(gpointer object , gchar *first_property_name  , ...) ;
#line 467
extern void g_object_get(gpointer object , gchar *first_property_name  , ...) ;
#line 471
extern gpointer g_object_connect(gpointer object , gchar *signal_spec  , ...) ;
#line 475
extern void g_object_disconnect(gpointer object , gchar *signal_spec  , ...) ;
#line 479
extern void g_object_setv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 484
extern void g_object_set_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 488
extern void g_object_getv(GObject *object , guint n_properties , gchar *names[] ,
                          GValue values[] ) ;
#line 493
extern void g_object_get_valist(GObject *object , gchar *first_property_name , va_list var_args ) ;
#line 497
extern void g_object_set_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 501
extern void g_object_get_property(GObject *object , gchar *property_name , GValue *value ) ;
#line 505
extern void g_object_freeze_notify(GObject *object ) ;
#line 507
extern void g_object_notify(GObject *object , gchar *property_name ) ;
#line 510
extern void g_object_notify_by_pspec(GObject *object , GParamSpec *pspec ) ;
#line 513
extern void g_object_thaw_notify(GObject *object ) ;
#line 515
extern gboolean g_object_is_floating(gpointer object ) ;
#line 517
extern gpointer g_object_ref_sink(gpointer object ) ;
#line 519
extern gpointer g_object_take_ref(gpointer object ) ;
#line 521
extern gpointer g_object_ref(gpointer object ) ;
#line 523
extern void g_object_unref(gpointer object ) ;
#line 525
extern void g_object_weak_ref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 529
extern void g_object_weak_unref(GObject *object , GWeakNotify notify , gpointer data ) ;
#line 533
extern void g_object_add_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 536
extern void g_object_remove_weak_pointer(GObject *object , gpointer *weak_pointer_location ) ;
#line 564
extern void g_object_add_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 568
extern void g_object_remove_toggle_ref(GObject *object , GToggleNotify notify , gpointer data ) ;
#line 573
extern gpointer g_object_get_qdata(GObject *object , GQuark quark ) ;
#line 576
extern void g_object_set_qdata(GObject *object , GQuark quark , gpointer data ) ;
#line 580
extern void g_object_set_qdata_full(GObject *object , GQuark quark , gpointer data ,
                                    GDestroyNotify destroy ) ;
#line 585
extern gpointer g_object_steal_qdata(GObject *object , GQuark quark ) ;
#line 589
extern gpointer g_object_dup_qdata(GObject *object , GQuark quark , GDuplicateFunc dup_func ,
                                   gpointer user_data ) ;
#line 594
extern gboolean g_object_replace_qdata(GObject *object , GQuark quark , gpointer oldval ,
                                       gpointer newval , GDestroyNotify destroy ,
                                       GDestroyNotify *old_destroy ) ;
#line 602
extern gpointer g_object_get_data(GObject *object , gchar *key ) ;
#line 605
extern void g_object_set_data(GObject *object , gchar *key , gpointer data ) ;
#line 609
extern void g_object_set_data_full(GObject *object , gchar *key , gpointer data ,
                                   GDestroyNotify destroy ) ;
#line 614
extern gpointer g_object_steal_data(GObject *object , gchar *key ) ;
#line 618
extern gpointer g_object_dup_data(GObject *object , gchar *key , GDuplicateFunc dup_func ,
                                  gpointer user_data ) ;
#line 623
extern gboolean g_object_replace_data(GObject *object , gchar *key , gpointer oldval ,
                                      gpointer newval , GDestroyNotify destroy , GDestroyNotify *old_destroy ) ;
#line 632
extern void g_object_watch_closure(GObject *object , GClosure *closure ) ;
#line 635
extern GClosure *g_cclosure_new_object(GCallback callback_func , GObject *object ) ;
#line 638
extern GClosure *g_cclosure_new_object_swap(GCallback callback_func , GObject *object ) ;
#line 641
extern GClosure *g_closure_new_object(guint sizeof_closure , GObject *object ) ;
#line 644
extern void g_value_set_object(GValue *value , gpointer v_object ) ;
#line 647
extern gpointer g_value_get_object(GValue *value ) ;
#line 649
extern gpointer g_value_dup_object(GValue *value ) ;
#line 651
extern gulong g_signal_connect_object(gpointer instance , gchar *detailed_signal ,
                                      GCallback c_handler , gpointer gobject , GConnectFlags connect_flags ) ;
#line 659
extern void g_object_force_floating(GObject *object ) ;
#line 661
extern void g_object_run_dispose(GObject *object ) ;
#line 665
extern void g_value_take_object(GValue *value , gpointer v_object ) ;
#line 668
extern void g_value_set_object_take_ownership(GValue *value , gpointer v_object ) ;
#line 672
extern gsize g_object_compat_control(gsize what , gpointer data ) ;
#line 702
extern void g_clear_object(GObject **object_ptr ) ;
#line 742 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_object(GObject **object_ptr , GObject *new_object ) 
{ 
  GObject *old_object ;
  gpointer __cil_tmp4 ;

  {
#line 745
  old_object = *object_ptr;
#line 753
  if (old_object == new_object) {
#line 754
    return (0);
  }
#line 756
  if (new_object != (void *)0) {
    {
#line 757
    __cil_tmp4 = g_object_ref(new_object);
    }
  }
#line 759
  *object_ptr = new_object;
#line 761
  if (old_object != (void *)0) {
    {
#line 762
    g_object_unref(old_object);
    }
  }
#line 764
  return (! 0);
}
}
#line 808 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_assert_finalize_object(GObject *object ) 
{ 
  gpointer weak_pointer ;
  long __cil_tmp3 ;
  long __cil_tmp4 ;

  {
#line 810
  weak_pointer = object;
  {
#line 812
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 812
    __cil_tmp3 = __builtin_expect((long )0, (long )1);
    }
#line 812
    if (__cil_tmp3) {

    } else {
      {
#line 812
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          812, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
      }
    }
#line 812
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  g_object_add_weak_pointer(object, & weak_pointer);
#line 814
  g_object_unref(weak_pointer);
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 815
    __cil_tmp4 = __builtin_expect((long )0, (long )1);
    }
#line 815
    if (__cil_tmp4) {

    } else {
      {
#line 815
      g_assertion_message((char const   *)((gchar *)0), "/usr/include/glib-2.0/gobject/gobject.h",
                          815, (char const   *)"g_assert_finalize_object\312\001@",
                          "\'weak_pointer\' should be NULL");
      }
    }
#line 815
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  return;
}
}
#line 843 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static void g_clear_weak_pointer(gpointer *weak_pointer_location ) 
{ 
  GObject *object ;

  {
#line 845
  object = (GObject *)*weak_pointer_location;
#line 847
  if (object != (void *)0) {
    {
#line 849
    g_object_remove_weak_pointer(object, weak_pointer_location);
#line 850
    *weak_pointer_location = (void *)0;
    }
  }
  return;
}
}
#line 898 "/usr/include/glib-2.0/gobject/gobject.h"
__inline static gboolean g_set_weak_pointer(gpointer *weak_pointer_location , GObject *new_object ) 
{ 
  GObject *old_object ;

  {
#line 901
  old_object = (GObject *)*weak_pointer_location;
#line 908
  if (old_object == new_object) {
#line 909
    return (0);
  }
#line 911
  if (old_object != (void *)0) {
    {
#line 912
    g_object_remove_weak_pointer(old_object, weak_pointer_location);
    }
  }
#line 914
  *weak_pointer_location = new_object;
#line 916
  if (new_object != (void *)0) {
    {
#line 917
    g_object_add_weak_pointer(new_object, weak_pointer_location);
    }
  }
#line 919
  return (! 0);
}
}
#line 934
extern void g_weak_ref_init(GWeakRef *weak_ref , gpointer object ) ;
#line 937
extern void g_weak_ref_clear(GWeakRef *weak_ref ) ;
#line 939
extern gpointer g_weak_ref_get(GWeakRef *weak_ref ) ;
#line 941
extern void g_weak_ref_set(GWeakRef *weak_ref , gpointer object ) ;
#line 106 "/usr/include/glib-2.0/gobject/gbinding.h"
extern GType g_binding_flags_get_type(void) ;
#line 108
extern GType g_binding_get_type(void) ;
#line 111
extern GBindingFlags g_binding_get_flags(GBinding *binding ) ;
#line 113
extern GObject *g_binding_get_source(GBinding *binding ) ;
#line 115
extern GObject *g_binding_dup_source(GBinding *binding ) ;
#line 117
extern GObject *g_binding_get_target(GBinding *binding ) ;
#line 119
extern GObject *g_binding_dup_target(GBinding *binding ) ;
#line 121
extern gchar *g_binding_get_source_property(GBinding *binding ) ;
#line 123
extern gchar *g_binding_get_target_property(GBinding *binding ) ;
#line 125
extern void g_binding_unbind(GBinding *binding ) ;
#line 128
extern GBinding *g_object_bind_property(gpointer source , gchar *source_property ,
                                        gpointer target , gchar *target_property ,
                                        GBindingFlags flags ) ;
#line 134
extern GBinding *g_object_bind_property_full(gpointer source , gchar *source_property ,
                                             gpointer target , gchar *target_property ,
                                             GBindingFlags flags , GBindingTransformFunc transform_to ,
                                             GBindingTransformFunc transform_from ,
                                             gpointer user_data , GDestroyNotify notify ) ;
#line 144
extern GBinding *g_object_bind_property_with_closures(gpointer source , gchar *source_property ,
                                                      gpointer target , gchar *target_property ,
                                                      GBindingFlags flags , GClosure *transform_to ,
                                                      GClosure *transform_from ) ;
#line 50 "/usr/include/glib-2.0/gobject/gbindinggroup.h"
extern GType g_binding_group_get_type(void) ;
#line 52
extern GBindingGroup *g_binding_group_new(void) ;
#line 54
extern gpointer g_binding_group_dup_source(GBindingGroup *self ) ;
#line 56
extern void g_binding_group_set_source(GBindingGroup *self , gpointer source ) ;
#line 59
extern void g_binding_group_bind(GBindingGroup *self , gchar *source_property , gpointer target ,
                                 gchar *target_property , GBindingFlags flags ) ;
#line 65
extern void g_binding_group_bind_full(GBindingGroup *self , gchar *source_property ,
                                      gpointer target , gchar *target_property , GBindingFlags flags ,
                                      GBindingTransformFunc transform_to , GBindingTransformFunc transform_from ,
                                      gpointer user_data , GDestroyNotify user_data_destroy ) ;
#line 75
extern void g_binding_group_bind_with_closures(GBindingGroup *self , gchar *source_property ,
                                               gpointer target , gchar *target_property ,
                                               GBindingFlags flags , GClosure *transform_to ,
                                               GClosure *transform_from ) ;
#line 219 "/usr/include/glib-2.0/gobject/genums.h"
extern GEnumValue *g_enum_get_value(GEnumClass *enum_class , gint value ) ;
#line 222
extern GEnumValue *g_enum_get_value_by_name(GEnumClass *enum_class , gchar *name ) ;
#line 225
extern GEnumValue *g_enum_get_value_by_nick(GEnumClass *enum_class , gchar *nick ) ;
#line 228
extern GFlagsValue *g_flags_get_first_value(GFlagsClass *flags_class , guint value ) ;
#line 231
extern GFlagsValue *g_flags_get_value_by_name(GFlagsClass *flags_class , gchar *name ) ;
#line 234
extern GFlagsValue *g_flags_get_value_by_nick(GFlagsClass *flags_class , gchar *nick ) ;
#line 237
extern gchar *g_enum_to_string(GType g_enum_type , gint value ) ;
#line 240
extern gchar *g_flags_to_string(GType flags_type , guint value ) ;
#line 243
extern void g_value_set_enum(GValue *value , gint v_enum ) ;
#line 246
extern gint g_value_get_enum(GValue *value ) ;
#line 248
extern void g_value_set_flags(GValue *value , guint v_flags ) ;
#line 251
extern guint g_value_get_flags(GValue *value ) ;
#line 260
extern GType g_enum_register_static(gchar *name , GEnumValue *const_static_values ) ;
#line 263
extern GType g_flags_register_static(gchar *name , GFlagsValue *const_static_values ) ;
#line 269
extern void g_enum_complete_type_info(GType g_enum_type , GTypeInfo *info , GEnumValue *const_values ) ;
#line 273
extern void g_flags_complete_type_info(GType g_flags_type , GTypeInfo *info , GFlagsValue *const_values ) ;
#line 12 "/usr/include/glib-2.0/gobject/glib-enumtypes.h"
extern GType g_unicode_type_get_type(void) ;
#line 14
extern GType g_unicode_break_type_get_type(void) ;
#line 16
extern GType g_unicode_script_get_type(void) ;
#line 18
extern GType g_normalize_mode_get_type(void) ;
#line 988 "/usr/include/glib-2.0/gobject/gparamspecs.h"
extern GParamSpec *g_param_spec_char(gchar *name , gchar *nick , gchar *blurb , gint8 minimum ,
                                     gint8 maximum , gint8 default_value , GParamFlags flags ) ;
#line 996
extern GParamSpec *g_param_spec_uchar(gchar *name , gchar *nick , gchar *blurb , guint8 minimum ,
                                      guint8 maximum , guint8 default_value , GParamFlags flags ) ;
#line 1004
extern GParamSpec *g_param_spec_boolean(gchar *name , gchar *nick , gchar *blurb ,
                                        gboolean default_value , GParamFlags flags ) ;
#line 1010
extern GParamSpec *g_param_spec_int(gchar *name , gchar *nick , gchar *blurb , gint minimum ,
                                    gint maximum , gint default_value , GParamFlags flags ) ;
#line 1018
extern GParamSpec *g_param_spec_uint(gchar *name , gchar *nick , gchar *blurb , guint minimum ,
                                     guint maximum , guint default_value , GParamFlags flags ) ;
#line 1026
extern GParamSpec *g_param_spec_long(gchar *name , gchar *nick , gchar *blurb , glong minimum ,
                                     glong maximum , glong default_value , GParamFlags flags ) ;
#line 1034
extern GParamSpec *g_param_spec_ulong(gchar *name , gchar *nick , gchar *blurb , gulong minimum ,
                                      gulong maximum , gulong default_value , GParamFlags flags ) ;
#line 1042
extern GParamSpec *g_param_spec_int64(gchar *name , gchar *nick , gchar *blurb , gint64 minimum ,
                                      gint64 maximum , gint64 default_value , GParamFlags flags ) ;
#line 1050
extern GParamSpec *g_param_spec_uint64(gchar *name , gchar *nick , gchar *blurb ,
                                       guint64 minimum , guint64 maximum , guint64 default_value ,
                                       GParamFlags flags ) ;
#line 1058
extern GParamSpec *g_param_spec_unichar(gchar *name , gchar *nick , gchar *blurb ,
                                        gunichar default_value , GParamFlags flags ) ;
#line 1064
extern GParamSpec *g_param_spec_enum(gchar *name , gchar *nick , gchar *blurb , GType enum_type ,
                                     gint default_value , GParamFlags flags ) ;
#line 1071
extern GParamSpec *g_param_spec_flags(gchar *name , gchar *nick , gchar *blurb , GType flags_type ,
                                      guint default_value , GParamFlags flags ) ;
#line 1078
extern GParamSpec *g_param_spec_float(gchar *name , gchar *nick , gchar *blurb , gfloat minimum ,
                                      gfloat maximum , gfloat default_value , GParamFlags flags ) ;
#line 1086
extern GParamSpec *g_param_spec_double(gchar *name , gchar *nick , gchar *blurb ,
                                       gdouble minimum , gdouble maximum , gdouble default_value ,
                                       GParamFlags flags ) ;
#line 1094
extern GParamSpec *g_param_spec_string(gchar *name , gchar *nick , gchar *blurb ,
                                       gchar *default_value , GParamFlags flags ) ;
#line 1100
extern GParamSpec *g_param_spec_param(gchar *name , gchar *nick , gchar *blurb , GType param_type ,
                                      GParamFlags flags ) ;
#line 1106
extern GParamSpec *g_param_spec_boxed(gchar *name , gchar *nick , gchar *blurb , GType boxed_type ,
                                      GParamFlags flags ) ;
#line 1112
extern GParamSpec *g_param_spec_pointer(gchar *name , gchar *nick , gchar *blurb ,
                                        GParamFlags flags ) ;
#line 1117
extern GParamSpec *g_param_spec_value_array(gchar *name , gchar *nick , gchar *blurb ,
                                            GParamSpec *element_spec , GParamFlags flags ) ;
#line 1123
extern GParamSpec *g_param_spec_object(gchar *name , gchar *nick , gchar *blurb ,
                                       GType object_type , GParamFlags flags ) ;
#line 1129
extern GParamSpec *g_param_spec_override(gchar *name , GParamSpec *overridden ) ;
#line 1132
extern GParamSpec *g_param_spec_gtype(gchar *name , gchar *nick , gchar *blurb , GType is_a_type ,
                                      GParamFlags flags ) ;
#line 1138
extern GParamSpec *g_param_spec_variant(gchar *name , gchar *nick , gchar *blurb ,
                                        GVariantType *type , GVariant *default_value ,
                                        GParamFlags flags ) ;
#line 1169
extern GType *g_param_spec_types ;
#line 50 "/usr/include/glib-2.0/gobject/gsignalgroup.h"
extern GType g_signal_group_get_type(void) ;
#line 52
extern GSignalGroup *g_signal_group_new(GType target_type ) ;
#line 54
extern void g_signal_group_set_target(GSignalGroup *self , gpointer target ) ;
#line 57
extern gpointer g_signal_group_dup_target(GSignalGroup *self ) ;
#line 59
extern void g_signal_group_block(GSignalGroup *self ) ;
#line 61
extern void g_signal_group_unblock(GSignalGroup *self ) ;
#line 63
extern void g_signal_group_connect_object(GSignalGroup *self , gchar *detailed_signal ,
                                          GCallback c_handler , gpointer object ,
                                          GConnectFlags flags ) ;
#line 69
extern void g_signal_group_connect_data(GSignalGroup *self , gchar *detailed_signal ,
                                        GCallback c_handler , gpointer data , GClosureNotify notify ,
                                        GConnectFlags flags ) ;
#line 76
extern void g_signal_group_connect(GSignalGroup *self , gchar *detailed_signal , GCallback c_handler ,
                                   gpointer data ) ;
#line 81
extern void g_signal_group_connect_after(GSignalGroup *self , gchar *detailed_signal ,
                                         GCallback c_handler , gpointer data ) ;
#line 86
extern void g_signal_group_connect_swapped(GSignalGroup *self , gchar *detailed_signal ,
                                           GCallback c_handler , gpointer data ) ;
#line 30 "/usr/include/glib-2.0/gobject/gsourceclosure.h"
extern void g_source_set_closure(GSource *source , GClosure *closure ) ;
#line 34
extern void g_source_set_dummy_callback(GSource *source ) ;
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_clear_GTypeModule(GTypeModule *_ptr ) 
{ 


  {
#line 39
  if (_ptr) {
    {
#line 39
    g_object_unref((GTypeModule *)_ptr);
    }
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_autoptr_cleanup_GTypeModule(GTypeModule **_ptr ) 
{ 


  {
  {
#line 39
  glib_autoptr_clear_GTypeModule(*_ptr);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_listautoptr_cleanup_GTypeModule(GList **_l ) 
{ 


  {
  {
#line 39
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_slistautoptr_cleanup_GTypeModule(GSList **_l ) 
{ 


  {
  {
#line 39
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gobject/gtypemodule.h"
__inline static void glib_queueautoptr_cleanup_GTypeModule(GQueue **_q ) 
{ 


  {
#line 39
  if (*_q) {
    {
#line 39
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_object_unref)));
    }
  }
  return;
}
}
#line 270
extern GType g_type_module_get_type(void) ;
#line 272
extern gboolean g_type_module_use(GTypeModule *module ) ;
#line 274
extern void g_type_module_unuse(GTypeModule *module ) ;
#line 276
extern void g_type_module_set_name(GTypeModule *module , gchar *name ) ;
#line 279
extern GType g_type_module_register_type(GTypeModule *module , GType parent_type ,
                                         gchar *type_name , GTypeInfo *type_info ,
                                         GTypeFlags flags ) ;
#line 285
extern void g_type_module_add_interface(GTypeModule *module , GType instance_type ,
                                        GType interface_type , GInterfaceInfo *interface_info ) ;
#line 290
extern GType g_type_module_register_enum(GTypeModule *module , gchar *name , GEnumValue *const_static_values ) ;
#line 294
extern GType g_type_module_register_flags(GTypeModule *module , gchar *name , GFlagsValue *const_static_values ) ;
#line 116 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
extern GType g_type_plugin_get_type(void) ;
#line 118
extern void g_type_plugin_use(GTypePlugin *plugin ) ;
#line 120
extern void g_type_plugin_unuse(GTypePlugin *plugin ) ;
#line 122
extern void g_type_plugin_complete_type_info(GTypePlugin *plugin , GType g_type ,
                                             GTypeInfo *info , GTypeValueTable *value_table ) ;
#line 127
extern void g_type_plugin_complete_interface_info(GTypePlugin *plugin , GType instance_type ,
                                                  GType interface_type , GInterfaceInfo *info ) ;
#line 60 "/usr/include/glib-2.0/gobject/gvaluearray.h"
extern GType g_value_array_get_type(void) ;
#line 63
extern GValue *g_value_array_get_nth(GValueArray *value_array , guint index_ ) ;
#line 67
extern GValueArray *g_value_array_new(guint n_prealloced ) ;
#line 70
extern void g_value_array_free(GValueArray *value_array ) ;
#line 73
extern GValueArray *g_value_array_copy(GValueArray *value_array ) ;
#line 76
extern GValueArray *g_value_array_prepend(GValueArray *value_array , GValue *value ) ;
#line 80
extern GValueArray *g_value_array_append(GValueArray *value_array , GValue *value ) ;
#line 84
extern GValueArray *g_value_array_insert(GValueArray *value_array , guint index_ ,
                                         GValue *value ) ;
#line 89
extern GValueArray *g_value_array_remove(GValueArray *value_array , guint index_ ) ;
#line 93
extern GValueArray *g_value_array_sort(GValueArray *value_array , GCompareFunc compare_func ) ;
#line 97
extern GValueArray *g_value_array_sort_with_data(GValueArray *value_array , GCompareDataFunc compare_func ,
                                                 gpointer user_data ) ;
#line 192 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
extern void g_value_set_char(GValue *value , gchar v_char ) ;
#line 195
extern gchar g_value_get_char(GValue *value ) ;
#line 197
extern void g_value_set_schar(GValue *value , gint8 v_char ) ;
#line 200
extern gint8 g_value_get_schar(GValue *value ) ;
#line 202
extern void g_value_set_uchar(GValue *value , guchar v_uchar ) ;
#line 205
extern guchar g_value_get_uchar(GValue *value ) ;
#line 207
extern void g_value_set_boolean(GValue *value , gboolean v_boolean ) ;
#line 210
extern gboolean g_value_get_boolean(GValue *value ) ;
#line 212
extern void g_value_set_int(GValue *value , gint v_int ) ;
#line 215
extern gint g_value_get_int(GValue *value ) ;
#line 217
extern void g_value_set_uint(GValue *value , guint v_uint ) ;
#line 220
extern guint g_value_get_uint(GValue *value ) ;
#line 222
extern void g_value_set_long(GValue *value , glong v_long ) ;
#line 225
extern glong g_value_get_long(GValue *value ) ;
#line 227
extern void g_value_set_ulong(GValue *value , gulong v_ulong ) ;
#line 230
extern gulong g_value_get_ulong(GValue *value ) ;
#line 232
extern void g_value_set_int64(GValue *value , gint64 v_int64 ) ;
#line 235
extern gint64 g_value_get_int64(GValue *value ) ;
#line 237
extern void g_value_set_uint64(GValue *value , guint64 v_uint64 ) ;
#line 240
extern guint64 g_value_get_uint64(GValue *value ) ;
#line 242
extern void g_value_set_float(GValue *value , gfloat v_float ) ;
#line 245
extern gfloat g_value_get_float(GValue *value ) ;
#line 247
extern void g_value_set_double(GValue *value , gdouble v_double ) ;
#line 250
extern gdouble g_value_get_double(GValue *value ) ;
#line 252
extern void g_value_set_string(GValue *value , gchar *v_string ) ;
#line 255
extern void g_value_set_static_string(GValue *value , gchar *v_string ) ;
#line 258
extern void g_value_set_interned_string(GValue *value , gchar *v_string ) ;
#line 261
extern gchar *g_value_get_string(GValue *value ) ;
#line 263
extern gchar *g_value_dup_string(GValue *value ) ;
#line 265
extern void g_value_set_pointer(GValue *value , gpointer v_pointer ) ;
#line 268
extern gpointer g_value_get_pointer(GValue *value ) ;
#line 270
extern GType g_gtype_get_type(void) ;
#line 272
extern void g_value_set_gtype(GValue *value , GType v_gtype ) ;
#line 275
extern GType g_value_get_gtype(GValue *value ) ;
#line 277
extern void g_value_set_variant(GValue *value , GVariant *variant ) ;
#line 280
extern void g_value_take_variant(GValue *value , GVariant *variant ) ;
#line 283
extern GVariant *g_value_get_variant(GValue *value ) ;
#line 285
extern GVariant *g_value_dup_variant(GValue *value ) ;
#line 290
extern GType g_pointer_type_register_static(gchar *name ) ;
#line 294
extern gchar *g_strdup_value_contents(GValue *value ) ;
#line 298
extern void g_value_take_string(GValue *value , gchar *v_string ) ;
#line 301
extern void g_value_set_string_take_ownership(GValue *value , gchar *v_string ) ;
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GClosure(GClosure *_ptr ) 
{ 


  {
#line 24
  if (_ptr) {
    {
#line 24
    g_closure_unref((GClosure *)_ptr);
    }
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GClosure(GClosure **_ptr ) 
{ 


  {
  {
#line 24
  glib_autoptr_clear_GClosure(*_ptr);
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GClosure(GList **_l ) 
{ 


  {
  {
#line 24
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GClosure(GSList **_l ) 
{ 


  {
  {
#line 24
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GClosure(GQueue **_q ) 
{ 


  {
#line 24
  if (*_q) {
    {
#line 24
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_closure_unref)));
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GEnumClass(GEnumClass *_ptr ) 
{ 


  {
#line 25
  if (_ptr) {
    {
#line 25
    g_type_class_unref((GEnumClass *)_ptr);
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEnumClass(GEnumClass **_ptr ) 
{ 


  {
  {
#line 25
  glib_autoptr_clear_GEnumClass(*_ptr);
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GEnumClass(GList **_l ) 
{ 


  {
  {
#line 25
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GEnumClass(GSList **_l ) 
{ 


  {
  {
#line 25
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GEnumClass(GQueue **_q ) 
{ 


  {
#line 25
  if (*_q) {
    {
#line 25
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_type_class_unref)));
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GFlagsClass(GFlagsClass *_ptr ) 
{ 


  {
#line 26
  if (_ptr) {
    {
#line 26
    g_type_class_unref((GFlagsClass *)_ptr);
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFlagsClass(GFlagsClass **_ptr ) 
{ 


  {
  {
#line 26
  glib_autoptr_clear_GFlagsClass(*_ptr);
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GObject(GObject *_ptr ) 
{ 


  {
#line 27
  if (_ptr) {
    {
#line 27
    g_object_unref((GObject *)_ptr);
    }
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GObject(GObject **_ptr ) 
{ 


  {
  {
#line 27
  glib_autoptr_clear_GObject(*_ptr);
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GInitiallyUnowned(GInitiallyUnowned *_ptr ) 
{ 


  {
#line 28
  if (_ptr) {
    {
#line 28
    g_object_unref((GInitiallyUnowned *)_ptr);
    }
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInitiallyUnowned(GInitiallyUnowned **_ptr ) 
{ 


  {
  {
#line 28
  glib_autoptr_clear_GInitiallyUnowned(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GParamSpec(GParamSpec *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_param_spec_unref((GParamSpec *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GParamSpec(GParamSpec **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GParamSpec(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GParamSpec(GList **_l ) 
{ 


  {
  {
#line 29
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GParamSpec(GSList **_l ) 
{ 


  {
  {
#line 29
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GParamSpec(GQueue **_q ) 
{ 


  {
#line 29
  if (*_q) {
    {
#line 29
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_param_spec_unref)));
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_clear_GTypeClass(GTypeClass *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_type_class_unref((GTypeClass *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTypeClass(GTypeClass **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GTypeClass(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gobject/gobject-autocleanups.h"
__inline static void glib_auto_cleanup_GValue(GValue *_ptr ) 
{ 


  {
  {
#line 31
  g_value_unset(_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gaction.h"
extern GType g_action_get_type(void) ;
#line 63
extern gchar *g_action_get_name(GAction *action ) ;
#line 65
extern GVariantType *g_action_get_parameter_type(GAction *action ) ;
#line 67
extern GVariantType *g_action_get_state_type(GAction *action ) ;
#line 69
extern GVariant *g_action_get_state_hint(GAction *action ) ;
#line 72
extern gboolean g_action_get_enabled(GAction *action ) ;
#line 74
extern GVariant *g_action_get_state(GAction *action ) ;
#line 77
extern void g_action_change_state(GAction *action , GVariant *value ) ;
#line 80
extern void g_action_activate(GAction *action , GVariant *parameter ) ;
#line 84
extern gboolean g_action_name_is_valid(gchar *action_name ) ;
#line 87
extern gboolean g_action_parse_detailed_name(gchar *detailed_name , gchar **action_name ,
                                             GVariant **target_value , GError **error ) ;
#line 93
extern gchar *g_action_print_detailed_name(gchar *action_name , GVariant *target_value ) ;
#line 98 "/usr/include/glib-2.0/gio/gactiongroup.h"
extern GType g_action_group_get_type(void) ;
#line 101
extern gboolean g_action_group_has_action(GActionGroup *action_group , gchar *action_name ) ;
#line 104
extern gchar **g_action_group_list_actions(GActionGroup *action_group ) ;
#line 107
extern GVariantType *g_action_group_get_action_parameter_type(GActionGroup *action_group ,
                                                              gchar *action_name ) ;
#line 110
extern GVariantType *g_action_group_get_action_state_type(GActionGroup *action_group ,
                                                          gchar *action_name ) ;
#line 113
extern GVariant *g_action_group_get_action_state_hint(GActionGroup *action_group ,
                                                      gchar *action_name ) ;
#line 117
extern gboolean g_action_group_get_action_enabled(GActionGroup *action_group , gchar *action_name ) ;
#line 121
extern GVariant *g_action_group_get_action_state(GActionGroup *action_group , gchar *action_name ) ;
#line 124
extern void g_action_group_change_action_state(GActionGroup *action_group , gchar *action_name ,
                                               GVariant *value ) ;
#line 129
extern void g_action_group_activate_action(GActionGroup *action_group , gchar *action_name ,
                                           GVariant *parameter ) ;
#line 135
extern void g_action_group_action_added(GActionGroup *action_group , gchar *action_name ) ;
#line 138
extern void g_action_group_action_removed(GActionGroup *action_group , gchar *action_name ) ;
#line 141
extern void g_action_group_action_enabled_changed(GActionGroup *action_group , gchar *action_name ,
                                                  gboolean enabled ) ;
#line 146
extern void g_action_group_action_state_changed(GActionGroup *action_group , gchar *action_name ,
                                                GVariant *state ) ;
#line 151
extern gboolean g_action_group_query_action(GActionGroup *action_group , gchar *action_name ,
                                            gboolean *enabled , GVariantType **parameter_type ,
                                            GVariantType **state_type , GVariant **state_hint ,
                                            GVariant **state ) ;
#line 34 "/usr/include/glib-2.0/gio/gactiongroupexporter.h"
extern guint g_dbus_connection_export_action_group(GDBusConnection *connection , gchar *object_path ,
                                                   GActionGroup *action_group , GError **error ) ;
#line 40
extern void g_dbus_connection_unexport_action_group(GDBusConnection *connection ,
                                                    guint export_id ) ;
#line 76 "/usr/include/glib-2.0/gio/gactionmap.h"
extern GType g_action_map_get_type(void) ;
#line 79
extern GAction *g_action_map_lookup_action(GActionMap *action_map , gchar *action_name ) ;
#line 82
extern void g_action_map_add_action(GActionMap *action_map , GAction *action ) ;
#line 85
extern void g_action_map_remove_action(GActionMap *action_map , gchar *action_name ) ;
#line 88
extern void g_action_map_add_action_entries(GActionMap *action_map , GActionEntry *entries ,
                                            gint n_entries , gpointer user_data ) ;
#line 148 "/usr/include/glib-2.0/gio/gappinfo.h"
extern GType g_app_info_get_type(void) ;
#line 150
extern GAppInfo *g_app_info_create_from_commandline(char const   *commandline , char const   *application_name ,
                                                    GAppInfoCreateFlags flags , GError **error ) ;
#line 155
extern GAppInfo *g_app_info_dup(GAppInfo *appinfo ) ;
#line 157
extern gboolean g_app_info_equal(GAppInfo *appinfo1 , GAppInfo *appinfo2 ) ;
#line 160
extern char const   *g_app_info_get_id(GAppInfo *appinfo ) ;
#line 162
extern char const   *g_app_info_get_name(GAppInfo *appinfo ) ;
#line 164
extern char const   *g_app_info_get_display_name(GAppInfo *appinfo ) ;
#line 166
extern char const   *g_app_info_get_description(GAppInfo *appinfo ) ;
#line 168
extern char const   *g_app_info_get_executable(GAppInfo *appinfo ) ;
#line 170
extern char const   *g_app_info_get_commandline(GAppInfo *appinfo ) ;
#line 172
extern GIcon *g_app_info_get_icon(GAppInfo *appinfo ) ;
#line 174
extern gboolean g_app_info_launch(GAppInfo *appinfo , GList *files , GAppLaunchContext *context ,
                                  GError **error ) ;
#line 179
extern gboolean g_app_info_supports_uris(GAppInfo *appinfo ) ;
#line 181
extern gboolean g_app_info_supports_files(GAppInfo *appinfo ) ;
#line 183
extern gboolean g_app_info_launch_uris(GAppInfo *appinfo , GList *uris , GAppLaunchContext *context ,
                                       GError **error ) ;
#line 188
extern void g_app_info_launch_uris_async(GAppInfo *appinfo , GList *uris , GAppLaunchContext *context ,
                                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                                         gpointer user_data ) ;
#line 195
extern gboolean g_app_info_launch_uris_finish(GAppInfo *appinfo , GAsyncResult *result ,
                                              GError **error ) ;
#line 200
extern gboolean g_app_info_should_show(GAppInfo *appinfo ) ;
#line 203
extern gboolean g_app_info_set_as_default_for_type(GAppInfo *appinfo , char const   *content_type ,
                                                   GError **error ) ;
#line 207
extern gboolean g_app_info_set_as_default_for_extension(GAppInfo *appinfo , char const   *extension ,
                                                        GError **error ) ;
#line 211
extern gboolean g_app_info_add_supports_type(GAppInfo *appinfo , char const   *content_type ,
                                             GError **error ) ;
#line 215
extern gboolean g_app_info_can_remove_supports_type(GAppInfo *appinfo ) ;
#line 217
extern gboolean g_app_info_remove_supports_type(GAppInfo *appinfo , char const   *content_type ,
                                                GError **error ) ;
#line 221
extern char const   **g_app_info_get_supported_types(GAppInfo *appinfo ) ;
#line 224
extern gboolean g_app_info_can_delete(GAppInfo *appinfo ) ;
#line 226
extern gboolean g_app_info_delete(GAppInfo *appinfo ) ;
#line 229
extern gboolean g_app_info_set_as_last_used_for_type(GAppInfo *appinfo , char const   *content_type ,
                                                     GError **error ) ;
#line 234
extern GList *g_app_info_get_all(void) ;
#line 236
extern GList *g_app_info_get_all_for_type(char const   *content_type ) ;
#line 238
extern GList *g_app_info_get_recommended_for_type(gchar *content_type ) ;
#line 240
extern GList *g_app_info_get_fallback_for_type(gchar *content_type ) ;
#line 243
extern void g_app_info_reset_type_associations(char const   *content_type ) ;
#line 245
extern GAppInfo *g_app_info_get_default_for_type(char const   *content_type , gboolean must_support_uris ) ;
#line 248
extern GAppInfo *g_app_info_get_default_for_uri_scheme(char const   *uri_scheme ) ;
#line 251
extern gboolean g_app_info_launch_default_for_uri(char const   *uri , GAppLaunchContext *context ,
                                                  GError **error ) ;
#line 256
extern void g_app_info_launch_default_for_uri_async(char const   *uri , GAppLaunchContext *context ,
                                                    GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                    gpointer user_data ) ;
#line 262
extern gboolean g_app_info_launch_default_for_uri_finish(GAsyncResult *result , GError **error ) ;
#line 307
extern GType g_app_launch_context_get_type(void) ;
#line 309
extern GAppLaunchContext *g_app_launch_context_new(void) ;
#line 312
extern void g_app_launch_context_setenv(GAppLaunchContext *context , char const   *variable ,
                                        char const   *value ) ;
#line 316
extern void g_app_launch_context_unsetenv(GAppLaunchContext *context , char const   *variable ) ;
#line 319
extern char **g_app_launch_context_get_environment(GAppLaunchContext *context ) ;
#line 322
extern char *g_app_launch_context_get_display(GAppLaunchContext *context , GAppInfo *info ,
                                              GList *files ) ;
#line 326
extern char *g_app_launch_context_get_startup_notify_id(GAppLaunchContext *context ,
                                                        GAppInfo *info , GList *files ) ;
#line 330
extern void g_app_launch_context_launch_failed(GAppLaunchContext *context , char const   *startup_notify_id ) ;
#line 342
extern GType g_app_info_monitor_get_type(void) ;
#line 345
extern GAppInfoMonitor *g_app_info_monitor_get(void) ;
#line 122 "/usr/include/glib-2.0/gio/gapplication.h"
extern GType g_application_get_type(void) ;
#line 125
extern gboolean g_application_id_is_valid(gchar *application_id ) ;
#line 128
extern GApplication *g_application_new(gchar *application_id , GApplicationFlags flags ) ;
#line 132
extern gchar *g_application_get_application_id(GApplication *application ) ;
#line 134
extern void g_application_set_application_id(GApplication *application , gchar *application_id ) ;
#line 138
extern GDBusConnection *g_application_get_dbus_connection(GApplication *application ) ;
#line 140
extern gchar *g_application_get_dbus_object_path(GApplication *application ) ;
#line 143
extern guint g_application_get_inactivity_timeout(GApplication *application ) ;
#line 145
extern void g_application_set_inactivity_timeout(GApplication *application , guint inactivity_timeout ) ;
#line 149
extern GApplicationFlags g_application_get_flags(GApplication *application ) ;
#line 151
extern void g_application_set_flags(GApplication *application , GApplicationFlags flags ) ;
#line 155
extern gchar *g_application_get_resource_base_path(GApplication *application ) ;
#line 157
extern void g_application_set_resource_base_path(GApplication *application , gchar *resource_path ) ;
#line 161
extern void g_application_set_action_group(GApplication *application , GActionGroup *action_group ) ;
#line 165
extern void g_application_add_main_option_entries(GApplication *application , GOptionEntry *entries ) ;
#line 169
extern void g_application_add_main_option(GApplication *application , char const   *long_name ,
                                          char short_name , GOptionFlags flags , GOptionArg arg ,
                                          char const   *description , char const   *arg_description ) ;
#line 177
extern void g_application_add_option_group(GApplication *application , GOptionGroup *group ) ;
#line 180
extern void g_application_set_option_context_parameter_string(GApplication *application ,
                                                              gchar *parameter_string ) ;
#line 183
extern void g_application_set_option_context_summary(GApplication *application , gchar *summary ) ;
#line 186
extern void g_application_set_option_context_description(GApplication *application ,
                                                         gchar *description ) ;
#line 189
extern gboolean g_application_get_is_registered(GApplication *application ) ;
#line 191
extern gboolean g_application_get_is_remote(GApplication *application ) ;
#line 194
extern gboolean g_application_register(GApplication *application , GCancellable *cancellable ,
                                       GError **error ) ;
#line 199
extern void g_application_hold(GApplication *application ) ;
#line 201
extern void g_application_release(GApplication *application ) ;
#line 204
extern void g_application_activate(GApplication *application ) ;
#line 207
extern void g_application_open(GApplication *application , GFile **files , gint n_files ,
                               gchar *hint ) ;
#line 213
extern int g_application_run(GApplication *application , int argc , char **argv ) ;
#line 218
extern void g_application_quit(GApplication *application ) ;
#line 221
extern GApplication *g_application_get_default(void) ;
#line 223
extern void g_application_set_default(GApplication *application ) ;
#line 226
extern void g_application_mark_busy(GApplication *application ) ;
#line 228
extern void g_application_unmark_busy(GApplication *application ) ;
#line 230
extern gboolean g_application_get_is_busy(GApplication *application ) ;
#line 233
extern void g_application_send_notification(GApplication *application , gchar *id ,
                                            GNotification *notification ) ;
#line 237
extern void g_application_withdraw_notification(GApplication *application , gchar *id ) ;
#line 241
extern void g_application_bind_busy_property(GApplication *application , gpointer object ,
                                             gchar *property ) ;
#line 246
extern void g_application_unbind_busy_property(GApplication *application , gpointer object ,
                                               gchar *property ) ;
#line 73 "/usr/include/glib-2.0/gio/gapplicationcommandline.h"
extern GType g_application_command_line_get_type(void) ;
#line 76
extern gchar **g_application_command_line_get_arguments(GApplicationCommandLine *cmdline ,
                                                        int *argc ) ;
#line 80
extern GVariantDict *g_application_command_line_get_options_dict(GApplicationCommandLine *cmdline ) ;
#line 83
extern GInputStream *g_application_command_line_get_stdin(GApplicationCommandLine *cmdline ) ;
#line 86
extern gchar * const  *g_application_command_line_get_environ(GApplicationCommandLine *cmdline ) ;
#line 89
extern gchar *g_application_command_line_getenv(GApplicationCommandLine *cmdline ,
                                                gchar *name ) ;
#line 93
extern gchar *g_application_command_line_get_cwd(GApplicationCommandLine *cmdline ) ;
#line 96
extern gboolean g_application_command_line_get_is_remote(GApplicationCommandLine *cmdline ) ;
#line 99
extern void g_application_command_line_print(GApplicationCommandLine *cmdline , gchar *format 
                                             , ...) ;
#line 103
extern void g_application_command_line_printerr(GApplicationCommandLine *cmdline ,
                                                gchar *format  , ...) ;
#line 108
extern int g_application_command_line_get_exit_status(GApplicationCommandLine *cmdline ) ;
#line 110
extern void g_application_command_line_set_exit_status(GApplicationCommandLine *cmdline ,
                                                       int exit_status ) ;
#line 114
extern GVariant *g_application_command_line_get_platform_data(GApplicationCommandLine *cmdline ) ;
#line 117
extern GFile *g_application_command_line_create_file_for_arg(GApplicationCommandLine *cmdline ,
                                                             gchar *arg ) ;
#line 70 "/usr/include/glib-2.0/gio/ginitable.h"
extern GType g_initable_get_type(void) ;
#line 73
extern gboolean g_initable_init(GInitable *initable , GCancellable *cancellable ,
                                GError **error ) ;
#line 78
extern gpointer g_initable_new(GType object_type , GCancellable *cancellable , GError **error ,
                               gchar *first_property_name  , ...) ;
#line 87
extern gpointer g_initable_newv(GType object_type , guint n_parameters , GParameter *parameters ,
                                GCancellable *cancellable , GError **error ) ;
#line 96
extern GObject *g_initable_new_valist(GType object_type , gchar *first_property_name ,
                                      va_list var_args , GCancellable *cancellable ,
                                      GError **error ) ;
#line 76 "/usr/include/glib-2.0/gio/gasyncinitable.h"
extern GType g_async_initable_get_type(void) ;
#line 80
extern void g_async_initable_init_async(GAsyncInitable *initable , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 86
extern gboolean g_async_initable_init_finish(GAsyncInitable *initable , GAsyncResult *res ,
                                             GError **error ) ;
#line 91
extern void g_async_initable_new_async(GType object_type , int io_priority , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ,
                                       gchar *first_property_name  , ...) ;
#line 102
extern void g_async_initable_newv_async(GType object_type , guint n_parameters , GParameter *parameters ,
                                        int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 113
extern void g_async_initable_new_valist_async(GType object_type , gchar *first_property_name ,
                                              va_list var_args , int io_priority ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 121
extern GObject *g_async_initable_new_finish(GAsyncInitable *initable , GAsyncResult *res ,
                                            GError **error ) ;
#line 69 "/usr/include/glib-2.0/gio/gasyncresult.h"
extern GType g_async_result_get_type(void) ;
#line 72
extern gpointer g_async_result_get_user_data(GAsyncResult *res ) ;
#line 74
extern GObject *g_async_result_get_source_object(GAsyncResult *res ) ;
#line 77
extern gboolean g_async_result_legacy_propagate_error(GAsyncResult *res , GError **error ) ;
#line 80
extern gboolean g_async_result_is_tagged(GAsyncResult *res , gpointer source_tag ) ;
#line 113 "/usr/include/glib-2.0/gio/ginputstream.h"
extern GType g_input_stream_get_type(void) ;
#line 116
extern gssize g_input_stream_read(GInputStream *stream , void *buffer , gsize count ,
                                  GCancellable *cancellable , GError **error ) ;
#line 122
extern gboolean g_input_stream_read_all(GInputStream *stream , void *buffer , gsize count ,
                                        gsize *bytes_read , GCancellable *cancellable ,
                                        GError **error ) ;
#line 129
extern GBytes *g_input_stream_read_bytes(GInputStream *stream , gsize count , GCancellable *cancellable ,
                                         GError **error ) ;
#line 134
extern gssize g_input_stream_skip(GInputStream *stream , gsize count , GCancellable *cancellable ,
                                  GError **error ) ;
#line 139
extern gboolean g_input_stream_close(GInputStream *stream , GCancellable *cancellable ,
                                     GError **error ) ;
#line 143
extern void g_input_stream_read_async(GInputStream *stream , void *buffer , gsize count ,
                                      int io_priority , GCancellable *cancellable ,
                                      GAsyncReadyCallback callback , gpointer user_data ) ;
#line 151
extern gssize g_input_stream_read_finish(GInputStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 156
extern void g_input_stream_read_all_async(GInputStream *stream , void *buffer , gsize count ,
                                          int io_priority , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 164
extern gboolean g_input_stream_read_all_finish(GInputStream *stream , GAsyncResult *result ,
                                               gsize *bytes_read , GError **error ) ;
#line 170
extern void g_input_stream_read_bytes_async(GInputStream *stream , gsize count , int io_priority ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 177
extern GBytes *g_input_stream_read_bytes_finish(GInputStream *stream , GAsyncResult *result ,
                                                GError **error ) ;
#line 181
extern void g_input_stream_skip_async(GInputStream *stream , gsize count , int io_priority ,
                                      GCancellable *cancellable , GAsyncReadyCallback callback ,
                                      gpointer user_data ) ;
#line 188
extern gssize g_input_stream_skip_finish(GInputStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 192
extern void g_input_stream_close_async(GInputStream *stream , int io_priority , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 198
extern gboolean g_input_stream_close_finish(GInputStream *stream , GAsyncResult *result ,
                                            GError **error ) ;
#line 205
extern gboolean g_input_stream_is_closed(GInputStream *stream ) ;
#line 207
extern gboolean g_input_stream_has_pending(GInputStream *stream ) ;
#line 209
extern gboolean g_input_stream_set_pending(GInputStream *stream , GError **error ) ;
#line 212
extern void g_input_stream_clear_pending(GInputStream *stream ) ;
#line 67 "/usr/include/glib-2.0/gio/gfilterinputstream.h"
extern GType g_filter_input_stream_get_type(void) ;
#line 69
extern GInputStream *g_filter_input_stream_get_base_stream(GFilterInputStream *stream ) ;
#line 71
extern gboolean g_filter_input_stream_get_close_base_stream(GFilterInputStream *stream ) ;
#line 73
extern void g_filter_input_stream_set_close_base_stream(GFilterInputStream *stream ,
                                                        gboolean close_base ) ;
#line 86 "/usr/include/glib-2.0/gio/gbufferedinputstream.h"
extern GType g_buffered_input_stream_get_type(void) ;
#line 88
extern GInputStream *g_buffered_input_stream_new(GInputStream *base_stream ) ;
#line 90
extern GInputStream *g_buffered_input_stream_new_sized(GInputStream *base_stream ,
                                                       gsize size ) ;
#line 94
extern gsize g_buffered_input_stream_get_buffer_size(GBufferedInputStream *stream ) ;
#line 96
extern void g_buffered_input_stream_set_buffer_size(GBufferedInputStream *stream ,
                                                    gsize size ) ;
#line 99
extern gsize g_buffered_input_stream_get_available(GBufferedInputStream *stream ) ;
#line 101
extern gsize g_buffered_input_stream_peek(GBufferedInputStream *stream , void *buffer ,
                                          gsize offset , gsize count ) ;
#line 106
extern void const   *g_buffered_input_stream_peek_buffer(GBufferedInputStream *stream ,
                                                         gsize *count ) ;
#line 110
extern gssize g_buffered_input_stream_fill(GBufferedInputStream *stream , gssize count ,
                                           GCancellable *cancellable , GError **error ) ;
#line 115
extern void g_buffered_input_stream_fill_async(GBufferedInputStream *stream , gssize count ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 122
extern gssize g_buffered_input_stream_fill_finish(GBufferedInputStream *stream , GAsyncResult *result ,
                                                  GError **error ) ;
#line 127
extern int g_buffered_input_stream_read_byte(GBufferedInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 152 "/usr/include/glib-2.0/gio/goutputstream.h"
extern GType g_output_stream_get_type(void) ;
#line 155
extern gssize g_output_stream_write(GOutputStream *stream , void const   *buffer ,
                                    gsize count , GCancellable *cancellable , GError **error ) ;
#line 161
extern gboolean g_output_stream_write_all(GOutputStream *stream , void const   *buffer ,
                                          gsize count , gsize *bytes_written , GCancellable *cancellable ,
                                          GError **error ) ;
#line 169
extern gboolean g_output_stream_writev(GOutputStream *stream , GOutputVector *vectors ,
                                       gsize n_vectors , gsize *bytes_written , GCancellable *cancellable ,
                                       GError **error ) ;
#line 176
extern gboolean g_output_stream_writev_all(GOutputStream *stream , GOutputVector *vectors ,
                                           gsize n_vectors , gsize *bytes_written ,
                                           GCancellable *cancellable , GError **error ) ;
#line 184
extern gboolean g_output_stream_printf(GOutputStream *stream , gsize *bytes_written ,
                                       GCancellable *cancellable , GError **error ,
                                       gchar *format  , ...) ;
#line 191
extern gboolean g_output_stream_vprintf(GOutputStream *stream , gsize *bytes_written ,
                                        GCancellable *cancellable , GError **error ,
                                        gchar *format , va_list args ) ;
#line 198
extern gssize g_output_stream_write_bytes(GOutputStream *stream , GBytes *bytes ,
                                          GCancellable *cancellable , GError **error ) ;
#line 203
extern gssize g_output_stream_splice(GOutputStream *stream , GInputStream *source ,
                                     GOutputStreamSpliceFlags flags , GCancellable *cancellable ,
                                     GError **error ) ;
#line 209
extern gboolean g_output_stream_flush(GOutputStream *stream , GCancellable *cancellable ,
                                      GError **error ) ;
#line 213
extern gboolean g_output_stream_close(GOutputStream *stream , GCancellable *cancellable ,
                                      GError **error ) ;
#line 217
extern void g_output_stream_write_async(GOutputStream *stream , void const   *buffer ,
                                        gsize count , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 225
extern gssize g_output_stream_write_finish(GOutputStream *stream , GAsyncResult *result ,
                                           GError **error ) ;
#line 230
extern void g_output_stream_write_all_async(GOutputStream *stream , void const   *buffer ,
                                            gsize count , int io_priority , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 239
extern gboolean g_output_stream_write_all_finish(GOutputStream *stream , GAsyncResult *result ,
                                                 gsize *bytes_written , GError **error ) ;
#line 245
extern void g_output_stream_writev_async(GOutputStream *stream , GOutputVector *vectors ,
                                         gsize n_vectors , int io_priority , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 253
extern gboolean g_output_stream_writev_finish(GOutputStream *stream , GAsyncResult *result ,
                                              gsize *bytes_written , GError **error ) ;
#line 259
extern void g_output_stream_writev_all_async(GOutputStream *stream , GOutputVector *vectors ,
                                             gsize n_vectors , int io_priority , GCancellable *cancellable ,
                                             GAsyncReadyCallback callback , gpointer user_data ) ;
#line 268
extern gboolean g_output_stream_writev_all_finish(GOutputStream *stream , GAsyncResult *result ,
                                                  gsize *bytes_written , GError **error ) ;
#line 274
extern void g_output_stream_write_bytes_async(GOutputStream *stream , GBytes *bytes ,
                                              int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 281
extern gssize g_output_stream_write_bytes_finish(GOutputStream *stream , GAsyncResult *result ,
                                                 GError **error ) ;
#line 285
extern void g_output_stream_splice_async(GOutputStream *stream , GInputStream *source ,
                                         GOutputStreamSpliceFlags flags , int io_priority ,
                                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                                         gpointer user_data ) ;
#line 293
extern gssize g_output_stream_splice_finish(GOutputStream *stream , GAsyncResult *result ,
                                            GError **error ) ;
#line 297
extern void g_output_stream_flush_async(GOutputStream *stream , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 303
extern gboolean g_output_stream_flush_finish(GOutputStream *stream , GAsyncResult *result ,
                                             GError **error ) ;
#line 307
extern void g_output_stream_close_async(GOutputStream *stream , int io_priority ,
                                        GCancellable *cancellable , GAsyncReadyCallback callback ,
                                        gpointer user_data ) ;
#line 313
extern gboolean g_output_stream_close_finish(GOutputStream *stream , GAsyncResult *result ,
                                             GError **error ) ;
#line 318
extern gboolean g_output_stream_is_closed(GOutputStream *stream ) ;
#line 320
extern gboolean g_output_stream_is_closing(GOutputStream *stream ) ;
#line 322
extern gboolean g_output_stream_has_pending(GOutputStream *stream ) ;
#line 324
extern gboolean g_output_stream_set_pending(GOutputStream *stream , GError **error ) ;
#line 327
extern void g_output_stream_clear_pending(GOutputStream *stream ) ;
#line 67 "/usr/include/glib-2.0/gio/gfilteroutputstream.h"
extern GType g_filter_output_stream_get_type(void) ;
#line 69
extern GOutputStream *g_filter_output_stream_get_base_stream(GFilterOutputStream *stream ) ;
#line 71
extern gboolean g_filter_output_stream_get_close_base_stream(GFilterOutputStream *stream ) ;
#line 73
extern void g_filter_output_stream_set_close_base_stream(GFilterOutputStream *stream ,
                                                         gboolean close_base ) ;
#line 67 "/usr/include/glib-2.0/gio/gbufferedoutputstream.h"
extern GType g_buffered_output_stream_get_type(void) ;
#line 69
extern GOutputStream *g_buffered_output_stream_new(GOutputStream *base_stream ) ;
#line 71
extern GOutputStream *g_buffered_output_stream_new_sized(GOutputStream *base_stream ,
                                                         gsize size ) ;
#line 74
extern gsize g_buffered_output_stream_get_buffer_size(GBufferedOutputStream *stream ) ;
#line 76
extern void g_buffered_output_stream_set_buffer_size(GBufferedOutputStream *stream ,
                                                     gsize size ) ;
#line 79
extern gboolean g_buffered_output_stream_get_auto_grow(GBufferedOutputStream *stream ) ;
#line 81
extern void g_buffered_output_stream_set_auto_grow(GBufferedOutputStream *stream ,
                                                   gboolean auto_grow ) ;
#line 42 "/usr/include/glib-2.0/gio/gbytesicon.h"
extern GType g_bytes_icon_get_type(void) ;
#line 45
extern GIcon *g_bytes_icon_new(GBytes *bytes ) ;
#line 48
extern GBytes *g_bytes_icon_get_bytes(GBytesIcon *icon ) ;
#line 71 "/usr/include/glib-2.0/gio/gcancellable.h"
extern GType g_cancellable_get_type(void) ;
#line 74
extern GCancellable *g_cancellable_new(void) ;
#line 78
extern gboolean g_cancellable_is_cancelled(GCancellable *cancellable ) ;
#line 80
extern gboolean g_cancellable_set_error_if_cancelled(GCancellable *cancellable , GError **error ) ;
#line 84
extern int g_cancellable_get_fd(GCancellable *cancellable ) ;
#line 86
extern gboolean g_cancellable_make_pollfd(GCancellable *cancellable , GPollFD *pollfd ) ;
#line 89
extern void g_cancellable_release_fd(GCancellable *cancellable ) ;
#line 92
extern GSource *g_cancellable_source_new(GCancellable *cancellable ) ;
#line 95
extern GCancellable *g_cancellable_get_current(void) ;
#line 97
extern void g_cancellable_push_current(GCancellable *cancellable ) ;
#line 99
extern void g_cancellable_pop_current(GCancellable *cancellable ) ;
#line 101
extern void g_cancellable_reset(GCancellable *cancellable ) ;
#line 103
extern gulong g_cancellable_connect(GCancellable *cancellable , GCallback callback ,
                                    gpointer data , GDestroyNotify data_destroy_func ) ;
#line 108
extern void g_cancellable_disconnect(GCancellable *cancellable , gulong handler_id ) ;
#line 114
extern void g_cancellable_cancel(GCancellable *cancellable ) ;
#line 77 "/usr/include/glib-2.0/gio/gconverter.h"
extern GType g_converter_get_type(void) ;
#line 80
extern GConverterResult g_converter_convert(GConverter *converter , void const   *inbuf ,
                                            gsize inbuf_size , void *outbuf , gsize outbuf_size ,
                                            GConverterFlags flags , gsize *bytes_read ,
                                            gsize *bytes_written , GError **error ) ;
#line 90
extern void g_converter_reset(GConverter *converter ) ;
#line 47 "/usr/include/glib-2.0/gio/gcharsetconverter.h"
extern GType g_charset_converter_get_type(void) ;
#line 50
extern GCharsetConverter *g_charset_converter_new(gchar *to_charset , gchar *from_charset ,
                                                  GError **error ) ;
#line 54
extern void g_charset_converter_set_use_fallback(GCharsetConverter *converter , gboolean use_fallback ) ;
#line 57
extern gboolean g_charset_converter_get_use_fallback(GCharsetConverter *converter ) ;
#line 59
extern guint g_charset_converter_get_num_fallbacks(GCharsetConverter *converter ) ;
#line 33 "/usr/include/glib-2.0/gio/gcontenttype.h"
extern gboolean g_content_type_equals(gchar *type1 , gchar *type2 ) ;
#line 36
extern gboolean g_content_type_is_a(gchar *type , gchar *supertype ) ;
#line 39
extern gboolean g_content_type_is_mime_type(gchar *type , gchar *mime_type ) ;
#line 42
extern gboolean g_content_type_is_unknown(gchar *type ) ;
#line 44
extern gchar *g_content_type_get_description(gchar *type ) ;
#line 46
extern gchar *g_content_type_get_mime_type(gchar *type ) ;
#line 48
extern GIcon *g_content_type_get_icon(gchar *type ) ;
#line 50
extern GIcon *g_content_type_get_symbolic_icon(gchar *type ) ;
#line 52
extern gchar *g_content_type_get_generic_icon_name(gchar *type ) ;
#line 55
extern gboolean g_content_type_can_be_executable(gchar *type ) ;
#line 58
extern gchar *g_content_type_from_mime_type(gchar *mime_type ) ;
#line 61
extern gchar *g_content_type_guess(gchar *filename , guchar *data , gsize data_size ,
                                   gboolean *result_uncertain ) ;
#line 67
extern gchar **g_content_type_guess_for_tree(GFile *root ) ;
#line 70
extern GList *g_content_types_get_registered(void) ;
#line 75
extern gchar * const  *g_content_type_get_mime_dirs(void) ;
#line 77
extern void g_content_type_set_mime_dirs(gchar * const  *dirs ) ;
#line 71 "/usr/include/glib-2.0/gio/gconverterinputstream.h"
extern GType g_converter_input_stream_get_type(void) ;
#line 73
extern GInputStream *g_converter_input_stream_new(GInputStream *base_stream , GConverter *converter ) ;
#line 76
extern GConverter *g_converter_input_stream_get_converter(GConverterInputStream *converter_stream ) ;
#line 71 "/usr/include/glib-2.0/gio/gconverteroutputstream.h"
extern GType g_converter_output_stream_get_type(void) ;
#line 73
extern GOutputStream *g_converter_output_stream_new(GOutputStream *base_stream , GConverter *converter ) ;
#line 76
extern GConverter *g_converter_output_stream_get_converter(GConverterOutputStream *converter_stream ) ;
#line 48 "/usr/include/glib-2.0/gio/gcredentials.h"
extern GType g_credentials_get_type(void) ;
#line 51
extern GCredentials *g_credentials_new(void) ;
#line 54
extern gchar *g_credentials_to_string(GCredentials *credentials ) ;
#line 57
extern gpointer g_credentials_get_native(GCredentials *credentials , GCredentialsType native_type ) ;
#line 61
extern void g_credentials_set_native(GCredentials *credentials , GCredentialsType native_type ,
                                     gpointer native ) ;
#line 66
extern gboolean g_credentials_is_same_user(GCredentials *credentials , GCredentials *other_credentials ,
                                           GError **error ) ;
#line 72
extern pid_t g_credentials_get_unix_pid(GCredentials *credentials , GError **error ) ;
#line 75
extern uid_t g_credentials_get_unix_user(GCredentials *credentials , GError **error ) ;
#line 78
extern gboolean g_credentials_set_unix_user(GCredentials *credentials , uid_t uid ,
                                            GError **error ) ;
#line 103 "/usr/include/glib-2.0/gio/gdatagrambased.h"
extern GType g_datagram_based_get_type(void) ;
#line 107
extern gint g_datagram_based_receive_messages(GDatagramBased *datagram_based , GInputMessage *messages ,
                                              guint num_messages , gint flags , gint64 timeout ,
                                              GCancellable *cancellable , GError **error ) ;
#line 117
extern gint g_datagram_based_send_messages(GDatagramBased *datagram_based , GOutputMessage *messages ,
                                           guint num_messages , gint flags , gint64 timeout ,
                                           GCancellable *cancellable , GError **error ) ;
#line 127
extern GSource *g_datagram_based_create_source(GDatagramBased *datagram_based , GIOCondition condition ,
                                               GCancellable *cancellable ) ;
#line 132
extern GIOCondition g_datagram_based_condition_check(GDatagramBased *datagram_based ,
                                                     GIOCondition condition ) ;
#line 136
extern gboolean g_datagram_based_condition_wait(GDatagramBased *datagram_based , GIOCondition condition ,
                                                gint64 timeout , GCancellable *cancellable ,
                                                GError **error ) ;
#line 70 "/usr/include/glib-2.0/gio/gdatainputstream.h"
extern GType g_data_input_stream_get_type(void) ;
#line 72
extern GDataInputStream *g_data_input_stream_new(GInputStream *base_stream ) ;
#line 75
extern void g_data_input_stream_set_byte_order(GDataInputStream *stream , GDataStreamByteOrder order ) ;
#line 78
extern GDataStreamByteOrder g_data_input_stream_get_byte_order(GDataInputStream *stream ) ;
#line 80
extern void g_data_input_stream_set_newline_type(GDataInputStream *stream , GDataStreamNewlineType type ) ;
#line 83
extern GDataStreamNewlineType g_data_input_stream_get_newline_type(GDataInputStream *stream ) ;
#line 85
extern guchar g_data_input_stream_read_byte(GDataInputStream *stream , GCancellable *cancellable ,
                                            GError **error ) ;
#line 89
extern gint16 g_data_input_stream_read_int16(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 93
extern guint16 g_data_input_stream_read_uint16(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 97
extern gint32 g_data_input_stream_read_int32(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 101
extern guint32 g_data_input_stream_read_uint32(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 105
extern gint64 g_data_input_stream_read_int64(GDataInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 109
extern guint64 g_data_input_stream_read_uint64(GDataInputStream *stream , GCancellable *cancellable ,
                                               GError **error ) ;
#line 113
extern char *g_data_input_stream_read_line(GDataInputStream *stream , gsize *length ,
                                           GCancellable *cancellable , GError **error ) ;
#line 118
extern char *g_data_input_stream_read_line_utf8(GDataInputStream *stream , gsize *length ,
                                                GCancellable *cancellable , GError **error ) ;
#line 123
extern void g_data_input_stream_read_line_async(GDataInputStream *stream , gint io_priority ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 129
extern char *g_data_input_stream_read_line_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                  gsize *length , GError **error ) ;
#line 134
extern char *g_data_input_stream_read_line_finish_utf8(GDataInputStream *stream ,
                                                       GAsyncResult *result , gsize *length ,
                                                       GError **error ) ;
#line 139
extern char *g_data_input_stream_read_until(GDataInputStream *stream , gchar *stop_chars ,
                                            gsize *length , GCancellable *cancellable ,
                                            GError **error ) ;
#line 145
extern void g_data_input_stream_read_until_async(GDataInputStream *stream , gchar *stop_chars ,
                                                 gint io_priority , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 152
extern char *g_data_input_stream_read_until_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                   gsize *length , GError **error ) ;
#line 158
extern char *g_data_input_stream_read_upto(GDataInputStream *stream , gchar *stop_chars ,
                                           gssize stop_chars_len , gsize *length ,
                                           GCancellable *cancellable , GError **error ) ;
#line 165
extern void g_data_input_stream_read_upto_async(GDataInputStream *stream , gchar *stop_chars ,
                                                gssize stop_chars_len , gint io_priority ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 173
extern char *g_data_input_stream_read_upto_finish(GDataInputStream *stream , GAsyncResult *result ,
                                                  gsize *length , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gdataoutputstream.h"
extern GType g_data_output_stream_get_type(void) ;
#line 74
extern GDataOutputStream *g_data_output_stream_new(GOutputStream *base_stream ) ;
#line 77
extern void g_data_output_stream_set_byte_order(GDataOutputStream *stream , GDataStreamByteOrder order ) ;
#line 80
extern GDataStreamByteOrder g_data_output_stream_get_byte_order(GDataOutputStream *stream ) ;
#line 83
extern gboolean g_data_output_stream_put_byte(GDataOutputStream *stream , guchar data ,
                                              GCancellable *cancellable , GError **error ) ;
#line 88
extern gboolean g_data_output_stream_put_int16(GDataOutputStream *stream , gint16 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 93
extern gboolean g_data_output_stream_put_uint16(GDataOutputStream *stream , guint16 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 98
extern gboolean g_data_output_stream_put_int32(GDataOutputStream *stream , gint32 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 103
extern gboolean g_data_output_stream_put_uint32(GDataOutputStream *stream , guint32 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 108
extern gboolean g_data_output_stream_put_int64(GDataOutputStream *stream , gint64 data ,
                                               GCancellable *cancellable , GError **error ) ;
#line 113
extern gboolean g_data_output_stream_put_uint64(GDataOutputStream *stream , guint64 data ,
                                                GCancellable *cancellable , GError **error ) ;
#line 118
extern gboolean g_data_output_stream_put_string(GDataOutputStream *stream , char const   *str ,
                                                GCancellable *cancellable , GError **error ) ;
#line 45 "/usr/include/glib-2.0/gio/gdbusactiongroup.h"
extern GType g_dbus_action_group_get_type(void) ;
#line 48
extern GDBusActionGroup *g_dbus_action_group_get(GDBusConnection *connection , gchar *bus_name ,
                                                 gchar *object_path ) ;
#line 33 "/usr/include/glib-2.0/gio/gdbusaddress.h"
extern gchar *g_dbus_address_escape_value(gchar *string ) ;
#line 36
extern gboolean g_dbus_is_address(gchar *string ) ;
#line 38
extern gboolean g_dbus_is_supported_address(gchar *string , GError **error ) ;
#line 42
extern void g_dbus_address_get_stream(gchar *address , GCancellable *cancellable ,
                                      GAsyncReadyCallback callback , gpointer user_data ) ;
#line 48
extern GIOStream *g_dbus_address_get_stream_finish(GAsyncResult *res , gchar **out_guid ,
                                                   GError **error ) ;
#line 53
extern GIOStream *g_dbus_address_get_stream_sync(gchar *address , gchar **out_guid ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 59
extern gchar *g_dbus_address_get_for_bus_sync(GBusType bus_type , GCancellable *cancellable ,
                                              GError **error ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusauthobserver.h"
extern GType g_dbus_auth_observer_get_type(void) ;
#line 39
extern GDBusAuthObserver *g_dbus_auth_observer_new(void) ;
#line 41
extern gboolean g_dbus_auth_observer_authorize_authenticated_peer(GDBusAuthObserver *observer ,
                                                                  GIOStream *stream ,
                                                                  GCredentials *credentials ) ;
#line 46
extern gboolean g_dbus_auth_observer_allow_mechanism(GDBusAuthObserver *observer ,
                                                     gchar *mechanism ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusconnection.h"
extern GType g_dbus_connection_get_type(void) ;
#line 42
extern void g_bus_get(GBusType bus_type , GCancellable *cancellable , GAsyncReadyCallback callback ,
                      gpointer user_data ) ;
#line 47
extern GDBusConnection *g_bus_get_finish(GAsyncResult *res , GError **error ) ;
#line 50
extern GDBusConnection *g_bus_get_sync(GBusType bus_type , GCancellable *cancellable ,
                                       GError **error ) ;
#line 57
extern void g_dbus_connection_new(GIOStream *stream , gchar *guid , GDBusConnectionFlags flags ,
                                  GDBusAuthObserver *observer , GCancellable *cancellable ,
                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 65
extern GDBusConnection *g_dbus_connection_new_finish(GAsyncResult *res , GError **error ) ;
#line 68
extern GDBusConnection *g_dbus_connection_new_sync(GIOStream *stream , gchar *guid ,
                                                   GDBusConnectionFlags flags , GDBusAuthObserver *observer ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 76
extern void g_dbus_connection_new_for_address(gchar *address , GDBusConnectionFlags flags ,
                                              GDBusAuthObserver *observer , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 83
extern GDBusConnection *g_dbus_connection_new_for_address_finish(GAsyncResult *res ,
                                                                 GError **error ) ;
#line 86
extern GDBusConnection *g_dbus_connection_new_for_address_sync(gchar *address , GDBusConnectionFlags flags ,
                                                               GDBusAuthObserver *observer ,
                                                               GCancellable *cancellable ,
                                                               GError **error ) ;
#line 95
extern void g_dbus_connection_start_message_processing(GDBusConnection *connection ) ;
#line 97
extern gboolean g_dbus_connection_is_closed(GDBusConnection *connection ) ;
#line 99
extern GIOStream *g_dbus_connection_get_stream(GDBusConnection *connection ) ;
#line 101
extern gchar *g_dbus_connection_get_guid(GDBusConnection *connection ) ;
#line 103
extern gchar *g_dbus_connection_get_unique_name(GDBusConnection *connection ) ;
#line 105
extern GCredentials *g_dbus_connection_get_peer_credentials(GDBusConnection *connection ) ;
#line 108
extern guint32 g_dbus_connection_get_last_serial(GDBusConnection *connection ) ;
#line 111
extern gboolean g_dbus_connection_get_exit_on_close(GDBusConnection *connection ) ;
#line 113
extern void g_dbus_connection_set_exit_on_close(GDBusConnection *connection , gboolean exit_on_close ) ;
#line 116
extern GDBusCapabilityFlags g_dbus_connection_get_capabilities(GDBusConnection *connection ) ;
#line 118
extern GDBusConnectionFlags g_dbus_connection_get_flags(GDBusConnection *connection ) ;
#line 123
extern void g_dbus_connection_close(GDBusConnection *connection , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 128
extern gboolean g_dbus_connection_close_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 132
extern gboolean g_dbus_connection_close_sync(GDBusConnection *connection , GCancellable *cancellable ,
                                             GError **error ) ;
#line 139
extern void g_dbus_connection_flush(GDBusConnection *connection , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 144
extern gboolean g_dbus_connection_flush_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 148
extern gboolean g_dbus_connection_flush_sync(GDBusConnection *connection , GCancellable *cancellable ,
                                             GError **error ) ;
#line 155
extern gboolean g_dbus_connection_send_message(GDBusConnection *connection , GDBusMessage *message ,
                                               GDBusSendMessageFlags flags , guint32 *out_serial ,
                                               GError **error ) ;
#line 161
extern void g_dbus_connection_send_message_with_reply(GDBusConnection *connection ,
                                                      GDBusMessage *message , GDBusSendMessageFlags flags ,
                                                      gint timeout_msec , guint32 *out_serial ,
                                                      GCancellable *cancellable ,
                                                      GAsyncReadyCallback callback ,
                                                      gpointer user_data ) ;
#line 170
extern GDBusMessage *g_dbus_connection_send_message_with_reply_finish(GDBusConnection *connection ,
                                                                      GAsyncResult *res ,
                                                                      GError **error ) ;
#line 174
extern GDBusMessage *g_dbus_connection_send_message_with_reply_sync(GDBusConnection *connection ,
                                                                    GDBusMessage *message ,
                                                                    GDBusSendMessageFlags flags ,
                                                                    gint timeout_msec ,
                                                                    guint32 *out_serial ,
                                                                    GCancellable *cancellable ,
                                                                    GError **error ) ;
#line 185
extern gboolean g_dbus_connection_emit_signal(GDBusConnection *connection , gchar *destination_bus_name ,
                                              gchar *object_path , gchar *interface_name ,
                                              gchar *signal_name , GVariant *parameters ,
                                              GError **error ) ;
#line 193
extern void g_dbus_connection_call(GDBusConnection *connection , gchar *bus_name ,
                                   gchar *object_path , gchar *interface_name , gchar *method_name ,
                                   GVariant *parameters , GVariantType *reply_type ,
                                   GDBusCallFlags flags , gint timeout_msec , GCancellable *cancellable ,
                                   GAsyncReadyCallback callback , gpointer user_data ) ;
#line 206
extern GVariant *g_dbus_connection_call_finish(GDBusConnection *connection , GAsyncResult *res ,
                                               GError **error ) ;
#line 210
extern GVariant *g_dbus_connection_call_sync(GDBusConnection *connection , gchar *bus_name ,
                                             gchar *object_path , gchar *interface_name ,
                                             gchar *method_name , GVariant *parameters ,
                                             GVariantType *reply_type , GDBusCallFlags flags ,
                                             gint timeout_msec , GCancellable *cancellable ,
                                             GError **error ) ;
#line 222
extern void g_dbus_connection_call_with_unix_fd_list(GDBusConnection *connection ,
                                                     gchar *bus_name , gchar *object_path ,
                                                     gchar *interface_name , gchar *method_name ,
                                                     GVariant *parameters , GVariantType *reply_type ,
                                                     GDBusCallFlags flags , gint timeout_msec ,
                                                     GUnixFDList *fd_list , GCancellable *cancellable ,
                                                     GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 236
extern GVariant *g_dbus_connection_call_with_unix_fd_list_finish(GDBusConnection *connection ,
                                                                 GUnixFDList **out_fd_list ,
                                                                 GAsyncResult *res ,
                                                                 GError **error ) ;
#line 241
extern GVariant *g_dbus_connection_call_with_unix_fd_list_sync(GDBusConnection *connection ,
                                                               gchar *bus_name , gchar *object_path ,
                                                               gchar *interface_name ,
                                                               gchar *method_name ,
                                                               GVariant *parameters ,
                                                               GVariantType *reply_type ,
                                                               GDBusCallFlags flags ,
                                                               gint timeout_msec ,
                                                               GUnixFDList *fd_list ,
                                                               GUnixFDList **out_fd_list ,
                                                               GCancellable *cancellable ,
                                                               GError **error ) ;
#line 399
extern guint g_dbus_connection_register_object(GDBusConnection *connection , gchar *object_path ,
                                               GDBusInterfaceInfo *interface_info ,
                                               GDBusInterfaceVTable *vtable , gpointer user_data ,
                                               GDestroyNotify user_data_free_func ,
                                               GError **error ) ;
#line 407
extern guint g_dbus_connection_register_object_with_closures(GDBusConnection *connection ,
                                                             gchar *object_path ,
                                                             GDBusInterfaceInfo *interface_info ,
                                                             GClosure *method_call_closure ,
                                                             GClosure *get_property_closure ,
                                                             GClosure *set_property_closure ,
                                                             GError **error ) ;
#line 415
extern gboolean g_dbus_connection_unregister_object(GDBusConnection *connection ,
                                                    guint registration_id ) ;
#line 537
extern guint g_dbus_connection_register_subtree(GDBusConnection *connection , gchar *object_path ,
                                                GDBusSubtreeVTable *vtable , GDBusSubtreeFlags flags ,
                                                gpointer user_data , GDestroyNotify user_data_free_func ,
                                                GError **error ) ;
#line 545
extern gboolean g_dbus_connection_unregister_subtree(GDBusConnection *connection ,
                                                     guint registration_id ) ;
#line 574
extern guint g_dbus_connection_signal_subscribe(GDBusConnection *connection , gchar *sender ,
                                                gchar *interface_name , gchar *member ,
                                                gchar *object_path , gchar *arg0 ,
                                                GDBusSignalFlags flags , GDBusSignalCallback callback ,
                                                gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 585
extern void g_dbus_connection_signal_unsubscribe(GDBusConnection *connection , guint subscription_id ) ;
#line 670
extern guint g_dbus_connection_add_filter(GDBusConnection *connection , GDBusMessageFilterFunction filter_function ,
                                          gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 676
extern void g_dbus_connection_remove_filter(GDBusConnection *connection , guint filter_id ) ;
#line 49 "/usr/include/glib-2.0/gio/gdbuserror.h"
extern GQuark g_dbus_error_quark(void) ;
#line 53
extern gboolean g_dbus_error_is_remote_error(GError *error ) ;
#line 55
extern gchar *g_dbus_error_get_remote_error(GError *error ) ;
#line 57
extern gboolean g_dbus_error_strip_remote_error(GError *error ) ;
#line 75
extern gboolean g_dbus_error_register_error(GQuark error_domain , gint error_code ,
                                            gchar *dbus_error_name ) ;
#line 79
extern gboolean g_dbus_error_unregister_error(GQuark error_domain , gint error_code ,
                                              gchar *dbus_error_name ) ;
#line 83
extern void g_dbus_error_register_error_domain(gchar *error_domain_quark_name , gsize *quark_volatile ,
                                               GDBusErrorEntry *entries , guint num_entries ) ;
#line 90
extern GError *g_dbus_error_new_for_dbus_error(gchar *dbus_error_name , gchar *dbus_error_message ) ;
#line 93
extern void g_dbus_error_set_dbus_error(GError **error , gchar *dbus_error_name ,
                                        gchar *dbus_error_message , gchar *format 
                                        , ...) ;
#line 99
extern void g_dbus_error_set_dbus_error_valist(GError **error , gchar *dbus_error_name ,
                                               gchar *dbus_error_message , gchar *format ,
                                               va_list var_args ) ;
#line 105
extern gchar *g_dbus_error_encode_gerror(GError *error ) ;
#line 68 "/usr/include/glib-2.0/gio/gdbusinterface.h"
extern GType g_dbus_interface_get_type(void) ;
#line 70
extern GDBusInterfaceInfo *g_dbus_interface_get_info(GDBusInterface *interface_ ) ;
#line 72
extern GDBusObject *g_dbus_interface_get_object(GDBusInterface *interface_ ) ;
#line 74
extern void g_dbus_interface_set_object(GDBusInterface *interface_ , GDBusObject *object ) ;
#line 77
extern GDBusObject *g_dbus_interface_dup_object(GDBusInterface *interface_ ) ;
#line 89 "/usr/include/glib-2.0/gio/gdbusinterfaceskeleton.h"
extern GType g_dbus_interface_skeleton_get_type(void) ;
#line 91
extern GDBusInterfaceSkeletonFlags g_dbus_interface_skeleton_get_flags(GDBusInterfaceSkeleton *interface_ ) ;
#line 93
extern void g_dbus_interface_skeleton_set_flags(GDBusInterfaceSkeleton *interface_ ,
                                                GDBusInterfaceSkeletonFlags flags ) ;
#line 96
extern GDBusInterfaceInfo *g_dbus_interface_skeleton_get_info(GDBusInterfaceSkeleton *interface_ ) ;
#line 98
extern GDBusInterfaceVTable *g_dbus_interface_skeleton_get_vtable(GDBusInterfaceSkeleton *interface_ ) ;
#line 100
extern GVariant *g_dbus_interface_skeleton_get_properties(GDBusInterfaceSkeleton *interface_ ) ;
#line 102
extern void g_dbus_interface_skeleton_flush(GDBusInterfaceSkeleton *interface_ ) ;
#line 105
extern gboolean g_dbus_interface_skeleton_export(GDBusInterfaceSkeleton *interface_ ,
                                                 GDBusConnection *connection , gchar *object_path ,
                                                 GError **error ) ;
#line 110
extern void g_dbus_interface_skeleton_unexport(GDBusInterfaceSkeleton *interface_ ) ;
#line 112
extern void g_dbus_interface_skeleton_unexport_from_connection(GDBusInterfaceSkeleton *interface_ ,
                                                               GDBusConnection *connection ) ;
#line 116
extern GDBusConnection *g_dbus_interface_skeleton_get_connection(GDBusInterfaceSkeleton *interface_ ) ;
#line 118
extern GList *g_dbus_interface_skeleton_get_connections(GDBusInterfaceSkeleton *interface_ ) ;
#line 120
extern gboolean g_dbus_interface_skeleton_has_connection(GDBusInterfaceSkeleton *interface_ ,
                                                         GDBusConnection *connection ) ;
#line 123
extern gchar *g_dbus_interface_skeleton_get_object_path(GDBusInterfaceSkeleton *interface_ ) ;
#line 183 "/usr/include/glib-2.0/gio/gdbusintrospection.h"
extern gchar *g_dbus_annotation_info_lookup(GDBusAnnotationInfo **annotations , gchar *name ) ;
#line 186
extern GDBusMethodInfo *g_dbus_interface_info_lookup_method(GDBusInterfaceInfo *info ,
                                                            gchar *name ) ;
#line 189
extern GDBusSignalInfo *g_dbus_interface_info_lookup_signal(GDBusInterfaceInfo *info ,
                                                            gchar *name ) ;
#line 192
extern GDBusPropertyInfo *g_dbus_interface_info_lookup_property(GDBusInterfaceInfo *info ,
                                                                gchar *name ) ;
#line 195
extern void g_dbus_interface_info_cache_build(GDBusInterfaceInfo *info ) ;
#line 197
extern void g_dbus_interface_info_cache_release(GDBusInterfaceInfo *info ) ;
#line 200
extern void g_dbus_interface_info_generate_xml(GDBusInterfaceInfo *info , guint indent ,
                                               GString *string_builder ) ;
#line 205
extern GDBusNodeInfo *g_dbus_node_info_new_for_xml(gchar *xml_data , GError **error ) ;
#line 208
extern GDBusInterfaceInfo *g_dbus_node_info_lookup_interface(GDBusNodeInfo *info ,
                                                             gchar *name ) ;
#line 211
extern void g_dbus_node_info_generate_xml(GDBusNodeInfo *info , guint indent , GString *string_builder ) ;
#line 216
extern GDBusNodeInfo *g_dbus_node_info_ref(GDBusNodeInfo *info ) ;
#line 218
extern GDBusInterfaceInfo *g_dbus_interface_info_ref(GDBusInterfaceInfo *info ) ;
#line 220
extern GDBusMethodInfo *g_dbus_method_info_ref(GDBusMethodInfo *info ) ;
#line 222
extern GDBusSignalInfo *g_dbus_signal_info_ref(GDBusSignalInfo *info ) ;
#line 224
extern GDBusPropertyInfo *g_dbus_property_info_ref(GDBusPropertyInfo *info ) ;
#line 226
extern GDBusArgInfo *g_dbus_arg_info_ref(GDBusArgInfo *info ) ;
#line 228
extern GDBusAnnotationInfo *g_dbus_annotation_info_ref(GDBusAnnotationInfo *info ) ;
#line 231
extern void g_dbus_node_info_unref(GDBusNodeInfo *info ) ;
#line 233
extern void g_dbus_interface_info_unref(GDBusInterfaceInfo *info ) ;
#line 235
extern void g_dbus_method_info_unref(GDBusMethodInfo *info ) ;
#line 237
extern void g_dbus_signal_info_unref(GDBusSignalInfo *info ) ;
#line 239
extern void g_dbus_property_info_unref(GDBusPropertyInfo *info ) ;
#line 241
extern void g_dbus_arg_info_unref(GDBusArgInfo *info ) ;
#line 243
extern void g_dbus_annotation_info_unref(GDBusAnnotationInfo *info ) ;
#line 309
extern GType g_dbus_node_info_get_type(void) ;
#line 311
extern GType g_dbus_interface_info_get_type(void) ;
#line 313
extern GType g_dbus_method_info_get_type(void) ;
#line 315
extern GType g_dbus_signal_info_get_type(void) ;
#line 317
extern GType g_dbus_property_info_get_type(void) ;
#line 319
extern GType g_dbus_arg_info_get_type(void) ;
#line 321
extern GType g_dbus_annotation_info_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/gdbusmenumodel.h"
extern GType g_dbus_menu_model_get_type(void) ;
#line 39
extern GDBusMenuModel *g_dbus_menu_model_get(GDBusConnection *connection , gchar *bus_name ,
                                             gchar *object_path ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusmessage.h"
extern GType g_dbus_message_get_type(void) ;
#line 39
extern GDBusMessage *g_dbus_message_new(void) ;
#line 41
extern GDBusMessage *g_dbus_message_new_signal(gchar *path , gchar *interface_ , gchar *signal ) ;
#line 45
extern GDBusMessage *g_dbus_message_new_method_call(gchar *name , gchar *path , gchar *interface_ ,
                                                    gchar *method ) ;
#line 50
extern GDBusMessage *g_dbus_message_new_method_reply(GDBusMessage *method_call_message ) ;
#line 52
extern GDBusMessage *g_dbus_message_new_method_error(GDBusMessage *method_call_message ,
                                                     gchar *error_name , gchar *error_message_format 
                                                     , ...) ;
#line 57
extern GDBusMessage *g_dbus_message_new_method_error_valist(GDBusMessage *method_call_message ,
                                                            gchar *error_name , gchar *error_message_format ,
                                                            va_list var_args ) ;
#line 62
extern GDBusMessage *g_dbus_message_new_method_error_literal(GDBusMessage *method_call_message ,
                                                             gchar *error_name , gchar *error_message ) ;
#line 66
extern gchar *g_dbus_message_print(GDBusMessage *message , guint indent ) ;
#line 69
extern gboolean g_dbus_message_get_locked(GDBusMessage *message ) ;
#line 71
extern void g_dbus_message_lock(GDBusMessage *message ) ;
#line 73
extern GDBusMessage *g_dbus_message_copy(GDBusMessage *message , GError **error ) ;
#line 76
extern GDBusMessageByteOrder g_dbus_message_get_byte_order(GDBusMessage *message ) ;
#line 78
extern void g_dbus_message_set_byte_order(GDBusMessage *message , GDBusMessageByteOrder byte_order ) ;
#line 82
extern GDBusMessageType g_dbus_message_get_message_type(GDBusMessage *message ) ;
#line 84
extern void g_dbus_message_set_message_type(GDBusMessage *message , GDBusMessageType type ) ;
#line 87
extern GDBusMessageFlags g_dbus_message_get_flags(GDBusMessage *message ) ;
#line 89
extern void g_dbus_message_set_flags(GDBusMessage *message , GDBusMessageFlags flags ) ;
#line 92
extern guint32 g_dbus_message_get_serial(GDBusMessage *message ) ;
#line 94
extern void g_dbus_message_set_serial(GDBusMessage *message , guint32 serial ) ;
#line 97
extern GVariant *g_dbus_message_get_header(GDBusMessage *message , GDBusMessageHeaderField header_field ) ;
#line 100
extern void g_dbus_message_set_header(GDBusMessage *message , GDBusMessageHeaderField header_field ,
                                      GVariant *value ) ;
#line 104
extern guchar *g_dbus_message_get_header_fields(GDBusMessage *message ) ;
#line 106
extern GVariant *g_dbus_message_get_body(GDBusMessage *message ) ;
#line 108
extern void g_dbus_message_set_body(GDBusMessage *message , GVariant *body ) ;
#line 111
extern GUnixFDList *g_dbus_message_get_unix_fd_list(GDBusMessage *message ) ;
#line 113
extern void g_dbus_message_set_unix_fd_list(GDBusMessage *message , GUnixFDList *fd_list ) ;
#line 117
extern guint32 g_dbus_message_get_reply_serial(GDBusMessage *message ) ;
#line 119
extern void g_dbus_message_set_reply_serial(GDBusMessage *message , guint32 value ) ;
#line 123
extern gchar *g_dbus_message_get_interface(GDBusMessage *message ) ;
#line 125
extern void g_dbus_message_set_interface(GDBusMessage *message , gchar *value ) ;
#line 129
extern gchar *g_dbus_message_get_member(GDBusMessage *message ) ;
#line 131
extern void g_dbus_message_set_member(GDBusMessage *message , gchar *value ) ;
#line 135
extern gchar *g_dbus_message_get_path(GDBusMessage *message ) ;
#line 137
extern void g_dbus_message_set_path(GDBusMessage *message , gchar *value ) ;
#line 141
extern gchar *g_dbus_message_get_sender(GDBusMessage *message ) ;
#line 143
extern void g_dbus_message_set_sender(GDBusMessage *message , gchar *value ) ;
#line 147
extern gchar *g_dbus_message_get_destination(GDBusMessage *message ) ;
#line 149
extern void g_dbus_message_set_destination(GDBusMessage *message , gchar *value ) ;
#line 153
extern gchar *g_dbus_message_get_error_name(GDBusMessage *message ) ;
#line 155
extern void g_dbus_message_set_error_name(GDBusMessage *message , gchar *value ) ;
#line 159
extern gchar *g_dbus_message_get_signature(GDBusMessage *message ) ;
#line 161
extern void g_dbus_message_set_signature(GDBusMessage *message , gchar *value ) ;
#line 165
extern guint32 g_dbus_message_get_num_unix_fds(GDBusMessage *message ) ;
#line 167
extern void g_dbus_message_set_num_unix_fds(GDBusMessage *message , guint32 value ) ;
#line 171
extern gchar *g_dbus_message_get_arg0(GDBusMessage *message ) ;
#line 175
extern GDBusMessage *g_dbus_message_new_from_blob(guchar *blob , gsize blob_len ,
                                                  GDBusCapabilityFlags capabilities ,
                                                  GError **error ) ;
#line 181
extern gssize g_dbus_message_bytes_needed(guchar *blob , gsize blob_len , GError **error ) ;
#line 186
extern guchar *g_dbus_message_to_blob(GDBusMessage *message , gsize *out_size , GDBusCapabilityFlags capabilities ,
                                      GError **error ) ;
#line 192
extern gboolean g_dbus_message_to_gerror(GDBusMessage *message , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gdbusmethodinvocation.h"
extern GType g_dbus_method_invocation_get_type(void) ;
#line 74
extern gchar *g_dbus_method_invocation_get_sender(GDBusMethodInvocation *invocation ) ;
#line 76
extern gchar *g_dbus_method_invocation_get_object_path(GDBusMethodInvocation *invocation ) ;
#line 78
extern gchar *g_dbus_method_invocation_get_interface_name(GDBusMethodInvocation *invocation ) ;
#line 80
extern gchar *g_dbus_method_invocation_get_method_name(GDBusMethodInvocation *invocation ) ;
#line 82
extern GDBusMethodInfo *g_dbus_method_invocation_get_method_info(GDBusMethodInvocation *invocation ) ;
#line 84
extern GDBusPropertyInfo *g_dbus_method_invocation_get_property_info(GDBusMethodInvocation *invocation ) ;
#line 86
extern GDBusConnection *g_dbus_method_invocation_get_connection(GDBusMethodInvocation *invocation ) ;
#line 88
extern GDBusMessage *g_dbus_method_invocation_get_message(GDBusMethodInvocation *invocation ) ;
#line 90
extern GVariant *g_dbus_method_invocation_get_parameters(GDBusMethodInvocation *invocation ) ;
#line 92
extern gpointer g_dbus_method_invocation_get_user_data(GDBusMethodInvocation *invocation ) ;
#line 95
extern void g_dbus_method_invocation_return_value(GDBusMethodInvocation *invocation ,
                                                  GVariant *parameters ) ;
#line 98
extern void g_dbus_method_invocation_return_value_with_unix_fd_list(GDBusMethodInvocation *invocation ,
                                                                    GVariant *parameters ,
                                                                    GUnixFDList *fd_list ) ;
#line 102
extern void g_dbus_method_invocation_return_error(GDBusMethodInvocation *invocation ,
                                                  GQuark domain , gint code , gchar *format 
                                                  , ...) ;
#line 108
extern void g_dbus_method_invocation_return_error_valist(GDBusMethodInvocation *invocation ,
                                                         GQuark domain , gint code ,
                                                         gchar *format , va_list var_args ) ;
#line 115
extern void g_dbus_method_invocation_return_error_literal(GDBusMethodInvocation *invocation ,
                                                          GQuark domain , gint code ,
                                                          gchar *message ) ;
#line 120
extern void g_dbus_method_invocation_return_gerror(GDBusMethodInvocation *invocation ,
                                                   GError *error ) ;
#line 123
extern void g_dbus_method_invocation_take_error(GDBusMethodInvocation *invocation ,
                                                GError *error ) ;
#line 126
extern void g_dbus_method_invocation_return_dbus_error(GDBusMethodInvocation *invocation ,
                                                       gchar *error_name , gchar *error_message ) ;
#line 76 "/usr/include/glib-2.0/gio/gdbusnameowning.h"
extern guint g_bus_own_name(GBusType bus_type , gchar *name , GBusNameOwnerFlags flags ,
                            GBusAcquiredCallback bus_acquired_handler , GBusNameAcquiredCallback name_acquired_handler ,
                            GBusNameLostCallback name_lost_handler , gpointer user_data ,
                            GDestroyNotify user_data_free_func ) ;
#line 86
extern guint g_bus_own_name_on_connection(GDBusConnection *connection , gchar *name ,
                                          GBusNameOwnerFlags flags , GBusNameAcquiredCallback name_acquired_handler ,
                                          GBusNameLostCallback name_lost_handler ,
                                          gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 95
extern guint g_bus_own_name_with_closures(GBusType bus_type , gchar *name , GBusNameOwnerFlags flags ,
                                          GClosure *bus_acquired_closure , GClosure *name_acquired_closure ,
                                          GClosure *name_lost_closure ) ;
#line 103
extern guint g_bus_own_name_on_connection_with_closures(GDBusConnection *connection ,
                                                        gchar *name , GBusNameOwnerFlags flags ,
                                                        GClosure *name_acquired_closure ,
                                                        GClosure *name_lost_closure ) ;
#line 111
extern void g_bus_unown_name(guint owner_id ) ;
#line 69 "/usr/include/glib-2.0/gio/gdbusnamewatching.h"
extern guint g_bus_watch_name(GBusType bus_type , gchar *name , GBusNameWatcherFlags flags ,
                              GBusNameAppearedCallback name_appeared_handler , GBusNameVanishedCallback name_vanished_handler ,
                              gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 77
extern guint g_bus_watch_name_on_connection(GDBusConnection *connection , gchar *name ,
                                            GBusNameWatcherFlags flags , GBusNameAppearedCallback name_appeared_handler ,
                                            GBusNameVanishedCallback name_vanished_handler ,
                                            gpointer user_data , GDestroyNotify user_data_free_func ) ;
#line 85
extern guint g_bus_watch_name_with_closures(GBusType bus_type , gchar *name , GBusNameWatcherFlags flags ,
                                            GClosure *name_appeared_closure , GClosure *name_vanished_closure ) ;
#line 91
extern guint g_bus_watch_name_on_connection_with_closures(GDBusConnection *connection ,
                                                          gchar *name , GBusNameWatcherFlags flags ,
                                                          GClosure *name_appeared_closure ,
                                                          GClosure *name_vanished_closure ) ;
#line 98
extern void g_bus_unwatch_name(guint watcher_id ) ;
#line 67 "/usr/include/glib-2.0/gio/gdbusobject.h"
extern GType g_dbus_object_get_type(void) ;
#line 69
extern gchar *g_dbus_object_get_object_path(GDBusObject *object ) ;
#line 71
extern GList *g_dbus_object_get_interfaces(GDBusObject *object ) ;
#line 73
extern GDBusInterface *g_dbus_object_get_interface(GDBusObject *object , gchar *interface_name ) ;
#line 79 "/usr/include/glib-2.0/gio/gdbusobjectmanager.h"
extern GType g_dbus_object_manager_get_type(void) ;
#line 81
extern gchar *g_dbus_object_manager_get_object_path(GDBusObjectManager *manager ) ;
#line 83
extern GList *g_dbus_object_manager_get_objects(GDBusObjectManager *manager ) ;
#line 85
extern GDBusObject *g_dbus_object_manager_get_object(GDBusObjectManager *manager ,
                                                     gchar *object_path ) ;
#line 88
extern GDBusInterface *g_dbus_object_manager_get_interface(GDBusObjectManager *manager ,
                                                           gchar *object_path , gchar *interface_name ) ;
#line 86 "/usr/include/glib-2.0/gio/gdbusobjectmanagerclient.h"
extern GType g_dbus_object_manager_client_get_type(void) ;
#line 88
extern void g_dbus_object_manager_client_new(GDBusConnection *connection , GDBusObjectManagerClientFlags flags ,
                                             gchar *name , gchar *object_path , GDBusProxyTypeFunc get_proxy_type_func ,
                                             gpointer get_proxy_type_user_data , GDestroyNotify get_proxy_type_destroy_notify ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 99
extern GDBusObjectManager *g_dbus_object_manager_client_new_finish(GAsyncResult *res ,
                                                                   GError **error ) ;
#line 102
extern GDBusObjectManager *g_dbus_object_manager_client_new_sync(GDBusConnection *connection ,
                                                                 GDBusObjectManagerClientFlags flags ,
                                                                 gchar *name , gchar *object_path ,
                                                                 GDBusProxyTypeFunc get_proxy_type_func ,
                                                                 gpointer get_proxy_type_user_data ,
                                                                 GDestroyNotify get_proxy_type_destroy_notify ,
                                                                 GCancellable *cancellable ,
                                                                 GError **error ) ;
#line 112
extern void g_dbus_object_manager_client_new_for_bus(GBusType bus_type , GDBusObjectManagerClientFlags flags ,
                                                     gchar *name , gchar *object_path ,
                                                     GDBusProxyTypeFunc get_proxy_type_func ,
                                                     gpointer get_proxy_type_user_data ,
                                                     GDestroyNotify get_proxy_type_destroy_notify ,
                                                     GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 123
extern GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_finish(GAsyncResult *res ,
                                                                           GError **error ) ;
#line 126
extern GDBusObjectManager *g_dbus_object_manager_client_new_for_bus_sync(GBusType bus_type ,
                                                                         GDBusObjectManagerClientFlags flags ,
                                                                         gchar *name ,
                                                                         gchar *object_path ,
                                                                         GDBusProxyTypeFunc get_proxy_type_func ,
                                                                         gpointer get_proxy_type_user_data ,
                                                                         GDestroyNotify get_proxy_type_destroy_notify ,
                                                                         GCancellable *cancellable ,
                                                                         GError **error ) ;
#line 136
extern GDBusConnection *g_dbus_object_manager_client_get_connection(GDBusObjectManagerClient *manager ) ;
#line 138
extern GDBusObjectManagerClientFlags g_dbus_object_manager_client_get_flags(GDBusObjectManagerClient *manager ) ;
#line 140
extern gchar *g_dbus_object_manager_client_get_name(GDBusObjectManagerClient *manager ) ;
#line 142
extern gchar *g_dbus_object_manager_client_get_name_owner(GDBusObjectManagerClient *manager ) ;
#line 70 "/usr/include/glib-2.0/gio/gdbusobjectmanagerserver.h"
extern GType g_dbus_object_manager_server_get_type(void) ;
#line 72
extern GDBusObjectManagerServer *g_dbus_object_manager_server_new(gchar *object_path ) ;
#line 74
extern GDBusConnection *g_dbus_object_manager_server_get_connection(GDBusObjectManagerServer *manager ) ;
#line 76
extern void g_dbus_object_manager_server_set_connection(GDBusObjectManagerServer *manager ,
                                                        GDBusConnection *connection ) ;
#line 79
extern void g_dbus_object_manager_server_export(GDBusObjectManagerServer *manager ,
                                                GDBusObjectSkeleton *object ) ;
#line 82
extern void g_dbus_object_manager_server_export_uniquely(GDBusObjectManagerServer *manager ,
                                                         GDBusObjectSkeleton *object ) ;
#line 85
extern gboolean g_dbus_object_manager_server_is_exported(GDBusObjectManagerServer *manager ,
                                                         GDBusObjectSkeleton *object ) ;
#line 88
extern gboolean g_dbus_object_manager_server_unexport(GDBusObjectManagerServer *manager ,
                                                      gchar *object_path ) ;
#line 70 "/usr/include/glib-2.0/gio/gdbusobjectproxy.h"
extern GType g_dbus_object_proxy_get_type(void) ;
#line 72
extern GDBusObjectProxy *g_dbus_object_proxy_new(GDBusConnection *connection , gchar *object_path ) ;
#line 75
extern GDBusConnection *g_dbus_object_proxy_get_connection(GDBusObjectProxy *proxy ) ;
#line 76 "/usr/include/glib-2.0/gio/gdbusobjectskeleton.h"
extern GType g_dbus_object_skeleton_get_type(void) ;
#line 78
extern GDBusObjectSkeleton *g_dbus_object_skeleton_new(gchar *object_path ) ;
#line 80
extern void g_dbus_object_skeleton_flush(GDBusObjectSkeleton *object ) ;
#line 82
extern void g_dbus_object_skeleton_add_interface(GDBusObjectSkeleton *object , GDBusInterfaceSkeleton *interface_ ) ;
#line 85
extern void g_dbus_object_skeleton_remove_interface(GDBusObjectSkeleton *object ,
                                                    GDBusInterfaceSkeleton *interface_ ) ;
#line 88
extern void g_dbus_object_skeleton_remove_interface_by_name(GDBusObjectSkeleton *object ,
                                                            gchar *interface_name ) ;
#line 91
extern void g_dbus_object_skeleton_set_object_path(GDBusObjectSkeleton *object , gchar *object_path ) ;
#line 88 "/usr/include/glib-2.0/gio/gdbusproxy.h"
extern GType g_dbus_proxy_get_type(void) ;
#line 90
extern void g_dbus_proxy_new(GDBusConnection *connection , GDBusProxyFlags flags ,
                             GDBusInterfaceInfo *info , gchar *name , gchar *object_path ,
                             gchar *interface_name , GCancellable *cancellable , GAsyncReadyCallback callback ,
                             gpointer user_data ) ;
#line 100
extern GDBusProxy *g_dbus_proxy_new_finish(GAsyncResult *res , GError **error ) ;
#line 103
extern GDBusProxy *g_dbus_proxy_new_sync(GDBusConnection *connection , GDBusProxyFlags flags ,
                                         GDBusInterfaceInfo *info , gchar *name ,
                                         gchar *object_path , gchar *interface_name ,
                                         GCancellable *cancellable , GError **error ) ;
#line 112
extern void g_dbus_proxy_new_for_bus(GBusType bus_type , GDBusProxyFlags flags , GDBusInterfaceInfo *info ,
                                     gchar *name , gchar *object_path , gchar *interface_name ,
                                     GCancellable *cancellable , GAsyncReadyCallback callback ,
                                     gpointer user_data ) ;
#line 122
extern GDBusProxy *g_dbus_proxy_new_for_bus_finish(GAsyncResult *res , GError **error ) ;
#line 125
extern GDBusProxy *g_dbus_proxy_new_for_bus_sync(GBusType bus_type , GDBusProxyFlags flags ,
                                                 GDBusInterfaceInfo *info , gchar *name ,
                                                 gchar *object_path , gchar *interface_name ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 134
extern GDBusConnection *g_dbus_proxy_get_connection(GDBusProxy *proxy ) ;
#line 136
extern GDBusProxyFlags g_dbus_proxy_get_flags(GDBusProxy *proxy ) ;
#line 138
extern gchar *g_dbus_proxy_get_name(GDBusProxy *proxy ) ;
#line 140
extern gchar *g_dbus_proxy_get_name_owner(GDBusProxy *proxy ) ;
#line 142
extern gchar *g_dbus_proxy_get_object_path(GDBusProxy *proxy ) ;
#line 144
extern gchar *g_dbus_proxy_get_interface_name(GDBusProxy *proxy ) ;
#line 146
extern gint g_dbus_proxy_get_default_timeout(GDBusProxy *proxy ) ;
#line 148
extern void g_dbus_proxy_set_default_timeout(GDBusProxy *proxy , gint timeout_msec ) ;
#line 151
extern GDBusInterfaceInfo *g_dbus_proxy_get_interface_info(GDBusProxy *proxy ) ;
#line 153
extern void g_dbus_proxy_set_interface_info(GDBusProxy *proxy , GDBusInterfaceInfo *info ) ;
#line 156
extern GVariant *g_dbus_proxy_get_cached_property(GDBusProxy *proxy , gchar *property_name ) ;
#line 159
extern void g_dbus_proxy_set_cached_property(GDBusProxy *proxy , gchar *property_name ,
                                             GVariant *value ) ;
#line 163
extern gchar **g_dbus_proxy_get_cached_property_names(GDBusProxy *proxy ) ;
#line 165
extern void g_dbus_proxy_call(GDBusProxy *proxy , gchar *method_name , GVariant *parameters ,
                              GDBusCallFlags flags , gint timeout_msec , GCancellable *cancellable ,
                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 174
extern GVariant *g_dbus_proxy_call_finish(GDBusProxy *proxy , GAsyncResult *res ,
                                          GError **error ) ;
#line 178
extern GVariant *g_dbus_proxy_call_sync(GDBusProxy *proxy , gchar *method_name , GVariant *parameters ,
                                        GDBusCallFlags flags , gint timeout_msec ,
                                        GCancellable *cancellable , GError **error ) ;
#line 187
extern void g_dbus_proxy_call_with_unix_fd_list(GDBusProxy *proxy , gchar *method_name ,
                                                GVariant *parameters , GDBusCallFlags flags ,
                                                gint timeout_msec , GUnixFDList *fd_list ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 197
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_finish(GDBusProxy *proxy , GUnixFDList **out_fd_list ,
                                                            GAsyncResult *res , GError **error ) ;
#line 202
extern GVariant *g_dbus_proxy_call_with_unix_fd_list_sync(GDBusProxy *proxy , gchar *method_name ,
                                                          GVariant *parameters , GDBusCallFlags flags ,
                                                          gint timeout_msec , GUnixFDList *fd_list ,
                                                          GUnixFDList **out_fd_list ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 37 "/usr/include/glib-2.0/gio/gdbusserver.h"
extern GType g_dbus_server_get_type(void) ;
#line 39
extern GDBusServer *g_dbus_server_new_sync(gchar *address , GDBusServerFlags flags ,
                                           gchar *guid , GDBusAuthObserver *observer ,
                                           GCancellable *cancellable , GError **error ) ;
#line 46
extern gchar *g_dbus_server_get_client_address(GDBusServer *server ) ;
#line 48
extern gchar *g_dbus_server_get_guid(GDBusServer *server ) ;
#line 50
extern GDBusServerFlags g_dbus_server_get_flags(GDBusServer *server ) ;
#line 52
extern void g_dbus_server_start(GDBusServer *server ) ;
#line 54
extern void g_dbus_server_stop(GDBusServer *server ) ;
#line 56
extern gboolean g_dbus_server_is_active(GDBusServer *server ) ;
#line 33 "/usr/include/glib-2.0/gio/gdbusutils.h"
extern gboolean g_dbus_is_guid(gchar *string ) ;
#line 35
extern gchar *g_dbus_generate_guid(void) ;
#line 38
extern gboolean g_dbus_is_name(gchar *string ) ;
#line 40
extern gboolean g_dbus_is_unique_name(gchar *string ) ;
#line 42
extern gboolean g_dbus_is_member_name(gchar *string ) ;
#line 44
extern gboolean g_dbus_is_interface_name(gchar *string ) ;
#line 46
extern gboolean g_dbus_is_error_name(gchar *string ) ;
#line 49
extern void g_dbus_gvariant_to_gvalue(GVariant *value , GValue *out_gvalue ) ;
#line 52
extern GVariant *g_dbus_gvalue_to_gvariant(GValue *gvalue , GVariantType *type ) ;
#line 55
extern gchar *g_dbus_escape_object_path_bytestring(guint8 *bytes ) ;
#line 57
extern gchar *g_dbus_escape_object_path(gchar *s ) ;
#line 59
extern guint8 *g_dbus_unescape_object_path(gchar *s ) ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
extern GType g_debug_controller_get_type(void) ;
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_autoptr_clear_GDebugController(GDebugController *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_autoptr_cleanup_GDebugController(GDebugController **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GDebugController(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_listautoptr_cleanup_GDebugController(GList **_l ) 
{ 


  {
  {
#line 52
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_slistautoptr_cleanup_GDebugController(GSList **_l ) 
{ 


  {
  {
#line 52
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static void glib_queueautoptr_cleanup_GDebugController(GQueue **_q ) 
{ 


  {
#line 52
  if (*_q) {
    {
#line 52
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& glib_autoptr_clear_GObject)));
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static GDebugController *g_debug_controller(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 52
  __cil_tmp2 = g_debug_controller_get_type();
#line 52
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 52
  return ((GDebugController *)((void *)__cil_tmp3));
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static gboolean g_IS_debug_controller(gpointer ptr ) 
{ 


  {
#line 52
  return (0);
}
}
#line 52 "/usr/include/glib-2.0/gio/gdebugcontroller.h"
__inline static GDebugControllerInterface *g_debug_controller_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 52
  __cil_tmp2 = g_debug_controller_get_type();
#line 52
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 52
  return ((GDebugControllerInterface *)__cil_tmp3);
}
}
#line 72
extern gboolean g_debug_controller_get_debug_enabled(GDebugController *self ) ;
#line 74
extern void g_debug_controller_set_debug_enabled(GDebugController *self , gboolean debug_enabled ) ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
extern GType g_debug_controller_dbus_get_type(void) ;
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_clear_GDebugControllerDBus(GDebugControllerDBus *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_cleanup_GDebugControllerDBus(GDebugControllerDBus **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GDebugControllerDBus(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_clear_GDebugControllerDBusClass(GDebugControllerDBusClass *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    g_type_class_unref((GDebugControllerDBusClass *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static void glib_autoptr_cleanup_GDebugControllerDBusClass(GDebugControllerDBusClass **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GDebugControllerDBusClass(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBus *G_DEBUG_CONTROLLER_DBUS(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp2 = g_debug_controller_dbus_get_type();
#line 38
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 38
  return ((GDebugControllerDBus *)((void *)__cil_tmp3));
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBusClass *G_DEBUG_CONTROLLER_DBUS_CLASS(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeClass *__cil_tmp3 ;

  {
  {
#line 38
  __cil_tmp2 = g_debug_controller_dbus_get_type();
#line 38
  __cil_tmp3 = g_type_check_class_cast((GTypeClass *)ptr, __cil_tmp2);
  }
#line 38
  return ((GDebugControllerDBusClass *)((void *)__cil_tmp3));
}
}
#line 38 "/usr/include/glib-2.0/gio/gdebugcontrollerdbus.h"
__inline static GDebugControllerDBusClass *G_DEBUG_CONTROLLER_DBUS_GET_CLASS(gpointer ptr ) 
{ 


  {
#line 38
  return ((GDebugControllerDBusClass *)((GTypeInstance *)ptr)->g_class);
}
}
#line 60
extern GDebugControllerDBus *g_debug_controller_dbus_new(GDBusConnection *connection ,
                                                         GCancellable *cancellable ,
                                                         GError **error ) ;
#line 65
extern void g_debug_controller_dbus_stop(GDebugControllerDBus *self ) ;
#line 172 "/usr/include/glib-2.0/gio/gdrive.h"
extern GType g_drive_get_type(void) ;
#line 175
extern char *g_drive_get_name(GDrive *drive ) ;
#line 177
extern GIcon *g_drive_get_icon(GDrive *drive ) ;
#line 179
extern GIcon *g_drive_get_symbolic_icon(GDrive *drive ) ;
#line 181
extern gboolean g_drive_has_volumes(GDrive *drive ) ;
#line 183
extern GList *g_drive_get_volumes(GDrive *drive ) ;
#line 185
extern gboolean g_drive_is_removable(GDrive *drive ) ;
#line 187
extern gboolean g_drive_is_media_removable(GDrive *drive ) ;
#line 189
extern gboolean g_drive_has_media(GDrive *drive ) ;
#line 191
extern gboolean g_drive_is_media_check_automatic(GDrive *drive ) ;
#line 193
extern gboolean g_drive_can_poll_for_media(GDrive *drive ) ;
#line 195
extern gboolean g_drive_can_eject(GDrive *drive ) ;
#line 197
extern void g_drive_eject(GDrive *drive , GMountUnmountFlags flags , GCancellable *cancellable ,
                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 204
extern gboolean g_drive_eject_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 208
extern void g_drive_poll_for_media(GDrive *drive , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 213
extern gboolean g_drive_poll_for_media_finish(GDrive *drive , GAsyncResult *result ,
                                              GError **error ) ;
#line 217
extern char *g_drive_get_identifier(GDrive *drive , char const   *kind ) ;
#line 220
extern char **g_drive_enumerate_identifiers(GDrive *drive ) ;
#line 223
extern GDriveStartStopType g_drive_get_start_stop_type(GDrive *drive ) ;
#line 226
extern gboolean g_drive_can_start(GDrive *drive ) ;
#line 228
extern gboolean g_drive_can_start_degraded(GDrive *drive ) ;
#line 230
extern void g_drive_start(GDrive *drive , GDriveStartFlags flags , GMountOperation *mount_operation ,
                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                          gpointer user_data ) ;
#line 237
extern gboolean g_drive_start_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 242
extern gboolean g_drive_can_stop(GDrive *drive ) ;
#line 244
extern void g_drive_stop(GDrive *drive , GMountUnmountFlags flags , GMountOperation *mount_operation ,
                         GCancellable *cancellable , GAsyncReadyCallback callback ,
                         gpointer user_data ) ;
#line 251
extern gboolean g_drive_stop_finish(GDrive *drive , GAsyncResult *result , GError **error ) ;
#line 256
extern void g_drive_eject_with_operation(GDrive *drive , GMountUnmountFlags flags ,
                                         GMountOperation *mount_operation , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 263
extern gboolean g_drive_eject_with_operation_finish(GDrive *drive , GAsyncResult *result ,
                                                    GError **error ) ;
#line 268
extern gchar *g_drive_get_sort_key(GDrive *drive ) ;
#line 109 "/usr/include/glib-2.0/gio/gdtlsconnection.h"
extern GType g_dtls_connection_get_type(void) ;
#line 112
extern void g_dtls_connection_set_database(GDtlsConnection *conn , GTlsDatabase *database ) ;
#line 115
extern GTlsDatabase *g_dtls_connection_get_database(GDtlsConnection *conn ) ;
#line 118
extern void g_dtls_connection_set_certificate(GDtlsConnection *conn , GTlsCertificate *certificate ) ;
#line 121
extern GTlsCertificate *g_dtls_connection_get_certificate(GDtlsConnection *conn ) ;
#line 124
extern void g_dtls_connection_set_interaction(GDtlsConnection *conn , GTlsInteraction *interaction ) ;
#line 127
extern GTlsInteraction *g_dtls_connection_get_interaction(GDtlsConnection *conn ) ;
#line 130
extern GTlsCertificate *g_dtls_connection_get_peer_certificate(GDtlsConnection *conn ) ;
#line 132
extern GTlsCertificateFlags g_dtls_connection_get_peer_certificate_errors(GDtlsConnection *conn ) ;
#line 135
extern void g_dtls_connection_set_require_close_notify(GDtlsConnection *conn , gboolean require_close_notify ) ;
#line 138
extern gboolean g_dtls_connection_get_require_close_notify(GDtlsConnection *conn ) ;
#line 142
extern void g_dtls_connection_set_rehandshake_mode(GDtlsConnection *conn , GTlsRehandshakeMode mode ) ;
#line 145
extern GTlsRehandshakeMode g_dtls_connection_get_rehandshake_mode(GDtlsConnection *conn ) ;
#line 149
extern gboolean g_dtls_connection_handshake(GDtlsConnection *conn , GCancellable *cancellable ,
                                            GError **error ) ;
#line 154
extern void g_dtls_connection_handshake_async(GDtlsConnection *conn , int io_priority ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 160
extern gboolean g_dtls_connection_handshake_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                                   GError **error ) ;
#line 165
extern gboolean g_dtls_connection_shutdown(GDtlsConnection *conn , gboolean shutdown_read ,
                                           gboolean shutdown_write , GCancellable *cancellable ,
                                           GError **error ) ;
#line 172
extern void g_dtls_connection_shutdown_async(GDtlsConnection *conn , gboolean shutdown_read ,
                                             gboolean shutdown_write , int io_priority ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 180
extern gboolean g_dtls_connection_shutdown_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                                  GError **error ) ;
#line 185
extern gboolean g_dtls_connection_close(GDtlsConnection *conn , GCancellable *cancellable ,
                                        GError **error ) ;
#line 190
extern void g_dtls_connection_close_async(GDtlsConnection *conn , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 196
extern gboolean g_dtls_connection_close_finish(GDtlsConnection *conn , GAsyncResult *result ,
                                               GError **error ) ;
#line 202
extern gboolean g_dtls_connection_emit_accept_certificate(GDtlsConnection *conn ,
                                                          GTlsCertificate *peer_cert ,
                                                          GTlsCertificateFlags errors ) ;
#line 206
extern void g_dtls_connection_set_advertised_protocols(GDtlsConnection *conn , gchar * const  *protocols ) ;
#line 210
extern gchar *g_dtls_connection_get_negotiated_protocol(GDtlsConnection *conn ) ;
#line 214
extern gboolean g_dtls_connection_get_channel_binding_data(GDtlsConnection *conn ,
                                                           GTlsChannelBindingType type ,
                                                           GByteArray *data , GError **error ) ;
#line 221
extern GTlsProtocolVersion g_dtls_connection_get_protocol_version(GDtlsConnection *conn ) ;
#line 224
extern gchar *g_dtls_connection_get_ciphersuite_name(GDtlsConnection *conn ) ;
#line 52 "/usr/include/glib-2.0/gio/gdtlsclientconnection.h"
extern GType g_dtls_client_connection_get_type(void) ;
#line 55
extern GDatagramBased *g_dtls_client_connection_new(GDatagramBased *base_socket ,
                                                    GSocketConnectable *server_identity ,
                                                    GError **error ) ;
#line 60
extern GTlsCertificateFlags g_dtls_client_connection_get_validation_flags(GDtlsClientConnection *conn ) ;
#line 62
extern void g_dtls_client_connection_set_validation_flags(GDtlsClientConnection *conn ,
                                                          GTlsCertificateFlags flags ) ;
#line 65
extern GSocketConnectable *g_dtls_client_connection_get_server_identity(GDtlsClientConnection *conn ) ;
#line 67
extern void g_dtls_client_connection_set_server_identity(GDtlsClientConnection *conn ,
                                                         GSocketConnectable *identity ) ;
#line 70
extern GList *g_dtls_client_connection_get_accepted_cas(GDtlsClientConnection *conn ) ;
#line 60 "/usr/include/glib-2.0/gio/gdtlsserverconnection.h"
extern GType g_dtls_server_connection_get_type(void) ;
#line 63
extern GDatagramBased *g_dtls_server_connection_new(GDatagramBased *base_socket ,
                                                    GTlsCertificate *certificate ,
                                                    GError **error ) ;
#line 82 "/usr/include/glib-2.0/gio/gicon.h"
extern GType g_icon_get_type(void) ;
#line 85
extern guint g_icon_hash(gconstpointer icon ) ;
#line 87
extern gboolean g_icon_equal(GIcon *icon1 , GIcon *icon2 ) ;
#line 90
extern gchar *g_icon_to_string(GIcon *icon ) ;
#line 92
extern GIcon *g_icon_new_for_string(gchar *str , GError **error ) ;
#line 96
extern GVariant *g_icon_serialize(GIcon *icon ) ;
#line 98
extern GIcon *g_icon_deserialize(GVariant *value ) ;
#line 47 "/usr/include/glib-2.0/gio/gemblem.h"
extern GType g_emblem_get_type(void) ;
#line 50
extern GEmblem *g_emblem_new(GIcon *icon ) ;
#line 52
extern GEmblem *g_emblem_new_with_origin(GIcon *icon , GEmblemOrigin origin ) ;
#line 55
extern GIcon *g_emblem_get_icon(GEmblem *emblem ) ;
#line 57
extern GEmblemOrigin g_emblem_get_origin(GEmblem *emblem ) ;
#line 64 "/usr/include/glib-2.0/gio/gemblemedicon.h"
extern GType g_emblemed_icon_get_type(void) ;
#line 67
extern GIcon *g_emblemed_icon_new(GIcon *icon , GEmblem *emblem ) ;
#line 70
extern GIcon *g_emblemed_icon_get_icon(GEmblemedIcon *emblemed ) ;
#line 72
extern GList *g_emblemed_icon_get_emblems(GEmblemedIcon *emblemed ) ;
#line 74
extern void g_emblemed_icon_add_emblem(GEmblemedIcon *emblemed , GEmblem *emblem ) ;
#line 77
extern void g_emblemed_icon_clear_emblems(GEmblemedIcon *emblemed ) ;
#line 605 "/usr/include/glib-2.0/gio/gfile.h"
extern GType g_file_get_type(void) ;
#line 608
extern GFile *g_file_new_for_path(char const   *path ) ;
#line 610
extern GFile *g_file_new_for_uri(char const   *uri ) ;
#line 612
extern GFile *g_file_new_for_commandline_arg(char const   *arg ) ;
#line 614
extern GFile *g_file_new_for_commandline_arg_and_cwd(gchar *arg , gchar *cwd ) ;
#line 617
extern GFile *g_file_new_tmp(char const   *tmpl , GFileIOStream **iostream , GError **error ) ;
#line 621
extern GFile *g_file_parse_name(char const   *parse_name ) ;
#line 623
extern GFile *g_file_new_build_filename(gchar *first_element  , ...) ;
#line 626
extern GFile *g_file_dup(GFile *file ) ;
#line 628
extern guint g_file_hash(gconstpointer file ) ;
#line 630
extern gboolean g_file_equal(GFile *file1 , GFile *file2 ) ;
#line 633
extern char *g_file_get_basename(GFile *file ) ;
#line 635
extern char *g_file_get_path(GFile *file ) ;
#line 637
extern char const   *g_file_peek_path(GFile *file ) ;
#line 639
extern char *g_file_get_uri(GFile *file ) ;
#line 641
extern char *g_file_get_parse_name(GFile *file ) ;
#line 643
extern GFile *g_file_get_parent(GFile *file ) ;
#line 645
extern gboolean g_file_has_parent(GFile *file , GFile *parent ) ;
#line 648
extern GFile *g_file_get_child(GFile *file , char const   *name ) ;
#line 651
extern GFile *g_file_get_child_for_display_name(GFile *file , char const   *display_name ,
                                                GError **error ) ;
#line 655
extern gboolean g_file_has_prefix(GFile *file , GFile *prefix ) ;
#line 658
extern char *g_file_get_relative_path(GFile *parent , GFile *descendant ) ;
#line 661
extern GFile *g_file_resolve_relative_path(GFile *file , char const   *relative_path ) ;
#line 664
extern gboolean g_file_is_native(GFile *file ) ;
#line 666
extern gboolean g_file_has_uri_scheme(GFile *file , char const   *uri_scheme ) ;
#line 669
extern char *g_file_get_uri_scheme(GFile *file ) ;
#line 671
extern GFileInputStream *g_file_read(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 675
extern void g_file_read_async(GFile *file , int io_priority , GCancellable *cancellable ,
                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 681
extern GFileInputStream *g_file_read_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 685
extern GFileOutputStream *g_file_append_to(GFile *file , GFileCreateFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 690
extern GFileOutputStream *g_file_create(GFile *file , GFileCreateFlags flags , GCancellable *cancellable ,
                                        GError **error ) ;
#line 695
extern GFileOutputStream *g_file_replace(GFile *file , char const   *etag , gboolean make_backup ,
                                         GFileCreateFlags flags , GCancellable *cancellable ,
                                         GError **error ) ;
#line 702
extern void g_file_append_to_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 709
extern GFileOutputStream *g_file_append_to_finish(GFile *file , GAsyncResult *res ,
                                                  GError **error ) ;
#line 713
extern void g_file_create_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                gpointer user_data ) ;
#line 720
extern GFileOutputStream *g_file_create_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 724
extern void g_file_replace_async(GFile *file , char const   *etag , gboolean make_backup ,
                                 GFileCreateFlags flags , int io_priority , GCancellable *cancellable ,
                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 733
extern GFileOutputStream *g_file_replace_finish(GFile *file , GAsyncResult *res ,
                                                GError **error ) ;
#line 737
extern GFileIOStream *g_file_open_readwrite(GFile *file , GCancellable *cancellable ,
                                            GError **error ) ;
#line 741
extern void g_file_open_readwrite_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 747
extern GFileIOStream *g_file_open_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                   GError **error ) ;
#line 751
extern GFileIOStream *g_file_create_readwrite(GFile *file , GFileCreateFlags flags ,
                                              GCancellable *cancellable , GError **error ) ;
#line 756
extern void g_file_create_readwrite_async(GFile *file , GFileCreateFlags flags , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 763
extern GFileIOStream *g_file_create_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                     GError **error ) ;
#line 767
extern GFileIOStream *g_file_replace_readwrite(GFile *file , char const   *etag ,
                                               gboolean make_backup , GFileCreateFlags flags ,
                                               GCancellable *cancellable , GError **error ) ;
#line 774
extern void g_file_replace_readwrite_async(GFile *file , char const   *etag , gboolean make_backup ,
                                           GFileCreateFlags flags , int io_priority ,
                                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                                           gpointer user_data ) ;
#line 783
extern GFileIOStream *g_file_replace_readwrite_finish(GFile *file , GAsyncResult *res ,
                                                      GError **error ) ;
#line 787
extern gboolean g_file_query_exists(GFile *file , GCancellable *cancellable ) ;
#line 790
extern GFileType g_file_query_file_type(GFile *file , GFileQueryInfoFlags flags ,
                                        GCancellable *cancellable ) ;
#line 794
extern GFileInfo *g_file_query_info(GFile *file , char const   *attributes , GFileQueryInfoFlags flags ,
                                    GCancellable *cancellable , GError **error ) ;
#line 800
extern void g_file_query_info_async(GFile *file , char const   *attributes , GFileQueryInfoFlags flags ,
                                    int io_priority , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 808
extern GFileInfo *g_file_query_info_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 812
extern GFileInfo *g_file_query_filesystem_info(GFile *file , char const   *attributes ,
                                               GCancellable *cancellable , GError **error ) ;
#line 817
extern void g_file_query_filesystem_info_async(GFile *file , char const   *attributes ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 824
extern GFileInfo *g_file_query_filesystem_info_finish(GFile *file , GAsyncResult *res ,
                                                      GError **error ) ;
#line 828
extern GMount *g_file_find_enclosing_mount(GFile *file , GCancellable *cancellable ,
                                           GError **error ) ;
#line 832
extern void g_file_find_enclosing_mount_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 838
extern GMount *g_file_find_enclosing_mount_finish(GFile *file , GAsyncResult *res ,
                                                  GError **error ) ;
#line 842
extern GFileEnumerator *g_file_enumerate_children(GFile *file , char const   *attributes ,
                                                  GFileQueryInfoFlags flags , GCancellable *cancellable ,
                                                  GError **error ) ;
#line 848
extern void g_file_enumerate_children_async(GFile *file , char const   *attributes ,
                                            GFileQueryInfoFlags flags , int io_priority ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 856
extern GFileEnumerator *g_file_enumerate_children_finish(GFile *file , GAsyncResult *res ,
                                                         GError **error ) ;
#line 860
extern GFile *g_file_set_display_name(GFile *file , char const   *display_name , GCancellable *cancellable ,
                                      GError **error ) ;
#line 865
extern void g_file_set_display_name_async(GFile *file , char const   *display_name ,
                                          int io_priority , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 872
extern GFile *g_file_set_display_name_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 876
extern gboolean g_file_delete(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 881
extern void g_file_delete_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                GAsyncReadyCallback callback , gpointer user_data ) ;
#line 888
extern gboolean g_file_delete_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 893
extern gboolean g_file_trash(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 898
extern void g_file_trash_async(GFile *file , int io_priority , GCancellable *cancellable ,
                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 905
extern gboolean g_file_trash_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 910
extern gboolean g_file_copy(GFile *source , GFile *destination , GFileCopyFlags flags ,
                            GCancellable *cancellable , GFileProgressCallback progress_callback ,
                            gpointer progress_callback_data , GError **error ) ;
#line 918
extern void g_file_copy_async(GFile *source , GFile *destination , GFileCopyFlags flags ,
                              int io_priority , GCancellable *cancellable , GFileProgressCallback progress_callback ,
                              gpointer progress_callback_data , GAsyncReadyCallback callback ,
                              gpointer user_data ) ;
#line 928
extern gboolean g_file_copy_finish(GFile *file , GAsyncResult *res , GError **error ) ;
#line 932
extern gboolean g_file_move(GFile *source , GFile *destination , GFileCopyFlags flags ,
                            GCancellable *cancellable , GFileProgressCallback progress_callback ,
                            gpointer progress_callback_data , GError **error ) ;
#line 940
extern void g_file_move_async(GFile *source , GFile *destination , GFileCopyFlags flags ,
                              int io_priority , GCancellable *cancellable , GFileProgressCallback progress_callback ,
                              gpointer progress_callback_data , GAsyncReadyCallback callback ,
                              gpointer user_data ) ;
#line 950
extern gboolean g_file_move_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 954
extern gboolean g_file_make_directory(GFile *file , GCancellable *cancellable , GError **error ) ;
#line 958
extern void g_file_make_directory_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 964
extern gboolean g_file_make_directory_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 969
extern gboolean g_file_make_directory_with_parents(GFile *file , GCancellable *cancellable ,
                                                   GError **error ) ;
#line 973
extern gboolean g_file_make_symbolic_link(GFile *file , char const   *symlink_value ,
                                          GCancellable *cancellable , GError **error ) ;
#line 978
extern GFileAttributeInfoList *g_file_query_settable_attributes(GFile *file , GCancellable *cancellable ,
                                                                GError **error ) ;
#line 982
extern GFileAttributeInfoList *g_file_query_writable_namespaces(GFile *file , GCancellable *cancellable ,
                                                                GError **error ) ;
#line 986
extern gboolean g_file_set_attribute(GFile *file , char const   *attribute , GFileAttributeType type ,
                                     gpointer value_p , GFileQueryInfoFlags flags ,
                                     GCancellable *cancellable , GError **error ) ;
#line 994
extern gboolean g_file_set_attributes_from_info(GFile *file , GFileInfo *info , GFileQueryInfoFlags flags ,
                                                GCancellable *cancellable , GError **error ) ;
#line 1000
extern void g_file_set_attributes_async(GFile *file , GFileInfo *info , GFileQueryInfoFlags flags ,
                                        int io_priority , GCancellable *cancellable ,
                                        GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1008
extern gboolean g_file_set_attributes_finish(GFile *file , GAsyncResult *result ,
                                             GFileInfo **info , GError **error ) ;
#line 1013
extern gboolean g_file_set_attribute_string(GFile *file , char const   *attribute ,
                                            char const   *value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1020
extern gboolean g_file_set_attribute_byte_string(GFile *file , char const   *attribute ,
                                                 char const   *value , GFileQueryInfoFlags flags ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 1027
extern gboolean g_file_set_attribute_uint32(GFile *file , char const   *attribute ,
                                            guint32 value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1034
extern gboolean g_file_set_attribute_int32(GFile *file , char const   *attribute ,
                                           gint32 value , GFileQueryInfoFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 1041
extern gboolean g_file_set_attribute_uint64(GFile *file , char const   *attribute ,
                                            guint64 value , GFileQueryInfoFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1048
extern gboolean g_file_set_attribute_int64(GFile *file , char const   *attribute ,
                                           gint64 value , GFileQueryInfoFlags flags ,
                                           GCancellable *cancellable , GError **error ) ;
#line 1055
extern void g_file_mount_enclosing_volume(GFile *location , GMountMountFlags flags ,
                                          GMountOperation *mount_operation , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1062
extern gboolean g_file_mount_enclosing_volume_finish(GFile *location , GAsyncResult *result ,
                                                     GError **error ) ;
#line 1066
extern void g_file_mount_mountable(GFile *file , GMountMountFlags flags , GMountOperation *mount_operation ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 1073
extern GFile *g_file_mount_mountable_finish(GFile *file , GAsyncResult *result , GError **error ) ;
#line 1077
extern void g_file_unmount_mountable(GFile *file , GMountUnmountFlags flags , GCancellable *cancellable ,
                                     GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1084
extern gboolean g_file_unmount_mountable_finish(GFile *file , GAsyncResult *result ,
                                                GError **error ) ;
#line 1088
extern void g_file_unmount_mountable_with_operation(GFile *file , GMountUnmountFlags flags ,
                                                    GMountOperation *mount_operation ,
                                                    GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                    gpointer user_data ) ;
#line 1095
extern gboolean g_file_unmount_mountable_with_operation_finish(GFile *file , GAsyncResult *result ,
                                                               GError **error ) ;
#line 1099
extern void g_file_eject_mountable(GFile *file , GMountUnmountFlags flags , GCancellable *cancellable ,
                                   GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1106
extern gboolean g_file_eject_mountable_finish(GFile *file , GAsyncResult *result ,
                                              GError **error ) ;
#line 1110
extern void g_file_eject_mountable_with_operation(GFile *file , GMountUnmountFlags flags ,
                                                  GMountOperation *mount_operation ,
                                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                  gpointer user_data ) ;
#line 1117
extern gboolean g_file_eject_mountable_with_operation_finish(GFile *file , GAsyncResult *result ,
                                                             GError **error ) ;
#line 1122
extern char *g_file_build_attribute_list_for_copy(GFile *file , GFileCopyFlags flags ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 1128
extern gboolean g_file_copy_attributes(GFile *source , GFile *destination , GFileCopyFlags flags ,
                                       GCancellable *cancellable , GError **error ) ;
#line 1136
extern GFileMonitor *g_file_monitor_directory(GFile *file , GFileMonitorFlags flags ,
                                              GCancellable *cancellable , GError **error ) ;
#line 1141
extern GFileMonitor *g_file_monitor_file(GFile *file , GFileMonitorFlags flags , GCancellable *cancellable ,
                                         GError **error ) ;
#line 1146
extern GFileMonitor *g_file_monitor(GFile *file , GFileMonitorFlags flags , GCancellable *cancellable ,
                                    GError **error ) ;
#line 1152
extern gboolean g_file_measure_disk_usage(GFile *file , GFileMeasureFlags flags ,
                                          GCancellable *cancellable , GFileMeasureProgressCallback progress_callback ,
                                          gpointer progress_data , guint64 *disk_usage ,
                                          guint64 *num_dirs , guint64 *num_files ,
                                          GError **error ) ;
#line 1163
extern void g_file_measure_disk_usage_async(GFile *file , GFileMeasureFlags flags ,
                                            gint io_priority , GCancellable *cancellable ,
                                            GFileMeasureProgressCallback progress_callback ,
                                            gpointer progress_data , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 1173
extern gboolean g_file_measure_disk_usage_finish(GFile *file , GAsyncResult *result ,
                                                 guint64 *disk_usage , guint64 *num_dirs ,
                                                 guint64 *num_files , GError **error ) ;
#line 1181
extern void g_file_start_mountable(GFile *file , GDriveStartFlags flags , GMountOperation *start_operation ,
                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                   gpointer user_data ) ;
#line 1188
extern gboolean g_file_start_mountable_finish(GFile *file , GAsyncResult *result ,
                                              GError **error ) ;
#line 1192
extern void g_file_stop_mountable(GFile *file , GMountUnmountFlags flags , GMountOperation *mount_operation ,
                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 1199
extern gboolean g_file_stop_mountable_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 1204
extern void g_file_poll_mountable(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 1209
extern gboolean g_file_poll_mountable_finish(GFile *file , GAsyncResult *result ,
                                             GError **error ) ;
#line 1216
extern GAppInfo *g_file_query_default_handler(GFile *file , GCancellable *cancellable ,
                                              GError **error ) ;
#line 1220
extern void g_file_query_default_handler_async(GFile *file , int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1226
extern GAppInfo *g_file_query_default_handler_finish(GFile *file , GAsyncResult *result ,
                                                     GError **error ) ;
#line 1231
extern gboolean g_file_load_contents(GFile *file , GCancellable *cancellable , char **contents ,
                                     gsize *length , char **etag_out , GError **error ) ;
#line 1238
extern void g_file_load_contents_async(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                       gpointer user_data ) ;
#line 1243
extern gboolean g_file_load_contents_finish(GFile *file , GAsyncResult *res , char **contents ,
                                            gsize *length , char **etag_out , GError **error ) ;
#line 1250
extern void g_file_load_partial_contents_async(GFile *file , GCancellable *cancellable ,
                                               GFileReadMoreCallback read_more_callback ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1256
extern gboolean g_file_load_partial_contents_finish(GFile *file , GAsyncResult *res ,
                                                    char **contents , gsize *length ,
                                                    char **etag_out , GError **error ) ;
#line 1263
extern gboolean g_file_replace_contents(GFile *file , char const   *contents , gsize length ,
                                        char const   *etag , gboolean make_backup ,
                                        GFileCreateFlags flags , char **new_etag ,
                                        GCancellable *cancellable , GError **error ) ;
#line 1273
extern void g_file_replace_contents_async(GFile *file , char const   *contents , gsize length ,
                                          char const   *etag , gboolean make_backup ,
                                          GFileCreateFlags flags , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 1283
extern void g_file_replace_contents_bytes_async(GFile *file , GBytes *contents , char const   *etag ,
                                                gboolean make_backup , GFileCreateFlags flags ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 1292
extern gboolean g_file_replace_contents_finish(GFile *file , GAsyncResult *res , char **new_etag ,
                                               GError **error ) ;
#line 1298
extern gboolean g_file_supports_thread_contexts(GFile *file ) ;
#line 1301
extern GBytes *g_file_load_bytes(GFile *file , GCancellable *cancellable , gchar **etag_out ,
                                 GError **error ) ;
#line 1306
extern void g_file_load_bytes_async(GFile *file , GCancellable *cancellable , GAsyncReadyCallback callback ,
                                    gpointer user_data ) ;
#line 1311
extern GBytes *g_file_load_bytes_finish(GFile *file , GAsyncResult *result , gchar **etag_out ,
                                        GError **error ) ;
#line 63 "/usr/include/glib-2.0/gio/gfileattribute.h"
extern GType g_file_attribute_info_list_get_type(void) ;
#line 66
extern GFileAttributeInfoList *g_file_attribute_info_list_new(void) ;
#line 68
extern GFileAttributeInfoList *g_file_attribute_info_list_ref(GFileAttributeInfoList *list ) ;
#line 70
extern void g_file_attribute_info_list_unref(GFileAttributeInfoList *list ) ;
#line 72
extern GFileAttributeInfoList *g_file_attribute_info_list_dup(GFileAttributeInfoList *list ) ;
#line 74
extern GFileAttributeInfo *g_file_attribute_info_list_lookup(GFileAttributeInfoList *list ,
                                                             char const   *name ) ;
#line 77
extern void g_file_attribute_info_list_add(GFileAttributeInfoList *list , char const   *name ,
                                           GFileAttributeType type , GFileAttributeInfoFlags flags ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileenumerator.h"
extern GType g_file_enumerator_get_type(void) ;
#line 101
extern GFileInfo *g_file_enumerator_next_file(GFileEnumerator *enumerator , GCancellable *cancellable ,
                                              GError **error ) ;
#line 105
extern gboolean g_file_enumerator_close(GFileEnumerator *enumerator , GCancellable *cancellable ,
                                        GError **error ) ;
#line 109
extern void g_file_enumerator_next_files_async(GFileEnumerator *enumerator , int num_files ,
                                               int io_priority , GCancellable *cancellable ,
                                               GAsyncReadyCallback callback , gpointer user_data ) ;
#line 116
extern GList *g_file_enumerator_next_files_finish(GFileEnumerator *enumerator , GAsyncResult *result ,
                                                  GError **error ) ;
#line 120
extern void g_file_enumerator_close_async(GFileEnumerator *enumerator , int io_priority ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 126
extern gboolean g_file_enumerator_close_finish(GFileEnumerator *enumerator , GAsyncResult *result ,
                                               GError **error ) ;
#line 130
extern gboolean g_file_enumerator_is_closed(GFileEnumerator *enumerator ) ;
#line 132
extern gboolean g_file_enumerator_has_pending(GFileEnumerator *enumerator ) ;
#line 134
extern void g_file_enumerator_set_pending(GFileEnumerator *enumerator , gboolean pending ) ;
#line 137
extern GFile *g_file_enumerator_get_container(GFileEnumerator *enumerator ) ;
#line 139
extern GFile *g_file_enumerator_get_child(GFileEnumerator *enumerator , GFileInfo *info ) ;
#line 143
extern gboolean g_file_enumerator_iterate(GFileEnumerator *direnum , GFileInfo **out_info ,
                                          GFile **out_child , GCancellable *cancellable ,
                                          GError **error ) ;
#line 47 "/usr/include/glib-2.0/gio/gfileicon.h"
extern GType g_file_icon_get_type(void) ;
#line 50
extern GIcon *g_file_icon_new(GFile *file ) ;
#line 53
extern GFile *g_file_icon_get_file(GFileIcon *icon ) ;
#line 1070 "/usr/include/glib-2.0/gio/gfileinfo.h"
extern GType g_file_info_get_type(void) ;
#line 1073
extern GFileInfo *g_file_info_new(void) ;
#line 1075
extern GFileInfo *g_file_info_dup(GFileInfo *other ) ;
#line 1077
extern void g_file_info_copy_into(GFileInfo *src_info , GFileInfo *dest_info ) ;
#line 1080
extern gboolean g_file_info_has_attribute(GFileInfo *info , char const   *attribute ) ;
#line 1083
extern gboolean g_file_info_has_namespace(GFileInfo *info , char const   *name_space ) ;
#line 1086
extern char **g_file_info_list_attributes(GFileInfo *info , char const   *name_space ) ;
#line 1089
extern gboolean g_file_info_get_attribute_data(GFileInfo *info , char const   *attribute ,
                                               GFileAttributeType *type , gpointer *value_pp ,
                                               GFileAttributeStatus *status ) ;
#line 1095
extern GFileAttributeType g_file_info_get_attribute_type(GFileInfo *info , char const   *attribute ) ;
#line 1098
extern void g_file_info_remove_attribute(GFileInfo *info , char const   *attribute ) ;
#line 1101
extern GFileAttributeStatus g_file_info_get_attribute_status(GFileInfo *info , char const   *attribute ) ;
#line 1104
extern gboolean g_file_info_set_attribute_status(GFileInfo *info , char const   *attribute ,
                                                 GFileAttributeStatus status ) ;
#line 1108
extern char *g_file_info_get_attribute_as_string(GFileInfo *info , char const   *attribute ) ;
#line 1111
extern char const   *g_file_info_get_attribute_string(GFileInfo *info , char const   *attribute ) ;
#line 1114
extern char const   *g_file_info_get_attribute_byte_string(GFileInfo *info , char const   *attribute ) ;
#line 1117
extern gboolean g_file_info_get_attribute_boolean(GFileInfo *info , char const   *attribute ) ;
#line 1120
extern guint32 g_file_info_get_attribute_uint32(GFileInfo *info , char const   *attribute ) ;
#line 1123
extern gint32 g_file_info_get_attribute_int32(GFileInfo *info , char const   *attribute ) ;
#line 1126
extern guint64 g_file_info_get_attribute_uint64(GFileInfo *info , char const   *attribute ) ;
#line 1129
extern gint64 g_file_info_get_attribute_int64(GFileInfo *info , char const   *attribute ) ;
#line 1132
extern GObject *g_file_info_get_attribute_object(GFileInfo *info , char const   *attribute ) ;
#line 1135
extern char **g_file_info_get_attribute_stringv(GFileInfo *info , char const   *attribute ) ;
#line 1139
extern void g_file_info_set_attribute(GFileInfo *info , char const   *attribute ,
                                      GFileAttributeType type , gpointer value_p ) ;
#line 1144
extern void g_file_info_set_attribute_string(GFileInfo *info , char const   *attribute ,
                                             char const   *attr_value ) ;
#line 1148
extern void g_file_info_set_attribute_byte_string(GFileInfo *info , char const   *attribute ,
                                                  char const   *attr_value ) ;
#line 1152
extern void g_file_info_set_attribute_boolean(GFileInfo *info , char const   *attribute ,
                                              gboolean attr_value ) ;
#line 1156
extern void g_file_info_set_attribute_uint32(GFileInfo *info , char const   *attribute ,
                                             guint32 attr_value ) ;
#line 1160
extern void g_file_info_set_attribute_int32(GFileInfo *info , char const   *attribute ,
                                            gint32 attr_value ) ;
#line 1164
extern void g_file_info_set_attribute_uint64(GFileInfo *info , char const   *attribute ,
                                             guint64 attr_value ) ;
#line 1168
extern void g_file_info_set_attribute_int64(GFileInfo *info , char const   *attribute ,
                                            gint64 attr_value ) ;
#line 1172
extern void g_file_info_set_attribute_object(GFileInfo *info , char const   *attribute ,
                                             GObject *attr_value ) ;
#line 1176
extern void g_file_info_set_attribute_stringv(GFileInfo *info , char const   *attribute ,
                                              char **attr_value ) ;
#line 1181
extern void g_file_info_clear_status(GFileInfo *info ) ;
#line 1185
extern GDateTime *g_file_info_get_deletion_date(GFileInfo *info ) ;
#line 1187
extern GFileType g_file_info_get_file_type(GFileInfo *info ) ;
#line 1189
extern gboolean g_file_info_get_is_hidden(GFileInfo *info ) ;
#line 1191
extern gboolean g_file_info_get_is_backup(GFileInfo *info ) ;
#line 1193
extern gboolean g_file_info_get_is_symlink(GFileInfo *info ) ;
#line 1195
extern char const   *g_file_info_get_name(GFileInfo *info ) ;
#line 1197
extern char const   *g_file_info_get_display_name(GFileInfo *info ) ;
#line 1199
extern char const   *g_file_info_get_edit_name(GFileInfo *info ) ;
#line 1201
extern GIcon *g_file_info_get_icon(GFileInfo *info ) ;
#line 1203
extern GIcon *g_file_info_get_symbolic_icon(GFileInfo *info ) ;
#line 1205
extern char const   *g_file_info_get_content_type(GFileInfo *info ) ;
#line 1207
extern goffset g_file_info_get_size(GFileInfo *info ) ;
#line 1210
extern void g_file_info_get_modification_time(GFileInfo *info , GTimeVal *result ) ;
#line 1214
extern GDateTime *g_file_info_get_modification_date_time(GFileInfo *info ) ;
#line 1216
extern GDateTime *g_file_info_get_access_date_time(GFileInfo *info ) ;
#line 1218
extern GDateTime *g_file_info_get_creation_date_time(GFileInfo *info ) ;
#line 1220
extern char const   *g_file_info_get_symlink_target(GFileInfo *info ) ;
#line 1222
extern char const   *g_file_info_get_etag(GFileInfo *info ) ;
#line 1224
extern gint32 g_file_info_get_sort_order(GFileInfo *info ) ;
#line 1227
extern void g_file_info_set_attribute_mask(GFileInfo *info , GFileAttributeMatcher *mask ) ;
#line 1230
extern void g_file_info_unset_attribute_mask(GFileInfo *info ) ;
#line 1234
extern void g_file_info_set_file_type(GFileInfo *info , GFileType type ) ;
#line 1237
extern void g_file_info_set_is_hidden(GFileInfo *info , gboolean is_hidden ) ;
#line 1240
extern void g_file_info_set_is_symlink(GFileInfo *info , gboolean is_symlink ) ;
#line 1243
extern void g_file_info_set_name(GFileInfo *info , char const   *name ) ;
#line 1246
extern void g_file_info_set_display_name(GFileInfo *info , char const   *display_name ) ;
#line 1249
extern void g_file_info_set_edit_name(GFileInfo *info , char const   *edit_name ) ;
#line 1252
extern void g_file_info_set_icon(GFileInfo *info , GIcon *icon ) ;
#line 1255
extern void g_file_info_set_symbolic_icon(GFileInfo *info , GIcon *icon ) ;
#line 1258
extern void g_file_info_set_content_type(GFileInfo *info , char const   *content_type ) ;
#line 1261
extern void g_file_info_set_size(GFileInfo *info , goffset size ) ;
#line 1265
extern void g_file_info_set_modification_time(GFileInfo *info , GTimeVal *mtime ) ;
#line 1269
extern void g_file_info_set_modification_date_time(GFileInfo *info , GDateTime *mtime ) ;
#line 1272
extern void g_file_info_set_access_date_time(GFileInfo *info , GDateTime *atime ) ;
#line 1275
extern void g_file_info_set_creation_date_time(GFileInfo *info , GDateTime *creation_time ) ;
#line 1278
extern void g_file_info_set_symlink_target(GFileInfo *info , char const   *symlink_target ) ;
#line 1281
extern void g_file_info_set_sort_order(GFileInfo *info , gint32 sort_order ) ;
#line 1286
extern GType g_file_attribute_matcher_get_type(void) ;
#line 1289
extern GFileAttributeMatcher *g_file_attribute_matcher_new(char const   *attributes ) ;
#line 1291
extern GFileAttributeMatcher *g_file_attribute_matcher_ref(GFileAttributeMatcher *matcher ) ;
#line 1293
extern void g_file_attribute_matcher_unref(GFileAttributeMatcher *matcher ) ;
#line 1295
extern GFileAttributeMatcher *g_file_attribute_matcher_subtract(GFileAttributeMatcher *matcher ,
                                                                GFileAttributeMatcher *subtract ) ;
#line 1298
extern gboolean g_file_attribute_matcher_matches(GFileAttributeMatcher *matcher ,
                                                 char const   *attribute ) ;
#line 1301
extern gboolean g_file_attribute_matcher_matches_only(GFileAttributeMatcher *matcher ,
                                                      char const   *attribute ) ;
#line 1304
extern gboolean g_file_attribute_matcher_enumerate_namespace(GFileAttributeMatcher *matcher ,
                                                             char const   *ns ) ;
#line 1307
extern char const   *g_file_attribute_matcher_enumerate_next(GFileAttributeMatcher *matcher ) ;
#line 1309
extern char *g_file_attribute_matcher_to_string(GFileAttributeMatcher *matcher ) ;
#line 93 "/usr/include/glib-2.0/gio/gfileinputstream.h"
extern GType g_file_input_stream_get_type(void) ;
#line 96
extern GFileInfo *g_file_input_stream_query_info(GFileInputStream *stream , char const   *attributes ,
                                                 GCancellable *cancellable , GError **error ) ;
#line 101
extern void g_file_input_stream_query_info_async(GFileInputStream *stream , char const   *attributes ,
                                                 int io_priority , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 108
extern GFileInfo *g_file_input_stream_query_info_finish(GFileInputStream *stream ,
                                                        GAsyncResult *result , GError **error ) ;
#line 42 "/usr/include/glib-2.0/gio/gioerror.h"
extern GQuark g_io_error_quark(void) ;
#line 44
extern GIOErrorEnum g_io_error_from_errno(gint err_no ) ;
#line 87 "/usr/include/glib-2.0/gio/giostream.h"
extern GType g_io_stream_get_type(void) ;
#line 90
extern GInputStream *g_io_stream_get_input_stream(GIOStream *stream ) ;
#line 92
extern GOutputStream *g_io_stream_get_output_stream(GIOStream *stream ) ;
#line 95
extern void g_io_stream_splice_async(GIOStream *stream1 , GIOStream *stream2 , GIOStreamSpliceFlags flags ,
                                     int io_priority , GCancellable *cancellable ,
                                     GAsyncReadyCallback callback , gpointer user_data ) ;
#line 104
extern gboolean g_io_stream_splice_finish(GAsyncResult *result , GError **error ) ;
#line 108
extern gboolean g_io_stream_close(GIOStream *stream , GCancellable *cancellable ,
                                  GError **error ) ;
#line 113
extern void g_io_stream_close_async(GIOStream *stream , int io_priority , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 119
extern gboolean g_io_stream_close_finish(GIOStream *stream , GAsyncResult *result ,
                                         GError **error ) ;
#line 124
extern gboolean g_io_stream_is_closed(GIOStream *stream ) ;
#line 126
extern gboolean g_io_stream_has_pending(GIOStream *stream ) ;
#line 128
extern gboolean g_io_stream_set_pending(GIOStream *stream , GError **error ) ;
#line 131
extern void g_io_stream_clear_pending(GIOStream *stream ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileiostream.h"
extern GType g_file_io_stream_get_type(void) ;
#line 101
extern GFileInfo *g_file_io_stream_query_info(GFileIOStream *stream , char const   *attributes ,
                                              GCancellable *cancellable , GError **error ) ;
#line 106
extern void g_file_io_stream_query_info_async(GFileIOStream *stream , char const   *attributes ,
                                              int io_priority , GCancellable *cancellable ,
                                              GAsyncReadyCallback callback , gpointer user_data ) ;
#line 113
extern GFileInfo *g_file_io_stream_query_info_finish(GFileIOStream *stream , GAsyncResult *result ,
                                                     GError **error ) ;
#line 117
extern char *g_file_io_stream_get_etag(GFileIOStream *stream ) ;
#line 78 "/usr/include/glib-2.0/gio/gfilemonitor.h"
extern GType g_file_monitor_get_type(void) ;
#line 81
extern gboolean g_file_monitor_cancel(GFileMonitor *monitor ) ;
#line 83
extern gboolean g_file_monitor_is_cancelled(GFileMonitor *monitor ) ;
#line 85
extern void g_file_monitor_set_rate_limit(GFileMonitor *monitor , gint limit_msecs ) ;
#line 91
extern void g_file_monitor_emit_event(GFileMonitor *monitor , GFile *child , GFile *other_file ,
                                      GFileMonitorEvent event_type ) ;
#line 62 "/usr/include/glib-2.0/gio/gfilenamecompleter.h"
extern GType g_filename_completer_get_type(void) ;
#line 65
extern GFilenameCompleter *g_filename_completer_new(void) ;
#line 68
extern char *g_filename_completer_get_completion_suffix(GFilenameCompleter *completer ,
                                                        char const   *initial_text ) ;
#line 71
extern char **g_filename_completer_get_completions(GFilenameCompleter *completer ,
                                                   char const   *initial_text ) ;
#line 74
extern void g_filename_completer_set_dirs_only(GFilenameCompleter *completer , gboolean dirs_only ) ;
#line 98 "/usr/include/glib-2.0/gio/gfileoutputstream.h"
extern GType g_file_output_stream_get_type(void) ;
#line 102
extern GFileInfo *g_file_output_stream_query_info(GFileOutputStream *stream , char const   *attributes ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 107
extern void g_file_output_stream_query_info_async(GFileOutputStream *stream , char const   *attributes ,
                                                  int io_priority , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 114
extern GFileInfo *g_file_output_stream_query_info_finish(GFileOutputStream *stream ,
                                                         GAsyncResult *result , GError **error ) ;
#line 118
extern char *g_file_output_stream_get_etag(GFileOutputStream *stream ) ;
#line 60 "/usr/include/glib-2.0/gio/ginetaddress.h"
extern GType g_inet_address_get_type(void) ;
#line 63
extern GInetAddress *g_inet_address_new_from_string(gchar *string ) ;
#line 66
extern GInetAddress *g_inet_address_new_from_bytes(guint8 *bytes , GSocketFamily family ) ;
#line 70
extern GInetAddress *g_inet_address_new_loopback(GSocketFamily family ) ;
#line 73
extern GInetAddress *g_inet_address_new_any(GSocketFamily family ) ;
#line 76
extern gboolean g_inet_address_equal(GInetAddress *address , GInetAddress *other_address ) ;
#line 80
extern gchar *g_inet_address_to_string(GInetAddress *address ) ;
#line 83
extern guint8 *g_inet_address_to_bytes(GInetAddress *address ) ;
#line 86
extern gsize g_inet_address_get_native_size(GInetAddress *address ) ;
#line 89
extern GSocketFamily g_inet_address_get_family(GInetAddress *address ) ;
#line 92
extern gboolean g_inet_address_get_is_any(GInetAddress *address ) ;
#line 95
extern gboolean g_inet_address_get_is_loopback(GInetAddress *address ) ;
#line 98
extern gboolean g_inet_address_get_is_link_local(GInetAddress *address ) ;
#line 101
extern gboolean g_inet_address_get_is_site_local(GInetAddress *address ) ;
#line 104
extern gboolean g_inet_address_get_is_multicast(GInetAddress *address ) ;
#line 107
extern gboolean g_inet_address_get_is_mc_global(GInetAddress *address ) ;
#line 110
extern gboolean g_inet_address_get_is_mc_link_local(GInetAddress *address ) ;
#line 113
extern gboolean g_inet_address_get_is_mc_node_local(GInetAddress *address ) ;
#line 116
extern gboolean g_inet_address_get_is_mc_org_local(GInetAddress *address ) ;
#line 119
extern gboolean g_inet_address_get_is_mc_site_local(GInetAddress *address ) ;
#line 55 "/usr/include/glib-2.0/gio/ginetaddressmask.h"
extern GType g_inet_address_mask_get_type(void) ;
#line 58
extern GInetAddressMask *g_inet_address_mask_new(GInetAddress *addr , guint length ,
                                                 GError **error ) ;
#line 63
extern GInetAddressMask *g_inet_address_mask_new_from_string(gchar *mask_string ,
                                                             GError **error ) ;
#line 66
extern gchar *g_inet_address_mask_to_string(GInetAddressMask *mask ) ;
#line 69
extern GSocketFamily g_inet_address_mask_get_family(GInetAddressMask *mask ) ;
#line 71
extern GInetAddress *g_inet_address_mask_get_address(GInetAddressMask *mask ) ;
#line 73
extern guint g_inet_address_mask_get_length(GInetAddressMask *mask ) ;
#line 76
extern gboolean g_inet_address_mask_matches(GInetAddressMask *mask , GInetAddress *address ) ;
#line 79
extern gboolean g_inet_address_mask_equal(GInetAddressMask *mask , GInetAddressMask *mask2 ) ;
#line 62 "/usr/include/glib-2.0/gio/gsocketaddress.h"
extern GType g_socket_address_get_type(void) ;
#line 65
extern GSocketFamily g_socket_address_get_family(GSocketAddress *address ) ;
#line 68
extern GSocketAddress *g_socket_address_new_from_native(gpointer native , gsize len ) ;
#line 72
extern gboolean g_socket_address_to_native(GSocketAddress *address , gpointer dest ,
                                           gsize destlen , GError **error ) ;
#line 78
extern gssize g_socket_address_get_native_size(GSocketAddress *address ) ;
#line 57 "/usr/include/glib-2.0/gio/ginetsocketaddress.h"
extern GType g_inet_socket_address_get_type(void) ;
#line 60
extern GSocketAddress *g_inet_socket_address_new(GInetAddress *address , guint16 port ) ;
#line 63
extern GSocketAddress *g_inet_socket_address_new_from_string(char const   *address ,
                                                             guint port ) ;
#line 67
extern GInetAddress *g_inet_socket_address_get_address(GInetSocketAddress *address ) ;
#line 69
extern guint16 g_inet_socket_address_get_port(GInetSocketAddress *address ) ;
#line 72
extern guint32 g_inet_socket_address_get_flowinfo(GInetSocketAddress *address ) ;
#line 74
extern guint32 g_inet_socket_address_get_scope_id(GInetSocketAddress *address ) ;
#line 12 "/usr/include/glib-2.0/gio/gioenumtypes.h"
extern GType g_app_info_create_flags_get_type(void) ;
#line 14
extern GType g_converter_flags_get_type(void) ;
#line 16
extern GType g_converter_result_get_type(void) ;
#line 18
extern GType g_data_stream_byte_order_get_type(void) ;
#line 20
extern GType g_data_stream_newline_type_get_type(void) ;
#line 22
extern GType g_file_attribute_type_get_type(void) ;
#line 24
extern GType g_file_attribute_info_flags_get_type(void) ;
#line 26
extern GType g_file_attribute_status_get_type(void) ;
#line 28
extern GType g_file_query_info_flags_get_type(void) ;
#line 30
extern GType g_file_create_flags_get_type(void) ;
#line 32
extern GType g_file_measure_flags_get_type(void) ;
#line 34
extern GType g_mount_mount_flags_get_type(void) ;
#line 36
extern GType g_mount_unmount_flags_get_type(void) ;
#line 38
extern GType g_drive_start_flags_get_type(void) ;
#line 40
extern GType g_drive_start_stop_type_get_type(void) ;
#line 42
extern GType g_file_copy_flags_get_type(void) ;
#line 44
extern GType g_file_monitor_flags_get_type(void) ;
#line 46
extern GType g_file_type_get_type(void) ;
#line 48
extern GType g_filesystem_preview_type_get_type(void) ;
#line 50
extern GType g_file_monitor_event_get_type(void) ;
#line 52
extern GType g_io_error_enum_get_type(void) ;
#line 54
extern GType g_ask_password_flags_get_type(void) ;
#line 56
extern GType g_password_save_get_type(void) ;
#line 58
extern GType g_mount_operation_result_get_type(void) ;
#line 60
extern GType g_output_stream_splice_flags_get_type(void) ;
#line 62
extern GType g_io_stream_splice_flags_get_type(void) ;
#line 64
extern GType g_emblem_origin_get_type(void) ;
#line 66
extern GType g_resolver_error_get_type(void) ;
#line 68
extern GType g_resolver_record_type_get_type(void) ;
#line 70
extern GType g_resource_error_get_type(void) ;
#line 72
extern GType g_resource_flags_get_type(void) ;
#line 74
extern GType g_resource_lookup_flags_get_type(void) ;
#line 76
extern GType g_socket_family_get_type(void) ;
#line 78
extern GType g_socket_type_get_type(void) ;
#line 80
extern GType g_socket_msg_flags_get_type(void) ;
#line 82
extern GType g_socket_protocol_get_type(void) ;
#line 84
extern GType g_zlib_compressor_format_get_type(void) ;
#line 86
extern GType g_unix_socket_address_type_get_type(void) ;
#line 88
extern GType g_bus_type_get_type(void) ;
#line 90
extern GType g_bus_name_owner_flags_get_type(void) ;
#line 92
extern GType g_bus_name_watcher_flags_get_type(void) ;
#line 94
extern GType g_dbus_proxy_flags_get_type(void) ;
#line 96
extern GType g_dbus_error_get_type(void) ;
#line 98
extern GType g_dbus_connection_flags_get_type(void) ;
#line 100
extern GType g_dbus_capability_flags_get_type(void) ;
#line 102
extern GType g_dbus_call_flags_get_type(void) ;
#line 104
extern GType g_dbus_message_type_get_type(void) ;
#line 106
extern GType g_dbus_message_flags_get_type(void) ;
#line 108
extern GType g_dbus_message_header_field_get_type(void) ;
#line 110
extern GType g_dbus_property_info_flags_get_type(void) ;
#line 112
extern GType g_dbus_subtree_flags_get_type(void) ;
#line 114
extern GType g_dbus_server_flags_get_type(void) ;
#line 116
extern GType g_dbus_signal_flags_get_type(void) ;
#line 118
extern GType g_dbus_send_message_flags_get_type(void) ;
#line 120
extern GType g_credentials_type_get_type(void) ;
#line 122
extern GType g_dbus_message_byte_order_get_type(void) ;
#line 124
extern GType g_application_flags_get_type(void) ;
#line 126
extern GType g_tls_error_get_type(void) ;
#line 128
extern GType g_tls_certificate_flags_get_type(void) ;
#line 130
extern GType g_tls_authentication_mode_get_type(void) ;
#line 132
extern GType g_tls_channel_binding_type_get_type(void) ;
#line 134
extern GType g_tls_channel_binding_error_get_type(void) ;
#line 136
extern GType g_tls_rehandshake_mode_get_type(void) ;
#line 138
extern GType g_tls_password_flags_get_type(void) ;
#line 140
extern GType g_tls_interaction_result_get_type(void) ;
#line 142
extern GType g_dbus_interface_skeleton_flags_get_type(void) ;
#line 144
extern GType g_dbus_object_manager_client_flags_get_type(void) ;
#line 146
extern GType g_tls_database_verify_flags_get_type(void) ;
#line 148
extern GType g_tls_database_lookup_flags_get_type(void) ;
#line 150
extern GType g_tls_certificate_request_flags_get_type(void) ;
#line 152
extern GType g_tls_protocol_version_get_type(void) ;
#line 154
extern GType g_io_module_scope_flags_get_type(void) ;
#line 156
extern GType g_socket_client_event_get_type(void) ;
#line 158
extern GType g_socket_listener_event_get_type(void) ;
#line 160
extern GType g_test_dbus_flags_get_type(void) ;
#line 162
extern GType g_subprocess_flags_get_type(void) ;
#line 164
extern GType g_notification_priority_get_type(void) ;
#line 166
extern GType g_network_connectivity_get_type(void) ;
#line 168
extern GType g_pollable_return_get_type(void) ;
#line 170
extern GType g_memory_monitor_warning_level_get_type(void) ;
#line 174
extern GType g_resolver_name_lookup_flags_get_type(void) ;
#line 178
extern GType g_settings_bind_flags_get_type(void) ;
#line 71 "/usr/include/glib-2.0/gmodule.h"
extern GQuark g_module_error_quark(void) ;
#line 91
extern gboolean g_module_supported(void) ;
#line 95
extern GModule *g_module_open(gchar *file_name , GModuleFlags flags ) ;
#line 99
extern GModule *g_module_open_full(gchar *file_name , GModuleFlags flags , GError **error ) ;
#line 105
extern gboolean g_module_close(GModule *module ) ;
#line 109
extern void g_module_make_resident(GModule *module ) ;
#line 113
extern gchar *g_module_error(void) ;
#line 117
extern gboolean g_module_symbol(GModule *module , gchar *symbol_name , gpointer *symbol ) ;
#line 123
extern gchar *g_module_name(GModule *module ) ;
#line 137
extern gchar *g_module_build_path(gchar *directory , gchar *module_name ) ;
#line 36 "/usr/include/glib-2.0/gio/giomodule.h"
extern GIOModuleScope *g_io_module_scope_new(GIOModuleScopeFlags flags ) ;
#line 38
extern void g_io_module_scope_free(GIOModuleScope *scope ) ;
#line 40
extern void g_io_module_scope_block(GIOModuleScope *scope , gchar *__xpg_basename ) ;
#line 58
extern GType g_io_module_get_type(void) ;
#line 60
extern GIOModule *g_io_module_new(gchar *filename ) ;
#line 63
extern void g_io_modules_scan_all_in_directory(char const   *dirname ) ;
#line 65
extern GList *g_io_modules_load_all_in_directory(gchar *dirname ) ;
#line 68
extern void g_io_modules_scan_all_in_directory_with_scope(gchar *dirname , GIOModuleScope *scope ) ;
#line 71
extern GList *g_io_modules_load_all_in_directory_with_scope(gchar *dirname , GIOModuleScope *scope ) ;
#line 75
extern GIOExtensionPoint *g_io_extension_point_register(char const   *name ) ;
#line 77
extern GIOExtensionPoint *g_io_extension_point_lookup(char const   *name ) ;
#line 79
extern void g_io_extension_point_set_required_type(GIOExtensionPoint *extension_point ,
                                                   GType type ) ;
#line 82
extern GType g_io_extension_point_get_required_type(GIOExtensionPoint *extension_point ) ;
#line 84
extern GList *g_io_extension_point_get_extensions(GIOExtensionPoint *extension_point ) ;
#line 86
extern GIOExtension *g_io_extension_point_get_extension_by_name(GIOExtensionPoint *extension_point ,
                                                                char const   *name ) ;
#line 89
extern GIOExtension *g_io_extension_point_implement(char const   *extension_point_name ,
                                                    GType type , char const   *extension_name ,
                                                    gint priority ) ;
#line 95
extern GType g_io_extension_get_type(GIOExtension *extension ) ;
#line 97
extern char const   *g_io_extension_get_name(GIOExtension *extension ) ;
#line 99
extern gint g_io_extension_get_priority(GIOExtension *extension ) ;
#line 101
extern GTypeClass *g_io_extension_ref_class(GIOExtension *extension ) ;
#line 125
extern void g_io_module_load(GIOModule *module ) ;
#line 145
extern void g_io_module_unload(GIOModule *module ) ;
#line 189
extern char **g_io_module_query(void) ;
#line 34 "/usr/include/glib-2.0/gio/gioscheduler.h"
extern void g_io_scheduler_push_job(GIOSchedulerJobFunc job_func , gpointer user_data ,
                                    GDestroyNotify notify , gint io_priority , GCancellable *cancellable ) ;
#line 40
extern void g_io_scheduler_cancel_all_jobs(void) ;
#line 42
extern gboolean g_io_scheduler_job_send_to_mainloop(GIOSchedulerJob *job , GSourceFunc func ,
                                                    gpointer user_data , GDestroyNotify notify ) ;
#line 47
extern void g_io_scheduler_job_send_to_mainloop_async(GIOSchedulerJob *job , GSourceFunc func ,
                                                      gpointer user_data , GDestroyNotify notify ) ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
extern GType g_list_model_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static void glib_autoptr_clear_GListModel(GListModel *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static void glib_autoptr_cleanup_GListModel(GListModel **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListModel(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static GListModel *G_LIST_MODEL(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_model_get_type();
#line 36
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 36
  return ((GListModel *)((void *)__cil_tmp3));
}
}
#line 36 "/usr/include/glib-2.0/gio/glistmodel.h"
__inline static GListModelInterface *G_LIST_MODEL_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_model_get_type();
#line 36
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 36
  return ((GListModelInterface *)__cil_tmp3);
}
}
#line 51
extern GType g_list_model_get_item_type(GListModel *list ) ;
#line 54
extern guint g_list_model_get_n_items(GListModel *list ) ;
#line 57
extern gpointer g_list_model_get_item(GListModel *list , guint position ) ;
#line 61
extern GObject *g_list_model_get_object(GListModel *list , guint position ) ;
#line 65
extern void g_list_model_items_changed(GListModel *list , guint position , guint removed ,
                                       guint added ) ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
extern GType g_list_store_get_type(void) ;
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_clear_GListStore(GListStore *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_cleanup_GListStore(GListStore **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListStore(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_clear_GListStoreClass(GListStoreClass *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    g_type_class_unref((GListStoreClass *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static void glib_autoptr_cleanup_GListStoreClass(GListStoreClass **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GListStoreClass(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gliststore.h"
__inline static GListStore *G_LIST_STORE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 36
  __cil_tmp2 = g_list_store_get_type();
#line 36
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 36
  return ((GListStore *)((void *)__cil_tmp3));
}
}
#line 39
extern GListStore *g_list_store_new(GType item_type ) ;
#line 42
extern void g_list_store_insert(GListStore *store , guint position , gpointer item ) ;
#line 47
extern guint g_list_store_insert_sorted(GListStore *store , gpointer item , GCompareDataFunc compare_func ,
                                        gpointer user_data ) ;
#line 53
extern void g_list_store_sort(GListStore *store , GCompareDataFunc compare_func ,
                              gpointer user_data ) ;
#line 58
extern void g_list_store_append(GListStore *store , gpointer item ) ;
#line 62
extern void g_list_store_remove(GListStore *store , guint position ) ;
#line 66
extern void g_list_store_remove_all(GListStore *store ) ;
#line 69
extern void g_list_store_splice(GListStore *store , guint position , guint n_removals ,
                                gpointer *additions , guint n_additions ) ;
#line 76
extern gboolean g_list_store_find(GListStore *store , gpointer item , guint *position ) ;
#line 81
extern gboolean g_list_store_find_with_equal_func(GListStore *store , gpointer item ,
                                                  GEqualFunc equal_func , guint *position ) ;
#line 77 "/usr/include/glib-2.0/gio/gloadableicon.h"
extern GType g_loadable_icon_get_type(void) ;
#line 80
extern GInputStream *g_loadable_icon_load(GLoadableIcon *icon , int size , char **type ,
                                          GCancellable *cancellable , GError **error ) ;
#line 86
extern void g_loadable_icon_load_async(GLoadableIcon *icon , int size , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 92
extern GInputStream *g_loadable_icon_load_finish(GLoadableIcon *icon , GAsyncResult *res ,
                                                 char **type , GError **error ) ;
#line 69 "/usr/include/glib-2.0/gio/gmemoryinputstream.h"
extern GType g_memory_input_stream_get_type(void) ;
#line 71
extern GInputStream *g_memory_input_stream_new(void) ;
#line 73
extern GInputStream *g_memory_input_stream_new_from_data(void const   *data , gssize len ,
                                                         GDestroyNotify destroy ) ;
#line 77
extern GInputStream *g_memory_input_stream_new_from_bytes(GBytes *bytes ) ;
#line 80
extern void g_memory_input_stream_add_data(GMemoryInputStream *stream , void const   *data ,
                                           gssize len , GDestroyNotify destroy ) ;
#line 85
extern void g_memory_input_stream_add_bytes(GMemoryInputStream *stream , GBytes *bytes ) ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
extern GType g_memory_monitor_get_type(void) ;
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static void glib_autoptr_clear_GMemoryMonitor(GMemoryMonitor *_ptr ) 
{ 


  {
#line 42
  if (_ptr) {
    {
#line 42
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static void glib_autoptr_cleanup_GMemoryMonitor(GMemoryMonitor **_ptr ) 
{ 


  {
  {
#line 42
  glib_autoptr_clear_GMemoryMonitor(*_ptr);
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static GMemoryMonitor *g_memory_monitor(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = g_memory_monitor_get_type();
#line 42
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 42
  return ((GMemoryMonitor *)((void *)__cil_tmp3));
}
}
#line 42 "/usr/include/glib-2.0/gio/gmemorymonitor.h"
__inline static GMemoryMonitorInterface *g_memory_monitor_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 42
  __cil_tmp2 = g_memory_monitor_get_type();
#line 42
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 42
  return ((GMemoryMonitorInterface *)__cil_tmp3);
}
}
#line 58
extern GMemoryMonitor *g_memory_monitor_dup_default(void) ;
#line 84 "/usr/include/glib-2.0/gio/gmemoryoutputstream.h"
extern GType g_memory_output_stream_get_type(void) ;
#line 87
extern GOutputStream *g_memory_output_stream_new(gpointer data , gsize size , GReallocFunc realloc_function ,
                                                 GDestroyNotify destroy_function ) ;
#line 92
extern GOutputStream *g_memory_output_stream_new_resizable(void) ;
#line 94
extern gpointer g_memory_output_stream_get_data(GMemoryOutputStream *ostream ) ;
#line 96
extern gsize g_memory_output_stream_get_size(GMemoryOutputStream *ostream ) ;
#line 98
extern gsize g_memory_output_stream_get_data_size(GMemoryOutputStream *ostream ) ;
#line 100
extern gpointer g_memory_output_stream_steal_data(GMemoryOutputStream *ostream ) ;
#line 103
extern GBytes *g_memory_output_stream_steal_as_bytes(GMemoryOutputStream *ostream ) ;
#line 184 "/usr/include/glib-2.0/gio/gmenumodel.h"
extern GType g_menu_model_get_type(void) ;
#line 187
extern gboolean g_menu_model_is_mutable(GMenuModel *model ) ;
#line 189
extern gint g_menu_model_get_n_items(GMenuModel *model ) ;
#line 192
extern GMenuAttributeIter *g_menu_model_iterate_item_attributes(GMenuModel *model ,
                                                                gint item_index ) ;
#line 195
extern GVariant *g_menu_model_get_item_attribute_value(GMenuModel *model , gint item_index ,
                                                       gchar *attribute , GVariantType *expected_type ) ;
#line 200
extern gboolean g_menu_model_get_item_attribute(GMenuModel *model , gint item_index ,
                                                gchar *attribute , gchar *format_string 
                                                , ...) ;
#line 206
extern GMenuLinkIter *g_menu_model_iterate_item_links(GMenuModel *model , gint item_index ) ;
#line 209
extern GMenuModel *g_menu_model_get_item_link(GMenuModel *model , gint item_index ,
                                              gchar *link ) ;
#line 214
extern void g_menu_model_items_changed(GMenuModel *model , gint position , gint removed ,
                                       gint added ) ;
#line 248
extern GType g_menu_attribute_iter_get_type(void) ;
#line 251
extern gboolean g_menu_attribute_iter_get_next(GMenuAttributeIter *iter , gchar **out_name ,
                                               GVariant **value ) ;
#line 255
extern gboolean g_menu_attribute_iter_next(GMenuAttributeIter *iter ) ;
#line 257
extern gchar *g_menu_attribute_iter_get_name(GMenuAttributeIter *iter ) ;
#line 259
extern GVariant *g_menu_attribute_iter_get_value(GMenuAttributeIter *iter ) ;
#line 290
extern GType g_menu_link_iter_get_type(void) ;
#line 293
extern gboolean g_menu_link_iter_get_next(GMenuLinkIter *iter , gchar **out_link ,
                                          GMenuModel **value ) ;
#line 297
extern gboolean g_menu_link_iter_next(GMenuLinkIter *iter ) ;
#line 299
extern gchar *g_menu_link_iter_get_name(GMenuLinkIter *iter ) ;
#line 301
extern GMenuModel *g_menu_link_iter_get_value(GMenuLinkIter *iter ) ;
#line 43 "/usr/include/glib-2.0/gio/gmenu.h"
extern GType g_menu_get_type(void) ;
#line 45
extern GMenu *g_menu_new(void) ;
#line 48
extern void g_menu_freeze(GMenu *menu ) ;
#line 51
extern void g_menu_insert_item(GMenu *menu , gint position , GMenuItem *item ) ;
#line 55
extern void g_menu_prepend_item(GMenu *menu , GMenuItem *item ) ;
#line 58
extern void g_menu_append_item(GMenu *menu , GMenuItem *item ) ;
#line 61
extern void g_menu_remove(GMenu *menu , gint position ) ;
#line 65
extern void g_menu_remove_all(GMenu *menu ) ;
#line 68
extern void g_menu_insert(GMenu *menu , gint position , gchar *label , gchar *detailed_action ) ;
#line 73
extern void g_menu_prepend(GMenu *menu , gchar *label , gchar *detailed_action ) ;
#line 77
extern void g_menu_append(GMenu *menu , gchar *label , gchar *detailed_action ) ;
#line 82
extern void g_menu_insert_section(GMenu *menu , gint position , gchar *label , GMenuModel *section ) ;
#line 87
extern void g_menu_prepend_section(GMenu *menu , gchar *label , GMenuModel *section ) ;
#line 91
extern void g_menu_append_section(GMenu *menu , gchar *label , GMenuModel *section ) ;
#line 96
extern void g_menu_insert_submenu(GMenu *menu , gint position , gchar *label , GMenuModel *submenu ) ;
#line 101
extern void g_menu_prepend_submenu(GMenu *menu , gchar *label , GMenuModel *submenu ) ;
#line 105
extern void g_menu_append_submenu(GMenu *menu , gchar *label , GMenuModel *submenu ) ;
#line 111
extern GType g_menu_item_get_type(void) ;
#line 113
extern GMenuItem *g_menu_item_new(gchar *label , gchar *detailed_action ) ;
#line 117
extern GMenuItem *g_menu_item_new_from_model(GMenuModel *model , gint item_index ) ;
#line 121
extern GMenuItem *g_menu_item_new_submenu(gchar *label , GMenuModel *submenu ) ;
#line 125
extern GMenuItem *g_menu_item_new_section(gchar *label , GMenuModel *section ) ;
#line 129
extern GVariant *g_menu_item_get_attribute_value(GMenuItem *menu_item , gchar *attribute ,
                                                 GVariantType *expected_type ) ;
#line 133
extern gboolean g_menu_item_get_attribute(GMenuItem *menu_item , gchar *attribute ,
                                          gchar *format_string  , ...) ;
#line 138
extern GMenuModel *g_menu_item_get_link(GMenuItem *menu_item , gchar *link ) ;
#line 142
extern void g_menu_item_set_attribute_value(GMenuItem *menu_item , gchar *attribute ,
                                            GVariant *value ) ;
#line 146
extern void g_menu_item_set_attribute(GMenuItem *menu_item , gchar *attribute , gchar *format_string 
                                      , ...) ;
#line 151
extern void g_menu_item_set_link(GMenuItem *menu_item , gchar *link , GMenuModel *model ) ;
#line 155
extern void g_menu_item_set_label(GMenuItem *menu_item , gchar *label ) ;
#line 158
extern void g_menu_item_set_submenu(GMenuItem *menu_item , GMenuModel *submenu ) ;
#line 161
extern void g_menu_item_set_section(GMenuItem *menu_item , GMenuModel *section ) ;
#line 164
extern void g_menu_item_set_action_and_target_value(GMenuItem *menu_item , gchar *action ,
                                                    GVariant *target_value ) ;
#line 168
extern void g_menu_item_set_action_and_target(GMenuItem *menu_item , gchar *action ,
                                              gchar *format_string  , ...) ;
#line 173
extern void g_menu_item_set_detailed_action(GMenuItem *menu_item , gchar *detailed_action ) ;
#line 177
extern void g_menu_item_set_icon(GMenuItem *menu_item , GIcon *icon ) ;
#line 29 "/usr/include/glib-2.0/gio/gmenuexporter.h"
extern guint g_dbus_connection_export_menu_model(GDBusConnection *connection , gchar *object_path ,
                                                 GMenuModel *menu , GError **error ) ;
#line 35
extern void g_dbus_connection_unexport_menu_model(GDBusConnection *connection , guint export_id ) ;
#line 165 "/usr/include/glib-2.0/gio/gmount.h"
extern GType g_mount_get_type(void) ;
#line 168
extern GFile *g_mount_get_root(GMount *mount ) ;
#line 170
extern GFile *g_mount_get_default_location(GMount *mount ) ;
#line 172
extern char *g_mount_get_name(GMount *mount ) ;
#line 174
extern GIcon *g_mount_get_icon(GMount *mount ) ;
#line 176
extern GIcon *g_mount_get_symbolic_icon(GMount *mount ) ;
#line 178
extern char *g_mount_get_uuid(GMount *mount ) ;
#line 180
extern GVolume *g_mount_get_volume(GMount *mount ) ;
#line 182
extern GDrive *g_mount_get_drive(GMount *mount ) ;
#line 184
extern gboolean g_mount_can_unmount(GMount *mount ) ;
#line 186
extern gboolean g_mount_can_eject(GMount *mount ) ;
#line 189
extern void g_mount_unmount(GMount *mount , GMountUnmountFlags flags , GCancellable *cancellable ,
                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 196
extern gboolean g_mount_unmount_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 201
extern void g_mount_eject(GMount *mount , GMountUnmountFlags flags , GCancellable *cancellable ,
                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 208
extern gboolean g_mount_eject_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 213
extern void g_mount_remount(GMount *mount , GMountMountFlags flags , GMountOperation *mount_operation ,
                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                            gpointer user_data ) ;
#line 220
extern gboolean g_mount_remount_finish(GMount *mount , GAsyncResult *result , GError **error ) ;
#line 225
extern void g_mount_guess_content_type(GMount *mount , gboolean force_rescan , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 231
extern gchar **g_mount_guess_content_type_finish(GMount *mount , GAsyncResult *result ,
                                                 GError **error ) ;
#line 235
extern gchar **g_mount_guess_content_type_sync(GMount *mount , gboolean force_rescan ,
                                               GCancellable *cancellable , GError **error ) ;
#line 241
extern gboolean g_mount_is_shadowed(GMount *mount ) ;
#line 243
extern void g_mount_shadow(GMount *mount ) ;
#line 245
extern void g_mount_unshadow(GMount *mount ) ;
#line 248
extern void g_mount_unmount_with_operation(GMount *mount , GMountUnmountFlags flags ,
                                           GMountOperation *mount_operation , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 255
extern gboolean g_mount_unmount_with_operation_finish(GMount *mount , GAsyncResult *result ,
                                                      GError **error ) ;
#line 260
extern void g_mount_eject_with_operation(GMount *mount , GMountUnmountFlags flags ,
                                         GMountOperation *mount_operation , GCancellable *cancellable ,
                                         GAsyncReadyCallback callback , gpointer user_data ) ;
#line 267
extern gboolean g_mount_eject_with_operation_finish(GMount *mount , GAsyncResult *result ,
                                                    GError **error ) ;
#line 272
extern gchar *g_mount_get_sort_key(GMount *mount ) ;
#line 122 "/usr/include/glib-2.0/gio/gmountoperation.h"
extern GType g_mount_operation_get_type(void) ;
#line 124
extern GMountOperation *g_mount_operation_new(void) ;
#line 127
extern char const   *g_mount_operation_get_username(GMountOperation *op ) ;
#line 129
extern void g_mount_operation_set_username(GMountOperation *op , char const   *username ) ;
#line 132
extern char const   *g_mount_operation_get_password(GMountOperation *op ) ;
#line 134
extern void g_mount_operation_set_password(GMountOperation *op , char const   *password ) ;
#line 137
extern gboolean g_mount_operation_get_anonymous(GMountOperation *op ) ;
#line 139
extern void g_mount_operation_set_anonymous(GMountOperation *op , gboolean anonymous ) ;
#line 142
extern char const   *g_mount_operation_get_domain(GMountOperation *op ) ;
#line 144
extern void g_mount_operation_set_domain(GMountOperation *op , char const   *domain ) ;
#line 147
extern GPasswordSave g_mount_operation_get_password_save(GMountOperation *op ) ;
#line 149
extern void g_mount_operation_set_password_save(GMountOperation *op , GPasswordSave save ) ;
#line 152
extern int g_mount_operation_get_choice(GMountOperation *op ) ;
#line 154
extern void g_mount_operation_set_choice(GMountOperation *op , int choice ) ;
#line 157
extern void g_mount_operation_reply(GMountOperation *op , GMountOperationResult result ) ;
#line 160
extern gboolean g_mount_operation_get_is_tcrypt_hidden_volume(GMountOperation *op ) ;
#line 162
extern void g_mount_operation_set_is_tcrypt_hidden_volume(GMountOperation *op , gboolean hidden_volume ) ;
#line 165
extern gboolean g_mount_operation_get_is_tcrypt_system_volume(GMountOperation *op ) ;
#line 167
extern void g_mount_operation_set_is_tcrypt_system_volume(GMountOperation *op , gboolean system_volume ) ;
#line 170
extern guint g_mount_operation_get_pim(GMountOperation *op ) ;
#line 172
extern void g_mount_operation_set_pim(GMountOperation *op , guint pim ) ;
#line 57 "/usr/include/glib-2.0/gio/gnativesocketaddress.h"
extern GType g_native_socket_address_get_type(void) ;
#line 60
extern GSocketAddress *g_native_socket_address_new(gpointer native , gsize len ) ;
#line 132 "/usr/include/glib-2.0/gio/gvolumemonitor.h"
extern GType g_volume_monitor_get_type(void) ;
#line 135
extern GVolumeMonitor *g_volume_monitor_get(void) ;
#line 137
extern GList *g_volume_monitor_get_connected_drives(GVolumeMonitor *volume_monitor ) ;
#line 139
extern GList *g_volume_monitor_get_volumes(GVolumeMonitor *volume_monitor ) ;
#line 141
extern GList *g_volume_monitor_get_mounts(GVolumeMonitor *volume_monitor ) ;
#line 143
extern GVolume *g_volume_monitor_get_volume_for_uuid(GVolumeMonitor *volume_monitor ,
                                                     char const   *uuid ) ;
#line 146
extern GMount *g_volume_monitor_get_mount_for_uuid(GVolumeMonitor *volume_monitor ,
                                                   char const   *uuid ) ;
#line 150
extern GVolume *g_volume_monitor_adopt_orphan_mount(GMount *mount ) ;
#line 57 "/usr/include/glib-2.0/gio/gnativevolumemonitor.h"
extern GType g_native_volume_monitor_get_type(void) ;
#line 55 "/usr/include/glib-2.0/gio/gnetworkaddress.h"
extern GType g_network_address_get_type(void) ;
#line 58
extern GSocketConnectable *g_network_address_new(gchar *hostname , guint16 port ) ;
#line 61
extern GSocketConnectable *g_network_address_new_loopback(guint16 port ) ;
#line 63
extern GSocketConnectable *g_network_address_parse(gchar *host_and_port , guint16 default_port ,
                                                   GError **error ) ;
#line 67
extern GSocketConnectable *g_network_address_parse_uri(gchar *uri , guint16 default_port ,
                                                       GError **error ) ;
#line 71
extern gchar *g_network_address_get_hostname(GNetworkAddress *addr ) ;
#line 73
extern guint16 g_network_address_get_port(GNetworkAddress *addr ) ;
#line 75
extern gchar *g_network_address_get_scheme(GNetworkAddress *addr ) ;
#line 68 "/usr/include/glib-2.0/gio/gnetworkmonitor.h"
extern GType g_network_monitor_get_type(void) ;
#line 70
extern GNetworkMonitor *g_network_monitor_get_default(void) ;
#line 73
extern gboolean g_network_monitor_get_network_available(GNetworkMonitor *monitor ) ;
#line 76
extern gboolean g_network_monitor_get_network_metered(GNetworkMonitor *monitor ) ;
#line 79
extern GNetworkConnectivity g_network_monitor_get_connectivity(GNetworkMonitor *monitor ) ;
#line 82
extern gboolean g_network_monitor_can_reach(GNetworkMonitor *monitor , GSocketConnectable *connectable ,
                                            GCancellable *cancellable , GError **error ) ;
#line 87
extern void g_network_monitor_can_reach_async(GNetworkMonitor *monitor , GSocketConnectable *connectable ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 93
extern gboolean g_network_monitor_can_reach_finish(GNetworkMonitor *monitor , GAsyncResult *result ,
                                                   GError **error ) ;
#line 55 "/usr/include/glib-2.0/gio/gnetworkservice.h"
extern GType g_network_service_get_type(void) ;
#line 58
extern GSocketConnectable *g_network_service_new(gchar *service , gchar *protocol ,
                                                 gchar *domain ) ;
#line 63
extern gchar *g_network_service_get_service(GNetworkService *srv ) ;
#line 65
extern gchar *g_network_service_get_protocol(GNetworkService *srv ) ;
#line 67
extern gchar *g_network_service_get_domain(GNetworkService *srv ) ;
#line 69
extern gchar *g_network_service_get_scheme(GNetworkService *srv ) ;
#line 71
extern void g_network_service_set_scheme(GNetworkService *srv , gchar *scheme ) ;
#line 37 "/usr/include/glib-2.0/gio/gnotification.h"
extern GType g_notification_get_type(void) ;
#line 40
extern GNotification *g_notification_new(gchar *title ) ;
#line 43
extern void g_notification_set_title(GNotification *notification , gchar *title ) ;
#line 47
extern void g_notification_set_body(GNotification *notification , gchar *body ) ;
#line 51
extern void g_notification_set_icon(GNotification *notification , GIcon *icon ) ;
#line 55
extern void g_notification_set_urgent(GNotification *notification , gboolean urgent ) ;
#line 59
extern void g_notification_set_priority(GNotification *notification , GNotificationPriority priority ) ;
#line 63
extern void g_notification_set_category(GNotification *notification , gchar *category ) ;
#line 67
extern void g_notification_add_button(GNotification *notification , gchar *label ,
                                      gchar *detailed_action ) ;
#line 72
extern void g_notification_add_button_with_target(GNotification *notification , gchar *label ,
                                                  gchar *action , gchar *target_format 
                                                  , ...) ;
#line 79
extern void g_notification_add_button_with_target_value(GNotification *notification ,
                                                        gchar *label , gchar *action ,
                                                        GVariant *target ) ;
#line 85
extern void g_notification_set_default_action(GNotification *notification , gchar *detailed_action ) ;
#line 89
extern void g_notification_set_default_action_and_target(GNotification *notification ,
                                                         gchar *action , gchar *target_format 
                                                         , ...) ;
#line 95
extern void g_notification_set_default_action_and_target_value(GNotification *notification ,
                                                               gchar *action , GVariant *target ) ;
#line 83 "/usr/include/glib-2.0/gio/gpermission.h"
extern GType g_permission_get_type(void) ;
#line 85
extern gboolean g_permission_acquire(GPermission *permission , GCancellable *cancellable ,
                                     GError **error ) ;
#line 89
extern void g_permission_acquire_async(GPermission *permission , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 94
extern gboolean g_permission_acquire_finish(GPermission *permission , GAsyncResult *result ,
                                            GError **error ) ;
#line 99
extern gboolean g_permission_release(GPermission *permission , GCancellable *cancellable ,
                                     GError **error ) ;
#line 103
extern void g_permission_release_async(GPermission *permission , GCancellable *cancellable ,
                                       GAsyncReadyCallback callback , gpointer user_data ) ;
#line 108
extern gboolean g_permission_release_finish(GPermission *permission , GAsyncResult *result ,
                                            GError **error ) ;
#line 113
extern gboolean g_permission_get_allowed(GPermission *permission ) ;
#line 115
extern gboolean g_permission_get_can_acquire(GPermission *permission ) ;
#line 117
extern gboolean g_permission_get_can_release(GPermission *permission ) ;
#line 120
extern void g_permission_impl_update(GPermission *permission , gboolean allowed ,
                                     gboolean can_acquire , gboolean can_release ) ;
#line 83 "/usr/include/glib-2.0/gio/gpollableinputstream.h"
extern GType g_pollable_input_stream_get_type(void) ;
#line 86
extern gboolean g_pollable_input_stream_can_poll(GPollableInputStream *stream ) ;
#line 89
extern gboolean g_pollable_input_stream_is_readable(GPollableInputStream *stream ) ;
#line 91
extern GSource *g_pollable_input_stream_create_source(GPollableInputStream *stream ,
                                                      GCancellable *cancellable ) ;
#line 95
extern gssize g_pollable_input_stream_read_nonblocking(GPollableInputStream *stream ,
                                                       void *buffer , gsize count ,
                                                       GCancellable *cancellable ,
                                                       GError **error ) ;
#line 96 "/usr/include/glib-2.0/gio/gpollableoutputstream.h"
extern GType g_pollable_output_stream_get_type(void) ;
#line 99
extern gboolean g_pollable_output_stream_can_poll(GPollableOutputStream *stream ) ;
#line 102
extern gboolean g_pollable_output_stream_is_writable(GPollableOutputStream *stream ) ;
#line 104
extern GSource *g_pollable_output_stream_create_source(GPollableOutputStream *stream ,
                                                       GCancellable *cancellable ) ;
#line 108
extern gssize g_pollable_output_stream_write_nonblocking(GPollableOutputStream *stream ,
                                                         void const   *buffer , gsize count ,
                                                         GCancellable *cancellable ,
                                                         GError **error ) ;
#line 115
extern GPollableReturn g_pollable_output_stream_writev_nonblocking(GPollableOutputStream *stream ,
                                                                   GOutputVector *vectors ,
                                                                   gsize n_vectors ,
                                                                   gsize *bytes_written ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 31 "/usr/include/glib-2.0/gio/gpollableutils.h"
extern GSource *g_pollable_source_new(GObject *pollable_stream ) ;
#line 34
extern GSource *g_pollable_source_new_full(gpointer pollable_stream , GSource *child_source ,
                                           GCancellable *cancellable ) ;
#line 39
extern gssize g_pollable_stream_read(GInputStream *stream , void *buffer , gsize count ,
                                     gboolean blocking , GCancellable *cancellable ,
                                     GError **error ) ;
#line 47
extern gssize g_pollable_stream_write(GOutputStream *stream , void const   *buffer ,
                                      gsize count , gboolean blocking , GCancellable *cancellable ,
                                      GError **error ) ;
#line 54
extern gboolean g_pollable_stream_write_all(GOutputStream *stream , void const   *buffer ,
                                            gsize count , gboolean blocking , gsize *bytes_written ,
                                            GCancellable *cancellable , GError **error ) ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
extern GType g_power_profile_monitor_get_type(void) ;
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static void glib_autoptr_clear_GPowerProfileMonitor(GPowerProfileMonitor *_ptr ) 
{ 


  {
#line 43
  if (_ptr) {
    {
#line 43
    glib_autoptr_clear_GObject((GObject *)_ptr);
    }
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static void glib_autoptr_cleanup_GPowerProfileMonitor(GPowerProfileMonitor **_ptr ) 
{ 


  {
  {
#line 43
  glib_autoptr_clear_GPowerProfileMonitor(*_ptr);
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static GPowerProfileMonitor *g_power_profile_monitor(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  GTypeInstance *__cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp2 = g_power_profile_monitor_get_type();
#line 43
  __cil_tmp3 = g_type_check_instance_cast((GTypeInstance *)ptr, __cil_tmp2);
  }
#line 43
  return ((GPowerProfileMonitor *)((void *)__cil_tmp3));
}
}
#line 43 "/usr/include/glib-2.0/gio/gpowerprofilemonitor.h"
__inline static GPowerProfileMonitorInterface *g_power_profile_monitor_GET_IFACE(gpointer ptr ) 
{ 
  GType __cil_tmp2 ;
  gpointer __cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp2 = g_power_profile_monitor_get_type();
#line 43
  __cil_tmp3 = g_type_interface_peek(((GTypeInstance *)ptr)->g_class, __cil_tmp2);
  }
#line 43
  return ((GPowerProfileMonitorInterface *)__cil_tmp3);
}
}
#line 56
extern GPowerProfileMonitor *g_power_profile_monitor_dup_default(void) ;
#line 59
extern gboolean g_power_profile_monitor_get_power_saver_enabled(GPowerProfileMonitor *monitor ) ;
#line 38 "/usr/include/glib-2.0/gio/gpropertyaction.h"
extern GType g_property_action_get_type(void) ;
#line 41
extern GPropertyAction *g_property_action_new(gchar *name , gpointer object , gchar *property_name ) ;
#line 98 "/usr/include/glib-2.0/gio/gproxy.h"
extern GType g_proxy_get_type(void) ;
#line 101
extern GProxy *g_proxy_get_default_for_protocol(gchar *protocol ) ;
#line 104
extern GIOStream *g_proxy_connect(GProxy *proxy , GIOStream *connection , GProxyAddress *proxy_address ,
                                  GCancellable *cancellable , GError **error ) ;
#line 111
extern void g_proxy_connect_async(GProxy *proxy , GIOStream *connection , GProxyAddress *proxy_address ,
                                  GCancellable *cancellable , GAsyncReadyCallback callback ,
                                  gpointer user_data ) ;
#line 119
extern GIOStream *g_proxy_connect_finish(GProxy *proxy , GAsyncResult *result , GError **error ) ;
#line 124
extern gboolean g_proxy_supports_hostname(GProxy *proxy ) ;
#line 57 "/usr/include/glib-2.0/gio/gproxyaddress.h"
extern GType g_proxy_address_get_type(void) ;
#line 60
extern GSocketAddress *g_proxy_address_new(GInetAddress *inetaddr , guint16 port ,
                                           gchar *protocol , gchar *dest_hostname ,
                                           guint16 dest_port , gchar *username , gchar *password ) ;
#line 69
extern gchar *g_proxy_address_get_protocol(GProxyAddress *proxy ) ;
#line 71
extern gchar *g_proxy_address_get_destination_protocol(GProxyAddress *proxy ) ;
#line 73
extern gchar *g_proxy_address_get_destination_hostname(GProxyAddress *proxy ) ;
#line 75
extern guint16 g_proxy_address_get_destination_port(GProxyAddress *proxy ) ;
#line 77
extern gchar *g_proxy_address_get_username(GProxyAddress *proxy ) ;
#line 79
extern gchar *g_proxy_address_get_password(GProxyAddress *proxy ) ;
#line 82
extern gchar *g_proxy_address_get_uri(GProxyAddress *proxy ) ;
#line 81 "/usr/include/glib-2.0/gio/gsocketaddressenumerator.h"
extern GType g_socket_address_enumerator_get_type(void) ;
#line 84
extern GSocketAddress *g_socket_address_enumerator_next(GSocketAddressEnumerator *enumerator ,
                                                        GCancellable *cancellable ,
                                                        GError **error ) ;
#line 89
extern void g_socket_address_enumerator_next_async(GSocketAddressEnumerator *enumerator ,
                                                   GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                   gpointer user_data ) ;
#line 94
extern GSocketAddress *g_socket_address_enumerator_next_finish(GSocketAddressEnumerator *enumerator ,
                                                               GAsyncResult *result ,
                                                               GError **error ) ;
#line 77 "/usr/include/glib-2.0/gio/gproxyaddressenumerator.h"
extern GType g_proxy_address_enumerator_get_type(void) ;
#line 70 "/usr/include/glib-2.0/gio/gproxyresolver.h"
extern GType g_proxy_resolver_get_type(void) ;
#line 72
extern GProxyResolver *g_proxy_resolver_get_default(void) ;
#line 75
extern gboolean g_proxy_resolver_is_supported(GProxyResolver *resolver ) ;
#line 77
extern gchar **g_proxy_resolver_lookup(GProxyResolver *resolver , gchar *uri , GCancellable *cancellable ,
                                       GError **error ) ;
#line 82
extern void g_proxy_resolver_lookup_async(GProxyResolver *resolver , gchar *uri ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 88
extern gchar **g_proxy_resolver_lookup_finish(GProxyResolver *resolver , GAsyncResult *result ,
                                              GError **error ) ;
#line 59 "/usr/include/glib-2.0/gio/gremoteactiongroup.h"
extern GType g_remote_action_group_get_type(void) ;
#line 62
extern void g_remote_action_group_activate_action_full(GRemoteActionGroup *remote ,
                                                       gchar *action_name , GVariant *parameter ,
                                                       GVariant *platform_data ) ;
#line 68
extern void g_remote_action_group_change_action_state_full(GRemoteActionGroup *remote ,
                                                           gchar *action_name , GVariant *value ,
                                                           GVariant *platform_data ) ;
#line 185 "/usr/include/glib-2.0/gio/gresolver.h"
extern GType g_resolver_get_type(void) ;
#line 187
extern GResolver *g_resolver_get_default(void) ;
#line 189
extern void g_resolver_set_default(GResolver *resolver ) ;
#line 191
extern GList *g_resolver_lookup_by_name(GResolver *resolver , gchar *hostname , GCancellable *cancellable ,
                                        GError **error ) ;
#line 196
extern void g_resolver_lookup_by_name_async(GResolver *resolver , gchar *hostname ,
                                            GCancellable *cancellable , GAsyncReadyCallback callback ,
                                            gpointer user_data ) ;
#line 202
extern GList *g_resolver_lookup_by_name_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 206
extern void g_resolver_lookup_by_name_with_flags_async(GResolver *resolver , gchar *hostname ,
                                                       GResolverNameLookupFlags flags ,
                                                       GCancellable *cancellable ,
                                                       GAsyncReadyCallback callback ,
                                                       gpointer user_data ) ;
#line 213
extern GList *g_resolver_lookup_by_name_with_flags_finish(GResolver *resolver , GAsyncResult *result ,
                                                          GError **error ) ;
#line 217
extern GList *g_resolver_lookup_by_name_with_flags(GResolver *resolver , gchar *hostname ,
                                                   GResolverNameLookupFlags flags ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 223
extern void g_resolver_free_addresses(GList *addresses ) ;
#line 225
extern gchar *g_resolver_lookup_by_address(GResolver *resolver , GInetAddress *address ,
                                           GCancellable *cancellable , GError **error ) ;
#line 230
extern void g_resolver_lookup_by_address_async(GResolver *resolver , GInetAddress *address ,
                                               GCancellable *cancellable , GAsyncReadyCallback callback ,
                                               gpointer user_data ) ;
#line 236
extern gchar *g_resolver_lookup_by_address_finish(GResolver *resolver , GAsyncResult *result ,
                                                  GError **error ) ;
#line 240
extern GList *g_resolver_lookup_service(GResolver *resolver , gchar *service , gchar *protocol ,
                                        gchar *domain , GCancellable *cancellable ,
                                        GError **error ) ;
#line 247
extern void g_resolver_lookup_service_async(GResolver *resolver , gchar *service ,
                                            gchar *protocol , gchar *domain , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 255
extern GList *g_resolver_lookup_service_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 259
extern GList *g_resolver_lookup_records(GResolver *resolver , gchar *rrname , GResolverRecordType record_type ,
                                        GCancellable *cancellable , GError **error ) ;
#line 265
extern void g_resolver_lookup_records_async(GResolver *resolver , gchar *rrname ,
                                            GResolverRecordType record_type , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data ) ;
#line 272
extern GList *g_resolver_lookup_records_finish(GResolver *resolver , GAsyncResult *result ,
                                               GError **error ) ;
#line 276
extern void g_resolver_free_targets(GList *targets ) ;
#line 288
extern GQuark g_resolver_error_quark(void) ;
#line 49 "/usr/include/glib-2.0/gio/gresource.h"
extern GQuark g_resource_error_quark(void) ;
#line 63
extern GType g_resource_get_type(void) ;
#line 65
extern GResource *g_resource_new_from_data(GBytes *data , GError **error ) ;
#line 68
extern GResource *g_resource_ref(GResource *resource ) ;
#line 70
extern void g_resource_unref(GResource *resource ) ;
#line 72
extern GResource *g_resource_load(gchar *filename , GError **error ) ;
#line 75
extern GInputStream *g_resource_open_stream(GResource *resource , char const   *path ,
                                            GResourceLookupFlags lookup_flags , GError **error ) ;
#line 80
extern GBytes *g_resource_lookup_data(GResource *resource , char const   *path , GResourceLookupFlags lookup_flags ,
                                      GError **error ) ;
#line 85
extern char **g_resource_enumerate_children(GResource *resource , char const   *path ,
                                            GResourceLookupFlags lookup_flags , GError **error ) ;
#line 90
extern gboolean g_resource_get_info(GResource *resource , char const   *path , GResourceLookupFlags lookup_flags ,
                                    gsize *size , guint32 *flags , GError **error ) ;
#line 98
extern void g_resources_register(GResource *resource ) ;
#line 100
extern void g_resources_unregister(GResource *resource ) ;
#line 102
extern GInputStream *g_resources_open_stream(char const   *path , GResourceLookupFlags lookup_flags ,
                                             GError **error ) ;
#line 106
extern GBytes *g_resources_lookup_data(char const   *path , GResourceLookupFlags lookup_flags ,
                                       GError **error ) ;
#line 110
extern char **g_resources_enumerate_children(char const   *path , GResourceLookupFlags lookup_flags ,
                                             GError **error ) ;
#line 114
extern gboolean g_resources_get_info(char const   *path , GResourceLookupFlags lookup_flags ,
                                     gsize *size , guint32 *flags , GError **error ) ;
#line 122
extern void g_static_resource_init(GStaticResource *static_resource ) ;
#line 124
extern void g_static_resource_fini(GStaticResource *static_resource ) ;
#line 126
extern GResource *g_static_resource_get_resource(GStaticResource *static_resource ) ;
#line 80 "/usr/include/glib-2.0/gio/gseekable.h"
extern GType g_seekable_get_type(void) ;
#line 83
extern goffset g_seekable_tell(GSeekable *seekable ) ;
#line 85
extern gboolean g_seekable_can_seek(GSeekable *seekable ) ;
#line 87
extern gboolean g_seekable_seek(GSeekable *seekable , goffset offset , GSeekType type ,
                                GCancellable *cancellable , GError **error ) ;
#line 93
extern gboolean g_seekable_can_truncate(GSeekable *seekable ) ;
#line 95
extern gboolean g_seekable_truncate(GSeekable *seekable , goffset offset , GCancellable *cancellable ,
                                    GError **error ) ;
#line 32 "/usr/include/glib-2.0/gio/gsettingsschema.h"
extern GType g_settings_schema_source_get_type(void) ;
#line 35
extern GSettingsSchemaSource *g_settings_schema_source_get_default(void) ;
#line 37
extern GSettingsSchemaSource *g_settings_schema_source_ref(GSettingsSchemaSource *source ) ;
#line 39
extern void g_settings_schema_source_unref(GSettingsSchemaSource *source ) ;
#line 42
extern GSettingsSchemaSource *g_settings_schema_source_new_from_directory(gchar *directory ,
                                                                          GSettingsSchemaSource *parent ,
                                                                          gboolean trusted ,
                                                                          GError **error ) ;
#line 48
extern GSettingsSchema *g_settings_schema_source_lookup(GSettingsSchemaSource *source ,
                                                        gchar *schema_id , gboolean recursive ) ;
#line 53
extern void g_settings_schema_source_list_schemas(GSettingsSchemaSource *source ,
                                                  gboolean recursive , gchar ***non_relocatable ,
                                                  gchar ***relocatable ) ;
#line 60
extern GType g_settings_schema_get_type(void) ;
#line 63
extern GSettingsSchema *g_settings_schema_ref(GSettingsSchema *schema ) ;
#line 65
extern void g_settings_schema_unref(GSettingsSchema *schema ) ;
#line 68
extern gchar *g_settings_schema_get_id(GSettingsSchema *schema ) ;
#line 70
extern gchar *g_settings_schema_get_path(GSettingsSchema *schema ) ;
#line 72
extern GSettingsSchemaKey *g_settings_schema_get_key(GSettingsSchema *schema , gchar *name ) ;
#line 75
extern gboolean g_settings_schema_has_key(GSettingsSchema *schema , gchar *name ) ;
#line 78
extern gchar **g_settings_schema_list_keys(GSettingsSchema *schema ) ;
#line 82
extern gchar **g_settings_schema_list_children(GSettingsSchema *schema ) ;
#line 86
extern GType g_settings_schema_key_get_type(void) ;
#line 89
extern GSettingsSchemaKey *g_settings_schema_key_ref(GSettingsSchemaKey *key ) ;
#line 91
extern void g_settings_schema_key_unref(GSettingsSchemaKey *key ) ;
#line 94
extern GVariantType *g_settings_schema_key_get_value_type(GSettingsSchemaKey *key ) ;
#line 96
extern GVariant *g_settings_schema_key_get_default_value(GSettingsSchemaKey *key ) ;
#line 98
extern GVariant *g_settings_schema_key_get_range(GSettingsSchemaKey *key ) ;
#line 100
extern gboolean g_settings_schema_key_range_check(GSettingsSchemaKey *key , GVariant *value ) ;
#line 104
extern gchar *g_settings_schema_key_get_name(GSettingsSchemaKey *key ) ;
#line 106
extern gchar *g_settings_schema_key_get_summary(GSettingsSchemaKey *key ) ;
#line 108
extern gchar *g_settings_schema_key_get_description(GSettingsSchemaKey *key ) ;
#line 71 "/usr/include/glib-2.0/gio/gsettings.h"
extern GType g_settings_get_type(void) ;
#line 74
extern gchar * const  *g_settings_list_schemas(void) ;
#line 76
extern gchar * const  *g_settings_list_relocatable_schemas(void) ;
#line 78
extern GSettings *g_settings_new(gchar *schema_id ) ;
#line 80
extern GSettings *g_settings_new_with_path(gchar *schema_id , gchar *path ) ;
#line 83
extern GSettings *g_settings_new_with_backend(gchar *schema_id , GSettingsBackend *backend ) ;
#line 86
extern GSettings *g_settings_new_with_backend_and_path(gchar *schema_id , GSettingsBackend *backend ,
                                                       gchar *path ) ;
#line 90
extern GSettings *g_settings_new_full(GSettingsSchema *schema , GSettingsBackend *backend ,
                                      gchar *path ) ;
#line 94
extern gchar **g_settings_list_children(GSettings *settings ) ;
#line 96
extern gchar **g_settings_list_keys(GSettings *settings ) ;
#line 98
extern GVariant *g_settings_get_range(GSettings *settings , gchar *key ) ;
#line 101
extern gboolean g_settings_range_check(GSettings *settings , gchar *key , GVariant *value ) ;
#line 106
extern gboolean g_settings_set_value(GSettings *settings , gchar *key , GVariant *value ) ;
#line 110
extern GVariant *g_settings_get_value(GSettings *settings , gchar *key ) ;
#line 114
extern GVariant *g_settings_get_user_value(GSettings *settings , gchar *key ) ;
#line 117
extern GVariant *g_settings_get_default_value(GSettings *settings , gchar *key ) ;
#line 121
extern gboolean g_settings_set(GSettings *settings , gchar *key , gchar *format  , ...) ;
#line 126
extern void g_settings_get(GSettings *settings , gchar *key , gchar *format  , ...) ;
#line 131
extern void g_settings_reset(GSettings *settings , gchar *key ) ;
#line 135
extern gint g_settings_get_int(GSettings *settings , gchar *key ) ;
#line 138
extern gboolean g_settings_set_int(GSettings *settings , gchar *key , gint value ) ;
#line 142
extern gint64 g_settings_get_int64(GSettings *settings , gchar *key ) ;
#line 145
extern gboolean g_settings_set_int64(GSettings *settings , gchar *key , gint64 value ) ;
#line 149
extern guint g_settings_get_uint(GSettings *settings , gchar *key ) ;
#line 152
extern gboolean g_settings_set_uint(GSettings *settings , gchar *key , guint value ) ;
#line 156
extern guint64 g_settings_get_uint64(GSettings *settings , gchar *key ) ;
#line 159
extern gboolean g_settings_set_uint64(GSettings *settings , gchar *key , guint64 value ) ;
#line 163
extern gchar *g_settings_get_string(GSettings *settings , gchar *key ) ;
#line 166
extern gboolean g_settings_set_string(GSettings *settings , gchar *key , gchar *value ) ;
#line 170
extern gboolean g_settings_get_boolean(GSettings *settings , gchar *key ) ;
#line 173
extern gboolean g_settings_set_boolean(GSettings *settings , gchar *key , gboolean value ) ;
#line 177
extern gdouble g_settings_get_double(GSettings *settings , gchar *key ) ;
#line 180
extern gboolean g_settings_set_double(GSettings *settings , gchar *key , gdouble value ) ;
#line 184
extern gchar **g_settings_get_strv(GSettings *settings , gchar *key ) ;
#line 187
extern gboolean g_settings_set_strv(GSettings *settings , gchar *key , gchar * const  *value ) ;
#line 191
extern gint g_settings_get_enum(GSettings *settings , gchar *key ) ;
#line 194
extern gboolean g_settings_set_enum(GSettings *settings , gchar *key , gint value ) ;
#line 198
extern guint g_settings_get_flags(GSettings *settings , gchar *key ) ;
#line 201
extern gboolean g_settings_set_flags(GSettings *settings , gchar *key , guint value ) ;
#line 205
extern GSettings *g_settings_get_child(GSettings *settings , gchar *name ) ;
#line 209
extern gboolean g_settings_is_writable(GSettings *settings , gchar *name ) ;
#line 213
extern void g_settings_delay(GSettings *settings ) ;
#line 215
extern void g_settings_apply(GSettings *settings ) ;
#line 217
extern void g_settings_revert(GSettings *settings ) ;
#line 219
extern gboolean g_settings_get_has_unapplied(GSettings *settings ) ;
#line 221
extern void g_settings_sync(void) ;
#line 308
extern void g_settings_bind(GSettings *settings , gchar *key , gpointer object , gchar *property ,
                            GSettingsBindFlags flags ) ;
#line 314
extern void g_settings_bind_with_mapping(GSettings *settings , gchar *key , gpointer object ,
                                         gchar *property , GSettingsBindFlags flags ,
                                         GSettingsBindGetMapping get_mapping , GSettingsBindSetMapping set_mapping ,
                                         gpointer user_data , GDestroyNotify destroy ) ;
#line 324
extern void g_settings_bind_writable(GSettings *settings , gchar *key , gpointer object ,
                                     gchar *property , gboolean inverted ) ;
#line 330
extern void g_settings_unbind(gpointer object , gchar *property ) ;
#line 334
extern GAction *g_settings_create_action(GSettings *settings , gchar *key ) ;
#line 338
extern gpointer g_settings_get_mapped(GSettings *settings , gchar *key , GSettingsGetMapping mapping ,
                                      gpointer user_data ) ;
#line 38 "/usr/include/glib-2.0/gio/gsimpleaction.h"
extern GType g_simple_action_get_type(void) ;
#line 41
extern GSimpleAction *g_simple_action_new(gchar *name , GVariantType *parameter_type ) ;
#line 45
extern GSimpleAction *g_simple_action_new_stateful(gchar *name , GVariantType *parameter_type ,
                                                   GVariant *state ) ;
#line 50
extern void g_simple_action_set_enabled(GSimpleAction *simple , gboolean enabled ) ;
#line 54
extern void g_simple_action_set_state(GSimpleAction *simple , GVariant *value ) ;
#line 58
extern void g_simple_action_set_state_hint(GSimpleAction *simple , GVariant *state_hint ) ;
#line 72 "/usr/include/glib-2.0/gio/gsimpleactiongroup.h"
extern GType g_simple_action_group_get_type(void) ;
#line 75
extern GSimpleActionGroup *g_simple_action_group_new(void) ;
#line 78
extern GAction *g_simple_action_group_lookup(GSimpleActionGroup *simple , gchar *action_name ) ;
#line 82
extern void g_simple_action_group_insert(GSimpleActionGroup *simple , GAction *action ) ;
#line 86
extern void g_simple_action_group_remove(GSimpleActionGroup *simple , gchar *action_name ) ;
#line 90
extern void g_simple_action_group_add_entries(GSimpleActionGroup *simple , GActionEntry *entries ,
                                              gint n_entries , gpointer user_data ) ;
#line 48 "/usr/include/glib-2.0/gio/gsimpleasyncresult.h"
extern GType g_simple_async_result_get_type(void) ;
#line 51
extern GSimpleAsyncResult *g_simple_async_result_new(GObject *source_object , GAsyncReadyCallback callback ,
                                                     gpointer user_data , gpointer source_tag ) ;
#line 56
extern GSimpleAsyncResult *g_simple_async_result_new_error(GObject *source_object ,
                                                           GAsyncReadyCallback callback ,
                                                           gpointer user_data , GQuark domain ,
                                                           gint code , char const   *format 
                                                           , ...) ;
#line 64
extern GSimpleAsyncResult *g_simple_async_result_new_from_error(GObject *source_object ,
                                                                GAsyncReadyCallback callback ,
                                                                gpointer user_data ,
                                                                GError *error ) ;
#line 69
extern GSimpleAsyncResult *g_simple_async_result_new_take_error(GObject *source_object ,
                                                                GAsyncReadyCallback callback ,
                                                                gpointer user_data ,
                                                                GError *error ) ;
#line 75
extern void g_simple_async_result_set_op_res_gpointer(GSimpleAsyncResult *simple ,
                                                      gpointer op_res , GDestroyNotify destroy_op_res ) ;
#line 79
extern gpointer g_simple_async_result_get_op_res_gpointer(GSimpleAsyncResult *simple ) ;
#line 82
extern void g_simple_async_result_set_op_res_gssize(GSimpleAsyncResult *simple , gssize op_res ) ;
#line 85
extern gssize g_simple_async_result_get_op_res_gssize(GSimpleAsyncResult *simple ) ;
#line 88
extern void g_simple_async_result_set_op_res_gboolean(GSimpleAsyncResult *simple ,
                                                      gboolean op_res ) ;
#line 91
extern gboolean g_simple_async_result_get_op_res_gboolean(GSimpleAsyncResult *simple ) ;
#line 96
extern void g_simple_async_result_set_check_cancellable(GSimpleAsyncResult *simple ,
                                                        GCancellable *check_cancellable ) ;
#line 99
extern gpointer g_simple_async_result_get_source_tag(GSimpleAsyncResult *simple ) ;
#line 101
extern void g_simple_async_result_set_handle_cancellation(GSimpleAsyncResult *simple ,
                                                          gboolean handle_cancellation ) ;
#line 104
extern void g_simple_async_result_complete(GSimpleAsyncResult *simple ) ;
#line 106
extern void g_simple_async_result_complete_in_idle(GSimpleAsyncResult *simple ) ;
#line 108
extern void g_simple_async_result_run_in_thread(GSimpleAsyncResult *simple , GSimpleAsyncThreadFunc func ,
                                                int io_priority , GCancellable *cancellable ) ;
#line 113
extern void g_simple_async_result_set_from_error(GSimpleAsyncResult *simple , GError *error ) ;
#line 116
extern void g_simple_async_result_take_error(GSimpleAsyncResult *simple , GError *error ) ;
#line 119
extern gboolean g_simple_async_result_propagate_error(GSimpleAsyncResult *simple ,
                                                      GError **dest ) ;
#line 122
extern void g_simple_async_result_set_error(GSimpleAsyncResult *simple , GQuark domain ,
                                            gint code , char const   *format  , ...) ;
#line 128
extern void g_simple_async_result_set_error_va(GSimpleAsyncResult *simple , GQuark domain ,
                                               gint code , char const   *format ,
                                               va_list args ) ;
#line 135
extern gboolean g_simple_async_result_is_valid(GAsyncResult *result , GObject *source ,
                                               gpointer source_tag ) ;
#line 140
extern void g_simple_async_report_error_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                gpointer user_data , GQuark domain ,
                                                gint code , char const   *format 
                                                , ...) ;
#line 148
extern void g_simple_async_report_gerror_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                 gpointer user_data , GError *error ) ;
#line 153
extern void g_simple_async_report_take_gerror_in_idle(GObject *object , GAsyncReadyCallback callback ,
                                                      gpointer user_data , GError *error ) ;
#line 37 "/usr/include/glib-2.0/gio/gsimpleiostream.h"
extern GType g_simple_io_stream_get_type(void) ;
#line 40
extern GIOStream *g_simple_io_stream_new(GInputStream *input_stream , GOutputStream *output_stream ) ;
#line 39 "/usr/include/glib-2.0/gio/gsimplepermission.h"
extern GType g_simple_permission_get_type(void) ;
#line 41
extern GPermission *g_simple_permission_new(gboolean allowed ) ;
#line 68 "/usr/include/glib-2.0/gio/gsimpleproxyresolver.h"
extern GType g_simple_proxy_resolver_get_type(void) ;
#line 71
extern GProxyResolver *g_simple_proxy_resolver_new(gchar *default_proxy , gchar **ignore_hosts ) ;
#line 75
extern void g_simple_proxy_resolver_set_default_proxy(GSimpleProxyResolver *resolver ,
                                                      gchar *default_proxy ) ;
#line 79
extern void g_simple_proxy_resolver_set_ignore_hosts(GSimpleProxyResolver *resolver ,
                                                     gchar **ignore_hosts ) ;
#line 83
extern void g_simple_proxy_resolver_set_uri_proxy(GSimpleProxyResolver *resolver ,
                                                  gchar *uri_scheme , gchar *proxy ) ;
#line 75 "/usr/include/glib-2.0/gio/gsocket.h"
extern GType g_socket_get_type(void) ;
#line 77
extern GSocket *g_socket_new(GSocketFamily family , GSocketType type , GSocketProtocol protocol ,
                             GError **error ) ;
#line 82
extern GSocket *g_socket_new_from_fd(gint fd , GError **error ) ;
#line 85
extern int g_socket_get_fd(GSocket *socket ) ;
#line 87
extern GSocketFamily g_socket_get_family(GSocket *socket ) ;
#line 89
extern GSocketType g_socket_get_socket_type(GSocket *socket ) ;
#line 91
extern GSocketProtocol g_socket_get_protocol(GSocket *socket ) ;
#line 93
extern GSocketAddress *g_socket_get_local_address(GSocket *socket , GError **error ) ;
#line 96
extern GSocketAddress *g_socket_get_remote_address(GSocket *socket , GError **error ) ;
#line 99
extern void g_socket_set_blocking(GSocket *socket , gboolean blocking ) ;
#line 102
extern gboolean g_socket_get_blocking(GSocket *socket ) ;
#line 104
extern void g_socket_set_keepalive(GSocket *socket , gboolean keepalive ) ;
#line 107
extern gboolean g_socket_get_keepalive(GSocket *socket ) ;
#line 109
extern gint g_socket_get_listen_backlog(GSocket *socket ) ;
#line 111
extern void g_socket_set_listen_backlog(GSocket *socket , gint backlog ) ;
#line 114
extern guint g_socket_get_timeout(GSocket *socket ) ;
#line 116
extern void g_socket_set_timeout(GSocket *socket , guint timeout ) ;
#line 120
extern guint g_socket_get_ttl(GSocket *socket ) ;
#line 122
extern void g_socket_set_ttl(GSocket *socket , guint ttl ) ;
#line 126
extern gboolean g_socket_get_broadcast(GSocket *socket ) ;
#line 128
extern void g_socket_set_broadcast(GSocket *socket , gboolean broadcast ) ;
#line 132
extern gboolean g_socket_get_multicast_loopback(GSocket *socket ) ;
#line 134
extern void g_socket_set_multicast_loopback(GSocket *socket , gboolean loopback ) ;
#line 137
extern guint g_socket_get_multicast_ttl(GSocket *socket ) ;
#line 139
extern void g_socket_set_multicast_ttl(GSocket *socket , guint ttl ) ;
#line 142
extern gboolean g_socket_is_connected(GSocket *socket ) ;
#line 144
extern gboolean g_socket_bind(GSocket *socket , GSocketAddress *address , gboolean allow_reuse ,
                              GError **error ) ;
#line 149
extern gboolean g_socket_join_multicast_group(GSocket *socket , GInetAddress *group ,
                                              gboolean source_specific , gchar *iface ,
                                              GError **error ) ;
#line 155
extern gboolean g_socket_leave_multicast_group(GSocket *socket , GInetAddress *group ,
                                               gboolean source_specific , gchar *iface ,
                                               GError **error ) ;
#line 161
extern gboolean g_socket_join_multicast_group_ssm(GSocket *socket , GInetAddress *group ,
                                                  GInetAddress *source_specific ,
                                                  gchar *iface , GError **error ) ;
#line 167
extern gboolean g_socket_leave_multicast_group_ssm(GSocket *socket , GInetAddress *group ,
                                                   GInetAddress *source_specific ,
                                                   gchar *iface , GError **error ) ;
#line 173
extern gboolean g_socket_connect(GSocket *socket , GSocketAddress *address , GCancellable *cancellable ,
                                 GError **error ) ;
#line 178
extern gboolean g_socket_check_connect_result(GSocket *socket , GError **error ) ;
#line 182
extern gssize g_socket_get_available_bytes(GSocket *socket ) ;
#line 185
extern GIOCondition g_socket_condition_check(GSocket *socket , GIOCondition condition ) ;
#line 188
extern gboolean g_socket_condition_wait(GSocket *socket , GIOCondition condition ,
                                        GCancellable *cancellable , GError **error ) ;
#line 193
extern gboolean g_socket_condition_timed_wait(GSocket *socket , GIOCondition condition ,
                                              gint64 timeout_us , GCancellable *cancellable ,
                                              GError **error ) ;
#line 199
extern GSocket *g_socket_accept(GSocket *socket , GCancellable *cancellable , GError **error ) ;
#line 203
extern gboolean g_socket_listen(GSocket *socket , GError **error ) ;
#line 206
extern gssize g_socket_receive(GSocket *socket , gchar *buffer , gsize size , GCancellable *cancellable ,
                               GError **error ) ;
#line 212
extern gssize g_socket_receive_from(GSocket *socket , GSocketAddress **address , gchar *buffer ,
                                    gsize size , GCancellable *cancellable , GError **error ) ;
#line 219
extern gssize g_socket_send(GSocket *socket , gchar *buffer , gsize size , GCancellable *cancellable ,
                            GError **error ) ;
#line 225
extern gssize g_socket_send_to(GSocket *socket , GSocketAddress *address , gchar *buffer ,
                               gsize size , GCancellable *cancellable , GError **error ) ;
#line 232
extern gssize g_socket_receive_message(GSocket *socket , GSocketAddress **address ,
                                       GInputVector *vectors , gint num_vectors ,
                                       GSocketControlMessage ***messages , gint *num_messages ,
                                       gint *flags , GCancellable *cancellable , GError **error ) ;
#line 242
extern gssize g_socket_send_message(GSocket *socket , GSocketAddress *address , GOutputVector *vectors ,
                                    gint num_vectors , GSocketControlMessage **messages ,
                                    gint num_messages , gint flags , GCancellable *cancellable ,
                                    GError **error ) ;
#line 253
extern gint g_socket_receive_messages(GSocket *socket , GInputMessage *messages ,
                                      guint num_messages , gint flags , GCancellable *cancellable ,
                                      GError **error ) ;
#line 260
extern gint g_socket_send_messages(GSocket *socket , GOutputMessage *messages , guint num_messages ,
                                   gint flags , GCancellable *cancellable , GError **error ) ;
#line 268
extern gboolean g_socket_close(GSocket *socket , GError **error ) ;
#line 271
extern gboolean g_socket_shutdown(GSocket *socket , gboolean shutdown_read , gboolean shutdown_write ,
                                  GError **error ) ;
#line 276
extern gboolean g_socket_is_closed(GSocket *socket ) ;
#line 278
extern GSource *g_socket_create_source(GSocket *socket , GIOCondition condition ,
                                       GCancellable *cancellable ) ;
#line 282
extern gboolean g_socket_speaks_ipv4(GSocket *socket ) ;
#line 284
extern GCredentials *g_socket_get_credentials(GSocket *socket , GError **error ) ;
#line 288
extern gssize g_socket_receive_with_blocking(GSocket *socket , gchar *buffer , gsize size ,
                                             gboolean blocking , GCancellable *cancellable ,
                                             GError **error ) ;
#line 295
extern gssize g_socket_send_with_blocking(GSocket *socket , gchar *buffer , gsize size ,
                                          gboolean blocking , GCancellable *cancellable ,
                                          GError **error ) ;
#line 302
extern GPollableReturn g_socket_send_message_with_timeout(GSocket *socket , GSocketAddress *address ,
                                                          GOutputVector *vectors ,
                                                          gint num_vectors , GSocketControlMessage **messages ,
                                                          gint num_messages , gint flags ,
                                                          gint64 timeout_us , gsize *bytes_written ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 314
extern gboolean g_socket_get_option(GSocket *socket , gint level , gint optname ,
                                    gint *value , GError **error ) ;
#line 320
extern gboolean g_socket_set_option(GSocket *socket , gint level , gint optname ,
                                    gint value , GError **error ) ;
#line 72 "/usr/include/glib-2.0/gio/gsocketclient.h"
extern GType g_socket_client_get_type(void) ;
#line 75
extern GSocketClient *g_socket_client_new(void) ;
#line 78
extern GSocketFamily g_socket_client_get_family(GSocketClient *client ) ;
#line 80
extern void g_socket_client_set_family(GSocketClient *client , GSocketFamily family ) ;
#line 83
extern GSocketType g_socket_client_get_socket_type(GSocketClient *client ) ;
#line 85
extern void g_socket_client_set_socket_type(GSocketClient *client , GSocketType type ) ;
#line 88
extern GSocketProtocol g_socket_client_get_protocol(GSocketClient *client ) ;
#line 90
extern void g_socket_client_set_protocol(GSocketClient *client , GSocketProtocol protocol ) ;
#line 93
extern GSocketAddress *g_socket_client_get_local_address(GSocketClient *client ) ;
#line 95
extern void g_socket_client_set_local_address(GSocketClient *client , GSocketAddress *address ) ;
#line 98
extern guint g_socket_client_get_timeout(GSocketClient *client ) ;
#line 100
extern void g_socket_client_set_timeout(GSocketClient *client , guint timeout ) ;
#line 103
extern gboolean g_socket_client_get_enable_proxy(GSocketClient *client ) ;
#line 105
extern void g_socket_client_set_enable_proxy(GSocketClient *client , gboolean enable ) ;
#line 109
extern gboolean g_socket_client_get_tls(GSocketClient *client ) ;
#line 111
extern void g_socket_client_set_tls(GSocketClient *client , gboolean tls ) ;
#line 114
extern GTlsCertificateFlags g_socket_client_get_tls_validation_flags(GSocketClient *client ) ;
#line 116
extern void g_socket_client_set_tls_validation_flags(GSocketClient *client , GTlsCertificateFlags flags ) ;
#line 119
extern GProxyResolver *g_socket_client_get_proxy_resolver(GSocketClient *client ) ;
#line 121
extern void g_socket_client_set_proxy_resolver(GSocketClient *client , GProxyResolver *proxy_resolver ) ;
#line 125
extern GSocketConnection *g_socket_client_connect(GSocketClient *client , GSocketConnectable *connectable ,
                                                  GCancellable *cancellable , GError **error ) ;
#line 130
extern GSocketConnection *g_socket_client_connect_to_host(GSocketClient *client ,
                                                          gchar *host_and_port , guint16 default_port ,
                                                          GCancellable *cancellable ,
                                                          GError **error ) ;
#line 136
extern GSocketConnection *g_socket_client_connect_to_service(GSocketClient *client ,
                                                             gchar *domain , gchar *service ,
                                                             GCancellable *cancellable ,
                                                             GError **error ) ;
#line 142
extern GSocketConnection *g_socket_client_connect_to_uri(GSocketClient *client , gchar *uri ,
                                                         guint16 default_port , GCancellable *cancellable ,
                                                         GError **error ) ;
#line 148
extern void g_socket_client_connect_async(GSocketClient *client , GSocketConnectable *connectable ,
                                          GCancellable *cancellable , GAsyncReadyCallback callback ,
                                          gpointer user_data ) ;
#line 154
extern GSocketConnection *g_socket_client_connect_finish(GSocketClient *client , GAsyncResult *result ,
                                                         GError **error ) ;
#line 158
extern void g_socket_client_connect_to_host_async(GSocketClient *client , gchar *host_and_port ,
                                                  guint16 default_port , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 165
extern GSocketConnection *g_socket_client_connect_to_host_finish(GSocketClient *client ,
                                                                 GAsyncResult *result ,
                                                                 GError **error ) ;
#line 170
extern void g_socket_client_connect_to_service_async(GSocketClient *client , gchar *domain ,
                                                     gchar *service , GCancellable *cancellable ,
                                                     GAsyncReadyCallback callback ,
                                                     gpointer user_data ) ;
#line 177
extern GSocketConnection *g_socket_client_connect_to_service_finish(GSocketClient *client ,
                                                                    GAsyncResult *result ,
                                                                    GError **error ) ;
#line 181
extern void g_socket_client_connect_to_uri_async(GSocketClient *client , gchar *uri ,
                                                 guint16 default_port , GCancellable *cancellable ,
                                                 GAsyncReadyCallback callback , gpointer user_data ) ;
#line 188
extern GSocketConnection *g_socket_client_connect_to_uri_finish(GSocketClient *client ,
                                                                GAsyncResult *result ,
                                                                GError **error ) ;
#line 192
extern void g_socket_client_add_application_proxy(GSocketClient *client , gchar *protocol ) ;
#line 67 "/usr/include/glib-2.0/gio/gsocketconnectable.h"
extern GType g_socket_connectable_get_type(void) ;
#line 70
extern GSocketAddressEnumerator *g_socket_connectable_enumerate(GSocketConnectable *connectable ) ;
#line 73
extern GSocketAddressEnumerator *g_socket_connectable_proxy_enumerate(GSocketConnectable *connectable ) ;
#line 76
extern gchar *g_socket_connectable_to_string(GSocketConnectable *connectable ) ;
#line 72 "/usr/include/glib-2.0/gio/gsocketconnection.h"
extern GType g_socket_connection_get_type(void) ;
#line 75
extern gboolean g_socket_connection_is_connected(GSocketConnection *connection ) ;
#line 77
extern gboolean g_socket_connection_connect(GSocketConnection *connection , GSocketAddress *address ,
                                            GCancellable *cancellable , GError **error ) ;
#line 82
extern void g_socket_connection_connect_async(GSocketConnection *connection , GSocketAddress *address ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 88
extern gboolean g_socket_connection_connect_finish(GSocketConnection *connection ,
                                                   GAsyncResult *result , GError **error ) ;
#line 93
extern GSocket *g_socket_connection_get_socket(GSocketConnection *connection ) ;
#line 95
extern GSocketAddress *g_socket_connection_get_local_address(GSocketConnection *connection ,
                                                             GError **error ) ;
#line 98
extern GSocketAddress *g_socket_connection_get_remote_address(GSocketConnection *connection ,
                                                              GError **error ) ;
#line 102
extern void g_socket_connection_factory_register_type(GType g_type , GSocketFamily family ,
                                                      GSocketType type , gint protocol ) ;
#line 107
extern GType g_socket_connection_factory_lookup_type(GSocketFamily family , GSocketType type ,
                                                     gint protocol_id ) ;
#line 111
extern GSocketConnection *g_socket_connection_factory_create_connection(GSocket *socket ) ;
#line 92 "/usr/include/glib-2.0/gio/gsocketcontrolmessage.h"
extern GType g_socket_control_message_get_type(void) ;
#line 94
extern gsize g_socket_control_message_get_size(GSocketControlMessage *message ) ;
#line 96
extern int g_socket_control_message_get_level(GSocketControlMessage *message ) ;
#line 98
extern int g_socket_control_message_get_msg_type(GSocketControlMessage *message ) ;
#line 100
extern void g_socket_control_message_serialize(GSocketControlMessage *message , gpointer data ) ;
#line 103
extern GSocketControlMessage *g_socket_control_message_deserialize(int level , int type ,
                                                                   gsize size , gpointer data ) ;
#line 83 "/usr/include/glib-2.0/gio/gsocketlistener.h"
extern GType g_socket_listener_get_type(void) ;
#line 86
extern GSocketListener *g_socket_listener_new(void) ;
#line 89
extern void g_socket_listener_set_backlog(GSocketListener *listener , int listen_backlog ) ;
#line 93
extern gboolean g_socket_listener_add_socket(GSocketListener *listener , GSocket *socket ,
                                             GObject *source_object , GError **error ) ;
#line 98
extern gboolean g_socket_listener_add_address(GSocketListener *listener , GSocketAddress *address ,
                                              GSocketType type , GSocketProtocol protocol ,
                                              GObject *source_object , GSocketAddress **effective_address ,
                                              GError **error ) ;
#line 106
extern gboolean g_socket_listener_add_inet_port(GSocketListener *listener , guint16 port ,
                                                GObject *source_object , GError **error ) ;
#line 111
extern guint16 g_socket_listener_add_any_inet_port(GSocketListener *listener , GObject *source_object ,
                                                   GError **error ) ;
#line 116
extern GSocket *g_socket_listener_accept_socket(GSocketListener *listener , GObject **source_object ,
                                                GCancellable *cancellable , GError **error ) ;
#line 121
extern void g_socket_listener_accept_socket_async(GSocketListener *listener , GCancellable *cancellable ,
                                                  GAsyncReadyCallback callback , gpointer user_data ) ;
#line 126
extern GSocket *g_socket_listener_accept_socket_finish(GSocketListener *listener ,
                                                       GAsyncResult *result , GObject **source_object ,
                                                       GError **error ) ;
#line 133
extern GSocketConnection *g_socket_listener_accept(GSocketListener *listener , GObject **source_object ,
                                                   GCancellable *cancellable , GError **error ) ;
#line 139
extern void g_socket_listener_accept_async(GSocketListener *listener , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 145
extern GSocketConnection *g_socket_listener_accept_finish(GSocketListener *listener ,
                                                          GAsyncResult *result , GObject **source_object ,
                                                          GError **error ) ;
#line 151
extern void g_socket_listener_close(GSocketListener *listener ) ;
#line 79 "/usr/include/glib-2.0/gio/gsocketservice.h"
extern GType g_socket_service_get_type(void) ;
#line 82
extern GSocketService *g_socket_service_new(void) ;
#line 84
extern void g_socket_service_start(GSocketService *service ) ;
#line 86
extern void g_socket_service_stop(GSocketService *service ) ;
#line 88
extern gboolean g_socket_service_is_active(GSocketService *service ) ;
#line 31 "/usr/include/glib-2.0/gio/gsrvtarget.h"
extern GType g_srv_target_get_type(void) ;
#line 35
extern GSrvTarget *g_srv_target_new(gchar *hostname , guint16 port , guint16 priority ,
                                    guint16 weight ) ;
#line 40
extern GSrvTarget *g_srv_target_copy(GSrvTarget *target ) ;
#line 42
extern void g_srv_target_free(GSrvTarget *target ) ;
#line 45
extern gchar *g_srv_target_get_hostname(GSrvTarget *target ) ;
#line 47
extern guint16 g_srv_target_get_port(GSrvTarget *target ) ;
#line 49
extern guint16 g_srv_target_get_priority(GSrvTarget *target ) ;
#line 51
extern guint16 g_srv_target_get_weight(GSrvTarget *target ) ;
#line 54
extern GList *g_srv_target_list_sort(GList *targets ) ;
#line 37 "/usr/include/glib-2.0/gio/gsubprocess.h"
extern GType g_subprocess_get_type(void) ;
#line 42
extern GSubprocess *g_subprocess_new(GSubprocessFlags flags , GError **error , gchar *argv0 
                                     , ...) ;
#line 47
extern GSubprocess *g_subprocess_newv(gchar * const  *argv , GSubprocessFlags flags ,
                                      GError **error ) ;
#line 52
extern GOutputStream *g_subprocess_get_stdin_pipe(GSubprocess *subprocess ) ;
#line 55
extern GInputStream *g_subprocess_get_stdout_pipe(GSubprocess *subprocess ) ;
#line 58
extern GInputStream *g_subprocess_get_stderr_pipe(GSubprocess *subprocess ) ;
#line 61
extern gchar *g_subprocess_get_identifier(GSubprocess *subprocess ) ;
#line 65
extern void g_subprocess_send_signal(GSubprocess *subprocess , gint signal_num ) ;
#line 70
extern void g_subprocess_force_exit(GSubprocess *subprocess ) ;
#line 73
extern gboolean g_subprocess_wait(GSubprocess *subprocess , GCancellable *cancellable ,
                                  GError **error ) ;
#line 78
extern void g_subprocess_wait_async(GSubprocess *subprocess , GCancellable *cancellable ,
                                    GAsyncReadyCallback callback , gpointer user_data ) ;
#line 84
extern gboolean g_subprocess_wait_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                         GError **error ) ;
#line 89
extern gboolean g_subprocess_wait_check(GSubprocess *subprocess , GCancellable *cancellable ,
                                        GError **error ) ;
#line 94
extern void g_subprocess_wait_check_async(GSubprocess *subprocess , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 100
extern gboolean g_subprocess_wait_check_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                               GError **error ) ;
#line 106
extern gint g_subprocess_get_status(GSubprocess *subprocess ) ;
#line 109
extern gboolean g_subprocess_get_successful(GSubprocess *subprocess ) ;
#line 112
extern gboolean g_subprocess_get_if_exited(GSubprocess *subprocess ) ;
#line 115
extern gint g_subprocess_get_exit_status(GSubprocess *subprocess ) ;
#line 118
extern gboolean g_subprocess_get_if_signaled(GSubprocess *subprocess ) ;
#line 121
extern gint g_subprocess_get_term_sig(GSubprocess *subprocess ) ;
#line 124
extern gboolean g_subprocess_communicate(GSubprocess *subprocess , GBytes *stdin_buf ,
                                         GCancellable *cancellable , GBytes **stdout_buf ,
                                         GBytes **stderr_buf , GError **error ) ;
#line 131
extern void g_subprocess_communicate_async(GSubprocess *subprocess , GBytes *stdin_buf ,
                                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                                           gpointer user_data ) ;
#line 138
extern gboolean g_subprocess_communicate_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                                GBytes **stdout_buf , GBytes **stderr_buf ,
                                                GError **error ) ;
#line 145
extern gboolean g_subprocess_communicate_utf8(GSubprocess *subprocess , char const   *stdin_buf ,
                                              GCancellable *cancellable , char **stdout_buf ,
                                              char **stderr_buf , GError **error ) ;
#line 152
extern void g_subprocess_communicate_utf8_async(GSubprocess *subprocess , char const   *stdin_buf ,
                                                GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                gpointer user_data ) ;
#line 159
extern gboolean g_subprocess_communicate_utf8_finish(GSubprocess *subprocess , GAsyncResult *result ,
                                                     char **stdout_buf , char **stderr_buf ,
                                                     GError **error ) ;
#line 39 "/usr/include/glib-2.0/gio/gsubprocesslauncher.h"
extern GType g_subprocess_launcher_get_type(void) ;
#line 42
extern GSubprocessLauncher *g_subprocess_launcher_new(GSubprocessFlags flags ) ;
#line 45
extern GSubprocess *g_subprocess_launcher_spawn(GSubprocessLauncher *self , GError **error ,
                                                gchar *argv0  , ...) ;
#line 51
extern GSubprocess *g_subprocess_launcher_spawnv(GSubprocessLauncher *self , gchar * const  *argv ,
                                                 GError **error ) ;
#line 56
extern void g_subprocess_launcher_set_environ(GSubprocessLauncher *self , gchar **env ) ;
#line 60
extern void g_subprocess_launcher_setenv(GSubprocessLauncher *self , gchar *variable ,
                                         gchar *value , gboolean overwrite ) ;
#line 66
extern void g_subprocess_launcher_unsetenv(GSubprocessLauncher *self , gchar *variable ) ;
#line 70
extern gchar *g_subprocess_launcher_getenv(GSubprocessLauncher *self , gchar *variable ) ;
#line 74
extern void g_subprocess_launcher_set_cwd(GSubprocessLauncher *self , gchar *cwd ) ;
#line 77
extern void g_subprocess_launcher_set_flags(GSubprocessLauncher *self , GSubprocessFlags flags ) ;
#line 83
extern void g_subprocess_launcher_set_stdin_file_path(GSubprocessLauncher *self ,
                                                      gchar *path ) ;
#line 86
extern void g_subprocess_launcher_take_stdin_fd(GSubprocessLauncher *self , gint fd ) ;
#line 89
extern void g_subprocess_launcher_set_stdout_file_path(GSubprocessLauncher *self ,
                                                       gchar *path ) ;
#line 92
extern void g_subprocess_launcher_take_stdout_fd(GSubprocessLauncher *self , gint fd ) ;
#line 95
extern void g_subprocess_launcher_set_stderr_file_path(GSubprocessLauncher *self ,
                                                       gchar *path ) ;
#line 98
extern void g_subprocess_launcher_take_stderr_fd(GSubprocessLauncher *self , gint fd ) ;
#line 102
extern void g_subprocess_launcher_take_fd(GSubprocessLauncher *self , gint source_fd ,
                                          gint target_fd ) ;
#line 107
extern void g_subprocess_launcher_close(GSubprocessLauncher *self ) ;
#line 111
extern void g_subprocess_launcher_set_child_setup(GSubprocessLauncher *self , GSpawnChildSetupFunc child_setup ,
                                                  gpointer user_data , GDestroyNotify destroy_notify ) ;
#line 40 "/usr/include/glib-2.0/gio/gtask.h"
extern GType g_task_get_type(void) ;
#line 43
extern GTask *g_task_new(gpointer source_object , GCancellable *cancellable , GAsyncReadyCallback callback ,
                         gpointer callback_data ) ;
#line 49
extern void g_task_report_error(gpointer source_object , GAsyncReadyCallback callback ,
                                gpointer callback_data , gpointer source_tag , GError *error ) ;
#line 55
extern void g_task_report_new_error(gpointer source_object , GAsyncReadyCallback callback ,
                                    gpointer callback_data , gpointer source_tag ,
                                    GQuark domain , gint code , char const   *format 
                                    , ...) ;
#line 65
extern void g_task_set_task_data(GTask *task , gpointer task_data , GDestroyNotify task_data_destroy ) ;
#line 69
extern void g_task_set_priority(GTask *task , gint priority ) ;
#line 72
extern void g_task_set_check_cancellable(GTask *task , gboolean check_cancellable ) ;
#line 75
extern void g_task_set_source_tag(GTask *task , gpointer source_tag ) ;
#line 78
extern void g_task_set_name(GTask *task , gchar *name ) ;
#line 92
extern gpointer g_task_get_source_object(GTask *task ) ;
#line 94
extern gpointer g_task_get_task_data(GTask *task ) ;
#line 96
extern gint g_task_get_priority(GTask *task ) ;
#line 98
extern GMainContext *g_task_get_context(GTask *task ) ;
#line 100
extern GCancellable *g_task_get_cancellable(GTask *task ) ;
#line 102
extern gboolean g_task_get_check_cancellable(GTask *task ) ;
#line 104
extern gpointer g_task_get_source_tag(GTask *task ) ;
#line 106
extern gchar *g_task_get_name(GTask *task ) ;
#line 109
extern gboolean g_task_is_valid(gpointer result , gpointer source_object ) ;
#line 118
extern void g_task_run_in_thread(GTask *task , GTaskThreadFunc task_func ) ;
#line 121
extern void g_task_run_in_thread_sync(GTask *task , GTaskThreadFunc task_func ) ;
#line 124
extern gboolean g_task_set_return_on_cancel(GTask *task , gboolean return_on_cancel ) ;
#line 127
extern gboolean g_task_get_return_on_cancel(GTask *task ) ;
#line 130
extern void g_task_attach_source(GTask *task , GSource *source , GSourceFunc callback ) ;
#line 136
extern void g_task_return_pointer(GTask *task , gpointer result , GDestroyNotify result_destroy ) ;
#line 140
extern void g_task_return_boolean(GTask *task , gboolean result ) ;
#line 143
extern void g_task_return_int(GTask *task , gssize result ) ;
#line 147
extern void g_task_return_error(GTask *task , GError *error ) ;
#line 150
extern void g_task_return_new_error(GTask *task , GQuark domain , gint code , char const   *format 
                                    , ...) ;
#line 156
extern void g_task_return_value(GTask *task , GValue *result ) ;
#line 160
extern gboolean g_task_return_error_if_cancelled(GTask *task ) ;
#line 163
extern gpointer g_task_propagate_pointer(GTask *task , GError **error ) ;
#line 166
extern gboolean g_task_propagate_boolean(GTask *task , GError **error ) ;
#line 169
extern gssize g_task_propagate_int(GTask *task , GError **error ) ;
#line 172
extern gboolean g_task_propagate_value(GTask *task , GValue *value , GError **error ) ;
#line 176
extern gboolean g_task_had_error(GTask *task ) ;
#line 178
extern gboolean g_task_get_completed(GTask *task ) ;
#line 59 "/usr/include/glib-2.0/gio/gtcpconnection.h"
extern GType g_tcp_connection_get_type(void) ;
#line 62
extern void g_tcp_connection_set_graceful_disconnect(GTcpConnection *connection ,
                                                     gboolean graceful_disconnect ) ;
#line 65
extern gboolean g_tcp_connection_get_graceful_disconnect(GTcpConnection *connection ) ;
#line 59 "/usr/include/glib-2.0/gio/gtcpwrapperconnection.h"
extern GType g_tcp_wrapper_connection_get_type(void) ;
#line 62
extern GSocketConnection *g_tcp_wrapper_connection_new(GIOStream *base_io_stream ,
                                                       GSocket *socket ) ;
#line 65
extern GIOStream *g_tcp_wrapper_connection_get_base_io_stream(GTcpWrapperConnection *conn ) ;
#line 43 "/usr/include/glib-2.0/gio/gtestdbus.h"
extern GType g_test_dbus_get_type(void) ;
#line 46
extern GTestDBus *g_test_dbus_new(GTestDBusFlags flags ) ;
#line 49
extern GTestDBusFlags g_test_dbus_get_flags(GTestDBus *self ) ;
#line 52
extern gchar *g_test_dbus_get_bus_address(GTestDBus *self ) ;
#line 55
extern void g_test_dbus_add_service_dir(GTestDBus *self , gchar *path ) ;
#line 59
extern void g_test_dbus_up(GTestDBus *self ) ;
#line 62
extern void g_test_dbus_stop(GTestDBus *self ) ;
#line 65
extern void g_test_dbus_down(GTestDBus *self ) ;
#line 68
extern void g_test_dbus_unset(void) ;
#line 47 "/usr/include/glib-2.0/gio/gthemedicon.h"
extern GType g_themed_icon_get_type(void) ;
#line 50
extern GIcon *g_themed_icon_new(char const   *iconname ) ;
#line 52
extern GIcon *g_themed_icon_new_with_default_fallbacks(char const   *iconname ) ;
#line 54
extern GIcon *g_themed_icon_new_from_names(char **iconnames , int len ) ;
#line 57
extern void g_themed_icon_prepend_name(GThemedIcon *icon , char const   *iconname ) ;
#line 60
extern void g_themed_icon_append_name(GThemedIcon *icon , char const   *iconname ) ;
#line 64
extern gchar * const  *g_themed_icon_get_names(GThemedIcon *icon ) ;
#line 75 "/usr/include/glib-2.0/gio/gthreadedsocketservice.h"
extern GType g_threaded_socket_service_get_type(void) ;
#line 77
extern GSocketService *g_threaded_socket_service_new(int max_threads ) ;
#line 81 "/usr/include/glib-2.0/gio/gtlsbackend.h"
extern GType g_tls_backend_get_type(void) ;
#line 84
extern GTlsBackend *g_tls_backend_get_default(void) ;
#line 87
extern GTlsDatabase *g_tls_backend_get_default_database(GTlsBackend *backend ) ;
#line 89
extern void g_tls_backend_set_default_database(GTlsBackend *backend , GTlsDatabase *database ) ;
#line 93
extern gboolean g_tls_backend_supports_tls(GTlsBackend *backend ) ;
#line 95
extern gboolean g_tls_backend_supports_dtls(GTlsBackend *backend ) ;
#line 98
extern GType g_tls_backend_get_certificate_type(GTlsBackend *backend ) ;
#line 100
extern GType g_tls_backend_get_client_connection_type(GTlsBackend *backend ) ;
#line 102
extern GType g_tls_backend_get_server_connection_type(GTlsBackend *backend ) ;
#line 104
extern GType g_tls_backend_get_file_database_type(GTlsBackend *backend ) ;
#line 107
extern GType g_tls_backend_get_dtls_client_connection_type(GTlsBackend *backend ) ;
#line 109
extern GType g_tls_backend_get_dtls_server_connection_type(GTlsBackend *backend ) ;
#line 60 "/usr/include/glib-2.0/gio/gtlscertificate.h"
extern GType g_tls_certificate_get_type(void) ;
#line 63
extern GTlsCertificate *g_tls_certificate_new_from_pem(gchar *data , gssize length ,
                                                       GError **error ) ;
#line 67
extern GTlsCertificate *g_tls_certificate_new_from_pkcs12(guint8 *data , gsize length ,
                                                          gchar *password , GError **error ) ;
#line 72
extern GTlsCertificate *g_tls_certificate_new_from_file_with_password(gchar *file ,
                                                                      gchar *password ,
                                                                      GError **error ) ;
#line 76
extern GTlsCertificate *g_tls_certificate_new_from_file(gchar *file , GError **error ) ;
#line 79
extern GTlsCertificate *g_tls_certificate_new_from_files(gchar *cert_file , gchar *key_file ,
                                                         GError **error ) ;
#line 83
extern GTlsCertificate *g_tls_certificate_new_from_pkcs11_uris(gchar *pkcs11_uri ,
                                                               gchar *private_key_pkcs11_uri ,
                                                               GError **error ) ;
#line 88
extern GList *g_tls_certificate_list_new_from_file(gchar *file , GError **error ) ;
#line 92
extern GTlsCertificate *g_tls_certificate_get_issuer(GTlsCertificate *cert ) ;
#line 95
extern GTlsCertificateFlags g_tls_certificate_verify(GTlsCertificate *cert , GSocketConnectable *identity ,
                                                     GTlsCertificate *trusted_ca ) ;
#line 100
extern gboolean g_tls_certificate_is_same(GTlsCertificate *cert_one , GTlsCertificate *cert_two ) ;
#line 104
extern GDateTime *g_tls_certificate_get_not_valid_before(GTlsCertificate *cert ) ;
#line 107
extern GDateTime *g_tls_certificate_get_not_valid_after(GTlsCertificate *cert ) ;
#line 110
extern gchar *g_tls_certificate_get_subject_name(GTlsCertificate *cert ) ;
#line 113
extern gchar *g_tls_certificate_get_issuer_name(GTlsCertificate *cert ) ;
#line 116
extern GPtrArray *g_tls_certificate_get_dns_names(GTlsCertificate *cert ) ;
#line 119
extern GPtrArray *g_tls_certificate_get_ip_addresses(GTlsCertificate *cert ) ;
#line 98 "/usr/include/glib-2.0/gio/gtlsconnection.h"
extern GType g_tls_connection_get_type(void) ;
#line 101
extern void g_tls_connection_set_use_system_certdb(GTlsConnection *conn , gboolean use_system_certdb ) ;
#line 104
extern gboolean g_tls_connection_get_use_system_certdb(GTlsConnection *conn ) ;
#line 107
extern void g_tls_connection_set_database(GTlsConnection *conn , GTlsDatabase *database ) ;
#line 110
extern GTlsDatabase *g_tls_connection_get_database(GTlsConnection *conn ) ;
#line 113
extern void g_tls_connection_set_certificate(GTlsConnection *conn , GTlsCertificate *certificate ) ;
#line 116
extern GTlsCertificate *g_tls_connection_get_certificate(GTlsConnection *conn ) ;
#line 119
extern void g_tls_connection_set_interaction(GTlsConnection *conn , GTlsInteraction *interaction ) ;
#line 122
extern GTlsInteraction *g_tls_connection_get_interaction(GTlsConnection *conn ) ;
#line 125
extern GTlsCertificate *g_tls_connection_get_peer_certificate(GTlsConnection *conn ) ;
#line 127
extern GTlsCertificateFlags g_tls_connection_get_peer_certificate_errors(GTlsConnection *conn ) ;
#line 130
extern void g_tls_connection_set_require_close_notify(GTlsConnection *conn , gboolean require_close_notify ) ;
#line 133
extern gboolean g_tls_connection_get_require_close_notify(GTlsConnection *conn ) ;
#line 137
extern void g_tls_connection_set_rehandshake_mode(GTlsConnection *conn , GTlsRehandshakeMode mode ) ;
#line 140
extern GTlsRehandshakeMode g_tls_connection_get_rehandshake_mode(GTlsConnection *conn ) ;
#line 144
extern void g_tls_connection_set_advertised_protocols(GTlsConnection *conn , gchar * const  *protocols ) ;
#line 148
extern gchar *g_tls_connection_get_negotiated_protocol(GTlsConnection *conn ) ;
#line 152
extern gboolean g_tls_connection_get_channel_binding_data(GTlsConnection *conn , GTlsChannelBindingType type ,
                                                          GByteArray *data , GError **error ) ;
#line 159
extern gboolean g_tls_connection_handshake(GTlsConnection *conn , GCancellable *cancellable ,
                                           GError **error ) ;
#line 164
extern void g_tls_connection_handshake_async(GTlsConnection *conn , int io_priority ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 170
extern gboolean g_tls_connection_handshake_finish(GTlsConnection *conn , GAsyncResult *result ,
                                                  GError **error ) ;
#line 175
extern GTlsProtocolVersion g_tls_connection_get_protocol_version(GTlsConnection *conn ) ;
#line 178
extern gchar *g_tls_connection_get_ciphersuite_name(GTlsConnection *conn ) ;
#line 189
extern GQuark g_tls_error_quark(void) ;
#line 202
extern GQuark g_tls_channel_binding_error_quark(void) ;
#line 206
extern gboolean g_tls_connection_emit_accept_certificate(GTlsConnection *conn , GTlsCertificate *peer_cert ,
                                                         GTlsCertificateFlags errors ) ;
#line 55 "/usr/include/glib-2.0/gio/gtlsclientconnection.h"
extern GType g_tls_client_connection_get_type(void) ;
#line 58
extern GIOStream *g_tls_client_connection_new(GIOStream *base_io_stream , GSocketConnectable *server_identity ,
                                              GError **error ) ;
#line 63
extern GTlsCertificateFlags g_tls_client_connection_get_validation_flags(GTlsClientConnection *conn ) ;
#line 65
extern void g_tls_client_connection_set_validation_flags(GTlsClientConnection *conn ,
                                                         GTlsCertificateFlags flags ) ;
#line 68
extern GSocketConnectable *g_tls_client_connection_get_server_identity(GTlsClientConnection *conn ) ;
#line 70
extern void g_tls_client_connection_set_server_identity(GTlsClientConnection *conn ,
                                                        GSocketConnectable *identity ) ;
#line 73
extern gboolean g_tls_client_connection_get_use_ssl3(GTlsClientConnection *conn ) ;
#line 75
extern void g_tls_client_connection_set_use_ssl3(GTlsClientConnection *conn , gboolean use_ssl3 ) ;
#line 78
extern GList *g_tls_client_connection_get_accepted_cas(GTlsClientConnection *conn ) ;
#line 81
extern void g_tls_client_connection_copy_session_state(GTlsClientConnection *conn ,
                                                       GTlsClientConnection *source ) ;
#line 147 "/usr/include/glib-2.0/gio/gtlsdatabase.h"
extern GType g_tls_database_get_type(void) ;
#line 150
extern GTlsCertificateFlags g_tls_database_verify_chain(GTlsDatabase *self , GTlsCertificate *chain ,
                                                        gchar *purpose , GSocketConnectable *identity ,
                                                        GTlsInteraction *interaction ,
                                                        GTlsDatabaseVerifyFlags flags ,
                                                        GCancellable *cancellable ,
                                                        GError **error ) ;
#line 160
extern void g_tls_database_verify_chain_async(GTlsDatabase *self , GTlsCertificate *chain ,
                                              gchar *purpose , GSocketConnectable *identity ,
                                              GTlsInteraction *interaction , GTlsDatabaseVerifyFlags flags ,
                                              GCancellable *cancellable , GAsyncReadyCallback callback ,
                                              gpointer user_data ) ;
#line 171
extern GTlsCertificateFlags g_tls_database_verify_chain_finish(GTlsDatabase *self ,
                                                               GAsyncResult *result ,
                                                               GError **error ) ;
#line 176
extern gchar *g_tls_database_create_certificate_handle(GTlsDatabase *self , GTlsCertificate *certificate ) ;
#line 180
extern GTlsCertificate *g_tls_database_lookup_certificate_for_handle(GTlsDatabase *self ,
                                                                     gchar *handle ,
                                                                     GTlsInteraction *interaction ,
                                                                     GTlsDatabaseLookupFlags flags ,
                                                                     GCancellable *cancellable ,
                                                                     GError **error ) ;
#line 188
extern void g_tls_database_lookup_certificate_for_handle_async(GTlsDatabase *self ,
                                                               gchar *handle , GTlsInteraction *interaction ,
                                                               GTlsDatabaseLookupFlags flags ,
                                                               GCancellable *cancellable ,
                                                               GAsyncReadyCallback callback ,
                                                               gpointer user_data ) ;
#line 197
extern GTlsCertificate *g_tls_database_lookup_certificate_for_handle_finish(GTlsDatabase *self ,
                                                                            GAsyncResult *result ,
                                                                            GError **error ) ;
#line 202
extern GTlsCertificate *g_tls_database_lookup_certificate_issuer(GTlsDatabase *self ,
                                                                 GTlsCertificate *certificate ,
                                                                 GTlsInteraction *interaction ,
                                                                 GTlsDatabaseLookupFlags flags ,
                                                                 GCancellable *cancellable ,
                                                                 GError **error ) ;
#line 210
extern void g_tls_database_lookup_certificate_issuer_async(GTlsDatabase *self , GTlsCertificate *certificate ,
                                                           GTlsInteraction *interaction ,
                                                           GTlsDatabaseLookupFlags flags ,
                                                           GCancellable *cancellable ,
                                                           GAsyncReadyCallback callback ,
                                                           gpointer user_data ) ;
#line 219
extern GTlsCertificate *g_tls_database_lookup_certificate_issuer_finish(GTlsDatabase *self ,
                                                                        GAsyncResult *result ,
                                                                        GError **error ) ;
#line 224
extern GList *g_tls_database_lookup_certificates_issued_by(GTlsDatabase *self , GByteArray *issuer_raw_dn ,
                                                           GTlsInteraction *interaction ,
                                                           GTlsDatabaseLookupFlags flags ,
                                                           GCancellable *cancellable ,
                                                           GError **error ) ;
#line 232
extern void g_tls_database_lookup_certificates_issued_by_async(GTlsDatabase *self ,
                                                               GByteArray *issuer_raw_dn ,
                                                               GTlsInteraction *interaction ,
                                                               GTlsDatabaseLookupFlags flags ,
                                                               GCancellable *cancellable ,
                                                               GAsyncReadyCallback callback ,
                                                               gpointer user_data ) ;
#line 241
extern GList *g_tls_database_lookup_certificates_issued_by_finish(GTlsDatabase *self ,
                                                                  GAsyncResult *result ,
                                                                  GError **error ) ;
#line 50 "/usr/include/glib-2.0/gio/gtlsfiledatabase.h"
extern GType g_tls_file_database_get_type(void) ;
#line 53
extern GTlsDatabase *g_tls_file_database_new(gchar *anchors , GError **error ) ;
#line 93 "/usr/include/glib-2.0/gio/gtlsinteraction.h"
extern GType g_tls_interaction_get_type(void) ;
#line 96
extern GTlsInteractionResult g_tls_interaction_invoke_ask_password(GTlsInteraction *interaction ,
                                                                   GTlsPassword *password ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 102
extern GTlsInteractionResult g_tls_interaction_ask_password(GTlsInteraction *interaction ,
                                                            GTlsPassword *password ,
                                                            GCancellable *cancellable ,
                                                            GError **error ) ;
#line 108
extern void g_tls_interaction_ask_password_async(GTlsInteraction *interaction , GTlsPassword *password ,
                                                 GCancellable *cancellable , GAsyncReadyCallback callback ,
                                                 gpointer user_data ) ;
#line 115
extern GTlsInteractionResult g_tls_interaction_ask_password_finish(GTlsInteraction *interaction ,
                                                                   GAsyncResult *result ,
                                                                   GError **error ) ;
#line 120
extern GTlsInteractionResult g_tls_interaction_invoke_request_certificate(GTlsInteraction *interaction ,
                                                                          GTlsConnection *connection ,
                                                                          GTlsCertificateRequestFlags flags ,
                                                                          GCancellable *cancellable ,
                                                                          GError **error ) ;
#line 127
extern GTlsInteractionResult g_tls_interaction_request_certificate(GTlsInteraction *interaction ,
                                                                   GTlsConnection *connection ,
                                                                   GTlsCertificateRequestFlags flags ,
                                                                   GCancellable *cancellable ,
                                                                   GError **error ) ;
#line 134
extern void g_tls_interaction_request_certificate_async(GTlsInteraction *interaction ,
                                                        GTlsConnection *connection ,
                                                        GTlsCertificateRequestFlags flags ,
                                                        GCancellable *cancellable ,
                                                        GAsyncReadyCallback callback ,
                                                        gpointer user_data ) ;
#line 142
extern GTlsInteractionResult g_tls_interaction_request_certificate_finish(GTlsInteraction *interaction ,
                                                                          GAsyncResult *result ,
                                                                          GError **error ) ;
#line 80 "/usr/include/glib-2.0/gio/gtlspassword.h"
extern GType g_tls_password_get_type(void) ;
#line 83
extern GTlsPassword *g_tls_password_new(GTlsPasswordFlags flags , gchar *description ) ;
#line 87
extern guchar *g_tls_password_get_value(GTlsPassword *password , gsize *length ) ;
#line 90
extern void g_tls_password_set_value(GTlsPassword *password , guchar *value , gssize length ) ;
#line 94
extern void g_tls_password_set_value_full(GTlsPassword *password , guchar *value ,
                                          gssize length , GDestroyNotify destroy ) ;
#line 100
extern GTlsPasswordFlags g_tls_password_get_flags(GTlsPassword *password ) ;
#line 102
extern void g_tls_password_set_flags(GTlsPassword *password , GTlsPasswordFlags flags ) ;
#line 106
extern gchar *g_tls_password_get_description(GTlsPassword *password ) ;
#line 108
extern void g_tls_password_set_description(GTlsPassword *password , gchar *description ) ;
#line 112
extern gchar *g_tls_password_get_warning(GTlsPassword *password ) ;
#line 114
extern void g_tls_password_set_warning(GTlsPassword *password , gchar *warning ) ;
#line 60 "/usr/include/glib-2.0/gio/gtlsserverconnection.h"
extern GType g_tls_server_connection_get_type(void) ;
#line 63
extern GIOStream *g_tls_server_connection_new(GIOStream *base_io_stream , GTlsCertificate *certificate ,
                                              GError **error ) ;
#line 130 "/usr/include/glib-2.0/gio/gvfs.h"
extern GType g_vfs_get_type(void) ;
#line 133
extern gboolean g_vfs_is_active(GVfs *vfs ) ;
#line 135
extern GFile *g_vfs_get_file_for_path(GVfs *vfs , char const   *path ) ;
#line 138
extern GFile *g_vfs_get_file_for_uri(GVfs *vfs , char const   *uri ) ;
#line 141
extern gchar * const  *g_vfs_get_supported_uri_schemes(GVfs *vfs ) ;
#line 144
extern GFile *g_vfs_parse_name(GVfs *vfs , char const   *parse_name ) ;
#line 148
extern GVfs *g_vfs_get_default(void) ;
#line 150
extern GVfs *g_vfs_get_local(void) ;
#line 153
extern gboolean g_vfs_register_uri_scheme(GVfs *vfs , char const   *scheme , GVfsFileLookupFunc uri_func ,
                                          gpointer uri_data , GDestroyNotify uri_destroy ,
                                          GVfsFileLookupFunc parse_name_func , gpointer parse_name_data ,
                                          GDestroyNotify parse_name_destroy ) ;
#line 162
extern gboolean g_vfs_unregister_uri_scheme(GVfs *vfs , char const   *scheme ) ;
#line 185 "/usr/include/glib-2.0/gio/gvolume.h"
extern GType g_volume_get_type(void) ;
#line 188
extern char *g_volume_get_name(GVolume *volume ) ;
#line 190
extern GIcon *g_volume_get_icon(GVolume *volume ) ;
#line 192
extern GIcon *g_volume_get_symbolic_icon(GVolume *volume ) ;
#line 194
extern char *g_volume_get_uuid(GVolume *volume ) ;
#line 196
extern GDrive *g_volume_get_drive(GVolume *volume ) ;
#line 198
extern GMount *g_volume_get_mount(GVolume *volume ) ;
#line 200
extern gboolean g_volume_can_mount(GVolume *volume ) ;
#line 202
extern gboolean g_volume_can_eject(GVolume *volume ) ;
#line 204
extern gboolean g_volume_should_automount(GVolume *volume ) ;
#line 206
extern void g_volume_mount(GVolume *volume , GMountMountFlags flags , GMountOperation *mount_operation ,
                           GCancellable *cancellable , GAsyncReadyCallback callback ,
                           gpointer user_data ) ;
#line 213
extern gboolean g_volume_mount_finish(GVolume *volume , GAsyncResult *result , GError **error ) ;
#line 217
extern void g_volume_eject(GVolume *volume , GMountUnmountFlags flags , GCancellable *cancellable ,
                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 224
extern gboolean g_volume_eject_finish(GVolume *volume , GAsyncResult *result , GError **error ) ;
#line 228
extern char *g_volume_get_identifier(GVolume *volume , char const   *kind ) ;
#line 231
extern char **g_volume_enumerate_identifiers(GVolume *volume ) ;
#line 234
extern GFile *g_volume_get_activation_root(GVolume *volume ) ;
#line 237
extern void g_volume_eject_with_operation(GVolume *volume , GMountUnmountFlags flags ,
                                          GMountOperation *mount_operation , GCancellable *cancellable ,
                                          GAsyncReadyCallback callback , gpointer user_data ) ;
#line 244
extern gboolean g_volume_eject_with_operation_finish(GVolume *volume , GAsyncResult *result ,
                                                     GError **error ) ;
#line 249
extern gchar *g_volume_get_sort_key(GVolume *volume ) ;
#line 48 "/usr/include/glib-2.0/gio/gzlibcompressor.h"
extern GType g_zlib_compressor_get_type(void) ;
#line 51
extern GZlibCompressor *g_zlib_compressor_new(GZlibCompressorFormat format , int level ) ;
#line 55
extern GFileInfo *g_zlib_compressor_get_file_info(GZlibCompressor *compressor ) ;
#line 57
extern void g_zlib_compressor_set_file_info(GZlibCompressor *compressor , GFileInfo *file_info ) ;
#line 48 "/usr/include/glib-2.0/gio/gzlibdecompressor.h"
extern GType g_zlib_decompressor_get_type(void) ;
#line 51
extern GZlibDecompressor *g_zlib_decompressor_new(GZlibCompressorFormat format ) ;
#line 54
extern GFileInfo *g_zlib_decompressor_get_file_info(GZlibDecompressor *decompressor ) ;
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAction(GAction *_ptr ) 
{ 


  {
#line 24
  if (_ptr) {
    {
#line 24
    g_object_unref((GAction *)_ptr);
    }
  }
  return;
}
}
#line 24 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAction(GAction **_ptr ) 
{ 


  {
  {
#line 24
  glib_autoptr_clear_GAction(*_ptr);
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GActionMap(GActionMap *_ptr ) 
{ 


  {
#line 25
  if (_ptr) {
    {
#line 25
    g_object_unref((GActionMap *)_ptr);
    }
  }
  return;
}
}
#line 25 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GActionMap(GActionMap **_ptr ) 
{ 


  {
  {
#line 25
  glib_autoptr_clear_GActionMap(*_ptr);
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppInfo(GAppInfo *_ptr ) 
{ 


  {
#line 26
  if (_ptr) {
    {
#line 26
    g_object_unref((GAppInfo *)_ptr);
    }
  }
  return;
}
}
#line 26 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppInfo(GAppInfo **_ptr ) 
{ 


  {
  {
#line 26
  glib_autoptr_clear_GAppInfo(*_ptr);
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppLaunchContext(GAppLaunchContext *_ptr ) 
{ 


  {
#line 27
  if (_ptr) {
    {
#line 27
    g_object_unref((GAppLaunchContext *)_ptr);
    }
  }
  return;
}
}
#line 27 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppLaunchContext(GAppLaunchContext **_ptr ) 
{ 


  {
  {
#line 27
  glib_autoptr_clear_GAppLaunchContext(*_ptr);
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAppInfoMonitor(GAppInfoMonitor *_ptr ) 
{ 


  {
#line 28
  if (_ptr) {
    {
#line 28
    g_object_unref((GAppInfoMonitor *)_ptr);
    }
  }
  return;
}
}
#line 28 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAppInfoMonitor(GAppInfoMonitor **_ptr ) 
{ 


  {
  {
#line 28
  glib_autoptr_clear_GAppInfoMonitor(*_ptr);
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GApplicationCommandLine(GApplicationCommandLine *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_object_unref((GApplicationCommandLine *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GApplicationCommandLine(GApplicationCommandLine **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GApplicationCommandLine(*_ptr);
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GApplication(GApplication *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_object_unref((GApplication *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GApplication(GApplication **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GApplication(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncInitable(GAsyncInitable *_ptr ) 
{ 


  {
#line 31
  if (_ptr) {
    {
#line 31
    g_object_unref((GAsyncInitable *)_ptr);
    }
  }
  return;
}
}
#line 31 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncInitable(GAsyncInitable **_ptr ) 
{ 


  {
  {
#line 31
  glib_autoptr_clear_GAsyncInitable(*_ptr);
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GAsyncResult(GAsyncResult *_ptr ) 
{ 


  {
#line 32
  if (_ptr) {
    {
#line 32
    g_object_unref((GAsyncResult *)_ptr);
    }
  }
  return;
}
}
#line 32 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GAsyncResult(GAsyncResult **_ptr ) 
{ 


  {
  {
#line 32
  glib_autoptr_clear_GAsyncResult(*_ptr);
  }
  return;
}
}
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBufferedInputStream(GBufferedInputStream *_ptr ) 
{ 


  {
#line 33
  if (_ptr) {
    {
#line 33
    g_object_unref((GBufferedInputStream *)_ptr);
    }
  }
  return;
}
}
#line 33 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBufferedInputStream(GBufferedInputStream **_ptr ) 
{ 


  {
  {
#line 33
  glib_autoptr_clear_GBufferedInputStream(*_ptr);
  }
  return;
}
}
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBufferedOutputStream(GBufferedOutputStream *_ptr ) 
{ 


  {
#line 34
  if (_ptr) {
    {
#line 34
    g_object_unref((GBufferedOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 34 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBufferedOutputStream(GBufferedOutputStream **_ptr ) 
{ 


  {
  {
#line 34
  glib_autoptr_clear_GBufferedOutputStream(*_ptr);
  }
  return;
}
}
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GBytesIcon(GBytesIcon *_ptr ) 
{ 


  {
#line 35
  if (_ptr) {
    {
#line 35
    g_object_unref((GBytesIcon *)_ptr);
    }
  }
  return;
}
}
#line 35 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GBytesIcon(GBytesIcon **_ptr ) 
{ 


  {
  {
#line 35
  glib_autoptr_clear_GBytesIcon(*_ptr);
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCancellable(GCancellable *_ptr ) 
{ 


  {
#line 36
  if (_ptr) {
    {
#line 36
    g_object_unref((GCancellable *)_ptr);
    }
  }
  return;
}
}
#line 36 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCancellable(GCancellable **_ptr ) 
{ 


  {
  {
#line 36
  glib_autoptr_clear_GCancellable(*_ptr);
  }
  return;
}
}
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCharsetConverter(GCharsetConverter *_ptr ) 
{ 


  {
#line 37
  if (_ptr) {
    {
#line 37
    g_object_unref((GCharsetConverter *)_ptr);
    }
  }
  return;
}
}
#line 37 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCharsetConverter(GCharsetConverter **_ptr ) 
{ 


  {
  {
#line 37
  glib_autoptr_clear_GCharsetConverter(*_ptr);
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverter(GConverter *_ptr ) 
{ 


  {
#line 38
  if (_ptr) {
    {
#line 38
    g_object_unref((GConverter *)_ptr);
    }
  }
  return;
}
}
#line 38 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverter(GConverter **_ptr ) 
{ 


  {
  {
#line 38
  glib_autoptr_clear_GConverter(*_ptr);
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverterInputStream(GConverterInputStream *_ptr ) 
{ 


  {
#line 39
  if (_ptr) {
    {
#line 39
    g_object_unref((GConverterInputStream *)_ptr);
    }
  }
  return;
}
}
#line 39 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverterInputStream(GConverterInputStream **_ptr ) 
{ 


  {
  {
#line 39
  glib_autoptr_clear_GConverterInputStream(*_ptr);
  }
  return;
}
}
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GConverterOutputStream(GConverterOutputStream *_ptr ) 
{ 


  {
#line 40
  if (_ptr) {
    {
#line 40
    g_object_unref((GConverterOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 40 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GConverterOutputStream(GConverterOutputStream **_ptr ) 
{ 


  {
  {
#line 40
  glib_autoptr_clear_GConverterOutputStream(*_ptr);
  }
  return;
}
}
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GCredentials(GCredentials *_ptr ) 
{ 


  {
#line 41
  if (_ptr) {
    {
#line 41
    g_object_unref((GCredentials *)_ptr);
    }
  }
  return;
}
}
#line 41 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GCredentials(GCredentials **_ptr ) 
{ 


  {
  {
#line 41
  glib_autoptr_clear_GCredentials(*_ptr);
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDatagramBased(GDatagramBased *_ptr ) 
{ 


  {
#line 42
  if (_ptr) {
    {
#line 42
    g_object_unref((GDatagramBased *)_ptr);
    }
  }
  return;
}
}
#line 42 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDatagramBased(GDatagramBased **_ptr ) 
{ 


  {
  {
#line 42
  glib_autoptr_clear_GDatagramBased(*_ptr);
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDataInputStream(GDataInputStream *_ptr ) 
{ 


  {
#line 43
  if (_ptr) {
    {
#line 43
    g_object_unref((GDataInputStream *)_ptr);
    }
  }
  return;
}
}
#line 43 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDataInputStream(GDataInputStream **_ptr ) 
{ 


  {
  {
#line 43
  glib_autoptr_clear_GDataInputStream(*_ptr);
  }
  return;
}
}
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDataOutputStream(GDataOutputStream *_ptr ) 
{ 


  {
#line 44
  if (_ptr) {
    {
#line 44
    g_object_unref((GDataOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 44 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDataOutputStream(GDataOutputStream **_ptr ) 
{ 


  {
  {
#line 44
  glib_autoptr_clear_GDataOutputStream(*_ptr);
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusActionGroup(GDBusActionGroup *_ptr ) 
{ 


  {
#line 45
  if (_ptr) {
    {
#line 45
    g_object_unref((GDBusActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 45 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusActionGroup(GDBusActionGroup **_ptr ) 
{ 


  {
  {
#line 45
  glib_autoptr_clear_GDBusActionGroup(*_ptr);
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusAuthObserver(GDBusAuthObserver *_ptr ) 
{ 


  {
#line 46
  if (_ptr) {
    {
#line 46
    g_object_unref((GDBusAuthObserver *)_ptr);
    }
  }
  return;
}
}
#line 46 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusAuthObserver(GDBusAuthObserver **_ptr ) 
{ 


  {
  {
#line 46
  glib_autoptr_clear_GDBusAuthObserver(*_ptr);
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusConnection(GDBusConnection *_ptr ) 
{ 


  {
#line 47
  if (_ptr) {
    {
#line 47
    g_object_unref((GDBusConnection *)_ptr);
    }
  }
  return;
}
}
#line 47 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusConnection(GDBusConnection **_ptr ) 
{ 


  {
  {
#line 47
  glib_autoptr_clear_GDBusConnection(*_ptr);
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusInterface(GDBusInterface *_ptr ) 
{ 


  {
#line 48
  if (_ptr) {
    {
#line 48
    g_object_unref((GDBusInterface *)_ptr);
    }
  }
  return;
}
}
#line 48 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusInterface(GDBusInterface **_ptr ) 
{ 


  {
  {
#line 48
  glib_autoptr_clear_GDBusInterface(*_ptr);
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusInterfaceSkeleton(GDBusInterfaceSkeleton *_ptr ) 
{ 


  {
#line 49
  if (_ptr) {
    {
#line 49
    g_object_unref((GDBusInterfaceSkeleton *)_ptr);
    }
  }
  return;
}
}
#line 49 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusInterfaceSkeleton(GDBusInterfaceSkeleton **_ptr ) 
{ 


  {
  {
#line 49
  glib_autoptr_clear_GDBusInterfaceSkeleton(*_ptr);
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMenuModel(GDBusMenuModel *_ptr ) 
{ 


  {
#line 50
  if (_ptr) {
    {
#line 50
    g_object_unref((GDBusMenuModel *)_ptr);
    }
  }
  return;
}
}
#line 50 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMenuModel(GDBusMenuModel **_ptr ) 
{ 


  {
  {
#line 50
  glib_autoptr_clear_GDBusMenuModel(*_ptr);
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMessage(GDBusMessage *_ptr ) 
{ 


  {
#line 51
  if (_ptr) {
    {
#line 51
    g_object_unref((GDBusMessage *)_ptr);
    }
  }
  return;
}
}
#line 51 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMessage(GDBusMessage **_ptr ) 
{ 


  {
  {
#line 51
  glib_autoptr_clear_GDBusMessage(*_ptr);
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusMethodInvocation(GDBusMethodInvocation *_ptr ) 
{ 


  {
#line 52
  if (_ptr) {
    {
#line 52
    g_object_unref((GDBusMethodInvocation *)_ptr);
    }
  }
  return;
}
}
#line 52 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusMethodInvocation(GDBusMethodInvocation **_ptr ) 
{ 


  {
  {
#line 52
  glib_autoptr_clear_GDBusMethodInvocation(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusNodeInfo(GDBusNodeInfo *_ptr ) 
{ 


  {
#line 53
  if (_ptr) {
    {
#line 53
    g_dbus_node_info_unref((GDBusNodeInfo *)_ptr);
    }
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusNodeInfo(GDBusNodeInfo **_ptr ) 
{ 


  {
  {
#line 53
  glib_autoptr_clear_GDBusNodeInfo(*_ptr);
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GDBusNodeInfo(GList **_l ) 
{ 


  {
  {
#line 53
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GDBusNodeInfo(GSList **_l ) 
{ 


  {
  {
#line 53
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
  }
  return;
}
}
#line 53 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GDBusNodeInfo(GQueue **_q ) 
{ 


  {
#line 53
  if (*_q) {
    {
#line 53
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_dbus_node_info_unref)));
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObject(GDBusObject *_ptr ) 
{ 


  {
#line 54
  if (_ptr) {
    {
#line 54
    g_object_unref((GDBusObject *)_ptr);
    }
  }
  return;
}
}
#line 54 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObject(GDBusObject **_ptr ) 
{ 


  {
  {
#line 54
  glib_autoptr_clear_GDBusObject(*_ptr);
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManagerClient(GDBusObjectManagerClient *_ptr ) 
{ 


  {
#line 55
  if (_ptr) {
    {
#line 55
    g_object_unref((GDBusObjectManagerClient *)_ptr);
    }
  }
  return;
}
}
#line 55 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManagerClient(GDBusObjectManagerClient **_ptr ) 
{ 


  {
  {
#line 55
  glib_autoptr_clear_GDBusObjectManagerClient(*_ptr);
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManager(GDBusObjectManager *_ptr ) 
{ 


  {
#line 56
  if (_ptr) {
    {
#line 56
    g_object_unref((GDBusObjectManager *)_ptr);
    }
  }
  return;
}
}
#line 56 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManager(GDBusObjectManager **_ptr ) 
{ 


  {
  {
#line 56
  glib_autoptr_clear_GDBusObjectManager(*_ptr);
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectManagerServer(GDBusObjectManagerServer *_ptr ) 
{ 


  {
#line 57
  if (_ptr) {
    {
#line 57
    g_object_unref((GDBusObjectManagerServer *)_ptr);
    }
  }
  return;
}
}
#line 57 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectManagerServer(GDBusObjectManagerServer **_ptr ) 
{ 


  {
  {
#line 57
  glib_autoptr_clear_GDBusObjectManagerServer(*_ptr);
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectProxy(GDBusObjectProxy *_ptr ) 
{ 


  {
#line 58
  if (_ptr) {
    {
#line 58
    g_object_unref((GDBusObjectProxy *)_ptr);
    }
  }
  return;
}
}
#line 58 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectProxy(GDBusObjectProxy **_ptr ) 
{ 


  {
  {
#line 58
  glib_autoptr_clear_GDBusObjectProxy(*_ptr);
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusObjectSkeleton(GDBusObjectSkeleton *_ptr ) 
{ 


  {
#line 59
  if (_ptr) {
    {
#line 59
    g_object_unref((GDBusObjectSkeleton *)_ptr);
    }
  }
  return;
}
}
#line 59 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusObjectSkeleton(GDBusObjectSkeleton **_ptr ) 
{ 


  {
  {
#line 59
  glib_autoptr_clear_GDBusObjectSkeleton(*_ptr);
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusProxy(GDBusProxy *_ptr ) 
{ 


  {
#line 60
  if (_ptr) {
    {
#line 60
    g_object_unref((GDBusProxy *)_ptr);
    }
  }
  return;
}
}
#line 60 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusProxy(GDBusProxy **_ptr ) 
{ 


  {
  {
#line 60
  glib_autoptr_clear_GDBusProxy(*_ptr);
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDBusServer(GDBusServer *_ptr ) 
{ 


  {
#line 61
  if (_ptr) {
    {
#line 61
    g_object_unref((GDBusServer *)_ptr);
    }
  }
  return;
}
}
#line 61 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDBusServer(GDBusServer **_ptr ) 
{ 


  {
  {
#line 61
  glib_autoptr_clear_GDBusServer(*_ptr);
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GDrive(GDrive *_ptr ) 
{ 


  {
#line 62
  if (_ptr) {
    {
#line 62
    g_object_unref((GDrive *)_ptr);
    }
  }
  return;
}
}
#line 62 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GDrive(GDrive **_ptr ) 
{ 


  {
  {
#line 62
  glib_autoptr_clear_GDrive(*_ptr);
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GEmblemedIcon(GEmblemedIcon *_ptr ) 
{ 


  {
#line 63
  if (_ptr) {
    {
#line 63
    g_object_unref((GEmblemedIcon *)_ptr);
    }
  }
  return;
}
}
#line 63 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEmblemedIcon(GEmblemedIcon **_ptr ) 
{ 


  {
  {
#line 63
  glib_autoptr_clear_GEmblemedIcon(*_ptr);
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GEmblem(GEmblem *_ptr ) 
{ 


  {
#line 64
  if (_ptr) {
    {
#line 64
    g_object_unref((GEmblem *)_ptr);
    }
  }
  return;
}
}
#line 64 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GEmblem(GEmblem **_ptr ) 
{ 


  {
  {
#line 64
  glib_autoptr_clear_GEmblem(*_ptr);
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileEnumerator(GFileEnumerator *_ptr ) 
{ 


  {
#line 65
  if (_ptr) {
    {
#line 65
    g_object_unref((GFileEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 65 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileEnumerator(GFileEnumerator **_ptr ) 
{ 


  {
  {
#line 65
  glib_autoptr_clear_GFileEnumerator(*_ptr);
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFile(GFile *_ptr ) 
{ 


  {
#line 66
  if (_ptr) {
    {
#line 66
    g_object_unref((GFile *)_ptr);
    }
  }
  return;
}
}
#line 66 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFile(GFile **_ptr ) 
{ 


  {
  {
#line 66
  glib_autoptr_clear_GFile(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileAttributeInfoList(GFileAttributeInfoList *_ptr ) 
{ 


  {
#line 67
  if (_ptr) {
    {
#line 67
    g_file_attribute_info_list_unref((GFileAttributeInfoList *)_ptr);
    }
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileAttributeInfoList(GFileAttributeInfoList **_ptr ) 
{ 


  {
  {
#line 67
  glib_autoptr_clear_GFileAttributeInfoList(*_ptr);
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GFileAttributeInfoList(GList **_l ) 
{ 


  {
  {
#line 67
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GFileAttributeInfoList(GSList **_l ) 
{ 


  {
  {
#line 67
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
  }
  return;
}
}
#line 67 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GFileAttributeInfoList(GQueue **_q ) 
{ 


  {
#line 67
  if (*_q) {
    {
#line 67
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_file_attribute_info_list_unref)));
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileIcon(GFileIcon *_ptr ) 
{ 


  {
#line 68
  if (_ptr) {
    {
#line 68
    g_object_unref((GFileIcon *)_ptr);
    }
  }
  return;
}
}
#line 68 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileIcon(GFileIcon **_ptr ) 
{ 


  {
  {
#line 68
  glib_autoptr_clear_GFileIcon(*_ptr);
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileInfo(GFileInfo *_ptr ) 
{ 


  {
#line 69
  if (_ptr) {
    {
#line 69
    g_object_unref((GFileInfo *)_ptr);
    }
  }
  return;
}
}
#line 69 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileInfo(GFileInfo **_ptr ) 
{ 


  {
  {
#line 69
  glib_autoptr_clear_GFileInfo(*_ptr);
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileInputStream(GFileInputStream *_ptr ) 
{ 


  {
#line 70
  if (_ptr) {
    {
#line 70
    g_object_unref((GFileInputStream *)_ptr);
    }
  }
  return;
}
}
#line 70 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileInputStream(GFileInputStream **_ptr ) 
{ 


  {
  {
#line 70
  glib_autoptr_clear_GFileInputStream(*_ptr);
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileIOStream(GFileIOStream *_ptr ) 
{ 


  {
#line 71
  if (_ptr) {
    {
#line 71
    g_object_unref((GFileIOStream *)_ptr);
    }
  }
  return;
}
}
#line 71 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileIOStream(GFileIOStream **_ptr ) 
{ 


  {
  {
#line 71
  glib_autoptr_clear_GFileIOStream(*_ptr);
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileMonitor(GFileMonitor *_ptr ) 
{ 


  {
#line 72
  if (_ptr) {
    {
#line 72
    g_object_unref((GFileMonitor *)_ptr);
    }
  }
  return;
}
}
#line 72 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileMonitor(GFileMonitor **_ptr ) 
{ 


  {
  {
#line 72
  glib_autoptr_clear_GFileMonitor(*_ptr);
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilenameCompleter(GFilenameCompleter *_ptr ) 
{ 


  {
#line 73
  if (_ptr) {
    {
#line 73
    g_object_unref((GFilenameCompleter *)_ptr);
    }
  }
  return;
}
}
#line 73 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilenameCompleter(GFilenameCompleter **_ptr ) 
{ 


  {
  {
#line 73
  glib_autoptr_clear_GFilenameCompleter(*_ptr);
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFileOutputStream(GFileOutputStream *_ptr ) 
{ 


  {
#line 74
  if (_ptr) {
    {
#line 74
    g_object_unref((GFileOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 74 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFileOutputStream(GFileOutputStream **_ptr ) 
{ 


  {
  {
#line 74
  glib_autoptr_clear_GFileOutputStream(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilterInputStream(GFilterInputStream *_ptr ) 
{ 


  {
#line 75
  if (_ptr) {
    {
#line 75
    g_object_unref((GFilterInputStream *)_ptr);
    }
  }
  return;
}
}
#line 75 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilterInputStream(GFilterInputStream **_ptr ) 
{ 


  {
  {
#line 75
  glib_autoptr_clear_GFilterInputStream(*_ptr);
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GFilterOutputStream(GFilterOutputStream *_ptr ) 
{ 


  {
#line 76
  if (_ptr) {
    {
#line 76
    g_object_unref((GFilterOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 76 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GFilterOutputStream(GFilterOutputStream **_ptr ) 
{ 


  {
  {
#line 76
  glib_autoptr_clear_GFilterOutputStream(*_ptr);
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIcon(GIcon *_ptr ) 
{ 


  {
#line 77
  if (_ptr) {
    {
#line 77
    g_object_unref((GIcon *)_ptr);
    }
  }
  return;
}
}
#line 77 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIcon(GIcon **_ptr ) 
{ 


  {
  {
#line 77
  glib_autoptr_clear_GIcon(*_ptr);
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetAddress(GInetAddress *_ptr ) 
{ 


  {
#line 78
  if (_ptr) {
    {
#line 78
    g_object_unref((GInetAddress *)_ptr);
    }
  }
  return;
}
}
#line 78 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetAddress(GInetAddress **_ptr ) 
{ 


  {
  {
#line 78
  glib_autoptr_clear_GInetAddress(*_ptr);
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetAddressMask(GInetAddressMask *_ptr ) 
{ 


  {
#line 79
  if (_ptr) {
    {
#line 79
    g_object_unref((GInetAddressMask *)_ptr);
    }
  }
  return;
}
}
#line 79 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetAddressMask(GInetAddressMask **_ptr ) 
{ 


  {
  {
#line 79
  glib_autoptr_clear_GInetAddressMask(*_ptr);
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInetSocketAddress(GInetSocketAddress *_ptr ) 
{ 


  {
#line 80
  if (_ptr) {
    {
#line 80
    g_object_unref((GInetSocketAddress *)_ptr);
    }
  }
  return;
}
}
#line 80 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInetSocketAddress(GInetSocketAddress **_ptr ) 
{ 


  {
  {
#line 80
  glib_autoptr_clear_GInetSocketAddress(*_ptr);
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInitable(GInitable *_ptr ) 
{ 


  {
#line 81
  if (_ptr) {
    {
#line 81
    g_object_unref((GInitable *)_ptr);
    }
  }
  return;
}
}
#line 81 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInitable(GInitable **_ptr ) 
{ 


  {
  {
#line 81
  glib_autoptr_clear_GInitable(*_ptr);
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GInputStream(GInputStream *_ptr ) 
{ 


  {
#line 82
  if (_ptr) {
    {
#line 82
    g_object_unref((GInputStream *)_ptr);
    }
  }
  return;
}
}
#line 82 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GInputStream(GInputStream **_ptr ) 
{ 


  {
  {
#line 82
  glib_autoptr_clear_GInputStream(*_ptr);
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIOModule(GIOModule *_ptr ) 
{ 


  {
#line 83
  if (_ptr) {
    {
#line 83
    g_object_unref((GIOModule *)_ptr);
    }
  }
  return;
}
}
#line 83 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOModule(GIOModule **_ptr ) 
{ 


  {
  {
#line 83
  glib_autoptr_clear_GIOModule(*_ptr);
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GIOStream(GIOStream *_ptr ) 
{ 


  {
#line 84
  if (_ptr) {
    {
#line 84
    g_object_unref((GIOStream *)_ptr);
    }
  }
  return;
}
}
#line 84 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GIOStream(GIOStream **_ptr ) 
{ 


  {
  {
#line 84
  glib_autoptr_clear_GIOStream(*_ptr);
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GLoadableIcon(GLoadableIcon *_ptr ) 
{ 


  {
#line 85
  if (_ptr) {
    {
#line 85
    g_object_unref((GLoadableIcon *)_ptr);
    }
  }
  return;
}
}
#line 85 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GLoadableIcon(GLoadableIcon **_ptr ) 
{ 


  {
  {
#line 85
  glib_autoptr_clear_GLoadableIcon(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMemoryInputStream(GMemoryInputStream *_ptr ) 
{ 


  {
#line 86
  if (_ptr) {
    {
#line 86
    g_object_unref((GMemoryInputStream *)_ptr);
    }
  }
  return;
}
}
#line 86 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMemoryInputStream(GMemoryInputStream **_ptr ) 
{ 


  {
  {
#line 86
  glib_autoptr_clear_GMemoryInputStream(*_ptr);
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMemoryOutputStream(GMemoryOutputStream *_ptr ) 
{ 


  {
#line 87
  if (_ptr) {
    {
#line 87
    g_object_unref((GMemoryOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 87 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMemoryOutputStream(GMemoryOutputStream **_ptr ) 
{ 


  {
  {
#line 87
  glib_autoptr_clear_GMemoryOutputStream(*_ptr);
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenu(GMenu *_ptr ) 
{ 


  {
#line 88
  if (_ptr) {
    {
#line 88
    g_object_unref((GMenu *)_ptr);
    }
  }
  return;
}
}
#line 88 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenu(GMenu **_ptr ) 
{ 


  {
  {
#line 88
  glib_autoptr_clear_GMenu(*_ptr);
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuItem(GMenuItem *_ptr ) 
{ 


  {
#line 89
  if (_ptr) {
    {
#line 89
    g_object_unref((GMenuItem *)_ptr);
    }
  }
  return;
}
}
#line 89 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuItem(GMenuItem **_ptr ) 
{ 


  {
  {
#line 89
  glib_autoptr_clear_GMenuItem(*_ptr);
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuModel(GMenuModel *_ptr ) 
{ 


  {
#line 90
  if (_ptr) {
    {
#line 90
    g_object_unref((GMenuModel *)_ptr);
    }
  }
  return;
}
}
#line 90 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuModel(GMenuModel **_ptr ) 
{ 


  {
  {
#line 90
  glib_autoptr_clear_GMenuModel(*_ptr);
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuAttributeIter(GMenuAttributeIter *_ptr ) 
{ 


  {
#line 91
  if (_ptr) {
    {
#line 91
    g_object_unref((GMenuAttributeIter *)_ptr);
    }
  }
  return;
}
}
#line 91 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuAttributeIter(GMenuAttributeIter **_ptr ) 
{ 


  {
  {
#line 91
  glib_autoptr_clear_GMenuAttributeIter(*_ptr);
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMenuLinkIter(GMenuLinkIter *_ptr ) 
{ 


  {
#line 92
  if (_ptr) {
    {
#line 92
    g_object_unref((GMenuLinkIter *)_ptr);
    }
  }
  return;
}
}
#line 92 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMenuLinkIter(GMenuLinkIter **_ptr ) 
{ 


  {
  {
#line 92
  glib_autoptr_clear_GMenuLinkIter(*_ptr);
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMount(GMount *_ptr ) 
{ 


  {
#line 93
  if (_ptr) {
    {
#line 93
    g_object_unref((GMount *)_ptr);
    }
  }
  return;
}
}
#line 93 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMount(GMount **_ptr ) 
{ 


  {
  {
#line 93
  glib_autoptr_clear_GMount(*_ptr);
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GMountOperation(GMountOperation *_ptr ) 
{ 


  {
#line 94
  if (_ptr) {
    {
#line 94
    g_object_unref((GMountOperation *)_ptr);
    }
  }
  return;
}
}
#line 94 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GMountOperation(GMountOperation **_ptr ) 
{ 


  {
  {
#line 94
  glib_autoptr_clear_GMountOperation(*_ptr);
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNativeVolumeMonitor(GNativeVolumeMonitor *_ptr ) 
{ 


  {
#line 95
  if (_ptr) {
    {
#line 95
    g_object_unref((GNativeVolumeMonitor *)_ptr);
    }
  }
  return;
}
}
#line 95 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNativeVolumeMonitor(GNativeVolumeMonitor **_ptr ) 
{ 


  {
  {
#line 95
  glib_autoptr_clear_GNativeVolumeMonitor(*_ptr);
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkAddress(GNetworkAddress *_ptr ) 
{ 


  {
#line 96
  if (_ptr) {
    {
#line 96
    g_object_unref((GNetworkAddress *)_ptr);
    }
  }
  return;
}
}
#line 96 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkAddress(GNetworkAddress **_ptr ) 
{ 


  {
  {
#line 96
  glib_autoptr_clear_GNetworkAddress(*_ptr);
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkMonitor(GNetworkMonitor *_ptr ) 
{ 


  {
#line 97
  if (_ptr) {
    {
#line 97
    g_object_unref((GNetworkMonitor *)_ptr);
    }
  }
  return;
}
}
#line 97 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkMonitor(GNetworkMonitor **_ptr ) 
{ 


  {
  {
#line 97
  glib_autoptr_clear_GNetworkMonitor(*_ptr);
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNetworkService(GNetworkService *_ptr ) 
{ 


  {
#line 98
  if (_ptr) {
    {
#line 98
    g_object_unref((GNetworkService *)_ptr);
    }
  }
  return;
}
}
#line 98 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNetworkService(GNetworkService **_ptr ) 
{ 


  {
  {
#line 98
  glib_autoptr_clear_GNetworkService(*_ptr);
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GNotification(GNotification *_ptr ) 
{ 


  {
#line 99
  if (_ptr) {
    {
#line 99
    g_object_unref((GNotification *)_ptr);
    }
  }
  return;
}
}
#line 99 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GNotification(GNotification **_ptr ) 
{ 


  {
  {
#line 99
  glib_autoptr_clear_GNotification(*_ptr);
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GOutputStream(GOutputStream *_ptr ) 
{ 


  {
#line 100
  if (_ptr) {
    {
#line 100
    g_object_unref((GOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 100 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GOutputStream(GOutputStream **_ptr ) 
{ 


  {
  {
#line 100
  glib_autoptr_clear_GOutputStream(*_ptr);
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPermission(GPermission *_ptr ) 
{ 


  {
#line 101
  if (_ptr) {
    {
#line 101
    g_object_unref((GPermission *)_ptr);
    }
  }
  return;
}
}
#line 101 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPermission(GPermission **_ptr ) 
{ 


  {
  {
#line 101
  glib_autoptr_clear_GPermission(*_ptr);
  }
  return;
}
}
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPollableInputStream(GPollableInputStream *_ptr ) 
{ 


  {
#line 102
  if (_ptr) {
    {
#line 102
    g_object_unref((GPollableInputStream *)_ptr);
    }
  }
  return;
}
}
#line 102 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPollableInputStream(GPollableInputStream **_ptr ) 
{ 


  {
  {
#line 102
  glib_autoptr_clear_GPollableInputStream(*_ptr);
  }
  return;
}
}
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPollableOutputStream(GPollableOutputStream *_ptr ) 
{ 


  {
#line 103
  if (_ptr) {
    {
#line 103
    g_object_unref((GPollableOutputStream *)_ptr);
    }
  }
  return;
}
}
#line 103 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPollableOutputStream(GPollableOutputStream **_ptr ) 
{ 


  {
  {
#line 103
  glib_autoptr_clear_GPollableOutputStream(*_ptr);
  }
  return;
}
}
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GPropertyAction(GPropertyAction *_ptr ) 
{ 


  {
#line 104
  if (_ptr) {
    {
#line 104
    g_object_unref((GPropertyAction *)_ptr);
    }
  }
  return;
}
}
#line 104 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GPropertyAction(GPropertyAction **_ptr ) 
{ 


  {
  {
#line 104
  glib_autoptr_clear_GPropertyAction(*_ptr);
  }
  return;
}
}
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyAddressEnumerator(GProxyAddressEnumerator *_ptr ) 
{ 


  {
#line 105
  if (_ptr) {
    {
#line 105
    g_object_unref((GProxyAddressEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 105 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyAddressEnumerator(GProxyAddressEnumerator **_ptr ) 
{ 


  {
  {
#line 105
  glib_autoptr_clear_GProxyAddressEnumerator(*_ptr);
  }
  return;
}
}
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyAddress(GProxyAddress *_ptr ) 
{ 


  {
#line 106
  if (_ptr) {
    {
#line 106
    g_object_unref((GProxyAddress *)_ptr);
    }
  }
  return;
}
}
#line 106 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyAddress(GProxyAddress **_ptr ) 
{ 


  {
  {
#line 106
  glib_autoptr_clear_GProxyAddress(*_ptr);
  }
  return;
}
}
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxy(GProxy *_ptr ) 
{ 


  {
#line 107
  if (_ptr) {
    {
#line 107
    g_object_unref((GProxy *)_ptr);
    }
  }
  return;
}
}
#line 107 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxy(GProxy **_ptr ) 
{ 


  {
  {
#line 107
  glib_autoptr_clear_GProxy(*_ptr);
  }
  return;
}
}
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GProxyResolver(GProxyResolver *_ptr ) 
{ 


  {
#line 108
  if (_ptr) {
    {
#line 108
    g_object_unref((GProxyResolver *)_ptr);
    }
  }
  return;
}
}
#line 108 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GProxyResolver(GProxyResolver **_ptr ) 
{ 


  {
  {
#line 108
  glib_autoptr_clear_GProxyResolver(*_ptr);
  }
  return;
}
}
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GRemoteActionGroup(GRemoteActionGroup *_ptr ) 
{ 


  {
#line 109
  if (_ptr) {
    {
#line 109
    g_object_unref((GRemoteActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 109 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GRemoteActionGroup(GRemoteActionGroup **_ptr ) 
{ 


  {
  {
#line 109
  glib_autoptr_clear_GRemoteActionGroup(*_ptr);
  }
  return;
}
}
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GResolver(GResolver *_ptr ) 
{ 


  {
#line 110
  if (_ptr) {
    {
#line 110
    g_object_unref((GResolver *)_ptr);
    }
  }
  return;
}
}
#line 110 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GResolver(GResolver **_ptr ) 
{ 


  {
  {
#line 110
  glib_autoptr_clear_GResolver(*_ptr);
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GResource(GResource *_ptr ) 
{ 


  {
#line 111
  if (_ptr) {
    {
#line 111
    g_resource_unref((GResource *)_ptr);
    }
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GResource(GResource **_ptr ) 
{ 


  {
  {
#line 111
  glib_autoptr_clear_GResource(*_ptr);
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GResource(GList **_l ) 
{ 


  {
  {
#line 111
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GResource(GSList **_l ) 
{ 


  {
  {
#line 111
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
  }
  return;
}
}
#line 111 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GResource(GQueue **_q ) 
{ 


  {
#line 111
  if (*_q) {
    {
#line 111
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_resource_unref)));
    }
  }
  return;
}
}
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSeekable(GSeekable *_ptr ) 
{ 


  {
#line 112
  if (_ptr) {
    {
#line 112
    g_object_unref((GSeekable *)_ptr);
    }
  }
  return;
}
}
#line 112 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSeekable(GSeekable **_ptr ) 
{ 


  {
  {
#line 112
  glib_autoptr_clear_GSeekable(*_ptr);
  }
  return;
}
}
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsBackend(GSettingsBackend *_ptr ) 
{ 


  {
#line 113
  if (_ptr) {
    {
#line 113
    g_object_unref((GSettingsBackend *)_ptr);
    }
  }
  return;
}
}
#line 113 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsBackend(GSettingsBackend **_ptr ) 
{ 


  {
  {
#line 113
  glib_autoptr_clear_GSettingsBackend(*_ptr);
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchema(GSettingsSchema *_ptr ) 
{ 


  {
#line 114
  if (_ptr) {
    {
#line 114
    g_settings_schema_unref((GSettingsSchema *)_ptr);
    }
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchema(GSettingsSchema **_ptr ) 
{ 


  {
  {
#line 114
  glib_autoptr_clear_GSettingsSchema(*_ptr);
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchema(GList **_l ) 
{ 


  {
  {
#line 114
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchema(GSList **_l ) 
{ 


  {
  {
#line 114
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
  }
  return;
}
}
#line 114 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchema(GQueue **_q ) 
{ 


  {
#line 114
  if (*_q) {
    {
#line 114
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_unref)));
    }
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchemaKey(GSettingsSchemaKey *_ptr ) 
{ 


  {
#line 115
  if (_ptr) {
    {
#line 115
    g_settings_schema_key_unref((GSettingsSchemaKey *)_ptr);
    }
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchemaKey(GSettingsSchemaKey **_ptr ) 
{ 


  {
  {
#line 115
  glib_autoptr_clear_GSettingsSchemaKey(*_ptr);
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchemaKey(GList **_l ) 
{ 


  {
  {
#line 115
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchemaKey(GSList **_l ) 
{ 


  {
  {
#line 115
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
  }
  return;
}
}
#line 115 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchemaKey(GQueue **_q ) 
{ 


  {
#line 115
  if (*_q) {
    {
#line 115
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_key_unref)));
    }
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettingsSchemaSource(GSettingsSchemaSource *_ptr ) 
{ 


  {
#line 116
  if (_ptr) {
    {
#line 116
    g_settings_schema_source_unref((GSettingsSchemaSource *)_ptr);
    }
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettingsSchemaSource(GSettingsSchemaSource **_ptr ) 
{ 


  {
  {
#line 116
  glib_autoptr_clear_GSettingsSchemaSource(*_ptr);
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_listautoptr_cleanup_GSettingsSchemaSource(GList **_l ) 
{ 


  {
  {
#line 116
  g_list_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_slistautoptr_cleanup_GSettingsSchemaSource(GSList **_l ) 
{ 


  {
  {
#line 116
  g_slist_free_full(*_l, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
  }
  return;
}
}
#line 116 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_queueautoptr_cleanup_GSettingsSchemaSource(GQueue **_q ) 
{ 


  {
#line 116
  if (*_q) {
    {
#line 116
    g_queue_free_full(*_q, (GDestroyNotify )((void (*)(void))(& g_settings_schema_source_unref)));
    }
  }
  return;
}
}
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSettings(GSettings *_ptr ) 
{ 


  {
#line 117
  if (_ptr) {
    {
#line 117
    g_object_unref((GSettings *)_ptr);
    }
  }
  return;
}
}
#line 117 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSettings(GSettings **_ptr ) 
{ 


  {
  {
#line 117
  glib_autoptr_clear_GSettings(*_ptr);
  }
  return;
}
}
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleActionGroup(GSimpleActionGroup *_ptr ) 
{ 


  {
#line 118
  if (_ptr) {
    {
#line 118
    g_object_unref((GSimpleActionGroup *)_ptr);
    }
  }
  return;
}
}
#line 118 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleActionGroup(GSimpleActionGroup **_ptr ) 
{ 


  {
  {
#line 118
  glib_autoptr_clear_GSimpleActionGroup(*_ptr);
  }
  return;
}
}
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleAction(GSimpleAction *_ptr ) 
{ 


  {
#line 119
  if (_ptr) {
    {
#line 119
    g_object_unref((GSimpleAction *)_ptr);
    }
  }
  return;
}
}
#line 119 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleAction(GSimpleAction **_ptr ) 
{ 


  {
  {
#line 119
  glib_autoptr_clear_GSimpleAction(*_ptr);
  }
  return;
}
}
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleAsyncResult(GSimpleAsyncResult *_ptr ) 
{ 


  {
#line 120
  if (_ptr) {
    {
#line 120
    g_object_unref((GSimpleAsyncResult *)_ptr);
    }
  }
  return;
}
}
#line 120 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleAsyncResult(GSimpleAsyncResult **_ptr ) 
{ 


  {
  {
#line 120
  glib_autoptr_clear_GSimpleAsyncResult(*_ptr);
  }
  return;
}
}
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimplePermission(GSimplePermission *_ptr ) 
{ 


  {
#line 121
  if (_ptr) {
    {
#line 121
    g_object_unref((GSimplePermission *)_ptr);
    }
  }
  return;
}
}
#line 121 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimplePermission(GSimplePermission **_ptr ) 
{ 


  {
  {
#line 121
  glib_autoptr_clear_GSimplePermission(*_ptr);
  }
  return;
}
}
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSimpleProxyResolver(GSimpleProxyResolver *_ptr ) 
{ 


  {
#line 122
  if (_ptr) {
    {
#line 122
    g_object_unref((GSimpleProxyResolver *)_ptr);
    }
  }
  return;
}
}
#line 122 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSimpleProxyResolver(GSimpleProxyResolver **_ptr ) 
{ 


  {
  {
#line 122
  glib_autoptr_clear_GSimpleProxyResolver(*_ptr);
  }
  return;
}
}
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketAddressEnumerator(GSocketAddressEnumerator *_ptr ) 
{ 


  {
#line 123
  if (_ptr) {
    {
#line 123
    g_object_unref((GSocketAddressEnumerator *)_ptr);
    }
  }
  return;
}
}
#line 123 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketAddressEnumerator(GSocketAddressEnumerator **_ptr ) 
{ 


  {
  {
#line 123
  glib_autoptr_clear_GSocketAddressEnumerator(*_ptr);
  }
  return;
}
}
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketAddress(GSocketAddress *_ptr ) 
{ 


  {
#line 124
  if (_ptr) {
    {
#line 124
    g_object_unref((GSocketAddress *)_ptr);
    }
  }
  return;
}
}
#line 124 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketAddress(GSocketAddress **_ptr ) 
{ 


  {
  {
#line 124
  glib_autoptr_clear_GSocketAddress(*_ptr);
  }
  return;
}
}
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketClient(GSocketClient *_ptr ) 
{ 


  {
#line 125
  if (_ptr) {
    {
#line 125
    g_object_unref((GSocketClient *)_ptr);
    }
  }
  return;
}
}
#line 125 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketClient(GSocketClient **_ptr ) 
{ 


  {
  {
#line 125
  glib_autoptr_clear_GSocketClient(*_ptr);
  }
  return;
}
}
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketConnectable(GSocketConnectable *_ptr ) 
{ 


  {
#line 126
  if (_ptr) {
    {
#line 126
    g_object_unref((GSocketConnectable *)_ptr);
    }
  }
  return;
}
}
#line 126 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketConnectable(GSocketConnectable **_ptr ) 
{ 


  {
  {
#line 126
  glib_autoptr_clear_GSocketConnectable(*_ptr);
  }
  return;
}
}
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketConnection(GSocketConnection *_ptr ) 
{ 


  {
#line 127
  if (_ptr) {
    {
#line 127
    g_object_unref((GSocketConnection *)_ptr);
    }
  }
  return;
}
}
#line 127 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketConnection(GSocketConnection **_ptr ) 
{ 


  {
  {
#line 127
  glib_autoptr_clear_GSocketConnection(*_ptr);
  }
  return;
}
}
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketControlMessage(GSocketControlMessage *_ptr ) 
{ 


  {
#line 128
  if (_ptr) {
    {
#line 128
    g_object_unref((GSocketControlMessage *)_ptr);
    }
  }
  return;
}
}
#line 128 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketControlMessage(GSocketControlMessage **_ptr ) 
{ 


  {
  {
#line 128
  glib_autoptr_clear_GSocketControlMessage(*_ptr);
  }
  return;
}
}
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocket(GSocket *_ptr ) 
{ 


  {
#line 129
  if (_ptr) {
    {
#line 129
    g_object_unref((GSocket *)_ptr);
    }
  }
  return;
}
}
#line 129 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocket(GSocket **_ptr ) 
{ 


  {
  {
#line 129
  glib_autoptr_clear_GSocket(*_ptr);
  }
  return;
}
}
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketListener(GSocketListener *_ptr ) 
{ 


  {
#line 130
  if (_ptr) {
    {
#line 130
    g_object_unref((GSocketListener *)_ptr);
    }
  }
  return;
}
}
#line 130 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketListener(GSocketListener **_ptr ) 
{ 


  {
  {
#line 130
  glib_autoptr_clear_GSocketListener(*_ptr);
  }
  return;
}
}
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSocketService(GSocketService *_ptr ) 
{ 


  {
#line 131
  if (_ptr) {
    {
#line 131
    g_object_unref((GSocketService *)_ptr);
    }
  }
  return;
}
}
#line 131 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSocketService(GSocketService **_ptr ) 
{ 


  {
  {
#line 131
  glib_autoptr_clear_GSocketService(*_ptr);
  }
  return;
}
}
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSubprocess(GSubprocess *_ptr ) 
{ 


  {
#line 132
  if (_ptr) {
    {
#line 132
    g_object_unref((GSubprocess *)_ptr);
    }
  }
  return;
}
}
#line 132 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSubprocess(GSubprocess **_ptr ) 
{ 


  {
  {
#line 132
  glib_autoptr_clear_GSubprocess(*_ptr);
  }
  return;
}
}
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GSubprocessLauncher(GSubprocessLauncher *_ptr ) 
{ 


  {
#line 133
  if (_ptr) {
    {
#line 133
    g_object_unref((GSubprocessLauncher *)_ptr);
    }
  }
  return;
}
}
#line 133 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GSubprocessLauncher(GSubprocessLauncher **_ptr ) 
{ 


  {
  {
#line 133
  glib_autoptr_clear_GSubprocessLauncher(*_ptr);
  }
  return;
}
}
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTask(GTask *_ptr ) 
{ 


  {
#line 134
  if (_ptr) {
    {
#line 134
    g_object_unref((GTask *)_ptr);
    }
  }
  return;
}
}
#line 134 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTask(GTask **_ptr ) 
{ 


  {
  {
#line 134
  glib_autoptr_clear_GTask(*_ptr);
  }
  return;
}
}
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTcpConnection(GTcpConnection *_ptr ) 
{ 


  {
#line 135
  if (_ptr) {
    {
#line 135
    g_object_unref((GTcpConnection *)_ptr);
    }
  }
  return;
}
}
#line 135 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTcpConnection(GTcpConnection **_ptr ) 
{ 


  {
  {
#line 135
  glib_autoptr_clear_GTcpConnection(*_ptr);
  }
  return;
}
}
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTcpWrapperConnection(GTcpWrapperConnection *_ptr ) 
{ 


  {
#line 136
  if (_ptr) {
    {
#line 136
    g_object_unref((GTcpWrapperConnection *)_ptr);
    }
  }
  return;
}
}
#line 136 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTcpWrapperConnection(GTcpWrapperConnection **_ptr ) 
{ 


  {
  {
#line 136
  glib_autoptr_clear_GTcpWrapperConnection(*_ptr);
  }
  return;
}
}
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTestDBus(GTestDBus *_ptr ) 
{ 


  {
#line 137
  if (_ptr) {
    {
#line 137
    g_object_unref((GTestDBus *)_ptr);
    }
  }
  return;
}
}
#line 137 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTestDBus(GTestDBus **_ptr ) 
{ 


  {
  {
#line 137
  glib_autoptr_clear_GTestDBus(*_ptr);
  }
  return;
}
}
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GThemedIcon(GThemedIcon *_ptr ) 
{ 


  {
#line 138
  if (_ptr) {
    {
#line 138
    g_object_unref((GThemedIcon *)_ptr);
    }
  }
  return;
}
}
#line 138 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThemedIcon(GThemedIcon **_ptr ) 
{ 


  {
  {
#line 138
  glib_autoptr_clear_GThemedIcon(*_ptr);
  }
  return;
}
}
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GThreadedSocketService(GThreadedSocketService *_ptr ) 
{ 


  {
#line 139
  if (_ptr) {
    {
#line 139
    g_object_unref((GThreadedSocketService *)_ptr);
    }
  }
  return;
}
}
#line 139 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GThreadedSocketService(GThreadedSocketService **_ptr ) 
{ 


  {
  {
#line 139
  glib_autoptr_clear_GThreadedSocketService(*_ptr);
  }
  return;
}
}
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsBackend(GTlsBackend *_ptr ) 
{ 


  {
#line 140
  if (_ptr) {
    {
#line 140
    g_object_unref((GTlsBackend *)_ptr);
    }
  }
  return;
}
}
#line 140 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsBackend(GTlsBackend **_ptr ) 
{ 


  {
  {
#line 140
  glib_autoptr_clear_GTlsBackend(*_ptr);
  }
  return;
}
}
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsCertificate(GTlsCertificate *_ptr ) 
{ 


  {
#line 141
  if (_ptr) {
    {
#line 141
    g_object_unref((GTlsCertificate *)_ptr);
    }
  }
  return;
}
}
#line 141 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsCertificate(GTlsCertificate **_ptr ) 
{ 


  {
  {
#line 141
  glib_autoptr_clear_GTlsCertificate(*_ptr);
  }
  return;
}
}
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsClientConnection(GTlsClientConnection *_ptr ) 
{ 


  {
#line 142
  if (_ptr) {
    {
#line 142
    g_object_unref((GTlsClientConnection *)_ptr);
    }
  }
  return;
}
}
#line 142 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsClientConnection(GTlsClientConnection **_ptr ) 
{ 


  {
  {
#line 142
  glib_autoptr_clear_GTlsClientConnection(*_ptr);
  }
  return;
}
}
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsConnection(GTlsConnection *_ptr ) 
{ 


  {
#line 143
  if (_ptr) {
    {
#line 143
    g_object_unref((GTlsConnection *)_ptr);
    }
  }
  return;
}
}
#line 143 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsConnection(GTlsConnection **_ptr ) 
{ 


  {
  {
#line 143
  glib_autoptr_clear_GTlsConnection(*_ptr);
  }
  return;
}
}
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsDatabase(GTlsDatabase *_ptr ) 
{ 


  {
#line 144
  if (_ptr) {
    {
#line 144
    g_object_unref((GTlsDatabase *)_ptr);
    }
  }
  return;
}
}
#line 144 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsDatabase(GTlsDatabase **_ptr ) 
{ 


  {
  {
#line 144
  glib_autoptr_clear_GTlsDatabase(*_ptr);
  }
  return;
}
}
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsFileDatabase(GTlsFileDatabase *_ptr ) 
{ 


  {
#line 145
  if (_ptr) {
    {
#line 145
    g_object_unref((GTlsFileDatabase *)_ptr);
    }
  }
  return;
}
}
#line 145 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsFileDatabase(GTlsFileDatabase **_ptr ) 
{ 


  {
  {
#line 145
  glib_autoptr_clear_GTlsFileDatabase(*_ptr);
  }
  return;
}
}
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsInteraction(GTlsInteraction *_ptr ) 
{ 


  {
#line 146
  if (_ptr) {
    {
#line 146
    g_object_unref((GTlsInteraction *)_ptr);
    }
  }
  return;
}
}
#line 146 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsInteraction(GTlsInteraction **_ptr ) 
{ 


  {
  {
#line 146
  glib_autoptr_clear_GTlsInteraction(*_ptr);
  }
  return;
}
}
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsPassword(GTlsPassword *_ptr ) 
{ 


  {
#line 147
  if (_ptr) {
    {
#line 147
    g_object_unref((GTlsPassword *)_ptr);
    }
  }
  return;
}
}
#line 147 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsPassword(GTlsPassword **_ptr ) 
{ 


  {
  {
#line 147
  glib_autoptr_clear_GTlsPassword(*_ptr);
  }
  return;
}
}
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GTlsServerConnection(GTlsServerConnection *_ptr ) 
{ 


  {
#line 148
  if (_ptr) {
    {
#line 148
    g_object_unref((GTlsServerConnection *)_ptr);
    }
  }
  return;
}
}
#line 148 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GTlsServerConnection(GTlsServerConnection **_ptr ) 
{ 


  {
  {
#line 148
  glib_autoptr_clear_GTlsServerConnection(*_ptr);
  }
  return;
}
}
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVfs(GVfs *_ptr ) 
{ 


  {
#line 149
  if (_ptr) {
    {
#line 149
    g_object_unref((GVfs *)_ptr);
    }
  }
  return;
}
}
#line 149 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVfs(GVfs **_ptr ) 
{ 


  {
  {
#line 149
  glib_autoptr_clear_GVfs(*_ptr);
  }
  return;
}
}
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVolume(GVolume *_ptr ) 
{ 


  {
#line 150
  if (_ptr) {
    {
#line 150
    g_object_unref((GVolume *)_ptr);
    }
  }
  return;
}
}
#line 150 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVolume(GVolume **_ptr ) 
{ 


  {
  {
#line 150
  glib_autoptr_clear_GVolume(*_ptr);
  }
  return;
}
}
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GVolumeMonitor(GVolumeMonitor *_ptr ) 
{ 


  {
#line 151
  if (_ptr) {
    {
#line 151
    g_object_unref((GVolumeMonitor *)_ptr);
    }
  }
  return;
}
}
#line 151 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GVolumeMonitor(GVolumeMonitor **_ptr ) 
{ 


  {
  {
#line 151
  glib_autoptr_clear_GVolumeMonitor(*_ptr);
  }
  return;
}
}
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GZlibCompressor(GZlibCompressor *_ptr ) 
{ 


  {
#line 152
  if (_ptr) {
    {
#line 152
    g_object_unref((GZlibCompressor *)_ptr);
    }
  }
  return;
}
}
#line 152 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GZlibCompressor(GZlibCompressor **_ptr ) 
{ 


  {
  {
#line 152
  glib_autoptr_clear_GZlibCompressor(*_ptr);
  }
  return;
}
}
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_clear_GZlibDecompressor(GZlibDecompressor *_ptr ) 
{ 


  {
#line 153
  if (_ptr) {
    {
#line 153
    g_object_unref((GZlibDecompressor *)_ptr);
    }
  }
  return;
}
}
#line 153 "/usr/include/glib-2.0/gio/gio-autocleanups.h"
__inline static void glib_autoptr_cleanup_GZlibDecompressor(GZlibDecompressor **_ptr ) 
{ 


  {
  {
#line 153
  glib_autoptr_clear_GZlibDecompressor(*_ptr);
  }
  return;
}
}
#line 86 "/usr/include/cairo/cairo.h"
int cairo_version(void) ;
#line 89
char const   *cairo_version_string(void) ;
#line 491
cairo_t *cairo_create(cairo_surface_t *target ) ;
#line 494
cairo_t *cairo_reference(cairo_t *cr ) ;
#line 497
void cairo_destroy(cairo_t *cr ) ;
#line 500
unsigned int cairo_get_reference_count(cairo_t *cr ) ;
#line 503
void *cairo_get_user_data(cairo_t *cr , cairo_user_data_key_t *key ) ;
#line 507
cairo_status_t cairo_set_user_data(cairo_t *cr , cairo_user_data_key_t *key , void *user_data ,
                                   cairo_destroy_func_t destroy ) ;
#line 513
void cairo_save(cairo_t *cr ) ;
#line 516
void cairo_restore(cairo_t *cr ) ;
#line 519
void cairo_push_group(cairo_t *cr ) ;
#line 522
void cairo_push_group_with_content(cairo_t *cr , cairo_content_t content ) ;
#line 525
cairo_pattern_t *cairo_pop_group(cairo_t *cr ) ;
#line 528
void cairo_pop_group_to_source(cairo_t *cr ) ;
#line 650
void cairo_set_operator(cairo_t *cr , cairo_operator_t op ) ;
#line 653
void cairo_set_source(cairo_t *cr , cairo_pattern_t *source ) ;
#line 656
void cairo_set_source_rgb(cairo_t *cr , double red , double green , double blue ) ;
#line 659
void cairo_set_source_rgba(cairo_t *cr , double red , double green , double blue ,
                           double alpha ) ;
#line 664
void cairo_set_source_surface(cairo_t *cr , cairo_surface_t *surface , double x ,
                              double y ) ;
#line 670
void cairo_set_tolerance(cairo_t *cr , double tolerance ) ;
#line 724
void cairo_set_antialias(cairo_t *cr , cairo_antialias_t antialias ) ;
#line 759
void cairo_set_fill_rule(cairo_t *cr , cairo_fill_rule_t fill_rule ) ;
#line 762
void cairo_set_line_width(cairo_t *cr , double width ) ;
#line 783
void cairo_set_line_cap(cairo_t *cr , cairo_line_cap_t line_cap ) ;
#line 807
void cairo_set_line_join(cairo_t *cr , cairo_line_join_t line_join ) ;
#line 810
void cairo_set_dash(cairo_t *cr , double const   *dashes , int num_dashes , double offset ) ;
#line 816
void cairo_set_miter_limit(cairo_t *cr , double limit ) ;
#line 819
void cairo_translate(cairo_t *cr , double tx , double ty ) ;
#line 822
void cairo_scale(cairo_t *cr , double sx , double sy ) ;
#line 825
void cairo_rotate(cairo_t *cr , double angle ) ;
#line 828
void cairo_transform(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 832
void cairo_set_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 836
void cairo_identity_matrix(cairo_t *cr ) ;
#line 839
void cairo_user_to_device(cairo_t *cr , double *x , double *y ) ;
#line 842
void cairo_user_to_device_distance(cairo_t *cr , double *dx , double *dy ) ;
#line 845
void cairo_device_to_user(cairo_t *cr , double *x , double *y ) ;
#line 848
void cairo_device_to_user_distance(cairo_t *cr , double *dx , double *dy ) ;
#line 852
void cairo_new_path(cairo_t *cr ) ;
#line 855
void cairo_move_to(cairo_t *cr , double x , double y ) ;
#line 858
void cairo_new_sub_path(cairo_t *cr ) ;
#line 861
void cairo_line_to(cairo_t *cr , double x , double y ) ;
#line 864
void cairo_curve_to(cairo_t *cr , double x1 , double y1 , double x2 , double y2 ,
                    double x3 , double y3 ) ;
#line 870
void cairo_arc(cairo_t *cr , double xc , double yc , double radius , double angle1 ,
               double angle2 ) ;
#line 876
void cairo_arc_negative(cairo_t *cr , double xc , double yc , double radius , double angle1 ,
                        double angle2 ) ;
#line 890
void cairo_rel_move_to(cairo_t *cr , double dx , double dy ) ;
#line 893
void cairo_rel_line_to(cairo_t *cr , double dx , double dy ) ;
#line 896
void cairo_rel_curve_to(cairo_t *cr , double dx1 , double dy1 , double dx2 , double dy2 ,
                        double dx3 , double dy3 ) ;
#line 902
void cairo_rectangle(cairo_t *cr , double x , double y , double width , double height ) ;
#line 912
void cairo_close_path(cairo_t *cr ) ;
#line 915
void cairo_path_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 921
void cairo_paint(cairo_t *cr ) ;
#line 924
void cairo_paint_with_alpha(cairo_t *cr , double alpha ) ;
#line 928
void cairo_mask(cairo_t *cr , cairo_pattern_t *pattern ) ;
#line 932
void cairo_mask_surface(cairo_t *cr , cairo_surface_t *surface , double surface_x ,
                        double surface_y ) ;
#line 938
void cairo_stroke(cairo_t *cr ) ;
#line 941
void cairo_stroke_preserve(cairo_t *cr ) ;
#line 944
void cairo_fill(cairo_t *cr ) ;
#line 947
void cairo_fill_preserve(cairo_t *cr ) ;
#line 950
void cairo_copy_page(cairo_t *cr ) ;
#line 953
void cairo_show_page(cairo_t *cr ) ;
#line 957
cairo_bool_t cairo_in_stroke(cairo_t *cr , double x , double y ) ;
#line 960
cairo_bool_t cairo_in_fill(cairo_t *cr , double x , double y ) ;
#line 963
cairo_bool_t cairo_in_clip(cairo_t *cr , double x , double y ) ;
#line 967
void cairo_stroke_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 972
void cairo_fill_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 978
void cairo_reset_clip(cairo_t *cr ) ;
#line 981
void cairo_clip(cairo_t *cr ) ;
#line 984
void cairo_clip_preserve(cairo_t *cr ) ;
#line 987
void cairo_clip_extents(cairo_t *cr , double *x1 , double *y1 , double *x2 , double *y2 ) ;
#line 1024
cairo_rectangle_list_t *cairo_copy_clip_rectangle_list(cairo_t *cr ) ;
#line 1027
void cairo_rectangle_list_destroy(cairo_rectangle_list_t *rectangle_list ) ;
#line 1035
void cairo_tag_begin(cairo_t *cr , char const   *tag_name , char const   *attributes ) ;
#line 1038
void cairo_tag_end(cairo_t *cr , char const   *tag_name ) ;
#line 1115
cairo_glyph_t *cairo_glyph_allocate(int num_glyphs ) ;
#line 1118
void cairo_glyph_free(cairo_glyph_t *glyphs ) ;
#line 1146
cairo_text_cluster_t *cairo_text_cluster_allocate(int num_clusters ) ;
#line 1149
void cairo_text_cluster_free(cairo_text_cluster_t *clusters ) ;
#line 1388
cairo_font_options_t *cairo_font_options_create(void) ;
#line 1391
cairo_font_options_t *cairo_font_options_copy(cairo_font_options_t *original ) ;
#line 1394
void cairo_font_options_destroy(cairo_font_options_t *options ) ;
#line 1397
cairo_status_t cairo_font_options_status(cairo_font_options_t *options ) ;
#line 1400
void cairo_font_options_merge(cairo_font_options_t *options , cairo_font_options_t *other ) ;
#line 1403
cairo_bool_t cairo_font_options_equal(cairo_font_options_t *options , cairo_font_options_t *other ) ;
#line 1407
unsigned long cairo_font_options_hash(cairo_font_options_t *options ) ;
#line 1410
void cairo_font_options_set_antialias(cairo_font_options_t *options , cairo_antialias_t antialias ) ;
#line 1413
cairo_antialias_t cairo_font_options_get_antialias(cairo_font_options_t *options ) ;
#line 1416
void cairo_font_options_set_subpixel_order(cairo_font_options_t *options , cairo_subpixel_order_t subpixel_order ) ;
#line 1419
cairo_subpixel_order_t cairo_font_options_get_subpixel_order(cairo_font_options_t *options ) ;
#line 1422
void cairo_font_options_set_hint_style(cairo_font_options_t *options , cairo_hint_style_t hint_style ) ;
#line 1425
cairo_hint_style_t cairo_font_options_get_hint_style(cairo_font_options_t *options ) ;
#line 1428
void cairo_font_options_set_hint_metrics(cairo_font_options_t *options , cairo_hint_metrics_t hint_metrics ) ;
#line 1431
cairo_hint_metrics_t cairo_font_options_get_hint_metrics(cairo_font_options_t *options ) ;
#line 1434
char const   *cairo_font_options_get_variations(cairo_font_options_t *options ) ;
#line 1437
void cairo_font_options_set_variations(cairo_font_options_t *options , char const   *variations ) ;
#line 1444
void cairo_select_font_face(cairo_t *cr , char const   *family , cairo_font_slant_t slant ,
                            cairo_font_weight_t weight ) ;
#line 1450
void cairo_set_font_size(cairo_t *cr , double size ) ;
#line 1453
void cairo_set_font_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1457
void cairo_get_font_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1461
void cairo_set_font_options(cairo_t *cr , cairo_font_options_t *options ) ;
#line 1465
void cairo_get_font_options(cairo_t *cr , cairo_font_options_t *options ) ;
#line 1469
void cairo_set_font_face(cairo_t *cr , cairo_font_face_t *font_face ) ;
#line 1472
cairo_font_face_t *cairo_get_font_face(cairo_t *cr ) ;
#line 1475
void cairo_set_scaled_font(cairo_t *cr , cairo_scaled_font_t *scaled_font ) ;
#line 1479
cairo_scaled_font_t *cairo_get_scaled_font(cairo_t *cr ) ;
#line 1482
void cairo_show_text(cairo_t *cr , char const   *utf8 ) ;
#line 1485
void cairo_show_glyphs(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs ) ;
#line 1488
void cairo_show_text_glyphs(cairo_t *cr , char const   *utf8 , int utf8_len , cairo_glyph_t *glyphs ,
                            int num_glyphs , cairo_text_cluster_t *clusters , int num_clusters ,
                            cairo_text_cluster_flags_t cluster_flags ) ;
#line 1498
void cairo_text_path(cairo_t *cr , char const   *utf8 ) ;
#line 1501
void cairo_glyph_path(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs ) ;
#line 1504
void cairo_text_extents(cairo_t *cr , char const   *utf8 , cairo_text_extents_t *extents ) ;
#line 1509
void cairo_glyph_extents(cairo_t *cr , cairo_glyph_t *glyphs , int num_glyphs , cairo_text_extents_t *extents ) ;
#line 1515
void cairo_font_extents(cairo_t *cr , cairo_font_extents_t *extents ) ;
#line 1521
cairo_font_face_t *cairo_font_face_reference(cairo_font_face_t *font_face ) ;
#line 1524
void cairo_font_face_destroy(cairo_font_face_t *font_face ) ;
#line 1527
unsigned int cairo_font_face_get_reference_count(cairo_font_face_t *font_face ) ;
#line 1530
cairo_status_t cairo_font_face_status(cairo_font_face_t *font_face ) ;
#line 1581
cairo_font_type_t cairo_font_face_get_type(cairo_font_face_t *font_face ) ;
#line 1584
void *cairo_font_face_get_user_data(cairo_font_face_t *font_face , cairo_user_data_key_t *key ) ;
#line 1588
cairo_status_t cairo_font_face_set_user_data(cairo_font_face_t *font_face , cairo_user_data_key_t *key ,
                                             void *user_data , cairo_destroy_func_t destroy ) ;
#line 1596
cairo_scaled_font_t *cairo_scaled_font_create(cairo_font_face_t *font_face , cairo_matrix_t *font_matrix ,
                                              cairo_matrix_t *ctm , cairo_font_options_t *options ) ;
#line 1602
cairo_scaled_font_t *cairo_scaled_font_reference(cairo_scaled_font_t *scaled_font ) ;
#line 1605
void cairo_scaled_font_destroy(cairo_scaled_font_t *scaled_font ) ;
#line 1608
unsigned int cairo_scaled_font_get_reference_count(cairo_scaled_font_t *scaled_font ) ;
#line 1611
cairo_status_t cairo_scaled_font_status(cairo_scaled_font_t *scaled_font ) ;
#line 1614
cairo_font_type_t cairo_scaled_font_get_type(cairo_scaled_font_t *scaled_font ) ;
#line 1617
void *cairo_scaled_font_get_user_data(cairo_scaled_font_t *scaled_font , cairo_user_data_key_t *key ) ;
#line 1621
cairo_status_t cairo_scaled_font_set_user_data(cairo_scaled_font_t *scaled_font ,
                                               cairo_user_data_key_t *key , void *user_data ,
                                               cairo_destroy_func_t destroy ) ;
#line 1627
void cairo_scaled_font_extents(cairo_scaled_font_t *scaled_font , cairo_font_extents_t *extents ) ;
#line 1631
void cairo_scaled_font_text_extents(cairo_scaled_font_t *scaled_font , char const   *utf8 ,
                                    cairo_text_extents_t *extents ) ;
#line 1636
void cairo_scaled_font_glyph_extents(cairo_scaled_font_t *scaled_font , cairo_glyph_t *glyphs ,
                                     int num_glyphs , cairo_text_extents_t *extents ) ;
#line 1642
cairo_status_t cairo_scaled_font_text_to_glyphs(cairo_scaled_font_t *scaled_font ,
                                                double x , double y , char const   *utf8 ,
                                                int utf8_len , cairo_glyph_t **glyphs ,
                                                int *num_glyphs , cairo_text_cluster_t **clusters ,
                                                int *num_clusters , cairo_text_cluster_flags_t *cluster_flags ) ;
#line 1654
cairo_font_face_t *cairo_scaled_font_get_font_face(cairo_scaled_font_t *scaled_font ) ;
#line 1657
void cairo_scaled_font_get_font_matrix(cairo_scaled_font_t *scaled_font , cairo_matrix_t *font_matrix ) ;
#line 1661
void cairo_scaled_font_get_ctm(cairo_scaled_font_t *scaled_font , cairo_matrix_t *ctm ) ;
#line 1665
void cairo_scaled_font_get_scale_matrix(cairo_scaled_font_t *scaled_font , cairo_matrix_t *scale_matrix ) ;
#line 1669
void cairo_scaled_font_get_font_options(cairo_scaled_font_t *scaled_font , cairo_font_options_t *options ) ;
#line 1676
cairo_font_face_t *cairo_toy_font_face_create(char const   *family , cairo_font_slant_t slant ,
                                              cairo_font_weight_t weight ) ;
#line 1681
char const   *cairo_toy_font_face_get_family(cairo_font_face_t *font_face ) ;
#line 1684
cairo_font_slant_t cairo_toy_font_face_get_slant(cairo_font_face_t *font_face ) ;
#line 1687
cairo_font_weight_t cairo_toy_font_face_get_weight(cairo_font_face_t *font_face ) ;
#line 1693
cairo_font_face_t *cairo_user_font_face_create(void) ;
#line 1900
void cairo_user_font_face_set_init_func(cairo_font_face_t *font_face , cairo_user_scaled_font_init_func_t init_func ) ;
#line 1904
void cairo_user_font_face_set_render_glyph_func(cairo_font_face_t *font_face , cairo_user_scaled_font_render_glyph_func_t render_glyph_func ) ;
#line 1908
void cairo_user_font_face_set_text_to_glyphs_func(cairo_font_face_t *font_face , cairo_user_scaled_font_text_to_glyphs_func_t text_to_glyphs_func ) ;
#line 1912
void cairo_user_font_face_set_unicode_to_glyph_func(cairo_font_face_t *font_face ,
                                                    cairo_user_scaled_font_unicode_to_glyph_func_t unicode_to_glyph_func ) ;
#line 1918
cairo_user_scaled_font_init_func_t cairo_user_font_face_get_init_func(cairo_font_face_t *font_face ) ;
#line 1921
cairo_user_scaled_font_render_glyph_func_t cairo_user_font_face_get_render_glyph_func(cairo_font_face_t *font_face ) ;
#line 1924
cairo_user_scaled_font_text_to_glyphs_func_t cairo_user_font_face_get_text_to_glyphs_func(cairo_font_face_t *font_face ) ;
#line 1927
cairo_user_scaled_font_unicode_to_glyph_func_t cairo_user_font_face_get_unicode_to_glyph_func(cairo_font_face_t *font_face ) ;
#line 1933
cairo_operator_t cairo_get_operator(cairo_t *cr ) ;
#line 1936
cairo_pattern_t *cairo_get_source(cairo_t *cr ) ;
#line 1939
double cairo_get_tolerance(cairo_t *cr ) ;
#line 1942
cairo_antialias_t cairo_get_antialias(cairo_t *cr ) ;
#line 1945
cairo_bool_t cairo_has_current_point(cairo_t *cr ) ;
#line 1948
void cairo_get_current_point(cairo_t *cr , double *x , double *y ) ;
#line 1951
cairo_fill_rule_t cairo_get_fill_rule(cairo_t *cr ) ;
#line 1954
double cairo_get_line_width(cairo_t *cr ) ;
#line 1957
cairo_line_cap_t cairo_get_line_cap(cairo_t *cr ) ;
#line 1960
cairo_line_join_t cairo_get_line_join(cairo_t *cr ) ;
#line 1963
double cairo_get_miter_limit(cairo_t *cr ) ;
#line 1966
int cairo_get_dash_count(cairo_t *cr ) ;
#line 1969
void cairo_get_dash(cairo_t *cr , double *dashes , double *offset ) ;
#line 1972
void cairo_get_matrix(cairo_t *cr , cairo_matrix_t *matrix ) ;
#line 1975
cairo_surface_t *cairo_get_target(cairo_t *cr ) ;
#line 1978
cairo_surface_t *cairo_get_group_target(cairo_t *cr ) ;
#line 2107
cairo_path_t *cairo_copy_path(cairo_t *cr ) ;
#line 2110
cairo_path_t *cairo_copy_path_flat(cairo_t *cr ) ;
#line 2113
void cairo_append_path(cairo_t *cr , cairo_path_t *path ) ;
#line 2117
void cairo_path_destroy(cairo_path_t *path ) ;
#line 2122
cairo_status_t cairo_status(cairo_t *cr ) ;
#line 2125
char const   *cairo_status_to_string(cairo_status_t status ) ;
#line 2130
cairo_device_t *cairo_device_reference(cairo_device_t *device ) ;
#line 2177
cairo_device_type_t cairo_device_get_type(cairo_device_t *device ) ;
#line 2180
cairo_status_t cairo_device_status(cairo_device_t *device ) ;
#line 2183
cairo_status_t cairo_device_acquire(cairo_device_t *device ) ;
#line 2186
void cairo_device_release(cairo_device_t *device ) ;
#line 2189
void cairo_device_flush(cairo_device_t *device ) ;
#line 2192
void cairo_device_finish(cairo_device_t *device ) ;
#line 2195
void cairo_device_destroy(cairo_device_t *device ) ;
#line 2198
unsigned int cairo_device_get_reference_count(cairo_device_t *device ) ;
#line 2201
void *cairo_device_get_user_data(cairo_device_t *device , cairo_user_data_key_t *key ) ;
#line 2205
cairo_status_t cairo_device_set_user_data(cairo_device_t *device , cairo_user_data_key_t *key ,
                                          void *user_data , cairo_destroy_func_t destroy ) ;
#line 2214
cairo_surface_t *cairo_surface_create_similar(cairo_surface_t *other , cairo_content_t content ,
                                              int width , int height ) ;
#line 2220
cairo_surface_t *cairo_surface_create_similar_image(cairo_surface_t *other , cairo_format_t format ,
                                                    int width , int height ) ;
#line 2226
cairo_surface_t *cairo_surface_map_to_image(cairo_surface_t *surface , cairo_rectangle_int_t *extents ) ;
#line 2230
void cairo_surface_unmap_image(cairo_surface_t *surface , cairo_surface_t *image ) ;
#line 2234
cairo_surface_t *cairo_surface_create_for_rectangle(cairo_surface_t *target , double x ,
                                                    double y , double width , double height ) ;
#line 2255
cairo_surface_t *cairo_surface_create_observer(cairo_surface_t *target , cairo_surface_observer_mode_t mode ) ;
#line 2263
cairo_status_t cairo_surface_observer_add_paint_callback(cairo_surface_t *abstract_surface ,
                                                         cairo_surface_observer_callback_t func ,
                                                         void *data ) ;
#line 2268
cairo_status_t cairo_surface_observer_add_mask_callback(cairo_surface_t *abstract_surface ,
                                                        cairo_surface_observer_callback_t func ,
                                                        void *data ) ;
#line 2273
cairo_status_t cairo_surface_observer_add_fill_callback(cairo_surface_t *abstract_surface ,
                                                        cairo_surface_observer_callback_t func ,
                                                        void *data ) ;
#line 2278
cairo_status_t cairo_surface_observer_add_stroke_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2283
cairo_status_t cairo_surface_observer_add_glyphs_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2288
cairo_status_t cairo_surface_observer_add_flush_callback(cairo_surface_t *abstract_surface ,
                                                         cairo_surface_observer_callback_t func ,
                                                         void *data ) ;
#line 2293
cairo_status_t cairo_surface_observer_add_finish_callback(cairo_surface_t *abstract_surface ,
                                                          cairo_surface_observer_callback_t func ,
                                                          void *data ) ;
#line 2298
cairo_status_t cairo_surface_observer_print(cairo_surface_t *surface , cairo_write_func_t write_func ,
                                            void *closure ) ;
#line 2302
double cairo_surface_observer_elapsed(cairo_surface_t *surface ) ;
#line 2305
cairo_status_t cairo_device_observer_print(cairo_device_t *device , cairo_write_func_t write_func ,
                                           void *closure ) ;
#line 2310
double cairo_device_observer_elapsed(cairo_device_t *device ) ;
#line 2313
double cairo_device_observer_paint_elapsed(cairo_device_t *device ) ;
#line 2316
double cairo_device_observer_mask_elapsed(cairo_device_t *device ) ;
#line 2319
double cairo_device_observer_fill_elapsed(cairo_device_t *device ) ;
#line 2322
double cairo_device_observer_stroke_elapsed(cairo_device_t *device ) ;
#line 2325
double cairo_device_observer_glyphs_elapsed(cairo_device_t *device ) ;
#line 2328
cairo_surface_t *cairo_surface_reference(cairo_surface_t *surface ) ;
#line 2331
void cairo_surface_finish(cairo_surface_t *surface ) ;
#line 2334
void cairo_surface_destroy(cairo_surface_t *surface ) ;
#line 2337
cairo_device_t *cairo_surface_get_device(cairo_surface_t *surface ) ;
#line 2340
unsigned int cairo_surface_get_reference_count(cairo_surface_t *surface ) ;
#line 2343
cairo_status_t cairo_surface_status(cairo_surface_t *surface ) ;
#line 2426
cairo_surface_type_t cairo_surface_get_type(cairo_surface_t *surface ) ;
#line 2429
cairo_content_t cairo_surface_get_content(cairo_surface_t *surface ) ;
#line 2434
cairo_status_t cairo_surface_write_to_png(cairo_surface_t *surface , char const   *filename ) ;
#line 2438
cairo_status_t cairo_surface_write_to_png_stream(cairo_surface_t *surface , cairo_write_func_t write_func ,
                                                 void *closure ) ;
#line 2445
void *cairo_surface_get_user_data(cairo_surface_t *surface , cairo_user_data_key_t *key ) ;
#line 2449
cairo_status_t cairo_surface_set_user_data(cairo_surface_t *surface , cairo_user_data_key_t *key ,
                                           void *user_data , cairo_destroy_func_t destroy ) ;
#line 2468
void cairo_surface_get_mime_data(cairo_surface_t *surface , char const   *mime_type ,
                                 unsigned char const   **data , unsigned long *length ) ;
#line 2474
cairo_status_t cairo_surface_set_mime_data(cairo_surface_t *surface , char const   *mime_type ,
                                           unsigned char const   *data , unsigned long length ,
                                           cairo_destroy_func_t destroy , void *closure ) ;
#line 2482
cairo_bool_t cairo_surface_supports_mime_type(cairo_surface_t *surface , char const   *mime_type ) ;
#line 2486
void cairo_surface_get_font_options(cairo_surface_t *surface , cairo_font_options_t *options ) ;
#line 2490
void cairo_surface_flush(cairo_surface_t *surface ) ;
#line 2493
void cairo_surface_mark_dirty(cairo_surface_t *surface ) ;
#line 2496
void cairo_surface_mark_dirty_rectangle(cairo_surface_t *surface , int x , int y ,
                                        int width , int height ) ;
#line 2503
void cairo_surface_set_device_scale(cairo_surface_t *surface , double x_scale , double y_scale ) ;
#line 2508
void cairo_surface_get_device_scale(cairo_surface_t *surface , double *x_scale , double *y_scale ) ;
#line 2513
void cairo_surface_set_device_offset(cairo_surface_t *surface , double x_offset ,
                                     double y_offset ) ;
#line 2518
void cairo_surface_get_device_offset(cairo_surface_t *surface , double *x_offset ,
                                     double *y_offset ) ;
#line 2523
void cairo_surface_set_fallback_resolution(cairo_surface_t *surface , double x_pixels_per_inch ,
                                           double y_pixels_per_inch ) ;
#line 2528
void cairo_surface_get_fallback_resolution(cairo_surface_t *surface , double *x_pixels_per_inch ,
                                           double *y_pixels_per_inch ) ;
#line 2533
void cairo_surface_copy_page(cairo_surface_t *surface ) ;
#line 2536
void cairo_surface_show_page(cairo_surface_t *surface ) ;
#line 2539
cairo_bool_t cairo_surface_has_show_text_glyphs(cairo_surface_t *surface ) ;
#line 2544
cairo_surface_t *cairo_image_surface_create(cairo_format_t format , int width , int height ) ;
#line 2549
int cairo_format_stride_for_width(cairo_format_t format , int width ) ;
#line 2553
cairo_surface_t *cairo_image_surface_create_for_data(unsigned char *data , cairo_format_t format ,
                                                     int width , int height , int stride ) ;
#line 2560
unsigned char *cairo_image_surface_get_data(cairo_surface_t *surface ) ;
#line 2563
cairo_format_t cairo_image_surface_get_format(cairo_surface_t *surface ) ;
#line 2566
int cairo_image_surface_get_width(cairo_surface_t *surface ) ;
#line 2569
int cairo_image_surface_get_height(cairo_surface_t *surface ) ;
#line 2572
int cairo_image_surface_get_stride(cairo_surface_t *surface ) ;
#line 2577
cairo_surface_t *cairo_image_surface_create_from_png(char const   *filename ) ;
#line 2580
cairo_surface_t *cairo_image_surface_create_from_png_stream(cairo_read_func_t read_func ,
                                                            void *closure ) ;
#line 2588
cairo_surface_t *cairo_recording_surface_create(cairo_content_t content , cairo_rectangle_t *extents ) ;
#line 2592
void cairo_recording_surface_ink_extents(cairo_surface_t *surface , double *x0 , double *y0 ,
                                         double *width , double *height ) ;
#line 2599
cairo_bool_t cairo_recording_surface_get_extents(cairo_surface_t *surface , cairo_rectangle_t *extents ) ;
#line 2706
cairo_pattern_t *cairo_pattern_create_raster_source(void *user_data , cairo_content_t content ,
                                                    int width , int height ) ;
#line 2711
void cairo_raster_source_pattern_set_callback_data(cairo_pattern_t *pattern , void *data ) ;
#line 2715
void *cairo_raster_source_pattern_get_callback_data(cairo_pattern_t *pattern ) ;
#line 2718
void cairo_raster_source_pattern_set_acquire(cairo_pattern_t *pattern , cairo_raster_source_acquire_func_t acquire ,
                                             cairo_raster_source_release_func_t release ) ;
#line 2723
void cairo_raster_source_pattern_get_acquire(cairo_pattern_t *pattern , cairo_raster_source_acquire_func_t *acquire ,
                                             cairo_raster_source_release_func_t *release ) ;
#line 2727
void cairo_raster_source_pattern_set_snapshot(cairo_pattern_t *pattern , cairo_raster_source_snapshot_func_t snapshot ) ;
#line 2731
cairo_raster_source_snapshot_func_t cairo_raster_source_pattern_get_snapshot(cairo_pattern_t *pattern ) ;
#line 2734
void cairo_raster_source_pattern_set_copy(cairo_pattern_t *pattern , cairo_raster_source_copy_func_t copy ) ;
#line 2738
cairo_raster_source_copy_func_t cairo_raster_source_pattern_get_copy(cairo_pattern_t *pattern ) ;
#line 2741
void cairo_raster_source_pattern_set_finish(cairo_pattern_t *pattern , cairo_raster_source_finish_func_t finish ) ;
#line 2745
cairo_raster_source_finish_func_t cairo_raster_source_pattern_get_finish(cairo_pattern_t *pattern ) ;
#line 2750
cairo_pattern_t *cairo_pattern_create_rgb(double red , double green , double blue ) ;
#line 2753
cairo_pattern_t *cairo_pattern_create_rgba(double red , double green , double blue ,
                                           double alpha ) ;
#line 2757
cairo_pattern_t *cairo_pattern_create_for_surface(cairo_surface_t *surface ) ;
#line 2760
cairo_pattern_t *cairo_pattern_create_linear(double x0 , double y0 , double x1 , double y1 ) ;
#line 2764
cairo_pattern_t *cairo_pattern_create_radial(double cx0 , double cy0 , double radius0 ,
                                             double cx1 , double cy1 , double radius1 ) ;
#line 2768
cairo_pattern_t *cairo_pattern_create_mesh(void) ;
#line 2771
cairo_pattern_t *cairo_pattern_reference(cairo_pattern_t *pattern ) ;
#line 2774
void cairo_pattern_destroy(cairo_pattern_t *pattern ) ;
#line 2777
unsigned int cairo_pattern_get_reference_count(cairo_pattern_t *pattern ) ;
#line 2780
cairo_status_t cairo_pattern_status(cairo_pattern_t *pattern ) ;
#line 2783
void *cairo_pattern_get_user_data(cairo_pattern_t *pattern , cairo_user_data_key_t *key ) ;
#line 2787
cairo_status_t cairo_pattern_set_user_data(cairo_pattern_t *pattern , cairo_user_data_key_t *key ,
                                           void *user_data , cairo_destroy_func_t destroy ) ;
#line 2834
cairo_pattern_type_t cairo_pattern_get_type(cairo_pattern_t *pattern ) ;
#line 2837
void cairo_pattern_add_color_stop_rgb(cairo_pattern_t *pattern , double offset , double red ,
                                      double green , double blue ) ;
#line 2842
void cairo_pattern_add_color_stop_rgba(cairo_pattern_t *pattern , double offset ,
                                       double red , double green , double blue , double alpha ) ;
#line 2848
void cairo_mesh_pattern_begin_patch(cairo_pattern_t *pattern ) ;
#line 2851
void cairo_mesh_pattern_end_patch(cairo_pattern_t *pattern ) ;
#line 2854
void cairo_mesh_pattern_curve_to(cairo_pattern_t *pattern , double x1 , double y1 ,
                                 double x2 , double y2 , double x3 , double y3 ) ;
#line 2860
void cairo_mesh_pattern_line_to(cairo_pattern_t *pattern , double x , double y ) ;
#line 2864
void cairo_mesh_pattern_move_to(cairo_pattern_t *pattern , double x , double y ) ;
#line 2868
void cairo_mesh_pattern_set_control_point(cairo_pattern_t *pattern , unsigned int point_num ,
                                          double x , double y ) ;
#line 2873
void cairo_mesh_pattern_set_corner_color_rgb(cairo_pattern_t *pattern , unsigned int corner_num ,
                                             double red , double green , double blue ) ;
#line 2878
void cairo_mesh_pattern_set_corner_color_rgba(cairo_pattern_t *pattern , unsigned int corner_num ,
                                              double red , double green , double blue ,
                                              double alpha ) ;
#line 2884
void cairo_pattern_set_matrix(cairo_pattern_t *pattern , cairo_matrix_t *matrix ) ;
#line 2888
void cairo_pattern_get_matrix(cairo_pattern_t *pattern , cairo_matrix_t *matrix ) ;
#line 2924
void cairo_pattern_set_extend(cairo_pattern_t *pattern , cairo_extend_t extend ) ;
#line 2927
cairo_extend_t cairo_pattern_get_extend(cairo_pattern_t *pattern ) ;
#line 2959
void cairo_pattern_set_filter(cairo_pattern_t *pattern , cairo_filter_t filter ) ;
#line 2962
cairo_filter_t cairo_pattern_get_filter(cairo_pattern_t *pattern ) ;
#line 2965
cairo_status_t cairo_pattern_get_rgba(cairo_pattern_t *pattern , double *red , double *green ,
                                      double *blue , double *alpha ) ;
#line 2970
cairo_status_t cairo_pattern_get_surface(cairo_pattern_t *pattern , cairo_surface_t **surface ) ;
#line 2975
cairo_status_t cairo_pattern_get_color_stop_rgba(cairo_pattern_t *pattern , int index ,
                                                 double *offset , double *red , double *green ,
                                                 double *blue , double *alpha ) ;
#line 2981
cairo_status_t cairo_pattern_get_color_stop_count(cairo_pattern_t *pattern , int *count ) ;
#line 2985
cairo_status_t cairo_pattern_get_linear_points(cairo_pattern_t *pattern , double *x0 ,
                                               double *y0 , double *x1 , double *y1 ) ;
#line 2990
cairo_status_t cairo_pattern_get_radial_circles(cairo_pattern_t *pattern , double *x0 ,
                                                double *y0 , double *r0 , double *x1 ,
                                                double *y1 , double *r1 ) ;
#line 2995
cairo_status_t cairo_mesh_pattern_get_patch_count(cairo_pattern_t *pattern , unsigned int *count ) ;
#line 2999
cairo_path_t *cairo_mesh_pattern_get_path(cairo_pattern_t *pattern , unsigned int patch_num ) ;
#line 3003
cairo_status_t cairo_mesh_pattern_get_corner_color_rgba(cairo_pattern_t *pattern ,
                                                        unsigned int patch_num , unsigned int corner_num ,
                                                        double *red , double *green ,
                                                        double *blue , double *alpha ) ;
#line 3010
cairo_status_t cairo_mesh_pattern_get_control_point(cairo_pattern_t *pattern , unsigned int patch_num ,
                                                    unsigned int point_num , double *x ,
                                                    double *y ) ;
#line 3018
void cairo_matrix_init(cairo_matrix_t *matrix , double xx , double yx , double xy ,
                       double yy , double x0 , double y0 ) ;
#line 3024
void cairo_matrix_init_identity(cairo_matrix_t *matrix ) ;
#line 3027
void cairo_matrix_init_translate(cairo_matrix_t *matrix , double tx , double ty ) ;
#line 3031
void cairo_matrix_init_scale(cairo_matrix_t *matrix , double sx , double sy ) ;
#line 3035
void cairo_matrix_init_rotate(cairo_matrix_t *matrix , double radians ) ;
#line 3039
void cairo_matrix_translate(cairo_matrix_t *matrix , double tx , double ty ) ;
#line 3042
void cairo_matrix_scale(cairo_matrix_t *matrix , double sx , double sy ) ;
#line 3045
void cairo_matrix_rotate(cairo_matrix_t *matrix , double radians ) ;
#line 3048
cairo_status_t cairo_matrix_invert(cairo_matrix_t *matrix ) ;
#line 3051
void cairo_matrix_multiply(cairo_matrix_t *result , cairo_matrix_t *a , cairo_matrix_t *b ) ;
#line 3056
void cairo_matrix_transform_distance(cairo_matrix_t *matrix , double *dx , double *dy ) ;
#line 3060
void cairo_matrix_transform_point(cairo_matrix_t *matrix , double *x , double *y ) ;
#line 3098
cairo_region_t *cairo_region_create(void) ;
#line 3101
cairo_region_t *cairo_region_create_rectangle(cairo_rectangle_int_t *rectangle ) ;
#line 3104
cairo_region_t *cairo_region_create_rectangles(cairo_rectangle_int_t *rects , int count ) ;
#line 3108
cairo_region_t *cairo_region_copy(cairo_region_t *original ) ;
#line 3111
cairo_region_t *cairo_region_reference(cairo_region_t *region ) ;
#line 3114
void cairo_region_destroy(cairo_region_t *region ) ;
#line 3117
cairo_bool_t cairo_region_equal(cairo_region_t *a , cairo_region_t *b ) ;
#line 3120
cairo_status_t cairo_region_status(cairo_region_t *region ) ;
#line 3123
void cairo_region_get_extents(cairo_region_t *region , cairo_rectangle_int_t *extents ) ;
#line 3127
int cairo_region_num_rectangles(cairo_region_t *region ) ;
#line 3130
void cairo_region_get_rectangle(cairo_region_t *region , int nth , cairo_rectangle_int_t *rectangle ) ;
#line 3135
cairo_bool_t cairo_region_is_empty(cairo_region_t *region ) ;
#line 3138
cairo_region_overlap_t cairo_region_contains_rectangle(cairo_region_t *region , cairo_rectangle_int_t *rectangle ) ;
#line 3142
cairo_bool_t cairo_region_contains_point(cairo_region_t *region , int x , int y ) ;
#line 3145
void cairo_region_translate(cairo_region_t *region , int dx , int dy ) ;
#line 3148
cairo_status_t cairo_region_subtract(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3151
cairo_status_t cairo_region_subtract_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3155
cairo_status_t cairo_region_intersect(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3158
cairo_status_t cairo_region_intersect_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3162
cairo_status_t cairo_region_union(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3165
cairo_status_t cairo_region_union_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3169
cairo_status_t cairo_region_xor(cairo_region_t *dst , cairo_region_t *other ) ;
#line 3172
cairo_status_t cairo_region_xor_rectangle(cairo_region_t *dst , cairo_rectangle_int_t *rectangle ) ;
#line 3177
void cairo_debug_reset_static_data(void) ;
#line 110 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-features.h"
extern guint gdk_pixbuf_major_version ;
#line 111
extern guint gdk_pixbuf_minor_version ;
#line 112
extern guint gdk_pixbuf_micro_version ;
#line 113
extern char const   *gdk_pixbuf_version ;
#line 155 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h"
extern GQuark gdk_pixbuf_error_quark(void) ;
#line 160
extern GType gdk_pixbuf_get_type(void) ;
#line 166
extern GdkPixbuf *gdk_pixbuf_ref(GdkPixbuf *pixbuf ) ;
#line 168
extern void gdk_pixbuf_unref(GdkPixbuf *pixbuf ) ;
#line 174
extern GdkColorspace gdk_pixbuf_get_colorspace(GdkPixbuf *pixbuf ) ;
#line 176
extern int gdk_pixbuf_get_n_channels(GdkPixbuf *pixbuf ) ;
#line 178
extern gboolean gdk_pixbuf_get_has_alpha(GdkPixbuf *pixbuf ) ;
#line 180
extern int gdk_pixbuf_get_bits_per_sample(GdkPixbuf *pixbuf ) ;
#line 182
extern guchar *gdk_pixbuf_get_pixels(GdkPixbuf *pixbuf ) ;
#line 184
extern int gdk_pixbuf_get_width(GdkPixbuf *pixbuf ) ;
#line 186
extern int gdk_pixbuf_get_height(GdkPixbuf *pixbuf ) ;
#line 188
extern int gdk_pixbuf_get_rowstride(GdkPixbuf *pixbuf ) ;
#line 190
extern gsize gdk_pixbuf_get_byte_length(GdkPixbuf *pixbuf ) ;
#line 193
extern guchar *gdk_pixbuf_get_pixels_with_length(GdkPixbuf *pixbuf , guint *length ) ;
#line 197
extern guint8 *gdk_pixbuf_read_pixels(GdkPixbuf *pixbuf ) ;
#line 199
extern GBytes *gdk_pixbuf_read_pixel_bytes(GdkPixbuf *pixbuf ) ;
#line 206
extern GdkPixbuf *gdk_pixbuf_new(GdkColorspace colorspace , gboolean has_alpha , int bits_per_sample ,
                                 int width , int height ) ;
#line 210
extern gint gdk_pixbuf_calculate_rowstride(GdkColorspace colorspace , gboolean has_alpha ,
                                           int bits_per_sample , int width , int height ) ;
#line 218
extern GdkPixbuf *gdk_pixbuf_copy(GdkPixbuf *pixbuf ) ;
#line 222
extern GdkPixbuf *gdk_pixbuf_new_subpixbuf(GdkPixbuf *src_pixbuf , int src_x , int src_y ,
                                           int width , int height ) ;
#line 252
extern GdkPixbuf *gdk_pixbuf_new_from_file(char const   *filename , GError **error ) ;
#line 255
extern GdkPixbuf *gdk_pixbuf_new_from_file_at_size(char const   *filename , int width ,
                                                   int height , GError **error ) ;
#line 260
extern GdkPixbuf *gdk_pixbuf_new_from_file_at_scale(char const   *filename , int width ,
                                                    int height , gboolean preserve_aspect_ratio ,
                                                    GError **error ) ;
#line 266
extern GdkPixbuf *gdk_pixbuf_new_from_resource(char const   *resource_path , GError **error ) ;
#line 269
extern GdkPixbuf *gdk_pixbuf_new_from_resource_at_scale(char const   *resource_path ,
                                                        int width , int height , gboolean preserve_aspect_ratio ,
                                                        GError **error ) ;
#line 276
extern GdkPixbuf *gdk_pixbuf_new_from_data(guchar *data , GdkColorspace colorspace ,
                                           gboolean has_alpha , int bits_per_sample ,
                                           int width , int height , int rowstride ,
                                           GdkPixbufDestroyNotify destroy_fn , gpointer destroy_fn_data ) ;
#line 286
extern GdkPixbuf *gdk_pixbuf_new_from_bytes(GBytes *data , GdkColorspace colorspace ,
                                            gboolean has_alpha , int bits_per_sample ,
                                            int width , int height , int rowstride ) ;
#line 294
extern GdkPixbuf *gdk_pixbuf_new_from_xpm_data(char const   **data ) ;
#line 298
extern GdkPixbuf *gdk_pixbuf_new_from_inline(gint data_length , guint8 *data , gboolean copy_pixels ,
                                             GError **error ) ;
#line 306
extern void gdk_pixbuf_fill(GdkPixbuf *pixbuf , guint32 pixel ) ;
#line 319
extern gboolean gdk_pixbuf_save(GdkPixbuf *pixbuf , char const   *filename , char const   *type ,
                                GError **error  , ...) ;
#line 326
extern gboolean gdk_pixbuf_savev(GdkPixbuf *pixbuf , char const   *filename , char const   *type ,
                                 char **option_keys , char **option_values , GError **error ) ;
#line 373
extern gboolean gdk_pixbuf_save_to_callback(GdkPixbuf *pixbuf , GdkPixbufSaveFunc save_func ,
                                            gpointer user_data , char const   *type ,
                                            GError **error  , ...) ;
#line 381
extern gboolean gdk_pixbuf_save_to_callbackv(GdkPixbuf *pixbuf , GdkPixbufSaveFunc save_func ,
                                             gpointer user_data , char const   *type ,
                                             char **option_keys , char **option_values ,
                                             GError **error ) ;
#line 392
extern gboolean gdk_pixbuf_save_to_buffer(GdkPixbuf *pixbuf , gchar **buffer , gsize *buffer_size ,
                                          char const   *type , GError **error  , ...) ;
#line 400
extern gboolean gdk_pixbuf_save_to_bufferv(GdkPixbuf *pixbuf , gchar **buffer , gsize *buffer_size ,
                                           char const   *type , char **option_keys ,
                                           char **option_values , GError **error ) ;
#line 409
extern GdkPixbuf *gdk_pixbuf_new_from_stream(GInputStream *stream , GCancellable *cancellable ,
                                             GError **error ) ;
#line 414
extern void gdk_pixbuf_new_from_stream_async(GInputStream *stream , GCancellable *cancellable ,
                                             GAsyncReadyCallback callback , gpointer user_data ) ;
#line 420
extern GdkPixbuf *gdk_pixbuf_new_from_stream_finish(GAsyncResult *async_result , GError **error ) ;
#line 424
extern GdkPixbuf *gdk_pixbuf_new_from_stream_at_scale(GInputStream *stream , gint width ,
                                                      gint height , gboolean preserve_aspect_ratio ,
                                                      GCancellable *cancellable ,
                                                      GError **error ) ;
#line 432
extern void gdk_pixbuf_new_from_stream_at_scale_async(GInputStream *stream , gint width ,
                                                      gint height , gboolean preserve_aspect_ratio ,
                                                      GCancellable *cancellable ,
                                                      GAsyncReadyCallback callback ,
                                                      gpointer user_data ) ;
#line 441
extern gboolean gdk_pixbuf_save_to_stream(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                          char const   *type , GCancellable *cancellable ,
                                          GError **error  , ...) ;
#line 449
extern void gdk_pixbuf_save_to_stream_async(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                            gchar *type , GCancellable *cancellable ,
                                            GAsyncReadyCallback callback , gpointer user_data 
                                            , ...) ;
#line 458
extern gboolean gdk_pixbuf_save_to_stream_finish(GAsyncResult *async_result , GError **error ) ;
#line 462
extern void gdk_pixbuf_save_to_streamv_async(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                             gchar *type , gchar **option_keys , gchar **option_values ,
                                             GCancellable *cancellable , GAsyncReadyCallback callback ,
                                             gpointer user_data ) ;
#line 472
extern gboolean gdk_pixbuf_save_to_streamv(GdkPixbuf *pixbuf , GOutputStream *stream ,
                                           char const   *type , char **option_keys ,
                                           char **option_values , GCancellable *cancellable ,
                                           GError **error ) ;
#line 482
extern GdkPixbuf *gdk_pixbuf_add_alpha(GdkPixbuf *pixbuf , gboolean substitute_color ,
                                       guchar r , guchar g , guchar b ) ;
#line 487
extern void gdk_pixbuf_copy_area(GdkPixbuf *src_pixbuf , int src_x , int src_y , int width ,
                                 int height , GdkPixbuf *dest_pixbuf , int dest_x ,
                                 int dest_y ) ;
#line 495
extern void gdk_pixbuf_saturate_and_pixelate(GdkPixbuf *src , GdkPixbuf *dest , gfloat saturation ,
                                             gboolean pixelate ) ;
#line 502
extern GdkPixbuf *gdk_pixbuf_apply_embedded_orientation(GdkPixbuf *src ) ;
#line 506
extern gboolean gdk_pixbuf_set_option(GdkPixbuf *pixbuf , gchar *key , gchar *value ) ;
#line 510
extern gchar *gdk_pixbuf_get_option(GdkPixbuf *pixbuf , gchar *key ) ;
#line 513
extern gboolean gdk_pixbuf_remove_option(GdkPixbuf *pixbuf , gchar *key ) ;
#line 516
extern GHashTable *gdk_pixbuf_get_options(GdkPixbuf *pixbuf ) ;
#line 518
extern gboolean gdk_pixbuf_copy_options(GdkPixbuf *src_pixbuf , GdkPixbuf *dest_pixbuf ) ;
#line 99 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-transform.h"
extern void gdk_pixbuf_scale(GdkPixbuf *src , GdkPixbuf *dest , int dest_x , int dest_y ,
                             int dest_width , int dest_height , double offset_x ,
                             double offset_y , double scale_x , double scale_y , GdkInterpType interp_type ) ;
#line 111
extern void gdk_pixbuf_composite(GdkPixbuf *src , GdkPixbuf *dest , int dest_x , int dest_y ,
                                 int dest_width , int dest_height , double offset_x ,
                                 double offset_y , double scale_x , double scale_y ,
                                 GdkInterpType interp_type , int overall_alpha ) ;
#line 124
extern void gdk_pixbuf_composite_color(GdkPixbuf *src , GdkPixbuf *dest , int dest_x ,
                                       int dest_y , int dest_width , int dest_height ,
                                       double offset_x , double offset_y , double scale_x ,
                                       double scale_y , GdkInterpType interp_type ,
                                       int overall_alpha , int check_x , int check_y ,
                                       int check_size , guint32 color1 , guint32 color2 ) ;
#line 143
extern GdkPixbuf *gdk_pixbuf_scale_simple(GdkPixbuf *src , int dest_width , int dest_height ,
                                          GdkInterpType interp_type ) ;
#line 149
extern GdkPixbuf *gdk_pixbuf_composite_color_simple(GdkPixbuf *src , int dest_width ,
                                                    int dest_height , GdkInterpType interp_type ,
                                                    int overall_alpha , int check_size ,
                                                    guint32 color1 , guint32 color2 ) ;
#line 159
extern GdkPixbuf *gdk_pixbuf_rotate_simple(GdkPixbuf *src , GdkPixbufRotation angle ) ;
#line 162
extern GdkPixbuf *gdk_pixbuf_flip(GdkPixbuf *src , gboolean horizontal ) ;
#line 53 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h"
extern GType gdk_pixbuf_animation_get_type(void) ;
#line 63
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_file(char const   *filename ,
                                                              GError **error ) ;
#line 66
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_stream(GInputStream *stream ,
                                                                GCancellable *cancellable ,
                                                                GError **error ) ;
#line 70
extern void gdk_pixbuf_animation_new_from_stream_async(GInputStream *stream , GCancellable *cancellable ,
                                                       GAsyncReadyCallback callback ,
                                                       gpointer user_data ) ;
#line 75
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_stream_finish(GAsyncResult *async_result ,
                                                                       GError **error ) ;
#line 78
extern GdkPixbufAnimation *gdk_pixbuf_animation_new_from_resource(char const   *resource_path ,
                                                                  GError **error ) ;
#line 84
extern GdkPixbufAnimation *gdk_pixbuf_animation_ref(GdkPixbufAnimation *animation ) ;
#line 86
extern void gdk_pixbuf_animation_unref(GdkPixbufAnimation *animation ) ;
#line 90
extern int gdk_pixbuf_animation_get_width(GdkPixbufAnimation *animation ) ;
#line 92
extern int gdk_pixbuf_animation_get_height(GdkPixbufAnimation *animation ) ;
#line 94
extern gboolean gdk_pixbuf_animation_is_static_image(GdkPixbufAnimation *animation ) ;
#line 96
extern GdkPixbuf *gdk_pixbuf_animation_get_static_image(GdkPixbufAnimation *animation ) ;
#line 100
extern GdkPixbufAnimationIter *gdk_pixbuf_animation_get_iter(GdkPixbufAnimation *animation ,
                                                             GTimeVal *start_time ) ;
#line 105
extern GType gdk_pixbuf_animation_iter_get_type(void) ;
#line 107
extern int gdk_pixbuf_animation_iter_get_delay_time(GdkPixbufAnimationIter *iter ) ;
#line 109
extern GdkPixbuf *gdk_pixbuf_animation_iter_get_pixbuf(GdkPixbufAnimationIter *iter ) ;
#line 111
extern gboolean gdk_pixbuf_animation_iter_on_currently_loading_frame(GdkPixbufAnimationIter *iter ) ;
#line 114
extern gboolean gdk_pixbuf_animation_iter_advance(GdkPixbufAnimationIter *iter , GTimeVal *current_time ) ;
#line 50 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-simple-anim.h"
extern GType gdk_pixbuf_simple_anim_get_type(void) ;
#line 52
extern GType gdk_pixbuf_simple_anim_iter_get_type(void) ;
#line 55
extern GdkPixbufSimpleAnim *gdk_pixbuf_simple_anim_new(gint width , gint height ,
                                                       gfloat rate ) ;
#line 59
extern void gdk_pixbuf_simple_anim_add_frame(GdkPixbufSimpleAnim *animation , GdkPixbuf *pixbuf ) ;
#line 62
extern void gdk_pixbuf_simple_anim_set_loop(GdkPixbufSimpleAnim *animation , gboolean loop ) ;
#line 65
extern gboolean gdk_pixbuf_simple_anim_get_loop(GdkPixbufSimpleAnim *animation ) ;
#line 45 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-io.h"
extern gboolean gdk_pixbuf_init_modules(char const   *path , GError **error ) ;
#line 49
extern GType gdk_pixbuf_format_get_type(void) ;
#line 52
extern GSList *gdk_pixbuf_get_formats(void) ;
#line 54
extern gchar *gdk_pixbuf_format_get_name(GdkPixbufFormat *format ) ;
#line 56
extern gchar *gdk_pixbuf_format_get_description(GdkPixbufFormat *format ) ;
#line 58
extern gchar **gdk_pixbuf_format_get_mime_types(GdkPixbufFormat *format ) ;
#line 60
extern gchar **gdk_pixbuf_format_get_extensions(GdkPixbufFormat *format ) ;
#line 62
extern gboolean gdk_pixbuf_format_is_save_option_supported(GdkPixbufFormat *format ,
                                                           gchar *option_key ) ;
#line 65
extern gboolean gdk_pixbuf_format_is_writable(GdkPixbufFormat *format ) ;
#line 67
extern gboolean gdk_pixbuf_format_is_scalable(GdkPixbufFormat *format ) ;
#line 69
extern gboolean gdk_pixbuf_format_is_disabled(GdkPixbufFormat *format ) ;
#line 71
extern void gdk_pixbuf_format_set_disabled(GdkPixbufFormat *format , gboolean disabled ) ;
#line 74
extern gchar *gdk_pixbuf_format_get_license(GdkPixbufFormat *format ) ;
#line 77
extern GdkPixbufFormat *gdk_pixbuf_get_file_info(gchar *filename , gint *width , gint *height ) ;
#line 81
extern void gdk_pixbuf_get_file_info_async(gchar *filename , GCancellable *cancellable ,
                                           GAsyncReadyCallback callback , gpointer user_data ) ;
#line 86
extern GdkPixbufFormat *gdk_pixbuf_get_file_info_finish(GAsyncResult *async_result ,
                                                        gint *width , gint *height ,
                                                        GError **error ) ;
#line 92
extern GdkPixbufFormat *gdk_pixbuf_format_copy(GdkPixbufFormat *format ) ;
#line 94
extern void gdk_pixbuf_format_free(GdkPixbufFormat *format ) ;
#line 77 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-loader.h"
extern GType gdk_pixbuf_loader_get_type(void) ;
#line 79
extern GdkPixbufLoader *gdk_pixbuf_loader_new(void) ;
#line 81
extern GdkPixbufLoader *gdk_pixbuf_loader_new_with_type(char const   *image_type ,
                                                        GError **error ) ;
#line 84
extern GdkPixbufLoader *gdk_pixbuf_loader_new_with_mime_type(char const   *mime_type ,
                                                             GError **error ) ;
#line 87
extern void gdk_pixbuf_loader_set_size(GdkPixbufLoader *loader , int width , int height ) ;
#line 91
extern gboolean gdk_pixbuf_loader_write(GdkPixbufLoader *loader , guchar *buf , gsize count ,
                                        GError **error ) ;
#line 96
extern gboolean gdk_pixbuf_loader_write_bytes(GdkPixbufLoader *loader , GBytes *buffer ,
                                              GError **error ) ;
#line 100
extern GdkPixbuf *gdk_pixbuf_loader_get_pixbuf(GdkPixbufLoader *loader ) ;
#line 102
extern GdkPixbufAnimation *gdk_pixbuf_loader_get_animation(GdkPixbufLoader *loader ) ;
#line 104
extern gboolean gdk_pixbuf_loader_close(GdkPixbufLoader *loader , GError **error ) ;
#line 107
extern GdkPixbufFormat *gdk_pixbuf_loader_get_format(GdkPixbufLoader *loader ) ;
#line 19 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h"
extern GType gdk_pixbuf_alpha_mode_get_type(void) ;
#line 22
extern GType gdk_colorspace_get_type(void) ;
#line 25
extern GType gdk_pixbuf_error_get_type(void) ;
#line 30
extern GType gdk_interp_type_get_type(void) ;
#line 33
extern GType gdk_pixbuf_rotation_get_type(void) ;
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbuf(GdkPixbuf *_ptr ) 
{ 


  {
#line 29
  if (_ptr) {
    {
#line 29
    g_object_unref((GdkPixbuf *)_ptr);
    }
  }
  return;
}
}
#line 29 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbuf(GdkPixbuf **_ptr ) 
{ 


  {
  {
#line 29
  glib_autoptr_clear_GdkPixbuf(*_ptr);
  }
  return;
}
}
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufAnimation(GdkPixbufAnimation *_ptr ) 
{ 


  {
#line 30
  if (_ptr) {
    {
#line 30
    g_object_unref((GdkPixbufAnimation *)_ptr);
    }
  }
  return;
}
}
#line 30 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufAnimation(GdkPixbufAnimation **_ptr ) 
{ 


  {
  {
#line 30
  glib_autoptr_clear_GdkPixbufAnimation(*_ptr);
  }
  return;
}
}
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufAnimationIter(GdkPixbufAnimationIter *_ptr ) 
{ 


  {
#line 31
  if (_ptr) {
    {
#line 31
    g_object_unref((GdkPixbufAnimationIter *)_ptr);
    }
  }
  return;
}
}
#line 31 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufAnimationIter(GdkPixbufAnimationIter **_ptr ) 
{ 


  {
  {
#line 31
  glib_autoptr_clear_GdkPixbufAnimationIter(*_ptr);
  }
  return;
}
}
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufLoader(GdkPixbufLoader *_ptr ) 
{ 


  {
#line 32
  if (_ptr) {
    {
#line 32
    g_object_unref((GdkPixbufLoader *)_ptr);
    }
  }
  return;
}
}
#line 32 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufLoader(GdkPixbufLoader **_ptr ) 
{ 


  {
  {
#line 32
  glib_autoptr_clear_GdkPixbufLoader(*_ptr);
  }
  return;
}
}
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_clear_GdkPixbufSimpleAnim(GdkPixbufSimpleAnim *_ptr ) 
{ 


  {
#line 33
  if (_ptr) {
    {
#line 33
    g_object_unref((GdkPixbufSimpleAnim *)_ptr);
    }
  }
  return;
}
}
#line 33 "/usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-autocleanups.h"
__inline static void glib_autoptr_cleanup_GdkPixbufSimpleAnim(GdkPixbufSimpleAnim **_ptr ) 
{ 


  {
  {
#line 33
  glib_autoptr_clear_GdkPixbufSimpleAnim(*_ptr);
  }
  return;
}
}
#line 75 "/usr/include/librsvg-2.0/librsvg/rsvg.h"
GQuark rsvg_error_quark(void) ;
#line 78
GType rsvg_error_get_type(void) ;
#line 379
GType rsvg_handle_get_type(void) ;
#line 474
void rsvg_cleanup(void) ;
#line 491
void rsvg_set_default_dpi(double dpi ) ;
#line 509
void rsvg_set_default_dpi_x_y(double dpi_x , double dpi_y ) ;
#line 526
void rsvg_handle_set_dpi(RsvgHandle *handle , double dpi ) ;
#line 544
void rsvg_handle_set_dpi_x_y(RsvgHandle *handle , double dpi_x , double dpi_y ) ;
#line 573
RsvgHandle *rsvg_handle_new(void) ;
#line 602
gboolean rsvg_handle_write(RsvgHandle *handle , guchar *buf , gsize count , GError **error ) ;
#line 630
gboolean rsvg_handle_close(RsvgHandle *handle , GError **error ) ;
#line 650
GdkPixbuf *rsvg_handle_get_pixbuf(RsvgHandle *handle ) ;
#line 684
GdkPixbuf *rsvg_handle_get_pixbuf_sub(RsvgHandle *handle , char const   *id ) ;
#line 696
char const   *rsvg_handle_get_base_uri(RsvgHandle *handle ) ;
#line 711
void rsvg_handle_set_base_uri(RsvgHandle *handle , char const   *base_uri ) ;
#line 731
void rsvg_handle_get_dimensions(RsvgHandle *handle , RsvgDimensionData *dimension_data ) ;
#line 756
gboolean rsvg_handle_get_dimensions_sub(RsvgHandle *handle , RsvgDimensionData *dimension_data ,
                                        char const   *id ) ;
#line 785
gboolean rsvg_handle_get_position_sub(RsvgHandle *handle , RsvgPositionData *position_data ,
                                      char const   *id ) ;
#line 807
gboolean rsvg_handle_has_sub(RsvgHandle *handle , char const   *id ) ;
#line 906
void rsvg_handle_get_intrinsic_dimensions(RsvgHandle *handle , gboolean *out_has_width ,
                                          RsvgLength *out_width , gboolean *out_has_height ,
                                          RsvgLength *out_height , gboolean *out_has_viewbox ,
                                          RsvgRectangle *out_viewbox ) ;
#line 977
gboolean rsvg_handle_get_intrinsic_size_in_pixels(RsvgHandle *handle , gdouble *out_width ,
                                                  gdouble *out_height ) ;
#line 1012
GType rsvg_handle_flags_get_type(void) ;
#line 1028
RsvgHandle *rsvg_handle_new_with_flags(RsvgHandleFlags flags ) ;
#line 1043
void rsvg_handle_set_base_gfile(RsvgHandle *handle , GFile *base_file ) ;
#line 1072
gboolean rsvg_handle_read_stream_sync(RsvgHandle *handle , GInputStream *stream ,
                                      GCancellable *cancellable , GError **error ) ;
#line 1100
RsvgHandle *rsvg_handle_new_from_gfile_sync(GFile *file , RsvgHandleFlags flags ,
                                            GCancellable *cancellable , GError **error ) ;
#line 1129
RsvgHandle *rsvg_handle_new_from_stream_sync(GInputStream *input_stream , GFile *base_file ,
                                             RsvgHandleFlags flags , GCancellable *cancellable ,
                                             GError **error ) ;
#line 1150
RsvgHandle *rsvg_handle_new_from_data(guint8 *data , gsize data_len , GError **error ) ;
#line 1166
RsvgHandle *rsvg_handle_new_from_file(gchar *filename , GError **error ) ;
#line 1190
gboolean rsvg_handle_set_stylesheet(RsvgHandle *handle , guint8 *css , gsize css_len ,
                                    GError **error ) ;
#line 1205
void rsvg_handle_internal_set_testing(RsvgHandle *handle , gboolean testing ) ;
#line 1221
void rsvg_init(void) ;
#line 1232
void rsvg_term(void) ;
#line 1242
void rsvg_handle_free(RsvgHandle *handle ) ;
#line 1292
void rsvg_handle_set_size_callback(RsvgHandle *handle , RsvgSizeFunc size_func , gpointer user_data ,
                                   GDestroyNotify user_data_destroy ) ;
#line 1322
GdkPixbuf *rsvg_pixbuf_from_file(gchar *filename , GError **error ) ;
#line 1341
GdkPixbuf *rsvg_pixbuf_from_file_at_zoom(gchar *filename , double x_zoom , double y_zoom ,
                                         GError **error ) ;
#line 1363
GdkPixbuf *rsvg_pixbuf_from_file_at_size(gchar *filename , gint width , gint height ,
                                         GError **error ) ;
#line 1384
GdkPixbuf *rsvg_pixbuf_from_file_at_max_size(gchar *filename , gint max_width , gint max_height ,
                                             GError **error ) ;
#line 1407
GdkPixbuf *rsvg_pixbuf_from_file_at_zoom_with_max(gchar *filename , double x_zoom ,
                                                  double y_zoom , gint max_width ,
                                                  gint max_height , GError **error ) ;
#line 1426
char const   *rsvg_handle_get_title(RsvgHandle *handle ) ;
#line 1440
char const   *rsvg_handle_get_desc(RsvgHandle *handle ) ;
#line 1454
char const   *rsvg_handle_get_metadata(RsvgHandle *handle ) ;
#line 165 "/usr/include/librsvg-2.0/librsvg/rsvg-features.h"
extern guint rsvg_major_version ;
#line 175
extern guint rsvg_minor_version ;
#line 185
extern guint rsvg_micro_version ;
#line 95 "/usr/include/librsvg-2.0/librsvg/rsvg-cairo.h"
gboolean rsvg_handle_render_cairo(RsvgHandle *handle , cairo_t *cr ) ;
#line 167
gboolean rsvg_handle_render_cairo_sub(RsvgHandle *handle , cairo_t *cr , char const   *id ) ;
#line 192
gboolean rsvg_handle_render_document(RsvgHandle *handle , cairo_t *cr , RsvgRectangle *viewport ,
                                     GError **error ) ;
#line 240
gboolean rsvg_handle_get_geometry_for_layer(RsvgHandle *handle , char const   *id ,
                                            RsvgRectangle *viewport , RsvgRectangle *out_ink_rect ,
                                            RsvgRectangle *out_logical_rect , GError **error ) ;
#line 286
gboolean rsvg_handle_render_layer(RsvgHandle *handle , cairo_t *cr , char const   *id ,
                                  RsvgRectangle *viewport , GError **error ) ;
#line 340
gboolean rsvg_handle_get_geometry_for_element(RsvgHandle *handle , char const   *id ,
                                              RsvgRectangle *out_ink_rect , RsvgRectangle *out_logical_rect ,
                                              GError **error ) ;
#line 382
gboolean rsvg_handle_render_element(RsvgHandle *handle , cairo_t *cr , char const   *id ,
                                    RsvgRectangle *element_viewport , GError **error ) ;
#line 220 "/usr/include/zlib.h"
extern char const   *zlibVersion(void) ;
#line 250
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 400
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 611
extern int deflateSetDictionary(z_streamp strm , Bytef *dictionary , uInt dictLength ) ;
#line 655
extern int deflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 677
extern int deflateCopy(z_streamp dest , z_streamp source ) ;
#line 695
extern int deflateReset(z_streamp strm ) ;
#line 706
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 744
extern int deflateTune(z_streamp strm , int good_length , int max_lazy , int nice_length ,
                       int max_chain ) ;
#line 761
extern uLong deflateBound(z_streamp strm , uLong sourceLen ) ;
#line 776
extern int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
#line 791
extern int deflatePrime(z_streamp strm , int bits , int value ) ;
#line 808
extern int deflateSetHeader(z_streamp strm , gz_headerp head ) ;
#line 885
extern int inflateSetDictionary(z_streamp strm , Bytef *dictionary , uInt dictLength ) ;
#line 908
extern int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 923
extern int inflateSync(z_streamp strm ) ;
#line 942
extern int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 958
extern int inflateReset(z_streamp strm ) ;
#line 968
extern int inflateReset2(z_streamp strm , int windowBits ) ;
#line 982
extern int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 1003
extern long inflateMark(z_streamp strm ) ;
#line 1031
extern int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1097
extern int inflateBack(z_streamp strm , in_func in , void *in_desc , out_func out ,
                       void *out_desc ) ;
#line 1167
extern int inflateBackEnd(z_streamp strm ) ;
#line 1175
extern uLong zlibCompileFlags(void) ;
#line 1228
extern int compress(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ) ;
#line 1243
extern int compress2(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ,
                     int level ) ;
#line 1259
extern uLong compressBound(uLong sourceLen ) ;
#line 1266
extern int uncompress(Bytef *dest , uLongf *destLen , Bytef *source , uLong sourceLen ) ;
#line 1284
extern int uncompress2(Bytef *dest , uLongf *destLen , Bytef *source , uLong *sourceLen ) ;
#line 1341
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1364
extern int gzbuffer(gzFile file , unsigned int size ) ;
#line 1380
extern int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1391
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1421
extern z_size_t gzfread(voidp buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1447
extern int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1455
extern z_size_t gzfwrite(voidpc buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1469
extern int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1484
extern int gzputs(gzFile file , char const   *s ) ;
#line 1492
extern char *gzgets(gzFile file , char *buf , int len ) ;
#line 1505
extern int gzputc(gzFile file , int c ) ;
#line 1511
extern int gzgetc(gzFile file ) ;
#line 1520
extern int gzungetc(int c , gzFile file ) ;
#line 1532
extern int gzflush(gzFile file , int flush ) ;
#line 1567
extern int gzrewind(gzFile file ) ;
#line 1595
extern int gzeof(gzFile file ) ;
#line 1610
extern int gzdirect(gzFile file ) ;
#line 1631
extern int gzclose(gzFile file ) ;
#line 1644
extern int gzclose_r(gzFile file ) ;
#line 1645
extern int gzclose_w(gzFile file ) ;
#line 1656
extern char const   *gzerror(gzFile file , int *errnum ) ;
#line 1672
extern void gzclearerr(gzFile file ) ;
#line 1689
extern uLong adler32(uLong adler , Bytef *buf , uInt len ) ;
#line 1708
extern uLong adler32_z(uLong adler , Bytef *buf , z_size_t len ) ;
#line 1726
extern uLong crc32(uLong crc , Bytef *buf , uInt len ) ;
#line 1743
extern uLong crc32_z(uLong adler , Bytef *buf , z_size_t len ) ;
#line 1765
extern int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1767
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 1769
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1773
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 1775
extern int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window ,
                            char const   *version , int stream_size ) ;
#line 1823
extern int gzgetc_(gzFile file ) ;
#line 1840
extern gzFile gzopen64(char const   * , char const   * ) ;
#line 1841
extern off64_t gzseek64(gzFile  , off64_t  , int  ) ;
#line 1842
extern off64_t gztell64(gzFile  ) ;
#line 1843
extern off64_t gzoffset64(gzFile  ) ;
#line 1844
extern uLong adler32_combine64(uLong  , uLong  , off64_t  ) ;
#line 1845
extern uLong crc32_combine64(uLong  , uLong  , off64_t  ) ;
#line 1873
extern gzFile gzopen(char const   * , char const   * ) ;
#line 1874
extern __off_t gzseek(gzFile  , __off_t  , int  ) ;
#line 1875
extern __off_t gztell(gzFile  ) ;
#line 1876
extern __off_t gzoffset(gzFile  ) ;
#line 1877
extern uLong adler32_combine(uLong  , uLong  , __off_t  ) ;
#line 1878
extern uLong crc32_combine(uLong  , uLong  , __off_t  ) ;
#line 1889
extern char const   *zError(int  ) ;
#line 1890
extern int inflateSyncPoint(z_streamp  ) ;
#line 1891
extern z_crc_t *get_crc_table(void) ;
#line 1892
extern int inflateUndermine(z_streamp  , int  ) ;
#line 1893
extern int inflateValidate(z_streamp  , int  ) ;
#line 1894
extern unsigned long inflateCodesUsed(z_streamp  ) ;
#line 1895
extern int inflateResetKeep(z_streamp  ) ;
#line 1896
extern int deflateResetKeep(z_streamp  ) ;
#line 1903
extern int gzvprintf(gzFile file , char const   *format , va_list va ) ;
#line 36 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int setjmp(jmp_buf __env ) ;
#line 41
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __savemask ) ;
#line 45
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag __env[1] ) ;
#line 54
extern  __attribute__((__nothrow__)) void longjmp(struct __jmp_buf_tag __env[1] ,
                                                  int __val ) ;
#line 61
extern  __attribute__((__nothrow__)) void _longjmp(struct __jmp_buf_tag __env[1] ,
                                                   int __val ) ;
#line 80
extern  __attribute__((__nothrow__)) void siglongjmp(struct __jmp_buf_tag __env[1] ,
                                                     int __val ) ;
#line 924 "/usr/include/libpng16/png.h"
extern png_uint_32 png_access_version_number(void) ;
#line 929
extern void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 936
extern int png_sig_cmp(png_const_bytep sig , size_t start , size_t num_to_check ) ;
#line 945
extern png_structp png_create_read_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                          png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 951
extern png_structp png_create_write_struct(png_const_charp user_png_ver , png_voidp error_ptr ,
                                           png_error_ptr error_fn , png_error_ptr warn_fn ) ;
#line 956
extern size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 959
extern void png_set_compression_buffer_size(png_structrp png_ptr , size_t size ) ;
#line 973
extern jmp_buf *png_set_longjmp_fn(png_structrp png_ptr , png_longjmp_ptr longjmp_fn ,
                                   size_t jmp_buf_size ) ;
#line 986
extern void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 991
extern int png_reset_zstream(png_structrp png_ptr ) ;
#line 996
extern png_structp png_create_read_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                            png_error_ptr error_fn , png_error_ptr warn_fn ,
                                            png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                            png_free_ptr free_fn ) ;
#line 1001
extern png_structp png_create_write_struct_2(png_const_charp user_png_ver , png_voidp error_ptr ,
                                             png_error_ptr error_fn , png_error_ptr warn_fn ,
                                             png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                                             png_free_ptr free_fn ) ;
#line 1009
extern void png_write_sig(png_structrp png_ptr ) ;
#line 1012
extern void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_name , png_const_bytep data ,
                            size_t length ) ;
#line 1016
extern void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_name ,
                                  png_uint_32 length ) ;
#line 1020
extern void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , size_t length ) ;
#line 1024
extern void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1027
extern png_infop png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1034
extern void png_info_init_3(png_infopp info_ptr , size_t png_info_struct_size ) ;
#line 1038
extern void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1040
extern void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1045
extern void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1056
extern png_const_charp png_convert_to_rfc1123(png_structrp png_ptr , png_const_timep ptime ) ;
#line 1059
extern int png_convert_to_rfc1123_buffer(char out[29] , png_const_timep ptime ) ;
#line 1065
extern void png_convert_from_struct_tm(png_timep ptime , struct tm *ttime ) ;
#line 1069
extern void png_convert_from_time_t(png_timep ptime , time_t ttime ) ;
#line 1074
extern void png_set_expand(png_structrp png_ptr ) ;
#line 1075
extern void png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr ) ;
#line 1076
extern void png_set_palette_to_rgb(png_structrp png_ptr ) ;
#line 1077
extern void png_set_tRNS_to_alpha(png_structrp png_ptr ) ;
#line 1084
extern void png_set_expand_16(png_structrp png_ptr ) ;
#line 1089
extern void png_set_bgr(png_structrp png_ptr ) ;
#line 1094
extern void png_set_gray_to_rgb(png_structrp png_ptr ) ;
#line 1104
extern void png_set_rgb_to_gray(png_structrp png_ptr , int error_action , double red ,
                                double green ) ;
#line 1106
extern void png_set_rgb_to_gray_fixed(png_structrp png_ptr , int error_action , png_fixed_point red ,
                                      png_fixed_point green ) ;
#line 1109
extern png_byte png_get_rgb_to_gray_status(png_const_structrp png_ptr ) ;
#line 1114
extern void png_build_grayscale_palette(int bit_depth , png_colorp palette ) ;
#line 1160
extern void png_set_alpha_mode(png_structrp png_ptr , int mode , double output_gamma ) ;
#line 1162
extern void png_set_alpha_mode_fixed(png_structrp png_ptr , int mode , png_fixed_point output_gamma ) ;
#line 1253
extern void png_set_strip_alpha(png_structrp png_ptr ) ;
#line 1258
extern void png_set_swap_alpha(png_structrp png_ptr ) ;
#line 1263
extern void png_set_invert_alpha(png_structrp png_ptr ) ;
#line 1268
extern void png_set_filler(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1274
extern void png_set_add_alpha(png_structrp png_ptr , png_uint_32 filler , int flags ) ;
#line 1280
extern void png_set_swap(png_structrp png_ptr ) ;
#line 1285
extern void png_set_packing(png_structrp png_ptr ) ;
#line 1291
extern void png_set_packswap(png_structrp png_ptr ) ;
#line 1296
extern void png_set_shift(png_structrp png_ptr , png_const_color_8p true_bits ) ;
#line 1308
extern int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1313
extern void png_set_invert_mono(png_structrp png_ptr ) ;
#line 1322
extern void png_set_background(png_structrp png_ptr , png_const_color_16p background_color ,
                               int background_gamma_code , int need_expand , double background_gamma ) ;
#line 1325
extern void png_set_background_fixed(png_structrp png_ptr , png_const_color_16p background_color ,
                                     int background_gamma_code , int need_expand ,
                                     png_fixed_point background_gamma ) ;
#line 1338
extern void png_set_scale_16(png_structrp png_ptr ) ;
#line 1344
extern void png_set_strip_16(png_structrp png_ptr ) ;
#line 1351
extern void png_set_quantize(png_structrp png_ptr , png_colorp palette , int num_palette ,
                             int maximum_colors , png_const_uint_16p histogram , int full_quantize ) ;
#line 1373
extern void png_set_gamma(png_structrp png_ptr , double screen_gamma , double override_file_gamma ) ;
#line 1375
extern void png_set_gamma_fixed(png_structrp png_ptr , png_fixed_point screen_gamma ,
                                png_fixed_point override_file_gamma ) ;
#line 1381
extern void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1383
extern void png_write_flush(png_structrp png_ptr ) ;
#line 1387
extern void png_start_read_image(png_structrp png_ptr ) ;
#line 1390
extern void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
extern void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                          png_uint_32 num_rows ) ;
#line 1401
extern void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep display_row ) ;
#line 1407
extern void png_read_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1411
extern void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1419
extern void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1423
extern void png_write_image(png_structrp png_ptr , png_bytepp image ) ;
#line 1426
extern void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1431
extern void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1435
extern void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1439
extern void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                                    png_infopp end_info_ptr_ptr ) ;
#line 1443
extern void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1447
extern void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1478
extern void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1508
extern void png_set_filter_heuristics(png_structrp png_ptr , int heuristic_method ,
                                      int num_weights , png_const_doublep filter_weights ,
                                      png_const_doublep filter_costs ) ;
#line 1511
extern void png_set_filter_heuristics_fixed(png_structrp png_ptr , int heuristic_method ,
                                            int num_weights , png_const_fixed_point_p filter_weights ,
                                            png_const_fixed_point_p filter_costs ) ;
#line 1531
extern void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1534
extern void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1537
extern void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1543
extern void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1546
extern void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1552
extern void png_set_text_compression_level(png_structrp png_ptr , int level ) ;
#line 1555
extern void png_set_text_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1558
extern void png_set_text_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1564
extern void png_set_text_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1567
extern void png_set_text_compression_method(png_structrp png_ptr , int method ) ;
#line 1583
extern void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1594
extern void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , png_error_ptr error_fn ,
                             png_error_ptr warning_fn ) ;
#line 1598
extern png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1610
extern void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr write_data_fn ,
                             png_flush_ptr output_flush_fn ) ;
#line 1614
extern void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , png_rw_ptr read_data_fn ) ;
#line 1618
extern png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1620
extern void png_set_read_status_fn(png_structrp png_ptr , png_read_status_ptr read_row_fn ) ;
#line 1623
extern void png_set_write_status_fn(png_structrp png_ptr , png_write_status_ptr write_row_fn ) ;
#line 1628
extern void png_set_mem_fn(png_structrp png_ptr , png_voidp mem_ptr , png_malloc_ptr malloc_fn ,
                           png_free_ptr free_fn ) ;
#line 1631
extern png_voidp png_get_mem_ptr(png_const_structrp png_ptr ) ;
#line 1635
extern void png_set_read_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr read_user_transform_fn ) ;
#line 1640
extern void png_set_write_user_transform_fn(png_structrp png_ptr , png_user_transform_ptr write_user_transform_fn ) ;
#line 1645
extern void png_set_user_transform_info(png_structrp png_ptr , png_voidp user_transform_ptr ,
                                        int user_transform_depth , int user_transform_channels ) ;
#line 1649
extern png_voidp png_get_user_transform_ptr(png_const_structrp png_ptr ) ;
#line 1665
extern png_uint_32 png_get_current_row_number(png_const_structrp  ) ;
#line 1666
extern png_byte png_get_current_pass_number(png_const_structrp  ) ;
#line 1689
extern void png_set_read_user_chunk_fn(png_structrp png_ptr , png_voidp user_chunk_ptr ,
                                       png_user_chunk_ptr read_user_chunk_fn ) ;
#line 1694
extern png_voidp png_get_user_chunk_ptr(png_const_structrp png_ptr ) ;
#line 1701
extern void png_set_progressive_read_fn(png_structrp png_ptr , png_voidp progressive_ptr ,
                                        png_progressive_info_ptr info_fn , png_progressive_row_ptr row_fn ,
                                        png_progressive_end_ptr end_fn ) ;
#line 1706
extern png_voidp png_get_progressive_ptr(png_const_structrp png_ptr ) ;
#line 1710
extern void png_process_data(png_structrp png_ptr , png_inforp info_ptr , png_bytep buffer ,
                             size_t buffer_size ) ;
#line 1720
extern size_t png_process_data_pause(png_structrp  , int save ) ;
#line 1728
extern png_uint_32 png_process_data_skip(png_structrp  ) ;
#line 1735
extern void png_progressive_combine_row(png_const_structrp png_ptr , png_bytep old_row ,
                                        png_const_bytep new_row ) ;
#line 1739
extern png_voidp png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1742
extern png_voidp png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1746
extern png_voidp png_malloc_warn(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1750
extern void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1753
extern void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 free_me ,
                          int num ) ;
#line 1763
extern void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                           png_uint_32 mask ) ;
#line 1789
extern png_voidp png_malloc_default(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1791
extern void png_free_default(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1797
extern void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1801
extern void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1813
extern void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1817
extern void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1827
extern void png_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1832
extern void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1836
extern void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1861
extern png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                 png_uint_32 flag ) ;
#line 1865
extern size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1872
extern png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1878
extern void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1883
extern png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1888
extern png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1892
extern png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
extern png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
extern png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1904
extern png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1908
extern png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1912
extern png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1916
extern png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1918
extern png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1920
extern png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1924
extern float png_get_pixel_aspect_ratio(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1926
extern png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr ,
                                                        png_const_inforp info_ptr ) ;
#line 1930
extern png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1932
extern png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1934
extern png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1936
extern png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1943
extern png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1948
extern png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_16p *background ) ;
#line 1953
extern void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 1958
extern png_uint_32 png_get_cHRM(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *white_x , double *white_y , double *red_x ,
                                double *red_y , double *green_x , double *green_y ,
                                double *blue_x , double *blue_y ) ;
#line 1962
extern png_uint_32 png_get_cHRM_XYZ(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    double *red_X , double *red_Y , double *red_Z ,
                                    double *green_X , double *green_Y , double *green_Z ,
                                    double *blue_X , double *blue_Y , double *blue_Z ) ;
#line 1966
extern png_uint_32 png_get_cHRM_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_white_x , png_fixed_point *int_white_y ,
                                      png_fixed_point *int_red_x , png_fixed_point *int_red_y ,
                                      png_fixed_point *int_green_x , png_fixed_point *int_green_y ,
                                      png_fixed_point *int_blue_x , png_fixed_point *int_blue_y ) ;
#line 1972
extern png_uint_32 png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                          png_fixed_point *int_red_X , png_fixed_point *int_red_Y ,
                                          png_fixed_point *int_red_Z , png_fixed_point *int_green_X ,
                                          png_fixed_point *int_green_Y , png_fixed_point *int_green_Z ,
                                          png_fixed_point *int_blue_X , png_fixed_point *int_blue_Y ,
                                          png_fixed_point *int_blue_Z ) ;
#line 1982
extern void png_set_cHRM(png_const_structrp png_ptr , png_inforp info_ptr , double white_x ,
                         double white_y , double red_x , double red_y , double green_x ,
                         double green_y , double blue_x , double blue_y ) ;
#line 1986
extern void png_set_cHRM_XYZ(png_const_structrp png_ptr , png_inforp info_ptr , double red_X ,
                             double red_Y , double red_Z , double green_X , double green_Y ,
                             double green_Z , double blue_X , double blue_Y , double blue_Z ) ;
#line 1990
extern void png_set_cHRM_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_white_x , png_fixed_point int_white_y ,
                               png_fixed_point int_red_x , png_fixed_point int_red_y ,
                               png_fixed_point int_green_x , png_fixed_point int_green_y ,
                               png_fixed_point int_blue_x , png_fixed_point int_blue_y ) ;
#line 1996
extern void png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_fixed_point int_red_X , png_fixed_point int_red_Y ,
                                   png_fixed_point int_red_Z , png_fixed_point int_green_X ,
                                   png_fixed_point int_green_Y , png_fixed_point int_green_Z ,
                                   png_fixed_point int_blue_X , png_fixed_point int_blue_Y ,
                                   png_fixed_point int_blue_Z ) ;
#line 2005
extern png_uint_32 png_get_eXIf(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *exif ) ;
#line 2007
extern void png_set_eXIf(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep exif ) ;
#line 2010
extern png_uint_32 png_get_eXIf_1(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  png_uint_32 *num_exif , png_bytep *exif ) ;
#line 2012
extern void png_set_eXIf_1(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 num_exif ,
                           png_bytep exif ) ;
#line 2017
extern png_uint_32 png_get_gAMA(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                double *file_gamma ) ;
#line 2019
extern png_uint_32 png_get_gAMA_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      png_fixed_point *int_file_gamma ) ;
#line 2025
extern void png_set_gAMA(png_const_structrp png_ptr , png_inforp info_ptr , double file_gamma ) ;
#line 2027
extern void png_set_gAMA_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               png_fixed_point int_file_gamma ) ;
#line 2032
extern png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_uint_16p *hist ) ;
#line 2034
extern void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2038
extern png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                                int *color_type , int *interlace_method , int *compression_method ,
                                int *filter_method ) ;
#line 2043
extern void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                         png_uint_32 height , int bit_depth , int color_type , int interlace_method ,
                         int compression_method , int filter_method ) ;
#line 2049
extern png_uint_32 png_get_oFFs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_int_32 *offset_x , png_int_32 *offset_y , int *unit_type ) ;
#line 2055
extern void png_set_oFFs(png_const_structrp png_ptr , png_inforp info_ptr , png_int_32 offset_x ,
                         png_int_32 offset_y , int unit_type ) ;
#line 2061
extern png_uint_32 png_get_pCAL(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charp *purpose , png_int_32 *X0 , png_int_32 *X1 ,
                                int *type , int *nparams , png_charp *units , png_charpp *params ) ;
#line 2068
extern void png_set_pCAL(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp purpose ,
                         png_int_32 X0 , png_int_32 X1 , int type , int nparams ,
                         png_const_charp units , png_charpp params ) ;
#line 2074
extern png_uint_32 png_get_pHYs(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2080
extern void png_set_pHYs(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 res_x ,
                         png_uint_32 res_y , int unit_type ) ;
#line 2084
extern png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_colorp *palette , int *num_palette ) ;
#line 2087
extern void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                         int num_palette ) ;
#line 2091
extern png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_color_8p *sig_bit ) ;
#line 2096
extern void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2101
extern png_uint_32 png_get_sRGB(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *file_srgb_intent ) ;
#line 2106
extern void png_set_sRGB(png_const_structrp png_ptr , png_inforp info_ptr , int srgb_intent ) ;
#line 2108
extern void png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr , png_inforp info_ptr ,
                                       int srgb_intent ) ;
#line 2113
extern png_uint_32 png_get_iCCP(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_charpp name , int *compression_type , png_bytepp profile ,
                                png_uint_32 *proflen ) ;
#line 2119
extern void png_set_iCCP(png_const_structrp png_ptr , png_inforp info_ptr , png_const_charp name ,
                         int compression_type , png_const_bytep profile , png_uint_32 proflen ) ;
#line 2125
extern int png_get_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_sPLT_tpp entries ) ;
#line 2130
extern void png_set_sPLT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_sPLT_tp entries ,
                         int nentries ) ;
#line 2136
extern int png_get_text(png_const_structrp png_ptr , png_inforp info_ptr , png_textp *text_ptr ,
                        int *num_text ) ;
#line 2148
extern void png_set_text(png_const_structrp png_ptr , png_inforp info_ptr , png_const_textp text_ptr ,
                         int num_text ) ;
#line 2153
extern png_uint_32 png_get_tIME(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_timep *mod_time ) ;
#line 2158
extern void png_set_tIME(png_const_structrp png_ptr , png_inforp info_ptr , png_const_timep mod_time ) ;
#line 2163
extern png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr ,
                                png_bytep *trans_alpha , int *num_trans , png_color_16p *trans_color ) ;
#line 2169
extern void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                         int num_trans , png_const_color_16p trans_color ) ;
#line 2175
extern png_uint_32 png_get_sCAL(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                int *unit , double *width , double *height ) ;
#line 2184
extern png_uint_32 png_get_sCAL_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                      int *unit , png_fixed_point *width , png_fixed_point *height ) ;
#line 2188
extern png_uint_32 png_get_sCAL_s(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                  int *unit , png_charpp swidth , png_charpp sheight ) ;
#line 2192
extern void png_set_sCAL(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                         double width , double height ) ;
#line 2194
extern void png_set_sCAL_fixed(png_const_structrp png_ptr , png_inforp info_ptr ,
                               int unit , png_fixed_point width , png_fixed_point height ) ;
#line 2197
extern void png_set_sCAL_s(png_const_structrp png_ptr , png_inforp info_ptr , int unit ,
                           png_const_charp swidth , png_const_charp sheight ) ;
#line 2302
extern void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                        int num_chunks ) ;
#line 2310
extern int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2315
extern void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                   png_const_unknown_chunkp unknowns , int num_unknowns ) ;
#line 2327
extern void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                           int chunk , int location ) ;
#line 2330
extern int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr ,
                                  png_unknown_chunkpp entries ) ;
#line 2338
extern void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2344
extern void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                         png_voidp params ) ;
#line 2348
extern void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms ,
                          png_voidp params ) ;
#line 2353
extern png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2355
extern png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2357
extern png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2359
extern png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2363
extern png_uint_32 png_permit_mng_features(png_structrp png_ptr , png_uint_32 mng_features_permitted ) ;
#line 2384
extern void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max ,
                                png_uint_32 user_height_max ) ;
#line 2386
extern png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2388
extern png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2391
extern void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2393
extern png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2396
extern void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_cache_max ) ;
#line 2398
extern png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2403
extern png_uint_32 png_get_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2406
extern png_uint_32 png_get_x_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2409
extern png_uint_32 png_get_y_pixels_per_inch(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2412
extern float png_get_x_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2415
extern png_fixed_point png_get_x_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2419
extern float png_get_y_offset_inches(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 2422
extern png_fixed_point png_get_y_offset_inches_fixed(png_const_structrp png_ptr ,
                                                     png_const_inforp info_ptr ) ;
#line 2427
extern png_uint_32 png_get_pHYs_dpi(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                                    png_uint_32 *res_x , png_uint_32 *res_y , int *unit_type ) ;
#line 2435
extern png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2441
extern png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2567
extern png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2568
extern png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2569
extern png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2572
extern png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 2578
extern void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2581
extern void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 2589
extern void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 2635
extern void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 2638
extern int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 3003
extern int png_image_begin_read_from_file(png_imagep image , char const   *file_name ) ;
#line 3009
extern int png_image_begin_read_from_stdio(png_imagep image , FILE *file ) ;
#line 3014
extern int png_image_begin_read_from_memory(png_imagep image , png_const_voidp memory ,
                                            size_t size ) ;
#line 3018
extern int png_image_finish_read(png_imagep image , png_const_colorp background ,
                                 void *buffer , png_int_32 row_stride , void *colormap ) ;
#line 3053
extern void png_image_free(png_imagep image ) ;
#line 3077
extern int png_image_write_to_file(png_imagep image , char const   *file , int convert_to_8bit ,
                                   void const   *buffer , png_int_32 row_stride ,
                                   void const   *colormap ) ;
#line 3082
extern int png_image_write_to_stdio(png_imagep image , FILE *file , int convert_to_8_bit ,
                                    void const   *buffer , png_int_32 row_stride ,
                                    void const   *colormap ) ;
#line 3109
extern int png_image_write_to_memory(png_imagep image , void *memory , png_alloc_size_t *memory_bytes ,
                                     int convert_to_8_bit , void const   *buffer ,
                                     png_int_32 row_stride , void const   *colormap ) ;
#line 3245
extern int png_set_option(png_structrp png_ptr , int option , int onoff ) ;
#line 3253
extern png_uint_32 png_get_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 *num_frames ,
                                png_uint_32 *num_plays ) ;
#line 3256
extern png_uint_32 png_set_acTL(png_structp png_ptr , png_infop info_ptr , png_uint_32 num_frames ,
                                png_uint_32 num_plays ) ;
#line 3259
extern png_uint_32 png_get_num_frames(png_structp png_ptr , png_infop info_ptr ) ;
#line 3262
extern png_uint_32 png_get_num_plays(png_structp png_ptr , png_infop info_ptr ) ;
#line 3265
extern png_uint_32 png_get_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 *width , png_uint_32 *height ,
                                           png_uint_32 *x_offset , png_uint_32 *y_offset ,
                                           png_uint_16 *delay_num , png_uint_16 *delay_den ,
                                           png_byte *dispose_op , png_byte *blend_op ) ;
#line 3271
extern png_uint_32 png_set_next_frame_fcTL(png_structp png_ptr , png_infop info_ptr ,
                                           png_uint_32 width , png_uint_32 height ,
                                           png_uint_32 x_offset , png_uint_32 y_offset ,
                                           png_uint_16 delay_num , png_uint_16 delay_den ,
                                           png_byte dispose_op , png_byte blend_op ) ;
#line 3277
extern png_uint_32 png_get_next_frame_width(png_structp png_ptr , png_infop info_ptr ) ;
#line 3279
extern png_uint_32 png_get_next_frame_height(png_structp png_ptr , png_infop info_ptr ) ;
#line 3281
extern png_uint_32 png_get_next_frame_x_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3283
extern png_uint_32 png_get_next_frame_y_offset(png_structp png_ptr , png_infop info_ptr ) ;
#line 3285
extern png_uint_16 png_get_next_frame_delay_num(png_structp png_ptr , png_infop info_ptr ) ;
#line 3287
extern png_uint_16 png_get_next_frame_delay_den(png_structp png_ptr , png_infop info_ptr ) ;
#line 3289
extern png_byte png_get_next_frame_dispose_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3291
extern png_byte png_get_next_frame_blend_op(png_structp png_ptr , png_infop info_ptr ) ;
#line 3293
extern png_byte png_get_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ) ;
#line 3295
extern png_uint_32 png_set_first_frame_is_hidden(png_structp png_ptr , png_infop info_ptr ,
                                                 png_byte is_hidden ) ;
#line 3299
extern void png_read_frame_head(png_structp png_ptr , png_infop info_ptr ) ;
#line 3302
extern void png_set_progressive_frame_fn(png_structp png_ptr , png_progressive_frame_ptr frame_info_fn ,
                                         png_progressive_frame_ptr frame_end_fn ) ;
#line 3309
extern void png_write_frame_head(png_structp png_ptr , png_infop info_ptr , png_bytepp row_pointers ,
                                 png_uint_32 width , png_uint_32 height , png_uint_32 x_offset ,
                                 png_uint_32 y_offset , png_uint_16 delay_num , png_uint_16 delay_den ,
                                 png_byte dispose_op , png_byte blend_op ) ;
#line 3316
extern void png_write_frame_tail(png_structp png_ptr , png_infop info_ptr ) ;
#line 74 "/usr/include/libimagequant.h"
extern liq_attr *liq_attr_create(void) ;
#line 75
extern liq_attr *liq_attr_create_with_allocator(void *(*malloc)(size_t  ) , void (*free)(void * ) ) ;
#line 76
extern liq_attr *liq_attr_copy(liq_attr *orig ) ;
#line 77
extern void liq_attr_destroy(liq_attr *attr ) ;
#line 79
extern liq_histogram *liq_histogram_create(liq_attr *attr ) ;
#line 80
extern liq_error liq_histogram_add_image(liq_histogram *hist , liq_attr *attr , liq_image *image ) ;
#line 81
extern liq_error liq_histogram_add_colors(liq_histogram *hist , liq_attr *attr , liq_histogram_entry entries[] ,
                                          int num_entries , double gamma ) ;
#line 82
extern liq_error liq_histogram_add_fixed_color(liq_histogram *hist , liq_color color ,
                                               double gamma ) ;
#line 83
extern void liq_histogram_destroy(liq_histogram *hist ) ;
#line 85
extern liq_error liq_set_max_colors(liq_attr *attr , int colors ) ;
#line 86
extern int liq_get_max_colors(liq_attr *attr ) ;
#line 87
extern liq_error liq_set_speed(liq_attr *attr , int speed ) ;
#line 88
extern int liq_get_speed(liq_attr *attr ) ;
#line 89
extern liq_error liq_set_min_opacity(liq_attr *attr , int min ) ;
#line 90
extern int liq_get_min_opacity(liq_attr *attr ) ;
#line 91
extern liq_error liq_set_min_posterization(liq_attr *attr , int bits ) ;
#line 92
extern int liq_get_min_posterization(liq_attr *attr ) ;
#line 93
extern liq_error liq_set_quality(liq_attr *attr , int minimum , int maximum ) ;
#line 94
extern int liq_get_min_quality(liq_attr *attr ) ;
#line 95
extern int liq_get_max_quality(liq_attr *attr ) ;
#line 96
extern void liq_set_last_index_transparent(liq_attr *attr , int is_last ) ;
#line 100
extern void liq_set_log_callback(liq_attr * , liq_log_callback_function * , void *user_info ) ;
#line 101
extern void liq_set_log_flush_callback(liq_attr * , liq_log_flush_callback_function * ,
                                       void *user_info ) ;
#line 104
extern void liq_attr_set_progress_callback(liq_attr * , liq_progress_callback_function * ,
                                           void *user_info ) ;
#line 105
extern void liq_result_set_progress_callback(liq_result * , liq_progress_callback_function * ,
                                             void *user_info ) ;
#line 108
extern liq_image *liq_image_create_rgba_rows(liq_attr *attr , void * const  rows[] ,
                                             int width , int height , double gamma ) ;
#line 109
extern liq_image *liq_image_create_rgba(liq_attr *attr , void const   *bitmap , int width ,
                                        int height , double gamma ) ;
#line 112
extern liq_image *liq_image_create_custom(liq_attr *attr , liq_image_get_rgba_row_callback *row_callback ,
                                          void *user_info , int width , int height ,
                                          double gamma ) ;
#line 114
extern liq_error liq_image_set_memory_ownership(liq_image *image , int ownership_flags ) ;
#line 115
extern liq_error liq_image_set_background(liq_image *img , liq_image *background_image ) ;
#line 116
extern liq_error liq_image_set_importance_map(liq_image *img , unsigned char buffer[] ,
                                              size_t buffer_size , enum liq_ownership memory_handling ) ;
#line 117
extern liq_error liq_image_add_fixed_color(liq_image *img , liq_color color ) ;
#line 118
extern int liq_image_get_width(liq_image *img ) ;
#line 119
extern int liq_image_get_height(liq_image *img ) ;
#line 120
extern void liq_image_destroy(liq_image *img ) ;
#line 122
extern liq_error liq_histogram_quantize(liq_histogram * const  input_hist , liq_attr * const  options ,
                                        liq_result **result_output ) ;
#line 123
extern liq_error liq_image_quantize(liq_image * const  input_image , liq_attr * const  options ,
                                    liq_result **result_output ) ;
#line 125
extern liq_error liq_set_dithering_level(liq_result *res , float dither_level ) ;
#line 126
extern liq_error liq_set_output_gamma(liq_result *res , double gamma ) ;
#line 127
extern double liq_get_output_gamma(liq_result *result ) ;
#line 129
extern liq_palette *liq_get_palette(liq_result *result ) ;
#line 131
extern liq_error liq_write_remapped_image(liq_result *result , liq_image *input_image ,
                                          void *buffer , size_t buffer_size ) ;
#line 132
extern liq_error liq_write_remapped_image_rows(liq_result *result , liq_image *input_image ,
                                               unsigned char **row_pointers ) ;
#line 134
extern double liq_get_quantization_error(liq_result *result ) ;
#line 135
extern int liq_get_quantization_quality(liq_result *result ) ;
#line 136
extern double liq_get_remapping_error(liq_result *result ) ;
#line 137
extern int liq_get_remapping_quality(liq_result *result ) ;
#line 139
extern void liq_result_destroy(liq_result * ) ;
#line 141
extern int liq_version(void) ;
#line 145
extern liq_result *liq_quantize_image(liq_attr *options , liq_image *input_image ) ;
#line 4 "src/mouse/watch.xbm"
static unsigned char watch_bits___0[128]  = 
#line 4 "src/mouse/watch.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )14,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )28,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )199,      (unsigned char )56,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )195,      (unsigned char )48,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )227,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )193,      (unsigned char )227,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )96,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )3,      (unsigned char )48,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )7,      (unsigned char )56,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )28,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )14,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/watch-mask.xbm"
static unsigned char watch_mask_bits___0[128]  = 
#line 4 "src/mouse/watch-mask.xbm"
  {      (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0};
#line 4 "src/mouse/hand.xbm"
static unsigned char hand_bits___0[128]  = 
#line 4 "src/mouse/hand.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )76,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )112,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )248,      (unsigned char )204,      (unsigned char )204,      (unsigned char )12, 
        (unsigned char )220,      (unsigned char )13,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )140,      (unsigned char )15,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )12,      (unsigned char )7,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )28,      (unsigned char )2,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )0,      (unsigned char )12, 
        (unsigned char )224,      (unsigned char )0,      (unsigned char )0,      (unsigned char )6, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )0,      (unsigned char )6, 
        (unsigned char )128,      (unsigned char )3,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )7,      (unsigned char )0,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )14,      (unsigned char )0,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )28,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/hand-mask.xbm"
static unsigned char hand_mask_bits___0[128]  = 
#line 4 "src/mouse/hand-mask.xbm"
  {      (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )112,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )248,      (unsigned char )254,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )252,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )252,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )248,      (unsigned char )255,      (unsigned char )255,      (unsigned char )31, 
        (unsigned char )240,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )15, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )255,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )255,      (unsigned char )0};
#line 4 "src/mouse/wand.xbm"
static unsigned char wand_bits___0[128]  = 
#line 4 "src/mouse/wand.xbm"
  {      (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )67,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )160,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )2,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )28,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )132,      (unsigned char )62,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/wand-mask.xbm"
static unsigned char wand_mask_bits___0[128]  = 
#line 4 "src/mouse/wand-mask.xbm"
  {      (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )8,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )4,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )227,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )252,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )196,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )130,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )127, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/insertion.xbm"
static unsigned char insertion_bits___0[64]  = 
#line 4 "src/mouse/insertion.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )56,      (unsigned char )48,      (unsigned char )6, 
        (unsigned char )64,      (unsigned char )1,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )1,      (unsigned char )48,      (unsigned char )6, 
        (unsigned char )14,      (unsigned char )56,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/insertion-mask.xbm"
static unsigned char insertion_mask_bits___0[64]  = 
#line 4 "src/mouse/insertion-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )14,      (unsigned char )56, 
        (unsigned char )63,      (unsigned char )126,      (unsigned char )126,      (unsigned char )63, 
        (unsigned char )240,      (unsigned char )7,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )192,      (unsigned char )1,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )240,      (unsigned char )7,      (unsigned char )126,      (unsigned char )63, 
        (unsigned char )63,      (unsigned char )126,      (unsigned char )14,      (unsigned char )56};
#line 4 "src/mouse/brush.xbm"
static unsigned char brush_bits___0[128]  = 
#line 4 "src/mouse/brush.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )6, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )96,      (unsigned char )12, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )32,      (unsigned char )6, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )48,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )24,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )136,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )204,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )102,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )34,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )51,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )25,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )12,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )6,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )96,      (unsigned char )2,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )56,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )236,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )196,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )198,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )195,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )195,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )97,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )112,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/brush-mask.xbm"
static unsigned char brush_mask_bits___0[128]  = 
#line 4 "src/mouse/brush-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )192,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )224,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )31, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )240,      (unsigned char )15, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )248,      (unsigned char )7, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )252,      (unsigned char )3, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )254,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )248,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )240,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/crosshair.xbm"
static unsigned char crosshair_bits___0[128]  = 
#line 4 "src/mouse/crosshair.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/crosshair-mask.xbm"
static unsigned char crosshair_mask_bits___0[128]  = 
#line 4 "src/mouse/crosshair-mask.xbm"
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )255,      (unsigned char )63,      (unsigned char )254,      (unsigned char )127, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )252,      (unsigned char )63, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/rotate.xbm"
static unsigned char rotate_bits___0[128]  = 
#line 4 "src/mouse/rotate.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )6,      (unsigned char )6,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )24,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )0,      (unsigned char )32,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )0,      (unsigned char )64,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )0,      (unsigned char )128,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )1, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )1, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )2, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )2, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )64,      (unsigned char )68, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )128,      (unsigned char )36, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )21, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )2,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )4,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )8,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )16,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )32,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )64,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )6,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/rotate-mask.xbm"
static unsigned char rotate_mask_bits___0[128]  = 
#line 4 "src/mouse/rotate-mask.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )7,      (unsigned char )62,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )1,      (unsigned char )120,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )224,      (unsigned char )0, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )192,      (unsigned char )1, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )128,      (unsigned char )3, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )7, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )64,      (unsigned char )78, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )224,      (unsigned char )238, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )192,      (unsigned char )127, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )128,      (unsigned char )63, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )31, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )14, 
        (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )4, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )28,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )56,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )112,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )224,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/up.xbm"
static unsigned char up_bits___0[128]  = 
#line 4 "src/mouse/up.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/up-mask.xbm"
static unsigned char up_mask_bits___0[128]  = 
#line 4 "src/mouse/up-mask.xbm"
  {      (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0};
#line 4 "src/mouse/down.xbm"
static unsigned char down_bits___0[128]  = 
#line 4 "src/mouse/down.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/down-mask.xbm"
static unsigned char down_mask_bits___0[128]  = 
#line 4 "src/mouse/down-mask.xbm"
  {      (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )224,      (unsigned char )255,      (unsigned char )255,      (unsigned char )3, 
        (unsigned char )192,      (unsigned char )255,      (unsigned char )255,      (unsigned char )1, 
        (unsigned char )128,      (unsigned char )255,      (unsigned char )255,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )255,      (unsigned char )127,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )63,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )31,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )15,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )7,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )224,      (unsigned char )3,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )192,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )128,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/tiny.xbm"
static unsigned char tiny_bits___0[7]  = {      (unsigned char )0,      (unsigned char )8,      (unsigned char )8,      (unsigned char )62, 
        (unsigned char )8,      (unsigned char )8,      (unsigned char )0};
#line 4 "src/mouse/tiny-mask.xbm"
static unsigned char tiny_mask_bits___0[7]  = {      (unsigned char )0,      (unsigned char )8,      (unsigned char )8,      (unsigned char )62, 
        (unsigned char )8,      (unsigned char )8,      (unsigned char )0};
#line 4 "src/mouse/arrow.xbm"
static unsigned char arrow_bits___0[128]  = 
#line 4 "src/mouse/arrow.xbm"
  {      (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )6,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )30,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )62,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )126,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )254,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )158,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )14,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )6,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )30,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )62,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )60,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )124,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )120,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )240,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 4 "src/mouse/arrow-mask.xbm"
static unsigned char arrow_mask_bits___0[128]  = 
#line 4 "src/mouse/arrow-mask.xbm"
  {      (unsigned char )7,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )15,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )31,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )63,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )127,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )1,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )3,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )7,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )255,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )15,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )255,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )159,      (unsigned char )31,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )143,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )7,      (unsigned char )63,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )2,      (unsigned char )127,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )126,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )254,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )252,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )1,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )248,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )48,      (unsigned char )0,      (unsigned char )0, 
        (unsigned char )0,      (unsigned char )0,      (unsigned char )0,      (unsigned char )0};
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static float const   sRGB_to_linear_table___1[256]  = 
#line 40 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
  {      (float )0.,      (float )0.000304000000001,      (float )0.000607000000001,      (float )0.000911000000001, 
        (float )0.00121400000001,      (float )0.00151800000001,      (float )0.001821,      (float )0.00212500000001, 
        (float )0.00242800000001,      (float )0.00273200000001,      (float )0.003035,      (float )0.00334700000001, 
        (float )0.00367700000001,      (float )0.004025,      (float )0.004391,      (float )0.004777, 
        (float )0.005182,      (float )0.005605,      (float )0.006049,      (float )0.00651200000001, 
        (float )0.00699500000001,      (float )0.007499,      (float )0.00802300000001,      (float )0.008568, 
        (float )0.009134,      (float )0.00972100000001,      (float )0.0103300000001,      (float )0.01096, 
        (float )0.0116120000001,      (float )0.0122860000001,      (float )0.012983,      (float )0.0137020000001, 
        (float )0.0144440000001,      (float )0.0152090000001,      (float )0.015996,      (float )0.016807, 
        (float )0.0176420000001,      (float )0.0185,      (float )0.019382,      (float )0.0202890000001, 
        (float )0.021219,      (float )0.022174,      (float )0.023153,      (float )0.024158, 
        (float )0.0251870000001,      (float )0.0262410000001,      (float )0.0273210000001,      (float )0.028426, 
        (float )0.029557,      (float )0.0307130000001,      (float )0.0318960000001,      (float )0.0331050000001, 
        (float )0.0343400000001,      (float )0.0356010000001,      (float )0.036889,      (float )0.0382040000001, 
        (float )0.039546,      (float )0.040915,      (float )0.0423110000001,      (float )0.0437350000001, 
        (float )0.045186,      (float )0.046665,      (float )0.048172,      (float )0.0497070000001, 
        (float )0.0512690000001,      (float )0.052861,      (float )0.0544800000001,      (float )0.056128, 
        (float )0.0578050000001,      (float )0.0595110000001,      (float )0.0612460000001,      (float )0.06301, 
        (float )0.064803,      (float )0.0666260000001,      (float )0.068478,      (float )0.0703600000001, 
        (float )0.0722720000001,      (float )0.0742140000001,      (float )0.0761850000001,      (float )0.0781870000001, 
        (float )0.08022,      (float )0.082283,      (float )0.0843760000001,      (float )0.0865, 
        (float )0.088656,      (float )0.0908420000001,      (float )0.0930590000001,      (float )0.0953070000001, 
        (float )0.097587,      (float )0.0998990000001,      (float )0.102242,      (float )0.104616000001, 
        (float )0.107023,      (float )0.109462000001,      (float )0.111932000001,      (float )0.114435, 
        (float )0.116971000001,      (float )0.119538000001,      (float )0.122139,      (float )0.124772, 
        (float )0.127438,      (float )0.130136000001,      (float )0.132868000001,      (float )0.135633000001, 
        (float )0.138432,      (float )0.141263,      (float )0.144128000001,      (float )0.147027, 
        (float )0.149960000001,      (float )0.152926000001,      (float )0.155926000001,      (float )0.158961, 
        (float )0.162029000001,      (float )0.165132000001,      (float )0.168269000001,      (float )0.171441000001, 
        (float )0.174647,      (float )0.177888,      (float )0.181164,      (float )0.184475000001, 
        (float )0.187821,      (float )0.191202000001,      (float )0.194618000001,      (float )0.198069, 
        (float )0.201556000001,      (float )0.205079000001,      (float )0.208637,      (float )0.212231000001, 
        (float )0.215861,      (float )0.219526,      (float )0.223228000001,      (float )0.226966000001, 
        (float )0.230740000001,      (float )0.234551000001,      (float )0.238398,      (float )0.242281, 
        (float )0.246201000001,      (float )0.250158,      (float )0.254152,      (float )0.258183, 
        (float )0.262251000001,      (float )0.266356,      (float )0.270498000001,      (float )0.274677000001, 
        (float )0.278894,      (float )0.283149,      (float )0.287441000001,      (float )0.291771000001, 
        (float )0.296138000001,      (float )0.300544,      (float )0.304987000001,      (float )0.309469, 
        (float )0.313989000001,      (float )0.318547000001,      (float )0.323143000001,      (float )0.327778000001, 
        (float )0.332452000001,      (float )0.337164000001,      (float )0.341914,      (float )0.346704000001, 
        (float )0.351533,      (float )0.3564,      (float )0.361307,      (float )0.366253, 
        (float )0.371238000001,      (float )0.376262,      (float )0.381326,      (float )0.386429000001, 
        (float )0.391572,      (float )0.396755000001,      (float )0.401978000001,      (float )0.40724, 
        (float )0.412543,      (float )0.417885000001,      (float )0.423268,      (float )0.428690000001, 
        (float )0.434154,      (float )0.439657000001,      (float )0.445201000001,      (float )0.450786000001, 
        (float )0.456411000001,      (float )0.462077000001,      (float )0.467784,      (float )0.473531, 
        (float )0.479320000001,      (float )0.485150000001,      (float )0.491021,      (float )0.496933000001, 
        (float )0.502886000001,      (float )0.508881000001,      (float )0.514918,      (float )0.520996000001, 
        (float )0.527115000001,      (float )0.533276,      (float )0.539479000001,      (float )0.545724, 
        (float )0.552011000001,      (float )0.55834,      (float )0.564712,      (float )0.571125, 
        (float )0.57758,      (float )0.584078,      (float )0.590619000001,      (float )0.597202000001, 
        (float )0.603827000001,      (float )0.610496000001,      (float )0.617207,      (float )0.62396, 
        (float )0.630757000001,      (float )0.637597,      (float )0.644480000001,      (float )0.651406000001, 
        (float )0.658375000001,      (float )0.665387,      (float )0.672443000001,      (float )0.679542, 
        (float )0.686685,      (float )0.693872000001,      (float )0.701102000001,      (float )0.708376000001, 
        (float )0.715694000001,      (float )0.723055000001,      (float )0.730461000001,      (float )0.73791, 
        (float )0.745404,      (float )0.752942000001,      (float )0.760525000001,      (float )0.768151000001, 
        (float )0.775822000001,      (float )0.783538,      (float )0.791298,      (float )0.799103000001, 
        (float )0.806952000001,      (float )0.814847,      (float )0.822786000001,      (float )0.830770000001, 
        (float )0.838799,      (float )0.846873,      (float )0.854993000001,      (float )0.863157, 
        (float )0.871367000001,      (float )0.879622000001,      (float )0.887923000001,      (float )0.896269, 
        (float )0.904661000001,      (float )0.913099,      (float )0.921582000001,      (float )0.930111000001, 
        (float )0.938686000001,      (float )0.947307000001,      (float )0.955973,      (float )0.964686000001, 
        (float )0.973445000001,      (float )0.982251,      (float )0.991102000001,      (float )1.};
#line 81 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/rgblinear.h"
static unsigned char const   linear_to_sRGB_table___1[4096]  =    "";
#line 138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
static int text_sizes___1[12]  = 
#line 138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fonts.h"
  {      9,      12,      18,      24, 
        36,      48,      56,      64, 
        96,      112,      128,      160};
#line 160 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/onscreen_keyboard.h"
struct osk_keyboard *osk_create(char *layout_name , SDL_Surface *canvas , SDL_Surface *LG_button_up ,
                                SDL_Surface *LG_button_down , SDL_Surface *LG_button_off ,
                                SDL_Surface *LG_button_nav , SDL_Surface *LG_button_hold ,
                                SDL_Surface *LG_oskdel , SDL_Surface *LG_osktab ,
                                SDL_Surface *LG_oskenter , SDL_Surface *LG_oskcapslock ,
                                SDL_Surface *LG_oskshift , SDL_Surface *SM_button_up ,
                                SDL_Surface *SM_button_down , SDL_Surface *SM_button_off ,
                                SDL_Surface *SM_button_nav , SDL_Surface *SM_button_hold ,
                                SDL_Surface *SM_oskdel , SDL_Surface *SM_osktab ,
                                SDL_Surface *SM_oskenter , SDL_Surface *SM_oskcapslock ,
                                SDL_Surface *SM_oskshift , int disable_change ) ;
#line 173
struct osk_layout *osk_load_layout(char *layout_name ) ;
#line 175
void osk_get_layout_data(char *layout_name , int *layout_w , int *layout_h , char *layout_buttons ,
                         char *layout_labels , char *layout_keycodes ) ;
#line 177
void osk_reset(on_screen_keyboard *osk ) ;
#line 178
struct osk_keyboard *osk_clicked(on_screen_keyboard *keyboard , int x , int y ) ;
#line 179
void osk_released(on_screen_keyboard *osk ) ;
#line 180
void osk_hover(on_screen_keyboard *keyboard , int x , int y ) ;
#line 181
void osk_free(on_screen_keyboard *osk ) ;
#line 182
void osk_change_layout(on_screen_keyboard *osk ) ;
#line 50 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tip_tux.h"
char const   * const  tux_img_fnames[6]  = {      "/usr/local/share/tuxpaint/images/tux/default.png",      "/usr/local/share/tuxpaint/images/tux/kiss.png",      "/usr/local/share/tuxpaint/images/tux/bored.png",      "/usr/local/share/tuxpaint/images/tux/great.png", 
        "/usr/local/share/tuxpaint/images/tux/oops.png",      "/usr/local/share/tuxpaint/images/tux/wait.png"};
#line 60 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
char const   * const  tool_names[16]  = 
#line 60 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
  {      "Paint",      "Stamp",      "Lines",      "Shapes", 
        "Text",      "Label",      "Fill",      "Magic", 
        "Undo",      "Redo",      "Eraser",      "New", 
        "Open",      "Save",      "Print",      "Quit"};
#line 113 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
char const   * const  tool_tips[16]  = 
#line 113
  {      "Pick a color and a brush shape to draw with.",      "Pick a picture to stamp around your drawing.",      "Click to start drawing a line. Let go to complete it.",      "P\256wt\324U", 
        "Choose a style of text. Click on your drawing and you can start typing. Press [Enter] or [Tab] to complete the text.",      "Choose a style of text. Click on your drawing and you can start typing. Press [Enter] or [Tab] to complete the text. By using the selector button and clicking an existing label, you can move it, edit it and change its text style.",      "\323\001 ",      "Pick a magical effect to use on your drawing!", 
        "Undo!",      "Redo!",      "Eraser!",      "Pick a color or picture with which to start a new drawing.", 
        "Open\342\200\246",      "Your image has been saved!",      "Printing\342\200\246",      "Bye bye!\250"};
#line 182 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
char const   * const  tool_img_fnames[16]  = 
#line 182
  {      "/usr/local/share/tuxpaint/images/tools/brush.png",      "/usr/local/share/tuxpaint/images/tools/stamp.png",      "/usr/local/share/tuxpaint/images/tools/lines.png",      "/usr/local/share/tuxpaint/images/tools/shapes.png", 
        "/usr/local/share/tuxpaint/images/tools/text.png",      "/usr/local/share/tuxpaint/images/tools/label.png",      "/usr/local/share/tuxpaint/images/tools/fill.png",      "/usr/local/share/tuxpaint/images/tools/magic.png", 
        "/usr/local/share/tuxpaint/images/tools/undo.png",      "/usr/local/share/tuxpaint/images/tools/redo.png",      "/usr/local/share/tuxpaint/images/tools/eraser.png",      "/usr/local/share/tuxpaint/images/tools/new.png", 
        "/usr/local/share/tuxpaint/images/tools/open.png",      "/usr/local/share/tuxpaint/images/tools/save.png",      "/usr/local/share/tuxpaint/images/tools/print.png",      "/usr/local/share/tuxpaint/images/tools/quit.png"};
#line 204 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tools.h"
int const   tool_tux[16]  = 
#line 204
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        4,      5,      0,      0, 
        0,      3,      3,      0};
#line 53 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/titles.h"
char const   * const  title_names[11]  = 
#line 53 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/titles.h"
  {      "\323\001 ",      "\323\001 ",      "Tools",      "Colors", 
        "Brushes",      "Erasers",      "Stamps",      "Shapes", 
        "Letters",      "Magic",      "Fills"};
#line 61 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/colors.h"
int const   default_color_hexes[17][3]  = 
#line 61 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/colors.h"
  { {        0,        0,        0}, 
   {        128,        128,        128}, 
   {        192,        192,        192}, 
   {        255,        255,        255}, 
   {        255,        0,        0}, 
   {        255,        128,        0}, 
   {        255,        255,        0}, 
   {        160,        228,        128}, 
   {        33,        148,        70}, 
   {        138,        168,        205}, 
   {        50,        100,        255}, 
   {        186,        157,        255}, 
   {        128,        0,        128}, 
   {        255,        165,        211}, 
   {        128,        80,        0}, 
   {        226,        189,        166}, 
   {        247,        228,        219}};
#line 84 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/colors.h"
char const   * const  default_color_names[17]  = 
#line 84
  {      "Black!",      "Dark grey! Some people spell it \342\200\234dark gray\342\200\235.\323\001 ",      "Light grey! Some people spell it \342\200\234light gray\342\200\235.",      "White!", 
        "Red!",      "Orange!",      "Yellow!",      "Light green!", 
        "Dark green!",      "Sky blue!",      "Blue!",      "Lavender!", 
        "Purple!",      "Pink!",      "Brown!",      "Tan!", 
        "Beige!"};
#line 137
char colorfile[256] ;
#line 68 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_sides[22]  = 
#line 68 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
  {      4,      4,      4,      4, 
        72,      72,      72,      72, 
        3,      3,      5,      5, 
        4,      4,      8,      8, 
        3,      3,      4,      4, 
        5,      5};
#line 96 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_locked[22]  = 
#line 96
  {      1,      1,      0,      0, 
        1,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      1,      1, 
        0,      0,      0,      0, 
        0,      0};
#line 124 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_filled[22]  = 
#line 124
  {      0,      1,      0,      1, 
        0,      1,      0,      1, 
        0,      1,      0,      1, 
        0,      1,      0,      1, 
        0,      1,      0,      1, 
        0,      1};
#line 153 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_init_ang[22]  = 
#line 153
  {      45,      45,      45,      45, 
        0,      0,      0,      0, 
        210,      210,      162,      162, 
        0,      0,      22,      22, 
        210,      210,      0,      0, 
        162,      162};
#line 181 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_no_rotate[22]  = 
#line 181
  {      0,      0,      0,      0, 
        1,      1,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0};
#line 208 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
int const   shape_valley[22]  = 
#line 208
  {      100,      100,      100,      100, 
        100,      100,      100,      100, 
        100,      100,      100,      100, 
        100,      100,      100,      100, 
        20,      20,      30,      30, 
        35,      35};
#line 236 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shape_names[22]  = 
#line 236
  {      "Square",      "Square",      "Rectangle",      "Rectangle", 
        "Circle",      "Circle",      "Ellipse",      "Ellipse", 
        "Triangle\323\001 ",      "Triangle\323\001 ",      "Pentagon\323\001 ",      "Pentagon\323\001 ", 
        "Rhombus",      "Rhombus",      "Octagon",      "Octagon", 
        "Star",      "Star",      "Star",      "Star", 
        "Star",      "Star"};
#line 291 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shape_tips[22]  = 
#line 291
  {      "A square is a rectangle with four equal sides.",      "A square is a rectangle with four equal sides.",      "A rectangle has four sides and four right angles.",      "A rectangle has four sides and four right angles.", 
        "A circle is a curve where all points have the same distance from the center.",      "A circle is a curve where all points have the same distance from the center.",      "An ellipse is a stretched circle.",      "An ellipse is a stretched circle.", 
        "A triangle has three sides.",      "A triangle has three sides.",      "A pentagon has five sides.",      "A pentagon has five sides.", 
        "A rhombus has four equal sides, and opposite sides are parallel.\323\001 ",      "A rhombus has four equal sides, and opposite sides are parallel.\323\001 ",      "An octagon has eight equal sides.",      "An octagon has eight equal sides.", 
        "A star with 3 points.",      "A star with 3 points.",      "A star with 4 points.",      "A star with 4 points.", 
        "A star with 5 points.",      "A star with 5 points."};
#line 335 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shape_img_fnames[22]  = 
#line 335
  {      "/usr/local/share/tuxpaint/images/shapes/square.png",      "/usr/local/share/tuxpaint/images/shapes/square_f.png\323\001 ",      "/usr/local/share/tuxpaint/images/shapes/rectangle.png",      "/usr/local/share/tuxpaint/images/shapes/rectangle_f.png", 
        "/usr/local/share/tuxpaint/images/shapes/circle.png",      "/usr/local/share/tuxpaint/images/shapes/circle_f.png\323\001 ",      "/usr/local/share/tuxpaint/images/shapes/oval.png",      "/usr/local/share/tuxpaint/images/shapes/oval_f.png", 
        "/usr/local/share/tuxpaint/images/shapes/triangle.png\323\001 ",      "/usr/local/share/tuxpaint/images/shapes/triangle_f.png",      "/usr/local/share/tuxpaint/images/shapes/pentagon.png\323\001 ",      "/usr/local/share/tuxpaint/images/shapes/pentagon_f.png", 
        "/usr/local/share/tuxpaint/images/shapes/diamond.png",      "/usr/local/share/tuxpaint/images/shapes/diamond_f.png",      "/usr/local/share/tuxpaint/images/shapes/octagon.png",      "/usr/local/share/tuxpaint/images/shapes/octagon_f.png", 
        "/usr/local/share/tuxpaint/images/shapes/star3p.png",      "/usr/local/share/tuxpaint/images/shapes/star3p_f.png\323\001 ",      "/usr/local/share/tuxpaint/images/shapes/star4p.png",      "/usr/local/share/tuxpaint/images/shapes/star4p_f.png\323\001 ", 
        "/usr/local/share/tuxpaint/images/shapes/star5p.png",      "/usr/local/share/tuxpaint/images/shapes/star5p_f.png\250"};
#line 370 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shapemode_img_fnames[2]  = {      "/usr/local/share/tuxpaint/images/ui/shapes_center.png",      "/usr/local/share/tuxpaint/images/ui/shapes_corner.png"};
#line 384 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shape_tool_tips[2]  = {      "Pick a shape. Click to start drawing, drag, and let go when it is the size and shape you want. Move around to rotate it, and click again to draw it.",      "Pick a shape. Click to start drawing, drag, and let go when it is the size and shape you want."};
#line 391 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/shapes.h"
char const   * const  shapemode_tips[22]  = {      "Draw shapes from the center.",      "Draw shapes from a corner."};
#line 35 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/great.h"
char const   * const  great_strs[4]  = {      "Great!",      "Cool!",      "Keep it up!",      "Good job!"};
#line 49 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill_tools.h"
char const   * const  fill_names[4]  = {      "Solid",      "Brush",      "Linear",      "Radial"};
#line 56 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill_tools.h"
char const   * const  fill_tips[4]  = {      "Click to fill an area with a solid color.",      "Click and drag to fill an area by hand, using a brush.",      "Click and drag to fill an area with a linear gradient (from the chosen color to transparent).",      "Click to fill an area with a radial gradient (from the chosen color to transparent)."};
#line 63 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/fill_tools.h"
char const   * const  fill_img_fnames[4]  = {      "/usr/local/share/tuxpaint/images/fills/solid.png",      "/usr/local/share/tuxpaint/images/fills/brush.png",      "/usr/local/share/tuxpaint/images/fills/gradient_linear.png",      "/usr/local/share/tuxpaint/images/fills/gradient_radial.png"};
#line 53 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/im.h"
void im_init(IM_DATA *im , int lang ) ;
#line 54
void im_softreset(IM_DATA *im ) ;
#line 55
int im_read(IM_DATA *im , SDL_keysym ks ) ;
#line 592 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int TP_EventFilter(SDL_Event *event ) ;
#line 688
static int NUM_COLORS ;
#line 689
static Uint8 **color_hexes ;
#line 690
static char **color_names ;
#line 700 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void debug(char const   *str ) 
{ 


  {
  return;
}
}
#line 729
static SDL_Rect r_canvas ;
#line 730
static SDL_Rect r_tools ;
#line 731
static SDL_Rect r_sfx ;
#line 732
static SDL_Rect r_toolopt ;
#line 733
static SDL_Rect r_colors ;
#line 734
static SDL_Rect r_ttools ;
#line 735
static SDL_Rect r_tcolors ;
#line 736
static SDL_Rect r_ttoolopt ;
#line 737
static SDL_Rect r_tuxarea ;
#line 738
static SDL_Rect r_label ;
#line 739
static SDL_Rect old_dest ;
#line 741
static int button_w ;
#line 742
static int button_h ;
#line 743
static float button_scale ;
#line 744
static int color_button_w ;
#line 745
static int color_button_h ;
#line 746
static int colors_rows ;
#line 748
static int buttons_tall ;
#line 752
static grid_dims gd_tools ;
#line 753
static grid_dims gd_sfx ;
#line 754
static grid_dims gd_toolopt ;
#line 759
static grid_dims gd_colors ;
#line 778 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int WINDOW_WIDTH  =    800;
#line 779 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int WINDOW_HEIGHT  =    600;
#line 782
static void magic_putpixel(SDL_Surface *surface , int x , int y , Uint32 pixel ) ;
#line 783
static Uint32 magic_getpixel(SDL_Surface *surface , int x , int y ) ;
#line 784
static void magic_xorpixel(SDL_Surface *surface , int x , int y ) ;
#line 789 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void set_max_buttonscale(void) 
{ 
  float max_w ;
  float max_h ;

  {
  {
#line 794
  max_w = (float )WINDOW_WIDTH / (float )(((int )gd_tools.cols * 48 + 432) + (int )gd_toolopt.cols * 48);
#line 797
  max_h = (float )WINDOW_HEIGHT / (float )((280 + (int )gd_colors.rows * 48) + 56);
#line 799
  button_scale = 0;
#line 800
  fprintf(stderr, "Will use a button size of %d\n", (int )(button_scale * (float )48));
  }
  return;
}
}
#line 808 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void setup_normal_screen_layout(void) 
{ 


  {
#line 810
  button_w = (int )((float )48 * button_scale);
#line 811
  button_h = (int )((float )48 * button_scale);
#line 813
  gd_toolopt.cols = (Uint8 )2;
#line 814
  gd_tools.cols = (Uint8 )2;
#line 816
  r_ttools.x = (Sint16 )0;
#line 817
  r_ttools.y = (Sint16 )0;
#line 818
  r_ttools.w = (Uint16 )((int )gd_tools.cols * button_w);
#line 819
  r_ttools.h = (Uint16 )((float )40 * button_scale);
#line 821
  r_ttoolopt.w = (Uint16 )((int )gd_toolopt.cols * button_w);
#line 822
  r_ttoolopt.h = (Uint16 )((float )40 * button_scale);
#line 823
  r_ttoolopt.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 824
  r_ttoolopt.y = (Sint16 )0;
#line 826
  gd_colors.rows = (Uint8 )colors_rows;
#line 827
  gd_colors.cols = (Uint8 )(((NUM_COLORS + (int )gd_colors.rows) - 1) / (int )gd_colors.rows);
#line 829
  r_colors.h = (Uint16 )(((float )48 * button_scale) * (float )((int )gd_colors.rows));
#line 830
  color_button_h = (int )r_colors.h / (int )gd_colors.rows;
#line 831
  r_tcolors.h = r_colors.h;
#line 833
  r_tcolors.x = (Sint16 )0;
#line 834
  r_tcolors.w = (Uint16 )((int )gd_tools.cols * button_w);
#line 835
  r_colors.x = (Sint16 )r_tcolors.w;
#line 836
  r_colors.w = (Uint16 )(WINDOW_WIDTH - (int )r_tcolors.w);
#line 838
  color_button_w = (int )r_colors.w / (int )gd_colors.cols;
#line 844
  r_canvas.x = (Sint16 )((int )gd_tools.cols * button_w);
#line 845
  r_canvas.y = (Sint16 )0;
#line 846
  r_canvas.w = (Uint16 )(WINDOW_WIDTH - ((int )gd_tools.cols + (int )gd_toolopt.cols) * button_w);
#line 848
  r_tuxarea.x = (Sint16 )0;
#line 849
  r_tuxarea.w = (Uint16 )WINDOW_WIDTH;
#line 852
  buttons_tall = (int )((((float )(WINDOW_HEIGHT - (int )r_ttoolopt.h) - (float )56 * button_scale) - (float )((int )r_colors.h)) / (float )button_h);
#line 853
  if (buttons_tall < 5) {
    {
#line 854
    fprintf(stderr, "Button size \'%d\' with window size \'%dx%d\' is not reasonable (not tall enough).\n",
            button_w, WINDOW_WIDTH, WINDOW_HEIGHT);
#line 856
    set_max_buttonscale();
#line 857
    setup_normal_screen_layout();
    }
  }
#line 860
  if ((int )r_canvas.w < button_w * 9) {
    {
#line 861
    fprintf(stderr, "Button size \'%d\' with window size \'%dx%d\' is not reasonable (not wide enough).\n",
            button_w, WINDOW_WIDTH, WINDOW_HEIGHT);
#line 863
    set_max_buttonscale();
#line 864
    setup_normal_screen_layout();
    }
  }
#line 867
  gd_tools.rows = (Uint8 )buttons_tall;
#line 868
  gd_toolopt.rows = (Uint8 )buttons_tall;
#line 870
  r_canvas.h = (Uint16 )((int )r_ttoolopt.h + buttons_tall * button_h);
#line 872
  r_label = r_canvas;
#line 874
  r_colors.y = (Sint16 )((int )r_canvas.h + (int )r_canvas.y);
#line 875
  r_tcolors.y = (Sint16 )((int )r_canvas.h + (int )r_canvas.y);
#line 877
  r_tuxarea.y = (Sint16 )((int )r_colors.y + (int )r_colors.h);
#line 878
  r_tuxarea.h = (Uint16 )(WINDOW_HEIGHT - (int )r_tuxarea.y);
#line 880
  r_sfx.x = r_tuxarea.x;
#line 881
  r_sfx.y = r_tuxarea.y;
#line 882
  r_sfx.w = (Uint16 )button_w;
#line 883
  r_sfx.h = (Uint16 )(button_h >> 1);
#line 885
  gd_sfx.rows = (Uint8 )1;
#line 886
  gd_sfx.cols = (Uint8 )2;
#line 888
  r_tools.x = (Sint16 )0;
#line 889
  r_tools.y = (Sint16 )((int )r_ttools.h + (int )r_ttools.y);
#line 890
  r_tools.w = (Uint16 )((int )gd_tools.cols * button_w);
#line 891
  r_tools.h = (Uint16 )((int )gd_tools.rows * button_h);
#line 893
  r_toolopt.w = (Uint16 )((int )gd_toolopt.cols * button_w);
#line 894
  r_toolopt.h = (Uint16 )((int )gd_toolopt.rows * button_h);
#line 895
  r_toolopt.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 896
  r_toolopt.y = (Sint16 )((int )r_ttoolopt.h + (int )r_ttoolopt.y);
  return;
}
}
#line 963 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void setup_screen_layout(void) 
{ 


  {
  {
#line 966
  setup_normal_screen_layout();
  }
  return;
}
}
#line 972 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *screen  =    (SDL_Surface *)((void *)0);
#line 973 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *canvas  =    (SDL_Surface *)((void *)0);
#line 974 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *label  =    (SDL_Surface *)((void *)0);
#line 975 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *save_canvas  =    (SDL_Surface *)((void *)0);
#line 976 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *canvas_back  =    (SDL_Surface *)((void *)0);
#line 977 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *img_starter  =    (SDL_Surface *)((void *)0);
#line 977 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *img_starter_bkgd  =    (SDL_Surface *)((void *)0);
#line 988 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_screen(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  int tmp ;

  {
#line 992
  if (x1 > x2) {
#line 994
    tmp = x1;
#line 995
    x1 = x2;
#line 996
    x2 = tmp;
  }
#line 999
  if (y1___0 > y2) {
#line 1001
    tmp = y1___0;
#line 1002
    y1___0 = y2;
#line 1003
    y2 = tmp;
  }
#line 1006
  x1 --;
#line 1007
  x2 ++;
#line 1008
  y1___0 --;
#line 1009
  y2 ++;
#line 1012
  if (x1 < 0) {
#line 1013
    x1 = 0;
  }
#line 1014
  if (x2 < 0) {
#line 1015
    x2 = 0;
  }
#line 1016
  if (y1___0 < 0) {
#line 1017
    y1___0 = 0;
  }
#line 1018
  if (y2 < 0) {
#line 1019
    y2 = 0;
  }
#line 1021
  if (x1 >= WINDOW_WIDTH) {
#line 1022
    x1 = WINDOW_WIDTH - 1;
  }
#line 1023
  if (x2 >= WINDOW_WIDTH) {
#line 1024
    x2 = WINDOW_WIDTH - 1;
  }
#line 1025
  if (y1___0 >= WINDOW_HEIGHT) {
#line 1026
    y1___0 = WINDOW_HEIGHT - 1;
  }
#line 1027
  if (y2 >= WINDOW_HEIGHT) {
#line 1028
    y2 = WINDOW_HEIGHT - 1;
  }
  {
#line 1030
  SDL_UpdateRect(screen, x1, y1___0, (Uint32 )((x2 - x1) + 1), (Uint32 )((y2 - y1___0) + 1));
  }
  return;
}
}
#line 1040 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_screen_rect(SDL_Rect *r ) 
{ 


  {
  {
#line 1042
  SDL_UpdateRect(screen, (Sint32 )r->x, (Sint32 )r->y, (Uint32 )r->w, (Uint32 )r->h);
  }
  return;
}
}
#line 1054 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int hit_test(SDL_Rect *r , unsigned int x , unsigned int y ) 
{ 


  {
#line 1057
  return (x - (unsigned int )r->x < (unsigned int )r->w && y - (unsigned int )r->y < (unsigned int )r->h);
}
}
#line 1072 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int grid_hit_gd(SDL_Rect *r , unsigned int x , unsigned int y , grid_dims *gd ) 
{ 
  unsigned int item_w ;
  unsigned int item_h ;
  unsigned int col ;
  unsigned int row ;

  {
#line 1074
  item_w = (unsigned int )((int )r->w / (int )gd->cols);
#line 1075
  item_h = (unsigned int )((int )r->h / (int )gd->rows);
#line 1076
  col = (x - (unsigned int )r->x) / item_w;
#line 1077
  row = (y - (unsigned int )r->y) / item_h;
#line 1084
  if (col >= (unsigned int )gd->cols) {
#line 1085
    return (- 1);
  } else
#line 1084
  if (row >= (unsigned int )gd->rows) {
#line 1085
    return (- 1);
  }
#line 1086
  return ((int )(col + row * (unsigned int )gd->cols));
}
}
#line 1097
static int disable_label ;
#line 1113 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_canvas_ex_r(int x1 , int y1___0 , int x2 , int y2 , int screen_too ) 
{ 
  SDL_Rect src ;
  SDL_Rect dest ;

  {
#line 1117
  src.x = (Sint16 )x1;
#line 1118
  src.y = (Sint16 )y1___0;
#line 1119
  src.w = (Uint16 )((x2 - x1) + 1);
#line 1120
  src.h = (Uint16 )((y2 - y1___0) + 1);
#line 1122
  dest.x = (Sint16 )x1;
#line 1123
  dest.y = (Sint16 )y1___0;
#line 1124
  dest.w = src.w;
#line 1125
  dest.h = src.h;
#line 1127
  if (img_starter != (void *)0) {
    {
#line 1132
    SDL_UpperBlit(img_starter, & dest, canvas, & dest);
    }
  }
  {
#line 1135
  dest.x = (Sint16 )(x1 + (int )r_ttools.w);
#line 1137
  SDL_UpperBlit(canvas, & src, screen, & dest);
  }
#line 1141
  if (! disable_label) {
    {
#line 1142
    SDL_UpperBlit(label, & src, screen, & dest);
    }
  }
#line 1144
  if (screen_too) {
    {
#line 1145
    update_screen(x1 + (int )r_ttools.w, y1___0, x2 + (int )r_ttools.w, y2);
    }
  }
  return;
}
}
#line 1161 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_canvas_ex(int x1 , int y1___0 , int x2 , int y2 , int screen_too ) 
{ 
  SDL_Rect src ;
  SDL_Rect dest ;

  {
#line 1165
  if (img_starter != (void *)0) {
    {
#line 1170
    src.x = (Sint16 )x1;
#line 1171
    src.y = (Sint16 )y1___0;
#line 1172
    src.w = (Uint16 )((x2 - x1) + 1);
#line 1173
    src.h = (Uint16 )((y2 - y1___0) + 1);
#line 1175
    dest.x = (Sint16 )x1;
#line 1176
    dest.y = (Sint16 )y1___0;
#line 1177
    dest.w = src.w;
#line 1178
    dest.h = src.h;
#line 1180
    SDL_UpperBlit(img_starter, & dest, canvas, & dest);
    }
  }
  {
#line 1183
  SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), screen, & r_canvas);
  }
#line 1187
  if (! disable_label) {
    {
#line 1188
    SDL_UpperBlit(label, (SDL_Rect *)((void *)0), screen, & r_label);
    }
  }
#line 1190
  if (screen_too) {
    {
#line 1191
    update_screen(x1 + (int )r_ttools.w, y1___0, x2 + (int )r_ttools.w, y2);
    }
  }
  return;
}
}
#line 1203 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_canvas(int x1 , int y1___0 , int x2 , int y2 ) 
{ 


  {
  {
#line 1205
  update_canvas_ex(x1, y1___0, x2, y2, 1);
  }
  return;
}
}
#line 1210 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int emulate_button_pressed  =    0;
#line 1211 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int mouseaccessibility  =    0;
#line 1212 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int onscreen_keyboard  =    0;
#line 1213 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char *onscreen_keyboard_layout  =    (char *)((void *)0);
#line 1214 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static on_screen_keyboard *kbd  =    (on_screen_keyboard *)((void *)0);
#line 1215 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int onscreen_keyboard_disable_change  =    0;
#line 1216 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_low_threshold  =    3200;
#line 1217 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_slowness  =    15;
#line 1218 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_maxsteps  =    7;
#line 1219 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_hat_slowness  =    15;
#line 1220 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint32 joystick_hat_timeout  =    (Uint32 )1000;
#line 1221 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_escape  =    255;
#line 1222 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectbrushtool  =    255;
#line 1223 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectstamptool  =    255;
#line 1224 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectlinestool  =    255;
#line 1225 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectshapestool  =    255;
#line 1226 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selecttexttool  =    255;
#line 1227 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectlabeltool  =    255;
#line 1228 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selectmagictool  =    255;
#line 1229 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_undo  =    255;
#line 1230 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_redo  =    255;
#line 1231 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_selecterasertool  =    255;
#line 1232 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_new  =    255;
#line 1233 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_open  =    255;
#line 1234 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_save  =    255;
#line 1235 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_pagesetup  =    255;
#line 1236 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_button_print  =    255;
#line 1237 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_buttons_ignore_len  =    0;
#line 1238
static int joystick_buttons_ignore[256] ;
#line 1239 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint32 old_hat_ticks  =    (Uint32 )0;
#line 1240
static int oldpos_x ;
#line 1241
static int oldpos_y ;
#line 1242
static int disable_screensaver ;
#line 1247
static int fullscreen ;
#line 1249
static int native_screensize ;
#line 1250
static int grab_input ;
#line 1251
static int rotate_orientation ;
#line 1252 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int joystick_dev  =    0;
#line 1254
static int disable_print ;
#line 1255
static int print_delay ;
#line 1256 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int use_print_config  =    1;
#line 1257 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int alt_print_command_default  =    0;
#line 1258
static int want_alt_printcommand ;
#line 1260 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int wheely  =    1;
#line 1261 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int keymouse  =    0;
#line 1262
static int no_button_distinction ;
#line 1263
static int button_down ;
#line 1264
static int scrolling ;
#line 1266 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int promptless_save  =    -1;
#line 1267
static int _promptless_save_over ;
#line 1267
static int _promptless_save_over_ask ;
#line 1267
static int _promptless_save_over_new ;
#line 1268
static int disable_quit ;
#line 1270
static int noshortcuts ;
#line 1271
static int disable_save ;
#line 1272 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int ok_to_use_lockfile  =    1;
#line 1273
static int start_blank ;
#line 1274
static int autosave_on_quit ;
#line 1275 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int no_prompt_on_quit  =    0;
#line 1277
static int dont_do_xor ;
#line 1278
static int dont_load_stamps ;
#line 1279
static int mirrorstamps ;
#line 1280
static int disable_stamp_controls ;
#line 1281 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int stamp_size_override  =    - 1;
#line 1282
static int new_colors_last ;
#line 1287
static int simple_shapes ;
#line 1289
static int only_uppercase ;
#line 1291
static int disable_magic_controls ;
#line 1292
static int disable_shape_controls ;
#line 1294 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int shape_mode  =    0;
#line 1296
static int starter_mirrored ;
#line 1297
static int starter_flipped ;
#line 1298
static int starter_personal ;
#line 1299
static int template_personal ;
#line 1300
static int starter_modified ;
#line 1302
static Uint8 canvas_color_r ;
#line 1302
static Uint8 canvas_color_g ;
#line 1302
static Uint8 canvas_color_b ;
#line 1303
static Uint8 *touched ;
#line 1304
static Uint8 *sim_flood_touched ;
#line 1305 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int sim_flood_x1  =    0;
#line 1305 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int sim_flood_y1  =    0;
#line 1305 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int sim_flood_x2  =    0;
#line 1305 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int sim_flood_y2  =    0;
#line 1306
int fill_x ;
#line 1306
int fill_y ;
#line 1307 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int last_print_time  =    0;
#line 1309
static int shape_radius ;
#line 1334
static struct label_node *start_label_node ;
#line 1335
static struct label_node *current_label_node ;
#line 1336
static struct label_node *first_label_node_in_redo_stack ;
#line 1337
static struct label_node *label_node_to_edit ;
#line 1338
static struct label_node *highlighted_label_node ;
#line 1340
static unsigned int select_texttool_len ;
#line 1341
static wchar_t select_texttool_str[256] ;
#line 1342
static unsigned int select_color ;
#line 1343
static int select_width ;
#line 1344
static int select_height ;
#line 1345
static Uint16 select_x ;
#line 1346
static Uint16 select_y ;
#line 1347
static int select_cur_font ;
#line 1348
static int select_text_state ;
#line 1349
static unsigned int select_text_size ;
#line 1350 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int coming_from_undo_or_redo  =    0;
#line 1353
static void add_label_node(int w , int h , Uint16 x , Uint16 y , SDL_Surface *label_node_surface ) ;
#line 1354
static void load_info_about_label_surface(FILE *lfi ) ;
#line 1356
static struct label_node *search_label_list(struct label_node **ref_head , Uint16 x ,
                                            Uint16 y , int hover ) ;
#line 1357
static void highlight_label_nodes(void) ;
#line 1358
static void cycle_highlighted_label_node(void) ;
#line 1359
static int are_labels(void) ;
#line 1361
static void do_undo_label_node(void) ;
#line 1362
static void do_redo_label_node(void) ;
#line 1363
static void rec_undo_label(void) ;
#line 1365
static void render_all_nodes_starting_at(struct label_node **node ) ;
#line 1366
static void simply_render_node(struct label_node *node ) ;
#line 1368
static void derender_node(struct label_node **ref_head ) ;
#line 1370
static void delete_label_list(struct label_node **ref_head ) ;
#line 1372
static void myblit(SDL_Surface *src_surf , SDL_Rect *src_rect , SDL_Surface *dest_surf ,
                   SDL_Rect *dest_rect ) ;
#line 1374
static void set_label_fonts(void) ;
#line 1376
static void tmp_apply_uncommited_text(void) ;
#line 1377
static void undo_tmp_applied_text(void) ;
#line 1379
static void handle_joyaxismotion(SDL_Event event , int *motioner , int *val_x , int *val_y ) ;
#line 1380
static void handle_joyhatmotion(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ,
                                int *valhat_x , int *valhat_y , int *hatmotioner ,
                                Uint32 *old_hat_ticks___0 ) ;
#line 1382
static void handle_joyballmotion(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ) ;
#line 1383
static void handle_joybuttonupdown(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ) ;
#line 1384
static void handle_motioners(int oldpos_x___0 , int oldpos_y___0 , int motioner ,
                             int hatmotioner , int old_hat_ticks___0 , int val_x ,
                             int val_y , int valhat_x , int valhat_y ) ;
#line 1387
static void handle_joybuttonupdownscl(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ,
                                      SDL_Rect real_r_tools ) ;
#line 1389
char *get_xdg_user_dir(char const   *dir_type , char const   *fallback ) ;
#line 1398
static void update_progress_bar(void) ;
#line 1399
static void special_notify(int flags ) ;
#line 1441
static int num_plugin_files ;
#line 1442
static void *magic_handle[2048] ;
#line 1443
static magic_funcs_t magic_funcs[2048] ;
#line 1445
static magic_t magics[16][128] ;
#line 1446
static int num_magics[16] ;
#line 1447
static int num_magics_total ;
#line 1459
static magic_api *magic_api_struct ;
#line 1471 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char const   *printcommand  =    "lpr";
#line 1472 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char const   *altprintcommand  =    "kprinter\220";
#line 1473
static char const   *papersize ;
#line 121 "/usr/include/fribidi/fribidi-common.h"
extern int fribidi_debug_status(void) ;
#line 129
extern int fribidi_set_debug(int state ) ;
#line 48 "/usr/include/fribidi/fribidi-unicode.h"
extern char const   *fribidi_unicode_version ;
#line 370 "/usr/include/fribidi/fribidi-bidi-types.h"
extern FriBidiCharType fribidi_get_bidi_type(FriBidiChar ch ) ;
#line 380
extern void fribidi_get_bidi_types(FriBidiChar *str , FriBidiStrIndex len , FriBidiCharType *btypes ) ;
#line 396
extern char const   *fribidi_get_bidi_type_name(FriBidiCharType t ) ;
#line 58 "/usr/include/fribidi/fribidi-bidi.h"
extern FriBidiParType fribidi_get_par_direction(FriBidiCharType *bidi_types , FriBidiStrIndex len ) ;
#line 80
extern FriBidiLevel fribidi_get_par_embedding_levels_ex(FriBidiCharType *bidi_types ,
                                                        FriBidiBracketType *bracket_types ,
                                                        FriBidiStrIndex len , FriBidiParType *pbase_dir ,
                                                        FriBidiLevel *embedding_levels ) ;
#line 121
extern FriBidiLevel fribidi_reorder_line(FriBidiFlags flags , FriBidiCharType *bidi_types ,
                                         FriBidiStrIndex len , FriBidiStrIndex off ,
                                         FriBidiParType base_dir , FriBidiLevel *embedding_levels ,
                                         FriBidiChar *visual_str , FriBidiStrIndex *map ) ;
#line 215 "/usr/include/fribidi/fribidi-joining-types.h"
extern FriBidiJoiningType fribidi_get_joining_type(FriBidiChar ch ) ;
#line 225
extern void fribidi_get_joining_types(FriBidiChar *str , FriBidiStrIndex len , FriBidiJoiningType *jtypes ) ;
#line 240
extern char const   *fribidi_get_joining_type_name(FriBidiJoiningType j ) ;
#line 56 "/usr/include/fribidi/fribidi-joining.h"
extern void fribidi_join_arabic(FriBidiCharType *bidi_types , FriBidiStrIndex len ,
                                FriBidiLevel *embedding_levels , FriBidiArabicProp *ar_props ) ;
#line 53 "/usr/include/fribidi/fribidi-mirroring.h"
extern fribidi_boolean fribidi_get_mirror_char(FriBidiChar ch , FriBidiChar *mirrored_ch ) ;
#line 67
extern void fribidi_shape_mirroring(FriBidiLevel *embedding_levels , FriBidiStrIndex len ,
                                    FriBidiChar *str ) ;
#line 55 "/usr/include/fribidi/fribidi-brackets.h"
extern FriBidiBracketType fribidi_get_bracket(FriBidiChar ch ) ;
#line 66
extern void fribidi_get_bracket_types(FriBidiChar *str , FriBidiStrIndex len , FriBidiCharType *types ,
                                      FriBidiBracketType *btypes ) ;
#line 61 "/usr/include/fribidi/fribidi-arabic.h"
extern void fribidi_shape_arabic(FriBidiFlags flags , FriBidiLevel *embedding_levels ,
                                 FriBidiStrIndex len , FriBidiArabicProp *ar_props ,
                                 FriBidiChar *str ) ;
#line 54 "/usr/include/fribidi/fribidi-shape.h"
extern void fribidi_shape(FriBidiFlags flags , FriBidiLevel *embedding_levels , FriBidiStrIndex len ,
                          FriBidiArabicProp *ar_props , FriBidiChar *str ) ;
#line 58 "/usr/include/fribidi/fribidi-char-sets.h"
extern FriBidiStrIndex fribidi_charset_to_unicode(FriBidiCharSet char_set , char const   *s ,
                                                  FriBidiStrIndex len , FriBidiChar *us ) ;
#line 72
extern FriBidiStrIndex fribidi_unicode_to_charset(FriBidiCharSet char_set , FriBidiChar *us ,
                                                  FriBidiStrIndex len , char *s ) ;
#line 84
extern FriBidiCharSet fribidi_parse_charset(char const   *s ) ;
#line 89
extern char const   *fribidi_char_set_name(FriBidiCharSet char_set ) ;
#line 93
extern char const   *fribidi_char_set_title(FriBidiCharSet char_set ) ;
#line 97
extern char const   *fribidi_char_set_desc(FriBidiCharSet char_set ) ;
#line 70 "/usr/include/fribidi/fribidi.h"
extern FriBidiStrIndex fribidi_remove_bidi_marks(FriBidiChar *str , FriBidiStrIndex len ,
                                                 FriBidiStrIndex *positions_to_this ,
                                                 FriBidiStrIndex *position_from_this_list ,
                                                 FriBidiLevel *embedding_levels ) ;
#line 99
extern FriBidiLevel fribidi_log2vis(FriBidiChar *str , FriBidiStrIndex len , FriBidiParType *pbase_dir ,
                                    FriBidiChar *visual_str , FriBidiStrIndex *positions_L_to_V ,
                                    FriBidiStrIndex *positions_V_to_L , FriBidiLevel *embedding_levels ) ;
#line 44 "/usr/include/fribidi/fribidi-deprecated.h"
extern fribidi_boolean fribidi_mirroring_status(void) ;
#line 62
extern fribidi_boolean fribidi_set_mirroring(fribidi_boolean state ) ;
#line 71
extern fribidi_boolean fribidi_reorder_nsm_status(void) ;
#line 91
extern fribidi_boolean fribidi_set_reorder_nsm(fribidi_boolean state ) ;
#line 103
extern FriBidiLevel fribidi_log2vis_get_embedding_levels(FriBidiCharType *bidi_types ,
                                                         FriBidiStrIndex len , FriBidiParType *pbase_dir ,
                                                         FriBidiLevel *embedding_levels ) ;
#line 117
extern FriBidiCharType fribidi_get_type(FriBidiChar ch ) ;
#line 126
extern FriBidiCharType fribidi_get_type_internal(FriBidiChar ch ) ;
#line 136
extern FriBidiLevel fribidi_get_par_embedding_levels(FriBidiCharType *bidi_types ,
                                                     FriBidiStrIndex len , FriBidiParType *pbase_dir ,
                                                     FriBidiLevel *embedding_levels ) ;
#line 120 "/usr/include/fribidi/fribidi.h"
extern char const   *fribidi_version_info ;
#line 1498 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *undo_bufs[20] ;
#line 1499
static int undo_starters[20] ;
#line 1500
static int cur_undo ;
#line 1500
static int oldest_undo ;
#line 1500
static int newest_undo ;
#line 1501
static int text_undo[20] ;
#line 1502
static int have_to_rec_label_node ;
#line 1503
static int have_to_rec_label_node_back ;
#line 1504
static SDL_Surface *img_title ;
#line 1504
static SDL_Surface *img_title_credits ;
#line 1504
static SDL_Surface *img_title_tuxpaint ;
#line 1505
static SDL_Surface *img_btn_up ;
#line 1505
static SDL_Surface *img_btn_down ;
#line 1505
static SDL_Surface *img_btn_off ;
#line 1505
static SDL_Surface *img_btn_hold ;
#line 1506
static SDL_Surface *img_btnsm_up ;
#line 1506
static SDL_Surface *img_btnsm_off ;
#line 1506
static SDL_Surface *img_btnsm_down ;
#line 1506
static SDL_Surface *img_btnsm_hold ;
#line 1507
static SDL_Surface *img_btn_nav ;
#line 1507
static SDL_Surface *img_btnsm_nav ;
#line 1508
static SDL_Surface *img_brush_anim ;
#line 1508
static SDL_Surface *img_brush_dir ;
#line 1509
static SDL_Surface *img_prev ;
#line 1509
static SDL_Surface *img_next ;
#line 1510
static SDL_Surface *img_mirror ;
#line 1510
static SDL_Surface *img_flip ;
#line 1511
static SDL_Surface *img_dead40x40 ;
#line 1512
static SDL_Surface *img_black ;
#line 1512
static SDL_Surface *img_grey ;
#line 1513
static SDL_Surface *img_yes ;
#line 1513
static SDL_Surface *img_no ;
#line 1514
static SDL_Surface *img_sfx ;
#line 1514
static SDL_Surface *img_speak ;
#line 1515
static SDL_Surface *img_open ;
#line 1515
static SDL_Surface *img_erase ;
#line 1515
static SDL_Surface *img_back ;
#line 1515
static SDL_Surface *img_trash ;
#line 1515
static SDL_Surface *img_pict_export ;
#line 1516
static SDL_Surface *img_slideshow ;
#line 1516
static SDL_Surface *img_play ;
#line 1516
static SDL_Surface *img_gif_export ;
#line 1516
static SDL_Surface *img_select_digits ;
#line 1517
static SDL_Surface *img_printer ;
#line 1517
static SDL_Surface *img_printer_wait ;
#line 1518
static SDL_Surface *img_save_over ;
#line 1518
static SDL_Surface *img_popup_arrow ;
#line 1519
static SDL_Surface *img_cursor_up ;
#line 1519
static SDL_Surface *img_cursor_down ;
#line 1520
static SDL_Surface *img_cursor_starter_up ;
#line 1520
static SDL_Surface *img_cursor_starter_down ;
#line 1521
static SDL_Surface *img_scroll_up ;
#line 1521
static SDL_Surface *img_scroll_down ;
#line 1522
static SDL_Surface *img_scroll_up_off ;
#line 1522
static SDL_Surface *img_scroll_down_off ;
#line 1523
static SDL_Surface *img_grow ;
#line 1523
static SDL_Surface *img_shrink ;
#line 1524
static SDL_Surface *img_magic_paint ;
#line 1524
static SDL_Surface *img_magic_fullscreen ;
#line 1525
static SDL_Surface *img_shapes_corner ;
#line 1525
static SDL_Surface *img_shapes_center ;
#line 1526
static SDL_Surface *img_bold ;
#line 1526
static SDL_Surface *img_italic ;
#line 1527
static SDL_Surface *img_label ;
#line 1527
static SDL_Surface *img_label_select ;
#line 1528
static SDL_Surface *img_color_picker ;
#line 1528
static SDL_Surface *img_color_picker_thumb ;
#line 1528
static SDL_Surface *img_paintwell ;
#line 1528
static SDL_Surface *img_color_sel ;
#line 1529
static int color_picker_x ;
#line 1529
static int color_picker_y ;
#line 1531
static SDL_Surface *img_title_on ;
#line 1531
static SDL_Surface *img_title_off ;
#line 1531
static SDL_Surface *img_title_large_on ;
#line 1531
static SDL_Surface *img_title_large_off ;
#line 1532
static SDL_Surface *img_title_names[11] ;
#line 1533
static SDL_Surface *img_tools[16] ;
#line 1533
static SDL_Surface *img_tool_names[16] ;
#line 1535
static SDL_Surface *img_oskdel ;
#line 1535
static SDL_Surface *img_osktab ;
#line 1535
static SDL_Surface *img_oskenter ;
#line 1535
static SDL_Surface *img_oskcapslock ;
#line 1535
static SDL_Surface *img_oskshift ;
#line 1536
static SDL_Surface *thumbnail(SDL_Surface *src , int max_x , int max_y , int keep_aspect ) ;
#line 1537
static SDL_Surface *thumbnail2(SDL_Surface *src , int max_x , int max_y , int keep_aspect ,
                               int keep_alpha ) ;
#line 1540
static SDL_Surface *zoom(SDL_Surface *src , int new_w , int new_h ) ;
#line 1552 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *render_text(TuxPaint_Font *font , char const   *str , SDL_Color color ) 
{ 
  SDL_Surface *ret ;
  int height ;
  SDLPango_Matrix pango_color ;
  SDL_Surface *__cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;

  {
#line 1554
  ret = (SDL_Surface *)((void *)0);
#line 1561
  if (font == (void *)0) {
    {
#line 1563
    fprintf(stderr, "render_text() received a NULL font!\n");
#line 1564
    fflush(stdout);
    }
#line 1565
    return ((SDL_Surface *)((void *)0));
  }
#line 1569
  if (font->typ == 0) {
    {
#line 1571
    sdl_color_to_pango_color(color, & pango_color);
#line 1578
    SDLPango_SetDefaultColor(font->pango_context, & pango_color);
#line 1579
    SDLPango_SetText(font->pango_context, str, - 1);
#line 1580
    ret = SDLPango_CreateSurfaceDraw(font->pango_context);
    }
  }
#line 1584
  if (font->typ == 1) {
    {
#line 1591
    ret = TTF_RenderUTF8_Blended(font->ttf_font, str, color);
    }
  }
#line 1594
  if (ret) {
#line 1595
    return (ret);
  }
  {
#line 1601
  height = 2;
#line 1603
  __cil_tmp9 = strlen(str);
#line 1603
  __cil_tmp10 = thumbnail(img_title_large_off, (int )(((unsigned long )height * __cil_tmp9) / 2UL),
                          height, 0);
  }
#line 1603
  return (__cil_tmp10);
}
}
#line 1618 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint16 *wcstou16(wchar_t *str ) 
{ 
  unsigned int i ;
  unsigned int len ;
  unsigned long __cil_tmp4 ;
  Uint16 *res ;
  void *__cil_tmp6 ;

  {
  {
#line 1620
  __cil_tmp4 = wcslen(str);
#line 1620
  len = (unsigned int )__cil_tmp4;
#line 1621
  __cil_tmp6 = malloc((unsigned long )(len + 1U) * sizeof(Uint16 ));
#line 1621
  res = __cil_tmp6;
#line 1623
  i = (unsigned int )0;
  }
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    if (! (i < len + 1U)) {
#line 1623
      goto while_break;
    }
#line 1630
    *(res + i) = (Uint16 )*(str + i);
#line 1623
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1633
  return (res);
}
}
#line 1645 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *render_text_w(TuxPaint_Font *font , wchar_t *str , SDL_Color color ) 
{ 
  SDL_Surface *ret ;
  int height ;
  Uint16 *ustr ;
  unsigned int i ;
  unsigned int j ;
  int utfstr_max ;
  char *utfstr ;
  SDLPango_Matrix pango_color ;
  unsigned long __cil_tmp12 ;
  void *__cil_tmp13 ;
  unsigned long __cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;
  unsigned int __cil_tmp17 ;
  unsigned int __cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  unsigned int __cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  unsigned int __cil_tmp25 ;
  SDL_Surface *__cil_tmp26 ;
  Uint16 *__cil_tmp27 ;
  SDL_Surface *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  SDL_Surface *__cil_tmp30 ;

  {
#line 1647
  ret = (SDL_Surface *)((void *)0);
#line 1659
  if (font->typ == 0) {
    {
#line 1661
    sdl_color_to_pango_color(color, & pango_color);
#line 1663
    SDLPango_SetDefaultColor(font->pango_context, & pango_color);
#line 1667
    __cil_tmp12 = wcslen(str);
#line 1667
    utfstr_max = (int )((sizeof(char ) * 4UL) * (__cil_tmp12 + 1UL));
#line 1668
    __cil_tmp13 = malloc((unsigned long )utfstr_max);
#line 1668
    utfstr = (char *)__cil_tmp13;
#line 1669
    memset(utfstr, 0, (unsigned long )utfstr_max);
#line 1671
    j = (unsigned int )0;
#line 1672
    i = (unsigned int )0;
    }
    {
#line 1672
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1672
      if (! ((unsigned long )i < __cil_tmp14)) {
#line 1672
        goto while_break;
      }
#line 1674
      if (*(str + i) <= 127) {
#line 1681
        __cil_tmp15 = j;
#line 1681
        j ++;
#line 1681
        *(utfstr + __cil_tmp15) = (char )(*(str + i) & 127);
      } else
#line 1683
      if (*(str + i) <= 2047) {
#line 1690
        __cil_tmp16 = j;
#line 1690
        j ++;
#line 1690
        *(utfstr + __cil_tmp16) = (char )((((*(str + i) & 1792) >> 6) | ((*(str + i) & 192) >> 6)) | 192);
#line 1694
        __cil_tmp17 = j;
#line 1694
        j ++;
#line 1694
        *(utfstr + __cil_tmp17) = (char )((*(str + i) & 63) | 128);
      } else
#line 1698
      if (*(str + i) <= 65535) {
#line 1711
        __cil_tmp18 = j;
#line 1711
        j ++;
#line 1711
        *(utfstr + __cil_tmp18) = (char )(((*(str + i) & 61440) >> 12) | 224);
#line 1713
        __cil_tmp19 = j;
#line 1713
        j ++;
#line 1713
        *(utfstr + __cil_tmp19) = (char )(((*(str + i) & 4032) >> 6) | 128);
#line 1715
        __cil_tmp20 = j;
#line 1715
        j ++;
#line 1715
        *(utfstr + __cil_tmp20) = (char )((*(str + i) & 63) | 128);
      } else {
#line 1727
        __cil_tmp21 = j;
#line 1727
        j ++;
#line 1727
        *(utfstr + __cil_tmp21) = (char )(((*(str + i) & 1835008) >> 18) | 240);
#line 1729
        __cil_tmp22 = j;
#line 1729
        j ++;
#line 1729
        *(utfstr + __cil_tmp22) = (char )((((*(str + i) & 196608) >> 12) | ((*(str + i) & 61440) >> 12)) | 128);
#line 1732
        __cil_tmp23 = j;
#line 1732
        j ++;
#line 1732
        *(utfstr + __cil_tmp23) = (char )((((*(str + i) & 3840) >> 6) | ((*(str + i) & 192) >> 6)) | 128);
#line 1735
        __cil_tmp24 = j;
#line 1735
        j ++;
#line 1735
        *(utfstr + __cil_tmp24) = (char )((*(str + i) & 63) | 128);
      }
#line 1672
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1740
    *(utfstr + j) = (char )'\000';
#line 1743
    SDLPango_SetText(font->pango_context, (char const   *)utfstr, - 1);
#line 1744
    ret = SDLPango_CreateSurfaceDraw(font->pango_context);
    }
  }
#line 1748
  if (font->typ == 1) {
    {
#line 1750
    ustr = wcstou16(str);
#line 1751
    ret = TTF_RenderUNICODE_Blended(font->ttf_font, ustr, color);
#line 1752
    free(ustr);
    }
  }
#line 1755
  if (ret) {
#line 1756
    return (ret);
  }
  {
#line 1762
  height = 2;
#line 1763
  __cil_tmp29 = wcslen(str);
#line 1763
  __cil_tmp30 = thumbnail(img_title_large_off, (int )(((unsigned long )height * __cil_tmp29) / 2UL),
                          height, 0);
  }
#line 1763
  return (__cil_tmp30);
}
}
#line 1809 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static unsigned int stamp_group_dir_depth  =    (unsigned int )1;
#line 1811 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int stamp_group  =    0;
#line 1813
static char const   *load_stamp_basedir ;
#line 1814 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int num_stamp_groups  =    0;
#line 1815
static int num_stamps[256] ;
#line 1816
static int max_stamps[256] ;
#line 1817
static stamp_type **stamp_data[256] ;
#line 1819
static SDL_Surface *active_stamp ;
#line 1828 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int stamp_colorable(int stamp ) 
{ 


  {
#line 1830
  return ((int )(*(stamp_data[stamp_group] + stamp))->colorable);
}
}
#line 1839 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int stamp_tintable(int stamp ) 
{ 


  {
#line 1841
  return ((int )(*(stamp_data[stamp_group] + stamp))->tintable);
}
}
#line 1846
static int num_brushes ;
#line 1846
static int num_brushes_max ;
#line 1846 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int shape_brush  =    0;
#line 1847
static SDL_Surface **img_brushes ;
#line 1847
static SDL_Surface **img_brushes_thumbs ;
#line 1848 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int *brushes_frames  =    (int *)((void *)0);
#line 1849 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int *brushes_spacing  =    (int *)((void *)0);
#line 1850 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static short *brushes_directional  =    (short *)((void *)0);
#line 1851 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static short *brushes_rotate  =    (short *)((void *)0);
#line 1853
static SDL_Surface *img_shapes[22] ;
#line 1853
static SDL_Surface *img_shape_names[22] ;
#line 1854
static SDL_Surface *img_fills[4] ;
#line 1854
static SDL_Surface *img_fill_names[4] ;
#line 1855
static SDL_Surface *img_openlabels_open ;
#line 1855
static SDL_Surface *img_openlabels_erase ;
#line 1856
static SDL_Surface *img_openlabels_slideshow ;
#line 1856
static SDL_Surface *img_openlabels_back ;
#line 1856
static SDL_Surface *img_openlabels_play ;
#line 1857
static SDL_Surface *img_openlabels_gif_export ;
#line 1857
static SDL_Surface *img_openlabels_pict_export ;
#line 1857
static SDL_Surface *img_openlabels_next ;
#line 1859
static SDL_Surface *img_tux[6] ;
#line 1861
static SDL_Surface *img_mouse ;
#line 1861
static SDL_Surface *img_mouse_click ;
#line 1866
static SDL_Surface **img_color_btns ;
#line 1867
static SDL_Surface *img_color_btn_off ;
#line 1870
static int colors_are_selectable ;
#line 1885
static SDL_Surface *img_cur_brush ;
#line 1886
static int img_cur_brush_frame_w ;
#line 1886
static int img_cur_brush_w ;
#line 1886
static int img_cur_brush_h ;
#line 1887
static int img_cur_brush_frames ;
#line 1887
static int img_cur_brush_directional ;
#line 1887
static int img_cur_brush_rotate ;
#line 1888
static int img_cur_brush_spacing ;
#line 1889
static int brush_counter ;
#line 1889
static int brush_frame ;
#line 1899
static unsigned int cur_color ;
#line 1900
static int cur_tool ;
#line 1900
static int cur_brush ;
#line 1900
static int old_tool ;
#line 1901 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int magic_group  =    0;
#line 1902
static int cur_stamp[256] ;
#line 1903
static int cur_shape ;
#line 1903
static int cur_magic[16] ;
#line 1904
static int cur_font ;
#line 1904
static int cur_eraser ;
#line 1904
static int cur_fill ;
#line 1904
static int fill_drag_started ;
#line 1905
static int cursor_left ;
#line 1905
static int cursor_x ;
#line 1905
static int cursor_y ;
#line 1905
static int cursor_textwidth ;
#line 1906
static int old_cursor_x ;
#line 1906
static int old_cursor_y ;
#line 1907
static int cur_label ;
#line 1907
static int cur_select ;
#line 1908
static int been_saved ;
#line 1909
static char file_id[4096] ;
#line 1910
static char starter_id[4096] ;
#line 1911
static char template_id[4096] ;
#line 1912
static int brush_scroll ;
#line 1913
static int stamp_scroll[256] ;
#line 1914
static int magic_scroll[16] ;
#line 1915
static int font_scroll ;
#line 1915
static int tool_scroll ;
#line 1916
static int eraser_scroll ;
#line 1916
static int shape_scroll ;
#line 1916
static int fill_scroll ;
#line 1918
static int eraser_sound ;
#line 1920
static IM_DATA im_data ;
#line 1921
static wchar_t texttool_str[256] ;
#line 1922
static unsigned int texttool_len ;
#line 1924
static int tool_avail[16] ;
#line 1924
static int tool_avail_bak[16] ;
#line 1926
static Uint32 cur_toggle_count ;
#line 1928
static int num_wished_langs ;
#line 1953
static SDL_Event scrolltimer_event ;
#line 1955 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int non_left_click_count  =    0;
#line 1964
SDL_Joystick *joystick ;
#line 1968
static void mainloop(void) ;
#line 1969
static void brush_draw(int x1 , int y1___0 , int x2 , int y2 , int update ) ;
#line 1970
static void blit_brush(int x , int y , int direction , double rotation , int *w ,
                       int *h ) ;
#line 1971
static void stamp_draw(int x , int y ) ;
#line 1972
static void rec_undo_buffer(void) ;
#line 1976
static char *progname ;
#line 1978
static SDL_Cursor *get_cursor(unsigned char *bits , unsigned char *mask_bits , unsigned int width ,
                              unsigned int height , unsigned int x , unsigned int y ) ;
#line 1980
static void seticon(void) ;
#line 1981
static SDL_Surface *loadimage(char const   *fname ) ;
#line 1982
static SDL_Surface *do_loadimage(char const   *fname , int abort_on_error ) ;
#line 1983
static void draw_toolbar(void) ;
#line 1984
static void draw_magic(void) ;
#line 1985
static void draw_brushes(void) ;
#line 1986
static void draw_stamps(void) ;
#line 1987
static void draw_shapes(void) ;
#line 1988
static void draw_erasers(void) ;
#line 1989
static void draw_fonts(void) ;
#line 1990
static void draw_fills(void) ;
#line 1991
static void draw_none(void) ;
#line 1993
static void do_undo(void) ;
#line 1994
static void do_redo(void) ;
#line 1995
static void render_brush(void) ;
#line 1996
static void _xorpixel(SDL_Surface *surf , int x , int y ) ;
#line 1997
static void line_xor(int x1 , int y1___0 , int x2 , int y2 ) ;
#line 1998
static void rect_xor(int x1 , int y1___0 , int x2 , int y2 ) ;
#line 1999
static void draw_blinking_cursor(void) ;
#line 2000
static void hide_blinking_cursor(void) ;
#line 2002
void reset_brush_counter(void) ;
#line 2013
static void stamp_xor(int x , int y ) ;
#line 2014
static void update_stamp_xor(void) ;
#line 2017
static void set_active_stamp(void) ;
#line 2019
static int calc_eraser_size(int which_eraser ) ;
#line 2020
static void do_eraser(int x , int y , int update ) ;
#line 2021
static void eraser_draw(int x1 , int y1___0 , int x2 , int y2 ) ;
#line 2022
static void disable_avail_tools(void) ;
#line 2023
static void enable_avail_tools(void) ;
#line 2024
static void reset_avail_tools(void) ;
#line 2025
static int compare_dirent2s(struct dirent2 *f1 , struct dirent2 *f2 ) ;
#line 2026
static void redraw_tux_text(void) ;
#line 2027
static void draw_tux_text(int which_tux , char const   *str , int want_right_to_left ) ;
#line 2028
static void draw_tux_text_ex(int which_tux , char const   *str , int want_right_to_left ,
                             Uint8 locale_text ) ;
#line 2029
static void draw_cur_tool_tip(void) ;
#line 2030
static void wordwrap_text(char const   *str , SDL_Color color , int left , int top ,
                          int right , int want_right_to_left ) ;
#line 2031
static void wordwrap_text_ex(char const   *str , SDL_Color color , int left , int top ,
                             int right , int want_right_to_left , Uint8 locale_text ) ;
#line 2033
static char *loaddesc(char const   *fname , Uint8 *locale_text ) ;
#line 2034
static double loadinfo(char const   *fname , stamp_type *inf ) ;
#line 2037
static Mix_Chunk *loadsound(char const   *fname ) ;
#line 2038
static Mix_Chunk *loaddescsound(char const   *fname ) ;
#line 2039
static void playstampdesc(int chan ) ;
#line 2041
static void do_wait(int counter ) ;
#line 2042
static void load_current(void) ;
#line 2043
static void save_current(void) ;
#line 2044
static int do_prompt_image_flash(char const   *text , char const   *btn_yes , char const   *btn_no ,
                                 SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                                 int animate , int ox , int oy ) ;
#line 2048
static int do_prompt_image_flash_snd(char const   *text , char const   *btn_yes ,
                                     char const   *btn_no , SDL_Surface *img1 , SDL_Surface *img2 ,
                                     SDL_Surface *img3 , int animate , int snd , int ox ,
                                     int oy ) ;
#line 2053
static int do_prompt_image(char const   *text , char const   *btn_yes , char const   *btn_no ,
                           SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                           int ox , int oy ) ;
#line 2056
static int do_prompt_image_snd(char const   *text , char const   *btn_yes , char const   *btn_no ,
                               SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                               int snd , int ox , int oy ) ;
#line 2060
static int do_prompt(char const   *text , char const   *btn_yes , char const   *btn_no ,
                     int ox , int oy ) ;
#line 2061
static int do_prompt_snd(char const   *text , char const   *btn_yes , char const   *btn_no ,
                         int snd , int ox , int oy ) ;
#line 2063
static void cleanup(void) ;
#line 2064
static void free_surface(SDL_Surface **surface_array ) ;
#line 2065
static void free_surface_array(SDL_Surface *surface_array[] , int count ) ;
#line 2069
static void do_shape(int sx , int sy , int nx , int ny , int rotn , int use_brush ) ;
#line 2070
static int shape_rotation(int ctr_x , int ctr_y , int ox , int oy ) ;
#line 2071
static int brush_rotation(int ctr_x , int ctr_y , int ox , int oy ) ;
#line 2072
static int do_save(int tool , int dont_show_success_results ) ;
#line 2073
static int do_png_save(FILE *fi , char const   *fname , SDL_Surface *surf , int embed ) ;
#line 2074
void load_embedded_data(char *fname , SDL_Surface *org_surf ) ;
#line 2075
int chunk_is_valid(char const   *chunk_name , png_unknown_chunk unknown ) ;
#line 2076
Bytef *get_chunk_data(FILE *fp , char *fname , png_structp png_ptr , png_infop info_ptr ,
                      char const   *chunk_name , png_unknown_chunk unknown , int *unc_size ) ;
#line 2078
static void get_new_file_id(void) ;
#line 2079
static int do_quit(int tool ) ;
#line 2080
static int do_open(void) ;
#line 2081
static int do_new_dialog(void) ;
#line 2082
static int do_new_dialog_add_colors(SDL_Surface **thumbs , int num_files , int *d_places ,
                                    char **d_names , char **d_exts , int *white_in_palette ) ;
#line 2084
static int do_color_picker(void) ;
#line 2085
static int do_color_sel(void) ;
#line 2087
static int do_slideshow(void) ;
#line 2088
static void play_slideshow(int *selected , int num_selected , char *dirname___0 ,
                           char **d_names , char **d_exts , int speed ) ;
#line 2089
static void draw_selection_digits(int right , int bottom , int n ) ;
#line 2091
static int export_gif(int *selected , int num_selected , char *dirname___0 , char **d_names ,
                      char **d_exts , int speed ) ;
#line 2092
int export_gif_monitor_events(void) ;
#line 2093
static int export_pict(char *fname ) ;
#line 2094
static char *get_export_filepath(char const   *ext ) ;
#line 2096
static void wait_for_sfx(void) ;
#line 2097
static void rgbtohsv(Uint8 r8 , Uint8 g8 , Uint8 b8 , float *h , float *s , float *v ) ;
#line 2098
static void hsvtorgb(float h , float s , float v , Uint8 *r8 , Uint8 *g8 , Uint8 *b8 ) ;
#line 2100
SDL_Surface *flip_surface(SDL_Surface *s ) ;
#line 2101
SDL_Surface *mirror_surface(SDL_Surface *s ) ;
#line 2103
static void print_image(void) ;
#line 2104
void do_print(void) ;
#line 2105
static void strip_trailing_whitespace(char *buf ) ;
#line 2106
static void do_render_cur_text(int do_blit ) ;
#line 2107
static char *uppercase(char const   *str ) ;
#line 2108
static wchar_t *uppercase_w(wchar_t *str ) ;
#line 2109
static char *textdir(char const   *str ) ;
#line 2110
static SDL_Surface *do_render_button_label(char const   *label___0 ) ;
#line 2111
static void create_button_labels(void) ;
#line 2112
static Uint32 scrolltimer_callback(Uint32 interval , void *param ) ;
#line 2113
static Uint32 drawtext_callback(Uint32 interval , void *param ) ;
#line 2114
static void control_drawtext_timer(Uint32 interval , char const   *text , Uint8 locale_text ) ;
#line 2115
static char const   *great_str(void) ;
#line 2116
static void draw_image_title(int t , SDL_Rect dest ) ;
#line 2117
static void handle_keymouse(SDLKey key , Uint8 updown , int steps , SDL_Rect *area1 ,
                            SDL_Rect *area2 ) ;
#line 2118
static void handle_keymouse_buttons(SDLKey key , int *whicht , int *whichc , SDL_Rect real_r_tools ) ;
#line 2119
static void handle_active(SDL_Event *event ) ;
#line 2125
static void load_starter_id(char *saved_id , FILE *fil ) ;
#line 2126
static void load_starter(char *img_id ) ;
#line 2127
static void load_template(char *img_id ) ;
#line 2128
static SDL_Surface *duplicate_surface(SDL_Surface *orig ) ;
#line 2129
static void mirror_starter(void) ;
#line 2130
static void flip_starter(void) ;
#line 2131
static int valid_click(Uint8 button ) ;
#line 2132
static int in_circle_rad(int x , int y , int rad ) ;
#line 2133
static int paintsound(int size ) ;
#line 2134
static void load_magic_plugins(void) ;
#line 2135
static int magic_sort(void const   *a , void const   *b ) ;
#line 2137
Mix_Chunk *magic_current_snd_ptr ;
#line 2138
static void magic_playsound(Mix_Chunk *snd , int left_right , int up_down ) ;
#line 2139
static void magic_stopsound(void) ;
#line 2140
static void magic_line_func(void *mapi , int which , SDL_Surface *canvas___0 , SDL_Surface *last ,
                            int x1 , int y1___0 , int x2 , int y2 , int step , void (*cb)(void * ,
                                                                                          int  ,
                                                                                          SDL_Surface * ,
                                                                                          SDL_Surface * ,
                                                                                          int  ,
                                                                                          int  ) ) ;
#line 2145
static Uint8 magic_linear_to_sRGB(float lin ) ;
#line 2146
static float magic_sRGB_to_linear(Uint8 srgb ) ;
#line 2147
static int magic_button_down(void) ;
#line 2148
static SDL_Surface *magic_scale(SDL_Surface *surf , int w , int h , int aspect ) ;
#line 2149
static void reset_touched(void) ;
#line 2150
static Uint8 magic_touched(int x , int y ) ;
#line 2152
static void magic_switchin(SDL_Surface *last ) ;
#line 2153
static void magic_switchout(SDL_Surface *last ) ;
#line 2154
static int magic_modeint(int mode ) ;
#line 2161
static SDL_Surface *load_kpx(char const   *file ) ;
#line 2164
static SDL_Surface *load_svg(char const   *file ) ;
#line 2165
static float pick_best_scape(unsigned int orig_w , unsigned int orig_h , unsigned int max_w ,
                             unsigned int max_h ) ;
#line 2167
static SDL_Surface *myIMG_Load_RWops(char const   *file ) ;
#line 2168
static SDL_Surface *myIMG_Load(char const   *file ) ;
#line 2169
static int trash(char *path ) ;
#line 2170
int file_exists(char *path ) ;
#line 2172
int generate_fontconfig_cache_spinner(SDL_Surface *screen___0 ) ;
#line 2174
char *safe_strncat(char *dest , char const   *src , size_t n ) ;
#line 2175
char *safe_strncpy(char *dest , char const   *src , size_t n ) ;
#line 2176
int safe_snprintf(char *str , size_t size , char const   *format  , ...) ;
#line 2185
static int bypass_splash_wait ;
#line 2192 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_wait(int counter ) 
{ 
  SDL_Event event ;
  int done ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2197
  if (bypass_splash_wait) {
#line 2198
    return;
  }
#line 2200
  done = 0;
  {
#line 2202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2204
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2204
      __cil_tmp4 = SDL_PollEvent(& event);
      }
#line 2204
      if (! __cil_tmp4) {
#line 2204
        goto while_break___0;
      }
#line 2206
      if ((int )event.type == 12) {
#line 2208
        done = 1;
      } else
#line 2212
      if ((int )event.type == 1) {
        {
#line 2214
        handle_active(& event);
        }
      } else
#line 2216
      if ((int )event.type == 2) {
#line 2218
        done = 1;
      } else {
        {
#line 2220
        __cil_tmp5 = valid_click(event.button.button);
        }
#line 2220
        if ((int )event.type == 5) {
#line 2220
          if (__cil_tmp5) {
#line 2222
            done = 1;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2226
    __cil_tmp6 = counter;
#line 2226
    counter --;
#line 2227
    SDL_Delay((Uint32 )100);
    }
#line 2202
    if (! (! done && counter > 0)) {
#line 2202
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 2310
int shape_reverse ;
#line 2313
int brushflag ;
#line 2313
int xnew ;
#line 2313
int ynew ;
#line 2313
int eraflag ;
#line 2313
int lineflag ;
#line 2313
int magicflag ;
#line 2313
int keybd_flag ;
#line 2313
int keybd_position ;
#line 2313
int keyglobal ;
#line 2313
int initial_y ;
#line 2313
int gen_key_flag ;
#line 2314
int ide ;
#line 2314
int activeflag ;
#line 2314
int old_x ;
#line 2314
int old_y ;
#line 2315
int cur_thing ;
#line 2320 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void mainloop(void) 
{ 
  int done ;
  int val_x ;
  int val_y ;
  int valhat_x ;
  int valhat_y ;
  int new_x ;
  int new_y ;
  int shape_tool_mode ;
  int shape_start_x ;
  int shape_start_y ;
  int shape_current_x ;
  int shape_current_y ;
  int old_stamp_group ;
  int which ;
  int num_things ;
  int *thing_scroll ;
  int do_draw ;
  int ignoring_motion ;
  int motioner ;
  int hatmotioner ;
  int whichc ;
  int whicht ;
  int line_start_x ;
  int line_start_y ;
  int j ;
  int stamp_size_selector_clicked ;
  int stamp_xored ;
  unsigned int i ;
  SDL_TimerID scrolltimer ;
  SDL_Event event ;
  SDLKey key ;
  SDLMod mod ;
  Uint32 last_cursor_blink ;
  Uint32 cur_cursor_blink ;
  Uint32 pre_event_time ;
  Uint32 current_event_time ;
  SDL_Rect update_rect ;
  SDL_Rect real_r_tools ;
  on_screen_keyboard *new_kbd ;
  SDL_Rect kbd_rect ;
  float angle ;
  char angle_tool_text[256] ;
  Uint32 __cil_tmp43 ;
  int __cil_tmp44 ;
  Uint32 __cil_tmp45 ;
  int __cil_tmp46 ;
  SDL_Rect r_stamps_sizesel ;
  int __cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  int __cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  int __cil_tmp54 ;
  static int redraw ;
  wchar_t *im_cp ;
  int __cil_tmp57 ;
  unsigned int __cil_tmp58 ;
  int font_height ;
  TuxPaint_Font *__cil_tmp60 ;
  int __cil_tmp61 ;
  struct label_node *__cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  int old_cursor_textwidth ;
  unsigned int __cil_tmp66 ;
  wchar_t *__cil_tmp67 ;
  int __cil_tmp68 ;
  int __cil_tmp69 ;
  int __cil_tmp70 ;
  int __cil_tmp71 ;
  int __cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  int __cil_tmp75 ;
  int __cil_tmp76 ;
  struct osk_keyboard *__cil_tmp77 ;
  char *__cil_tmp78 ;
  struct osk_keyboard *__cil_tmp79 ;
  char *__cil_tmp80 ;
  int __cil_tmp81 ;
  int __cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  int __cil_tmp85 ;
  int __cil_tmp86 ;
  int num_rows_needed ;
  SDL_Rect r_controls ;
  SDL_Rect r_notcontrols ;
  SDL_Rect r_items ;
  int toolopt_changed ;
  int select_changed ;
  grid_dims gd_controls ;
  grid_dims gd_items ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int control_sound ;
  int old_size ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  int grp ;
  int cur ;
  int tries ;
  int __cil_tmp106 ;
  int __cil_tmp107 ;
  int __cil_tmp108 ;
  int control_sound___0 ;
  unsigned int __cil_tmp110 ;
  unsigned int __cil_tmp111 ;
  int i___61 ;
  int __cil_tmp113 ;
  int control_sound___1 ;
  unsigned int __cil_tmp115 ;
  unsigned int __cil_tmp116 ;
  int __cil_tmp117 ;
  int i___62 ;
  int __cil_tmp119 ;
  int is_upper ;
  int tmp ;
  SDL_TimerID __cil_tmp122 ;
  SDL_TimerID __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int grp___0 ;
  int cur___0 ;
  int __cil_tmp128 ;
  int __cil_tmp129 ;
  int __cil_tmp130 ;
  int __cil_tmp131 ;
  int __cil_tmp132 ;
  int __cil_tmp133 ;
  int __cil_tmp134 ;
  int __cil_tmp135 ;
  int tmp___0 ;
  int grp___1 ;
  int cur___1 ;
  int undo_ctr ;
  SDL_Surface *last ;
  int __cil_tmp141 ;
  Uint32 draw_color ;
  Uint32 canv_color ;
  Uint32 __cil_tmp144 ;
  int __cil_tmp145 ;
  int x1 ;
  int y1___0 ;
  int x2 ;
  int y2 ;
  SDL_Surface *last___0 ;
  int undo_ctr___0 ;
  int __cil_tmp152 ;
  int __cil_tmp153 ;
  SDL_Surface *tmp_canvas ;
  SDL_Surface *__cil_tmp155 ;
  struct label_node *__cil_tmp156 ;
  int __cil_tmp157 ;
  int __cil_tmp158 ;
  struct osk_keyboard *__cil_tmp159 ;
  int __cil_tmp160 ;
  int __cil_tmp161 ;
  int __cil_tmp162 ;
  int most ;
  int num_rows_needed___0 ;
  SDL_Rect r_controls___0 ;
  SDL_Rect r_notcontrols___0 ;
  SDL_Rect r_items___0 ;
  int __cil_tmp168 ;
  int is_upper___0 ;
  grid_dims gd_controls___0 ;
  grid_dims gd_items___0 ;
  int is_upper___1 ;
  int tmp___1 ;
  char const   *__cil_tmp174 ;
  double __cil_tmp175 ;
  int __cil_tmp176 ;
  int __cil_tmp177 ;
  int __cil_tmp178 ;
  int tmp___2 ;
  int __cil_tmp180 ;
  int tmp___3 ;
  int grp___2 ;
  int cur___2 ;
  int undo_ctr___1 ;
  SDL_Surface *last___1 ;
  int __cil_tmp186 ;
  int __cil_tmp187 ;
  int most___0 ;
  int __cil_tmp189 ;
  int __cil_tmp190 ;
  int __cil_tmp191 ;
  int __cil_tmp192 ;
  int __cil_tmp193 ;
  int control_rows ;
  int num_places ;
  int __cil_tmp196 ;
  int __cil_tmp197 ;
  int __cil_tmp198 ;
  struct label_node *__cil_tmp199 ;
  int __cil_tmp200 ;
  float __cil_tmp201 ;
  char *__cil_tmp202 ;
  int undo_ctr___2 ;
  SDL_Surface *last___2 ;
  int sz ;
  int __cil_tmp206 ;
  Uint32 draw_color___0 ;
  int undo_ctr___3 ;
  SDL_Surface *last___3 ;
  Uint32 draw_color___1 ;
  int x1___0 ;
  int y1___1 ;
  int x2___0 ;
  int y2___0 ;
  int w ;
  int h ;
  int __cil_tmp217 ;
  int control_sound___2 ;
  int w___116 ;
  int h___117 ;
  int old_size___0 ;
  int deg ;
  int __cil_tmp223 ;
  int __cil_tmp224 ;
  char *__cil_tmp225 ;
  Uint32 __cil_tmp226 ;
  Uint32 __cil_tmp227 ;

  {
#line 2328
  motioner = 0;
#line 2329
  hatmotioner = 0;
#line 2330
  whichc = 0;
#line 2331
  whicht = 0;
#line 2332
  line_start_x = 0;
#line 2333
  line_start_y = 0;
#line 2334
  j = 0;
#line 2335
  stamp_size_selector_clicked = 0;
#line 2336
  stamp_xored = 0;
#line 2338
  i = (unsigned int )0;
#line 2339
  scrolltimer = (SDL_TimerID )((void *)0);
#line 2345
  real_r_tools = r_tools;
#line 2358
  num_things = num_brushes;
#line 2359
  thing_scroll = & brush_scroll;
#line 2360
  cur_thing = 0;
#line 2361
  do_draw = 0;
#line 2362
  old_x = 0;
#line 2363
  old_y = 0;
#line 2364
  which = 0;
#line 2365
  shape_start_x = 0;
#line 2366
  shape_start_y = 0;
#line 2367
  shape_current_x = 0;
#line 2368
  shape_current_y = 0;
#line 2369
  shape_tool_mode = 2;
#line 2370
  button_down = 0;
#line 2371
  cur_toggle_count = (Uint32 )0;
#line 2371
  last_cursor_blink = cur_toggle_count;
#line 2372
  texttool_len = (unsigned int )0;
#line 2373
  scrolling = 0;
#line 2374
  scrolltimer = (SDL_TimerID )0;
#line 2375
  val_x = 0;
#line 2376
  val_y = 0;
#line 2377
  valhat_x = 0;
#line 2378
  valhat_y = 0;
#line 2379
  done = 0;
#line 2380
  keyglobal = 0;
#line 2381
  kbd = (on_screen_keyboard *)((void *)0);
#line 2383
  if (16 > buttons_tall * (int )gd_tools.cols) {
#line 2385
    real_r_tools.h = (Uint16 )((int )r_tools.h - button_h);
#line 2386
    real_r_tools.y = (Sint16 )((int )r_tools.y + button_h / 2);
  }
  {
#line 2389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2391
    ignoring_motion = 0;
#line 2393
    pre_event_time = SDL_GetTicks();
    }
    {
#line 2396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2396
      __cil_tmp44 = SDL_PollEvent(& event);
      }
#line 2396
      if (! __cil_tmp44) {
#line 2396
        goto while_break___0;
      }
      {
#line 2398
      current_event_time = SDL_GetTicks();
      }
#line 2402
      if (current_event_time > pre_event_time + 500U) {
#line 2402
        if ((int )event.type == 4) {
#line 2404
          ignoring_motion = (ignoring_motion + 1) % 3;
        }
      }
#line 2407
      if ((int )event.type == 12) {
        {
#line 2409
        magic_switchout(canvas);
#line 2410
        done = do_quit(cur_tool);
        }
#line 2411
        if (! done) {
          {
#line 2413
          magic_switchin(canvas);
          }
#line 2415
          if (cur_tool == 4) {
            _L: /* CIL Label */ 
#line 2417
            if (kbd) {
#line 2417
              if (onscreen_keyboard) {
                {
#line 2419
                SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2420
                update_screen_rect(& kbd_rect);
                }
              }
            }
          } else
#line 2415
          if (cur_tool == 5) {
#line 2415
            goto _L;
          }
        }
      } else
#line 2425
      if ((int )event.type == 1) {
#line 2428
        if (mouseaccessibility) {
#line 2428
          if (emulate_button_pressed) {
#line 2428
            if (cur_tool == 3) {
#line 2428
              if (shape_tool_mode != 2) {
                _L___8: /* CIL Label */ 
#line 2428
                if ((int )event.active.state & 6) {
#line 2428
                  if ((int )event.active.gain == 0) {
                    {
#line 2432
                    do_undo();
#line 2433
                    tool_avail[9] = 0;
#line 2434
                    draw_toolbar();
#line 2435
                    update_screen_rect(& r_tools);
#line 2436
                    shape_tool_mode = 2;
                    }
                  }
                }
              } else {
#line 2428
                goto _L___9;
              }
            } else
            _L___9: /* CIL Label */ 
#line 2428
            if (cur_tool == 2) {
#line 2428
              goto _L___8;
            }
          }
        }
        {
#line 2438
        handle_active(& event);
        }
      } else
#line 2440
      if ((int )event.type == 3) {
        {
#line 2442
        key = event.key.keysym.sym;
#line 2444
        handle_keymouse(key, (Uint8 )3, 16, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 2446
      if ((int )event.type == 2) {
#line 2448
        key = event.key.keysym.sym;
#line 2449
        mod = event.key.keysym.mod;
#line 2462
        if (cur_tool == 1) {
          {
#line 2466
          r_stamps_sizesel.x = (Sint16 )((int )r_canvas.x + (int )r_canvas.w);
#line 2467
          r_stamps_sizesel.y = (Sint16 )((int )r_canvas.h - img_btn_up->h);
#line 2468
          r_stamps_sizesel.w = (Uint16 )(img_btn_up->w * 2);
#line 2469
          r_stamps_sizesel.h = (Uint16 )img_btn_up->h;
#line 2470
          handle_keymouse(key, (Uint8 )2, 16, & r_canvas, & r_stamps_sizesel);
          }
        } else {
          {
#line 2473
          handle_keymouse(key, (Uint8 )2, 16, & r_canvas, (SDL_Rect *)((void *)0));
          }
        }
        {
#line 2476
        handle_keymouse_buttons(key, & whicht, & whichc, real_r_tools);
        }
#line 2479
        if ((unsigned int )key == 27U) {
#line 2479
          if (! disable_quit) {
            {
#line 2481
            magic_switchout(canvas);
#line 2482
            done = do_quit(cur_tool);
            }
#line 2483
            if (! done) {
              {
#line 2485
              magic_switchin(canvas);
              }
#line 2487
              if (cur_tool == 4) {
                _L___10: /* CIL Label */ 
#line 2489
                if (kbd) {
#line 2489
                  if (onscreen_keyboard) {
                    {
#line 2491
                    SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2492
                    update_screen_rect(& kbd_rect);
                    }
                  }
                }
              } else
#line 2487
              if (cur_tool == 5) {
#line 2487
                goto _L___10;
              }
            }
          } else {
#line 2479
            goto _L___37;
          }
        } else
        _L___37: /* CIL Label */ 
#line 2497
        if ((unsigned int )key == 115U) {
#line 2497
          if ((unsigned int )mod & 768U) {
#line 2500
            if (use_sound) {
              {
#line 2506
              mute = ! mute;
#line 2507
              Mix_HaltChannel(- 1);
              }
#line 2509
              if (mute) {
                {
#line 2512
                __cil_tmp49 = dcgettext((char const   *)((void *)0), "Sound muted.",
                                        5);
#line 2512
                draw_tux_text(2, (char const   *)__cil_tmp49, 0);
                }
              } else {
                {
#line 2517
                __cil_tmp50 = dcgettext((char const   *)((void *)0), "Sound unmuted.",
                                        5);
#line 2517
                draw_tux_text(2, (char const   *)__cil_tmp50, 0);
                }
              }
            }
          } else {
#line 2497
            goto _L___36;
          }
        } else
        _L___36: /* CIL Label */ 
#line 2522
        if ((unsigned int )key == 27U) {
#line 2522
          if ((unsigned int )mod & 3U) {
#line 2522
            if ((unsigned int )mod & 192U) {
              {
#line 2524
              magic_switchout(canvas);
#line 2525
              done = do_quit(cur_tool);
              }
#line 2526
              if (! done) {
                {
#line 2527
                magic_switchin(canvas);
                }
              }
            } else {
#line 2522
              goto _L___34;
            }
          } else {
#line 2522
            goto _L___34;
          }
        } else
        _L___34: /* CIL Label */ 
        _L___35: /* CIL Label */ 
#line 2538
        if ((unsigned int )key == 122U) {
#line 2538
          if ((unsigned int )mod & 192U) {
#line 2538
            if (! noshortcuts) {
              {
#line 2542
              magic_switchout(canvas);
              }
#line 2544
              if (tool_avail[8]) {
#line 2546
                if (cursor_x != -1) {
#line 2546
                  if (cursor_y != -1) {
                    {
#line 2548
                    hide_blinking_cursor();
                    }
#line 2549
                    if (texttool_len > 0U) {
                      {
#line 2551
                      rec_undo_buffer();
#line 2552
                      do_render_cur_text(1);
#line 2553
                      texttool_len = (unsigned int )0;
#line 2554
                      cursor_textwidth = 0;
#line 2555
                      label_node_to_edit = (struct label_node *)((void *)0);
                      }
                    } else
#line 2557
                    if (label_node_to_edit) {
#line 2557
                      if (cur_tool == 5) {
                        {
#line 2559
                        rec_undo_buffer();
#line 2560
                        have_to_rec_label_node = ! 0;
#line 2561
                        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
#line 2562
                        derender_node(& label_node_to_edit);
#line 2563
                        label_node_to_edit = (struct label_node *)((void *)0);
                        }
                      }
                    }
                  }
                }
#line 2567
                if (cur_undo == newest_undo) {
                  {
#line 2569
                  rec_undo_buffer();
#line 2570
                  do_undo();
                  }
                }
                {
#line 2572
                do_undo();
#line 2573
                update_screen_rect(& r_tools);
#line 2574
                shape_tool_mode = 2;
                }
              }
              {
#line 2577
              magic_switchin(canvas);
              }
            } else {
#line 2538
              goto _L___32;
            }
          } else {
#line 2538
            goto _L___32;
          }
        } else
        _L___32: /* CIL Label */ 
        _L___33: /* CIL Label */ 
#line 2579
        if ((unsigned int )key == 114U) {
#line 2579
          if ((unsigned int )mod & 192U) {
#line 2579
            if (! noshortcuts) {
              {
#line 2583
              magic_switchout(canvas);
              }
#line 2585
              if (tool_avail[9]) {
                {
#line 2587
                hide_blinking_cursor();
#line 2588
                do_redo();
#line 2589
                update_screen_rect(& r_tools);
#line 2590
                shape_tool_mode = 2;
                }
              }
              {
#line 2593
              magic_switchin(canvas);
              }
            } else {
#line 2579
              goto _L___30;
            }
          } else {
#line 2579
            goto _L___30;
          }
        } else
        _L___30: /* CIL Label */ 
        _L___31: /* CIL Label */ 
#line 2595
        if ((unsigned int )key == 111U) {
#line 2595
          if ((unsigned int )mod & 192U) {
#line 2595
            if (! noshortcuts) {
              {
#line 2599
              magic_switchout(canvas);
#line 2601
              disable_avail_tools();
#line 2602
              draw_toolbar();
#line 2603
              draw_colors((unsigned int )8);
#line 2604
              draw_none();
#line 2606
              __cil_tmp52 = do_open();
              }
#line 2606
              if (__cil_tmp52 == 0) {
#line 2608
                if (cur_tool == 4) {
                  {
                  {
#line 2609
                  do_render_cur_text(0);
                  }
                  }
                } else
#line 2608
                if (cur_tool == 5) {
                  {
                  {
#line 2609
                  do_render_cur_text(0);
                  }
                  }
                }
              }
              {
#line 2612
              enable_avail_tools();
#line 2614
              draw_toolbar();
#line 2615
              update_screen_rect(& r_tools);
#line 2616
              draw_colors((unsigned int )4);
              }
#line 2618
              if (cur_tool == 0) {
                {
                {
#line 2619
                draw_brushes();
                }
                }
              } else
#line 2618
              if (cur_tool == 2) {
                {
                {
#line 2619
                draw_brushes();
                }
                }
              } else
#line 2620
              if (cur_tool == 7) {
                {
#line 2621
                draw_magic();
                }
              } else
#line 2622
              if (cur_tool == 1) {
                {
#line 2623
                draw_stamps();
                }
              } else
#line 2624
              if (cur_tool == 4) {
                _L___11: /* CIL Label */ 
                {
#line 2626
                draw_fonts();
                }
#line 2627
                if (kbd) {
#line 2627
                  if (onscreen_keyboard) {
                    {
#line 2629
                    SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2630
                    update_screen_rect(& kbd_rect);
                    }
                  }
                }
              } else
#line 2624
              if (cur_tool == 5) {
#line 2624
                goto _L___11;
              } else
#line 2633
              if (cur_tool == 3) {
                {
#line 2634
                draw_shapes();
                }
              } else
#line 2635
              if (cur_tool == 10) {
                {
#line 2636
                draw_erasers();
                }
              } else
#line 2637
              if (cur_tool == 6) {
                {
#line 2638
                draw_fills();
                }
              }
              {
#line 2640
              draw_cur_tool_tip();
#line 2643
              control_drawtext_timer((Uint32 )1000, tool_tips[cur_tool], (Uint8 )0);
#line 2646
              magic_switchin(canvas);
              }
            } else {
#line 2595
              goto _L___28;
            }
          } else {
#line 2595
            goto _L___28;
          }
        } else
        _L___28: /* CIL Label */ 
        _L___29: /* CIL Label */ 
#line 2648
        if ((unsigned int )key == 110U) {
#line 2648
          if ((unsigned int )mod & 192U) {
#line 2648
            if (! noshortcuts) {
              {
#line 2652
              magic_switchout(canvas);
#line 2654
              hide_blinking_cursor();
#line 2655
              shape_tool_mode = 2;
#line 2657
              disable_avail_tools();
#line 2658
              draw_toolbar();
#line 2659
              draw_colors((unsigned int )8);
#line 2660
              draw_none();
#line 2662
              __cil_tmp53 = do_new_dialog();
              }
#line 2662
              if (__cil_tmp53 == 0) {
                {
#line 2664
                draw_tux_text(tool_tux[0], "OK then\342\200\246 Let\342\200\231s keep drawing this one!",
                              1);
                }
#line 2666
                if (cur_tool == 4) {
                  {
                  {
#line 2667
                  do_render_cur_text(0);
                  }
                  }
                } else
#line 2666
                if (cur_tool == 5) {
                  {
                  {
#line 2667
                  do_render_cur_text(0);
                  }
                  }
                }
              }
              {
#line 2670
              enable_avail_tools();
#line 2672
              draw_toolbar();
#line 2673
              update_screen_rect(& r_tools);
#line 2674
              draw_colors((unsigned int )4);
              }
#line 2676
              if (cur_tool == 0) {
                {
                {
#line 2677
                draw_brushes();
                }
                }
              } else
#line 2676
              if (cur_tool == 2) {
                {
                {
#line 2677
                draw_brushes();
                }
                }
              } else
#line 2678
              if (cur_tool == 7) {
                {
#line 2679
                draw_magic();
                }
              } else
#line 2680
              if (cur_tool == 1) {
                {
#line 2681
                draw_stamps();
                }
              } else
#line 2682
              if (cur_tool == 4) {
                _L___12: /* CIL Label */ 
                {
#line 2684
                draw_fonts();
                }
#line 2685
                if (kbd) {
#line 2685
                  if (onscreen_keyboard) {
                    {
#line 2687
                    SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2688
                    update_screen_rect(& kbd_rect);
                    }
                  }
                }
              } else
#line 2682
              if (cur_tool == 5) {
#line 2682
                goto _L___12;
              } else
#line 2691
              if (cur_tool == 3) {
                {
#line 2692
                draw_shapes();
                }
              } else
#line 2693
              if (cur_tool == 10) {
                {
#line 2694
                draw_erasers();
                }
              } else
#line 2695
              if (cur_tool == 6) {
                {
#line 2696
                draw_fills();
                }
              }
              {
#line 2698
              update_screen_rect(& r_toolopt);
#line 2699
              update_screen_rect(& r_ttoolopt);
#line 2700
              magic_switchin(canvas);
              }
            } else {
#line 2648
              goto _L___26;
            }
          } else {
#line 2648
            goto _L___26;
          }
        } else
        _L___26: /* CIL Label */ 
        _L___27: /* CIL Label */ 
#line 2702
        if ((unsigned int )key == 115U) {
#line 2702
          if ((unsigned int )mod & 192U) {
#line 2702
            if (! noshortcuts) {
              {
#line 2706
              magic_switchout(canvas);
#line 2707
              hide_blinking_cursor();
#line 2709
              __cil_tmp54 = do_save(cur_tool, 0);
              }
#line 2709
              if (__cil_tmp54) {
#line 2713
                been_saved = 1;
#line 2714
                tool_avail[13] = 0;
              }
              {
#line 2717
              draw_toolbar();
#line 2718
              update_screen_rect(& r_tools);
              }
#line 2719
              if (cur_tool == 4) {
                _L___13: /* CIL Label */ 
#line 2721
                if (kbd) {
#line 2721
                  if (onscreen_keyboard) {
                    {
#line 2723
                    SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2724
                    update_screen_rect(& kbd_rect);
                    }
                  }
                }
              } else
#line 2719
              if (cur_tool == 5) {
#line 2719
                goto _L___13;
              }
              {
#line 2728
              magic_switchin(canvas);
              }
            } else {
#line 2702
              goto _L___24;
            }
          } else {
#line 2702
            goto _L___24;
          }
        } else
        _L___24: /* CIL Label */ 
        _L___25: /* CIL Label */ 
#line 2738
        if ((unsigned int )key == 112U) {
#line 2738
          if ((unsigned int )mod & 192U) {
#line 2738
            if (! noshortcuts) {
#line 2742
              if (! disable_print) {
                {
#line 2744
                magic_switchout(canvas);
#line 2748
                tmp_apply_uncommited_text();
#line 2749
                print_image();
#line 2750
                undo_tmp_applied_text();
#line 2751
                magic_switchin(canvas);
                }
#line 2753
                if (cur_tool == 4) {
                  _L___14: /* CIL Label */ 
#line 2755
                  if (kbd) {
#line 2755
                    if (onscreen_keyboard) {
                      {
#line 2757
                      SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 2758
                      update_screen_rect(& kbd_rect);
                      }
                    }
                  }
                } else
#line 2753
                if (cur_tool == 5) {
#line 2753
                  goto _L___14;
                }
                {
#line 2762
                draw_toolbar();
#line 2763
                draw_tux_text(2, "\251", 0);
#line 2764
                update_screen_rect(& r_tools);
                }
              }
            } else {
#line 2738
              goto _L___22;
            }
          } else {
#line 2738
            goto _L___22;
          }
        } else
        _L___22: /* CIL Label */ 
        _L___23: /* CIL Label */ 
#line 2771
        if (cur_tool == 4) {
          _L___21: /* CIL Label */ 
#line 2771
          if (cursor_x != -1) {
#line 2771
            if (cursor_y != -1) {
              _L___18: /* CIL Label */ 
#line 2774
              redraw = 0;
#line 2775
              im_cp = (wchar_t *)im_data.s;
#line 2797
              if ((int )texttool_len <= redraw) {
#line 2798
                texttool_len = (unsigned int )0;
              } else {
#line 2800
                texttool_len -= (unsigned int )redraw;
              }
              {
#line 2801
              texttool_str[texttool_len] = '\000';
#line 2804
              redraw = im_read(& im_data, event.key.keysym);
              }
#line 2807
              if (! *im_cp) {
                {
#line 2808
                do_render_cur_text(0);
                }
              }
              {
#line 2811
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 2811
                if (! *im_cp) {
#line 2811
                  goto while_break___1;
                }
#line 2813
                if (*im_cp == 8) {
                  {
#line 2815
                  hide_blinking_cursor();
                  }
#line 2816
                  if (texttool_len > 0U) {
                    {
#line 2818
                    __cil_tmp58 = texttool_len;
#line 2818
                    texttool_len --;
#line 2819
                    texttool_str[texttool_len] = 0;
#line 2820
                    playsound(screen, 0, 18, 0, - 998, - 999);
#line 2822
                    do_render_cur_text(0);
                    }
#line 2824
                    if (been_saved) {
#line 2826
                      been_saved = 0;
#line 2828
                      if (! disable_save) {
#line 2829
                        tool_avail[13] = 1;
                      }
                      {
#line 2831
                      draw_toolbar();
#line 2832
                      update_screen_rect(& r_tools);
                      }
                    }
                  }
                } else
#line 2837
                if (*im_cp == 13) {
                  {
#line 2841
                  __cil_tmp60 = getfonthandle(cur_font);
#line 2841
                  __cil_tmp61 = TuxPaint_Font_FontHeight(__cil_tmp60);
#line 2841
                  font_height = __cil_tmp61;
#line 2843
                  hide_blinking_cursor();
                  }
#line 2844
                  if (texttool_len > 0U) {
                    {
#line 2846
                    rec_undo_buffer();
#line 2847
                    do_render_cur_text(1);
#line 2848
                    label_node_to_edit = (struct label_node *)((void *)0);
#line 2849
                    texttool_len = (unsigned int )0;
#line 2850
                    cursor_textwidth = 0;
                    }
#line 2851
                    if (cur_tool == 5) {
                      {
#line 2853
                      draw_fonts();
#line 2854
                      update_screen_rect(& r_toolopt);
                      }
                    }
#line 2857
                    if (been_saved) {
#line 2859
                      been_saved = 0;
#line 2861
                      if (! disable_save) {
#line 2862
                        tool_avail[13] = 1;
                      }
                      {
#line 2864
                      draw_toolbar();
#line 2865
                      update_screen_rect(& r_tools);
                      }
                    }
                    {
#line 2869
                    cursor_x = cursor_left;
#line 2870
                    cursor_y = 0;
#line 2872
                    playsound(screen, 0, 20, 1, - 999, - 999);
                    }
                  } else
#line 2875
                  if (label_node_to_edit) {
#line 2875
                    if (cur_tool == 5) {
                      {
#line 2877
                      rec_undo_buffer();
#line 2878
                      have_to_rec_label_node = ! 0;
#line 2879
                      add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
#line 2880
                      derender_node(& label_node_to_edit);
#line 2881
                      label_node_to_edit = (struct label_node *)((void *)0);
                      }
#line 2884
                      if (been_saved) {
#line 2886
                        been_saved = 0;
#line 2888
                        if (! disable_save) {
#line 2889
                          tool_avail[13] = 1;
                        }
                        {
#line 2891
                        draw_toolbar();
#line 2892
                        update_screen_rect(& r_tools);
                        }
                      }
                    } else {
#line 2875
                      goto _L___15;
                    }
                  } else
                  _L___15: /* CIL Label */ 
#line 2897
                  if (cur_tool == 5) {
#line 2897
                    if (cur_label == 2) {
                      {
#line 2899
                      label_node_to_edit = search_label_list(& highlighted_label_node,
                                                             (Uint16 )((int )highlighted_label_node->save_x + 3),
                                                             (Uint16 )((int )highlighted_label_node->save_y + 3),
                                                             0);
                      }
#line 2902
                      if (label_node_to_edit) {
                        {
#line 2904
                        cur_label = 1;
#line 2905
                        cur_thing = label_node_to_edit->save_cur_font;
#line 2906
                        do_setcursor(cursor_insertion);
#line 2907
                        i = (unsigned int )0;
#line 2908
                        label_node_to_edit->is_enabled = 0;
#line 2909
                        derender_node(& label_node_to_edit);
#line 2911
                        texttool_len = select_texttool_len;
                        }
                        {
#line 2912
                        while (1) {
                          while_continue___2: /* CIL Label */ ;
#line 2912
                          if (! (i < texttool_len)) {
#line 2912
                            goto while_break___2;
                          }
#line 2914
                          texttool_str[i] = select_texttool_str[i];
#line 2915
                          i ++;
                        }
                        while_break___2: /* CIL Label */ ;
                        }
#line 2917
                        texttool_str[i] = '\000';
#line 2918
                        cur_color = select_color;
#line 2919
                        old_x = (int )select_x;
#line 2920
                        old_y = (int )select_y;
#line 2921
                        cur_font = select_cur_font;
#line 2922
                        text_state = select_text_state;
#line 2923
                        text_size = select_text_size;
#line 2924
                        j = 0;
                        {
#line 2924
                        while (1) {
                          while_continue___3: /* CIL Label */ ;
#line 2924
                          if (! (j < num_font_families)) {
#line 2924
                            goto while_break___3;
                          }
#line 2926
                          if (*(user_font_families + j)) {
#line 2926
                            if ((*(user_font_families + j))->handle) {
                              {
#line 2928
                              TuxPaint_Font_CloseFont((*(user_font_families + j))->handle);
#line 2929
                              (*(user_font_families + j))->handle = (TuxPaint_Font *)((void *)0);
                              }
                            }
                          }
#line 2924
                          j ++;
                        }
                        while_break___3: /* CIL Label */ ;
                        }
                        {
#line 2932
                        draw_fonts();
#line 2933
                        update_screen_rect(& r_toolopt);
#line 2935
                        cursor_x = old_x;
#line 2936
                        cursor_y = old_y;
#line 2937
                        cursor_left = old_x;
#line 2939
                        draw_colors((unsigned int )4);
#line 2940
                        draw_fonts();
                        }
                      }
                      {
#line 2944
                      do_render_cur_text(0);
                      }
                    } else {
#line 2949
                      cursor_x = cursor_left;
#line 2950
                      cursor_y = 0;
                    }
                  } else {
#line 2949
                    cursor_x = cursor_left;
#line 2950
                    cursor_y = 0;
                  }
                  {
#line 2959
                  im_softreset(& im_data);
                  }
                } else
#line 2961
                if (*im_cp == 9) {
#line 2964
                  if (texttool_len > 0U) {
                    {
#line 2966
                    rec_undo_buffer();
#line 2967
                    do_render_cur_text(1);
#line 2968
                    label_node_to_edit = (struct label_node *)((void *)0);
#line 2969
                    cursor_x = 0;
#line 2970
                    texttool_len = (unsigned int )0;
#line 2971
                    cursor_textwidth = 0;
                    }
#line 2972
                    if (cur_tool == 5) {
                      {
#line 2974
                      draw_fonts();
#line 2975
                      update_screen_rect(& r_toolopt);
                      }
                    }
#line 2978
                    if (been_saved) {
#line 2980
                      been_saved = 0;
#line 2982
                      if (! disable_save) {
#line 2983
                        tool_avail[13] = 1;
                      }
                      {
#line 2985
                      draw_toolbar();
#line 2986
                      update_screen_rect(& r_tools);
                      }
                    }
                  } else
#line 2989
                  if (label_node_to_edit) {
#line 2989
                    if (cur_tool == 5) {
                      {
#line 2991
                      rec_undo_buffer();
#line 2992
                      have_to_rec_label_node = ! 0;
#line 2993
                      add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
#line 2994
                      derender_node(& label_node_to_edit);
#line 2995
                      label_node_to_edit = (struct label_node *)((void *)0);
                      }
#line 2998
                      if (been_saved) {
#line 3000
                        been_saved = 0;
#line 3002
                        if (! disable_save) {
#line 3003
                          tool_avail[13] = 1;
                        }
                        {
#line 3005
                        draw_toolbar();
#line 3006
                        update_screen_rect(& r_tools);
                        }
                      }
                    } else {
#line 2989
                      goto _L___16;
                    }
                  } else
                  _L___16: /* CIL Label */ 
#line 3010
                  if (cur_tool == 5) {
#line 3010
                    if (cur_label == 2) {
                      {
#line 3012
                      cycle_highlighted_label_node();
#line 3013
                      highlight_label_nodes();
                      }
                    }
                  }
                  {
#line 3024
                  im_softreset(& im_data);
                  }
                } else {
                  {
#line 3026
                  __cil_tmp64 = iswprint((wint_t )*im_cp);
                  }
#line 3026
                  if (__cil_tmp64) {
#line 3026
                    if (cur_tool == 4) {
                      _L___17: /* CIL Label */ 
#line 3028
                      if ((unsigned long )texttool_len < sizeof(texttool_str) / sizeof(wchar_t ) - 1UL) {
                        {
#line 3030
                        old_cursor_textwidth = cursor_textwidth;
#line 3037
                        __cil_tmp66 = texttool_len;
#line 3037
                        texttool_len ++;
#line 3037
                        texttool_str[__cil_tmp66] = *im_cp;
#line 3038
                        texttool_str[texttool_len] = 0;
#line 3040
                        do_render_cur_text(0);
                        }
#line 3042
                        if (been_saved) {
#line 3044
                          been_saved = 0;
#line 3046
                          if (! disable_save) {
#line 3047
                            tool_avail[13] = 1;
                          }
                          {
#line 3049
                          draw_toolbar();
#line 3050
                          update_screen_rect(& r_tools);
                          }
                        }
#line 3054
                        if (cursor_x + old_cursor_textwidth <= canvas->w - 50) {
#line 3054
                          if (cursor_x + cursor_textwidth > canvas->w - 50) {
                            {
#line 3057
                            playsound(screen, 0, 19, 1, - 999, - 999);
                            }
                          } else {
                            {
                            {
#line 3064
                            playsound(screen, 0, 18, 0, - 998, - 999);
                            }
                            }
                          }
                        } else {
                          {
                          {
#line 3064
                          playsound(screen, 0, 18, 0, - 998, - 999);
                          }
                          }
                        }
                      }
                    } else
#line 3026
                    if (cur_label == 1) {
#line 3026
                      goto _L___17;
                    }
                  }
                }
#line 3069
                im_cp ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3073
              if (im_data.tip_text) {
                {
#line 3075
                draw_tux_text(0, im_data.tip_text, 1);
                }
              }
            } else {
#line 2771
              goto _L___19;
            }
          } else {
#line 2771
            goto _L___19;
          }
        } else
#line 2771
        if (cur_tool == 5) {
#line 2771
          goto _L___21;
        } else
        _L___19: /* CIL Label */ 
        _L___20: /* CIL Label */ 
#line 2771
        if (cur_tool == 5) {
#line 2771
          if (cur_label == 2) {
#line 2771
            goto _L___18;
          }
        }
      } else
#line 3081
      if ((int )event.type == 7) {
        {
#line 3083
        handle_joyaxismotion(event, & motioner, & val_x, & val_y);
        }
      } else
#line 3085
      if ((int )event.type == 9) {
        {
#line 3087
        handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                            & old_hat_ticks);
        }
      } else
#line 3089
      if ((int )event.type == 8) {
        {
#line 3091
        handle_joyballmotion(event, oldpos_x, oldpos_y);
        }
      } else
#line 3093
      if ((int )event.type == 10) {
        {
        {
#line 3095
        handle_joybuttonupdownscl(event, oldpos_x, oldpos_y, real_r_tools);
        }
        }
      } else
#line 3093
      if ((int )event.type == 11) {
        {
        {
#line 3095
        handle_joybuttonupdownscl(event, oldpos_x, oldpos_y, real_r_tools);
        }
        }
      } else {
        {
#line 3097
        __cil_tmp69 = grid_hit_gd(& r_tools, (unsigned int )event.button.x, (unsigned int )event.button.y,
                                  & gd_tools);
        }
        {
#line 3097
        __cil_tmp68 = hit_test(& r_tools, (unsigned int )event.button.x, (unsigned int )event.button.y);
        }
#line 3097
        if ((int )event.type == 5) {
#line 3097
          if ((int )event.button.button >= 2) {
#line 3097
            if ((int )event.button.button <= 3) {
#line 3097
              if (no_button_distinction == 0) {
#line 3097
                if (! (__cil_tmp68 && __cil_tmp69 == 14)) {
#line 3104
                  non_left_click_count ++;
#line 3107
                  if (non_left_click_count == 10) {
                    _L___38: /* CIL Label */ 
                    _L___39: /* CIL Label */ 
                    {
#line 3111
                    hide_blinking_cursor();
#line 3112
                    do_prompt_image_flash("Remember to use the left mouse button!",
                                          "OK", "\230\001", img_mouse, img_mouse_click,
                                          (SDL_Surface *)((void *)0), 1, (int )event.button.x,
                                          (int )event.button.y);
                    }
#line 3115
                    if (cur_tool == 4) {
                      {
                      {
#line 3116
                      do_render_cur_text(0);
                      }
                      }
                    } else
#line 3115
                    if (cur_tool == 5) {
                      {
                      {
#line 3116
                      do_render_cur_text(0);
                      }
                      }
                    }
                    {
#line 3117
                    draw_tux_text(2, "\251", 0);
                    }
                  } else
#line 3107
                  if (non_left_click_count == 20) {
#line 3107
                    goto _L___38;
                  } else
#line 3107
                  if (non_left_click_count % 50 == 0) {
#line 3107
                    goto _L___38;
                  }
                } else {
#line 3097
                  goto _L___126;
                }
              } else {
#line 3097
                goto _L___126;
              }
            } else {
#line 3097
              goto _L___126;
            }
          } else {
#line 3097
            goto _L___126;
          }
        } else
        _L___126: /* CIL Label */ 
        _L___127: /* CIL Label */ 
        _L___128: /* CIL Label */ 
#line 3120
        if ((int )event.type == 5) {
          _L___125: /* CIL Label */ 
#line 3120
          if ((int )event.button.button <= 3) {
            {
#line 3123
            __cil_tmp71 = hit_test(& r_tools, (unsigned int )event.button.x, (unsigned int )event.button.y);
            }
#line 3123
            if (__cil_tmp71) {
              {
#line 3127
              __cil_tmp72 = hit_test(& real_r_tools, (unsigned int )event.button.x,
                                     (unsigned int )event.button.y);
              }
#line 3127
              if (__cil_tmp72) {
                {
#line 3130
                brushflag = 0;
#line 3131
                magicflag = 0;
#line 3132
                magic_switchout(canvas);
#line 3133
                __cil_tmp73 = grid_hit_gd(& real_r_tools, (unsigned int )event.button.x,
                                          (unsigned int )event.button.y, & gd_tools);
#line 3133
                whicht = tool_scroll + __cil_tmp73;
#line 3135
                __cil_tmp74 = valid_click(event.button.button);
                }
#line 3135
                if (whicht < 16) {
#line 3135
                  if (tool_avail[whicht]) {
#line 3135
                    if (__cil_tmp74) {
                      _L___53: /* CIL Label */ 
#line 3144
                      if (cur_tool == 4) {
#line 3144
                        if (whicht != 4) {
#line 3144
                          if (whicht != 11) {
#line 3144
                            if (whicht != 12) {
#line 3144
                              if (whicht != 13) {
#line 3144
                                if (whicht != 14) {
#line 3144
                                  if (whicht != 15) {
                                    _L___40: /* CIL Label */ 
#line 3152
                                    if (cursor_x != -1) {
#line 3152
                                      if (cursor_y != -1) {
                                        {
#line 3154
                                        hide_blinking_cursor();
                                        }
#line 3155
                                        if (texttool_len > 0U) {
                                          {
#line 3157
                                          rec_undo_buffer();
#line 3158
                                          do_render_cur_text(1);
#line 3159
                                          texttool_len = (unsigned int )0;
#line 3160
                                          cursor_textwidth = 0;
#line 3161
                                          label_node_to_edit = (struct label_node *)((void *)0);
                                          }
                                        } else
#line 3163
                                        if (label_node_to_edit) {
#line 3163
                                          if (cur_tool == 5) {
                                            {
#line 3165
                                            rec_undo_buffer();
#line 3166
                                            have_to_rec_label_node = ! 0;
#line 3167
                                            add_label_node(0, 0, (Uint16 )0, (Uint16 )0,
                                                           (SDL_Surface *)((void *)0));
#line 3168
                                            derender_node(& label_node_to_edit);
#line 3169
                                            label_node_to_edit = (struct label_node *)((void *)0);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
#line 3144
                                    goto _L___41;
                                  }
                                } else {
#line 3144
                                  goto _L___41;
                                }
                              } else {
#line 3144
                                goto _L___41;
                              }
                            } else {
#line 3144
                              goto _L___41;
                            }
                          } else {
#line 3144
                            goto _L___41;
                          }
                        } else {
#line 3144
                          goto _L___41;
                        }
                      } else
                      _L___41: /* CIL Label */ 
                      _L___42: /* CIL Label */ 
                      _L___43: /* CIL Label */ 
                      _L___44: /* CIL Label */ 
                      _L___45: /* CIL Label */ 
                      _L___46: /* CIL Label */ 
#line 3144
                      if (cur_tool == 5) {
#line 3144
                        if (whicht != 5) {
#line 3144
                          if (whicht != 11) {
#line 3144
                            if (whicht != 12) {
#line 3144
                              if (whicht != 13) {
#line 3144
                                if (whicht != 14) {
#line 3144
                                  if (whicht != 15) {
#line 3144
                                    goto _L___40;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      {
#line 3173
                      update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w, button_h * buttons_tall + (int )r_ttools.h);
#line 3175
                      old_tool = cur_tool;
#line 3176
                      cur_tool = whicht;
#line 3177
                      draw_toolbar();
#line 3178
                      update_screen_rect(& r_tools);
#line 3180
                      playsound(screen, 1, 1, 0, - 997, - 999);
                      }
#line 3183
                      if (cur_tool != 4) {
                        {
#line 3184
                        draw_cur_tool_tip();
                        }
                      }
#line 3188
                      if (cur_tool == 0) {
                        {
#line 3190
                        keybd_flag = 0;
#line 3191
                        cur_thing = cur_brush;
#line 3192
                        num_things = num_brushes;
#line 3193
                        thing_scroll = & brush_scroll;
#line 3194
                        draw_brushes();
#line 3195
                        draw_colors((unsigned int )1);
                        }
                      } else
#line 3197
                      if (cur_tool == 1) {
                        {
#line 3199
                        keybd_flag = 0;
#line 3200
                        cur_thing = cur_stamp[stamp_group];
#line 3201
                        num_things = num_stamps[stamp_group];
#line 3202
                        thing_scroll = & stamp_scroll[stamp_group];
#line 3203
                        draw_stamps();
#line 3204
                        __cil_tmp76 = stamp_tintable(cur_stamp[stamp_group]);
                        }
                        {
#line 3204
                        __cil_tmp75 = stamp_colorable(cur_stamp[stamp_group]);
#line 3204
                        draw_colors((unsigned int )(__cil_tmp75 || __cil_tmp76));
#line 3206
                        set_active_stamp();
#line 3207
                        update_stamp_xor();
                        }
                      } else
#line 3209
                      if (cur_tool == 2) {
                        {
#line 3211
                        keybd_flag = 0;
#line 3212
                        cur_thing = cur_brush;
#line 3213
                        num_things = num_brushes;
#line 3214
                        thing_scroll = & brush_scroll;
#line 3215
                        draw_brushes();
#line 3216
                        draw_colors((unsigned int )1);
                        }
                      } else
#line 3218
                      if (cur_tool == 6) {
                        {
#line 3220
                        keybd_flag = 0;
#line 3221
                        cur_thing = cur_fill;
#line 3222
                        num_things = 4;
#line 3223
                        thing_scroll = & fill_scroll;
#line 3224
                        draw_fills();
#line 3225
                        draw_colors((unsigned int )1);
                        }
                      } else
#line 3227
                      if (cur_tool == 3) {
                        {
#line 3229
                        keybd_flag = 0;
#line 3230
                        cur_thing = cur_shape;
#line 3231
                        num_things = 22;
#line 3232
                        thing_scroll = & shape_scroll;
#line 3233
                        draw_shapes();
#line 3234
                        draw_colors((unsigned int )1);
#line 3235
                        shape_tool_mode = 2;
                        }
                      } else
#line 3237
                      if (cur_tool == 4) {
                        _L___52: /* CIL Label */ 
#line 3239
                        if (onscreen_keyboard) {
#line 3241
                          if (kbd == (void *)0) {
#line 3243
                            if (onscreen_keyboard_layout) {
                              {
#line 3244
                              kbd = osk_create(onscreen_keyboard_layout, screen, img_btn_up,
                                               img_btn_down, img_btn_off, img_btn_nav,
                                               img_btn_hold, img_oskdel, img_osktab,
                                               img_oskenter, img_oskcapslock, img_oskshift,
                                               img_btnsm_up, img_btnsm_down, img_btnsm_off,
                                               img_btnsm_nav, img_btnsm_hold, img_oskdel,
                                               img_osktab, img_oskenter, img_oskcapslock,
                                               img_oskshift, onscreen_keyboard_disable_change);
                              }
                            } else {
                              {
#line 3257
                              __cil_tmp78 = strdup("default.layout");
#line 3257
                              __cil_tmp79 = osk_create(__cil_tmp78, screen, img_btn_up,
                                                       img_btn_down, img_btn_off,
                                                       img_btn_nav, img_btn_hold,
                                                       img_oskdel, img_osktab, img_oskenter,
                                                       img_oskcapslock, img_oskshift,
                                                       img_btnsm_up, img_btnsm_down,
                                                       img_btnsm_off, img_btnsm_nav,
                                                       img_btnsm_hold, img_oskdel,
                                                       img_osktab, img_oskenter, img_oskcapslock,
                                                       img_oskshift, onscreen_keyboard_disable_change);
#line 3257
                              kbd = __cil_tmp79;
                              }
                            }
                          }
#line 3270
                          if (kbd == (void *)0) {
                            {
#line 3272
                            fprintf(stderr, "kbd = NULL\n");
                            }
                          } else {
#line 3276
                            kbd_rect.x = (Sint16 )(button_w * 2 + (canvas->w - (kbd->surface)->w) / 2);
#line 3277
                            if (old_y > canvas->h / 2) {
#line 3278
                              kbd_rect.y = (Sint16 )0;
                            } else {
#line 3280
                              kbd_rect.y = (Sint16 )(canvas->h - (kbd->surface)->h);
                            }
                            {
#line 3281
                            kbd_rect.w = (Uint16 )(kbd->surface)->w;
#line 3282
                            kbd_rect.h = (Uint16 )(kbd->surface)->h;
#line 3283
                            SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3284
                            update_screen_rect(& kbd_rect);
                            }
                          }
                        }
#line 3287
                        if (! font_thread_done) {
                          {
#line 3289
                          draw_colors((unsigned int )0);
#line 3290
                          draw_none();
#line 3291
                          update_screen_rect(& r_toolopt);
#line 3292
                          update_screen_rect(& r_ttoolopt);
#line 3293
                          do_setcursor(cursor_watch);
#line 3296
                          __cil_tmp80 = dcgettext((char const   *)((void *)0), "Please wait\342\200\246",
                                                  5);
#line 3296
                          draw_tux_text(5, (char const   *)__cil_tmp80, 1);
#line 3298
                          waiting_for_fonts = (long )1;
#line 3300
                          receive_some_font_info(screen);
#line 3311
                          set_label_fonts();
#line 3312
                          do_setcursor(cursor_arrow);
                          }
                        }
                        {
#line 3314
                        draw_cur_tool_tip();
                        }
#line 3316
                        if (num_font_families > 0) {
                          {
#line 3318
                          cur_thing = cur_font;
#line 3319
                          num_things = num_font_families;
#line 3320
                          thing_scroll = & font_scroll;
#line 3321
                          cur_label = 1;
#line 3323
                          draw_fonts();
#line 3324
                          draw_colors((unsigned int )1);
                          }
                        } else {
                          {
#line 3330
                          cur_tool = old_tool;
#line 3331
                          draw_toolbar();
#line 3332
                          update_screen_rect(& r_tools);
                          }
                        }
                      } else
#line 3237
                      if (cur_tool == 5) {
#line 3237
                        goto _L___52;
                      } else
#line 3335
                      if (cur_tool == 7) {
                        {
#line 3337
                        keybd_flag = 0;
#line 3338
                        cur_thing = cur_magic[magic_group];
#line 3339
                        num_things = num_magics[magic_group];
#line 3340
                        thing_scroll = & magic_scroll[magic_group];
#line 3341
                        magic_current_snd_ptr = (Mix_Chunk *)((void *)0);
#line 3342
                        draw_magic();
#line 3343
                        draw_colors((unsigned int )magics[magic_group][cur_thing].colors);
                        }
#line 3345
                        if (magics[magic_group][cur_thing].colors) {
                          {
#line 3346
                          (*(magic_funcs[magics[magic_group][cur_thing].handle_idx].set_color))(magic_api_struct,
                                                                                                *(*(color_hexes + cur_color) + 0),
                                                                                                *(*(color_hexes + cur_color) + 1),
                                                                                                *(*(color_hexes + cur_color) + 2));
                          }
                        }
                      } else
#line 3351
                      if (cur_tool == 10) {
                        {
#line 3353
                        keybd_flag = 0;
#line 3354
                        cur_thing = cur_eraser;
#line 3355
                        num_things = 16;
#line 3356
                        thing_scroll = & eraser_scroll;
#line 3357
                        draw_erasers();
#line 3358
                        draw_colors((unsigned int )0);
                        }
                      } else
#line 3360
                      if (cur_tool == 8) {
#line 3362
                        if (cur_undo == newest_undo) {
                          {
#line 3364
                          rec_undo_buffer();
#line 3365
                          do_undo();
                          }
                        }
                        {
#line 3367
                        do_undo();
#line 3369
                        been_saved = 0;
                        }
#line 3371
                        if (! disable_save) {
#line 3372
                          tool_avail[13] = 1;
                        }
                        {
#line 3374
                        cur_tool = old_tool;
#line 3375
                        draw_toolbar();
#line 3376
                        update_screen_rect(& r_tools);
#line 3377
                        shape_tool_mode = 2;
                        }
                      } else
#line 3379
                      if (cur_tool == 9) {
                        {
#line 3381
                        do_redo();
#line 3383
                        been_saved = 0;
                        }
#line 3385
                        if (! disable_save) {
#line 3386
                          tool_avail[13] = 1;
                        }
                        {
#line 3388
                        cur_tool = old_tool;
#line 3389
                        draw_toolbar();
#line 3390
                        update_screen_rect(& r_tools);
#line 3391
                        shape_tool_mode = 2;
                        }
                      } else
#line 3393
                      if (cur_tool == 12) {
                        {
#line 3395
                        disable_avail_tools();
#line 3396
                        draw_toolbar();
#line 3397
                        draw_colors((unsigned int )8);
#line 3398
                        draw_none();
#line 3400
                        __cil_tmp81 = do_open();
                        }
#line 3400
                        if (__cil_tmp81 == 0) {
#line 3402
                          if (old_tool == 4) {
                            {
                            {
#line 3403
                            do_render_cur_text(0);
                            }
                            }
                          } else
#line 3402
                          if (old_tool == 5) {
                            {
                            {
#line 3403
                            do_render_cur_text(0);
                            }
                            }
                          }
                        }
                        {
#line 3406
                        enable_avail_tools();
#line 3408
                        cur_tool = old_tool;
#line 3409
                        draw_toolbar();
#line 3410
                        update_screen_rect(& r_tools);
#line 3412
                        draw_cur_tool_tip();
#line 3414
                        draw_colors((unsigned int )4);
                        }
#line 3416
                        if (cur_tool == 0) {
                          {
                          {
#line 3417
                          draw_brushes();
                          }
                          }
                        } else
#line 3416
                        if (cur_tool == 2) {
                          {
                          {
#line 3417
                          draw_brushes();
                          }
                          }
                        } else
#line 3418
                        if (cur_tool == 7) {
                          {
#line 3419
                          draw_magic();
                          }
                        } else
#line 3420
                        if (cur_tool == 1) {
                          {
#line 3421
                          draw_stamps();
                          }
                        } else
#line 3422
                        if (cur_tool == 4) {
                          _L___47: /* CIL Label */ 
                          {
#line 3424
                          draw_fonts();
                          }
#line 3425
                          if (kbd) {
#line 3425
                            if (onscreen_keyboard) {
                              {
#line 3427
                              SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3428
                              update_screen_rect(& kbd_rect);
                              }
                            }
                          }
                        } else
#line 3422
                        if (cur_tool == 5) {
#line 3422
                          goto _L___47;
                        } else
#line 3431
                        if (cur_tool == 3) {
                          {
#line 3432
                          draw_shapes();
                          }
                        } else
#line 3433
                        if (cur_tool == 10) {
                          {
#line 3434
                          draw_erasers();
                          }
                        } else
#line 3435
                        if (cur_tool == 6) {
                          {
#line 3436
                          draw_fills();
                          }
                        }
                      } else
#line 3438
                      if (cur_tool == 13) {
                        {
#line 3440
                        __cil_tmp82 = do_save(old_tool, 0);
                        }
#line 3440
                        if (__cil_tmp82) {
#line 3442
                          been_saved = 1;
#line 3443
                          tool_avail[13] = 0;
                        }
#line 3446
                        if (old_tool == 4) {
                          _L___48: /* CIL Label */ 
#line 3448
                          if (kbd) {
#line 3448
                            if (onscreen_keyboard) {
                              {
#line 3450
                              SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3451
                              update_screen_rect(& kbd_rect);
                              }
                            }
                          }
                        } else
#line 3446
                        if (old_tool == 5) {
#line 3446
                          goto _L___48;
                        }
                        {
#line 3455
                        cur_tool = old_tool;
#line 3456
                        draw_toolbar();
#line 3457
                        update_screen_rect(& r_tools);
                        }
                      } else
#line 3459
                      if (cur_tool == 11) {
                        {
#line 3461
                        shape_tool_mode = 2;
#line 3463
                        disable_avail_tools();
#line 3464
                        draw_toolbar();
#line 3465
                        draw_colors((unsigned int )8);
#line 3466
                        draw_none();
#line 3468
                        __cil_tmp83 = do_new_dialog();
                        }
#line 3468
                        if (__cil_tmp83 == 0) {
                          {
#line 3470
                          cur_tool = old_tool;
#line 3472
                          draw_tux_text(tool_tux[0], "OK then\342\200\246 Let\342\200\231s keep drawing this one!",
                                        1);
                          }
#line 3474
                          if (cur_tool == 4) {
                            {
                            {
#line 3475
                            do_render_cur_text(0);
                            }
                            }
                          } else
#line 3474
                          if (cur_tool == 5) {
                            {
                            {
#line 3475
                            do_render_cur_text(0);
                            }
                            }
                          }
                        }
                        {
#line 3478
                        cur_tool = old_tool;
#line 3480
                        enable_avail_tools();
#line 3482
                        draw_toolbar();
#line 3483
                        update_screen_rect(& r_tools);
#line 3484
                        draw_colors((unsigned int )4);
                        }
#line 3486
                        if (cur_tool == 0) {
                          {
                          {
#line 3487
                          draw_brushes();
                          }
                          }
                        } else
#line 3486
                        if (cur_tool == 2) {
                          {
                          {
#line 3487
                          draw_brushes();
                          }
                          }
                        } else
#line 3488
                        if (cur_tool == 7) {
                          {
#line 3489
                          draw_magic();
                          }
                        } else
#line 3490
                        if (cur_tool == 1) {
                          {
#line 3491
                          draw_stamps();
                          }
                        } else
#line 3492
                        if (cur_tool == 4) {
                          _L___49: /* CIL Label */ 
                          {
#line 3494
                          draw_fonts();
                          }
#line 3495
                          if (kbd) {
#line 3495
                            if (onscreen_keyboard) {
                              {
#line 3497
                              SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3498
                              update_screen_rect(& kbd_rect);
                              }
                            }
                          }
                        } else
#line 3492
                        if (cur_tool == 5) {
#line 3492
                          goto _L___49;
                        } else
#line 3501
                        if (cur_tool == 3) {
                          {
#line 3502
                          draw_shapes();
                          }
                        } else
#line 3503
                        if (cur_tool == 10) {
                          {
#line 3504
                          draw_erasers();
                          }
                        } else
#line 3505
                        if (cur_tool == 6) {
                          {
#line 3506
                          draw_fills();
                          }
                        }
                      } else
#line 3508
                      if (cur_tool == 14) {
                        {
#line 3511
                        tmp_apply_uncommited_text();
#line 3513
                        print_image();
#line 3514
                        undo_tmp_applied_text();
                        }
#line 3516
                        if (old_tool == 4) {
                          _L___50: /* CIL Label */ 
#line 3518
                          if (kbd) {
#line 3518
                            if (onscreen_keyboard) {
                              {
#line 3520
                              SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3521
                              update_screen_rect(& kbd_rect);
                              }
                            }
                          }
                        } else
#line 3516
                        if (old_tool == 5) {
#line 3516
                          goto _L___50;
                        }
                        {
#line 3525
                        cur_tool = old_tool;
#line 3526
                        draw_toolbar();
#line 3527
                        draw_tux_text(2, "\251", 0);
#line 3528
                        update_screen_rect(& r_tools);
                        }
                      } else
#line 3530
                      if (cur_tool == 15) {
                        {
#line 3532
                        done = do_quit(old_tool);
                        }
#line 3534
                        if (old_tool == 4) {
                          _L___51: /* CIL Label */ 
#line 3536
                          if (kbd) {
#line 3536
                            if (onscreen_keyboard) {
                              {
#line 3538
                              SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 3539
                              update_screen_rect(& kbd_rect);
                              }
                            }
                          }
                        } else
#line 3534
                        if (old_tool == 5) {
#line 3534
                          goto _L___51;
                        }
                        {
#line 3543
                        cur_tool = old_tool;
#line 3544
                        draw_toolbar();
#line 3545
                        update_screen_rect(& r_tools);
                        }
                      }
                      {
#line 3547
                      update_screen_rect(& r_toolopt);
#line 3548
                      update_screen_rect(& r_ttoolopt);
                      }
                    } else
#line 3135
                    if (whicht == 14) {
#line 3135
                      goto _L___53;
                    }
                  }
                }
#line 3551
                if (! done) {
                  {
#line 3552
                  magic_switchin(canvas);
                  }
                }
              } else
#line 3554
              if ((int )event.button.y < (int )r_tools.y + button_h / 2) {
#line 3554
                if (tool_scroll > 0) {
                  {
#line 3556
                  tool_scroll -= (int )gd_tools.cols;
#line 3557
                  playsound(screen, 1, 7, 1, - 998, - 999);
#line 3559
                  draw_toolbar();
#line 3560
                  update_screen_rect(& r_tools);
                  }
                } else {
#line 3554
                  goto _L___54;
                }
              } else
              _L___54: /* CIL Label */ 
#line 3563
              if ((int )event.button.y > (int )real_r_tools.y + (int )real_r_tools.h) {
#line 3563
                if (tool_scroll < (16 - buttons_tall * (int )gd_tools.cols) + (int )gd_tools.cols) {
                  {
#line 3566
                  tool_scroll += (int )gd_tools.cols;
#line 3567
                  draw_toolbar();
#line 3568
                  playsound(screen, 1, 7, 1, - 998, - 999);
#line 3570
                  update_screen_rect(& r_tools);
                  }
                }
              }
            } else {
              {
#line 3575
              __cil_tmp86 = valid_click(event.button.button);
              }
              {
#line 3575
              __cil_tmp85 = hit_test(& r_toolopt, (unsigned int )event.button.x, (unsigned int )event.button.y);
              }
#line 3575
              if (__cil_tmp85) {
#line 3575
                if (__cil_tmp86) {
#line 3581
                  if (cur_tool == 0) {
                    _L___68: /* CIL Label */ 
                    _L___69: /* CIL Label */ 
                    _L___70: /* CIL Label */ 
                    _L___71: /* CIL Label */ 
                    _L___72: /* CIL Label */ 
                    _L___73: /* CIL Label */ 
                    _L___74: /* CIL Label */ 
                    _L___75: /* CIL Label */ 
#line 3592
                    select_changed = 0;
#line 3596
                    gd_controls.rows = (Uint8 )0;
#line 3597
                    gd_controls.cols = (Uint8 )0;
#line 3598
                    gd_items.rows = (Uint8 )2;
#line 3599
                    gd_items.cols = (Uint8 )2;
#line 3604
                    if (cur_tool == 1) {
#line 3606
                      if (! disable_stamp_controls) {
#line 3609
                        gd_controls.rows = (Uint8 )3;
#line 3610
                        gd_controls.cols = (Uint8 )2;
                      } else {
#line 3615
                        gd_controls.rows = (Uint8 )1;
#line 3616
                        gd_controls.cols = (Uint8 )2;
                      }
                    } else
#line 3619
                    if (cur_tool == 4) {
#line 3621
                      if (! disable_stamp_controls) {
#line 3623
                        gd_controls.rows = (Uint8 )2;
#line 3624
                        gd_controls.cols = (Uint8 )2;
                      }
                    } else
#line 3627
                    if (cur_tool == 5) {
#line 3629
                      if (! disable_stamp_controls) {
#line 3631
                        gd_controls.rows = (Uint8 )3;
#line 3632
                        gd_controls.cols = (Uint8 )2;
                      } else {
#line 3636
                        gd_controls.rows = (Uint8 )1;
#line 3637
                        gd_controls.cols = (Uint8 )2;
                      }
                    } else
#line 3641
                    if (cur_tool == 7) {
#line 3643
                      if (! disable_magic_controls) {
#line 3645
                        gd_controls.rows = (Uint8 )2;
#line 3646
                        gd_controls.cols = (Uint8 )2;
                      } else {
#line 3650
                        gd_controls.rows = (Uint8 )1;
#line 3651
                        gd_controls.cols = (Uint8 )2;
                      }
                    } else
#line 3655
                    if (cur_tool == 3) {
#line 3657
                      if (! disable_shape_controls) {
#line 3659
                        gd_controls.rows = (Uint8 )1;
#line 3660
                        gd_controls.cols = (Uint8 )2;
                      }
                    }
#line 3666
                    num_rows_needed = ((num_things + (int )gd_items.cols) - 1) / (int )gd_items.cols;
#line 3668
                    do_draw = 0;
#line 3670
                    r_controls.w = r_toolopt.w;
#line 3671
                    r_controls.h = (Uint16 )((int )gd_controls.rows * button_h);
#line 3672
                    r_controls.x = r_toolopt.x;
#line 3673
                    r_controls.y = (Sint16 )(((int )r_toolopt.y + (int )r_toolopt.h) - (int )r_controls.h);
#line 3675
                    r_notcontrols.w = r_toolopt.w;
#line 3676
                    r_notcontrols.h = (Uint16 )((int )r_toolopt.h - (int )r_controls.h);
#line 3677
                    r_notcontrols.x = r_toolopt.x;
#line 3678
                    r_notcontrols.y = r_toolopt.y;
#line 3680
                    r_items.x = r_notcontrols.x;
#line 3681
                    r_items.y = r_notcontrols.y;
#line 3682
                    r_items.w = r_notcontrols.w;
#line 3683
                    r_items.h = r_notcontrols.h;
#line 3685
                    if (num_rows_needed * button_h > (int )r_items.h) {
#line 3688
                      r_items.h -= button_h;
#line 3689
                      r_items.y += button_h / 2;
                    }
                    {
#line 3691
                    gd_items.rows = (Uint8 )((int )r_items.h / button_h);
#line 3693
                    toolopt_changed = 0;
#line 3695
                    __cil_tmp95 = hit_test(& r_items, (unsigned int )event.button.x,
                                           (unsigned int )event.button.y);
                    }
#line 3695
                    if (__cil_tmp95) {
                      {
#line 3697
                      __cil_tmp96 = grid_hit_gd(& r_items, (unsigned int )event.button.x,
                                                (unsigned int )event.button.y, & gd_items);
#line 3697
                      which = __cil_tmp96 + *thing_scroll;
                      }
#line 3699
                      if (which < num_things) {
#line 3701
                        toolopt_changed = 1;
#line 3703
                        if ((*(stamp_data[stamp_group] + which))->ssnd == (void *)0) {
                          {
                          {
#line 3705
                          playsound(screen, 1, 2, 0, - 999, - 999);
                          }
                          }
                        } else
#line 3703
                        if (cur_tool != 1) {
                          {
                          {
#line 3705
                          playsound(screen, 1, 2, 0, - 999, - 999);
                          }
                          }
                        }
#line 3708
                        cur_thing = which;
#line 3709
                        do_draw = 1;
                      }
                    } else {
                      {
#line 3712
                      __cil_tmp97 = hit_test(& r_controls, (unsigned int )event.button.x,
                                             (unsigned int )event.button.y);
                      }
#line 3712
                      if (__cil_tmp97) {
                        {
#line 3714
                        which = grid_hit_gd(& r_controls, (unsigned int )event.button.x,
                                            (unsigned int )event.button.y, & gd_controls);
                        }
#line 3715
                        if (cur_tool == 1) {
#line 3718
                          control_sound = - 1;
#line 3720
                          if (which == 4) {
                            _L___56: /* CIL Label */ 
#line 3749
                            old_size = (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size;
#line 3751
                            (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size = (unsigned int )(((((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->max - (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min) + 1) * ((int )event.button.x - (WINDOW_WIDTH - (int )r_ttoolopt.w))) / (int )r_ttoolopt.w + (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min);
#line 3761
                            if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size < old_size) {
#line 3762
                              control_sound = 21;
                            } else
#line 3763
                            if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size > old_size) {
#line 3764
                              control_sound = 22;
                            }
                          } else
#line 3720
                          if (which == 5) {
#line 3720
                            goto _L___56;
                          } else
#line 3767
                          if (which == 2) {
                            _L___55: /* CIL Label */ 
#line 3770
                            if (which == 3) {
#line 3773
                              if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->flipable) {
#line 3775
                                (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->flipped = ! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->flipped;
#line 3777
                                control_sound = 16;
                              }
                            } else
#line 3783
                            if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->mirrorable) {
#line 3785
                              (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->mirrored = ! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->mirrored;
#line 3787
                              control_sound = 17;
                            }
                          } else
#line 3767
                          if (which == 3) {
#line 3767
                            goto _L___55;
                          } else {
#line 3795
                            old_stamp_group = stamp_group;
#line 3797
                            if (which == 1) {
#line 3800
                              stamp_group ++;
#line 3801
                              if (stamp_group >= num_stamp_groups) {
#line 3802
                                stamp_group = 0;
                              }
#line 3803
                              control_sound = 1;
                            } else {
#line 3808
                              __cil_tmp102 = stamp_group;
#line 3808
                              stamp_group --;
#line 3809
                              if (stamp_group < 0) {
#line 3810
                                stamp_group = num_stamp_groups - 1;
                              }
#line 3811
                              control_sound = 1;
                            }
#line 3814
                            if (stamp_group == old_stamp_group) {
#line 3815
                              control_sound = - 1;
                            } else {
#line 3818
                              cur_thing = cur_stamp[stamp_group];
#line 3819
                              num_things = num_stamps[stamp_group];
#line 3820
                              thing_scroll = & stamp_scroll[stamp_group];
                            }
                          }
#line 3824
                          if (control_sound != -1) {
                            {
#line 3826
                            playsound(screen, 0, control_sound, 0, - 998, - 999);
#line 3827
                            draw_stamps();
#line 3828
                            update_screen_rect(& r_toolopt);
#line 3829
                            set_active_stamp();
#line 3830
                            update_stamp_xor();
                            }
                          }
                        } else
#line 3833
                        if (cur_tool == 7) {
#line 3838
                          grp = magic_group;
#line 3839
                          cur = cur_magic[grp];
#line 3841
                          if (which == 0) {
                            _L___60: /* CIL Label */ 
                            {
#line 3843
                            tries = 0;
#line 3845
                            magic_switchout(canvas);
                            }
                            {
#line 3848
                            while (1) {
                              while_continue___4: /* CIL Label */ ;
#line 3850
                              tries ++;
#line 3852
                              if (which == 0) {
#line 3854
                                __cil_tmp107 = magic_group;
#line 3854
                                magic_group --;
#line 3855
                                if (magic_group < 0) {
#line 3856
                                  magic_group = 15;
                                }
                              } else
#line 3858
                              if (which == 1) {
#line 3860
                                magic_group ++;
#line 3861
                                if (magic_group >= 16) {
#line 3862
                                  magic_group = 0;
                                }
                              }
#line 3848
                              if (! (num_magics[magic_group] == 0 && tries < 16)) {
#line 3848
                                goto while_break___4;
                              }
                            }
                            while_break___4: /* CIL Label */ ;
                            }
                            {
#line 3867
                            keybd_flag = 0;
#line 3868
                            cur_thing = cur_magic[magic_group];
#line 3869
                            num_things = num_magics[magic_group];
#line 3870
                            thing_scroll = & magic_scroll[magic_group];
#line 3871
                            magic_current_snd_ptr = (Mix_Chunk *)((void *)0);
#line 3873
                            draw_magic();
#line 3874
                            update_screen_rect(& r_toolopt);
#line 3876
                            draw_colors((unsigned int )magics[magic_group][cur_thing].colors);
                            }
#line 3878
                            if (magics[magic_group][cur_thing].colors) {
                              {
#line 3879
                              (*(magic_funcs[magics[magic_group][cur_thing].handle_idx].set_color))(magic_api_struct,
                                                                                                    *(*(color_hexes + cur_color) + 0),
                                                                                                    *(*(color_hexes + cur_color) + 1),
                                                                                                    *(*(color_hexes + cur_color) + 2));
                              }
                            }
                            {
#line 3884
                            magic_switchin(canvas);
#line 3886
                            playsound(screen, 0, 1, 0, - 998, - 999);
                            }
                          } else
#line 3841
                          if (which == 1) {
#line 3841
                            goto _L___60;
                          } else
#line 3891
                          if (which == 3) {
#line 3891
                            if (magics[grp][cur].avail_modes & 2) {
                              {
#line 3893
                              magic_switchout(canvas);
#line 3894
                              magics[grp][cur].mode = 2;
#line 3895
                              magic_switchin(canvas);
#line 3896
                              draw_magic();
#line 3897
                              update_screen_rect(& r_toolopt);
                              }
                            } else {
#line 3891
                              goto _L___59;
                            }
                          } else
                          _L___59: /* CIL Label */ 
#line 3899
                          if (which == 2) {
#line 3899
                            if (magics[grp][cur].avail_modes & 1) {
                              {
#line 3901
                              magic_switchout(canvas);
#line 3902
                              magics[grp][cur].mode = 1;
#line 3903
                              magic_switchin(canvas);
#line 3904
                              draw_magic();
#line 3905
                              update_screen_rect(& r_toolopt);
                              }
                            } else {
#line 3899
                              goto _L___58;
                            }
                          } else
                          _L___58: /* CIL Label */ 
#line 3907
                          if (which == 2) {
#line 3907
                            if (magics[grp][cur].avail_modes & 4) {
                              {
#line 3909
                              magic_switchout(canvas);
#line 3910
                              magics[grp][cur].mode = 4;
#line 3911
                              magic_switchin(canvas);
#line 3912
                              draw_magic();
#line 3913
                              update_screen_rect(& r_toolopt);
                              }
                            } else {
#line 3907
                              goto _L___57;
                            }
                          } else
                          _L___57: /* CIL Label */ 
#line 3915
                          if (which == 2) {
#line 3915
                            if (magics[grp][cur].avail_modes & 8) {
                              {
#line 3917
                              magic_switchout(canvas);
#line 3918
                              magics[grp][cur].mode = 8;
#line 3919
                              magic_switchin(canvas);
#line 3920
                              draw_magic();
#line 3921
                              update_screen_rect(& r_toolopt);
                              }
                            }
                          }
                        } else
#line 3926
                        if (cur_tool == 3) {
                          {
#line 3929
                          shape_mode = which;
#line 3930
                          draw_shapes();
#line 3931
                          update_screen_rect(& r_toolopt);
#line 3932
                          draw_tux_text(3, shapemode_tips[shape_mode], 1);
#line 3933
                          playsound(screen, 0, 1, 0, - 999, - 999);
#line 3934
                          update_screen_rect(& r_tuxarea);
#line 3935
                          toolopt_changed = 0;
                          }
                        } else
#line 3937
                        if (cur_tool == 4) {
#line 3940
                          control_sound___0 = - 1;
#line 3942
                          if (which & 2) {
#line 3945
                            if (which & 1) {
#line 3948
                              if ((unsigned long )text_size < sizeof(text_sizes___1) / sizeof(text_sizes___1[0]) - 1UL) {
#line 3950
                                text_size ++;
#line 3951
                                control_sound___0 = 22;
#line 3952
                                toolopt_changed = 1;
                              }
                            } else
#line 3958
                            if (text_size > 0U) {
#line 3960
                              __cil_tmp111 = text_size;
#line 3960
                              text_size --;
#line 3961
                              control_sound___0 = 21;
#line 3962
                              toolopt_changed = 1;
                            }
                          } else {
#line 3969
                            if (which & 1) {
#line 3972
                              if (text_state & 2) {
#line 3974
                                text_state &= ~ 2;
#line 3975
                                control_sound___0 = 23;
                              } else {
#line 3979
                                text_state |= 2;
#line 3980
                                control_sound___0 = 24;
                              }
                            } else
#line 3986
                            if (text_state & 1) {
#line 3988
                              text_state &= ~ 1;
#line 3989
                              control_sound___0 = 29;
                            } else {
#line 3993
                              text_state |= 1;
#line 3994
                              control_sound___0 = 28;
                            }
#line 3997
                            toolopt_changed = 1;
                          }
#line 3999
                          if (control_sound___0 != -1) {
                            {
#line 4001
                            playsound(screen, 0, control_sound___0, 0, - 998, - 999);
                            }
#line 4004
                            if (cur_tool == 4) {
#line 4010
                              i___61 = 0;
                              {
#line 4010
                              while (1) {
                                while_continue___5: /* CIL Label */ ;
#line 4010
                                if (! (i___61 < num_font_families)) {
#line 4010
                                  goto while_break___5;
                                }
#line 4012
                                if (*(user_font_families + i___61)) {
#line 4012
                                  if ((*(user_font_families + i___61))->handle) {
                                    {
#line 4014
                                    TuxPaint_Font_CloseFont((*(user_font_families + i___61))->handle);
#line 4015
                                    (*(user_font_families + i___61))->handle = (TuxPaint_Font *)((void *)0);
                                    }
                                  }
                                }
#line 4010
                                i___61 ++;
                              }
                              while_break___5: /* CIL Label */ ;
                              }
                              {
#line 4018
                              draw_fonts();
#line 4019
                              update_screen_rect(& r_toolopt);
                              }
                            }
                          }
                        } else
#line 4025
                        if (cur_tool == 5) {
#line 4027
                          control_sound___1 = - 1;
#line 4029
                          if (which & 4) {
#line 4032
                            if (which & 1) {
#line 4035
                              if ((unsigned long )text_size < sizeof(text_sizes___1) / sizeof(text_sizes___1[0]) - 1UL) {
#line 4037
                                text_size ++;
#line 4038
                                control_sound___1 = 22;
#line 4039
                                toolopt_changed = 1;
                              }
                            } else
#line 4045
                            if (text_size > 0U) {
#line 4047
                              __cil_tmp116 = text_size;
#line 4047
                              text_size --;
#line 4048
                              control_sound___1 = 21;
#line 4049
                              toolopt_changed = 1;
                            }
                          } else
#line 4055
                          if (which & 2) {
#line 4058
                            if (which & 1) {
#line 4061
                              if (text_state & 2) {
#line 4063
                                text_state &= ~ 2;
#line 4064
                                control_sound___1 = 23;
                              } else {
#line 4068
                                text_state |= 2;
#line 4069
                                control_sound___1 = 24;
                              }
                            } else
#line 4075
                            if (text_state & 1) {
#line 4077
                              text_state &= ~ 1;
#line 4078
                              control_sound___1 = 29;
                            } else {
#line 4082
                              text_state |= 1;
#line 4083
                              control_sound___1 = 28;
                            }
#line 4086
                            toolopt_changed = 1;
                          } else
#line 4092
                          if (which & 1) {
#line 4095
                            if (cur_label == 2) {
                              {
#line 4097
                              cur_label = 1;
#line 4098
                              update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w,
                                            button_h * buttons_tall + (int )r_ttoolopt.h);
                              }
#line 4099
                              if (onscreen_keyboard) {
                                {
#line 4101
                                SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 4102
                                update_screen_rect(& kbd_rect);
                                }
                              }
                            } else {
                              {
#line 4107
                              __cil_tmp117 = are_labels();
                              }
#line 4107
                              if (__cil_tmp117) {
                                {
#line 4109
                                update_canvas_ex_r((int )kbd_rect.x - (int )r_ttools.w,
                                                   (int )kbd_rect.y, (int )kbd_rect.x + (int )kbd_rect.w,
                                                   (int )kbd_rect.y + (int )kbd_rect.h,
                                                   1);
                                }
#line 4112
                                if (texttool_len > 0U) {
                                  {
#line 4114
                                  rec_undo_buffer();
#line 4115
                                  do_render_cur_text(1);
#line 4116
                                  texttool_len = (unsigned int )0;
#line 4117
                                  cursor_textwidth = 0;
#line 4118
                                  label_node_to_edit = (struct label_node *)((void *)0);
                                  }
                                } else
#line 4120
                                if (label_node_to_edit) {
                                  {
#line 4122
                                  rec_undo_buffer();
#line 4123
                                  have_to_rec_label_node = ! 0;
#line 4124
                                  add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
#line 4125
                                  label_node_to_edit = (struct label_node *)((void *)0);
                                  }
                                }
                                {
#line 4129
                                cur_label = 2;
#line 4130
                                highlight_label_nodes();
                                }
                              }
                            }
#line 4133
                            toolopt_changed = 1;
                          }
#line 4138
                          if (control_sound___1 != -1) {
                            {
#line 4140
                            playsound(screen, 0, control_sound___1, 0, - 998, - 999);
                            }
#line 4143
                            if (cur_tool == 5) {
#line 4149
                              i___62 = 0;
                              {
#line 4149
                              while (1) {
                                while_continue___6: /* CIL Label */ ;
#line 4149
                                if (! (i___62 < num_font_families)) {
#line 4149
                                  goto while_break___6;
                                }
#line 4151
                                if (*(user_font_families + i___62)) {
#line 4151
                                  if ((*(user_font_families + i___62))->handle) {
                                    {
#line 4153
                                    TuxPaint_Font_CloseFont((*(user_font_families + i___62))->handle);
#line 4154
                                    (*(user_font_families + i___62))->handle = (TuxPaint_Font *)((void *)0);
                                    }
                                  }
                                }
#line 4149
                                i___62 ++;
                              }
                              while_break___6: /* CIL Label */ ;
                              }
                              {
#line 4157
                              draw_fonts();
#line 4158
                              update_screen_rect(& r_toolopt);
                              }
                            }
                          }
                          {
#line 4161
                          draw_fonts();
#line 4162
                          update_screen_rect(& r_toolopt);
                          }
                        }
                      } else {
#line 4169
                        is_upper = (int )event.button.y < (int )r_toolopt.y + button_h / 2;
#line 4171
                        if (is_upper) {
#line 4171
                          if (*thing_scroll > 0) {
                            _L___64: /* CIL Label */ 
#line 4175
                            if (is_upper) {
#line 4175
                              tmp = - ((int )gd_items.cols);
                            } else {
#line 4175
                              tmp = (int )gd_items.cols;
                            }
                            {
#line 4175
                            *thing_scroll += tmp;
#line 4176
                            do_draw = 1;
#line 4177
                            playsound(screen, 1, 7, 1, - 999, - 999);
                            }
#line 4179
                            if (scrolltimer != (void *)0) {
                              {
#line 4181
                              SDL_RemoveTimer(scrolltimer);
#line 4182
                              scrolltimer = (SDL_TimerID )((void *)0);
                              }
                            }
#line 4185
                            if (! scrolling) {
#line 4185
                              if ((int )event.type == 5) {
                                {
#line 4188
                                memcpy(& scrolltimer_event, & event, sizeof(SDL_Event ));
#line 4189
                                scrolltimer_event.type = (Uint8 )25;
#line 4198
                                scrolling = 1;
#line 4199
                                SDL_InitSubSystem((Uint32 )1);
#line 4200
                                scrolltimer = SDL_AddTimer((Uint32 )300, & scrolltimer_callback,
                                                           (void *)(& scrolltimer_event));
                                }
                              } else {
                                {
                                {
#line 4206
                                scrolltimer = SDL_AddTimer((Uint32 )100, & scrolltimer_callback,
                                                           (void *)(& scrolltimer_event));
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 4206
                              scrolltimer = SDL_AddTimer((Uint32 )100, & scrolltimer_callback,
                                                         (void *)(& scrolltimer_event));
                              }
                              }
                            }
#line 4210
                            if (*thing_scroll == 0) {
                              _L___63: /* CIL Label */ 
                              {
#line 4212
                              do_setcursor(cursor_arrow);
                              }
#line 4213
                              if (scrolling) {
#line 4215
                                if (scrolltimer != (void *)0) {
                                  {
#line 4217
                                  SDL_RemoveTimer(scrolltimer);
#line 4218
                                  scrolltimer = (SDL_TimerID )((void *)0);
                                  }
                                }
                                {
#line 4220
                                scrolling = 0;
#line 4221
                                SDL_QuitSubSystem((Uint32 )1);
                                }
                              }
                            } else
#line 4210
                            if (*thing_scroll / (int )gd_items.cols == num_rows_needed - (int )gd_items.rows) {
#line 4210
                              goto _L___63;
                            }
                          } else {
#line 4171
                            goto _L___65;
                          }
                        } else
                        _L___65: /* CIL Label */ 
#line 4171
                        if (! is_upper) {
#line 4171
                          if (*thing_scroll / (int )gd_items.cols < num_rows_needed - (int )gd_items.rows) {
#line 4171
                            goto _L___64;
                          }
                        }
                      }
                    }
#line 4230
                    if (cur_tool == 0) {
                      _L___67: /* CIL Label */ 
                      {
#line 4232
                      cur_brush = cur_thing;
#line 4233
                      render_brush();
                      }
#line 4235
                      if (do_draw) {
                        {
#line 4236
                        draw_brushes();
                        }
                      }
                    } else
#line 4230
                    if (cur_tool == 2) {
#line 4230
                      goto _L___67;
                    } else
#line 4238
                    if (cur_tool == 10) {
#line 4240
                      cur_eraser = cur_thing;
#line 4242
                      if (do_draw) {
                        {
#line 4243
                        draw_erasers();
                        }
                      }
                    } else
#line 4245
                    if (cur_tool == 6) {
                      {
#line 4247
                      cur_fill = cur_thing;
#line 4248
                      draw_tux_text(3, fill_tips[cur_fill], 1);
                      }
#line 4250
                      if (do_draw) {
                        {
#line 4251
                        draw_fills();
                        }
                      }
                    } else
#line 4253
                    if (cur_tool == 4) {
                      _L___66: /* CIL Label */ 
#line 4258
                      cur_font = cur_thing;
#line 4268
                      if (do_draw) {
                        {
#line 4269
                        draw_fonts();
                        }
                      }
#line 4273
                      if (toolopt_changed) {
                        {
#line 4275
                        draw_fonts();
                        }
#line 4276
                        if (select_changed) {
                          {
#line 4278
                          rec_undo_buffer();
#line 4279
                          do_render_cur_text(1);
#line 4280
                          texttool_len = (unsigned int )0;
                          }
                        } else {
                          {
#line 4284
                          do_render_cur_text(0);
                          }
                        }
                      }
                    } else
#line 4253
                    if (cur_tool == 5) {
#line 4253
                      goto _L___66;
                    } else
#line 4288
                    if (cur_tool == 1) {
#line 4292
                      if (toolopt_changed) {
#line 4292
                        if (! mute) {
#line 4296
                          if ((*(stamp_data[stamp_group] + cur_thing))->ssnd != (void *)0) {
                            {
#line 4298
                            Mix_ChannelFinished((void (*)(int  ))((void *)0));
#line 4300
                            Mix_PlayChannelTimed(2, (*(stamp_data[stamp_group] + cur_thing))->ssnd,
                                                 0, - 1);
                            }
#line 4304
                            if ((*(stamp_data[stamp_group] + cur_thing))->sdesc != (void *)0) {
                              {
#line 4306
                              Mix_ChannelFinished(& playstampdesc);
                              }
                            }
                          } else
#line 4313
                          if ((*(stamp_data[stamp_group] + cur_thing))->sdesc != (void *)0) {
                            {
#line 4315
                            Mix_PlayChannelTimed(2, (*(stamp_data[stamp_group] + cur_thing))->sdesc,
                                                 0, - 1);
                            }
                          }
                        }
                      }
#line 4321
                      if (cur_thing != cur_stamp[stamp_group]) {
                        {
#line 4323
                        cur_stamp[stamp_group] = cur_thing;
#line 4324
                        set_active_stamp();
#line 4325
                        update_stamp_xor();
                        }
                      }
#line 4328
                      if (do_draw) {
                        {
#line 4329
                        draw_stamps();
                        }
                      }
#line 4331
                      if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->stxt != (void *)0) {
                        {
#line 4338
                        draw_tux_text_ex(3, (char const   *)(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->stxt,
                                         1, (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->locale_text);
                        }
                      } else {
                        {
#line 4342
                        draw_tux_text(3, "\251", 0);
                        }
                      }
                      {
#line 4345
                      __cil_tmp125 = stamp_tintable(cur_stamp[stamp_group]);
                      }
                      {
#line 4345
                      __cil_tmp124 = stamp_colorable(cur_stamp[stamp_group]);
#line 4345
                      draw_colors((unsigned int )(__cil_tmp124 || __cil_tmp125));
                      }
#line 4347
                      if (! scrolling) {
                        {
#line 4349
                        stamp_xor(canvas->w / 2, canvas->h / 2);
#line 4350
                        stamp_xored = 1;
#line 4351
                        stamp_size_selector_clicked = 1;
#line 4352
                        update_screen((int )(((unsigned int )(canvas->w / 2) - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )(canvas->h / 2) - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y),
                                      (int )(((unsigned int )(canvas->w / 2) + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )(canvas->h / 2) + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y));
                        }
                      }
                    } else
#line 4358
                    if (cur_tool == 3) {
#line 4360
                      cur_shape = cur_thing;
#line 4363
                      if (shape_tool_mode != 2) {
                        {
#line 4365
                        shape_tool_mode = 2;
#line 4366
                        do_undo();
#line 4367
                        tool_avail[9] = 0;
#line 4368
                        draw_toolbar();
#line 4369
                        update_screen_rect(& r_tools);
#line 4370
                        update_canvas(0, 0, canvas->w, canvas->h);
                        }
                      }
#line 4373
                      if (toolopt_changed) {
                        {
#line 4374
                        draw_tux_text(3, shape_tips[cur_shape], 1);
                        }
                      }
#line 4376
                      if (do_draw) {
                        {
#line 4377
                        draw_shapes();
                        }
                      }
                    } else
#line 4379
                    if (cur_tool == 7) {
#line 4384
                      grp___0 = magic_group;
#line 4385
                      cur___0 = cur_magic[grp___0];
#line 4387
                      if (cur_thing != cur___0) {
                        {
#line 4389
                        cur___0 = cur_thing;
#line 4390
                        magic_switchout(canvas);
#line 4392
                        cur_magic[grp___0] = cur_thing;
#line 4393
                        draw_colors((unsigned int )magics[grp___0][cur___0].colors);
                        }
#line 4395
                        if (magics[grp___0][cur___0].colors) {
                          {
#line 4396
                          (*(magic_funcs[magics[grp___0][cur___0].handle_idx].set_color))(magic_api_struct,
                                                                                          *(*(color_hexes + cur_color) + 0),
                                                                                          *(*(color_hexes + cur_color) + 1),
                                                                                          *(*(color_hexes + cur_color) + 2));
                          }
                        }
                        {
#line 4401
                        magic_switchin(canvas);
                        }
                      }
                      {
#line 4404
                      __cil_tmp128 = magic_modeint(magics[grp___0][cur___0].mode);
#line 4404
                      draw_tux_text(3, (char const   *)magics[grp___0][cur___0].tip[__cil_tmp128],
                                    1);
                      }
#line 4406
                      if (do_draw) {
                        {
#line 4407
                        draw_magic();
                        }
                      }
                    }
#line 4411
                    if (do_draw) {
                      {
#line 4412
                      update_screen_rect(& r_toolopt);
                      }
                    }
                  } else
#line 3581
                  if (cur_tool == 1) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 3) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 2) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 7) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 4) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 10) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 5) {
#line 3581
                    goto _L___68;
                  } else
#line 3581
                  if (cur_tool == 6) {
#line 3581
                    goto _L___68;
                  }
                } else {
#line 3575
                  goto _L___85;
                }
              } else {
                _L___85: /* CIL Label */ 
                {
#line 4415
                __cil_tmp129 = hit_test(& r_colors, (unsigned int )event.button.x,
                                        (unsigned int )event.button.y);
                }
#line 4415
                if (__cil_tmp129) {
#line 4415
                  if (colors_are_selectable) {
                    {
#line 4418
                    whichc = grid_hit_gd(& r_colors, (unsigned int )event.button.x,
                                         (unsigned int )event.button.y, & gd_colors);
#line 4420
                    __cil_tmp131 = valid_click(event.button.button);
                    }
#line 4420
                    if (__cil_tmp131) {
#line 4424
                      if (whichc >= 0) {
#line 4424
                        if (whichc < NUM_COLORS) {
                          {
#line 4426
                          cur_color = (unsigned int )whichc;
#line 4427
                          draw_tux_text(1, (char const   *)*(color_names + cur_color),
                                        1);
                          }
#line 4429
                          if (cur_color == (unsigned int )(NUM_COLORS - 1)) {
                            _L___77: /* CIL Label */ 
                            {
#line 4431
                            disable_avail_tools();
#line 4432
                            draw_toolbar();
#line 4433
                            draw_colors((unsigned int )8);
#line 4434
                            draw_none();
                            }
#line 4436
                            if (cur_color == (unsigned int )(NUM_COLORS - 1)) {
                              {
#line 4437
                              do_color_picker();
                              }
                            } else {
                              {
#line 4439
                              do_color_sel();
                              }
                            }
#line 4441
                            if (cur_tool == 4) {
                              _L___76: /* CIL Label */ 
#line 4443
                              if (kbd) {
#line 4443
                                if (onscreen_keyboard) {
                                  {
#line 4445
                                  SDL_UpperBlit(kbd->surface, & kbd->rect, screen,
                                                & kbd_rect);
#line 4446
                                  update_screen_rect(& kbd_rect);
                                  }
                                }
                              }
                            } else
#line 4441
                            if (cur_tool == 5) {
#line 4441
                              goto _L___76;
                            }
                            {
#line 4450
                            enable_avail_tools();
#line 4451
                            draw_toolbar();
#line 4452
                            update_screen_rect(& r_tools);
#line 4454
                            draw_cur_tool_tip();
#line 4456
                            draw_colors((unsigned int )16);
                            }
#line 4458
                            if (cur_tool == 0) {
                              {
                              {
#line 4459
                              draw_brushes();
                              }
                              }
                            } else
#line 4458
                            if (cur_tool == 2) {
                              {
                              {
#line 4459
                              draw_brushes();
                              }
                              }
                            } else
#line 4460
                            if (cur_tool == 7) {
                              {
#line 4461
                              draw_magic();
                              }
                            } else
#line 4462
                            if (cur_tool == 1) {
                              {
#line 4463
                              draw_stamps();
                              }
                            } else
#line 4464
                            if (cur_tool == 4) {
                              {
                              {
#line 4465
                              draw_fonts();
                              }
                              }
                            } else
#line 4464
                            if (cur_tool == 5) {
                              {
                              {
#line 4465
                              draw_fonts();
                              }
                              }
                            } else
#line 4466
                            if (cur_tool == 3) {
                              {
#line 4467
                              draw_shapes();
                              }
                            } else
#line 4468
                            if (cur_tool == 10) {
                              {
#line 4469
                              draw_erasers();
                              }
                            } else
#line 4470
                            if (cur_tool == 6) {
                              {
#line 4471
                              draw_fills();
                              }
                            }
                            {
#line 4473
                            playsound(screen, 1, 3, 1, - 998, - 999);
#line 4475
                            SDL_Flip(screen);
                            }
                          } else
#line 4429
                          if (cur_color == (unsigned int )(NUM_COLORS - 2)) {
#line 4429
                            goto _L___77;
                          } else {
                            {
#line 4479
                            draw_colors((unsigned int )4);
#line 4481
                            playsound(screen, 1, 3, 1, (int )event.button.x, - 999);
                            }
                          }
                          {
#line 4484
                          render_brush();
                          }
#line 4487
                          if (cur_tool == 4) {
                            {
                            {
#line 4488
                            do_render_cur_text(0);
                            }
                            }
                          } else
#line 4487
                          if (cur_tool == 5) {
                            {
                            {
#line 4488
                            do_render_cur_text(0);
                            }
                            }
                          } else
#line 4489
                          if (cur_tool == 7) {
                            {
#line 4490
                            (*(magic_funcs[magics[magic_group][cur_magic[magic_group]].handle_idx].set_color))(magic_api_struct,
                                                                                                               *(*(color_hexes + cur_color) + 0),
                                                                                                               *(*(color_hexes + cur_color) + 1),
                                                                                                               *(*(color_hexes + cur_color) + 2));
                            }
                          }
                        }
                      }
                    }
                  } else {
#line 4415
                    goto _L___84;
                  }
                } else {
                  _L___84: /* CIL Label */ 
                  {
#line 4498
                  __cil_tmp133 = valid_click(event.button.button);
                  }
                  {
#line 4498
                  __cil_tmp132 = hit_test(& r_canvas, (unsigned int )event.button.x,
                                          (unsigned int )event.button.y);
                  }
#line 4498
                  if (__cil_tmp132) {
#line 4498
                    if (__cil_tmp133) {
#line 4498
                      if (keyglobal == 0) {
#line 4501
                        old_x = (int )event.button.x - (int )r_canvas.x;
#line 4502
                        old_y = (int )event.button.y - (int )r_canvas.y;
#line 4512
                        if (been_saved) {
#line 4514
                          been_saved = 0;
#line 4516
                          if (! disable_save) {
#line 4517
                            tool_avail[13] = 1;
                          }
                          {
#line 4519
                          draw_toolbar();
#line 4520
                          update_screen_rect(& r_tools);
                          }
                        }
#line 4523
                        if (cur_tool == 0) {
#line 4526
                          if (! emulate_button_pressed) {
                            {
#line 4527
                            rec_undo_buffer();
                            }
                          }
                          {
#line 4530
                          reset_brush_counter();
#line 4533
                          __cil_tmp134 = paintsound(img_cur_brush_w);
#line 4533
                          playsound(screen, 0, __cil_tmp134, 1, (int )event.button.x,
                                    - 999);
                          }
#line 4535
                          if (mouseaccessibility) {
#line 4536
                            emulate_button_pressed = ! emulate_button_pressed;
                          }
                        } else
#line 4538
                        if (cur_tool == 2) {
#line 4542
                          if (! emulate_button_pressed) {
                            {
#line 4544
                            rec_undo_buffer();
#line 4546
                            line_start_x = old_x;
#line 4547
                            line_start_y = old_y;
#line 4550
                            reset_brush_counter();
#line 4554
                            playsound(screen, 1, 5, 1, (int )event.button.x, - 999);
#line 4555
                            draw_tux_text(2, "Let go of the button to complete the line.",
                                          1);
                            }
                          }
#line 4557
                          if (mouseaccessibility) {
#line 4558
                            emulate_button_pressed = ! emulate_button_pressed;
                          }
                        } else
#line 4560
                        if (cur_tool == 3) {
#line 4562
                          if (shape_tool_mode == 2) {
                            {
#line 4566
                            rec_undo_buffer();
#line 4568
                            shape_start_x = old_x;
#line 4569
                            shape_start_y = old_y;
#line 4571
                            shape_tool_mode = 0;
#line 4573
                            playsound(screen, 1, 5, 1, (int )event.button.x, - 999);
#line 4574
                            draw_tux_text(2, "Hold the button to stretch the shape.",
                                          1);
                            }
#line 4575
                            if (mouseaccessibility) {
#line 4576
                              emulate_button_pressed = 1;
                            }
                          } else
#line 4578
                          if (shape_tool_mode == 1) {
#line 4584
                            if (mouseaccessibility) {
                              {
#line 4587
                              reset_brush_counter();
#line 4589
                              playsound(screen, 1, 6, 1, (int )event.button.x, - 999);
#line 4590
                              __cil_tmp135 = shape_rotation(shape_start_x, shape_start_y,
                                                            (int )event.button.x - (int )r_canvas.x,
                                                            (int )event.button.y - (int )r_canvas.y);
#line 4590
                              do_shape(shape_start_x, shape_start_y, shape_current_x,
                                       shape_current_y, __cil_tmp135, 1);
#line 4594
                              shape_tool_mode = 2;
                              }
#line 4595
                              if (simple_shapes) {
#line 4595
                                tmp___0 = 1;
                              } else {
#line 4595
                                tmp___0 = 0;
                              }
                              {
#line 4595
                              draw_tux_text(3, shape_tool_tips[tmp___0], 1);
                              }
                            }
                          } else
#line 4598
                          if (shape_tool_mode == 0) {
#line 4600
                            emulate_button_pressed = 0;
                          }
                        } else
#line 4602
                        if (cur_tool == 7) {
#line 4607
                          grp___1 = magic_group;
#line 4608
                          cur___1 = cur_magic[grp___1];
#line 4610
                          if (! emulate_button_pressed) {
                            {
#line 4627
                            rec_undo_buffer();
                            }
#line 4630
                            if (cur_undo > 0) {
#line 4631
                              undo_ctr = cur_undo - 1;
                            } else {
#line 4633
                              undo_ctr = 19;
                            }
                            {
#line 4635
                            last = undo_bufs[undo_ctr];
#line 4637
                            update_rect.x = (Sint16 )0;
#line 4638
                            update_rect.y = (Sint16 )0;
#line 4639
                            update_rect.w = (Uint16 )0;
#line 4640
                            update_rect.h = (Uint16 )0;
#line 4642
                            reset_touched();
#line 4644
                            (*(magic_funcs[magics[grp___1][cur___1].handle_idx].click))(magic_api_struct,
                                                                                        magics[grp___1][cur___1].idx,
                                                                                        magics[grp___1][cur___1].mode,
                                                                                        canvas,
                                                                                        last,
                                                                                        old_x,
                                                                                        old_y,
                                                                                        & update_rect);
#line 4649
                            __cil_tmp141 = magic_modeint(magics[grp___1][cur___1].mode);
#line 4649
                            draw_tux_text(3, (char const   *)magics[grp___1][cur___1].tip[__cil_tmp141],
                                          1);
#line 4651
                            update_canvas((int )update_rect.x, (int )update_rect.y,
                                          (int )update_rect.x + (int )update_rect.w,
                                          (int )update_rect.y + (int )update_rect.h);
                            }
                          }
#line 4655
                          if (mouseaccessibility) {
#line 4657
                            if (magics[grp___1][cur___1].mode != 2) {
#line 4657
                              if (magics[grp___1][cur___1].mode != 8) {
#line 4658
                                emulate_button_pressed = ! emulate_button_pressed;
                              }
                            }
                          }
                        } else
#line 4661
                        if (cur_tool == 10) {
#line 4664
                          if (! emulate_button_pressed) {
                            {
#line 4665
                            rec_undo_buffer();
                            }
                          }
                          {
#line 4667
                          do_eraser(old_x, old_y, 1);
                          }
#line 4669
                          if (mouseaccessibility) {
#line 4670
                            emulate_button_pressed = ! emulate_button_pressed;
                          }
                        } else
#line 4672
                        if (cur_tool == 6) {
                          {
#line 4678
                          draw_color = ((((unsigned int )*(*(color_hexes + cur_color) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + cur_color) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + cur_color) + 2) & 255U);
#line 4682
                          canv_color = (*(getpixels[(canvas->format)->BytesPerPixel]))(canvas,
                                                                                       old_x,
                                                                                       old_y);
#line 4684
                          fill_x = old_x;
#line 4685
                          fill_y = old_y;
#line 4687
                          __cil_tmp145 = would_flood_fill(canvas, draw_color, canv_color);
                          }
#line 4687
                          if (__cil_tmp145) {
                            {
#line 4696
                            rec_undo_buffer();
#line 4697
                            x2 = old_x;
#line 4697
                            x1 = x2;
#line 4698
                            y2 = old_y;
#line 4698
                            y1___0 = y2;
                            }
#line 4700
                            if (cur_undo > 0) {
#line 4701
                              undo_ctr___0 = cur_undo - 1;
                            } else {
#line 4703
                              undo_ctr___0 = 19;
                            }
#line 4705
                            last___0 = undo_bufs[undo_ctr___0];
#line 4708
                            y1___0 = 0;
                            {
#line 4708
                            while (1) {
                              while_continue___7: /* CIL Label */ ;
#line 4708
                              if (! (y1___0 < canvas->h)) {
#line 4708
                                goto while_break___7;
                              }
#line 4709
                              x1 = 0;
                              {
#line 4709
                              while (1) {
                                while_continue___8: /* CIL Label */ ;
#line 4709
                                if (! (x1 < canvas->w)) {
#line 4709
                                  goto while_break___8;
                                }
#line 4710
                                *(sim_flood_touched + (y1___0 * canvas->w + x1)) = (Uint8 )0;
#line 4709
                                x1 ++;
                              }
                              while_break___8: /* CIL Label */ ;
                              }
#line 4708
                              y1___0 ++;
                            }
                            while_break___7: /* CIL Label */ ;
                            }
#line 4714
                            if (cur_fill == 0) {
                              {
#line 4717
                              do_flood_fill(screen, last___0, canvas, old_x, old_y,
                                            draw_color, canv_color, & x1, & y1___0,
                                            & x2, & y2, sim_flood_touched);
#line 4719
                              update_canvas(x1, y1___0, x2, y2);
                              }
                            } else {
                              {
#line 4725
                              tmp_canvas = SDL_CreateRGBSurface(canvas->flags, canvas->w,
                                                                canvas->h, (int )(canvas->format)->BitsPerPixel,
                                                                (canvas->format)->Rmask,
                                                                (canvas->format)->Gmask,
                                                                (canvas->format)->Bmask,
                                                                (canvas->format)->Amask);
#line 4728
                              SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), tmp_canvas,
                                            (SDL_Rect *)((void *)0));
#line 4730
                              simulate_flood_fill(screen, last___0, tmp_canvas, old_x,
                                                  old_y, draw_color, canv_color, & x1,
                                                  & y1___0, & x2, & y2, sim_flood_touched);
#line 4731
                              SDL_FreeSurface(tmp_canvas);
#line 4733
                              sim_flood_x1 = x1;
#line 4734
                              sim_flood_y1 = y1___0;
#line 4735
                              sim_flood_x2 = x2;
#line 4736
                              sim_flood_y2 = y2;
                              }
#line 4738
                              if (cur_fill == 3) {
                                {
#line 4741
                                draw_radial_gradient(canvas, sim_flood_x1, sim_flood_y1,
                                                     sim_flood_x2, sim_flood_y2, old_x,
                                                     old_y, draw_color, sim_flood_touched);
                                }
                              } else
#line 4744
                              if (cur_fill == 2) {
                                {
#line 4747
                                draw_linear_gradient(canvas, canvas, sim_flood_x1,
                                                     sim_flood_y1, sim_flood_x2, sim_flood_y2,
                                                     fill_x, fill_y, old_x, old_y + 1,
                                                     draw_color, sim_flood_touched);
#line 4749
                                fill_drag_started = 1;
                                }
                              } else
#line 4751
                              if (cur_fill == 1) {
                                {
#line 4754
                                draw_brush_fill(canvas, sim_flood_x1, sim_flood_y1,
                                                sim_flood_x2, sim_flood_y2, fill_x,
                                                fill_y, old_x, old_y, draw_color,
                                                sim_flood_touched, & x1, & y1___0,
                                                & x2, & y2);
                                }
                              }
                              {
#line 4758
                              update_canvas(x1, y1___0, x2, y2);
                              }
                            }
                            {
#line 4761
                            draw_tux_text(3, fill_tips[cur_fill], 1);
                            }
                          }
                        } else
#line 4764
                        if (cur_tool == 4) {
                          _L___80: /* CIL Label */ 
#line 4767
                          if (cur_tool == 5) {
#line 4767
                            if (cur_label == 2) {
                              {
#line 4769
                              label_node_to_edit = search_label_list(& highlighted_label_node,
                                                                     (Uint16 )old_x,
                                                                     (Uint16 )old_y,
                                                                     0);
                              }
#line 4770
                              if (label_node_to_edit) {
                                {
#line 4772
                                cur_label = 1;
#line 4773
                                cur_thing = label_node_to_edit->save_cur_font;
#line 4774
                                do_setcursor(cursor_insertion);
#line 4775
                                i = (unsigned int )0;
#line 4776
                                label_node_to_edit->is_enabled = 0;
#line 4777
                                derender_node(& label_node_to_edit);
#line 4779
                                texttool_len = select_texttool_len;
                                }
                                {
#line 4780
                                while (1) {
                                  while_continue___9: /* CIL Label */ ;
#line 4780
                                  if (! (i < texttool_len)) {
#line 4780
                                    goto while_break___9;
                                  }
#line 4782
                                  texttool_str[i] = select_texttool_str[i];
#line 4783
                                  i ++;
                                }
                                while_break___9: /* CIL Label */ ;
                                }
#line 4785
                                texttool_str[i] = '\000';
#line 4786
                                cur_color = select_color;
#line 4787
                                old_x = (int )select_x;
#line 4788
                                old_y = (int )select_y;
#line 4789
                                cur_font = select_cur_font;
#line 4790
                                text_state = select_text_state;
#line 4791
                                text_size = select_text_size;
#line 4793
                                j = 0;
                                {
#line 4793
                                while (1) {
                                  while_continue___10: /* CIL Label */ ;
#line 4793
                                  if (! (j < num_font_families)) {
#line 4793
                                    goto while_break___10;
                                  }
#line 4795
                                  if (*(user_font_families + j)) {
#line 4795
                                    if ((*(user_font_families + j))->handle) {
                                      {
#line 4797
                                      TuxPaint_Font_CloseFont((*(user_font_families + j))->handle);
#line 4798
                                      (*(user_font_families + j))->handle = (TuxPaint_Font *)((void *)0);
                                      }
                                    }
                                  }
#line 4793
                                  j ++;
                                }
                                while_break___10: /* CIL Label */ ;
                                }
                                {
#line 4801
                                draw_fonts();
#line 4802
                                update_screen_rect(& r_toolopt);
                                }
#line 4803
                                if (onscreen_keyboard) {
#line 4805
                                  if (old_y < (int )r_canvas.h / 2) {
#line 4806
                                    kbd_rect.y = (Sint16 )((int )r_canvas.h - (kbd->surface)->h);
                                  } else {
#line 4808
                                    kbd_rect.y = (Sint16 )0;
                                  }
                                  {
#line 4810
                                  SDL_UpperBlit(kbd->surface, & kbd->rect, screen,
                                                & kbd_rect);
#line 4811
                                  update_screen_rect(& kbd_rect);
                                  }
                                }
                                {
#line 4814
                                do_render_cur_text(0);
#line 4815
                                draw_colors((unsigned int )4);
#line 4816
                                draw_fonts();
                                }
                              }
                            } else {
                              {
                              {
#line 4821
                              hide_blinking_cursor();
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 4821
                            hide_blinking_cursor();
                            }
                            }
                          }
#line 4825
                          if (cursor_x != -1) {
#line 4825
                            if (cursor_y != -1) {

                            }
                          }
                          {
#line 4836
                          __cil_tmp158 = hit_test(& kbd_rect, (unsigned int )event.button.x,
                                                  (unsigned int )event.button.y);
                          }
#line 4836
                          if (onscreen_keyboard) {
#line 4836
                            if (__cil_tmp158) {
#line 4836
                              if (! (cur_tool == 5 && cur_label == 2)) {
                                {
#line 4838
                                new_kbd = osk_clicked(kbd, (old_x - (int )kbd_rect.x) + (int )r_canvas.x,
                                                      (old_y - (int )kbd_rect.y) + (int )r_canvas.y);
                                }
#line 4840
                                if (new_kbd != kbd) {
                                  {
#line 4842
                                  kbd = new_kbd;
#line 4843
                                  update_canvas_ex((int )kbd_rect.x, (int )kbd_rect.y,
                                                   (int )kbd_rect.x + (int )kbd_rect.w,
                                                   (int )kbd_rect.y + (int )kbd_rect.h,
                                                   0);
#line 4846
                                  kbd_rect.x = (Sint16 )(button_w * 2 + (canvas->w - (kbd->surface)->w) / 2);
                                  }
#line 4847
                                  if ((int )kbd_rect.y != 0) {
#line 4848
                                    kbd_rect.y = (Sint16 )(canvas->h - (kbd->surface)->h);
                                  }
#line 4849
                                  kbd_rect.w = (Uint16 )(kbd->surface)->w;
#line 4850
                                  kbd_rect.h = (Uint16 )(kbd->surface)->h;
                                }
                                {
#line 4852
                                SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
#line 4853
                                update_screen_rect(& kbd_rect);
                                }
                              } else {
#line 4836
                                goto _L___78;
                              }
                            } else {
#line 4836
                              goto _L___78;
                            }
                          } else {
                            _L___78: /* CIL Label */ 
                            _L___79: /* CIL Label */ 
#line 4857
                            cursor_x = old_x;
#line 4858
                            cursor_y = old_y;
#line 4859
                            cursor_left = old_x;
#line 4861
                            if (onscreen_keyboard) {
#line 4861
                              if (! (cur_tool == 5 && cur_label == 2)) {
#line 4863
                                if (old_y < (int )r_canvas.h / 2) {
#line 4865
                                  if ((int )kbd_rect.y != (int )r_canvas.h - (kbd->surface)->h) {
                                    {
#line 4867
                                    update_canvas_ex((int )kbd_rect.x, (int )kbd_rect.y,
                                                     (int )kbd_rect.x + (int )kbd_rect.w,
                                                     (int )kbd_rect.y + (int )kbd_rect.h,
                                                     0);
#line 4869
                                    update_screen_rect(& kbd_rect);
#line 4870
                                    kbd_rect.y = (Sint16 )((int )r_canvas.h - (kbd->surface)->h);
#line 4871
                                    SDL_UpperBlit(kbd->surface, & kbd->rect, screen,
                                                  & kbd_rect);
#line 4872
                                    update_screen_rect(& kbd_rect);
                                    }
                                  }
                                } else
#line 4877
                                if ((int )kbd_rect.y != 0) {
                                  {
#line 4879
                                  update_canvas_ex((int )kbd_rect.x, (int )kbd_rect.y,
                                                   (int )kbd_rect.x + (int )kbd_rect.w,
                                                   (int )kbd_rect.y + (int )kbd_rect.h,
                                                   0);
#line 4881
                                  update_screen_rect(& kbd_rect);
#line 4882
                                  kbd_rect.y = (Sint16 )0;
#line 4883
                                  SDL_UpperBlit(kbd->surface, & kbd->rect, screen,
                                                & kbd_rect);
#line 4884
                                  update_screen_rect(& kbd_rect);
                                  }
                                }
                              }
                            }
                          }
                          {
#line 4890
                          do_render_cur_text(0);
                          }
                        } else
#line 4764
                        if (cur_tool == 5) {
#line 4764
                          goto _L___80;
                        }
#line 4893
                        button_down = 1;
                      } else {
#line 4498
                        goto _L___82;
                      }
                    } else {
#line 4498
                      goto _L___82;
                    }
                  } else {
                    _L___82: /* CIL Label */ 
                    _L___83: /* CIL Label */ 
                    {
#line 4895
                    __cil_tmp161 = valid_click(event.button.button);
                    }
                    {
#line 4895
                    __cil_tmp160 = hit_test(& r_sfx, (unsigned int )event.button.x,
                                            (unsigned int )event.button.y);
                    }
#line 4895
                    if (__cil_tmp160) {
#line 4895
                      if (__cil_tmp161) {
#line 4899
                        if (cur_tool == 1) {
#line 4899
                          if (use_sound) {
#line 4899
                            if (! mute) {
                              {
#line 4901
                              which = grid_hit_gd(& r_sfx, (unsigned int )event.button.x,
                                                  (unsigned int )event.button.y, & gd_sfx);
                              }
#line 4903
                              if (which == 0) {
#line 4903
                                if (! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_sound) {
                                  {
#line 4907
                                  Mix_ChannelFinished((void (*)(int  ))((void *)0));
#line 4908
                                  Mix_PlayChannelTimed(2, (*(stamp_data[stamp_group] + cur_thing))->ssnd,
                                                       0, - 1);
                                  }
                                } else {
#line 4903
                                  goto _L___81;
                                }
                              } else
                              _L___81: /* CIL Label */ 
#line 4910
                              if (which == 1) {
#line 4910
                                if (! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_descsound) {
                                  {
#line 4912
                                  Mix_ChannelFinished((void (*)(int  ))((void *)0));
#line 4913
                                  Mix_PlayChannelTimed(2, (*(stamp_data[stamp_group] + cur_thing))->sdesc,
                                                       0, - 1);
                                  }
                                }
                              }
                              {
#line 4916
                              magic_switchout(canvas);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
#line 3120
            goto _L___124;
          }
        } else
#line 3120
        if ((int )event.type == 25) {
#line 3120
          goto _L___125;
        } else
        _L___124: /* CIL Label */ 
#line 4921
        if ((int )event.type == 5) {
#line 4921
          if (wheely) {
#line 4921
            if ((int )event.button.button >= 4) {
#line 4921
              if ((int )event.button.button <= 5) {
#line 4923
                most = 14;
#line 4933
                if (cur_tool == 0) {
                  _L___92: /* CIL Label */ 
                  _L___93: /* CIL Label */ 
                  _L___94: /* CIL Label */ 
                  _L___95: /* CIL Label */ 
                  _L___96: /* CIL Label */ 
                  _L___97: /* CIL Label */ 
                  _L___98: /* CIL Label */ 
                  _L___99: /* CIL Label */ 
                  {
#line 4941
                  __cil_tmp168 = hit_test(& r_tools, (unsigned int )event.button.x,
                                          (unsigned int )event.button.y);
                  }
#line 4941
                  if (__cil_tmp168) {
#line 4941
                    if (16 > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 4943
                      is_upper___0 = (int )event.button.button == 4;
#line 4945
                      if (is_upper___0) {
#line 4945
                        if (tool_scroll > 0) {
                          {
#line 4947
                          tool_scroll -= (int )gd_tools.cols;
#line 4948
                          playsound(screen, 1, 7, 1, (int )event.button.x, - 999);
#line 4949
                          draw_toolbar();
                          }
                        } else {
#line 4945
                          goto _L___86;
                        }
                      } else
                      _L___86: /* CIL Label */ 
#line 4951
                      if (! is_upper___0) {
#line 4951
                        if (tool_scroll < 4 - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
                          {
#line 4953
                          tool_scroll += (int )gd_tools.cols;
#line 4954
                          playsound(screen, 1, 7, 1, (int )event.button.x, - 999);
#line 4955
                          draw_toolbar();
                          }
                        }
                      }
#line 4958
                      if ((int )event.button.y < (int )r_tools.y + button_h / 2) {
#line 4960
                        if (tool_scroll == 0) {
                          {
#line 4961
                          do_setcursor(cursor_arrow);
                          }
                        } else {
                          {
#line 4963
                          do_setcursor(cursor_up);
                          }
                        }
                      } else
#line 4966
                      if ((int )event.button.y > ((int )r_tools.y + (int )r_tools.h) - button_h / 2) {
#line 4968
                        if (tool_scroll < 4 - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
                          {
#line 4969
                          do_setcursor(cursor_down);
                          }
                        } else {
                          {
#line 4971
                          do_setcursor(cursor_arrow);
                          }
                        }
                      } else
#line 4974
                      if (tool_avail[(((int )event.button.x - (int )r_tools.x) / button_w + ((((int )event.button.y - (int )r_tools.y) - button_h / 2) / button_h) * (int )gd_tools.cols) + tool_scroll]) {
                        {
#line 4978
                        do_setcursor(cursor_hand);
                        }
                      } else {
                        {
#line 4982
                        do_setcursor(cursor_arrow);
                        }
                      }
                      {
#line 4984
                      update_screen_rect(& r_tools);
                      }
                    } else {
#line 4941
                      goto _L___91;
                    }
                  } else {
                    _L___91: /* CIL Label */ 
#line 4993
                    gd_controls___0.rows = (Uint8 )0;
#line 4994
                    gd_controls___0.cols = (Uint8 )0;
#line 4995
                    gd_items___0.rows = (Uint8 )2;
#line 4996
                    gd_items___0.cols = (Uint8 )2;
#line 5001
                    if (cur_tool == 1) {
#line 5003
                      if (! disable_stamp_controls) {
#line 5006
                        gd_controls___0.rows = (Uint8 )3;
#line 5007
                        gd_controls___0.cols = (Uint8 )2;
                      } else {
#line 5012
                        gd_controls___0.rows = (Uint8 )1;
#line 5013
                        gd_controls___0.cols = (Uint8 )2;
                      }
                    } else
#line 5016
                    if (cur_tool == 4) {
#line 5018
                      if (! disable_stamp_controls) {
#line 5020
                        gd_controls___0.rows = (Uint8 )2;
#line 5021
                        gd_controls___0.cols = (Uint8 )2;
                      }
                    } else
#line 5024
                    if (cur_tool == 5) {
#line 5026
                      if (! disable_stamp_controls) {
#line 5028
                        gd_controls___0.rows = (Uint8 )3;
#line 5029
                        gd_controls___0.cols = (Uint8 )2;
                      } else {
#line 5033
                        gd_controls___0.rows = (Uint8 )1;
#line 5034
                        gd_controls___0.cols = (Uint8 )2;
                      }
                    } else
#line 5037
                    if (cur_tool == 7) {
#line 5039
                      if (! disable_magic_controls) {
#line 5041
                        gd_controls___0.rows = (Uint8 )2;
#line 5042
                        gd_controls___0.cols = (Uint8 )2;
                      } else {
#line 5046
                        gd_controls___0.rows = (Uint8 )1;
#line 5047
                        gd_controls___0.cols = (Uint8 )2;
                      }
                    } else
#line 5050
                    if (cur_tool == 3) {
#line 5052
                      if (! disable_shape_controls) {
#line 5054
                        gd_controls___0.rows = (Uint8 )1;
#line 5055
                        gd_controls___0.cols = (Uint8 )2;
                      }
                    }
#line 5061
                    num_rows_needed___0 = ((num_things + (int )gd_items___0.cols) - 1) / (int )gd_items___0.cols;
#line 5063
                    do_draw = 0;
#line 5065
                    r_controls___0.w = r_toolopt.w;
#line 5066
                    r_controls___0.h = (Uint16 )((int )gd_controls___0.rows * button_h);
#line 5067
                    r_controls___0.x = r_toolopt.x;
#line 5068
                    r_controls___0.y = (Sint16 )(((int )r_toolopt.y + (int )r_toolopt.h) - (int )r_controls___0.h);
#line 5070
                    r_notcontrols___0.w = r_toolopt.w;
#line 5071
                    r_notcontrols___0.h = (Uint16 )((int )r_toolopt.h - (int )r_controls___0.h);
#line 5072
                    r_notcontrols___0.x = r_toolopt.x;
#line 5073
                    r_notcontrols___0.y = r_toolopt.y;
#line 5075
                    r_items___0.x = r_notcontrols___0.x;
#line 5076
                    r_items___0.y = r_notcontrols___0.y;
#line 5077
                    r_items___0.w = r_notcontrols___0.w;
#line 5078
                    r_items___0.h = r_notcontrols___0.h;
#line 5080
                    if (num_rows_needed___0 * button_h > (int )r_items___0.h) {
#line 5083
                      r_items___0.h -= button_h;
#line 5084
                      r_items___0.y += button_h / 2;
                    }
#line 5086
                    gd_items___0.rows = (Uint8 )((int )r_items___0.h / button_h);
#line 5088
                    if (! 0) {
#line 5094
                      is_upper___1 = (int )event.button.button == 4;
#line 5096
                      if (is_upper___1) {
#line 5096
                        if (*thing_scroll > 0) {
                          _L___87: /* CIL Label */ 
#line 5100
                          if (is_upper___1) {
#line 5100
                            tmp___1 = - ((int )gd_items___0.cols);
                          } else {
#line 5100
                            tmp___1 = (int )gd_items___0.cols;
                          }
                          {
#line 5100
                          *thing_scroll += tmp___1;
#line 5101
                          do_draw = 1;
#line 5102
                          playsound(screen, 1, 7, 1, - 999, - 999);
                          }
#line 5103
                          if (*thing_scroll == 0) {
                            {
#line 5105
                            do_setcursor(cursor_arrow);
                            }
                          }
                        } else {
#line 5096
                          goto _L___88;
                        }
                      } else
                      _L___88: /* CIL Label */ 
#line 5096
                      if (! is_upper___1) {
#line 5096
                        if (*thing_scroll / (int )gd_items___0.cols < num_rows_needed___0 - (int )gd_items___0.rows) {
#line 5096
                          goto _L___87;
                        }
                      }
                    }
#line 5113
                    if (cur_tool == 0) {
                      _L___90: /* CIL Label */ 
#line 5115
                      if (do_draw) {
                        {
#line 5116
                        draw_brushes();
                        }
                      }
                    } else
#line 5113
                    if (cur_tool == 2) {
#line 5113
                      goto _L___90;
                    } else
#line 5118
                    if (cur_tool == 10) {
#line 5120
                      if (do_draw) {
                        {
#line 5121
                        draw_erasers();
                        }
                      }
                    } else
#line 5123
                    if (cur_tool == 6) {
#line 5125
                      if (do_draw) {
                        {
#line 5126
                        draw_fills();
                        }
                      }
                    } else
#line 5128
                    if (cur_tool == 4) {
                      _L___89: /* CIL Label */ 
#line 5130
                      if (do_draw) {
                        {
#line 5131
                        draw_fonts();
                        }
                      }
                    } else
#line 5128
                    if (cur_tool == 5) {
#line 5128
                      goto _L___89;
                    } else
#line 5133
                    if (cur_tool == 1) {
#line 5135
                      if (do_draw) {
                        {
#line 5136
                        draw_stamps();
                        }
                      }
                    } else
#line 5138
                    if (cur_tool == 3) {
#line 5140
                      if (do_draw) {
                        {
#line 5141
                        draw_shapes();
                        }
                      }
                    } else
#line 5143
                    if (cur_tool == 7) {
#line 5145
                      if (do_draw) {
                        {
#line 5146
                        draw_magic();
                        }
                      }
                    }
#line 5150
                    if (do_draw) {
                      {
#line 5151
                      update_screen_rect(& r_toolopt);
                      }
                    }
                  }
                } else
#line 4933
                if (cur_tool == 1) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 3) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 2) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 7) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 4) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 10) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 5) {
#line 4933
                  goto _L___92;
                } else
#line 4933
                if (cur_tool == 6) {
#line 4933
                  goto _L___92;
                }
              } else {
#line 4921
                goto _L___121;
              }
            } else {
#line 4921
              goto _L___121;
            }
          } else {
#line 4921
            goto _L___121;
          }
        } else
        _L___121: /* CIL Label */ 
        _L___122: /* CIL Label */ 
        _L___123: /* CIL Label */ 
#line 5156
        if ((int )event.type == 24) {
#line 5158
          if (event.user.code == 1) {
#line 5162
            if (event.user.data1 != (void *)0) {
#line 5164
              if ((int )*((unsigned char *)event.user.data1 + 0) == 61) {
                {
#line 5166
                draw_tux_text_ex(3, (char const   *)((char *)event.user.data1 + 1),
                                 1, (Uint8 )((int )((intptr_t )event.user.data2)));
                }
              } else {
                {
#line 5170
                draw_tux_text_ex(3, (char const   *)((char *)event.user.data1), 0,
                                 (Uint8 )((int )((intptr_t )event.user.data2)));
                }
              }
            } else {
              {
#line 5174
              draw_tux_text(3, "\251", 1);
              }
            }
          } else
#line 5176
          if (event.user.code == 2) {
            {
#line 5182
            debug("Playing description sound...");
#line 5185
            Mix_ChannelFinished((void (*)(int  ))((void *)0));
            }
#line 5187
            if (event.user.data1 != (void *)0) {
#line 5189
              if ((int )((intptr_t )event.user.data1) == cur_stamp[stamp_group]) {
#line 5191
                if ((*(stamp_data[stamp_group] + (int )((intptr_t )event.user.data1)))->sdesc != (void *)0) {
#line 5191
                  if (! mute) {
                    {
#line 5192
                    Mix_PlayChannelTimed(2, (*(stamp_data[stamp_group] + (int )((intptr_t )event.user.data1)))->sdesc,
                                         0, - 1);
                    }
                  }
                }
              }
            }
          }
        } else
#line 5199
        if ((int )event.type == 6) {
#line 5201
          if (scrolling) {
#line 5203
            if (scrolltimer != (void *)0) {
              {
#line 5205
              SDL_RemoveTimer(scrolltimer);
#line 5206
              scrolltimer = (SDL_TimerID )((void *)0);
              }
            }
            {
#line 5208
            scrolling = 0;
#line 5209
            SDL_QuitSubSystem((Uint32 )1);
            }
          } else
#line 5214
          if (cur_tool == 1) {
#line 5214
            if (stamp_xored) {
#line 5214
              if ((int )event.button.button < 4) {
                {
#line 5216
                stamp_xor(canvas->w / 2, canvas->h / 2);
#line 5217
                stamp_xored = 0;
#line 5218
                stamp_size_selector_clicked = 0;
#line 5219
                update_screen((int )(((unsigned int )(canvas->w / 2) - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                              (int )(((unsigned int )(canvas->h / 2) - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y),
                              (int )(((unsigned int )(canvas->w / 2) + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                              (int )(((unsigned int )(canvas->h / 2) + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y));
                }
              }
            }
          }
#line 5226
          if (button_down) {
            _L___107: /* CIL Label */ 
#line 5228
            if (cur_tool == 0) {
              {
#line 5231
              brush_draw(old_x, old_y, old_x, old_y, 1);
              }
            } else
#line 5233
            if (cur_tool == 1) {
#line 5235
              if (old_x >= 0) {
#line 5235
                if (old_y >= 0) {
#line 5235
                  if (old_x <= (int )r_canvas.w) {
#line 5235
                    if (old_y <= (int )r_canvas.h) {
                      {
#line 5239
                      rec_undo_buffer();
#line 5241
                      stamp_draw(old_x, old_y);
#line 5242
                      stamp_xor(old_x, old_y);
#line 5243
                      playsound(screen, 1, 4, 1, (int )event.button.x, - 999);
#line 5245
                      __cil_tmp174 = great_str();
#line 5245
                      draw_tux_text(3, __cil_tmp174, 1);
#line 5249
                      control_drawtext_timer((Uint32 )1000, (char const   *)(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->stxt,
                                             (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->locale_text);
                      }
                    }
                  }
                }
              }
            } else
#line 5254
            if (cur_tool == 2) {
#line 5256
              if (! mouseaccessibility) {
                {
                {
#line 5259
                reset_brush_counter();
                }
                {
#line 5261
                brush_draw(line_start_x, line_start_y, (int )event.button.x - (int )r_canvas.x,
                           (int )event.button.y - (int )r_canvas.y, 1);
                }
                {
#line 5263
                brush_draw((int )event.button.x - (int )r_canvas.x, (int )event.button.y - (int )r_canvas.y,
                           (int )event.button.x - (int )r_canvas.x, (int )event.button.y - (int )r_canvas.y,
                           1);
                }
                {
#line 5267
                playsound(screen, 1, 6, 1, (int )event.button.x, - 999);
                }
                {
#line 5268
                draw_tux_text(3, tool_tips[2], 1);
                }
                }
              } else
#line 5256
              if (mouseaccessibility) {
#line 5256
                if (! emulate_button_pressed) {
                  {
                  {
#line 5259
                  reset_brush_counter();
                  }
                  {
#line 5261
                  brush_draw(line_start_x, line_start_y, (int )event.button.x - (int )r_canvas.x,
                             (int )event.button.y - (int )r_canvas.y, 1);
                  }
                  {
#line 5263
                  brush_draw((int )event.button.x - (int )r_canvas.x, (int )event.button.y - (int )r_canvas.y,
                             (int )event.button.x - (int )r_canvas.x, (int )event.button.y - (int )r_canvas.y,
                             1);
                  }
                  {
#line 5267
                  playsound(screen, 1, 6, 1, (int )event.button.x, - 999);
                  }
                  {
#line 5268
                  draw_tux_text(3, tool_tips[2], 1);
                  }
                  }
                }
              }
            } else
#line 5272
            if (cur_tool == 3) {
#line 5274
              if (! mouseaccessibility) {
                _L___101: /* CIL Label */ 
#line 5276
                if (shape_tool_mode == 0) {
#line 5280
                  shape_current_x = (int )event.button.x - (int )r_canvas.x;
#line 5281
                  shape_current_y = (int )event.button.y - (int )r_canvas.y;
#line 5283
                  if (! simple_shapes) {
#line 5283
                    if (! shape_no_rotate[cur_shape]) {
                      {
#line 5285
                      shape_tool_mode = 1;
#line 5287
                      __cil_tmp175 = sqrt((double )((shape_start_x - shape_current_x) * (shape_start_x - shape_current_x) + (shape_start_y - shape_current_y) * (shape_start_y - shape_current_y)));
#line 5287
                      shape_radius = (int )__cil_tmp175;
#line 5291
                      SDL_WarpMouse((Uint16 )(shape_current_x + (int )r_ttools.w),
                                    (Uint16 )shape_start_y);
#line 5292
                      do_setcursor(cursor_rotate);
#line 5297
                      __cil_tmp177 = abs(shape_start_y - shape_current_y);
                      }
                      {
#line 5297
                      __cil_tmp176 = abs(shape_start_x - shape_current_x);
                      }
#line 5297
                      if (__cil_tmp176 > 15) {
                        {
                        {
#line 5298
                        do_shape(shape_start_x, shape_start_y, old_x, old_y, 0, 0);
                        }
                        }
                      } else
#line 5297
                      if (__cil_tmp177 > 15) {
                        {
                        {
#line 5298
                        do_shape(shape_start_x, shape_start_y, old_x, old_y, 0, 0);
                        }
                        }
                      }
                      {
#line 5302
                      __cil_tmp178 = shape_rotation(shape_start_x, shape_start_y,
                                                    shape_current_x, shape_current_y);
#line 5302
                      do_shape(shape_start_x, shape_start_y, shape_current_x, shape_current_y,
                               __cil_tmp178, 0);
#line 5306
                      playsound(screen, 1, 5, 1, (int )event.button.x, - 999);
#line 5307
                      draw_tux_text(2, "Move the mouse to rotate the shape. Click to draw it.",
                                    1);
#line 5312
                      SDL_Flip(screen);
                      }
                    } else {
#line 5283
                      goto _L___100;
                    }
                  } else {
                    _L___100: /* CIL Label */ 
                    {
#line 5316
                    reset_brush_counter();
#line 5319
                    playsound(screen, 1, 6, 1, (int )event.button.x, - 999);
#line 5320
                    do_shape(shape_start_x, shape_start_y, shape_current_x, shape_current_y,
                             0, 1);
#line 5322
                    SDL_Flip(screen);
#line 5324
                    shape_tool_mode = 2;
                    }
#line 5325
                    if (simple_shapes) {
#line 5325
                      tmp___2 = 1;
                    } else {
#line 5325
                      tmp___2 = 0;
                    }
                    {
#line 5325
                    draw_tux_text(3, shape_tool_tips[tmp___2], 1);
                    }
                  }
                } else
#line 5328
                if (shape_tool_mode == 1) {
                  {
#line 5330
                  reset_brush_counter();
#line 5332
                  playsound(screen, 1, 6, 1, (int )event.button.x, - 999);
#line 5333
                  __cil_tmp180 = shape_rotation(shape_start_x, shape_start_y, (int )event.button.x - (int )r_canvas.x,
                                                (int )event.button.y - (int )r_canvas.y);
#line 5333
                  do_shape(shape_start_x, shape_start_y, shape_current_x, shape_current_y,
                           __cil_tmp180, 1);
#line 5337
                  shape_tool_mode = 2;
                  }
#line 5338
                  if (simple_shapes) {
#line 5338
                    tmp___3 = 1;
                  } else {
#line 5338
                    tmp___3 = 0;
                  }
                  {
#line 5338
                  draw_tux_text(3, shape_tool_tips[tmp___3], 1);
#line 5342
                  SDL_Flip(screen);
                  }
                }
              } else
#line 5274
              if (mouseaccessibility) {
#line 5274
                if (! emulate_button_pressed) {
#line 5274
                  goto _L___101;
                }
              }
            } else
#line 5346
            if (cur_tool == 7) {
#line 5346
              if (magics[magic_group][cur_magic[magic_group]].mode == 1) {
                _L___105: /* CIL Label */ 
                _L___106: /* CIL Label */ 
#line 5354
                grp___2 = magic_group;
#line 5355
                cur___2 = cur_magic[grp___2];
#line 5357
                if (! mouseaccessibility) {
                  _L___102: /* CIL Label */ 
#line 5364
                  if (cur_undo > 0) {
#line 5365
                    undo_ctr___1 = cur_undo - 1;
                  } else {
#line 5367
                    undo_ctr___1 = 19;
                  }
                  {
#line 5369
                  last___1 = undo_bufs[undo_ctr___1];
#line 5371
                  update_rect.x = (Sint16 )0;
#line 5372
                  update_rect.y = (Sint16 )0;
#line 5373
                  update_rect.w = (Uint16 )0;
#line 5374
                  update_rect.h = (Uint16 )0;
#line 5376
                  (*(magic_funcs[magics[grp___2][cur___2].handle_idx].release))(magic_api_struct,
                                                                                magics[grp___2][cur___2].idx,
                                                                                canvas,
                                                                                last___1,
                                                                                old_x,
                                                                                old_y,
                                                                                & update_rect);
#line 5380
                  __cil_tmp186 = magic_modeint(magics[grp___2][cur___2].mode);
#line 5380
                  draw_tux_text(3, (char const   *)magics[grp___2][cur___2].tip[__cil_tmp186],
                                1);
#line 5382
                  update_canvas((int )update_rect.x, (int )update_rect.y, (int )update_rect.x + (int )update_rect.w,
                                (int )update_rect.y + (int )update_rect.h);
                  }
                } else
#line 5357
                if (mouseaccessibility) {
#line 5357
                  if (! emulate_button_pressed) {
#line 5357
                    goto _L___102;
                  }
                }
              } else
#line 5346
              if (magics[magic_group][cur_magic[magic_group]].mode == 8) {
#line 5346
                goto _L___105;
              } else
#line 5346
              if (magics[magic_group][cur_magic[magic_group]].mode == 4) {
#line 5346
                goto _L___105;
              } else {
#line 5346
                goto _L___104;
              }
            } else
            _L___104: /* CIL Label */ 
#line 5386
            if (onscreen_keyboard) {
#line 5386
              if (cur_tool == 4) {
                {
                {
#line 5389
                osk_released(kbd);
                }
                {
#line 5390
                SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
                }
                {
#line 5391
                update_screen_rect(& kbd_rect);
                }
                }
              } else
#line 5386
              if (cur_tool == 5) {
#line 5386
                if (cur_label != 2) {
                  {
                  {
#line 5389
                  osk_released(kbd);
                  }
                  {
#line 5390
                  SDL_UpperBlit(kbd->surface, & kbd->rect, screen, & kbd_rect);
                  }
                  {
#line 5391
                  update_screen_rect(& kbd_rect);
                  }
                  }
                } else {
#line 5386
                  goto _L___103;
                }
              } else {
#line 5386
                goto _L___103;
              }
            } else
            _L___103: /* CIL Label */ 
#line 5394
            if (cur_tool == 6) {
#line 5396
              fill_drag_started = 0;
            }
          } else
#line 5226
          if (emulate_button_pressed) {
#line 5226
            goto _L___107;
          }
#line 5399
          button_down = 0;
        } else
#line 5401
        if ((int )event.type == 4) {
#line 5401
          if (! ignoring_motion) {
            {
#line 5403
            new_x = (int )event.button.x - (int )r_canvas.x;
#line 5404
            new_y = (int )event.button.y - (int )r_canvas.y;
#line 5406
            oldpos_x = (int )event.motion.x;
#line 5407
            oldpos_y = (int )event.motion.y;
#line 5413
            __cil_tmp187 = hit_test(& r_tools, (unsigned int )event.button.x, (unsigned int )event.button.y);
            }
#line 5413
            if (__cil_tmp187) {
#line 5415
              most___0 = buttons_tall * (int )gd_tools.cols;
#line 5419
              if (16 > most___0) {
#line 5421
                if ((int )event.button.y < (int )r_tools.y + button_h / 2) {
#line 5423
                  if (tool_scroll > 0) {
                    {
#line 5424
                    do_setcursor(cursor_up);
                    }
                  } else {
                    {
#line 5426
                    do_setcursor(cursor_arrow);
                    }
                  }
                } else
#line 5428
                if ((int )event.button.y > ((int )r_tools.y + (int )r_tools.h) - button_h / 2) {
#line 5430
                  if (tool_scroll < (16 - buttons_tall * (int )gd_tools.cols) + (int )gd_tools.cols) {
                    {
#line 5431
                    do_setcursor(cursor_down);
                    }
                  } else {
                    {
#line 5433
                    do_setcursor(cursor_arrow);
                    }
                  }
                } else
#line 5436
                if (tool_avail[(((int )event.button.x - (int )r_tools.x) / button_w + ((((int )event.button.y - (int )r_tools.y) - button_h / 2) / button_h) * (int )gd_tools.cols) + tool_scroll]) {
                  {
#line 5440
                  do_setcursor(cursor_hand);
                  }
                } else {
                  {
#line 5444
                  do_setcursor(cursor_arrow);
                  }
                }
              } else
#line 5450
              if (tool_avail[((int )event.button.x - (int )r_tools.x) / button_w + (((int )event.button.y - (int )r_tools.y) / button_h) * (int )gd_tools.cols]) {
                {
#line 5453
                do_setcursor(cursor_hand);
                }
              } else {
                {
#line 5457
                do_setcursor(cursor_arrow);
                }
              }
            } else {
              {
#line 5461
              __cil_tmp189 = hit_test(& r_sfx, (unsigned int )event.button.x, (unsigned int )event.button.y);
              }
#line 5461
              if (__cil_tmp189) {
                {
#line 5465
                __cil_tmp191 = grid_hit_gd(& r_sfx, (unsigned int )event.button.x,
                                           (unsigned int )event.button.y, & gd_sfx);
                }
                {
#line 5465
                __cil_tmp190 = grid_hit_gd(& r_sfx, (unsigned int )event.button.x,
                                           (unsigned int )event.button.y, & gd_sfx);
                }
#line 5465
                if (cur_tool == 1) {
#line 5465
                  if (use_sound) {
#line 5465
                    if (! mute) {
#line 5465
                      if (__cil_tmp190 == 0) {
#line 5465
                        if (! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_sound) {
                          {
                          {
#line 5471
                          do_setcursor(cursor_hand);
                          }
                          }
                        } else {
#line 5465
                          goto _L___108;
                        }
                      } else
                      _L___108: /* CIL Label */ 
#line 5465
                      if (__cil_tmp191 == 1) {
#line 5465
                        if (! (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_descsound) {
                          {
                          {
#line 5471
                          do_setcursor(cursor_hand);
                          }
                          }
                        } else {
                          {
                          {
                          {
                          {
                          {
#line 5475
                          do_setcursor(cursor_arrow);
                          }
                          }
                          }
                          }
                          }
                        }
                      } else {
                        {
                        {
                        {
                        {
                        {
#line 5475
                        do_setcursor(cursor_arrow);
                        }
                        }
                        }
                        }
                        }
                      }
                    } else {
                      {
                      {
                      {
                      {
                      {
#line 5475
                      do_setcursor(cursor_arrow);
                      }
                      }
                      }
                      }
                      }
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 5475
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 5475
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
#line 5478
                __cil_tmp192 = hit_test(& r_colors, (unsigned int )event.button.x,
                                        (unsigned int )event.button.y);
                }
#line 5478
                if (__cil_tmp192) {
#line 5481
                  if (colors_are_selectable) {
                    {
#line 5482
                    do_setcursor(cursor_hand);
                    }
                  } else {
                    {
#line 5484
                    do_setcursor(cursor_arrow);
                    }
                  }
                } else {
                  {
#line 5486
                  __cil_tmp193 = hit_test(& r_toolopt, (unsigned int )event.button.x,
                                          (unsigned int )event.button.y);
                  }
#line 5486
                  if (__cil_tmp193) {
#line 5494
                    if (! (cur_tool == 1)) {
#line 5497
                      if (! (cur_tool == 4)) {
#line 5497
                        if (cur_tool == 5) {

                        }
                      }
                    }
#line 5501
                    control_rows = 0;
#line 5502
                    if (cur_tool == 1) {
#line 5502
                      if (! disable_stamp_controls) {
#line 5503
                        control_rows = 3;
                      }
                    }
#line 5504
                    if (cur_tool == 5) {
#line 5506
                      control_rows = 1;
#line 5507
                      if (! disable_stamp_controls) {
#line 5508
                        control_rows = 3;
                      }
                    }
#line 5511
                    if (cur_tool == 4) {
#line 5511
                      if (! disable_stamp_controls) {
#line 5512
                        control_rows = 2;
                      }
                    }
#line 5513
                    if (cur_tool == 7) {
#line 5515
                      control_rows = 1;
#line 5516
                      if (! disable_magic_controls) {
#line 5517
                        control_rows = 2;
                      }
                    }
#line 5519
                    if (cur_tool == 3) {
#line 5519
                      if (! disable_shape_controls) {
#line 5520
                        control_rows = 1;
                      }
                    }
#line 5521
                    num_places = buttons_tall * (int )gd_toolopt.cols - control_rows * (int )gd_toolopt.cols;
#line 5523
                    if (num_things > num_places) {
#line 5526
                      num_places -= (int )gd_toolopt.cols;
#line 5527
                      if ((int )event.button.y < (int )r_ttoolopt.h + img_scroll_up->h) {
#line 5531
                        if (*thing_scroll > 0) {
                          {
#line 5532
                          do_setcursor(cursor_up);
                          }
                        } else {
                          {
#line 5534
                          do_setcursor(cursor_arrow);
                          }
                        }
                      } else
#line 5536
                      if ((int )event.button.y > (button_h * (num_places / (int )gd_toolopt.cols) + (int )r_ttoolopt.h) + img_scroll_up->h) {
#line 5536
                        if ((int )event.button.y <= ((button_h * (num_places / (int )gd_toolopt.cols) + (int )r_ttoolopt.h) + img_scroll_up->h) + img_scroll_up->h) {
#line 5542
                          if (*thing_scroll < num_things - num_places) {
                            {
#line 5543
                            do_setcursor(cursor_down);
                            }
                          } else {
                            {
#line 5545
                            do_setcursor(cursor_arrow);
                            }
                          }
                        } else {
#line 5536
                          goto _L___109;
                        }
                      } else {
                        _L___109: /* CIL Label */ 
#line 5551
                        which = ((((int )event.button.y - (int )r_ttoolopt.h) - img_scroll_up->h) / button_h) * 2 + ((int )event.button.x - (WINDOW_WIDTH - (int )r_ttoolopt.w)) / button_w;
#line 5553
                        if (which < num_things) {
                          {
#line 5554
                          do_setcursor(cursor_hand);
                          }
                        } else {
                          {
#line 5556
                          do_setcursor(cursor_arrow);
                          }
                        }
                      }
                    } else {
#line 5563
                      which = (((int )event.button.y - (int )r_ttoolopt.h) / button_h) * 2 + ((int )event.button.x - (WINDOW_WIDTH - (int )r_ttoolopt.w)) / button_w;
#line 5565
                      if (which < num_things) {
                        {
#line 5566
                        do_setcursor(cursor_hand);
                        }
                      } else {
                        {
#line 5568
                        do_setcursor(cursor_arrow);
                        }
                      }
                    }
                  } else {
                    {
#line 5571
                    __cil_tmp196 = hit_test(& r_canvas, (unsigned int )event.button.x,
                                            (unsigned int )event.button.y);
                    }
#line 5571
                    if (__cil_tmp196) {
#line 5571
                      if (keyglobal == 0) {
#line 5575
                        if (cur_tool == 0) {
                          {
#line 5576
                          do_setcursor(cursor_brush);
                          }
                        } else
#line 5577
                        if (cur_tool == 1) {
                          {
#line 5578
                          do_setcursor(cursor_tiny);
                          }
                        } else
#line 5579
                        if (cur_tool == 2) {
                          {
                          {
#line 5580
                          do_setcursor(cursor_crosshair);
                          }
                          }
                        } else
#line 5579
                        if (cur_tool == 6) {
                          {
                          {
#line 5580
                          do_setcursor(cursor_crosshair);
                          }
                          }
                        } else
#line 5581
                        if (cur_tool == 3) {
#line 5583
                          if (shape_tool_mode != 1) {
                            {
#line 5584
                            do_setcursor(cursor_crosshair);
                            }
                          } else {
                            {
#line 5586
                            do_setcursor(cursor_rotate);
                            }
                          }
                        } else
#line 5588
                        if (cur_tool == 4) {
                          {
#line 5590
                          __cil_tmp197 = hit_test(& kbd_rect, (unsigned int )event.button.x,
                                                  (unsigned int )event.button.y);
                          }
#line 5590
                          if (onscreen_keyboard) {
#line 5590
                            if (__cil_tmp197) {
                              {
#line 5591
                              do_setcursor(cursor_hand);
                              }
                            } else {
                              {
                              {
#line 5593
                              do_setcursor(cursor_insertion);
                              }
                              }
                            }
                          } else {
                            {
                            {
#line 5593
                            do_setcursor(cursor_insertion);
                            }
                            }
                          }
                        } else
#line 5595
                        if (cur_tool == 5) {
#line 5597
                          if (cur_label == 1) {
                            {
#line 5598
                            __cil_tmp198 = hit_test(& kbd_rect, (unsigned int )event.button.x,
                                                    (unsigned int )event.button.y);
                            }
#line 5598
                            if (onscreen_keyboard) {
#line 5598
                              if (__cil_tmp198) {
                                {
#line 5599
                                do_setcursor(cursor_hand);
                                }
                              } else {
                                {
                                {
#line 5601
                                do_setcursor(cursor_insertion);
                                }
                                }
                              }
                            } else {
                              {
                              {
#line 5601
                              do_setcursor(cursor_insertion);
                              }
                              }
                            }
                          } else
#line 5602
                          if (cur_label == 2) {
                            {
#line 5604
                            __cil_tmp199 = search_label_list(& current_label_node,
                                                             (Uint16 )((int )event.button.x - (int )r_ttools.w),
                                                             event.button.y, 1);
                            }
#line 5604
                            if (__cil_tmp199) {
                              {
#line 5605
                              do_setcursor(cursor_hand);
                              }
                            } else {
                              {
#line 5607
                              do_setcursor(cursor_arrow);
                              }
                            }
                          }
                        } else
#line 5610
                        if (cur_tool == 7) {
                          {
#line 5611
                          do_setcursor(cursor_wand);
                          }
                        } else
#line 5612
                        if (cur_tool == 10) {
                          {
#line 5613
                          do_setcursor(cursor_tiny);
                          }
                        }
                      } else {
                        {
                        {
#line 5617
                        do_setcursor(cursor_arrow);
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 5617
                      do_setcursor(cursor_arrow);
                      }
                      }
                    }
                  }
                }
              }
            }
#line 5621
            if (button_down) {
              _L___115: /* CIL Label */ 
#line 5623
              if (cur_tool == 0) {
                {
#line 5627
                brush_draw(old_x, old_y, new_x, new_y, 1);
#line 5629
                __cil_tmp200 = paintsound(img_cur_brush_w);
#line 5629
                playsound(screen, 0, __cil_tmp200, 0, (int )event.button.x, - 999);
                }
              } else
#line 5631
              if (cur_tool == 2) {
                {
#line 5635
                update_screen(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
#line 5636
                line_xor(line_start_x, line_start_y, old_x, old_y);
#line 5638
                line_xor(line_start_x, line_start_y, new_x, new_y);
                }
#line 5640
                if (new_y != line_start_y) {
                  {
#line 5641
                  __cil_tmp201 = atan2f((float )(new_x - line_start_x), (float )(new_y - line_start_y));
#line 5641
                  angle = (float )((double )(__cil_tmp201 * (float )180) / 3.14159265359 - 90.);
                  }
                } else
#line 5642
                if (new_x >= line_start_x) {
#line 5643
                  angle = (float )0.;
                } else {
#line 5645
                  angle = (float )180.;
                }
#line 5647
                if ((double )angle < 0.) {
#line 5648
                  angle += 360.;
                }
                {
#line 5650
                update_screen(line_start_x + (int )r_canvas.x, line_start_y + (int )r_canvas.y,
                              old_x + (int )r_canvas.x, old_y + (int )r_canvas.y);
#line 5652
                update_screen(line_start_x + (int )r_canvas.x, line_start_y + (int )r_canvas.y,
                              new_x + (int )r_canvas.x, new_y + (int )r_canvas.y);
#line 5654
                update_screen(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
#line 5656
                __cil_tmp202 = dcgettext((char const   *)((void *)0), "Let go of the button to complete the line. (Your line\'s angle is %.0f degrees.)",
                                         5);
#line 5656
                snprintf((char *)angle_tool_text, sizeof(angle_tool_text), (char const   *)__cil_tmp202,
                         (double )angle);
#line 5657
                draw_tux_text(2, (char const   *)((char *)angle_tool_text), 1);
                }
              } else
#line 5659
              if (cur_tool == 3) {
#line 5664
                if (shape_tool_mode == 0) {
                  {
#line 5666
                  do_shape(shape_start_x, shape_start_y, old_x, old_y, 0, 0);
#line 5668
                  do_shape(shape_start_x, shape_start_y, new_x, new_y, 0, 0);
#line 5670
                  shape_reverse = new_x < shape_start_x;
#line 5679
                  SDL_Flip(screen);
                  }
                }
              } else
#line 5682
              if (cur_tool == 7) {
#line 5682
                if (magics[magic_group][cur_magic[magic_group]].mode == 1) {
                  _L___113: /* CIL Label */ 
                  _L___114: /* CIL Label */ 
#line 5692
                  if (cur_undo > 0) {
#line 5693
                    undo_ctr___2 = cur_undo - 1;
                  } else {
#line 5695
                    undo_ctr___2 = 19;
                  }
                  {
#line 5697
                  last___2 = undo_bufs[undo_ctr___2];
#line 5699
                  update_rect.x = (Sint16 )0;
#line 5700
                  update_rect.y = (Sint16 )0;
#line 5701
                  update_rect.w = (Uint16 )0;
#line 5702
                  update_rect.h = (Uint16 )0;
#line 5704
                  (*(magic_funcs[magics[magic_group][cur_magic[magic_group]].handle_idx].drag))(magic_api_struct,
                                                                                                magics[magic_group][cur_magic[magic_group]].idx,
                                                                                                canvas,
                                                                                                last___2,
                                                                                                old_x,
                                                                                                old_y,
                                                                                                new_x,
                                                                                                new_y,
                                                                                                & update_rect);
#line 5710
                  update_canvas((int )update_rect.x, (int )update_rect.y, (int )update_rect.x + (int )update_rect.w,
                                (int )update_rect.y + (int )update_rect.h);
                  }
                } else
#line 5682
                if (magics[magic_group][cur_magic[magic_group]].mode == 8) {
#line 5682
                  goto _L___113;
                } else
#line 5682
                if (magics[magic_group][cur_magic[magic_group]].mode == 4) {
#line 5682
                  goto _L___113;
                } else {
#line 5682
                  goto _L___112;
                }
              } else
              _L___112: /* CIL Label */ 
#line 5713
              if (cur_tool == 10) {
                {
#line 5719
                eraser_draw(old_x, old_y, new_x, new_y);
#line 5721
                sz = calc_eraser_size(cur_eraser);
#line 5722
                rect_xor(new_x - sz / 2, new_y - sz / 2, new_x + sz / 2, new_y + sz / 2);
                }
              } else
#line 5724
              if (cur_tool == 6) {
#line 5724
                if (cur_fill == 2) {
#line 5724
                  if (fill_drag_started) {
#line 5730
                    if (cur_undo > 0) {
#line 5731
                      undo_ctr___3 = cur_undo - 1;
                    } else {
#line 5733
                      undo_ctr___3 = 19;
                    }
                    {
#line 5735
                    last___3 = undo_bufs[undo_ctr___3];
#line 5739
                    draw_color___0 = ((((unsigned int )*(*(color_hexes + cur_color) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + cur_color) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + cur_color) + 2) & 255U);
#line 5743
                    draw_linear_gradient(canvas, last___3, sim_flood_x1, sim_flood_y1,
                                         sim_flood_x2, sim_flood_y2, fill_x, fill_y,
                                         new_x, new_y, draw_color___0, sim_flood_touched);
#line 5746
                    update_canvas(sim_flood_x1, sim_flood_y1, sim_flood_x2, sim_flood_y2);
                    }
                  } else {
#line 5724
                    goto _L___110;
                  }
                } else {
#line 5724
                  goto _L___110;
                }
              } else
              _L___110: /* CIL Label */ 
              _L___111: /* CIL Label */ 
#line 5748
              if (cur_tool == 6) {
#line 5748
                if (cur_fill == 1) {
                  {
#line 5755
                  draw_color___1 = ((((unsigned int )*(*(color_hexes + cur_color) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + cur_color) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + cur_color) + 2) & 255U);
#line 5760
                  draw_brush_fill(canvas, sim_flood_x1, sim_flood_y1, sim_flood_x2,
                                  sim_flood_y2, old_x, old_y, new_x, new_y, draw_color___1,
                                  sim_flood_touched, & x1___0, & y1___1, & x2___0,
                                  & y2___0);
#line 5763
                  update_canvas(x1___0, y1___1, x2___0, y2___0);
                  }
                }
              }
            } else
#line 5621
            if (emulate_button_pressed) {
#line 5621
              goto _L___115;
            }
#line 5768
            if (cur_tool == 1) {
              _L___118: /* CIL Label */ 
#line 5772
              w = 0;
#line 5773
              h = 0;
#line 5778
              if (cur_tool == 1) {
#line 5780
                w = active_stamp->w;
#line 5781
                h = active_stamp->h;
              } else {
#line 5785
                if (cur_eraser < 8) {
#line 5787
                  w = 5 + ((8 - cur_eraser) - 1) * 17;
                } else {
#line 5793
                  w = 5 + ((8 - (cur_eraser - 8)) - 1) * 17;
                }
#line 5798
                h = w;
              }
#line 5801
              if (old_x >= 0) {
#line 5801
                if (old_x < (int )r_canvas.w) {
#line 5801
                  if (old_y >= 0) {
#line 5801
                    if (old_y < (int )r_canvas.h) {
#line 5803
                      if (cur_tool == 1) {
                        {
#line 5805
                        stamp_xor(old_x, old_y);
#line 5807
                        update_screen((int )(((unsigned int )old_x - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )old_y - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y),
                                      (int )(((unsigned int )old_x + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )old_y + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y));
                        }
                      } else {
                        {
#line 5815
                        rect_xor(old_x - w / 2, old_y - h / 2, old_x + w / 2, old_y + h / 2);
#line 5817
                        update_screen((old_x - w / 2) + (int )r_canvas.x, (old_y - h / 2) + (int )r_canvas.y,
                                      (old_x + w / 2) + (int )r_canvas.x, (old_y + h / 2) + (int )r_canvas.y);
                        }
                      }
                    }
                  }
                }
              }
#line 5823
              if (new_x >= 0) {
#line 5823
                if (new_x < (int )r_canvas.w) {
#line 5823
                  if (new_y >= 0) {
#line 5823
                    if (new_y < (int )r_canvas.h) {
#line 5825
                      if (cur_tool == 1) {
                        {
#line 5827
                        stamp_xor(new_x, new_y);
#line 5829
                        update_screen((int )(((unsigned int )old_x - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )old_y - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y),
                                      (int )(((unsigned int )old_x + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                      (int )(((unsigned int )old_y + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y));
                        }
                      } else {
                        {
#line 5836
                        rect_xor(new_x - w / 2, new_y - h / 2, new_x + w / 2, new_y + h / 2);
#line 5838
                        update_screen((new_x - w / 2) + (int )r_canvas.x, (new_y - h / 2) + (int )r_canvas.y,
                                      (new_x + w / 2) + (int )r_canvas.x, (new_y + h / 2) + (int )r_canvas.y);
                        }
                      }
                    }
                  }
                }
              }
              {
#line 5843
              __cil_tmp217 = hit_test(& r_toolopt, (unsigned int )event.button.x,
                                      (unsigned int )event.button.y);
              }
#line 5843
              if (cur_tool == 1) {
#line 5843
                if (__cil_tmp217) {
#line 5843
                  if ((int )event.motion.y > (int )r_toolopt.h) {
#line 5843
                    if ((int )event.motion.state == 1) {
#line 5843
                      if (stamp_size_selector_clicked) {
#line 5846
                        control_sound___2 = - 1;
#line 5854
                        old_size___0 = (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size;
#line 5855
                        w___116 = (int )((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom);
#line 5856
                        h___117 = (int )((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom);
#line 5858
                        (*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size = (unsigned int )(((((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->max - (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min) + 1) * ((int )event.button.x - (WINDOW_WIDTH - (int )r_ttoolopt.w))) / (int )r_toolopt.w + (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min);
#line 5869
                        if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size != old_size___0) {
#line 5871
                          if (stamp_xored) {
                            {
#line 5873
                            stamp_xor(canvas->w / 2, canvas->h / 2);
#line 5874
                            stamp_xored = 0;
#line 5876
                            update_screen((canvas->w / 2 - (w___116 + 1) / 2) + (int )r_canvas.x,
                                          (canvas->h / 2 - (h___117 + 1) / 2) + (int )r_canvas.y,
                                          (canvas->w / 2 + (w___116 + 1) / 2) + (int )r_canvas.x,
                                          (canvas->h / 2 + (h___117 + 1) / 2) + (int )r_canvas.y);
                            }
                          }
                          {
#line 5882
                          update_stamp_xor();
#line 5883
                          stamp_xor(canvas->w / 2, canvas->h / 2);
#line 5884
                          stamp_xored = 1;
#line 5885
                          update_screen((int )(((unsigned int )(canvas->w / 2) - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                        (int )(((unsigned int )(canvas->h / 2) - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y),
                                        (int )(((unsigned int )(canvas->w / 2) + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.x),
                                        (int )(((unsigned int )(canvas->h / 2) + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U) + (unsigned int )r_canvas.y));
                          }
                        }
#line 5891
                        if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size < old_size___0) {
#line 5892
                          control_sound___2 = 21;
                        } else
#line 5893
                        if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size > old_size___0) {
#line 5894
                          control_sound___2 = 22;
                        }
#line 5896
                        if (control_sound___2) {
                          {
#line 5898
                          playsound(screen, 0, control_sound___2, 0, - 998, - 999);
#line 5899
                          draw_stamps();
#line 5900
                          update_screen_rect(& r_toolopt);
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else
#line 5768
            if (cur_tool == 10) {
#line 5768
              if (! button_down) {
#line 5768
                if (! mouseaccessibility) {
#line 5768
                  goto _L___118;
                } else
#line 5768
                if (mouseaccessibility) {
#line 5768
                  if (! emulate_button_pressed) {
#line 5768
                    goto _L___118;
                  } else {
#line 5768
                    goto _L___119;
                  }
                } else {
#line 5768
                  goto _L___119;
                }
              } else {
#line 5768
                goto _L___119;
              }
            } else
            _L___119: /* CIL Label */ 
            _L___120: /* CIL Label */ 
#line 5904
            if (cur_tool == 3) {
#line 5904
              if (shape_tool_mode == 1) {
                {
#line 5908
                deg = shape_rotation(shape_start_x, shape_start_y, old_x, old_y);
#line 5909
                do_shape(shape_start_x, shape_start_y, shape_current_x, shape_current_y,
                         deg, 0);
#line 5911
                deg = shape_rotation(shape_start_x, shape_start_y, new_x, new_y);
#line 5912
                do_shape(shape_start_x, shape_start_y, shape_current_x, shape_current_y,
                         deg, 0);
#line 5914
                deg = - deg;
                }
#line 5915
                if (deg < 0) {
#line 5916
                  deg += 360;
                }
                {
#line 5918
                __cil_tmp225 = dcgettext((char const   *)((void *)0), "Move the mouse to rotate the shape. Click to draw it. (It is rotated %d degrees.)",
                                         5);
#line 5918
                snprintf((char *)angle_tool_text, sizeof(angle_tool_text), (char const   *)__cil_tmp225,
                         deg);
#line 5919
                draw_tux_text(2, (char const   *)((char *)angle_tool_text), 1);
#line 5922
                SDL_Flip(screen);
                }
              }
            }
#line 5925
            old_x = new_x;
#line 5926
            old_y = new_y;
#line 5927
            oldpos_x = (int )event.button.x;
#line 5928
            oldpos_y = (int )event.button.y;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5932
    if (cur_tool == 4) {
      _L___129: /* CIL Label */ 
      {
#line 5937
      cur_cursor_blink = SDL_GetTicks();
      }
#line 5939
      if (cursor_x != -1) {
#line 5939
        if (cursor_y != -1) {
#line 5939
          if (cur_cursor_blink > last_cursor_blink + 500U) {
            {
#line 5941
            last_cursor_blink = SDL_GetTicks();
#line 5942
            draw_blinking_cursor();
            }
          }
        }
      }
    } else
#line 5932
    if (cur_tool == 5) {
#line 5932
      if (cur_label != 2) {
#line 5932
        goto _L___129;
      }
    }
#line 5946
    if (motioner | hatmotioner) {
      {
#line 5947
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 5950
    SDL_Delay((Uint32 )10);
    }
#line 2389
    if (! (! done)) {
#line 2389
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 5959 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void hide_blinking_cursor(void) 
{ 


  {
#line 5961
  if (cur_toggle_count & 1U) {
    {
#line 5963
    draw_blinking_cursor();
    }
  }
  return;
}
}
#line 5972 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_blinking_cursor(void) 
{ 
  Uint32 __cil_tmp1 ;
  TuxPaint_Font *__cil_tmp2 ;
  int __cil_tmp3 ;
  TuxPaint_Font *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 5974
  cur_toggle_count ++;
#line 5976
  __cil_tmp2 = getfonthandle(cur_font);
#line 5976
  __cil_tmp3 = TuxPaint_Font_FontHeight(__cil_tmp2);
#line 5976
  line_xor(cursor_x + cursor_textwidth, cursor_y, cursor_x + cursor_textwidth, cursor_y + __cil_tmp3);
#line 5979
  __cil_tmp4 = getfonthandle(cur_font);
#line 5979
  __cil_tmp5 = TuxPaint_Font_FontHeight(__cil_tmp4);
#line 5979
  update_screen((cursor_x + (int )r_canvas.x) + cursor_textwidth, cursor_y + (int )r_canvas.y,
                (cursor_x + (int )r_canvas.x) + cursor_textwidth, (cursor_y + (int )r_canvas.y) + __cil_tmp5);
  }
  return;
}
}
#line 5994 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void brush_draw(int x1 , int y1___0 , int x2 , int y2 , int update ) 
{ 
  int dx ;
  int dy ;
  int y ;
  int frame_w ;
  int w ;
  int h ;
  int sz ;
  int orig_x1 ;
  int orig_y1 ;
  int orig_x2 ;
  int orig_y2 ;
  int tmp ;
  int direction ;
  float m ;
  float b ;
  double r ;
  int __cil_tmp22 ;
  int tmp___130 ;
  int tmp___131 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;

  {
  {
#line 6002
  orig_x1 = x1;
#line 6003
  orig_y1 = y1___0;
#line 6005
  orig_x2 = x2;
#line 6006
  orig_y2 = y2;
#line 6009
  __cil_tmp22 = abs(*(brushes_frames + cur_brush));
#line 6009
  frame_w = (*(img_brushes + cur_brush))->w / __cil_tmp22;
  }
#line 6010
  if ((int )*(brushes_directional + cur_brush)) {
#line 6010
    tmp___130 = 3;
  } else {
#line 6010
    tmp___130 = 1;
  }
#line 6010
  w = frame_w / tmp___130;
#line 6011
  if ((int )*(brushes_directional + cur_brush)) {
#line 6011
    tmp___131 = 3;
  } else {
#line 6011
    tmp___131 = 1;
  }
#line 6011
  h = (*(img_brushes + cur_brush))->h / tmp___131;
#line 6013
  x1 -= w >> 1;
#line 6014
  y1___0 -= h >> 1;
#line 6016
  x2 -= w >> 1;
#line 6017
  y2 -= h >> 1;
#line 6020
  direction = 8;
#line 6021
  r = - 1.;
#line 6022
  if ((int )*(brushes_directional + cur_brush)) {
    _L: /* CIL Label */ 
    {
#line 6024
    __cil_tmp25 = brush_rotation(x1, y1___0, x2, y2);
#line 6024
    r = (double )__cil_tmp25;
    }
#line 6026
    if (*(brushes_directional + cur_brush)) {
#line 6028
      r += 22.;
#line 6029
      if (r < 0.) {
#line 6030
        r += 360.;
      }
#line 6031
      if (x1 != x2) {
#line 6032
        direction = (int )(r / 45.);
      } else
#line 6031
      if (y1___0 != y2) {
#line 6032
        direction = (int )(r / 45.);
      }
    } else {
#line 6036
      r = 270. - r;
    }
  } else
#line 6022
  if ((int )*(brushes_rotate + cur_brush)) {
#line 6022
    goto _L;
  }
#line 6041
  dx = x2 - x1;
#line 6042
  dy = y2 - y1___0;
#line 6044
  if (dx != 0) {
#line 6046
    m = (float )dy / (float )dx;
#line 6047
    b = (float )y1___0 - m * (float )x1;
#line 6049
    if (x2 >= x1) {
#line 6050
      dx = 1;
    } else {
#line 6052
      dx = - 1;
    }
    {
#line 6055
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6055
      if (! (x1 != x2)) {
#line 6055
        goto while_break;
      }
#line 6057
      y1___0 = (int )(m * (float )x1 + b);
#line 6058
      y2 = (int )(m * (float )(x1 + dx) + b);
#line 6060
      if (y1___0 > y2) {
#line 6062
        y = y1___0;
        {
#line 6062
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6062
          if (! (y >= y2)) {
#line 6062
            goto while_break___0;
          }
          {
#line 6063
          blit_brush(x1, y, direction, r, & w, & h);
          }
#line 6062
          __cil_tmp26 = y;
#line 6062
          y --;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 6067
        y = y1___0;
        {
#line 6067
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 6067
          if (! (y <= y2)) {
#line 6067
            goto while_break___1;
          }
          {
#line 6068
          blit_brush(x1, y, direction, r, & w, & h);
          }
#line 6067
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 6071
      x1 += dx;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 6076
    if (y1___0 > y2) {
#line 6078
      y = y1___0;
#line 6079
      y1___0 = y2;
#line 6080
      y2 = y;
    }
#line 6083
    y = y1___0;
    {
#line 6083
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6083
      if (! (y <= y2)) {
#line 6083
        goto while_break___2;
      }
      {
#line 6084
      blit_brush(x1, y, direction, r, & w, & h);
      }
#line 6083
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 6087
  if (orig_x1 > orig_x2) {
#line 6089
    tmp = orig_x1;
#line 6090
    orig_x1 = orig_x2;
#line 6091
    orig_x2 = tmp;
  }
#line 6094
  if (orig_y1 > orig_y2) {
#line 6096
    tmp = orig_y1;
#line 6097
    orig_y1 = orig_y2;
#line 6098
    orig_y2 = tmp;
  }
#line 6102
  if (update) {
    {
#line 6104
    sz = 0;
#line 6105
    update_canvas(orig_x1 - sz, orig_y1 - sz, orig_x2 + sz, orig_y2 + sz);
    }
  }
  return;
}
}
#line 6117 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
void reset_brush_counter(void) 
{ 


  {
#line 6119
  if (img_cur_brush_rotate) {
#line 6120
    brush_counter = 0;
  } else {
#line 6122
    brush_counter = 999;
  }
  return;
}
}
#line 6138 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void blit_brush(int x , int y , int direction , double rotation , int *w ,
                       int *h ) 
{ 
  SDL_Rect src ;
  SDL_Rect dest ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int old_brush_frame ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  SDL_Surface *rotated_brush ;
  SDL_Surface *brush_frame_surf ;
  SDL_Surface *__cil_tmp16 ;
  SDL_Surface *__cil_tmp17 ;
  SDL_Surface *__cil_tmp18 ;

  {
#line 6142
  brush_counter ++;
#line 6144
  if (brush_counter >= img_cur_brush_spacing) {
#line 6146
    brush_counter = 0;
#line 6148
    if (img_cur_brush_frames >= 0) {
#line 6150
      brush_frame ++;
#line 6151
      if (brush_frame >= img_cur_brush_frames) {
#line 6152
        brush_frame = 0;
      }
    } else {
#line 6156
      old_brush_frame = brush_frame;
      {
#line 6158
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 6160
        __cil_tmp13 = abs(img_cur_brush_frames);
        }
        {
#line 6160
        __cil_tmp12 = rand();
#line 6160
        brush_frame = __cil_tmp12 % __cil_tmp13;
        }
#line 6158
        if (! (brush_frame == old_brush_frame)) {
#line 6158
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 6165
    dest.x = (Sint16 )x;
#line 6166
    dest.y = (Sint16 )y;
#line 6168
    if (img_cur_brush_directional) {
#line 6170
      if (direction == 5) {
#line 6173
        src.y = (Sint16 )0;
      } else
#line 6170
      if (direction == 6) {
#line 6173
        src.y = (Sint16 )0;
      } else
#line 6170
      if (direction == 7) {
#line 6173
        src.y = (Sint16 )0;
      } else
#line 6175
      if (direction == 4) {
#line 6178
        src.y = (Sint16 )img_cur_brush_h;
      } else
#line 6175
      if (direction == 8) {
#line 6178
        src.y = (Sint16 )img_cur_brush_h;
      } else
#line 6175
      if (direction == 0) {
#line 6178
        src.y = (Sint16 )img_cur_brush_h;
      } else
#line 6180
      if (direction == 3) {
#line 6183
        src.y = (Sint16 )(img_cur_brush_h << 1);
      } else
#line 6180
      if (direction == 2) {
#line 6183
        src.y = (Sint16 )(img_cur_brush_h << 1);
      } else
#line 6180
      if (direction == 1) {
#line 6183
        src.y = (Sint16 )(img_cur_brush_h << 1);
      }
#line 6186
      if (direction == 5) {
#line 6189
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w);
      } else
#line 6186
      if (direction == 4) {
#line 6189
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w);
      } else
#line 6186
      if (direction == 3) {
#line 6189
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w);
      } else
#line 6191
      if (direction == 6) {
#line 6194
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + img_cur_brush_w);
      } else
#line 6191
      if (direction == 8) {
#line 6194
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + img_cur_brush_w);
      } else
#line 6191
      if (direction == 2) {
#line 6194
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + img_cur_brush_w);
      } else
#line 6196
      if (direction == 7) {
#line 6199
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + (img_cur_brush_w << 1));
      } else
#line 6196
      if (direction == 0) {
#line 6199
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + (img_cur_brush_w << 1));
      } else
#line 6196
      if (direction == 1) {
#line 6199
        src.x = (Sint16 )(brush_frame * img_cur_brush_frame_w + (img_cur_brush_w << 1));
      }
    } else {
#line 6204
      src.x = (Sint16 )(brush_frame * img_cur_brush_w);
#line 6205
      src.y = (Sint16 )0;
    }
#line 6208
    src.w = (Uint16 )img_cur_brush_w;
#line 6209
    src.h = (Uint16 )img_cur_brush_h;
#line 6211
    if (img_cur_brush_rotate) {
#line 6211
      if (rotation != - 1.) {
#line 6217
        rotated_brush = (SDL_Surface *)((void *)0);
#line 6219
        if (img_cur_brush_frames != 1) {
          {
#line 6223
          brush_frame_surf = SDL_CreateRGBSurface(img_cur_brush->flags, (int )src.w,
                                                  (int )src.h, (int )(img_cur_brush->format)->BitsPerPixel,
                                                  (img_cur_brush->format)->Rmask,
                                                  (img_cur_brush->format)->Gmask,
                                                  (img_cur_brush->format)->Bmask,
                                                  (img_cur_brush->format)->Amask);
          }
#line 6230
          if (brush_frame_surf != (void *)0) {
            {
#line 6232
            SDL_gfxBlitRGBA(img_cur_brush, & src, brush_frame_surf, (SDL_Rect *)((void *)0));
#line 6233
            rotated_brush = rotozoomSurface(brush_frame_surf, rotation, 1., 1);
#line 6234
            SDL_FreeSurface(brush_frame_surf);
            }
          }
        } else {
          {
#line 6239
          rotated_brush = rotozoomSurface(img_cur_brush, rotation, 1., 1);
          }
        }
#line 6242
        if (rotated_brush != (void *)0) {
          {
#line 6244
          src.x = (Sint16 )0;
#line 6245
          src.y = (Sint16 )0;
#line 6246
          src.w = (Uint16 )rotated_brush->w;
#line 6247
          src.h = (Uint16 )rotated_brush->h;
#line 6249
          dest.x = (Sint16 )(((int )dest.x - (img_cur_brush_w >> 1)) + (rotated_brush->w >> 1));
#line 6250
          dest.y = (Sint16 )(((int )dest.y - (img_cur_brush_h >> 1)) + (rotated_brush->h >> 1));
#line 6251
          dest.w = (Uint16 )rotated_brush->w;
#line 6252
          dest.h = (Uint16 )rotated_brush->h;
#line 6254
          SDL_UpperBlit(rotated_brush, & src, canvas, & dest);
#line 6256
          SDL_FreeSurface(rotated_brush);
          }
        }
      } else {
        {
        {
#line 6261
        SDL_UpperBlit(img_cur_brush, & src, canvas, & dest);
        }
        }
      }
    } else {
      {
      {
#line 6261
      SDL_UpperBlit(img_cur_brush, & src, canvas, & dest);
      }
      }
    }
  }
#line 6265
  *w = (int )src.w;
#line 6266
  *h = (int )src.h;
  return;
}
}
#line 6294 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void fill_multichan(multichan *mc , double *up , double *vp ) 
{ 
  double X ;
  double Y ;
  double Z ;
  double u ;
  double v ;
  double u_prime ;
  double v_prime ;
  double Y_norm ;
  double fract ;
  double r ;
  double g ;
  double b ;
  double __cil_tmp16 ;
  double tmp ;
  double __cil_tmp18 ;
  double __cil_tmp19 ;

  {
#line 6300
  r = (double )sRGB_to_linear_table___1[mc->or];
#line 6301
  g = (double )sRGB_to_linear_table___1[mc->og];
#line 6302
  b = (double )sRGB_to_linear_table___1[mc->ob];
#line 6305
  X = (0.4124 * r + 0.3576 * g) + 0.1805 * b;
#line 6306
  Y = (0.212600000001 * r + 0.7152 * g) + 0.0722000000001 * b;
#line 6307
  Z = (0.0193000000001 * r + 0.119200000001 * g) + 0.950500000001 * b;
#line 6310
  Y_norm = Y / (double )1.;
#line 6311
  fract = 1. / ((X + 15. * Y) + 3. * Z);
#line 6312
  u_prime = (4. * X) * fract;
#line 6313
  v_prime = (9. * Y) * fract;
#line 6314
  if (Y_norm > 0.008856) {
    {
#line 6314
    __cil_tmp16 = pow(Y_norm, 1. / 3.);
#line 6314
    tmp = 116. * __cil_tmp16 - 16.;
    }
  } else {
#line 6314
    tmp = 903.3 * Y_norm;
  }
  {
#line 6314
  mc->L = tmp;
#line 6315
  u = (13. * mc->L) * (u_prime - (4. * (double )0.950500000001) / (((double )0.950500000001 + 15. * (double )1.) + 3. * (double )1.089));
#line 6316
  v = (13. * mc->L) * (v_prime - (9. * (double )1.) / (((double )0.950500000001 + 15. * (double )1.) + 3. * (double )1.089));
#line 6318
  mc->sat = sqrt(u * u + v * v);
#line 6319
  mc->hue = atan2(u, v);
  }
#line 6320
  if (up) {
#line 6321
    *up = u;
  }
#line 6322
  if (vp) {
#line 6323
    *vp = v;
  }
  return;
}
}
#line 6330 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static double tint_part_1(multichan *work , SDL_Surface *in ) 
{ 
  int xx ;
  int yy ;
  double u_total ;
  double v_total ;
  double u ;
  double v ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  multichan *mc ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  double __cil_tmp13 ;

  {
  {
#line 6333
  u_total = (double )0;
#line 6334
  v_total = (double )0;
#line 6337
  getpixel = getpixels[(in->format)->BytesPerPixel];
#line 6340
  SDL_LockSurface(in);
#line 6341
  yy = 0;
  }
  {
#line 6341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6341
    if (! (yy < in->h)) {
#line 6341
      goto while_break;
    }
#line 6343
    xx = 0;
    {
#line 6343
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6343
      if (! (xx < in->w)) {
#line 6343
        goto while_break___0;
      }
      {
#line 6345
      mc = (work + yy * in->w) + xx;
#line 6350
      fill_multichan(mc, & u, & v);
#line 6356
      u_total += ((double )((int )mc->alpha) * u) * mc->sat;
#line 6357
      v_total += ((double )((int )mc->alpha) * v) * mc->sat;
      }
#line 6343
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6341
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6361
  SDL_UnlockSurface(in);
#line 6367
  __cil_tmp13 = atan2(u_total, v_total);
  }
#line 6367
  return (__cil_tmp13);
}
}
#line 6374 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void change_colors(SDL_Surface *out , multichan *work , double hue_range ,
                          multichan *key_color_ptr ) 
{ 
  double lower_hue_1 ;
  double upper_hue_1 ;
  double lower_hue_2 ;
  double upper_hue_2 ;
  int xx ;
  int yy ;
  multichan dst ;
  double satratio ;
  double slope ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  double old_sat ;
  double newsat ;
  double L ;
  double X ;
  double Y ;
  double Z ;
  double u_prime ;
  double v_prime ;
  unsigned int tries ;
  double u ;
  double v ;
  double r ;
  double g ;
  double b ;
  multichan key_color ;
  multichan *mc ;
  double oldhue ;
  double __cil_tmp32 ;
  double __cil_tmp33 ;
  double __cil_tmp34 ;
  double tmp ;
  unsigned int __cil_tmp36 ;
  unsigned char __cil_tmp37 ;
  unsigned char __cil_tmp38 ;
  unsigned char __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;

  {
#line 6395
  key_color = *key_color_ptr;
#line 6397
  lower_hue_1 = key_color.hue - hue_range;
#line 6398
  upper_hue_1 = key_color.hue + hue_range;
#line 6399
  if (lower_hue_1 < - 3.14159265359) {
#line 6401
    lower_hue_2 = lower_hue_1 + (double )2 * 3.14159265359;
#line 6402
    upper_hue_2 = upper_hue_1 + (double )2 * 3.14159265359;
  } else {
#line 6406
    lower_hue_2 = lower_hue_1 - (double )2 * 3.14159265359;
#line 6407
    upper_hue_2 = upper_hue_1 - (double )2 * 3.14159265359;
  }
  {
#line 6411
  dst.or = *(*(color_hexes + cur_color) + 0);
#line 6412
  dst.og = *(*(color_hexes + cur_color) + 1);
#line 6413
  dst.ob = *(*(color_hexes + cur_color) + 2);
#line 6414
  fill_multichan(& dst, (double *)((void *)0), (double *)((void *)0));
#line 6416
  satratio = dst.sat / key_color.sat;
#line 6417
  slope = (dst.L - key_color.L) / dst.sat;
#line 6418
  putpixel = putpixels[(out->format)->BytesPerPixel];
#line 6420
  SDL_LockSurface(out);
#line 6421
  yy = 0;
  }
  {
#line 6421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6421
    if (! (yy < out->h)) {
#line 6421
      goto while_break;
    }
#line 6423
    xx = 0;
    {
#line 6423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6423
      if (! (xx < out->w)) {
#line 6423
        goto while_break___0;
      }
#line 6425
      mc = (work + yy * out->w) + xx;
#line 6426
      oldhue = mc->hue;
#line 6430
      if (oldhue < lower_hue_1) {
        _L: /* CIL Label */ 
#line 6430
        if (oldhue < lower_hue_2) {
          {
          {
#line 6432
          (*putpixel)(out, xx, yy, (((((unsigned int )mc->alpha & 255U) << 24) | (((unsigned int )mc->or & 255U) << 16)) | (((unsigned int )mc->og & 255U) << 8)) | ((unsigned int )mc->ob & 255U));
          }
          }
#line 6433
          goto while_continue___0;
        } else
#line 6430
        if (oldhue > upper_hue_2) {
          {
          {
#line 6432
          (*putpixel)(out, xx, yy, (((((unsigned int )mc->alpha & 255U) << 24) | (((unsigned int )mc->or & 255U) << 16)) | (((unsigned int )mc->og & 255U) << 8)) | ((unsigned int )mc->ob & 255U));
          }
          }
#line 6433
          goto while_continue___0;
        }
      } else
#line 6430
      if (oldhue > upper_hue_1) {
#line 6430
        goto _L;
      }
#line 6437
      old_sat = mc->sat;
#line 6438
      newsat = old_sat * satratio;
#line 6439
      L = mc->L;
#line 6440
      if (dst.sat > (double )0) {
#line 6441
        L += newsat * slope;
      } else {
#line 6443
        L += (old_sat * (dst.L - key_color.L)) / key_color.sat;
      }
#line 6446
      tries = (unsigned int )3;
      trysat: ;
      {
#line 6448
      __cil_tmp32 = sin(dst.hue);
#line 6448
      u = newsat * __cil_tmp32;
#line 6449
      __cil_tmp33 = cos(dst.hue);
#line 6449
      v = newsat * __cil_tmp33;
#line 6452
      u_prime = u / (13. * L) + (4. * (double )0.950500000001) / (((double )0.950500000001 + 15. * (double )1.) + 3. * (double )1.089);
#line 6453
      v_prime = v / (13. * L) + (9. * (double )1.) / (((double )0.950500000001 + 15. * (double )1.) + 3. * (double )1.089);
      }
#line 6454
      if (L > 7.99959199308) {
        {
#line 6454
        __cil_tmp34 = pow((L + 16.) / 116., 3.);
#line 6454
        tmp = (double )1. * __cil_tmp34;
        }
      } else {
#line 6454
        tmp = ((double )1. * L) / 903.3;
      }
#line 6454
      Y = tmp;
#line 6455
      X = ((2.25 * Y) * u_prime) / v_prime;
#line 6456
      Z = (3. * Y - (0.75 * Y) * u_prime) / v_prime - 5. * Y;
#line 6459
      r = (3.24100000001 * X + - 1.53740000001 * Y) + - 0.4986 * Z;
#line 6460
      g = (- 0.9692 * X + 1.876 * Y) + 0.0416 * Z;
#line 6461
      b = (0.0556 * X + - 0.204 * Y) + 1.057 * Z;
#line 6465
      __cil_tmp36 = tries;
#line 6465
      tries --;
#line 6465
      if (r <= - 0.5) {
        _L___132: /* CIL Label */ 
        _L___133: /* CIL Label */ 
        _L___134: /* CIL Label */ 
        _L___135: /* CIL Label */ 
        _L___136: /* CIL Label */ 
#line 6465
        if (__cil_tmp36) {
#line 6467
          newsat *= 0.800000000001;
#line 6468
          goto trysat;
        }
      } else
#line 6465
      if (g <= - 0.5) {
#line 6465
        goto _L___132;
      } else
#line 6465
      if (b <= - 0.5) {
#line 6465
        goto _L___132;
      } else
#line 6465
      if (r >= 255.5) {
#line 6465
        goto _L___132;
      } else
#line 6465
      if (g >= 255.5) {
#line 6465
        goto _L___132;
      } else
#line 6465
      if (b >= 255.5) {
#line 6465
        goto _L___132;
      }
      {
#line 6471
      __cil_tmp39 = linear_to_sRGB((float )b);
      }
      {
#line 6471
      __cil_tmp38 = linear_to_sRGB((float )g);
      }
      {
#line 6471
      __cil_tmp37 = linear_to_sRGB((float )r);
#line 6471
      (*putpixel)(out, xx, yy, (((((unsigned int )mc->alpha & 255U) << 24) | (((unsigned int )__cil_tmp37 & 255U) << 16)) | (((unsigned int )__cil_tmp38 & 255U) << 8)) | ((unsigned int )__cil_tmp39 & 255U));
      }
#line 6423
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6421
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6475
  SDL_UnlockSurface(out);
  }
  return;
}
}
#line 6482 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static multichan *find_most_saturated(double initial_hue , multichan *work , unsigned int num ,
                                      double *hue_range_ptr ) 
{ 
  multichan *key_color_ptr ;
  double hue_range ;
  unsigned int i ;
  double max_sat ;
  double lower_hue_1 ;
  double upper_hue_1 ;
  double lower_hue_2 ;
  double upper_hue_2 ;
  multichan *mc ;
  unsigned int __cil_tmp14 ;

  {
#line 6485
  key_color_ptr = (multichan *)((void *)0);
  {
#line 6501
  if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->tinter == 1) {
#line 6501
    goto case_1;
  }
#line 6504
  if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->tinter == 0) {
#line 6504
    goto case_0;
  }
#line 6497
  goto switch_default;
  switch_default: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 6499
  hue_range = ((double )18 * 3.14159265359) / 180.;
#line 6500
  goto switch_break;
  case_1: /* CIL Label */ 
#line 6502
  hue_range = ((double )6 * 3.14159265359) / 180.;
#line 6503
  goto switch_break;
  case_0: /* CIL Label */ 
#line 6505
  hue_range = 3.14159265359;
#line 6506
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  hue_range_retry: ;
#line 6511
  max_sat = (double )0;
#line 6512
  lower_hue_1 = initial_hue - hue_range;
#line 6513
  upper_hue_1 = initial_hue + hue_range;
#line 6515
  if (lower_hue_1 < - 3.14159265359) {
#line 6517
    lower_hue_2 = lower_hue_1 + (double )2 * 3.14159265359;
#line 6518
    upper_hue_2 = upper_hue_1 + (double )2 * 3.14159265359;
  } else {
#line 6522
    lower_hue_2 = lower_hue_1 - (double )2 * 3.14159265359;
#line 6523
    upper_hue_2 = upper_hue_1 - (double )2 * 3.14159265359;
  }
#line 6526
  i = num;
  {
#line 6527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6527
    __cil_tmp14 = i;
#line 6527
    i --;
#line 6527
    if (! __cil_tmp14) {
#line 6527
      goto while_break;
    }
#line 6529
    mc = work + i;
#line 6532
    if (mc->hue < lower_hue_1) {
      _L: /* CIL Label */ 
#line 6532
      if (mc->hue < lower_hue_2) {
#line 6533
        goto while_continue;
      } else
#line 6532
      if (mc->hue > upper_hue_2) {
#line 6533
        goto while_continue;
      }
    } else
#line 6532
    if (mc->hue > upper_hue_1) {
#line 6532
      goto _L;
    }
#line 6535
    if (mc->sat > max_sat) {
#line 6537
      max_sat = mc->sat;
#line 6538
      key_color_ptr = mc;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6542
  if (! key_color_ptr) {
#line 6544
    hue_range *= 1.5;
#line 6546
    if (hue_range < 3.14159265359) {
#line 6547
      goto hue_range_retry;
    }
  }
#line 6550
  *hue_range_ptr = hue_range;
#line 6552
  return (key_color_ptr);
}
}
#line 6559 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void vector_tint_surface(SDL_Surface *out , SDL_Surface *in ) 
{ 
  int xx ;
  int yy ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  double r ;
  double g ;
  double b ;
  unsigned char r8 ;
  unsigned char g8 ;
  unsigned char b8 ;
  unsigned char a8 ;
  double old ;
  unsigned char __cil_tmp15 ;
  unsigned char __cil_tmp16 ;
  unsigned char __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
  {
#line 6563
  getpixel = getpixels[(in->format)->BytesPerPixel];
#line 6564
  putpixel = putpixels[(out->format)->BytesPerPixel];
#line 6566
  r = (double )sRGB_to_linear_table___1[*(*(color_hexes + cur_color) + 0)];
#line 6567
  g = (double )sRGB_to_linear_table___1[*(*(color_hexes + cur_color) + 1)];
#line 6568
  b = (double )sRGB_to_linear_table___1[*(*(color_hexes + cur_color) + 2)];
#line 6570
  SDL_LockSurface(in);
#line 6571
  yy = 0;
  }
  {
#line 6571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6571
    if (! (yy < in->h)) {
#line 6571
      goto while_break;
    }
#line 6573
    xx = 0;
    {
#line 6573
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6573
      if (! (xx < in->w)) {
#line 6573
        goto while_break___0;
      }
      {
#line 6580
      old = ((double )sRGB_to_linear_table___1[r8] * 0.212600000001 + (double )sRGB_to_linear_table___1[g8] * 0.7152) + (double )sRGB_to_linear_table___1[b8] * 0.0722000000001;
#line 6583
      __cil_tmp17 = linear_to_sRGB((float )(b * old));
      }
      {
#line 6583
      __cil_tmp16 = linear_to_sRGB((float )(g * old));
      }
      {
#line 6583
      __cil_tmp15 = linear_to_sRGB((float )(r * old));
#line 6583
      (*putpixel)(out, xx, yy, (((((unsigned int )a8 & 255U) << 24) | (((unsigned int )__cil_tmp15 & 255U) << 16)) | (((unsigned int )__cil_tmp16 & 255U) << 8)) | ((unsigned int )__cil_tmp17 & 255U));
      }
#line 6573
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6571
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6588
  SDL_UnlockSurface(in);
  }
  return;
}
}
#line 6598 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void tint_surface(SDL_Surface *tmp_surf , SDL_Surface *surf_ptr ) 
{ 
  unsigned int width ;
  unsigned int height ;
  multichan *work ;
  multichan *key_color_ptr ;
  double initial_hue ;
  double hue_range ;
  void *__cil_tmp9 ;
  double __cil_tmp10 ;
  multichan *__cil_tmp11 ;

  {
  {
#line 6600
  width = (unsigned int )surf_ptr->w;
#line 6601
  height = (unsigned int )surf_ptr->h;
#line 6608
  work = (multichan *)malloc((sizeof(multichan ) * (unsigned long )width) * (unsigned long )height);
  }
#line 6610
  if (work) {
    {
#line 6612
    initial_hue = tint_part_1(work, surf_ptr);
#line 6619
    key_color_ptr = find_most_saturated(initial_hue, work, width * height, & hue_range);
    }
#line 6626
    if (key_color_ptr) {
      {
#line 6629
      hue_range *= 1.5;
#line 6631
      change_colors(tmp_surf, work, hue_range, key_color_ptr);
#line 6633
      free(work);
      }
#line 6634
      return;
    } else {
      {
#line 6638
      fprintf(stderr, "find_most_saturated() failed\n");
      }
    }
    {
#line 6641
    free(work);
    }
  }
  {
#line 6646
  fprintf(stderr, "Falling back to tinter=vector, this should be in the *.dat file\n\220");
#line 6648
  vector_tint_surface(tmp_surf, surf_ptr);
  }
  return;
}
}
#line 6659 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void stamp_draw(int x , int y ) 
{ 
  SDL_Rect dest ;
  SDL_Surface *tmp_surf ;
  SDL_Surface *surf_ptr ;
  SDL_Surface *final_surf ;
  Uint32 amask ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  int xx ;
  int yy ;
  int dont_free_tmp_surf ;
  int base_x ;
  int base_y ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  SDL_Surface *__cil_tmp21 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  SDL_Surface *__cil_tmp27 ;

  {
  {
#line 6670
  surf_ptr = active_stamp;
#line 6672
  getpixel = getpixels[(surf_ptr->format)->BytesPerPixel];
#line 6677
  __cil_tmp20 = stamp_tintable(cur_stamp[stamp_group]);
  }
  {
#line 6677
  __cil_tmp19 = stamp_colorable(cur_stamp[stamp_group]);
  }
#line 6677
  if (__cil_tmp19) {
    _L: /* CIL Label */ 
    {
#line 6679
    amask = ~ (((surf_ptr->format)->Rmask | (surf_ptr->format)->Gmask) | (surf_ptr->format)->Bmask);
#line 6681
    tmp_surf = SDL_CreateRGBSurface((Uint32 )0, surf_ptr->w, surf_ptr->h, (int )(surf_ptr->format)->BitsPerPixel,
                                    (surf_ptr->format)->Rmask, (surf_ptr->format)->Gmask,
                                    (surf_ptr->format)->Bmask, amask);
    }
#line 6688
    if (tmp_surf == (void *)0) {
      {
#line 6690
      __cil_tmp22 = SDL_GetError();
#line 6690
      fprintf(stderr, "\nError: Can\'t render the colored stamp!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\210t\324U",
              __cil_tmp22);
#line 6693
      cleanup();
#line 6694
      exit(1);
      }
    }
#line 6697
    dont_free_tmp_surf = 0;
  } else
#line 6677
  if (__cil_tmp20) {
#line 6677
    goto _L;
  } else {
#line 6703
    tmp_surf = (SDL_Surface *)((void *)0);
#line 6704
    dont_free_tmp_surf = 1;
  }
#line 6707
  if (tmp_surf != (void *)0) {
#line 6708
    putpixel = putpixels[(tmp_surf->format)->BytesPerPixel];
  } else {
#line 6710
    putpixel = (void (*)(SDL_Surface * , int  , int  , Uint32  ))((void *)0);
  }
  {
#line 6715
  __cil_tmp23 = stamp_colorable(cur_stamp[stamp_group]);
  }
#line 6715
  if (tmp_surf != (void *)0) {
#line 6715
    if (__cil_tmp23) {
      {
#line 6724
      SDL_LockSurface(surf_ptr);
#line 6725
      SDL_LockSurface(tmp_surf);
#line 6727
      yy = 0;
      }
      {
#line 6727
      while (1) {
        while_continue: /* CIL Label */ ;
#line 6727
        if (! (yy < surf_ptr->h)) {
#line 6727
          goto while_break;
        }
#line 6729
        xx = 0;
        {
#line 6729
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6729
          if (! (xx < surf_ptr->w)) {
#line 6729
            goto while_break___0;
          }
          {
#line 6733
          (*putpixel)(tmp_surf, xx, yy, (((((unsigned int )a & 255U) << 24) | (((unsigned int )*(*(color_hexes + cur_color) + 0) & 255U) << 16)) | (((unsigned int )*(*(color_hexes + cur_color) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + cur_color) + 2) & 255U));
          }
#line 6729
          xx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 6727
        yy ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 6739
      SDL_UnlockSurface(tmp_surf);
#line 6740
      SDL_UnlockSurface(surf_ptr);
      }
    } else {
#line 6715
      goto _L___137;
    }
  } else {
    _L___137: /* CIL Label */ 
    {
#line 6742
    __cil_tmp26 = stamp_tintable(cur_stamp[stamp_group]);
    }
#line 6742
    if (__cil_tmp26) {
#line 6744
      if ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->tinter == 3) {
        {
#line 6745
        vector_tint_surface(tmp_surf, surf_ptr);
        }
      } else {
        {
#line 6747
        tint_surface(tmp_surf, surf_ptr);
        }
      }
    } else {
#line 6752
      tmp_surf = surf_ptr;
    }
  }
  {
#line 6756
  final_surf = thumbnail(tmp_surf, (int )((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom),
                         (int )((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom),
                         0);
#line 6759
  base_x = (int )((unsigned int )x - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U);
#line 6760
  base_y = (int )((unsigned int )y - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U);
#line 6763
  dest.x = (Sint16 )base_x;
#line 6764
  dest.y = (Sint16 )base_y;
#line 6765
  SDL_UpperBlit(final_surf, (SDL_Rect *)((void *)0), canvas, & dest);
#line 6767
  update_canvas((int )((unsigned int )x - ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U),
                (int )((unsigned int )y - ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U),
                (int )((unsigned int )x + ((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U),
                (int )((unsigned int )y + ((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom + 1U) / 2U));
  }
#line 6772
  if (! dont_free_tmp_surf) {
    {
#line 6773
    SDL_FreeSurface(tmp_surf);
    }
  }
  {
#line 6775
  SDL_FreeSurface(final_surf);
  }
  return;
}
}
#line 6782 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void rec_undo_buffer(void) 
{ 
  int wanna_update_toolbar ;

  {
  {
#line 6786
  wanna_update_toolbar = 0;
#line 6788
  rec_undo_label();
#line 6790
  SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), undo_bufs[cur_undo], (SDL_Rect *)((void *)0));
#line 6791
  undo_starters[cur_undo] = 0;
#line 6793
  cur_undo = (cur_undo + 1) % 20;
  }
#line 6795
  if (cur_undo == oldest_undo) {
#line 6796
    oldest_undo = (oldest_undo + 1) % 20;
  }
#line 6798
  newest_undo = cur_undo;
#line 6808
  if (tool_avail[8] == 0) {
#line 6810
    tool_avail[8] = 1;
#line 6811
    wanna_update_toolbar = 1;
  }
#line 6814
  if (tool_avail[9]) {
#line 6816
    tool_avail[9] = 0;
#line 6817
    wanna_update_toolbar = 1;
  }
#line 6820
  if (wanna_update_toolbar) {
    {
#line 6822
    draw_toolbar();
#line 6823
    update_screen_rect(& r_tools);
    }
  }
  return;
}
}
#line 6834 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
void show_version(int details ) 
{ 


  {
  {
#line 6836
  printf("\nTux Paint\n");
#line 6837
  printf("  Version 0.9.27 (2024-04-18)\n");
  }
#line 6840
  if (details == 0) {
#line 6841
    return;
  }
  {
#line 6844
  printf("\nBuilt with these options:\n");
#line 6899
  printf("  Built for POSIX\n");
#line 6908
  printf("  Using software surface  (no USE_HWSURFACE)\n");
#line 6910
  printf("  Using %dbpp video  (VIDEO_BPP=%d)\n", 32, 32);
#line 6920
  printf("  Prints as PostScript  (PRINTMETHOD_PS)\n");
#line 6927
  printf("  Threaded font loader enabled  (FORKED_FONTS)\n");
#line 6939
  printf("  Data directory (DATA_PREFIX) = %s\n", "/usr/local/share/tuxpaint/");
#line 6940
  printf("  Plugin directory (MAGIC_PREFIX) = %s\n", "/usr/local/lib/tuxpaint/plugins/\220");
#line 6941
  printf("  Doc directory (DOC_PREFIX) = %s\n", "/usr/local/share/doc/tuxpaint-0.9.27/");
#line 6942
  printf("  Locale directory (LOCALEDIR) = %s\n", "/usr/local/share/locale/\220");
#line 6943
  printf("  Input Method directory (IMDIR) = %s\n", "/usr/local/share/tuxpaint/im/");
#line 6944
  printf("  System config directory (CONFDIR) = %s\n", "/usr/local/etc/tuxpaint/\220");
#line 6958
  printf("\n");
  }
  return;
}
}
#line 6968 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
void show_usage(int exitcode ) 
{ 
  FILE *f ;
  FILE *tmp ;

  {
#line 6970
  if (exitcode) {
#line 6970
    tmp = stderr;
  } else {
#line 6970
    tmp = stdout;
  }
  {
#line 6970
  f = tmp;
#line 6973
  fprintf(f, "\nUsage: %s {--usage | --help | --version | --verbose-version | --copying}\n\n Config:\n  [--nosysconfig]\n\n Video/Sound:\n  [--windowed | --fullscreen]\n  [--WIDTHxHEIGHT | --native]\n  [--orient=landscape | --orient=portrait]\n  [--disablescreensaver | --allowscreensaver ]\n  [--sound | --nosound]\n  [--stereo | --nostereo]\n  [--buttonsize=N] (24-192; default=48)\n  [--colorsrows=N] (1-3; default=1)\n  [--colorfile FILE]\n\n Mouse/Keyboard:\n  [--fancycursors | --nofancycursors]\n  [--hidecursor | --showcursor]\n  [--noshortcuts | --shortcuts]\n  [--dontgrab | --grab]\n  [--wheelmouse | --nowheelmouse]\n  [--nobuttondistinction | --buttondistinction]\n\n Simplification:\n  [--complexshapes | --simpleshapes]\n  [--outlines | --nooutlines]\n  [--mixedcase | --uppercase]\n  [--stampsize=[0-10] | --stampsize=default]\n  [--quit | --noquit]\n  [--stamps | --nostamps]\n  [--nostampcontrols | --stampcontrols]\n  [--nomagiccontrols | --magiccontrols]\n  [--noshapecontrols | --shapecontrols]\n  [--nolabel | --label]\n  [--newcolorsfirst | --newcolorslast]\n\n Languages:\n  [--lang LANGUAGE | --locale LOCALE | --lang help]\n  [--mirrorstamps | --dontmirrorstamps]\n  [--sysfonts | --nosysfonts]\n  [--currentlocalefont | --alllocalefonts]\n\n Printing:\n  [--print | --noprint]\n  [--printdelay=SECONDS]\n  [--altprintmod | --altprintalways | --altprintnever]\n  [--printcommand=COMMAND]\n  [--altprintcommand=COMMAND]\n  [--papersize PAPERSIZE | --papersize help]\n\n Saving:\n  [--saveoverask | --saveover | --saveovernew]\n  [--startblank | --startlast]\n  [--savedir DIRECTORY]\n  [--nosave | --save]\n  [--autosave | --noautosave]\n\n Data:\n  [--nolockfile]\n  [--datadir DIRECTORY]\n\n Exporting:\n  [--exportdir DIRECTORY]\n\n Accessibility:\n  [--mouse-accessibility]\n  [--mouse | --keyboard]\n  [--onscreen-keyboard]\n  [--onscreen-keyboard-layout=LAYOUT]\n  [--onscreen-keyboard-disable-change]\n\n Joystick:\n  [--joystick-dev N] (default=0)\n  [--joystick-slowness N] (0-500; default value is 15)\n  [--joystick-threshold N] (0-32766; default value is 3200)\n  [--joystick-maxsteps N] (1-7; default value is 7)\n  [--joystick-hat-slowness N] (0-500; default value is 15)\n  [--joystick-hat-timeout N] (0-3000; default value is 1000)\n  [--joystick-buttons-ignore=BUTTON1,BUTTON2,...]\n  [--joystick-btn-COMMAND=BUTTON]\n\n",
          progname);
  }
  return;
}
}
#line 7081 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static unsigned int compute_default_scale_factor(double ratio ) 
{ 
  double old_diag ;
  double __cil_tmp3 ;
  double new_diag ;
  double __cil_tmp5 ;
  double good_def ;
  double __cil_tmp7 ;
  double good_log ;
  double __cil_tmp9 ;
  unsigned int defsize ;
  double this_err ;
  double __cil_tmp12 ;
  double next_err ;
  double __cil_tmp14 ;
  double __cil_tmp15 ;
  double __cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
  {
#line 7083
  __cil_tmp3 = sqrt((double )342080);
#line 7083
  old_diag = __cil_tmp3;
#line 7084
  __cil_tmp5 = sqrt((double )(canvas->w * canvas->w + canvas->h * canvas->h));
#line 7084
  new_diag = __cil_tmp5;
#line 7085
  __cil_tmp7 = sqrt(new_diag / old_diag);
#line 7085
  good_def = ratio * __cil_tmp7;
#line 7086
  __cil_tmp9 = log(good_def);
#line 7086
  good_log = __cil_tmp9;
#line 7087
  defsize = (unsigned int )(sizeof(scaletable) / sizeof(scaletable[0]) - 1UL);
  }
  {
#line 7089
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7089
    if (! (defsize > 0U)) {
#line 7089
      goto while_break;
    }
    {
#line 7091
    __cil_tmp12 = log((double )scaletable[defsize].numer / (double )scaletable[defsize].denom);
#line 7091
    this_err = good_log - __cil_tmp12;
#line 7092
    __cil_tmp14 = log((double )scaletable[defsize - 1U].numer / (double )scaletable[defsize - 1U].denom);
#line 7092
    next_err = good_log - __cil_tmp14;
#line 7094
    __cil_tmp16 = fabs(this_err);
    }
    {
#line 7094
    __cil_tmp15 = fabs(next_err);
    }
#line 7094
    if (__cil_tmp15 > __cil_tmp16) {
#line 7095
      goto while_break;
    }
#line 7096
    __cil_tmp17 = defsize;
#line 7096
    defsize --;
  }
  while_break: /* CIL Label */ ;
  }
#line 7098
  return (defsize);
}
}
#line 7112 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void loadbrush_callback(SDL_Surface *screen___0 , char const   *dir , unsigned int dirlen ,
                               tp_ftw_str *files , unsigned int i , char const   *locale ) 
{ 
  FILE *fi ;
  char buf[64] ;
  int want_rand ;
  int brush_w ;
  int brush_h ;
  float scale ;
  unsigned int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char fname[512] ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  SDL_Surface *__cil_tmp23 ;
  char *__cil_tmp24 ;
  FILE *__cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  int __cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  int __cil_tmp37 ;
  int tmp ;
  int tmp___0 ;
  SDL_Surface *__cil_tmp40 ;
  SDL_Surface *__cil_tmp41 ;
  int __cil_tmp42 ;

  {
  {
#line 7126
  qsort(files, (size_t )i, sizeof(*files), & compare_ftw_str);
  }
  {
#line 7127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7127
    __cil_tmp13 = i;
#line 7127
    i --;
#line 7127
    if (! __cil_tmp13) {
#line 7127
      goto while_break;
    }
    {
#line 7129
    show_progress_bar(screen___0);
#line 7130
    __cil_tmp14 = strcasestr((char const   *)(files + i)->str, ".png");
    }
#line 7130
    if (__cil_tmp14) {
      {
#line 7134
      __cil_tmp16 = strcasecmp((char const   *)(files + i)->str, "aa_round_03.png");
      }
#line 7134
      if (__cil_tmp16 == 0) {
#line 7135
        shape_brush = num_brushes;
      }
      {
#line 7137
      safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dir, (files + i)->str);
      }
#line 7138
      if (num_brushes == num_brushes_max) {
        {
#line 7140
        num_brushes_max = (num_brushes_max * 5) / 4 + 4;
#line 7141
        img_brushes = (SDL_Surface **)realloc(img_brushes, (unsigned long )num_brushes_max * sizeof(*img_brushes));
#line 7142
        img_brushes_thumbs = (SDL_Surface **)realloc(img_brushes_thumbs, (unsigned long )num_brushes_max * sizeof(*img_brushes_thumbs));
#line 7143
        brushes_frames = (int *)realloc(brushes_frames, (unsigned long )num_brushes_max * sizeof(int ));
#line 7144
        brushes_directional = (short *)realloc(brushes_directional, (unsigned long )num_brushes_max * sizeof(short ));
#line 7145
        brushes_rotate = (short *)realloc(brushes_rotate, (unsigned long )num_brushes_max * sizeof(short ));
#line 7146
        brushes_spacing = (int *)realloc(brushes_spacing, (unsigned long )num_brushes_max * sizeof(int ));
        }
      }
      {
#line 7148
      *(img_brushes + num_brushes) = loadimage((char const   *)((char *)fname));
#line 7152
      *(brushes_frames + num_brushes) = 1;
#line 7153
      *(brushes_directional + num_brushes) = (short )0;
#line 7154
      *(brushes_rotate + num_brushes) = (short )0;
#line 7155
      *(brushes_spacing + num_brushes) = (*(img_brushes + num_brushes))->h / 4;
#line 7157
      __cil_tmp24 = strcasestr((char const   *)((char *)fname), ".png");
#line 7157
      strcpy(__cil_tmp24, ".dat");
#line 7158
      fi = fopen((char const   *)((char *)fname), "r\177\212t\324U");
#line 7160
      want_rand = 0;
      }
#line 7162
      if (fi != (void *)0) {
        {
#line 7164
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 7166
          __cil_tmp27 = fgets((char *)buf, (int )sizeof(buf), fi);
          }
#line 7166
          if (__cil_tmp27) {
            {
#line 7168
            __cil_tmp28 = strstr((char const   *)((char *)buf), "frames=");
            }
#line 7168
            if (__cil_tmp28 != (void *)0) {
              {
#line 7170
              __cil_tmp29 = strstr((char const   *)((char *)buf), "frames=");
#line 7170
              __cil_tmp30 = atoi((char const   *)(__cil_tmp29 + 7));
#line 7170
              *(brushes_frames + num_brushes) = __cil_tmp30;
              }
            } else {
              {
#line 7172
              __cil_tmp31 = strstr((char const   *)((char *)buf), "spacing=\220");
              }
#line 7172
              if (__cil_tmp31 != (void *)0) {
                {
#line 7174
                __cil_tmp32 = strstr((char const   *)((char *)buf), "spacing=\220");
#line 7174
                __cil_tmp33 = atoi((char const   *)(__cil_tmp32 + 8));
#line 7174
                *(brushes_spacing + num_brushes) = __cil_tmp33;
                }
              } else {
                {
#line 7176
                __cil_tmp34 = strstr((char const   *)((char *)buf), "directional");
                }
#line 7176
                if (__cil_tmp34 != (void *)0) {
#line 7178
                  *(brushes_directional + num_brushes) = (short )1;
                } else {
                  {
#line 7180
                  __cil_tmp35 = strstr((char const   *)((char *)buf), "rotate");
                  }
#line 7180
                  if (__cil_tmp35 != (void *)0) {
#line 7182
                    *(brushes_rotate + num_brushes) = (short )1;
                  } else {
                    {
#line 7184
                    __cil_tmp36 = strstr((char const   *)((char *)buf), "random");
                    }
#line 7184
                    if (__cil_tmp36 != (void *)0) {
#line 7186
                      want_rand = 1;
                    }
                  }
                }
              }
            }
          }
#line 7164
          if (! (! __cil_tmp26)) {
#line 7164
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 7191
        fclose(fi);
        }
#line 7193
        if (want_rand) {
#line 7194
          *(brushes_frames + num_brushes) *= - 1;
        }
      }
#line 7198
      if ((int )*(brushes_directional + num_brushes)) {
#line 7198
        tmp = 3;
      } else {
#line 7198
        tmp = 1;
      }
      {
#line 7198
      __cil_tmp37 = abs(*(brushes_frames + num_brushes));
#line 7198
      brush_w = ((*(img_brushes + num_brushes))->w / __cil_tmp37) / tmp;
      }
#line 7199
      if ((int )*(brushes_directional + num_brushes)) {
#line 7199
        tmp___0 = 3;
      } else {
#line 7199
        tmp___0 = 1;
      }
#line 7199
      brush_h = (*(img_brushes + num_brushes))->h / tmp___0;
#line 7201
      if (brush_w <= button_w) {
#line 7201
        if (brush_h <= button_h) {
          {
#line 7203
          *(img_brushes_thumbs + num_brushes) = duplicate_surface(*(img_brushes + num_brushes));
          }
        } else {
#line 7201
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 7205
        if (brush_w > brush_h) {
#line 7206
          scale = (float )((float )button_w / (float )brush_w);
        } else {
#line 7208
          scale = (float )((float )button_h / (float )brush_h);
        }
        {
#line 7211
        *(img_brushes_thumbs + num_brushes) = thumbnail2(*(img_brushes + num_brushes),
                                                         (int )((float )(*(img_brushes + num_brushes))->w * scale),
                                                         (int )((float )(*(img_brushes + num_brushes))->h * scale),
                                                         0, 1);
        }
      }
#line 7221
      num_brushes ++;
    }
    {
#line 7223
    free((files + i)->str);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7225
  free(files);
  }
  return;
}
}
#line 7232 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_brush_dir(SDL_Surface *screen___0 , char const   *dir ) 
{ 
  char buf[400] ;
  unsigned int dirlen ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 7235
  __cil_tmp5 = strlen(dir);
#line 7235
  dirlen = (unsigned int )__cil_tmp5;
#line 7237
  memcpy((char *)buf, dir, (unsigned long )dirlen);
#line 7238
  tp_ftw(screen___0, (char *)buf, dirlen, 0, & loadbrush_callback, (char const   *)((void *)0));
  }
  return;
}
}
#line 7244 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
SDL_Surface *mirror_surface(SDL_Surface *s ) 
{ 
  SDL_Surface *new_surf ;
  int x ;
  SDL_Rect src ;
  SDL_Rect dest ;
  SDL_Surface *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 7253
  new_surf = duplicate_surface(s);
  }
#line 7255
  if (new_surf != (void *)0) {
#line 7257
    x = 0;
    {
#line 7257
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7257
      if (! (x < s->w)) {
#line 7257
        goto while_break;
      }
      {
#line 7259
      src.x = (Sint16 )x;
#line 7260
      src.y = (Sint16 )0;
#line 7261
      src.w = (Uint16 )1;
#line 7262
      src.h = (Uint16 )s->h;
#line 7264
      dest.x = (Sint16 )((s->w - x) - 1);
#line 7265
      dest.y = (Sint16 )0;
#line 7267
      SDL_UpperBlit(s, & src, new_surf, & dest);
      }
#line 7257
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 7270
    SDL_FreeSurface(s);
    }
#line 7272
    return (new_surf);
  } else {
#line 7276
    return (s);
  }
}
}
#line 7283 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
SDL_Surface *flip_surface(SDL_Surface *s ) 
{ 
  SDL_Surface *new_surf ;
  int y ;
  SDL_Rect src ;
  SDL_Rect dest ;
  SDL_Surface *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 7292
  new_surf = duplicate_surface(s);
  }
#line 7294
  if (new_surf != (void *)0) {
#line 7296
    y = 0;
    {
#line 7296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7296
      if (! (y < s->h)) {
#line 7296
        goto while_break;
      }
      {
#line 7298
      src.x = (Sint16 )0;
#line 7299
      src.y = (Sint16 )y;
#line 7300
      src.w = (Uint16 )s->w;
#line 7301
      src.h = (Uint16 )1;
#line 7303
      dest.x = (Sint16 )0;
#line 7304
      dest.y = (Sint16 )((s->h - y) - 1);
#line 7306
      SDL_UpperBlit(s, & src, new_surf, & dest);
      }
#line 7296
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 7309
    SDL_FreeSurface(s);
    }
#line 7311
    return (new_surf);
  } else {
#line 7315
    return (s);
  }
}
}
#line 7319
static unsigned int default_stamp_size ;
#line 7324 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void loadstamp_finisher(stamp_type *sd , unsigned int w , unsigned int h ,
                               double ratio ) 
{ 
  unsigned int upper ;
  unsigned int underscanned_upper ;
  unsigned int lower ;
  unsigned int mid ;
  scaleparams *s ;
  int pw ;
  int ph ;
  scaleparams *s___0 ;
  int pw___0 ;
  int ph___0 ;
  unsigned int __cil_tmp15 ;
  unsigned int __cil_tmp16 ;

  {
#line 7326
  upper = (unsigned int )(sizeof(scaletable) / sizeof(scaletable[0]) - 1UL);
#line 7327
  underscanned_upper = (unsigned int )(sizeof(scaletable) / sizeof(scaletable[0]) - 1UL);
#line 7328
  lower = (unsigned int )0;
#line 7336
  if (mirrorstamps) {
#line 7336
    if ((int )sd->mirrorable) {
#line 7337
      sd->mirrored = (unsigned int )1;
    }
  }
  {
#line 7339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7341
    s = & scaletable[upper];
#line 7344
    pw = (int )(((w * s->numer + s->denom) - 1U) / s->denom);
#line 7345
    ph = (int )(((h * s->numer + s->denom) - 1U) / s->denom);
#line 7350
    if ((double )pw < (double )canvas->w * 1.5) {
#line 7350
      if (ph < canvas->h) {
#line 7355
        if (pw > canvas->w) {
#line 7357
          underscanned_upper = upper - 1U;
        } else {
#line 7361
          underscanned_upper = upper;
        }
#line 7363
        goto while_break;
      }
    }
#line 7365
    if (pw < canvas->w) {
#line 7365
      if ((double )ph < (double )canvas->h * 1.5) {
#line 7370
        if (ph > canvas->h) {
#line 7372
          underscanned_upper = upper - 1U;
        } else {
#line 7376
          underscanned_upper = upper;
        }
#line 7378
        goto while_break;
      }
    }
#line 7339
    if (! upper) {
#line 7339
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7396
    s___0 = & scaletable[lower];
#line 7399
    pw___0 = (int )(((w * s___0->numer + s___0->denom) - 1U) / s___0->denom);
#line 7400
    ph___0 = (int )(((h * s___0->numer + s___0->denom) - 1U) / s___0->denom);
#line 7402
    if (pw___0 * ph___0 > 20) {
#line 7407
      goto while_break___0;
    }
#line 7394
    if (! ((unsigned long )lower < sizeof(scaletable) / sizeof(scaletable[0]) - 1UL)) {
#line 7394
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 7413
  if (upper < lower) {
#line 7416
    upper = (upper + lower) / 2U;
#line 7417
    lower = upper;
  }
#line 7420
  mid = default_stamp_size;
#line 7421
  if (ratio != 1.) {
    {
#line 7422
    mid = compute_default_scale_factor(ratio);
    }
  }
#line 7425
  if (ratio == 1.) {
#line 7425
    if ((int )sd->is_svg) {
      {
#line 7427
      mid = compute_default_scale_factor(0.200000000001);
      }
    }
  }
#line 7430
  if (mid > upper) {
#line 7431
    mid = upper;
  }
#line 7433
  if (mid > underscanned_upper) {
#line 7434
    mid = underscanned_upper;
  }
#line 7436
  if (mid < lower) {
#line 7437
    mid = lower;
  }
#line 7439
  sd->min = lower;
#line 7440
  sd->size = mid;
#line 7441
  sd->max = upper;
#line 7447
  if (stamp_size_override != -1) {
#line 7449
    sd->size = ((upper - lower) * (unsigned int )stamp_size_override) / 10U + lower;
  }
  return;
}
}
#line 7464 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void set_active_stamp(void) 
{ 
  stamp_type *sd ;
  unsigned int len ;
  unsigned long __cil_tmp3 ;
  char *buf ;
  unsigned long __cil_tmp5 ;
  void *__cil_tmp6 ;
  int needs_mirror ;
  int needs_flip ;
  SDL_Surface *__cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;
  SDL_Surface *__cil_tmp11 ;
  SDL_Surface *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;
  SDL_Surface *__cil_tmp15 ;
  SDL_Surface *__cil_tmp16 ;
  SDL_Surface *__cil_tmp17 ;
  SDL_Surface *__cil_tmp18 ;
  SDL_Surface *__cil_tmp19 ;
  SDL_Surface *__cil_tmp20 ;
  SDL_Surface *__cil_tmp21 ;
  SDL_Surface *__cil_tmp22 ;
  SDL_Surface *__cil_tmp23 ;

  {
  {
#line 7466
  sd = *(stamp_data[stamp_group] + cur_stamp[stamp_group]);
#line 7467
  __cil_tmp3 = strlen((char const   *)sd->stampname);
#line 7467
  len = (unsigned int )__cil_tmp3;
#line 7468
  __cil_tmp5 = strlen("_mirror_flip.EXT\220");
#line 7468
  __cil_tmp6 = __builtin_alloca(((unsigned long )len + __cil_tmp5) + 1UL);
#line 7468
  buf = __cil_tmp6;
  }
#line 7471
  if (active_stamp) {
    {
#line 7472
    SDL_FreeSurface(active_stamp);
    }
  }
  {
#line 7473
  active_stamp = (SDL_Surface *)((void *)0);
#line 7475
  memcpy(buf, sd->stampname, (unsigned long )len);
#line 7483
  needs_mirror = (int )sd->mirrored;
#line 7484
  needs_flip = (int )sd->flipped;
  }
#line 7486
  if ((int )sd->mirrored) {
#line 7486
    if ((int )sd->flipped) {
#line 7494
      if (! sd->no_premirrorflip) {
        {
#line 7497
        memcpy(buf + len, "_mirror_flip.svg\251", (unsigned long )17);
#line 7498
        active_stamp = do_loadimage((char const   *)buf, 0);
        }
#line 7501
        if (active_stamp == (void *)0) {
          {
#line 7503
          memcpy(buf + len, "_mirror_flip.png\251", (unsigned long )17);
#line 7504
          active_stamp = do_loadimage((char const   *)buf, 0);
          }
        }
      }
#line 7509
      if (active_stamp != (void *)0) {
#line 7515
        needs_mirror = 0;
#line 7516
        needs_flip = 0;
      } else {
#line 7527
        if (! sd->no_premirror) {
          {
#line 7530
          memcpy(buf + len, "_mirror.svg", (unsigned long )12);
#line 7531
          active_stamp = do_loadimage((char const   *)buf, 0);
          }
#line 7534
          if (active_stamp == (void *)0) {
            {
#line 7536
            memcpy(buf + len, "_mirror.png", (unsigned long )12);
#line 7537
            active_stamp = do_loadimage((char const   *)buf, 0);
            }
          }
        }
#line 7541
        if (active_stamp != (void *)0) {
#line 7546
          needs_mirror = 0;
        } else {
#line 7557
          if (! sd->no_preflip) {
            {
#line 7560
            memcpy(buf + len, "_flip.svg", (unsigned long )10);
#line 7561
            active_stamp = do_loadimage((char const   *)buf, 0);
            }
#line 7564
            if (active_stamp == (void *)0) {
              {
#line 7566
              memcpy(buf + len, "_flip.png", (unsigned long )10);
#line 7567
              active_stamp = do_loadimage((char const   *)buf, 0);
              }
            }
          }
#line 7571
          if (active_stamp != (void *)0) {
#line 7576
            needs_flip = 0;
          }
        }
      }
    } else {
#line 7486
      goto _L___138;
    }
  } else
  _L___138: /* CIL Label */ 
#line 7587
  if ((int )sd->flipped) {
#line 7587
    if (! sd->no_preflip) {
      {
#line 7596
      memcpy(buf + len, "_flip.svg", (unsigned long )10);
#line 7597
      active_stamp = do_loadimage((char const   *)buf, 0);
      }
#line 7600
      if (active_stamp == (void *)0) {
        {
#line 7602
        memcpy(buf + len, "_flip.png", (unsigned long )10);
#line 7603
        active_stamp = do_loadimage((char const   *)buf, 0);
        }
      }
#line 7606
      if (active_stamp != (void *)0) {
#line 7611
        needs_flip = 0;
      }
    } else {
#line 7587
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 7620
  if ((int )sd->mirrored) {
#line 7620
    if (! sd->no_premirror) {
      {
#line 7629
      memcpy(buf + len, "_mirror.svg", (unsigned long )12);
#line 7630
      active_stamp = do_loadimage((char const   *)buf, 0);
      }
#line 7633
      if (active_stamp == (void *)0) {
        {
#line 7635
        memcpy(buf + len, "_mirror.png", (unsigned long )12);
#line 7636
        active_stamp = do_loadimage((char const   *)buf, 0);
        }
      }
#line 7639
      if (active_stamp != (void *)0) {
#line 7644
        needs_mirror = 0;
      }
    }
  }
#line 7658
  if (! active_stamp) {
    {
#line 7665
    memcpy(buf + len, ".svg", (unsigned long )5);
#line 7666
    active_stamp = do_loadimage((char const   *)buf, 0);
    }
#line 7669
    if (active_stamp == (void *)0) {
      {
#line 7671
      memcpy(buf + len, ".png", (unsigned long )5);
#line 7672
      active_stamp = do_loadimage((char const   *)buf, 0);
      }
    }
  }
#line 7679
  if (! active_stamp) {
    {
#line 7680
    active_stamp = thumbnail(img_dead40x40, 40, 40, 1);
    }
  }
#line 7686
  if (needs_mirror) {
    {
#line 7691
    active_stamp = mirror_surface(active_stamp);
    }
  }
#line 7694
  if (needs_flip) {
    {
#line 7699
    active_stamp = flip_surface(active_stamp);
    }
  }
  return;
}
}
#line 7710 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void get_stamp_thumb(stamp_type *sd ) 
{ 
  SDL_Surface *bigimg ;
  unsigned int len ;
  unsigned long __cil_tmp4 ;
  char *buf ;
  unsigned long __cil_tmp6 ;
  void *__cil_tmp7 ;
  int need_mirror ;
  int need_flip ;
  double ratio ;
  unsigned int w ;
  unsigned int h ;
  double __cil_tmp13 ;
  char *__cil_tmp14 ;
  Mix_Chunk *__cil_tmp15 ;
  Mix_Chunk *__cil_tmp16 ;
  SDL_Surface *__cil_tmp17 ;
  SDL_Surface *__cil_tmp18 ;
  SDL_Surface *__cil_tmp19 ;
  SDL_Surface *__cil_tmp20 ;
  SDL_Surface *__cil_tmp21 ;
  SDL_Surface *__cil_tmp22 ;
  SDL_Surface *__cil_tmp23 ;
  SDL_Surface *__cil_tmp24 ;
  SDL_Surface *__cil_tmp25 ;
  SDL_Surface *__cil_tmp26 ;
  SDL_Surface *__cil_tmp27 ;
  SDL_Surface *__cil_tmp28 ;
  int ww ;
  int hh ;
  SDL_Surface *__cil_tmp31 ;
  SDL_Surface *__cil_tmp32 ;
  SDL_Surface *__cil_tmp33 ;
  SDL_Surface *__cil_tmp34 ;

  {
  {
#line 7712
  bigimg = (SDL_Surface *)((void *)0);
#line 7713
  __cil_tmp4 = strlen((char const   *)sd->stampname);
#line 7713
  len = (unsigned int )__cil_tmp4;
#line 7714
  __cil_tmp6 = strlen("_mirror_flip.EXT\220");
#line 7714
  __cil_tmp7 = __builtin_alloca(((unsigned long )len + __cil_tmp6) + 1UL);
#line 7714
  buf = __cil_tmp7;
#line 7724
  memcpy(buf, sd->stampname, (unsigned long )len);
  }
#line 7726
  if (! sd->processed) {
    {
#line 7728
    memcpy(buf + len, ".dat\324U", (unsigned long )5);
#line 7729
    ratio = loadinfo((char const   *)buf, sd);
    }
  } else {
#line 7748
    ratio = 1.;
  }
#line 7751
  if (! sd->stxt) {
#line 7751
    if (! sd->no_txt) {
      {
#line 7754
      memcpy(buf + len, ".png\324U", (unsigned long )5);
#line 7755
      sd->stxt = loaddesc((char const   *)buf, & sd->locale_text);
#line 7756
      sd->no_txt = (unsigned int )(! sd->stxt);
      }
    }
  }
#line 7761
  if (! sd->ssnd) {
#line 7761
    if (! sd->no_sound) {
#line 7761
      if (use_sound) {
        {
#line 7764
        memcpy(buf + len, ".png\324U", (unsigned long )5);
#line 7765
        sd->ssnd = loadsound((char const   *)buf);
#line 7766
        sd->no_sound = (unsigned int )(! sd->ssnd);
        }
      }
    }
  }
#line 7770
  if (! sd->sdesc) {
#line 7770
    if (! sd->no_descsound) {
#line 7770
      if (use_sound) {
        {
#line 7773
        memcpy(buf + len, ".png", (unsigned long )5);
#line 7774
        sd->sdesc = loaddescsound((char const   *)buf);
#line 7775
        sd->no_descsound = (unsigned int )(! sd->sdesc);
        }
      }
    }
  }
#line 7781
  if (sd->thumbnail) {
#line 7787
    if ((int )sd->thumb_mirrored_flipped == (int )sd->flipped) {
#line 7787
      if ((int )sd->thumb_mirrored_flipped == (int )sd->mirrored) {
#line 7787
        if ((int )sd->mirrored == (int )sd->thumb_mirrored) {
#line 7787
          if ((int )sd->flipped == (int )sd->thumb_flipped) {
#line 7797
            return;
          }
        }
      }
    }
  }
  {
#line 7804
  show_progress_bar(screen);
#line 7806
  need_mirror = (int )sd->mirrored;
#line 7807
  need_flip = (int )sd->flipped;
#line 7808
  bigimg = (SDL_Surface *)((void *)0);
  }
#line 7810
  if ((int )sd->mirrored) {
#line 7810
    if ((int )sd->flipped) {
#line 7816
      if (! sd->no_premirrorflip) {
        {
#line 7818
        memcpy(buf + len, "_mirror_flip.png\251", (unsigned long )17);
#line 7819
        bigimg = do_loadimage((char const   *)buf, 0);
        }
#line 7822
        if (bigimg == (void *)0) {
          {
#line 7824
          memcpy(buf + len, "_mirror_flip.svg\251", (unsigned long )17);
#line 7825
          bigimg = do_loadimage((char const   *)buf, 0);
          }
        }
      }
#line 7830
      if (bigimg) {
#line 7836
        need_mirror = 0;
#line 7837
        need_flip = 0;
      } else {
#line 7844
        sd->no_premirrorflip = (unsigned int )1;
#line 7846
        if (! sd->no_premirror) {
          {
#line 7848
          memcpy(buf + len, "_mirror.pngt\324U", (unsigned long )12);
#line 7849
          bigimg = do_loadimage((char const   *)buf, 0);
          }
#line 7852
          if (bigimg == (void *)0) {
            {
#line 7854
            memcpy(buf + len, "_mirror.svgt\324U", (unsigned long )12);
#line 7855
            bigimg = do_loadimage((char const   *)buf, 0);
            }
          }
        }
#line 7860
        if (bigimg) {
#line 7866
          need_mirror = 0;
        } else {
#line 7874
          if (! sd->no_preflip) {
            {
#line 7876
            memcpy(buf + len, "_flip.png4\213t\324U", (unsigned long )10);
#line 7877
            bigimg = do_loadimage((char const   *)buf, 0);
            }
#line 7880
            if (bigimg == (void *)0) {
              {
#line 7882
              memcpy(buf + len, "_flip.svg\274\213t\324U", (unsigned long )10);
#line 7883
              bigimg = do_loadimage((char const   *)buf, 0);
              }
            }
          }
#line 7888
          if (bigimg) {
#line 7894
            need_flip = 0;
          }
        }
      }
    } else {
#line 7810
      goto _L___139;
    }
  } else
  _L___139: /* CIL Label */ 
#line 7899
  if ((int )sd->mirrored) {
#line 7899
    if (! sd->no_premirror) {
      {
#line 7905
      memcpy(buf + len, "_mirror.png", (unsigned long )12);
#line 7906
      bigimg = do_loadimage((char const   *)buf, 0);
      }
#line 7909
      if (bigimg == (void *)0) {
        {
#line 7911
        memcpy(buf + len, "_mirror.svg", (unsigned long )12);
#line 7912
        bigimg = do_loadimage((char const   *)buf, 0);
        }
      }
#line 7916
      if (bigimg) {
#line 7921
        need_mirror = 0;
      } else {
#line 7928
        sd->no_premirror = (unsigned int )1;
      }
    } else {
#line 7899
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 7931
  if ((int )sd->flipped) {
#line 7931
    if (! sd->no_preflip) {
      {
#line 7937
      memcpy(buf + len, "_flip.png", (unsigned long )10);
#line 7938
      bigimg = do_loadimage((char const   *)buf, 0);
      }
#line 7941
      if (bigimg == (void *)0) {
        {
#line 7943
        memcpy(buf + len, "_flip.svg\'\213t\324U", (unsigned long )10);
#line 7944
        bigimg = do_loadimage((char const   *)buf, 0);
        }
      }
#line 7948
      if (bigimg) {
#line 7953
        need_flip = 0;
      } else {
#line 7960
        sd->no_preflip = (unsigned int )1;
      }
    }
  }
#line 7967
  if (! bigimg) {
    {
#line 7973
    memcpy(buf + len, ".png\324U", (unsigned long )5);
#line 7974
    bigimg = do_loadimage((char const   *)buf, 0);
    }
#line 7977
    if (bigimg == (void *)0) {
      {
#line 7979
      memcpy(buf + len, ".svg\324U", (unsigned long )5);
#line 7980
      bigimg = do_loadimage((char const   *)buf, 0);
      }
    }
  }
#line 7988
  w = (unsigned int )40;
#line 7989
  h = (unsigned int )40;
#line 7990
  ww = (40 * button_h) / 48;
#line 7991
  hh = (40 * button_h) / 48;
#line 7992
  if (bigimg) {
#line 7994
    w = (unsigned int )bigimg->w;
#line 7995
    h = (unsigned int )bigimg->h;
  }
#line 7998
  if (! bigimg) {
    {
#line 7999
    sd->thumbnail = thumbnail(img_dead40x40, ww, hh, 1);
    }
  } else
#line 8000
  if (bigimg->w > 40) {
    {
    {
#line 8002
    sd->thumbnail = thumbnail(bigimg, ww, hh, 1);
    }
    {
#line 8003
    SDL_FreeSurface(bigimg);
    }
    }
  } else
#line 8000
  if (bigimg->h > 40) {
    {
    {
#line 8002
    sd->thumbnail = thumbnail(bigimg, ww, hh, 1);
    }
    {
#line 8003
    SDL_FreeSurface(bigimg);
    }
    }
  } else {
#line 8006
    sd->thumbnail = bigimg;
  }
#line 8011
  if (need_mirror) {
    {
#line 8016
    sd->thumbnail = mirror_surface(sd->thumbnail);
    }
  }
#line 8019
  if (need_flip) {
    {
#line 8024
    sd->thumbnail = flip_surface(sd->thumbnail);
    }
  }
#line 8031
  if ((int )sd->mirrored) {
#line 8031
    if ((int )sd->flipped) {
#line 8032
      sd->thumb_mirrored_flipped = (unsigned int )1;
    } else {
#line 8034
      sd->thumb_mirrored_flipped = (unsigned int )0;
    }
  } else {
#line 8034
    sd->thumb_mirrored_flipped = (unsigned int )0;
  }
#line 8036
  sd->thumb_mirrored = sd->mirrored;
#line 8037
  sd->thumb_flipped = sd->flipped;
#line 8046
  if (sd->processed) {
#line 8047
    return;
  }
  {
#line 8049
  sd->processed = (unsigned int )1;
#line 8050
  loadstamp_finisher(sd, w, h, ratio);
  }
  return;
}
}
#line 8064 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void loadstamp_callback(SDL_Surface *screen___0 , char const   *dir , unsigned int dirlen ,
                               tp_ftw_str *files , unsigned int i , char const   *locale ) 
{ 
  unsigned int i___140 ;
  unsigned int slashcount ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  unsigned int __cil_tmp12 ;
  int __cil_tmp13 ;
  unsigned int __cil_tmp14 ;
  char fname[512] ;
  char const   *dotext ;
  char const   *ext ;
  char const   *mirror_ext ;
  char const   *flip_ext ;
  char const   *mirrorflip_ext ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char svgname[512] ;
  FILE *fi ;
  char *__cil_tmp25 ;
  FILE *__cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;

  {
#line 8074
  if (num_stamps[stamp_group] > 0) {
    {
#line 8084
    slashcount = (unsigned int )0;
#line 8086
    __cil_tmp9 = strlen(load_stamp_basedir);
#line 8086
    i___140 = (unsigned int )(__cil_tmp9 + 1UL);
    }
    {
#line 8086
    while (1) {
      while_continue: /* CIL Label */ ;
#line 8086
      if (! ((unsigned long )i___140 < __cil_tmp10)) {
#line 8086
        goto while_break;
      }
#line 8088
      if ((int )*(dir + i___140) == 47) {
#line 8089
        slashcount ++;
      } else
#line 8088
      if ((int )*(dir + i___140) == 92) {
#line 8089
        slashcount ++;
      }
#line 8086
      i___140 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 8092
    if (slashcount <= stamp_group_dir_depth) {
#line 8094
      stamp_group ++;
    }
  }
  {
#line 8111
  qsort(files, (size_t )i, sizeof(*files), & compare_ftw_str);
  }
  {
#line 8112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 8112
    __cil_tmp14 = i;
#line 8112
    i --;
#line 8112
    if (! __cil_tmp14) {
#line 8112
      goto while_break___0;
    }
    {
#line 8117
    ext = ".png";
#line 8118
    mirror_ext = "_mirror.png";
#line 8119
    flip_ext = "_flip.png";
#line 8120
    mirrorflip_ext = "_mirror_flip.png\220";
#line 8121
    __cil_tmp21 = strcasestr((char const   *)(files + i)->str, ext);
#line 8121
    dotext = (char const   *)((char *)__cil_tmp21);
    }
#line 8124
    if (dotext == (void *)0) {
      {
#line 8126
      ext = ".svg";
#line 8127
      mirror_ext = "_mirror.svg";
#line 8128
      flip_ext = "_flip.svg";
#line 8129
      mirrorflip_ext = "_mirror_flip.svg\220";
#line 8130
      __cil_tmp22 = strcasestr((char const   *)(files + i)->str, ext);
#line 8130
      dotext = (char const   *)((char *)__cil_tmp22);
      }
    } else {
      {
#line 8140
      safe_snprintf((char *)svgname, sizeof(svgname), "%s/%s", dir, (files + i)->str);
#line 8141
      __cil_tmp25 = strcasestr((char const   *)((char *)svgname), ".png");
#line 8141
      strcpy(__cil_tmp25, ".svg");
#line 8143
      fi = fopen((char const   *)((char *)svgname), "r");
      }
#line 8144
      if (fi != (void *)0) {
        {
#line 8146
        debug("Found SVG version of ");
#line 8147
        debug((char const   *)(files + i)->str);
#line 8148
        debug("\n");
#line 8150
        fclose(fi);
        }
#line 8151
        goto while_continue___0;
      }
    }
#line 8160
    if (i % 32U == 0U) {
      {
#line 8161
      show_progress_bar(screen___0);
      }
    }
    {
#line 8163
    __cil_tmp30 = strcasestr((char const   *)(files + i)->str, mirrorflip_ext);
    }
    {
#line 8163
    __cil_tmp29 = strcasestr((char const   *)(files + i)->str, flip_ext);
    }
    {
#line 8163
    __cil_tmp28 = strcasestr((char const   *)(files + i)->str, mirror_ext);
    }
    {
#line 8163
    __cil_tmp27 = strcasecmp(dotext, ext);
    }
#line 8163
    if (dotext > (files + i)->str) {
#line 8163
      if (! __cil_tmp27) {
#line 8163
        if (((dotext - (files + i)->str) + 1L) + (long )dirlen < (long )((int )sizeof(fname))) {
#line 8163
          if (! __cil_tmp28) {
#line 8163
            if (! __cil_tmp29) {
#line 8163
              if (! __cil_tmp30) {
                {
#line 8168
                safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dir, (files + i)->str);
                }
#line 8169
                if (num_stamps[stamp_group] == max_stamps[stamp_group]) {
                  {
#line 8171
                  max_stamps[stamp_group] = (max_stamps[stamp_group] * 5) / 4 + 15;
#line 8172
                  stamp_data[stamp_group] = (stamp_type **)realloc(stamp_data[stamp_group],
                                                                   (unsigned long )max_stamps[stamp_group] * sizeof(*(stamp_data[stamp_group])));
                  }
                }
                {
#line 8175
                *(stamp_data[stamp_group] + num_stamps[stamp_group]) = (stamp_type *)calloc((unsigned long )1,
                                                                                            sizeof(*(*(stamp_data[stamp_group] + num_stamps[stamp_group]))));
#line 8177
                (*(stamp_data[stamp_group] + num_stamps[stamp_group]))->stampname = (char *)malloc((unsigned long )((((dotext - (files + i)->str) + 1L) + (long )dirlen) + 1L));
#line 8178
                memcpy((*(stamp_data[stamp_group] + num_stamps[stamp_group]))->stampname,
                       (char *)fname, (unsigned long )(((dotext - (files + i)->str) + 1L) + (long )dirlen));
#line 8180
                *((*(stamp_data[stamp_group] + num_stamps[stamp_group]))->stampname + (((dotext - (files + i)->str) + 1L) + (long )dirlen)) = (char )'\000';
#line 8182
                __cil_tmp34 = strcmp(ext, ".svg");
                }
#line 8182
                if (__cil_tmp34 == 0) {
#line 8184
                  (*(stamp_data[stamp_group] + num_stamps[stamp_group]))->is_svg = (unsigned int )1;
                } else {
#line 8188
                  (*(stamp_data[stamp_group] + num_stamps[stamp_group]))->is_svg = (unsigned int )0;
                }
#line 8191
                (num_stamps[stamp_group]) ++;
              }
            }
          }
        }
      }
    }
    {
#line 8193
    free((files + i)->str);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 8195
  free(files);
  }
  return;
}
}
#line 8201 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_stamp_dir(SDL_Surface *screen___0 , char const   *dir ) 
{ 
  char buf[400] ;
  unsigned int dirlen ;
  unsigned long __cil_tmp5 ;

  {
  {
#line 8204
  __cil_tmp5 = strlen(dir);
#line 8204
  dirlen = (unsigned int )__cil_tmp5;
#line 8206
  memcpy((char *)buf, dir, (unsigned long )dirlen);
#line 8207
  load_stamp_basedir = dir;
#line 8208
  tp_ftw(screen___0, (char *)buf, dirlen, 0, & loadstamp_callback, (char const   *)((void *)0));
  }
  return;
}
}
#line 8214 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_stamps(SDL_Surface *screen___0 ) 
{ 
  char *homedirdir ;
  char *__cil_tmp3 ;
  unsigned int __cil_tmp4 ;

  {
  {
#line 8216
  __cil_tmp3 = get_fname("stamps", 1);
#line 8216
  homedirdir = __cil_tmp3;
#line 8218
  default_stamp_size = compute_default_scale_factor(1.);
#line 8220
  load_stamp_dir(screen___0, (char const   *)homedirdir);
#line 8221
  load_stamp_dir(screen___0, "/usr/local/share/tuxpaint/stamps");
  }
#line 8235
  if (num_stamps[0] == 0) {
    {
#line 8237
    fprintf(stderr, "\nWarning: No stamps found in /usr/local/share/tuxpaint/stamps/\nor %s\n\n",
            homedirdir);
    }
  }
  {
#line 8240
  num_stamp_groups = stamp_group + 1;
#line 8242
  free(homedirdir);
  }
  return;
}
}
#line 8256 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
long fontconfig_thread_done  =    (long )0;
#line 8261 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int generate_fontconfig_cache_spinner(SDL_Surface *screen___0 ) 
{ 
  SDL_Event event ;
  int __cil_tmp3 ;

  {
  {
#line 8265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8265
    if (! (fontconfig_thread_done == 0L)) {
#line 8265
      goto while_break;
    }
    {
#line 8267
    show_progress_bar(screen___0);
#line 8268
    SDL_Flip(screen___0);
#line 8269
    SDL_Delay((Uint32 )20);
    }
    {
#line 8271
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 8271
      __cil_tmp3 = SDL_PollEvent(& event);
      }
#line 8271
      if (! (__cil_tmp3 > 0)) {
#line 8271
        goto while_break___0;
      }
#line 8273
      if ((int )event.type == 12) {
        {
        {
#line 8275
        fprintf(stderr, "Aborting!\n");
        }
        {
#line 8276
        fflush(stdout);
        }
        }
#line 8277
        return (1);
      } else
#line 8273
      if ((int )event.type == 2) {
#line 8273
        if ((unsigned int )event.key.keysym.sym == 27U) {
          {
          {
#line 8275
          fprintf(stderr, "Aborting!\n");
          }
          {
#line 8276
          fflush(stdout);
          }
          }
#line 8277
          return (1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 8281
  return (0);
}
}
#line 8287 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int generate_fontconfig_cache_real(void) 
{ 
  TuxPaint_Font *tmp_font ;
  SDL_Surface *tmp_surf ;
  SDL_Color black ;
  TuxPaint_Font *__cil_tmp4 ;
  SDL_Surface *__cil_tmp5 ;

  {
#line 8291
  black.r = (Uint8 )0;
#line 8291
  black.g = (Uint8 )0;
#line 8291
  black.b = (Uint8 )0;
  {
#line 8291
  black.unused = (Uint8 )0;
#line 8298
  tmp_font = TuxPaint_Font_OpenFont("BitStream Vera", (char const   *)((void *)0),
                                    12);
  }
#line 8300
  if (tmp_font != (void *)0) {
    {
#line 8306
    tmp_surf = render_text(tmp_font, "Test", black);
    }
#line 8307
    if (tmp_surf != (void *)0) {
      {
#line 8313
      SDL_FreeSurface(tmp_surf);
      }
    }
    {
#line 8322
    TuxPaint_Font_CloseFont(tmp_font);
    }
  }
#line 8332
  fontconfig_thread_done = (long )1;
#line 8338
  return (0);
}
}
#line 8344 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int generate_fontconfig_cache(void *vp ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 8346
  __cil_tmp2 = generate_fontconfig_cache_real();
  }
#line 8346
  return (__cil_tmp2);
}
}
#line 8355 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void signal_handler(int sig ) 
{ 


  {
#line 8358
  if (sig == 10) {
    _L: /* CIL Label */ 
#line 8360
    autosave_on_quit = 1;
#line 8361
    no_prompt_on_quit = 1;
#line 8362
    if (sig == 10) {
#line 8364
      promptless_save = 2;
    } else {
#line 8368
      promptless_save = 1;
    }
    {
#line 8370
    raise(15);
    }
  } else
#line 8358
  if (sig == 12) {
#line 8358
    goto _L;
  }
  return;
}
}
#line 8379 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *do_render_button_label(char const   *label___0 ) 
{ 
  SDL_Surface *tmp_surf ;
  SDL_Surface *surf ;
  SDL_Color black ;
  TuxPaint_Font *myfont ;
  char *td_str ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *upstr ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;

  {
#line 8382
  black.r = (Uint8 )0;
#line 8382
  black.g = (Uint8 )0;
#line 8382
  black.b = (Uint8 )0;
  {
#line 8382
  black.unused = (Uint8 )0;
#line 8384
  __cil_tmp7 = dcgettext((char const   *)((void *)0), label___0, 5);
#line 8384
  __cil_tmp8 = textdir((char const   *)__cil_tmp7);
#line 8384
  td_str = __cil_tmp8;
#line 8385
  __cil_tmp10 = uppercase((char const   *)td_str);
#line 8385
  upstr = __cil_tmp10;
#line 8387
  free(td_str);
  }
#line 8389
  if (button_w <= 48) {
#line 8390
    myfont = small_font;
  } else
#line 8391
  if (button_w <= 144) {
#line 8392
    myfont = medium_font;
  } else {
#line 8394
    myfont = large_font;
  }
  {
#line 8396
  __cil_tmp11 = dcgettext((char const   *)((void *)0), label___0, 5);
#line 8396
  __cil_tmp12 = strcmp((char const   *)__cil_tmp11, label___0);
  }
#line 8396
  if (need_own_font) {
#line 8396
    if (__cil_tmp12) {
#line 8397
      myfont = locale_font;
    }
  }
  {
#line 8398
  tmp_surf = render_text(myfont, (char const   *)upstr, black);
#line 8399
  free(upstr);
#line 8401
  surf = thumbnail(tmp_surf, 0, 0, 0);
#line 8402
  SDL_FreeSurface(tmp_surf);
  }
#line 8404
  return (surf);
}
}
#line 8410 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void create_button_labels(void) 
{ 
  int i ;
  int j ;
  SDL_Surface *__cil_tmp3 ;
  int __cil_tmp4 ;
  SDL_Surface *__cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;
  int __cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;
  int __cil_tmp11 ;
  SDL_Surface *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;
  SDL_Surface *__cil_tmp15 ;
  SDL_Surface *__cil_tmp16 ;
  SDL_Surface *__cil_tmp17 ;
  SDL_Surface *__cil_tmp18 ;
  SDL_Surface *__cil_tmp19 ;

  {
#line 8415
  i = 0;
  {
#line 8415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8415
    if (! (i < 16)) {
#line 8415
      goto while_break;
    }
    {
#line 8416
    img_tool_names[i] = do_render_button_label(tool_names[i]);
    }
#line 8415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8419
  i = 0;
  {
#line 8419
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 8419
    if (! (i < 16)) {
#line 8419
      goto while_break___0;
    }
#line 8421
    j = 0;
    {
#line 8421
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 8421
      if (! (j < num_magics[i])) {
#line 8421
        goto while_break___1;
      }
      {
#line 8423
      magics[i][j].img_name = do_render_button_label((char const   *)magics[i][j].name);
      }
#line 8421
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 8419
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 8428
  i = 0;
  {
#line 8428
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 8428
    if (! (i < 22)) {
#line 8428
      goto while_break___2;
    }
    {
#line 8429
    img_shape_names[i] = do_render_button_label(shape_names[i]);
    }
#line 8428
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 8432
  i = 0;
  {
#line 8432
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 8432
    if (! (i < 4)) {
#line 8432
      goto while_break___3;
    }
    {
#line 8433
    img_fill_names[i] = do_render_button_label(fill_names[i]);
    }
#line 8432
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 8438
  img_openlabels_open = do_render_button_label("Open");
#line 8441
  img_openlabels_erase = do_render_button_label("EraseU");
#line 8444
  img_openlabels_slideshow = do_render_button_label("Slides");
#line 8447
  img_openlabels_pict_export = do_render_button_label("Export");
#line 8450
  img_openlabels_back = do_render_button_label("Back\324U");
#line 8453
  img_openlabels_play = do_render_button_label("Play\324U");
#line 8456
  img_openlabels_gif_export = do_render_button_label("GIF Export\214t\324U");
#line 8459
  img_openlabels_next = do_render_button_label("Next\324U");
  }
  return;
}
}
#line 8466 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void seticon(void) 
{ 
  int masklen ;
  Uint8 *mask ;
  SDL_Surface *icon ;
  SDL_Surface *__cil_tmp4 ;
  char *__cil_tmp5 ;
  void *__cil_tmp6 ;

  {
  {
#line 8477
  icon = IMG_Load("/usr/local/share/tuxpaint/images/icon.pngU");
  }
#line 8482
  if (icon == (void *)0) {
    {
#line 8484
    __cil_tmp5 = SDL_GetError();
#line 8484
    fprintf(stderr, "\nWarning: I could not load the icon image: %s\nThe Simple DirectMedia error that occurred was:\n%s\n\n\214t\324U",
            "/usr/local/share/tuxpaint/images/icon.pngU", __cil_tmp5);
    }
#line 8488
    return;
  }
  {
#line 8494
  masklen = ((icon->w + 7) / 8) * icon->h;
#line 8495
  mask = (Uint8 *)malloc((unsigned long )masklen * sizeof(Uint8 ));
#line 8496
  memset(mask, 255, (unsigned long )masklen);
#line 8499
  SDL_WM_SetIcon(icon, mask);
#line 8502
  free(mask);
#line 8507
  SDL_FreeSurface(icon);
  }
#line 8512
  if (grab_input) {
    {
#line 8514
    debug("Grabbing input!");
#line 8515
    SDL_WM_GrabInput((SDL_GrabMode )1);
    }
  }
  return;
}
}
#line 8524 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Cursor *get_cursor(unsigned char *bits , unsigned char *mask_bits , unsigned int width ,
                              unsigned int height , unsigned int x , unsigned int y ) 
{ 
  Uint8 b ;
  Uint8 temp_bitmap[128] ;
  Uint8 temp_bitmask[128] ;
  unsigned int i ;
  unsigned int __cil_tmp11 ;
  SDL_Cursor *__cil_tmp12 ;

  {
#line 8532
  if (((width + 7U) / 8U) * height > 128U) {
    {
#line 8534
    fprintf(stderr, "Error: Cursor is too large!\n");
#line 8535
    cleanup();
#line 8536
    exit(1);
    }
  }
#line 8539
  i = (unsigned int )0;
  {
#line 8539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8539
    if (! (i < ((width + 7U) / 8U) * height)) {
#line 8539
      goto while_break;
    }
#line 8541
    b = *(bits + i);
#line 8543
    temp_bitmap[i] = (Uint8 )((((((((((int )b & 1) << 7) | (((int )b & 2) << 5)) | (((int )b & 4) << 3)) | (((int )b & 8) << 1)) | (((int )b & 16) >> 1)) | (((int )b & 32) >> 3)) | (((int )b & 64) >> 5)) | (((int )b & 128) >> 7));
#line 8549
    b = *(mask_bits + i);
#line 8551
    temp_bitmask[i] = (Uint8 )((((((((((int )b & 1) << 7) | (((int )b & 2) << 5)) | (((int )b & 4) << 3)) | (((int )b & 8) << 1)) | (((int )b & 16) >> 1)) | (((int )b & 32) >> 3)) | (((int )b & 64) >> 5)) | (((int )b & 128) >> 7));
#line 8539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8558
  __cil_tmp12 = SDL_CreateCursor((Uint8 *)temp_bitmap, (Uint8 *)temp_bitmask, (int )width,
                                 (int )height, (int )x, (int )y);
  }
#line 8558
  return (__cil_tmp12);
}
}
#line 8564 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *loadimagerb(char const   *fname ) 
{ 
  SDL_Surface *__cil_tmp2 ;
  int w ;
  int h ;
  SDL_Surface *aux_surf ;
  SDL_Surface *aux2_surf ;
  SDL_Surface *__cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;

  {
#line 8567
  if (button_h == 48) {
    {
#line 8568
    __cil_tmp2 = loadimage(fname);
    }
#line 8568
    return (__cil_tmp2);
  }
  {
#line 8575
  aux_surf = loadimage(fname);
  }
#line 8576
  if (aux_surf) {
    {
#line 8578
    w = (aux_surf->w * button_w) / 48;
#line 8579
    h = (aux_surf->h * button_h) / 48;
#line 8580
    aux2_surf = thumbnail(aux_surf, w, h, 0);
    }
  } else {
#line 8583
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 8585
  SDL_FreeSurface(aux_surf);
  }
#line 8586
  return (aux2_surf);
}
}
#line 8593 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *loadimage(char const   *fname ) 
{ 
  SDL_Surface *__cil_tmp2 ;

  {
  {
#line 8595
  __cil_tmp2 = do_loadimage(fname, 1);
  }
#line 8595
  return (__cil_tmp2);
}
}
#line 8603 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *do_loadimage(char const   *fname , int abort_on_error ) 
{ 
  SDL_Surface *s ;
  SDL_Surface *disp_fmt_s ;
  SDL_Surface *__cil_tmp5 ;
  char *__cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 8610
  s = myIMG_Load((char const   *)((char *)fname));
  }
#line 8611
  if (s == (void *)0) {
#line 8613
    if (abort_on_error) {
      {
#line 8615
      __cil_tmp6 = SDL_GetError();
#line 8615
      fprintf(stderr, "\nError: I couldn\'t load a graphics file:\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\215t\324U",
              fname, __cil_tmp6);
#line 8619
      cleanup();
#line 8620
      exit(1);
      }
    } else {
#line 8624
      return ((SDL_Surface *)((void *)0));
    }
  }
  {
#line 8631
  disp_fmt_s = SDL_DisplayFormatAlpha(s);
  }
#line 8632
  if (disp_fmt_s == (void *)0) {
#line 8634
    if (abort_on_error) {
      {
#line 8636
      __cil_tmp8 = SDL_GetError();
#line 8636
      fprintf(stderr, "\nError: I couldn\'t convert a graphics file:\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\nU",
              fname, __cil_tmp8);
#line 8640
      SDL_FreeSurface(s);
#line 8641
      cleanup();
#line 8642
      exit(1);
      }
    } else {
      {
#line 8646
      SDL_FreeSurface(s);
      }
#line 8647
      return ((SDL_Surface *)((void *)0));
    }
  }
  {
#line 8654
  SDL_FreeSurface(s);
  }
#line 8656
  return (disp_fmt_s);
}
}
#line 8664 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_toolbar(void) 
{ 
  int i ;
  int off_y ;
  int max ;
  int most ;
  int tool ;
  SDL_Rect dest ;
  SDL_Surface *button_color ;
  SDL_Surface *button_body ;
  int __cil_tmp9 ;

  {
  {
#line 8669
  most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 8670
  off_y = 0;
#line 8674
  draw_image_title(2, r_ttools);
  }
#line 8679
  if (16 > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 8681
    off_y = img_scroll_up->h;
#line 8682
    max = (most - (int )gd_tools.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 8683
    gd_tools.rows = (Uint8 )(max / (int )gd_tools.cols);
#line 8685
    dest.x = (Sint16 )0;
#line 8686
    dest.y = (Sint16 )r_ttools.h;
#line 8688
    if (tool_scroll > 0) {
      {
#line 8690
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 8694
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 8697
    dest.x = (Sint16 )0;
#line 8698
    dest.y = (Sint16 )(((int )r_ttools.h + off_y) + (((most - (int )gd_tools.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_tools.cols) * button_h);
#line 8702
    if (tool_scroll < (16 - (most - (int )gd_tools.cols)) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 8704
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 8708
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 8713
    off_y = 0;
#line 8714
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 8720
  tool = tool_scroll;
  {
#line 8720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8720
    if (! (tool < tool_scroll + max)) {
#line 8720
      goto while_break;
    }
#line 8722
    i = tool - tool_scroll;
#line 8723
    dest.x = (Sint16 )((i % 2) * button_w);
#line 8724
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttools.h) + off_y);
#line 8727
    if (tool < 16) {
#line 8732
      if (tool_scroll + i == cur_tool) {
#line 8734
        button_body = img_btn_down;
#line 8735
        button_color = img_black;
      } else
#line 8737
      if (tool_avail[tool]) {
#line 8739
        button_body = img_btn_up;
#line 8740
        button_color = img_black;
      } else {
#line 8744
        button_body = img_btn_off;
#line 8745
        button_color = img_grey;
      }
      {
#line 8747
      SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 8748
      SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_tools[tool], (SDL_Rect *)((void *)0));
#line 8749
      SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_tool_names[tool], (SDL_Rect *)((void *)0));
#line 8751
      dest.x = (Sint16 )((i % 2) * button_w + 4);
#line 8752
      dest.y = (Sint16 )((((i / 2) * button_h + (int )r_ttools.h) + 2) + off_y);
#line 8754
      SDL_UpperBlit(img_tools[tool], (SDL_Rect *)((void *)0), screen, & dest);
#line 8757
      dest.x = (Sint16 )(((i % 2) * button_w + (4 * button_w) / 48) + ((40 * button_w) / 48 - (img_tool_names[tool])->w) / 2);
#line 8758
      dest.y = (Sint16 )(((((i / 2) * button_h + (int )r_ttools.h) + (2 * button_w) / 48) + (((44 + button_label_y_nudge) * button_w) / 48 - (img_tool_names[tool])->h)) + off_y);
#line 8760
      SDL_UpperBlit(img_tool_names[tool], (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 8764
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 8720
    tool ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 8774 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_magic(void) 
{ 
  int magic ;
  int i ;
  int max ;
  int off_y ;
  SDL_Rect dest ;
  int most ;
  SDL_Surface *button_color ;
  SDL_Surface *button_body ;
  int __cil_tmp9 ;
  SDL_Surface *button_color___141 ;
  int grp ;
  int cur ;

  {
  {
#line 8782
  draw_image_title(9, r_ttoolopt);
#line 8786
  most = ((buttons_tall * (int )gd_toolopt.cols - (int )gd_toolopt.cols) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) - 2;
  }
#line 8787
  if (disable_magic_controls) {
#line 8788
    most += (int )gd_toolopt.cols;
  }
#line 8790
  if (num_magics[magic_group] > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 8792
    off_y = img_scroll_down->h;
#line 8793
    max = (most - 2) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 8795
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 8796
    dest.y = (Sint16 )r_ttoolopt.h;
#line 8798
    if (magic_scroll[magic_group] > 0) {
      {
#line 8800
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 8804
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 8807
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 8808
    dest.y = (Sint16 )(((int )r_ttoolopt.h + img_scroll_down->h) + ((most - 2) / 2 + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / 2) * button_h);
#line 8810
    if (magic_scroll[magic_group] < (num_magics[magic_group] - (most - 2)) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 8812
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 8816
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 8821
    off_y = 0;
#line 8822
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 8826
  magic = magic_scroll[magic_group];
  {
#line 8826
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8826
    if (! (magic < magic_scroll[magic_group] + max)) {
#line 8826
      goto while_break;
    }
#line 8828
    i = magic - magic_scroll[magic_group];
#line 8830
    dest.x = (Sint16 )((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w));
#line 8831
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 8833
    if (magic < num_magics[magic_group]) {
#line 8835
      if (magic == cur_magic[magic_group]) {
        {
#line 8837
        SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 8841
        SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
      {
#line 8844
      dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) + (i % 2) * button_w) + 4);
#line 8845
      dest.y = (Sint16 )((((i / 2) * button_h + (int )r_ttoolopt.h) + 4) + off_y);
#line 8847
      SDL_UpperBlit(magics[magic_group][magic].img_icon, (SDL_Rect *)((void *)0),
                    screen, & dest);
#line 8850
      dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttoolopt.w) + (i % 2) * button_w) + (4 * button_w) / 48) + ((40 * button_w) / 48 - (magics[magic_group][magic].img_name)->w) / 2);
#line 8851
      dest.y = (Sint16 )(((((i / 2) * button_h + (int )r_ttoolopt.h) + (4 * button_h) / 48) + ((44 * button_h) / 48 - (magics[magic_group][magic].img_name)->h)) + off_y);
#line 8853
      SDL_UpperBlit(magics[magic_group][magic].img_name, (SDL_Rect *)((void *)0),
                    screen, & dest);
      }
    } else {
      {
#line 8857
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 8826
    magic ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 8866
  button_color = img_black;
#line 8867
  button_body = img_btn_nav;
#line 8869
  dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 8870
  dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / 2) * button_h);
#line 8872
  SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 8874
  dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_prev->w) / 2);
#line 8875
  dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / 2) * button_h) + (button_h - img_prev->h) / 2);
#line 8877
  SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_prev, (SDL_Rect *)((void *)0));
#line 8878
  SDL_UpperBlit(img_prev, (SDL_Rect *)((void *)0), screen, & dest);
#line 8882
  button_color = img_black;
#line 8883
  button_body = img_btn_nav;
#line 8885
  dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 8886
  dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
#line 8888
  SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 8890
  dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_next->w) / 2);
#line 8891
  dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_next->h) / 2);
#line 8893
  SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_next, (SDL_Rect *)((void *)0));
#line 8894
  SDL_UpperBlit(img_next, (SDL_Rect *)((void *)0), screen, & dest);
  }
#line 8899
  if (! disable_magic_controls) {
#line 8904
    grp = magic_group;
#line 8905
    cur = cur_magic[magic_group];
#line 8910
    if (magics[grp][cur].mode == 1) {
#line 8912
      button_color___141 = img_btn_down;
    } else
#line 8910
    if (magics[grp][cur].mode == 8) {
#line 8912
      button_color___141 = img_btn_down;
    } else
#line 8910
    if (magics[grp][cur].mode == 4) {
#line 8912
      button_color___141 = img_btn_down;
    } else
#line 8913
    if (magics[grp][cur].avail_modes & 1) {
#line 8915
      button_color___141 = img_btn_up;
    } else
#line 8913
    if (magics[grp][cur].avail_modes & 8) {
#line 8915
      button_color___141 = img_btn_up;
    } else
#line 8913
    if (magics[grp][cur].avail_modes & 4) {
#line 8915
      button_color___141 = img_btn_up;
    } else {
#line 8917
      button_color___141 = img_btn_off;
    }
    {
#line 8919
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 8920
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + ((int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) + 2) / (int )gd_toolopt.cols) * button_h);
#line 8922
    SDL_UpperBlit(button_color___141, (SDL_Rect *)((void *)0), screen, & dest);
#line 8924
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_magic_paint->w) / 2);
#line 8925
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + ((int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) + 2) / (int )gd_toolopt.cols) * button_h) + (button_h - img_magic_paint->h) / 2);
#line 8927
    SDL_UpperBlit(img_magic_paint, (SDL_Rect *)((void *)0), screen, & dest);
    }
#line 8932
    if (magics[grp][cur].mode == 2) {
#line 8933
      button_color___141 = img_btn_down;
    } else
#line 8934
    if (magics[grp][cur].avail_modes & 2) {
#line 8935
      button_color___141 = img_btn_up;
    } else {
#line 8937
      button_color___141 = img_btn_off;
    }
    {
#line 8939
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 8940
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + ((int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) + 2) / (int )gd_toolopt.cols) * button_h);
#line 8942
    SDL_UpperBlit(button_color___141, (SDL_Rect *)((void *)0), screen, & dest);
#line 8944
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_magic_fullscreen->w) / 2);
#line 8945
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + ((int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) + 2) / (int )gd_toolopt.cols) * button_h) + (button_h - img_magic_fullscreen->h) / 2);
#line 8947
    SDL_UpperBlit(img_magic_fullscreen, (SDL_Rect *)((void *)0), screen, & dest);
    }
  }
  return;
}
}
#line 8952 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static unsigned int colors_state  =    (unsigned int )3;
#line 8958 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static unsigned int draw_colors(unsigned int action ) 
{ 
  unsigned int i ;
  SDL_Rect dest ;
  static unsigned int old_color ;
  unsigned int old_colors_state ;
  SDL_Surface *tmp ;
  unsigned int __cil_tmp7 ;

  {
#line 8965
  old_colors_state = colors_state;
#line 8967
  if (action == 2U) {
#line 8968
    colors_state |= (unsigned int )2;
  } else
#line 8967
  if (action == 8U) {
#line 8968
    colors_state |= (unsigned int )2;
  } else
#line 8969
  if (action == 4U) {
#line 8970
    colors_state &= (unsigned int )(~ 2);
  } else
#line 8971
  if (action == 0U) {
#line 8972
    colors_state = (unsigned int )0;
  } else
#line 8973
  if (action == 1U) {
#line 8974
    colors_state = (unsigned int )1;
  } else
#line 8973
  if (action == 16U) {
#line 8974
    colors_state = (unsigned int )1;
  }
#line 8976
  colors_are_selectable = colors_state == 1U;
#line 8978
  if (colors_state & 2U) {
#line 8978
    if (action != 8U) {
#line 8979
      return (old_colors_state);
    }
  }
#line 8981
  if (cur_color == old_color) {
#line 8981
    if (colors_state == old_colors_state) {
#line 8981
      if (action != 8U) {
#line 8981
        if (action != 16U) {
#line 8983
          return (old_colors_state);
        }
      }
    }
  }
#line 8985
  old_color = cur_color;
#line 8987
  i = (unsigned int )0;
  {
#line 8987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8987
    if (! (i < (unsigned int )NUM_COLORS)) {
#line 8987
      goto while_break;
    }
#line 8989
    dest.x = (Sint16 )((unsigned int )r_colors.x + (i % (unsigned int )gd_colors.cols) * (unsigned int )color_button_w);
#line 8990
    dest.y = (Sint16 )((unsigned int )r_colors.y + (i / (unsigned int )gd_colors.cols) * (unsigned int )color_button_h);
#line 8992
    if (colors_state == 1U) {
#line 8992
      tmp = *(img_color_btns + (i + (i == cur_color) * NUM_COLORS));
    } else {
#line 8992
      tmp = img_color_btn_off;
    }
    {
#line 8992
    SDL_UpperBlit(tmp, (SDL_Rect *)((void *)0), screen, & dest);
    }
#line 8987
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9012
  update_screen_rect(& r_colors);
  }
#line 9015
  if (colors_state == old_colors_state) {
#line 9016
    return (old_colors_state);
  }
#line 9019
  if ((int )gd_colors.rows > 1) {
    {
#line 9020
    SDL_FillRect(screen, & r_tcolors, (((255U << 24) | (255U << 16)) | (255U << 8)) | 255U);
    }
  }
#line 9022
  if (colors_state == 1U) {
    {
#line 9024
    SDL_UpperBlit(img_title_large_on, (SDL_Rect *)((void *)0), screen, & r_tcolors);
#line 9026
    dest.x = (Sint16 )((int )r_tcolors.x + ((int )r_tcolors.w - (img_title_names[3])->w) / 2);
#line 9027
    dest.y = (Sint16 )((int )r_tcolors.y + ((int )r_tcolors.h - (img_title_names[3])->h) / 2);
#line 9028
    SDL_UpperBlit(img_title_names[3], (SDL_Rect *)((void *)0), screen, & dest);
    }
  } else {
    {
#line 9032
    SDL_UpperBlit(img_title_large_off, (SDL_Rect *)((void *)0), screen, & r_tcolors);
    }
  }
  {
#line 9035
  update_screen_rect(& r_tcolors);
  }
#line 9037
  return (old_colors_state);
}
}
#line 9045 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_brushes(void) 
{ 
  int i ;
  int off_y ;
  int max ;
  int brush ;
  SDL_Rect src ;
  SDL_Rect dest ;
  int most ;
  int ui_btn_x ;
  int ui_btn_y ;
  int __cil_tmp10 ;
  int tmp ;
  int __cil_tmp12 ;
  int tmp___0 ;
  int tmp___1 ;
  int __cil_tmp15 ;

  {
  {
#line 9052
  draw_image_title(4, r_ttoolopt);
#line 9055
  most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9059
  if (num_brushes > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 9061
    most -= (int )gd_toolopt.cols;
#line 9062
    off_y = img_scroll_up->h;
#line 9063
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 9065
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9066
    dest.y = (Sint16 )r_ttoolopt.h;
#line 9068
    if (brush_scroll > 0) {
      {
#line 9070
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9074
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9077
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9078
    dest.y = (Sint16 )(((int )r_ttoolopt.h + img_scroll_up->h) + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9080
    if (brush_scroll < (num_brushes - most) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 9082
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9086
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 9091
    off_y = 0;
#line 9092
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9098
  brush = brush_scroll;
  {
#line 9098
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9098
    if (! (brush < brush_scroll + max)) {
#line 9098
      goto while_break;
    }
#line 9100
    i = brush - brush_scroll;
#line 9103
    dest.x = (Sint16 )((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w));
#line 9104
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9106
    if (brush == cur_brush) {
      {
#line 9108
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 9110
    if (brush < num_brushes) {
      {
#line 9112
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9116
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9119
    if (brush < num_brushes) {
#line 9123
      if (*(brushes_directional + brush)) {
        {
#line 9124
        __cil_tmp10 = abs(*(brushes_frames + brush));
#line 9124
        src.x = (Sint16 )(((*(img_brushes_thumbs + brush))->w / __cil_tmp10) / 3);
        }
      } else {
#line 9126
        src.x = (Sint16 )0;
      }
#line 9128
      if ((int )*(brushes_directional + brush)) {
#line 9128
        tmp = (*(img_brushes_thumbs + brush))->h / 3;
      } else {
#line 9128
        tmp = 0;
      }
#line 9128
      src.y = (Sint16 )tmp;
#line 9130
      if ((int )*(brushes_directional + brush)) {
#line 9130
        tmp___0 = 3;
      } else {
#line 9130
        tmp___0 = 1;
      }
      {
#line 9130
      __cil_tmp12 = abs(*(brushes_frames + brush));
#line 9130
      src.w = (Uint16 )(((*(img_brushes_thumbs + brush))->w / __cil_tmp12) / tmp___0);
      }
#line 9131
      if ((int )*(brushes_directional + brush)) {
#line 9131
        tmp___1 = 3;
      } else {
#line 9131
        tmp___1 = 1;
      }
      {
#line 9131
      src.h = (Uint16 )((*(img_brushes_thumbs + brush))->h / tmp___1);
#line 9133
      ui_btn_x = (i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9134
      ui_btn_y = ((i / 2) * button_h + (int )r_ttoolopt.h) + off_y;
#line 9136
      dest.x = (Sint16 )(ui_btn_x + ((button_w - (int )src.w) >> 1));
#line 9137
      dest.y = (Sint16 )(ui_btn_y + ((button_h - (int )src.h) >> 1));
#line 9139
      SDL_UpperBlit(*(img_brushes_thumbs + brush), & src, screen, & dest);
      }
#line 9141
      if ((int )*(brushes_directional + brush)) {
        {
#line 9143
        dest.x = (Sint16 )((ui_btn_x + button_w) - img_brush_dir->w);
#line 9144
        dest.y = (Sint16 )((ui_btn_y + button_h) - img_brush_dir->h);
        {
#line 9145
        SDL_UpperBlit(img_brush_dir, (SDL_Rect *)((void *)0), screen, & dest);
        }
        }
      } else
#line 9141
      if ((int )*(brushes_rotate + brush)) {
        {
#line 9143
        dest.x = (Sint16 )((ui_btn_x + button_w) - img_brush_dir->w);
#line 9144
        dest.y = (Sint16 )((ui_btn_y + button_h) - img_brush_dir->h);
        {
#line 9145
        SDL_UpperBlit(img_brush_dir, (SDL_Rect *)((void *)0), screen, & dest);
        }
        }
      }
#line 9147
      if (*(brushes_frames + brush) != 1) {
        {
#line 9149
        dest.x = (Sint16 )ui_btn_x;
#line 9150
        dest.y = (Sint16 )((ui_btn_y + button_h) - img_brush_anim->h);
#line 9151
        SDL_UpperBlit(img_brush_anim, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
    }
#line 9098
    brush ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 9162 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_fonts(void) 
{ 
  int i ;
  int off_y ;
  int max ;
  int font ;
  int most ;
  SDL_Rect dest ;
  SDL_Rect src ;
  SDL_Surface *tmp_surf ;
  SDL_Color black ;
  SDL_Surface *tmp_surf_1 ;
  TuxPaint_Font *__cil_tmp11 ;
  char *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;
  int __cil_tmp15 ;
  SDL_Surface *button_color ;
  SDL_Surface *button_body ;
  int __cil_tmp18 ;

  {
#line 9167
  black.r = (Uint8 )0;
#line 9167
  black.g = (Uint8 )0;
#line 9167
  black.b = (Uint8 )0;
  {
#line 9167
  black.unused = (Uint8 )0;
#line 9170
  draw_image_title(8, r_ttoolopt);
#line 9173
  most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9177
  if (cur_tool == 5) {
#line 9179
    most = ((most - (int )gd_toolopt.cols) - (int )gd_toolopt.cols) - (int )gd_toolopt.cols;
#line 9180
    if (disable_stamp_controls) {
#line 9181
      most = (most + (int )gd_toolopt.cols) + (int )gd_toolopt.cols;
    }
  } else {
#line 9185
    most = (most - (int )gd_toolopt.cols) - (int )gd_toolopt.cols;
#line 9186
    if (disable_stamp_controls) {
#line 9187
      most = (most + (int )gd_toolopt.cols) + (int )gd_toolopt.cols;
    }
  }
#line 9197
  if (num_font_families > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 9199
    off_y = img_scroll_up->h;
#line 9200
    max = (most - (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 9202
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9203
    dest.y = (Sint16 )r_ttoolopt.h;
#line 9205
    if (font_scroll > 0) {
      {
#line 9207
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9211
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9214
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9215
    dest.y = (Sint16 )(((int )r_ttoolopt.h + off_y) + ((most - (int )gd_toolopt.cols) / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9220
    if (font_scroll < (num_font_families - (most - (int )gd_toolopt.cols)) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 9222
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9226
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 9231
    off_y = 0;
#line 9232
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9236
  if (! num_font_families % 2) {
#line 9237
    font_scroll = 0;
  } else {
#line 9239
    font_scroll = 0;
  }
#line 9241
  font = font_scroll;
  {
#line 9241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9241
    if (! (font < font_scroll + max)) {
#line 9241
      goto while_break;
    }
#line 9243
    i = font - font_scroll;
#line 9246
    dest.x = (Sint16 )((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w));
#line 9247
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9249
    if (font == cur_font) {
      {
#line 9251
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 9253
    if (font < num_font_families) {
      {
#line 9255
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9259
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9262
    if (font < num_font_families) {
      {
#line 9267
      __cil_tmp11 = getfonthandle(font);
      }
      {
#line 9267
      __cil_tmp12 = dcgettext((char const   *)((void *)0), "Aa", 5);
#line 9267
      __cil_tmp13 = render_text(__cil_tmp11, (char const   *)__cil_tmp12, black);
#line 9267
      tmp_surf_1 = __cil_tmp13;
      }
#line 9269
      if (tmp_surf_1 == (void *)0) {
        {
#line 9271
        fprintf(stderr, "render_text() returned NULL!\n");
        }
#line 9272
        return;
      }
#line 9275
      if (tmp_surf_1->w > button_w) {
        {
        {
#line 9277
        tmp_surf = thumbnail(tmp_surf_1, button_w, button_h, 1);
        }
        {
#line 9278
        SDL_FreeSurface(tmp_surf_1);
        }
        }
      } else
#line 9275
      if (tmp_surf_1->h > button_h) {
        {
        {
#line 9277
        tmp_surf = thumbnail(tmp_surf_1, button_w, button_h, 1);
        }
        {
#line 9278
        SDL_FreeSurface(tmp_surf_1);
        }
        }
      } else {
#line 9281
        tmp_surf = tmp_surf_1;
      }
#line 9283
      src.x = (Sint16 )((tmp_surf->w - button_w) / 2);
#line 9284
      src.y = (Sint16 )((tmp_surf->h - button_h) / 2);
#line 9285
      src.w = (Uint16 )button_w;
#line 9286
      src.h = (Uint16 )button_h;
#line 9288
      if ((int )src.x < 0) {
#line 9289
        src.x = (Sint16 )0;
      }
#line 9290
      if ((int )src.y < 0) {
#line 9291
        src.y = (Sint16 )0;
      }
#line 9293
      dest.x = (Sint16 )((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w));
#line 9294
      if ((int )src.w > tmp_surf->w) {
#line 9296
        src.w = (Uint16 )tmp_surf->w;
#line 9297
        dest.x = (Sint16 )((int )dest.x + (button_w - tmp_surf->w) / 2);
      }
#line 9301
      dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9302
      if ((int )src.h > tmp_surf->h) {
#line 9304
        src.h = (Uint16 )tmp_surf->h;
#line 9305
        dest.y = (Sint16 )((int )dest.y + (button_h - tmp_surf->h) / 2);
      }
      {
#line 9308
      SDL_UpperBlit(tmp_surf, & src, screen, & dest);
#line 9310
      SDL_FreeSurface(tmp_surf);
      }
    }
#line 9241
    font ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9317
  if (! disable_stamp_controls) {
#line 9322
    if (cur_tool == 5) {
      {
#line 9326
      dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9327
      dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9328
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
#line 9340
      dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9341
      dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
      }
#line 9343
      if (cur_label == 2) {
        {
#line 9344
        SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 9348
        __cil_tmp18 = are_labels();
        }
#line 9348
        if (__cil_tmp18) {
          {
#line 9349
          SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
          }
        } else {
          {
#line 9351
          SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
          }
        }
      }
      {
#line 9355
      dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_label_select->w) / 2);
#line 9356
      dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_label_select->h) / 2);
#line 9358
      SDL_UpperBlit(img_label_select, (SDL_Rect *)((void *)0), screen, & dest);
#line 9359
      most += (int )gd_toolopt.cols;
      }
    }
#line 9364
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9365
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9367
    if (text_state & 1) {
      {
#line 9368
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9370
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
    {
#line 9372
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_bold->w) / 2);
#line 9373
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_bold->h) / 2);
#line 9375
    SDL_UpperBlit(img_bold, (SDL_Rect *)((void *)0), screen, & dest);
#line 9380
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9381
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
    }
#line 9383
    if (text_state & 2) {
      {
#line 9384
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9386
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
    {
#line 9388
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_italic->w) / 2);
#line 9389
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_italic->h) / 2);
#line 9391
    SDL_UpperBlit(img_italic, (SDL_Rect *)((void *)0), screen, & dest);
#line 9393
    most += (int )gd_toolopt.cols;
#line 9398
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9399
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
    }
#line 9401
    if (text_size > 0U) {
#line 9403
      button_color = img_black;
#line 9404
      button_body = img_btn_up;
    } else {
#line 9408
      button_color = img_grey;
#line 9409
      button_body = img_btn_off;
    }
    {
#line 9411
    SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9413
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_shrink->w) / 2);
#line 9414
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_shrink->h) / 2);
#line 9416
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_shrink, (SDL_Rect *)((void *)0));
#line 9417
    SDL_UpperBlit(img_shrink, (SDL_Rect *)((void *)0), screen, & dest);
#line 9422
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9423
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
    }
#line 9425
    if ((unsigned long )text_size < sizeof(text_sizes___1) / sizeof(text_sizes___1[0]) - 1UL) {
#line 9427
      button_color = img_black;
#line 9428
      button_body = img_btn_up;
    } else {
#line 9432
      button_color = img_grey;
#line 9433
      button_body = img_btn_off;
    }
    {
#line 9435
    SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9437
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_grow->w) / 2);
#line 9438
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_grow->h) / 2);
#line 9440
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_grow, (SDL_Rect *)((void *)0));
#line 9441
    SDL_UpperBlit(img_grow, (SDL_Rect *)((void *)0), screen, & dest);
    }
  } else
#line 9445
  if (cur_tool == 5) {
    {
#line 9447
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9448
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9450
    SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
#line 9452
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_label->w) / 2);
#line 9453
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_label->h) / 2);
#line 9455
    SDL_UpperBlit(img_label, (SDL_Rect *)((void *)0), screen, & dest);
#line 9457
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9458
    dest.y = (Sint16 )((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9460
    SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
#line 9462
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_label_select->w) / 2);
#line 9463
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h) + (button_h - img_label_select->h) / 2);
#line 9465
    SDL_UpperBlit(img_label_select, (SDL_Rect *)((void *)0), screen, & dest);
    }
  }
  return;
}
}
#line 9475 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_stamps(void) 
{ 
  int i ;
  int off_y ;
  int max ;
  int stamp ;
  int most ;
  int base_x ;
  int base_y ;
  SDL_Rect dest ;
  SDL_Surface *img ;
  int sizes ;
  int size_at ;
  float x_per ;
  float y_per ;
  int xx ;
  int yy ;
  SDL_Surface *btn ;
  SDL_Surface *blnk ;
  SDL_Surface *button_color ;
  SDL_Surface *button_body ;
  int __cil_tmp20 ;
  double __cil_tmp21 ;
  double __cil_tmp22 ;
  SDL_Surface *__cil_tmp23 ;
  SDL_Surface *__cil_tmp24 ;
  SDL_Surface *__cil_tmp25 ;
  int __cil_tmp26 ;

  {
  {
#line 9490
  draw_image_title(6, r_ttoolopt);
#line 9495
  most = (((buttons_tall * (int )gd_toolopt.cols - (int )gd_toolopt.cols) - (int )gd_toolopt.cols) - (int )gd_toolopt.cols) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9496
  if (disable_stamp_controls) {
#line 9497
    most = (buttons_tall * (int )gd_toolopt.cols - (int )gd_toolopt.cols) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9502
  if (num_stamps[stamp_group] > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 9504
    off_y = img_scroll_up->h;
#line 9505
    max = (most - (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 9507
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9508
    dest.y = (Sint16 )r_ttoolopt.h;
#line 9510
    if (stamp_scroll[stamp_group] > 0) {
      {
#line 9512
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9516
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9520
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9521
    dest.y = (Sint16 )(((int )r_ttoolopt.h + off_y) + ((most + 2) / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9523
    if (! disable_stamp_controls) {
#line 9524
      dest.y = (Sint16 )((int )dest.y - button_h * 2);
    }
#line 9526
    if (stamp_scroll[stamp_group] < (num_stamps[stamp_group] - (most - 2)) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 9528
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9532
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 9537
    off_y = 0;
#line 9538
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9544
  stamp = stamp_scroll[stamp_group];
  {
#line 9544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9544
    if (! (stamp < stamp_scroll[stamp_group] + max)) {
#line 9544
      goto while_break;
    }
#line 9546
    i = stamp - stamp_scroll[stamp_group];
#line 9548
    dest.x = (Sint16 )((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w));
#line 9549
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9551
    if (stamp == cur_stamp[stamp_group]) {
      {
#line 9553
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 9555
    if (stamp < num_stamps[stamp_group]) {
      {
#line 9557
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9561
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9564
    if (stamp < num_stamps[stamp_group]) {
      {
#line 9566
      get_stamp_thumb(*(stamp_data[stamp_group] + stamp));
#line 9567
      img = (*(stamp_data[stamp_group] + stamp))->thumbnail;
#line 9569
      base_x = ((i % 2) * button_w + (WINDOW_WIDTH - (int )r_ttoolopt.w)) + (button_w - img->w) / 2;
#line 9571
      base_y = (((i / 2) * button_h + (int )r_ttoolopt.h) + (button_h - img->h) / 2) + off_y;
#line 9573
      dest.x = (Sint16 )base_x;
#line 9574
      dest.y = (Sint16 )base_y;
#line 9576
      SDL_UpperBlit(img, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9544
    stamp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9586
  button_color = img_black;
#line 9587
  button_body = img_btn_nav;
#line 9589
  dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9590
  dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / 2) * button_h);
#line 9592
  SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9594
  dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_prev->w) / 2);
#line 9595
  dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / 2) * button_h) + (button_h - img_prev->h) / 2);
#line 9597
  SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_prev, (SDL_Rect *)((void *)0));
#line 9598
  SDL_UpperBlit(img_prev, (SDL_Rect *)((void *)0), screen, & dest);
#line 9602
  button_color = img_black;
#line 9603
  button_body = img_btn_nav;
#line 9605
  dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9606
  dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
#line 9608
  SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9610
  dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_next->w) / 2);
#line 9611
  dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_next->h) / 2);
#line 9613
  SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_next, (SDL_Rect *)((void *)0));
#line 9614
  SDL_UpperBlit(img_next, (SDL_Rect *)((void *)0), screen, & dest);
  }
#line 9619
  if (! disable_stamp_controls) {
#line 9623
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9624
    dest.y = (Sint16 )((int )r_ttoolopt.h + (((most + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
#line 9626
    if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->mirrorable) {
#line 9628
      if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->mirrored) {
#line 9630
        button_color = img_black;
#line 9631
        button_body = img_btn_down;
      } else {
#line 9635
        button_color = img_black;
#line 9636
        button_body = img_btn_up;
      }
    } else {
#line 9641
      button_color = img_grey;
#line 9642
      button_body = img_btn_off;
    }
    {
#line 9644
    SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9646
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_mirror->w) / 2);
#line 9647
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (((most + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_mirror->h) / 2);
#line 9649
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_mirror, (SDL_Rect *)((void *)0));
#line 9650
    SDL_UpperBlit(img_mirror, (SDL_Rect *)((void *)0), screen, & dest);
#line 9654
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9655
    dest.y = (Sint16 )((int )r_ttoolopt.h + (((most + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
    }
#line 9657
    if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->flipable) {
#line 9659
      if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->flipped) {
#line 9661
        button_color = img_black;
#line 9662
        button_body = img_btn_down;
      } else {
#line 9666
        button_color = img_black;
#line 9667
        button_body = img_btn_up;
      }
    } else {
#line 9672
      button_color = img_grey;
#line 9673
      button_body = img_btn_off;
    }
    {
#line 9675
    SDL_UpperBlit(button_body, (SDL_Rect *)((void *)0), screen, & dest);
#line 9677
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_flip->w) / 2);
#line 9678
    dest.y = (Sint16 )(((int )r_ttoolopt.h + (((most + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_flip->h) / 2);
#line 9680
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), img_flip, (SDL_Rect *)((void *)0));
#line 9681
    SDL_UpperBlit(img_flip, (SDL_Rect *)((void *)0), screen, & dest);
#line 9733
    sizes = ((int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->max - (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min) + 1;
#line 9734
    size_at = (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size - (int )(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->min;
#line 9736
    x_per = (float )r_ttoolopt.w / (float )sizes;
#line 9737
    y_per = (float )button_h / (float )sizes;
#line 9739
    i = 0;
    }
    {
#line 9739
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 9739
      if (! (i < sizes)) {
#line 9739
        goto while_break___0;
      }
      {
#line 9741
      __cil_tmp21 = ceil((double )x_per);
#line 9741
      xx = (int )__cil_tmp21;
#line 9742
      __cil_tmp22 = ceil((double )(y_per * (float )i));
#line 9742
      yy = (int )__cil_tmp22;
      }
#line 9744
      if (i <= size_at) {
        {
#line 9745
        btn = thumbnail(img_btn_down, xx, yy, 0);
        }
      } else {
        {
#line 9747
        btn = thumbnail(img_btn_up, xx, yy, 0);
        }
      }
      {
#line 9749
      blnk = thumbnail(img_btn_off, xx, button_h - yy, 0);
#line 9753
      dest.x = (Sint16 )((float )(WINDOW_WIDTH - (int )r_ttoolopt.w) + (float )i * x_per);
#line 9754
      dest.y = (Sint16 )((float )((((((most + (int )gd_toolopt.cols) + (int )gd_toolopt.cols) + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) - (float )8 * button_scale);
#line 9755
      SDL_UpperBlit(blnk, (SDL_Rect *)((void *)0), screen, & dest);
#line 9757
      dest.x = (Sint16 )((float )(WINDOW_WIDTH - (int )r_ttoolopt.w) + (float )i * x_per);
#line 9758
      dest.y = (Sint16 )(((float )(((((((most + (int )gd_toolopt.cols) + (int )gd_toolopt.cols) + (int )gd_toolopt.cols) + (int )gd_toolopt.cols) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) - (float )8 * button_scale) - y_per * (float )i);
#line 9759
      SDL_UpperBlit(btn, (SDL_Rect *)((void *)0), screen, & dest);
#line 9761
      SDL_FreeSurface(btn);
#line 9762
      SDL_FreeSurface(blnk);
      }
#line 9739
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 9767
  redraw_tux_text();
  }
  return;
}
}
#line 9775 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_shapes(void) 
{ 
  int i ;
  int shape ;
  int max ;
  int off_y ;
  int most ;
  SDL_Rect dest ;
  int __cil_tmp7 ;
  SDL_Surface *button_color ;

  {
  {
#line 9781
  draw_image_title(7, r_ttoolopt);
  }
#line 9783
  if (disable_shape_controls) {
#line 9784
    most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  } else {
#line 9786
    most = (buttons_tall * (int )gd_toolopt.cols - (int )gd_toolopt.cols) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9788
  if (22 > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 9790
    off_y = img_scroll_up->h;
#line 9791
    max = (most - 2) + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
#line 9793
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9794
    dest.y = (Sint16 )r_ttoolopt.h;
#line 9796
    if (shape_scroll > 0) {
      {
#line 9798
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9802
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9805
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9806
    dest.y = (Sint16 )(((int )r_ttoolopt.h + img_scroll_up->h) + ((most - 2) / 2 + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / 2) * button_h);
#line 9808
    if (shape_scroll < (22 - (most - 2)) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 9810
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9814
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 9819
    off_y = 0;
#line 9820
    max = most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9823
  shape = shape_scroll;
  {
#line 9823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9823
    if (! (shape < shape_scroll + max)) {
#line 9823
      goto while_break;
    }
#line 9825
    i = shape - shape_scroll;
#line 9827
    dest.x = (Sint16 )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 9828
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9830
    if (shape == cur_shape) {
      {
#line 9832
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 9834
    if (shape < 22) {
      {
#line 9836
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9840
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9844
    if (shape < 22) {
      {
#line 9846
      dest.x = (Sint16 )((((i % 2) * button_w + (4 * button_w) / 48) + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 9847
      dest.y = (Sint16 )((((i / 2) * button_h + (int )r_ttoolopt.h) + (4 * button_h) / 48) + off_y);
#line 9849
      SDL_UpperBlit(img_shapes[shape], (SDL_Rect *)((void *)0), screen, & dest);
#line 9851
      dest.x = (Sint16 )(((((i % 2) * button_w + (4 * button_w) / 48) + WINDOW_WIDTH) - (int )r_ttoolopt.w) + ((40 * button_w) / 48 - (img_shape_names[shape])->w) / 2);
#line 9852
      dest.y = (Sint16 )(((((i / 2) * button_h + (int )r_ttoolopt.h) + (4 * button_h) / 48) + ((44 * button_h) / 48 - (img_shape_names[shape])->h)) + off_y);
#line 9854
      SDL_UpperBlit(img_shape_names[shape], (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9823
    shape ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 9860
  if (! disable_shape_controls) {
#line 9866
    if (shape_mode == 0) {
#line 9867
      button_color = img_btn_down;
    } else {
#line 9869
      button_color = img_btn_up;
    }
    {
#line 9871
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9872
    dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
#line 9874
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), screen, & dest);
#line 9876
    dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) + (button_w - img_shapes_center->w) / 2);
#line 9877
    dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_shapes_center->h) / 2);
#line 9879
    SDL_UpperBlit(img_shapes_center, (SDL_Rect *)((void *)0), screen, & dest);
    }
#line 9884
    if (shape_mode == 1) {
#line 9885
      button_color = img_btn_down;
    } else {
#line 9887
      button_color = img_btn_up;
    }
    {
#line 9889
    dest.x = (Sint16 )(WINDOW_WIDTH - button_w);
#line 9890
    dest.y = (Sint16 )((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h);
#line 9892
    SDL_UpperBlit(button_color, (SDL_Rect *)((void *)0), screen, & dest);
#line 9894
    dest.x = (Sint16 )((WINDOW_WIDTH - button_w) + (button_w - img_shapes_corner->w) / 2);
#line 9895
    dest.y = (Sint16 )(((int )r_ttoolopt.h + ((most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) / (int )gd_toolopt.cols) * button_h) + (button_h - img_shapes_corner->h) / 2);
#line 9897
    SDL_UpperBlit(img_shapes_corner, (SDL_Rect *)((void *)0), screen, & dest);
    }
  }
  return;
}
}
#line 9906 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_erasers(void) 
{ 
  int i ;
  int j ;
  int x ;
  int y ;
  int sz ;
  int xx ;
  int yy ;
  int n ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  SDL_Rect dest ;
  int most ;
  int off_y ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
  {
#line 9914
  putpixel = putpixels[(screen->format)->BytesPerPixel];
#line 9916
  draw_image_title(5, r_ttoolopt);
#line 9919
  most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 9923
  if (4 > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 9925
    most -= (int )gd_toolopt.cols;
#line 9926
    off_y = img_scroll_up->h;
#line 9928
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9929
    dest.y = (Sint16 )r_ttoolopt.h;
#line 9931
    if (eraser_scroll > 0) {
      {
#line 9933
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9937
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9940
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 9941
    dest.y = (Sint16 )(((int )r_ttoolopt.h + img_scroll_up->h) + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 9943
    if (eraser_scroll < (16 - most) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 9945
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9949
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 9954
    off_y = 0;
  }
#line 9957
  j = 0;
  {
#line 9957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9957
    if (! (j < most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)))) {
#line 9957
      goto while_break;
    }
#line 9959
    i = j;
#line 9960
    dest.x = (Sint16 )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 9961
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 9963
    i = j + eraser_scroll;
#line 9965
    if (i == cur_eraser) {
      {
#line 9967
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 9969
    if (i < 16) {
      {
#line 9971
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 9975
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 9978
    if (i < 16) {
#line 9980
      if (i < 8) {
        {
#line 9984
        sz = (int )((float )(2 + (7 - i) * 5) * button_scale);
#line 9986
        x = (int )(((float )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w) + (float )24 * button_scale) - (float )(sz / 2));
#line 9987
        y = (int )((((float )((j / 2) * button_h + (int )r_ttoolopt.h) + (float )24 * button_scale) - (float )(sz / 2)) + (float )off_y);
#line 9989
        dest.x = (Sint16 )x;
#line 9990
        dest.y = (Sint16 )y;
#line 9991
        dest.w = (Uint16 )sz;
#line 9992
        dest.h = (Uint16 )2;
#line 9994
        SDL_FillRect(screen, & dest, 0U);
#line 9996
        dest.x = (Sint16 )x;
#line 9997
        dest.y = (Sint16 )((y + sz) - 2);
#line 9998
        dest.w = (Uint16 )sz;
#line 9999
        dest.h = (Uint16 )2;
#line 10001
        SDL_FillRect(screen, & dest, 0U);
#line 10003
        dest.x = (Sint16 )x;
#line 10004
        dest.y = (Sint16 )y;
#line 10005
        dest.w = (Uint16 )2;
#line 10006
        dest.h = (Uint16 )sz;
#line 10008
        SDL_FillRect(screen, & dest, 0U);
#line 10010
        dest.x = (Sint16 )((x + sz) - 2);
#line 10011
        dest.y = (Sint16 )y;
#line 10012
        dest.w = (Uint16 )2;
#line 10013
        dest.h = (Uint16 )sz;
#line 10015
        SDL_FillRect(screen, & dest, 0U);
        }
      } else {
#line 10021
        sz = (int )((float )(2 + (7 - (i - 8)) * 5) * button_scale);
#line 10023
        x = (int )(((float )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w) + (float )24 * button_scale) - (float )(sz / 2));
#line 10024
        y = (int )(((((float )((j / 2) * button_h) + (float )40 * button_scale) + (float )24 * button_scale) - (float )(sz / 2)) + (float )off_y);
#line 10026
        yy = 0;
        {
#line 10026
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 10026
          if (! (yy <= sz)) {
#line 10026
            goto while_break___0;
          }
#line 10028
          xx = 0;
          {
#line 10028
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 10028
            if (! (xx <= sz)) {
#line 10028
              goto while_break___1;
            }
#line 10030
            n = (xx * xx + yy * yy) - (sz / 2) * (sz / 2);
#line 10032
            if (n >= - sz) {
#line 10032
              if (n <= sz) {
                {
#line 10034
                (*putpixel)(screen, (x + sz / 2) + xx, (y + sz / 2) + yy, 0U);
#line 10036
                (*putpixel)(screen, (x + sz / 2) - xx, (y + sz / 2) + yy, 0U);
#line 10038
                (*putpixel)(screen, (x + sz / 2) + xx, (y + sz / 2) - yy, 0U);
#line 10040
                (*putpixel)(screen, (x + sz / 2) - xx, (y + sz / 2) - yy, 0U);
                }
              }
            }
#line 10028
            xx ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 10026
          yy ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 9957
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 10055 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_none(void) 
{ 
  int i ;
  SDL_Rect dest ;
  int __cil_tmp3 ;

  {
  {
#line 10060
  dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 10061
  dest.y = (Sint16 )0;
#line 10062
  SDL_UpperBlit(img_title_off, (SDL_Rect *)((void *)0), screen, & dest);
#line 10064
  i = 0;
  }
  {
#line 10064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10064
    if (! (i < buttons_tall * (int )gd_toolopt.cols)) {
#line 10064
      goto while_break;
    }
    {
#line 10066
    dest.x = (Sint16 )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 10067
    dest.y = (Sint16 )((i / 2) * button_h + (int )r_ttoolopt.h);
#line 10069
    SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
    }
#line 10064
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 10074 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_fills(void) 
{ 
  int i ;
  int j ;
  SDL_Rect dest ;
  int most ;
  int off_y ;
  int __cil_tmp6 ;

  {
  {
#line 10080
  draw_image_title(10, r_ttoolopt);
#line 10083
  most = buttons_tall * (int )gd_toolopt.cols - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2));
  }
#line 10088
  if (4 > most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
#line 10090
    most -= (int )gd_toolopt.cols;
#line 10091
    off_y = img_scroll_up->h;
#line 10093
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 10094
    dest.y = (Sint16 )r_ttoolopt.h;
#line 10096
    if (fill_scroll > 0) {
      {
#line 10098
      SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 10102
      SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 10105
    dest.x = (Sint16 )(WINDOW_WIDTH - (int )r_ttoolopt.w);
#line 10106
    dest.y = (Sint16 )(((int )r_ttoolopt.h + img_scroll_up->h) + (most / (int )gd_toolopt.cols + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)) / (int )gd_toolopt.cols) * button_h);
#line 10108
    if (fill_scroll < (4 - most) - (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2))) {
      {
#line 10110
      SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 10114
      SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
  } else {
#line 10119
    off_y = 0;
  }
#line 10122
  j = 0;
  {
#line 10122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10122
    if (! (j < most + (int )((Sint16 )(((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / button_h) * 2)))) {
#line 10122
      goto while_break;
    }
#line 10124
    i = j;
#line 10125
    dest.x = (Sint16 )(((i % 2) * button_w + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 10126
    dest.y = (Sint16 )(((i / 2) * button_h + (int )r_ttoolopt.h) + off_y);
#line 10128
    i = j + fill_scroll;
#line 10130
    if (i == cur_fill) {
      {
#line 10132
      SDL_UpperBlit(img_btn_down, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else
#line 10134
    if (i < 4) {
      {
#line 10136
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
      }
    } else {
      {
#line 10140
      SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 10143
    if (i < 4) {
      {
#line 10145
      dest.x = (Sint16 )((((i % 2) * button_w + (4 * button_w) / 48) + WINDOW_WIDTH) - (int )r_ttoolopt.w);
#line 10146
      dest.y = (Sint16 )((((i / 2) * button_h + (int )r_ttoolopt.h) + (4 * button_h) / 48) + off_y);
#line 10148
      SDL_UpperBlit(img_fills[i], (SDL_Rect *)((void *)0), screen, & dest);
#line 10150
      dest.x = (Sint16 )(((((i % 2) * button_w + (4 * button_w) / 48) + WINDOW_WIDTH) - (int )r_ttoolopt.w) + ((40 * button_w) / 48 - (img_fill_names[i])->w) / 2);
#line 10151
      dest.y = (Sint16 )(((((i / 2) * button_h + (int )r_ttoolopt.h) + (4 * button_h) / 48) + ((44 * button_h) / 48 - (img_fill_names[i])->h)) + off_y);
#line 10153
      SDL_UpperBlit(img_fill_names[i], (SDL_Rect *)((void *)0), screen, & dest);
      }
    }
#line 10122
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 10163 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *thumbnail(SDL_Surface *src , int max_x , int max_y , int keep_aspect ) 
{ 
  SDL_Surface *__cil_tmp5 ;

  {
  {
#line 10165
  __cil_tmp5 = thumbnail2(src, max_x, max_y, keep_aspect, 1);
  }
#line 10165
  return (__cil_tmp5);
}
}
#line 10171 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *thumbnail2(SDL_Surface *src , int max_x , int max_y , int keep_aspect ,
                               int keep_alpha ) 
{ 
  int x ;
  int y ;
  float src_x ;
  float src_y ;
  float off_x ;
  float off_y ;
  SDL_Surface *s ;
  float tr ;
  float tg ;
  float tb ;
  float ta ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  float xscale ;
  float yscale ;
  int tmp ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  SDL_Surface *__cil_tmp26 ;
  SDL_Surface *__cil_tmp27 ;
  char *__cil_tmp28 ;
  int __cil_tmp29 ;
  float __cil_tmp30 ;
  float __cil_tmp31 ;
  unsigned char __cil_tmp32 ;
  unsigned char __cil_tmp33 ;
  unsigned char __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;

  {
#line 10187
  getpixel = getpixels[(src->format)->BytesPerPixel];
#line 10191
  if (! keep_aspect) {
#line 10193
    yscale = (float )((float )src->h / (float )max_y);
#line 10194
    xscale = (float )((float )src->w / (float )max_x);
#line 10196
    off_x = (float )0;
#line 10197
    off_y = (float )0;
  } else
#line 10201
  if (src->h > src->w) {
#line 10203
    yscale = (float )((float )src->h / (float )max_y);
#line 10204
    xscale = yscale;
#line 10206
    off_x = ((float )(src->h - src->w) / xscale) / (float )2;
#line 10207
    off_y = (float )0;
  } else {
#line 10211
    xscale = (float )((float )src->w / (float )max_x);
#line 10212
    yscale = xscale;
#line 10214
    off_x = (float )0;
#line 10215
    off_y = ((float )(src->w - src->h) / xscale) / (float )2;
  }
#line 10221
  if (max_x > src->w) {
#line 10221
    if (max_y > src->h) {
      {
#line 10222
      __cil_tmp26 = zoom(src, max_x, max_y);
      }
#line 10222
      return (__cil_tmp26);
    }
  }
  {
#line 10228
  s = SDL_CreateRGBSurface(src->flags, max_x, max_y, (int )(src->format)->BitsPerPixel,
                           (src->format)->Rmask, (src->format)->Gmask, (src->format)->Bmask,
                           (src->format)->Amask);
  }
#line 10233
  if (s == (void *)0) {
    {
#line 10235
    __cil_tmp28 = SDL_GetError();
#line 10235
    fprintf(stderr, "\nError: Can\'t build stamp thumbnails\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
            __cil_tmp28);
#line 10238
    cleanup();
#line 10239
    exit(1);
    }
  }
  {
#line 10242
  putpixel = putpixels[(s->format)->BytesPerPixel];
#line 10246
  SDL_LockSurface(src);
#line 10247
  SDL_LockSurface(s);
#line 10249
  y = 0;
  }
  {
#line 10249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10249
    if (! (y < max_y)) {
#line 10249
      goto while_break;
    }
#line 10251
    x = 0;
    {
#line 10251
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10251
      if (! (x < max_x)) {
#line 10251
        goto while_break___0;
      }
#line 10254
      tr = (float )0;
#line 10255
      tg = (float )0;
#line 10256
      tb = (float )0;
#line 10257
      ta = (float )0;
#line 10259
      tmp = 0;
#line 10261
      src_y = (float )y * yscale;
      {
#line 10261
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 10261
        if (! (src_y < (float )y * yscale + yscale && src_y < (float )src->h)) {
#line 10261
          goto while_break___1;
        }
#line 10263
        src_x = (float )x * xscale;
        {
#line 10263
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 10263
          if (! (src_x < (float )x * xscale + xscale && src_x < (float )src->w)) {
#line 10263
            goto while_break___2;
          }
#line 10270
          tr += sRGB_to_linear_table___1[r];
#line 10271
          tg += sRGB_to_linear_table___1[g];
#line 10272
          tb += sRGB_to_linear_table___1[b];
#line 10278
          ta += (float )((int )a);
#line 10280
          tmp ++;
#line 10263
          src_x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 10261
        src_y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 10284
      if (tmp != 0) {
        {
#line 10286
        tr /= (float )tmp;
#line 10287
        tb /= (float )tmp;
#line 10288
        tg /= (float )tmp;
#line 10289
        ta /= (float )tmp;
#line 10292
        __cil_tmp32 = linear_to_sRGB(tr);
#line 10292
        tr = (float )__cil_tmp32;
#line 10293
        __cil_tmp33 = linear_to_sRGB(tg);
#line 10293
        tg = (float )__cil_tmp33;
#line 10294
        __cil_tmp34 = linear_to_sRGB(tb);
#line 10294
        tb = (float )__cil_tmp34;
        }
#line 10297
        if (keep_alpha == 0) {
#line 10297
          if ((s->format)->Amask != 0U) {
            {
#line 10299
            tr = (ta * tr) / (float )255 + ((float )255 - ta);
#line 10300
            tg = (ta * tg) / (float )255 + ((float )255 - ta);
#line 10301
            tb = (ta * tb) / (float )255 + ((float )255 - ta);
#line 10303
            (*putpixel)(s, (int )((float )x + off_x), (int )((float )y + off_y), (((255U << 24) | (((unsigned int )((Uint8 )tr) & 255U) << 16)) | (((unsigned int )((Uint8 )tg) & 255U) << 8)) | ((unsigned int )((Uint8 )tb) & 255U));
            }
          } else {
            {
            {
#line 10307
            (*putpixel)(s, (int )((float )x + off_x), (int )((float )y + off_y), (((((unsigned int )((Uint8 )ta) & 255U) << 24) | (((unsigned int )((Uint8 )tr) & 255U) << 16)) | (((unsigned int )((Uint8 )tg) & 255U) << 8)) | ((unsigned int )((Uint8 )tb) & 255U));
            }
            }
          }
        } else {
          {
          {
#line 10307
          (*putpixel)(s, (int )((float )x + off_x), (int )((float )y + off_y), (((((unsigned int )((Uint8 )ta) & 255U) << 24) | (((unsigned int )((Uint8 )tr) & 255U) << 16)) | (((unsigned int )((Uint8 )tg) & 255U) << 8)) | ((unsigned int )((Uint8 )tb) & 255U));
          }
          }
        }
      }
#line 10251
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10249
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10320
  SDL_UnlockSurface(s);
#line 10321
  SDL_UnlockSurface(src);
  }
#line 10323
  return (s);
}
}
#line 10334 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *zoom(SDL_Surface *src , int new_w , int new_h ) 
{ 
  SDL_Surface *s ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  float xscale ;
  float yscale ;
  int x ;
  int y ;
  float floor_x ;
  float ceil_x ;
  float floor_y ;
  float ceil_y ;
  float fraction_x ;
  float fraction_y ;
  float one_minus_x ;
  float one_minus_y ;
  float n1 ;
  float n2 ;
  float r1 ;
  float g1 ;
  float b1 ;
  float a1 ;
  float r2 ;
  float g2 ;
  float b2 ;
  float a2 ;
  float r3 ;
  float g3 ;
  float b3 ;
  float a3 ;
  float r4 ;
  float g4 ;
  float b4 ;
  float a4 ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  SDL_Surface *__cil_tmp41 ;
  char *__cil_tmp42 ;
  double __cil_tmp43 ;
  double __cil_tmp44 ;
  Uint8 r___142 ;
  Uint8 g___143 ;
  Uint8 b___144 ;
  Uint8 a___145 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;

  {
  {
#line 10339
  getpixel = getpixels[(src->format)->BytesPerPixel];
#line 10353
  s = SDL_CreateRGBSurface(src->flags, new_w, new_h, (int )(src->format)->BitsPerPixel,
                           (src->format)->Rmask, (src->format)->Gmask, (src->format)->Bmask,
                           (src->format)->Amask);
  }
#line 10358
  if (s == (void *)0) {
    {
#line 10360
    __cil_tmp42 = SDL_GetError();
#line 10360
    fprintf(stderr, "\nError: Can\'t build zoom surface\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
            __cil_tmp42);
#line 10363
    cleanup();
#line 10364
    exit(1);
    }
  }
  {
#line 10367
  putpixel = putpixels[(s->format)->BytesPerPixel];
#line 10370
  SDL_LockSurface(src);
#line 10371
  SDL_LockSurface(s);
#line 10373
  xscale = (float )src->w / (float )new_w;
#line 10374
  yscale = (float )src->h / (float )new_h;
#line 10376
  x = 0;
  }
  {
#line 10376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10376
    if (! (x < new_w)) {
#line 10376
      goto while_break;
    }
#line 10378
    y = 0;
    {
#line 10378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10378
      if (! (y < new_h)) {
#line 10378
        goto while_break___0;
      }
      {
#line 10380
      __cil_tmp43 = floor((double )((float )x * xscale));
#line 10380
      floor_x = (float )__cil_tmp43;
#line 10381
      ceil_x = floor_x + (float )1;
      }
#line 10382
      if (ceil_x >= (float )src->w) {
#line 10383
        ceil_x = floor_x;
      }
      {
#line 10385
      __cil_tmp44 = floor((double )((float )y * yscale));
#line 10385
      floor_y = (float )__cil_tmp44;
#line 10386
      ceil_y = floor_y + (float )1;
      }
#line 10387
      if (ceil_y >= (float )src->h) {
#line 10388
        ceil_y = floor_y;
      }
      {
#line 10390
      fraction_x = (float )x * xscale - floor_x;
#line 10391
      fraction_y = (float )y * yscale - floor_y;
#line 10393
      one_minus_x = (float )(1. - (double )fraction_x);
#line 10394
      one_minus_y = (float )(1. - (double )fraction_y);
#line 10401
      r1 = (float )r___142;
#line 10402
      g1 = (float )g___143;
#line 10403
      b1 = (float )b___144;
#line 10404
      a1 = (float )a___145;
#line 10406
      r2 = (float )r___142;
#line 10407
      g2 = (float )g___143;
#line 10408
      b2 = (float )b___144;
#line 10409
      a2 = (float )a___145;
#line 10411
      r3 = (float )r___142;
#line 10412
      g3 = (float )g___143;
#line 10413
      b3 = (float )b___144;
#line 10414
      a3 = (float )a___145;
#line 10416
      r4 = (float )r___142;
#line 10417
      g4 = (float )g___143;
#line 10418
      b4 = (float )b___144;
#line 10419
      a4 = (float )a___145;
#line 10463
      n1 = one_minus_x * r1 + fraction_x * r2;
#line 10464
      n2 = one_minus_x * r3 + fraction_x * r4;
#line 10465
      r = (Uint8 )(one_minus_y * n1 + fraction_y * n2);
#line 10467
      n1 = one_minus_x * g1 + fraction_x * g2;
#line 10468
      n2 = one_minus_x * g3 + fraction_x * g4;
#line 10469
      g = (Uint8 )(one_minus_y * n1 + fraction_y * n2);
#line 10471
      n1 = one_minus_x * b1 + fraction_x * b2;
#line 10472
      n2 = one_minus_x * b3 + fraction_x * b4;
#line 10473
      b = (Uint8 )(one_minus_y * n1 + fraction_y * n2);
#line 10475
      n1 = one_minus_x * a1 + fraction_x * a2;
#line 10476
      n2 = one_minus_x * a3 + fraction_x * a4;
#line 10477
      a = (Uint8 )(one_minus_y * n1 + fraction_y * n2);
#line 10479
      (*putpixel)(s, x, y, (((((unsigned int )a & 255U) << 24) | (((unsigned int )r & 255U) << 16)) | (((unsigned int )g & 255U) << 8)) | ((unsigned int )b & 255U));
      }
#line 10378
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10376
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10483
  SDL_UnlockSurface(s);
#line 10484
  SDL_UnlockSurface(src);
  }
#line 10486
  return (s);
}
}
#line 10494 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void _xorpixel(SDL_Surface *surf , int x , int y ) 
{ 
  Uint8 *p ;
  int BytesPerPixel ;
  long __cil_tmp6 ;

  {
#line 10500
  if (x < 0) {
#line 10501
    return;
  } else
#line 10500
  if (x >= surf->w) {
#line 10501
    return;
  } else
#line 10500
  if (y < 0) {
#line 10501
    return;
  } else
#line 10500
  if (y >= surf->h) {
#line 10501
    return;
  }
  {
#line 10504
  BytesPerPixel = (int )(surf->format)->BytesPerPixel;
#line 10507
  p = (Uint8 *)(((Uint8 *)surf->pixels + y * (int )surf->pitch) + x * BytesPerPixel);
#line 10512
  __cil_tmp6 = __builtin_expect((long )(! (! (BytesPerPixel == 4))), (long )1);
  }
#line 10512
  if (__cil_tmp6) {
#line 10513
    *((Uint32 *)p) ^= 2155905152U;
  } else
#line 10514
  if (BytesPerPixel == 1) {
#line 10515
    *p ^= 128;
  } else
#line 10516
  if (BytesPerPixel == 2) {
#line 10517
    *((Uint16 *)p) ^= 54998;
  } else
#line 10518
  if (BytesPerPixel == 3) {
#line 10520
    *(p + 0) ^= 128;
#line 10521
    *(p + 1) ^= 128;
#line 10522
    *(p + 2) ^= 128;
  }
  return;
}
}
#line 10529 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void xorpixel(int x , int y ) 
{ 


  {
#line 10531
  if ((unsigned int )x >= (unsigned int )canvas->w) {
#line 10532
    return;
  } else
#line 10531
  if ((unsigned int )y >= (unsigned int )canvas->h) {
#line 10532
    return;
  }
  {
#line 10535
  x += (int )r_canvas.x;
#line 10536
  y += (int )r_canvas.y;
#line 10538
  _xorpixel(screen, x, y);
  }
  return;
}
}
#line 10546 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_undo(void) 
{ 
  int wanna_update_toolbar ;
  int __cil_tmp2 ;

  {
#line 10550
  wanna_update_toolbar = 0;
#line 10552
  if (cur_undo != oldest_undo) {
    {
#line 10554
    __cil_tmp2 = cur_undo;
#line 10554
    cur_undo --;
#line 10556
    do_undo_label_node();
    }
#line 10558
    if (cur_undo < 0) {
#line 10559
      cur_undo = 19;
    }
    {
#line 10564
    SDL_UpperBlit(undo_bufs[cur_undo], (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
    }
#line 10567
    if (img_starter != (void *)0) {
#line 10569
      if (undo_starters[cur_undo] == 1) {
        {
#line 10571
        starter_mirrored = ! starter_mirrored;
#line 10572
        mirror_starter();
        }
      } else
#line 10574
      if (undo_starters[cur_undo] == 2) {
        {
#line 10576
        starter_flipped = ! starter_flipped;
#line 10577
        flip_starter();
        }
      }
    }
    {
#line 10581
    update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w, (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)));
    }
#line 10584
    if (cur_undo == oldest_undo) {
#line 10586
      tool_avail[8] = 0;
#line 10587
      wanna_update_toolbar = 1;
    }
#line 10590
    if (tool_avail[9] == 0) {
#line 10592
      tool_avail[9] = 1;
#line 10593
      wanna_update_toolbar = 1;
    }
#line 10596
    if (wanna_update_toolbar) {
      {
#line 10598
      draw_toolbar();
#line 10599
      update_screen_rect(& r_tools);
      }
    }
#line 10602
    been_saved = 0;
  }
  return;
}
}
#line 10615 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_redo(void) 
{ 


  {
#line 10617
  if (cur_undo != newest_undo) {
#line 10619
    if (img_starter != (void *)0) {
#line 10621
      if (undo_starters[cur_undo] == 1) {
        {
#line 10623
        starter_mirrored = ! starter_mirrored;
#line 10624
        mirror_starter();
        }
      } else
#line 10626
      if (undo_starters[cur_undo] == 2) {
        {
#line 10628
        starter_flipped = ! starter_flipped;
#line 10629
        flip_starter();
        }
      }
    }
    {
#line 10633
    cur_undo = (cur_undo + 1) % 20;
#line 10638
    do_redo_label_node();
#line 10639
    SDL_UpperBlit(undo_bufs[cur_undo], (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
#line 10641
    update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w, (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)));
#line 10643
    been_saved = 0;
    }
  }
#line 10651
  if ((cur_undo + 1) % 20 == newest_undo) {
#line 10653
    tool_avail[9] = 0;
  }
  {
#line 10656
  tool_avail[8] = 1;
#line 10658
  draw_toolbar();
#line 10659
  update_screen_rect(& r_tools);
  }
  return;
}
}
#line 10667 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void render_brush(void) 
{ 
  Uint32 amask ;
  int x ;
  int y ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  Uint32 (*getpixel_brush)(SDL_Surface * , int  , int  ) ;
  void (*putpixel_brush)(SDL_Surface * , int  , int  , Uint32  ) ;
  SDL_Surface *__cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int tmp___0 ;

  {
#line 10673
  getpixel_brush = getpixels[((*(img_brushes + cur_brush))->format)->BytesPerPixel];
#line 10674
  putpixel_brush = putpixels[((*(img_brushes + cur_brush))->format)->BytesPerPixel];
#line 10679
  if (cur_brush >= num_brushes) {
#line 10680
    cur_brush = 0;
  }
#line 10685
  if (img_cur_brush != (void *)0) {
    {
#line 10687
    SDL_FreeSurface(img_cur_brush);
    }
  }
  {
#line 10693
  amask = ~ ((((*(img_brushes + cur_brush))->format)->Rmask | ((*(img_brushes + cur_brush))->format)->Gmask) | ((*(img_brushes + cur_brush))->format)->Bmask);
#line 10696
  img_cur_brush = SDL_CreateRGBSurface((Uint32 )0, (*(img_brushes + cur_brush))->w,
                                       (*(img_brushes + cur_brush))->h, (int )((*(img_brushes + cur_brush))->format)->BitsPerPixel,
                                       ((*(img_brushes + cur_brush))->format)->Rmask,
                                       ((*(img_brushes + cur_brush))->format)->Gmask,
                                       ((*(img_brushes + cur_brush))->format)->Bmask,
                                       amask);
  }
#line 10704
  if (img_cur_brush == (void *)0) {
    {
#line 10706
    __cil_tmp11 = SDL_GetError();
#line 10706
    fprintf(stderr, "\nError: Can\'t render a brush!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\230",
            __cil_tmp11);
#line 10709
    cleanup();
#line 10710
    exit(1);
    }
  }
  {
#line 10716
  SDL_LockSurface(*(img_brushes + cur_brush));
#line 10717
  SDL_LockSurface(img_cur_brush);
#line 10719
  y = 0;
  }
  {
#line 10719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10719
    if (! (y < (*(img_brushes + cur_brush))->h)) {
#line 10719
      goto while_break;
    }
#line 10721
    x = 0;
    {
#line 10721
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10721
      if (! (x < (*(img_brushes + cur_brush))->w)) {
#line 10721
        goto while_break___0;
      }
#line 10725
      if ((int )r == (int )g) {
#line 10725
        if ((int )g == (int )b) {
          {
#line 10727
          (*putpixel_brush)(img_cur_brush, x, y, (((((unsigned int )a & 255U) << 24) | (((unsigned int )*(*(color_hexes + cur_color) + 0) & 255U) << 16)) | (((unsigned int )*(*(color_hexes + cur_color) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + cur_color) + 2) & 255U));
          }
        } else {
          {
          {
#line 10734
          (*putpixel_brush)(img_cur_brush, x, y, (((((unsigned int )a & 255U) << 24) | (((unsigned int )(((int )r + (int )*(*(color_hexes + cur_color) + 0)) >> 1) & 255U) << 16)) | (((unsigned int )(((int )g + (int )*(*(color_hexes + cur_color) + 1)) >> 1) & 255U) << 8)) | ((unsigned int )(((int )b + (int )*(*(color_hexes + cur_color) + 2)) >> 1) & 255U));
          }
          }
        }
      } else {
        {
        {
#line 10734
        (*putpixel_brush)(img_cur_brush, x, y, (((((unsigned int )a & 255U) << 24) | (((unsigned int )(((int )r + (int )*(*(color_hexes + cur_color) + 0)) >> 1) & 255U) << 16)) | (((unsigned int )(((int )g + (int )*(*(color_hexes + cur_color) + 1)) >> 1) & 255U) << 8)) | ((unsigned int )(((int )b + (int )*(*(color_hexes + cur_color) + 2)) >> 1) & 255U));
        }
        }
      }
#line 10721
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10719
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10743
  SDL_UnlockSurface(img_cur_brush);
#line 10744
  SDL_UnlockSurface(*(img_brushes + cur_brush));
#line 10746
  __cil_tmp14 = abs(*(brushes_frames + cur_brush));
#line 10746
  img_cur_brush_frame_w = img_cur_brush->w / __cil_tmp14;
  }
#line 10747
  if ((int )*(brushes_directional + cur_brush)) {
#line 10747
    tmp = 3;
  } else {
#line 10747
    tmp = 1;
  }
#line 10747
  img_cur_brush_w = img_cur_brush_frame_w / tmp;
#line 10748
  if ((int )*(brushes_directional + cur_brush)) {
#line 10748
    tmp___0 = 3;
  } else {
#line 10748
    tmp___0 = 1;
  }
#line 10748
  img_cur_brush_h = img_cur_brush->h / tmp___0;
#line 10749
  img_cur_brush_frames = *(brushes_frames + cur_brush);
#line 10750
  img_cur_brush_directional = (int )*(brushes_directional + cur_brush);
#line 10751
  img_cur_brush_rotate = (int )*(brushes_rotate + cur_brush);
#line 10752
  img_cur_brush_spacing = *(brushes_spacing + cur_brush);
#line 10754
  brush_counter = 0;
  return;
}
}
#line 10762 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void line_xor(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  int dx ;
  int dy ;
  int y ;
  int num_drawn ;
  float m ;
  float b ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 10772
  dx = x2 - x1;
#line 10773
  dy = y2 - y1___0;
#line 10775
  num_drawn = 0;
#line 10777
  if (dx != 0) {
#line 10779
    m = (float )dy / (float )dx;
#line 10780
    b = (float )y1___0 - m * (float )x1;
#line 10782
    if (x2 >= x1) {
#line 10783
      dx = 1;
    } else {
#line 10785
      dx = - 1;
    }
    {
#line 10788
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10788
      if (! (x1 != x2)) {
#line 10788
        goto while_break;
      }
#line 10790
      y1___0 = (int )(m * (float )x1 + b);
#line 10791
      y2 = (int )(m * (float )(x1 + dx) + b);
#line 10793
      if (y1___0 > y2) {
#line 10795
        y = y1___0;
#line 10796
        y1___0 = y2;
#line 10797
        y2 = y;
      }
#line 10800
      y = y1___0;
      {
#line 10800
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 10800
        if (! (y <= y2)) {
#line 10800
          goto while_break___0;
        }
#line 10802
        num_drawn ++;
#line 10803
        if (num_drawn < 10) {
          {
          {
#line 10804
          xorpixel(x1, y);
          }
          }
        } else
#line 10803
        if (dont_do_xor == 0) {
          {
          {
#line 10804
          xorpixel(x1, y);
          }
          }
        }
#line 10800
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 10807
      x1 += dx;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 10812
  if (y1___0 > y2) {
#line 10814
    y = y1___0;
    {
#line 10814
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10814
      if (! (y >= y2)) {
#line 10814
        goto while_break___1;
      }
#line 10816
      num_drawn ++;
#line 10818
      if (num_drawn < 10) {
        {
        {
#line 10819
        xorpixel(x1, y);
        }
        }
      } else
#line 10818
      if (dont_do_xor == 0) {
        {
        {
#line 10819
        xorpixel(x1, y);
        }
        }
      }
#line 10814
      __cil_tmp14 = y;
#line 10814
      y --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 10824
    y = y1___0;
    {
#line 10824
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 10824
      if (! (y <= y2)) {
#line 10824
        goto while_break___2;
      }
#line 10826
      num_drawn ++;
#line 10828
      if (num_drawn < 10) {
        {
        {
#line 10829
        xorpixel(x1, y);
        }
        }
      } else
#line 10828
      if (dont_do_xor == 0) {
        {
        {
#line 10829
        xorpixel(x1, y);
        }
        }
      }
#line 10824
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 10842 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void rect_xor(int x1 , int y1___0 , int x2 , int y2 ) 
{ 


  {
#line 10844
  if (x1 < 0) {
#line 10845
    x1 = 0;
  }
#line 10847
  if (x2 < 0) {
#line 10848
    x2 = 0;
  }
#line 10850
  if (y1___0 < 0) {
#line 10851
    y1___0 = 0;
  }
#line 10853
  if (y2 < 0) {
#line 10854
    y2 = 0;
  }
#line 10856
  if (x1 >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) {
#line 10857
    x1 = ((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) - 1;
  }
#line 10859
  if (x2 >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) {
#line 10860
    x2 = ((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) - 1;
  }
#line 10862
  if (y1___0 >= (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h))) {
#line 10863
    y1___0 = ((button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h))) - 1;
  }
#line 10865
  if (y2 >= (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h))) {
#line 10866
    y2 = ((button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h))) - 1;
  }
  {
#line 10868
  line_xor(x1, y1___0, x2, y1___0);
#line 10869
  line_xor(x2, y1___0, x2, y2);
#line 10870
  line_xor(x2, y2, x1, y2);
#line 10871
  line_xor(x1, y2, x1, y1___0);
  }
  return;
}
}
#line 10875 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int calc_eraser_size(int which_eraser ) 
{ 


  {
#line 10878
  if (which_eraser >= 8) {
#line 10879
    which_eraser -= 8;
  }
#line 10881
  return ((7 - which_eraser) * 17 + 5);
}
}
#line 10888 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_eraser(int x , int y , int update ) 
{ 
  SDL_Rect dest ;
  int sz ;
  int xx ;
  int yy ;
  int n ;
  int hit ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;

  {
  {
#line 10894
  sz = calc_eraser_size(cur_eraser);
  }
#line 10896
  if (cur_eraser < 8) {
#line 10900
    dest.x = (Sint16 )(x - sz / 2);
#line 10901
    dest.y = (Sint16 )(y - sz / 2);
#line 10902
    dest.w = (Uint16 )sz;
#line 10903
    dest.h = (Uint16 )sz;
#line 10905
    if (img_starter_bkgd == (void *)0) {
      {
#line 10906
      SDL_FillRect(canvas, & dest, ((((unsigned int )canvas_color_r & 255U) << 16) | (((unsigned int )canvas_color_g & 255U) << 8)) | ((unsigned int )canvas_color_b & 255U));
      }
    } else {
      {
#line 10908
      SDL_UpperBlit(img_starter_bkgd, & dest, canvas, & dest);
      }
    }
  } else {
#line 10914
    yy = 0;
    {
#line 10914
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10914
      if (! (yy <= sz)) {
#line 10914
        goto while_break;
      }
#line 10916
      hit = 0;
#line 10917
      xx = 0;
      {
#line 10917
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 10917
        if (! (xx <= sz && hit == 0)) {
#line 10917
          goto while_break___0;
        }
#line 10919
        n = (xx * xx + yy * yy) - (sz * sz) / 4;
#line 10921
        if (n >= - sz) {
#line 10921
          if (n <= sz) {
#line 10922
            hit = 1;
          }
        }
#line 10924
        if (hit) {
#line 10926
          dest.x = (Sint16 )(x - xx);
#line 10927
          dest.y = (Sint16 )(y - yy);
#line 10928
          dest.w = (Uint16 )(xx * 2);
#line 10929
          dest.h = (Uint16 )1;
#line 10931
          if (img_starter_bkgd == (void *)0) {
            {
#line 10932
            SDL_FillRect(canvas, & dest, ((((unsigned int )canvas_color_r & 255U) << 16) | (((unsigned int )canvas_color_g & 255U) << 8)) | ((unsigned int )canvas_color_b & 255U));
            }
          } else {
            {
#line 10935
            SDL_UpperBlit(img_starter_bkgd, & dest, canvas, & dest);
            }
          }
#line 10938
          dest.x = (Sint16 )(x - xx);
#line 10939
          dest.y = (Sint16 )(y + yy);
#line 10940
          dest.w = (Uint16 )(xx * 2);
#line 10941
          dest.h = (Uint16 )1;
#line 10943
          if (img_starter_bkgd == (void *)0) {
            {
#line 10944
            SDL_FillRect(canvas, & dest, ((((unsigned int )canvas_color_r & 255U) << 16) | (((unsigned int )canvas_color_g & 255U) << 8)) | ((unsigned int )canvas_color_b & 255U));
            }
          } else {
            {
#line 10947
            SDL_UpperBlit(img_starter_bkgd, & dest, canvas, & dest);
            }
          }
        }
#line 10917
        xx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 10914
      yy ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 10955
  if (! mute) {
#line 10955
    if (use_sound) {
      {
#line 10957
      __cil_tmp13 = Mix_Playing(0);
      }
#line 10957
      if (! __cil_tmp13) {
        {
#line 10959
        eraser_sound = (eraser_sound + 1) % 2;
#line 10961
        playsound(screen, 0, 12 + eraser_sound, 0, x, - 999);
        }
      }
    }
  }
#line 10966
  if (update) {
    {
#line 10968
    update_canvas(x - sz / 2, y - sz / 2, x + sz / 2, y + sz / 2);
#line 10970
    rect_xor(x - sz / 2, y - sz / 2, x + sz / 2, y + sz / 2);
    }
  }
  return;
}
}
#line 10987 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void eraser_draw(int x1 , int y1___0 , int x2 , int y2 ) 
{ 
  int dx ;
  int dy ;
  int y ;
  int orig_x1 ;
  int orig_y1 ;
  int orig_x2 ;
  int orig_y2 ;
  int tmp ;
  int length ;
  float m ;
  float b ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;

  {
#line 10993
  orig_x1 = x1;
#line 10994
  orig_y1 = y1___0;
#line 10996
  orig_x2 = x2;
#line 10997
  orig_y2 = y2;
#line 11000
  dx = x2 - x1;
#line 11001
  dy = y2 - y1___0;
#line 11003
  if (dx != 0) {
#line 11005
    m = (float )dy / (float )dx;
#line 11006
    b = (float )y1___0 - m * (float )x1;
#line 11008
    if (x2 >= x1) {
#line 11009
      dx = 1;
    } else {
#line 11011
      dx = - 1;
    }
    {
#line 11014
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11014
      if (! (x1 != x2)) {
#line 11014
        goto while_break;
      }
#line 11016
      y1___0 = (int )(m * (float )x1 + b);
#line 11017
      y2 = (int )(m * (float )(x1 + dx) + b);
#line 11019
      if (y1___0 > y2) {
#line 11021
        y = y1___0;
        {
#line 11021
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 11021
          if (! (y >= y2)) {
#line 11021
            goto while_break___0;
          }
          {
#line 11022
          do_eraser(x1, y, 0);
          }
#line 11021
          __cil_tmp16 = y;
#line 11021
          y --;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 11026
        y = y1___0;
        {
#line 11026
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 11026
          if (! (y <= y2)) {
#line 11026
            goto while_break___1;
          }
          {
#line 11027
          do_eraser(x1, y, 0);
          }
#line 11026
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 11030
      x1 += dx;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 11035
    if (y1___0 > y2) {
#line 11037
      y = y1___0;
#line 11038
      y1___0 = y2;
#line 11039
      y2 = y;
    }
#line 11042
    y = y1___0;
    {
#line 11042
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 11042
      if (! (y <= y2)) {
#line 11042
        goto while_break___2;
      }
      {
#line 11043
      do_eraser(x1, y, 0);
      }
#line 11042
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 11047
  if (orig_x1 > orig_x2) {
#line 11049
    tmp = orig_x1;
#line 11050
    orig_x1 = orig_x2;
#line 11051
    orig_x2 = tmp;
  }
#line 11054
  if (orig_y1 > orig_y2) {
#line 11056
    tmp = orig_y1;
#line 11057
    orig_y1 = orig_y2;
#line 11058
    orig_y2 = tmp;
  }
  {
#line 11061
  __cil_tmp19 = calc_eraser_size(cur_eraser);
#line 11061
  length = (__cil_tmp19 >> 1) + 1;
#line 11062
  update_canvas(orig_x1 - length, orig_y1 - length, orig_x2 + length, orig_y2 + length);
  }
  return;
}
}
#line 11069 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void reset_avail_tools(void) 
{ 
  int i ;
  int disallow_print ;
  int __cil_tmp3 ;

  {
#line 11072
  disallow_print = disable_print;
#line 11074
  i = 0;
  {
#line 11074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11074
    if (! (i < 16)) {
#line 11074
      goto while_break;
    }
#line 11076
    tool_avail[i] = 1;
#line 11074
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11082
  tool_avail[8] = 0;
#line 11083
  tool_avail[9] = 0;
#line 11085
  if (been_saved) {
#line 11086
    tool_avail[13] = 0;
  }
#line 11091
  if (num_stamps[0] == 0) {
#line 11092
    tool_avail[1] = 0;
  }
#line 11094
  if (num_magics_total == 0) {
#line 11095
    tool_avail[7] = 0;
  }
#line 11100
  if (disable_quit) {
#line 11101
    tool_avail[15] = 0;
  }
#line 11106
  if (disable_label) {
#line 11107
    tool_avail[5] = 0;
  }
#line 11112
  if (disable_save) {
#line 11113
    tool_avail[13] = 0;
  }
#line 11129
  if (disallow_print) {
#line 11130
    tool_avail[14] = 0;
  }
  return;
}
}
#line 11145 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void disable_avail_tools(void) 
{ 
  int i ;
  int __cil_tmp2 ;

  {
  {
#line 11149
  hide_blinking_cursor();
#line 11150
  i = 0;
  }
  {
#line 11150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11150
    if (! (i < 16)) {
#line 11150
      goto while_break;
    }
#line 11152
    tool_avail_bak[i] = tool_avail[i];
#line 11153
    tool_avail[i] = 0;
#line 11150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 11161 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void enable_avail_tools(void) 
{ 
  int i ;
  int __cil_tmp2 ;

  {
#line 11165
  i = 0;
  {
#line 11165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11165
    if (! (i < 16)) {
#line 11165
      goto while_break;
    }
#line 11167
    tool_avail[i] = tool_avail_bak[i];
#line 11165
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 11176 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int compare_dirent2s(struct dirent2 *f1 , struct dirent2 *f2 ) 
{ 
  int __cil_tmp3 ;

  {
#line 11182
  if (f1->place == f2->place) {
    {
#line 11183
    __cil_tmp3 = strcmp((char const   *)((char *)f1->f.d_name), (char const   *)((char *)f2->f.d_name));
    }
#line 11183
    return (__cil_tmp3);
  } else {
#line 11185
    return (f1->place - f2->place);
  }
}
}
#line 11193 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_tux_text(int which_tux , char const   *str , int want_right_to_left ) 
{ 


  {
  {
#line 11195
  draw_tux_text_ex(which_tux, str, want_right_to_left, (Uint8 )0);
  }
  return;
}
}
#line 11198
static int latest_tux ;
#line 11199
static char const   *latest_tux_text ;
#line 11200
static int latest_r2l ;
#line 11201
static Uint8 latest_locale_text ;
#line 11206 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void redraw_tux_text(void) 
{ 


  {
  {
#line 11208
  draw_tux_text_ex(latest_tux, latest_tux_text, latest_r2l, latest_locale_text);
  }
  return;
}
}
#line 11214 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_tux_text_ex(int which_tux , char const   *str , int want_right_to_left ,
                             Uint8 locale_text ) 
{ 
  SDL_Rect dest ;
  SDL_Color black ;
  int w ;
  SDL_Surface *btn ;

  {
#line 11217
  black.r = (Uint8 )0;
#line 11217
  black.g = (Uint8 )0;
#line 11217
  black.b = (Uint8 )0;
  {
#line 11217
  black.unused = (Uint8 )0;
#line 11221
  latest_tux = which_tux;
#line 11222
  latest_tux_text = str;
#line 11223
  latest_r2l = want_right_to_left;
#line 11224
  latest_locale_text = locale_text;
#line 11228
  control_drawtext_timer((Uint32 )0, "\251", (Uint8 )0);
#line 11231
  SDL_FillRect(screen, & r_tuxarea, ((255U << 16) | (255U << 8)) | 255U);
#line 11234
  dest.x = r_tuxarea.x;
#line 11235
  dest.y = (Sint16 )(((int )r_tuxarea.y + (int )r_tuxarea.h) - (img_tux[which_tux])->h);
  }
#line 11238
  if ((int )dest.y < (int )r_tuxarea.y) {
#line 11239
    dest.y = r_tuxarea.y;
  }
#line 11242
  if (cur_tool == 1) {
#line 11242
    if (use_sound) {
#line 11242
      if (! mute) {
#line 11244
        if ((int )dest.y < (int )r_sfx.y + (int )r_sfx.h) {
#line 11245
          dest.y = (Sint16 )((int )r_sfx.y + (int )r_sfx.h);
        }
      }
    }
  }
  {
#line 11248
  SDL_UpperBlit(img_tux[which_tux], (SDL_Rect *)((void *)0), screen, & dest);
#line 11251
  w = 5;
#line 11253
  wordwrap_text_ex(str, black, w, (int )r_tuxarea.y, (int )r_tuxarea.w, want_right_to_left,
                   locale_text);
  }
#line 11258
  if (cur_tool == 1) {
#line 11258
    if (use_sound) {
#line 11258
      if (! mute) {
#line 11262
        if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_sound) {
#line 11263
          btn = img_btnsm_off;
        } else {
#line 11265
          btn = img_btnsm_up;
        }
        {
#line 11267
        dest.x = (Sint16 )0;
#line 11268
        dest.y = r_tuxarea.y;
#line 11270
        SDL_UpperBlit(btn, (SDL_Rect *)((void *)0), screen, & dest);
#line 11272
        dest.x = (Sint16 )((img_btnsm_up->w - img_sfx->w) / 2);
#line 11273
        dest.y = (Sint16 )((int )r_tuxarea.y + (img_btnsm_up->h - img_sfx->h) / 2);
#line 11275
        SDL_UpperBlit(img_sfx, (SDL_Rect *)((void *)0), screen, & dest);
        }
#line 11280
        if ((*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->no_descsound) {
#line 11281
          btn = img_btnsm_off;
        } else {
#line 11283
          btn = img_btnsm_up;
        }
        {
#line 11285
        dest.x = (Sint16 )img_btnsm_up->w;
#line 11286
        dest.y = r_tuxarea.y;
#line 11288
        SDL_UpperBlit(btn, (SDL_Rect *)((void *)0), screen, & dest);
#line 11290
        dest.x = (Sint16 )(img_btnsm_up->w + (img_btnsm_up->w - img_speak->w) / 2);
#line 11291
        dest.y = (Sint16 )((int )r_tuxarea.y + (img_btnsm_up->h - img_speak->h) / 2);
#line 11293
        SDL_UpperBlit(img_speak, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
    }
  }
  {
#line 11296
  update_screen_rect(& r_tuxarea);
  }
  return;
}
}
#line 11308 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_cur_tool_tip(void) 
{ 
  int tmp ;

  {
#line 11310
  if (cur_tool == 6) {
    {
#line 11312
    draw_tux_text(tool_tux[cur_tool], fill_tips[cur_fill], 1);
    }
  } else
#line 11314
  if (cur_tool == 3) {
#line 11316
    if (simple_shapes) {
#line 11316
      tmp = 1;
    } else {
#line 11316
      tmp = 0;
    }
    {
#line 11316
    draw_tux_text(tool_tux[cur_tool], shape_tool_tips[tmp], 1);
    }
  } else {
    {
#line 11320
    draw_tux_text(tool_tux[cur_tool], tool_tips[cur_tool], 1);
    }
  }
  return;
}
}
#line 11327 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void wordwrap_text(char const   *str , SDL_Color color , int left , int top ,
                          int right , int want_right_to_left ) 
{ 


  {
  {
#line 11329
  wordwrap_text_ex(str, color, left, top, right, want_right_to_left, (Uint8 )0);
  }
  return;
}
}
#line 11335 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void wordwrap_text_ex(char const   *str , SDL_Color color , int left , int top ,
                             int right , int want_right_to_left , Uint8 locale_text ) 
{ 
  SDL_Surface *text ;
  TuxPaint_Font *myfont ;
  SDL_Rect dest ;
  SDLPango_Matrix pango_color ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *upper_str ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *upper_str___0 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  SDL_Surface *__cil_tmp24 ;

  {
#line 11339
  myfont = medium_font;
#line 11358
  if (str == (void *)0) {
#line 11359
    return;
  } else
#line 11358
  if ((int )*(str + 0) == 0) {
#line 11359
    return;
  }
  {
#line 11361
  __cil_tmp12 = dcgettext((char const   *)((void *)0), str, 5);
#line 11361
  __cil_tmp13 = strcmp((char const   *)__cil_tmp12, str);
  }
#line 11361
  if (need_own_font) {
#line 11361
    if (__cil_tmp13) {
#line 11362
      myfont = locale_font;
    } else
#line 11361
    if ((int )locale_text) {
#line 11362
      myfont = locale_font;
    }
  }
  {
#line 11364
  __cil_tmp14 = dcgettext((char const   *)((void *)0), str, 5);
#line 11364
  __cil_tmp15 = strcmp(str, (char const   *)__cil_tmp14);
  }
#line 11364
  if (__cil_tmp15 == 0) {
#line 11367
    want_right_to_left = 0;
  }
  {
#line 11374
  sdl_color_to_pango_color(color, & pango_color);
#line 11376
  SDLPango_SetDefaultColor(myfont->pango_context, & pango_color);
#line 11377
  SDLPango_SetMinimumSize(myfont->pango_context, right - left, canvas->h - top);
  }
#line 11378
  if (want_right_to_left) {
#line 11378
    if (need_right_to_left) {
      {
#line 11380
      SDLPango_SetBaseDirection(locale_font->pango_context, (SDLPango_Direction )1);
      }
#line 11381
      if (only_uppercase) {
        {
#line 11383
        __cil_tmp17 = dcgettext((char const   *)((void *)0), str, 5);
#line 11383
        __cil_tmp18 = uppercase((char const   *)__cil_tmp17);
#line 11383
        upper_str = __cil_tmp18;
#line 11385
        SDLPango_SetText_GivenAlignment(myfont->pango_context, (char const   *)upper_str,
                                        - 1, (SDLPango_Alignment )2);
#line 11386
        free(upper_str);
        }
      } else {
        {
#line 11389
        __cil_tmp19 = dcgettext((char const   *)((void *)0), str, 5);
#line 11389
        SDLPango_SetText_GivenAlignment(myfont->pango_context, (char const   *)__cil_tmp19,
                                        - 1, (SDLPango_Alignment )2);
        }
      }
    } else {
#line 11378
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 11393
    SDLPango_SetBaseDirection(locale_font->pango_context, (SDLPango_Direction )0);
    }
#line 11394
    if (only_uppercase) {
      {
#line 11396
      __cil_tmp21 = dcgettext((char const   *)((void *)0), str, 5);
#line 11396
      __cil_tmp22 = uppercase((char const   *)__cil_tmp21);
#line 11396
      upper_str___0 = __cil_tmp22;
#line 11398
      SDLPango_SetText_GivenAlignment(myfont->pango_context, (char const   *)upper_str___0,
                                      - 1, (SDLPango_Alignment )0);
#line 11399
      free(upper_str___0);
      }
    } else {
      {
#line 11402
      __cil_tmp23 = dcgettext((char const   *)((void *)0), str, 5);
#line 11402
      SDLPango_SetText_GivenAlignment(myfont->pango_context, (char const   *)__cil_tmp23,
                                      - 1, (SDLPango_Alignment )0);
      }
    }
  }
  {
#line 11405
  text = SDLPango_CreateSurfaceDraw(myfont->pango_context);
#line 11407
  dest.x = (Sint16 )left;
#line 11408
  dest.y = (Sint16 )top;
  }
#line 11409
  if (text != (void *)0) {
    {
#line 11411
    SDL_UpperBlit(text, (SDL_Rect *)((void *)0), screen, & dest);
#line 11412
    SDL_FreeSurface(text);
    }
  }
  return;
}
}
#line 11745 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void playstampdesc(int chan ) 
{ 
  static SDL_Event playsound_event ;

  {
#line 11749
  if (chan == 2) {
    {
#line 11751
    debug("Stamp SFX ended. Pushing event to play description sound...");
#line 11753
    playsound_event.type = (Uint8 )24;
#line 11754
    playsound_event.user.code = 2;
#line 11755
    playsound_event.user.data1 = (void *)((intptr_t )cur_stamp[stamp_group]);
#line 11757
    SDL_PushEvent(& playsound_event);
    }
  }
  return;
}
}
#line 11771 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Mix_Chunk *loadsound_extra(char const   *fname , char const   *extra ) 
{ 
  char *snd_fname ;
  char tmp_str[256] ;
  char ext[5] ;
  Mix_Chunk *tmp_snd ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  SDL_RWops *__cil_tmp12 ;
  Mix_Chunk *__cil_tmp13 ;
  char *__cil_tmp14 ;
  SDL_RWops *__cil_tmp15 ;
  Mix_Chunk *__cil_tmp16 ;
  char *__cil_tmp17 ;
  SDL_RWops *__cil_tmp18 ;
  Mix_Chunk *__cil_tmp19 ;
  char *__cil_tmp20 ;
  SDL_RWops *__cil_tmp21 ;
  Mix_Chunk *__cil_tmp22 ;
  char *__cil_tmp23 ;
  SDL_RWops *__cil_tmp24 ;
  Mix_Chunk *__cil_tmp25 ;
  char *__cil_tmp26 ;
  SDL_RWops *__cil_tmp27 ;
  Mix_Chunk *__cil_tmp28 ;

  {
  {
#line 11778
  __cil_tmp7 = strcasestr(fname, ".png");
  }
#line 11778
  if (__cil_tmp7 != (void *)0) {
    {
#line 11780
    strcpy((char *)ext, ".png");
    }
  } else {
#line 11786
    return ((Mix_Chunk *)((void *)0));
  }
  {
#line 11791
  __cil_tmp9 = strlen(lang_prefix);
  }
  {
#line 11791
  __cil_tmp8 = strlen(fname);
#line 11791
  __cil_tmp10 = malloc((__cil_tmp8 + __cil_tmp9) + 16UL);
#line 11791
  snd_fname = __cil_tmp10;
#line 11793
  strcpy(snd_fname, fname);
#line 11794
  safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s_%s.ogg", extra, lang_prefix);
#line 11795
  __cil_tmp11 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11795
  strcpy((char *)__cil_tmp11, (char const   *)((char *)tmp_str));
#line 11796
  debug((char const   *)snd_fname);
#line 11797
  __cil_tmp12 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11797
  __cil_tmp13 = Mix_LoadWAV_RW(__cil_tmp12, 1);
#line 11797
  tmp_snd = __cil_tmp13;
  }
#line 11799
  if (tmp_snd == (void *)0) {
    {
#line 11801
    debug("...No local version of sound (OGG)!");
#line 11803
    strcpy(snd_fname, fname);
#line 11804
    safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s_%s.wav", extra, lang_prefix);
#line 11805
    __cil_tmp14 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11805
    strcpy((char *)__cil_tmp14, (char const   *)((char *)tmp_str));
#line 11806
    debug((char const   *)snd_fname);
#line 11807
    __cil_tmp15 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11807
    __cil_tmp16 = Mix_LoadWAV_RW(__cil_tmp15, 1);
#line 11807
    tmp_snd = __cil_tmp16;
    }
#line 11809
    if (tmp_snd == (void *)0) {
      {
#line 11811
      debug("...No local version of sound (WAV)!");
#line 11815
      strcpy(snd_fname, fname);
#line 11816
      safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s_%s.ogg", extra, short_lang_prefix);
#line 11817
      __cil_tmp17 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11817
      strcpy((char *)__cil_tmp17, (char const   *)((char *)tmp_str));
#line 11818
      debug((char const   *)snd_fname);
#line 11819
      __cil_tmp18 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11819
      __cil_tmp19 = Mix_LoadWAV_RW(__cil_tmp18, 1);
#line 11819
      tmp_snd = __cil_tmp19;
      }
#line 11821
      if (tmp_snd == (void *)0) {
        {
#line 11823
        debug("...No short local version of sound (OGG)!");
#line 11825
        strcpy(snd_fname, fname);
#line 11826
        safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s_%s.wav", extra, short_lang_prefix);
#line 11827
        __cil_tmp20 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11827
        strcpy((char *)__cil_tmp20, (char const   *)((char *)tmp_str));
#line 11828
        debug((char const   *)snd_fname);
#line 11829
        __cil_tmp21 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11829
        __cil_tmp22 = Mix_LoadWAV_RW(__cil_tmp21, 1);
#line 11829
        tmp_snd = __cil_tmp22;
        }
#line 11831
        if (tmp_snd == (void *)0) {
          {
#line 11835
          debug("...No short local version of sound (WAV)!");
#line 11837
          strcpy(snd_fname, fname);
#line 11838
          safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s.ogg", extra);
#line 11839
          __cil_tmp23 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11839
          strcpy((char *)__cil_tmp23, (char const   *)((char *)tmp_str));
#line 11840
          debug((char const   *)snd_fname);
#line 11841
          __cil_tmp24 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11841
          __cil_tmp25 = Mix_LoadWAV_RW(__cil_tmp24, 1);
#line 11841
          tmp_snd = __cil_tmp25;
          }
#line 11843
          if (tmp_snd == (void *)0) {
            {
#line 11845
            debug("...No default version of sound (OGG)!");
#line 11847
            strcpy(snd_fname, fname);
#line 11848
            safe_snprintf((char *)tmp_str, sizeof(tmp_str), "%s.wav", extra);
#line 11849
            __cil_tmp26 = strcasestr((char const   *)snd_fname, (char const   *)((char *)ext));
#line 11849
            strcpy((char *)__cil_tmp26, (char const   *)((char *)tmp_str));
#line 11850
            debug((char const   *)snd_fname);
#line 11851
            __cil_tmp27 = SDL_RWFromFile((char const   *)snd_fname, "rb");
#line 11851
            __cil_tmp28 = Mix_LoadWAV_RW(__cil_tmp27, 1);
#line 11851
            tmp_snd = __cil_tmp28;
            }
#line 11853
            if (tmp_snd == (void *)0) {
              {
#line 11854
              debug("...No default version of sound (WAV)!");
              }
            }
          }
        }
      }
    }
  }
  {
#line 11861
  free(snd_fname);
  }
#line 11862
  return (tmp_snd);
}
}
#line 11869 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Mix_Chunk *loadsound(char const   *fname ) 
{ 
  Mix_Chunk *__cil_tmp2 ;

  {
  {
#line 11871
  __cil_tmp2 = loadsound_extra(fname, "pe\226t\324U");
  }
#line 11871
  return (__cil_tmp2);
}
}
#line 11877 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Mix_Chunk *loaddescsound(char const   *fname ) 
{ 
  Mix_Chunk *__cil_tmp2 ;

  {
  {
#line 11879
  __cil_tmp2 = loadsound_extra(fname, "_desc");
  }
#line 11879
  return (__cil_tmp2);
}
}
#line 11890 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void strip_trailing_whitespace(char *buf ) 
{ 
  unsigned int i ;
  unsigned long __cil_tmp3 ;
  unsigned int __cil_tmp4 ;
  unsigned short const   **__cil_tmp5 ;

  {
  {
#line 11892
  __cil_tmp3 = strlen((char const   *)buf);
#line 11892
  i = (unsigned int )__cil_tmp3;
  }
  {
#line 11894
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11894
    __cil_tmp4 = i;
#line 11894
    i --;
#line 11894
    if (! __cil_tmp4) {
#line 11894
      goto while_break;
    }
    {
#line 11896
    __cil_tmp5 = __ctype_b_loc();
    }
#line 11896
    if (! ((int )*(*__cil_tmp5 + (int )*(buf + i)) & 8192)) {
#line 11897
      goto while_break;
    }
#line 11898
    *(buf + i) = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 11908 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char *loaddesc(char const   *fname , Uint8 *locale_text ) 
{ 
  char *txt_fname ;
  char *extptr ;
  char buf[512] ;
  char def_buf[512] ;
  int found ;
  int got_first ;
  FILE *fi ;
  int i ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  FILE *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  char *__cil_tmp21 ;
  unsigned long __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 11916
  txt_fname = strdup(fname);
#line 11917
  *locale_text = (Uint8 )0;
#line 11919
  extptr = strcasestr((char const   *)txt_fname, ".png");
  }
#line 11922
  if (extptr == (void *)0) {
    {
#line 11923
    extptr = strcasestr((char const   *)txt_fname, ".svg");
    }
  }
#line 11926
  if (extptr != (void *)0) {
    {
#line 11928
    found = 0;
#line 11929
    strcpy((char *)def_buf, "\220");
#line 11932
    i = 0;
    }
    {
#line 11932
    while (1) {
      while_continue: /* CIL Label */ ;
#line 11932
      if (! (i < num_wished_langs && ! found)) {
#line 11932
        goto while_break;
      }
      {
#line 11934
      strcpy((char *)extptr, ".txt");
#line 11935
      fi = fopen((char const   *)txt_fname, "r");
      }
#line 11936
      if (! fi) {
#line 11937
        return ((char *)((void *)0));
      }
      {
#line 11939
      got_first = 0;
#line 11940
      strcpy((char *)def_buf, "\220");
      }
      {
#line 11942
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 11944
        __cil_tmp16 = fgets((char *)buf, (int )sizeof(buf), fi);
        }
#line 11944
        if (__cil_tmp16) {
          {
#line 11946
          __cil_tmp17 = feof(fi);
          }
#line 11946
          if (! __cil_tmp17) {
            {
#line 11948
            strip_trailing_whitespace((char *)buf);
            }
#line 11950
            if (! got_first) {
              {
#line 11954
              strcpy((char *)def_buf, (char const   *)((char *)buf));
#line 11955
              got_first = 1;
              }
            }
            {
#line 11958
            debug((char const   *)((char *)buf));
#line 11964
            __cil_tmp18 = strcasestr((char const   *)((char *)buf), wished_langs[i].lang_prefix);
            }
#line 11964
            if ((char *)__cil_tmp18 == (char *)buf) {
              {
#line 11967
              __cil_tmp19 = strlen(wished_langs[i].lang_prefix);
#line 11967
              debug((char const   *)((char *)buf + __cil_tmp19));
#line 11968
              __cil_tmp22 = strlen(wished_langs[i].lang_prefix);
              }
              {
#line 11968
              __cil_tmp20 = strlen(wished_langs[i].lang_prefix);
#line 11968
              __cil_tmp21 = strcasestr((char const   *)((char *)buf + __cil_tmp20),
                                       ".utf8=");
              }
#line 11968
              if ((char *)__cil_tmp21 == (char *)buf + __cil_tmp22) {
                {
#line 11971
                lang_prefix = wished_langs[i].lang_prefix;
#line 11972
                __cil_tmp23 = strdup(lang_prefix);
#line 11972
                short_lang_prefix = (char const   *)__cil_tmp23;
#line 11974
                __cil_tmp24 = strchr(short_lang_prefix, '_');
                }
#line 11974
                if (__cil_tmp24) {
                  {
#line 11975
                  __cil_tmp25 = strchr(short_lang_prefix, '_');
#line 11975
                  *__cil_tmp25 = (char )'\000';
                  }
                }
                {
#line 11977
                need_own_font = wished_langs[i].need_own_font;
#line 11978
                need_right_to_left = wished_langs[i].need_right_to_left;
#line 11979
                need_right_to_left_word = wished_langs[i].need_right_to_left_word;
#line 11981
                found = 1;
#line 11983
                debug("...FOUND!");
                }
              }
            }
          }
        }
#line 11942
        if (! (! __cil_tmp15 && ! found)) {
#line 11942
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 11991
      fclose(fi);
      }
#line 11932
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 11995
    free(txt_fname);
    }
#line 12000
    if (found) {
      {
#line 12002
      *locale_text = (Uint8 )1;
#line 12003
      __cil_tmp27 = strlen(lang_prefix);
#line 12003
      __cil_tmp28 = strdup((char const   *)(((char *)buf + __cil_tmp27) + 6));
      }
#line 12003
      return (__cil_tmp28);
    } else {
      {
#line 12008
      __cil_tmp29 = strdup((char const   *)((char *)def_buf));
      }
#line 12008
      return (__cil_tmp29);
    }
  } else {
    {
#line 12013
    fprintf(stderr, "Somehow, \'%s\' doesn\'t have a filename extension!?\n", fname);
    }
#line 12014
    return ((char *)((void *)0));
  }
}
}
#line 12023 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static double loadinfo(char const   *fname , stamp_type *inf ) 
{ 
  char buf[256] ;
  FILE *fi ;
  double ratio ;
  FILE *__cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  unsigned short const   **__cil_tmp13 ;
  double tmp ;
  double tmp2 ;
  char *cp ;
  unsigned short const   **__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  double __cil_tmp20 ;
  char *__cil_tmp21 ;
  double __cil_tmp22 ;
  unsigned short const   **__cil_tmp23 ;
  char *__cil_tmp24 ;
  double __cil_tmp25 ;
  char *__cil_tmp26 ;
  double __cil_tmp27 ;
  unsigned short const   **__cil_tmp28 ;
  char *__cil_tmp29 ;
  double __cil_tmp30 ;
  double __cil_tmp31 ;
  int __cil_tmp32 ;
  unsigned short const   **__cil_tmp33 ;
  char *cp___0 ;
  unsigned short const   **__cil_tmp35 ;
  char *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;

  {
  {
#line 12027
  ratio = 1.;
#line 12029
  inf->colorable = (unsigned int )0;
#line 12030
  inf->tintable = (unsigned int )0;
#line 12031
  inf->mirrorable = (unsigned int )1;
#line 12032
  inf->flipable = (unsigned int )1;
#line 12033
  inf->tinter = (unsigned int )2;
#line 12035
  fi = fopen(fname, "r");
  }
#line 12036
  if (! fi) {
#line 12037
    return (ratio);
  }
  {
#line 12039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 12041
    __cil_tmp8 = fgets((char *)buf, (int )sizeof(buf), fi);
    }
#line 12041
    if (__cil_tmp8) {
      {
#line 12043
      __cil_tmp9 = feof(fi);
      }
#line 12043
      if (! __cil_tmp9) {
        {
#line 12045
        strip_trailing_whitespace((char *)buf);
#line 12047
        __cil_tmp10 = strcmp((char const   *)((char *)buf), "colorable\267\226t\324U");
        }
#line 12047
        if (__cil_tmp10 == 0) {
#line 12048
          inf->colorable = (unsigned int )1;
        } else {
          {
#line 12049
          __cil_tmp11 = strcmp((char const   *)((char *)buf), "tintable\220");
          }
#line 12049
          if (__cil_tmp11 == 0) {
#line 12050
            inf->tintable = (unsigned int )1;
          } else {
            {
#line 12051
            __cil_tmp13 = __ctype_b_loc();
            }
            {
#line 12051
            __cil_tmp12 = memcmp((char *)buf, "scale", (unsigned long )5);
            }
#line 12051
            if (! __cil_tmp12) {
#line 12051
              if ((int )*(*__cil_tmp13 + (int )buf[5]) & 8192) {
                _L___148: /* CIL Label */ 
#line 12054
                cp = (char *)buf + 6;
                {
#line 12056
                while (1) {
                  while_continue___0: /* CIL Label */ ;
                  {
#line 12056
                  __cil_tmp17 = __ctype_b_loc();
                  }
#line 12056
                  if (! ((int )*(*__cil_tmp17 + (int )*cp) & 8192 || (int )*cp == 61)) {
#line 12056
                    goto while_break___0;
                  }
#line 12057
                  cp ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 12058
                __cil_tmp19 = strchr((char const   *)cp, '%');
                }
#line 12058
                if (__cil_tmp19) {
                  {
#line 12060
                  __cil_tmp20 = strtod((char const   *)cp, (char **)((void *)0));
#line 12060
                  tmp = __cil_tmp20 / 100.;
                  }
#line 12061
                  if (tmp > 0.000100000000001) {
#line 12061
                    if (tmp < 10000.) {
#line 12062
                      ratio = tmp;
                    }
                  }
                } else {
                  {
#line 12064
                  __cil_tmp21 = strchr((char const   *)cp, '/');
                  }
#line 12064
                  if (__cil_tmp21) {
                    {
#line 12066
                    tmp = strtod((char const   *)cp, & cp);
                    }
                    {
#line 12067
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
                      {
#line 12067
                      __cil_tmp23 = __ctype_b_loc();
                      }
#line 12067
                      if (! ((int )*cp && ! ((int )*(*__cil_tmp23 + (int )*cp) & 2048))) {
#line 12067
                        goto while_break___1;
                      }
#line 12068
                      cp ++;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
                    {
#line 12069
                    tmp2 = strtod((char const   *)cp, (char **)((void *)0));
                    }
#line 12070
                    if (tmp > 0.000100000000001) {
#line 12070
                      if (tmp < 10000.) {
#line 12070
                        if (tmp2 > 0.000100000000001) {
#line 12070
                          if (tmp2 < 10000.) {
#line 12070
                            if (tmp / tmp2 > 0.000100000000001) {
#line 12070
                              if (tmp / tmp2 < 10000.) {
#line 12072
                                ratio = tmp / tmp2;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    {
#line 12074
                    __cil_tmp26 = strchr((char const   *)cp, ':');
                    }
#line 12074
                    if (__cil_tmp26) {
                      {
#line 12076
                      tmp = strtod((char const   *)cp, & cp);
                      }
                      {
#line 12077
                      while (1) {
                        while_continue___2: /* CIL Label */ ;
                        {
#line 12077
                        __cil_tmp28 = __ctype_b_loc();
                        }
#line 12077
                        if (! ((int )*cp && ! ((int )*(*__cil_tmp28 + (int )*cp) & 2048))) {
#line 12077
                          goto while_break___2;
                        }
#line 12078
                        cp ++;
                      }
                      while_break___2: /* CIL Label */ ;
                      }
                      {
#line 12079
                      tmp2 = strtod((char const   *)cp, (char **)((void *)0));
                      }
#line 12080
                      if (tmp > 0.000100000000001) {
#line 12080
                        if (tmp < 10000.) {
#line 12080
                          if (tmp2 > 0.000100000000001) {
#line 12080
                            if (tmp2 < 10000.) {
#line 12080
                              if (tmp2 / tmp > 0.000100000000001) {
#line 12080
                                if (tmp2 / tmp < 10000.) {
#line 12082
                                  ratio = tmp2 / tmp;
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      {
#line 12086
                      tmp = strtod((char const   *)cp, (char **)((void *)0));
                      }
#line 12087
                      if (tmp > 0.000100000000001) {
#line 12087
                        if (tmp < 10000.) {
#line 12088
                          ratio = 1. / tmp;
                        }
                      }
                    }
                  }
                }
              } else
#line 12051
              if ((int )buf[5] == 61) {
#line 12051
                goto _L___148;
              } else {
#line 12051
                goto _L___147;
              }
            } else {
              _L___147: /* CIL Label */ 
              {
#line 12091
              __cil_tmp33 = __ctype_b_loc();
              }
              {
#line 12091
              __cil_tmp32 = memcmp((char *)buf, "tinter", (unsigned long )6);
              }
#line 12091
              if (! __cil_tmp32) {
#line 12091
                if ((int )*(*__cil_tmp33 + (int )buf[6]) & 8192) {
                  _L___146: /* CIL Label */ 
#line 12093
                  cp___0 = (char *)buf + 7;
                  {
#line 12095
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    {
#line 12095
                    __cil_tmp35 = __ctype_b_loc();
                    }
#line 12095
                    if (! ((int )*(*__cil_tmp35 + (int )*cp___0) & 8192 || (int )*cp___0 == 61)) {
#line 12095
                      goto while_break___3;
                    }
#line 12096
                    cp___0 ++;
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                  {
#line 12097
                  __cil_tmp37 = strcmp((char const   *)cp___0, "anyhue");
                  }
#line 12097
                  if (! __cil_tmp37) {
#line 12099
                    inf->tinter = (unsigned int )0;
                  } else {
                    {
#line 12101
                    __cil_tmp38 = strcmp((char const   *)cp___0, "narrow");
                    }
#line 12101
                    if (! __cil_tmp38) {
#line 12103
                      inf->tinter = (unsigned int )1;
                    } else {
                      {
#line 12105
                      __cil_tmp39 = strcmp((char const   *)cp___0, "normal");
                      }
#line 12105
                      if (! __cil_tmp39) {
#line 12107
                        inf->tinter = (unsigned int )2;
                      } else {
                        {
#line 12109
                        __cil_tmp40 = strcmp((char const   *)cp___0, "vector");
                        }
#line 12109
                        if (! __cil_tmp40) {
#line 12111
                          inf->tinter = (unsigned int )3;
                        } else {
                          {
#line 12115
                          debug((char const   *)cp___0);
                          }
                        }
                      }
                    }
                  }
                } else
#line 12091
                if ((int )buf[6] == 61) {
#line 12091
                  goto _L___146;
                } else {
#line 12091
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
                {
#line 12118
                __cil_tmp41 = strcmp((char const   *)((char *)buf), "nomirror\220");
                }
#line 12118
                if (__cil_tmp41 == 0) {
#line 12119
                  inf->mirrorable = (unsigned int )0;
                } else {
                  {
#line 12120
                  __cil_tmp42 = strcmp((char const   *)((char *)buf), "noflip");
                  }
#line 12120
                  if (__cil_tmp42 == 0) {
#line 12121
                    inf->flipable = (unsigned int )0;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 12039
    if (! (! __cil_tmp7)) {
#line 12039
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12127
  fclose(fi);
  }
#line 12128
  return (ratio);
}
}
#line 12135 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int NondefectiveBlit(SDL_Surface *src , SDL_Rect *srcrect , SDL_Surface *dst ,
                            SDL_Rect *dstrect ) 
{ 
  int dstx ;
  int dsty ;
  int srcx ;
  int srcy ;
  int srcw ;
  int srch ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int i ;
  int __cil_tmp16 ;
  Uint32 __cil_tmp17 ;

  {
#line 12137
  dstx = 0;
#line 12138
  dsty = 0;
#line 12139
  srcx = 0;
#line 12140
  srcy = 0;
#line 12141
  srcw = src->w;
#line 12142
  srch = src->h;
#line 12144
  getpixel = getpixels[(src->format)->BytesPerPixel];
#line 12145
  putpixel = putpixels[(dst->format)->BytesPerPixel];
#line 12148
  if (srcrect) {
#line 12150
    srcx = (int )srcrect->x;
#line 12151
    srcy = (int )srcrect->y;
#line 12152
    srcw = (int )srcrect->w;
#line 12153
    srch = (int )srcrect->h;
  }
#line 12155
  if (dstrect) {
#line 12157
    dstx = (int )dstrect->x;
#line 12158
    dsty = (int )dstrect->y;
  }
#line 12160
  if (dsty < 0) {
#line 12162
    srcy += - dsty;
#line 12163
    srch -= - dsty;
#line 12164
    dsty = 0;
  }
#line 12166
  if (dstx < 0) {
#line 12168
    srcx += - dstx;
#line 12169
    srcw -= - dstx;
#line 12170
    dstx = 0;
  }
#line 12172
  if (dstx + srcw > dst->w - 1) {
#line 12174
    srcw -= (dstx + srcw) - (dst->w - 1);
  }
#line 12176
  if (dsty + srch > dst->h - 1) {
#line 12178
    srch -= (dsty + srch) - (dst->h - 1);
  }
#line 12180
  if (srcw < 1) {
#line 12181
    return (- 1);
  } else
#line 12180
  if (srch < 1) {
#line 12181
    return (- 1);
  }
#line 12182
  srch ++;
  {
#line 12183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12183
    __cil_tmp14 = srch;
#line 12183
    srch --;
#line 12183
    if (! __cil_tmp14) {
#line 12183
      goto while_break;
    }
#line 12185
    i = srcw + 1;
    {
#line 12187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12187
      __cil_tmp16 = i;
#line 12187
      i --;
#line 12187
      if (! __cil_tmp16) {
#line 12187
        goto while_break___0;
      }
      {
#line 12189
      __cil_tmp17 = (*getpixel)(src, i + srcx, srch + srcy);
#line 12189
      (*putpixel)(dst, i + dstx, srch + dsty, __cil_tmp17);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 12193
  return (0);
}
}
#line 12205 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void autoscale_copy_smear_free(SDL_Surface *src , SDL_Surface *dst , int (*blit)(SDL_Surface * ,
                                                                                        SDL_Rect * ,
                                                                                        SDL_Surface * ,
                                                                                        SDL_Rect * ) ) 
{ 
  SDL_Surface *src1 ;
  SDL_Rect dest ;
  SDL_Surface *__cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  SDL_Rect sour ;
  int i ;
  int __cil_tmp10 ;
  SDL_Rect sour___0 ;
  int i___0 ;
  int __cil_tmp13 ;

  {
#line 12216
  if (src->w != dst->w) {
    _L: /* CIL Label */ 
#line 12218
    if ((float )src->w / (float )dst->w > (float )src->h / (float )dst->h) {
      {
#line 12219
      src1 = thumbnail(src, dst->w, (src->h * dst->w) / src->w, 0);
      }
    } else {
      {
#line 12221
      src1 = thumbnail(src, (src->w * dst->h) / src->h, dst->h, 0);
      }
    }
    {
#line 12222
    SDL_FreeSurface(src);
#line 12223
    src = src1;
    }
  } else
#line 12216
  if (src->h != dst->h) {
#line 12216
    goto _L;
  }
  {
#line 12226
  dest.x = (Sint16 )((dst->w - src->w) / 2);
#line 12227
  dest.y = (Sint16 )((dst->h - src->h) / 2);
#line 12228
  (*blit)(src, (SDL_Rect *)((void *)0), dst, & dest);
  }
#line 12230
  if (src->w != dst->w) {
#line 12234
    i = (dst->w - src->w) / 2;
#line 12236
    sour.w = (Uint16 )1;
#line 12237
    sour.x = (Sint16 )0;
#line 12238
    sour.h = (Uint16 )src->h;
#line 12239
    sour.y = (Sint16 )0;
    {
#line 12240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12240
      __cil_tmp10 = i;
#line 12240
      i --;
#line 12240
      if (! (__cil_tmp10 > 0)) {
#line 12240
        goto while_break;
      }
      {
#line 12242
      dest.x = (Sint16 )i;
#line 12243
      (*blit)(src, & sour, dst, & dest);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 12245
    sour.x = (Sint16 )(src->w - 1);
#line 12246
    i = ((dst->w - src->w) / 2 + src->w) - 1;
    {
#line 12247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12247
      i ++;
#line 12247
      if (! (i < dst->w)) {
#line 12247
        goto while_break___0;
      }
      {
#line 12249
      dest.x = (Sint16 )i;
#line 12250
      (*blit)(src, & sour, dst, & dest);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 12254
  if (src->h != dst->h) {
#line 12258
    i___0 = (dst->h - src->h) / 2;
#line 12260
    sour___0.w = (Uint16 )src->w;
#line 12261
    sour___0.x = (Sint16 )0;
#line 12262
    sour___0.h = (Uint16 )1;
#line 12263
    sour___0.y = (Sint16 )0;
    {
#line 12264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 12264
      __cil_tmp13 = i___0;
#line 12264
      i___0 --;
#line 12264
      if (! (__cil_tmp13 > 0)) {
#line 12264
        goto while_break___1;
      }
      {
#line 12266
      dest.y = (Sint16 )i___0;
#line 12267
      (*blit)(src, & sour___0, dst, & dest);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 12269
    sour___0.y = (Sint16 )(src->h - 1);
#line 12270
    i___0 = ((dst->h - src->h) / 2 + src->h) - 1;
    {
#line 12271
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 12271
      i___0 ++;
#line 12271
      if (! (i___0 < dst->h)) {
#line 12271
        goto while_break___2;
      }
      {
#line 12273
      dest.y = (Sint16 )i___0;
#line 12274
      (*blit)(src, & sour___0, dst, & dest);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 12278
  SDL_FreeSurface(src);
  }
  return;
}
}
#line 12285 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_starter_id(char *saved_id , FILE *fil ) 
{ 
  char *rname ;
  char fname[4096] ;
  FILE *fi ;
  char color_tag ;
  int r ;
  int g ;
  int b ;
  int tmp ;
  char *tmp_ptr ;
  char *__cil_tmp12 ;
  FILE *__cil_tmp13 ;
  char *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  unsigned long __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;

  {
#line 12294
  rname = (char *)((void *)0);
#line 12296
  if (saved_id != (void *)0) {
    {
#line 12298
    safe_snprintf((char *)fname, sizeof(fname), "saved/%s.dat", saved_id);
#line 12299
    rname = get_fname((char const   *)((char *)fname), 0);
#line 12301
    fi = fopen((char const   *)rname, "r");
    }
  } else {
#line 12304
    fi = fil;
  }
#line 12306
  starter_id[0] = (char )'\000';
#line 12307
  template_id[0] = (char )'\000';
#line 12309
  if (fi != (void *)0) {
    {
#line 12311
    __cil_tmp14 = fgets((char *)starter_id, (int )sizeof(starter_id), fi);
    }
#line 12311
    if (__cil_tmp14) {
      {
#line 12313
      __cil_tmp15 = strlen((char const   *)((char *)starter_id));
#line 12313
      starter_id[__cil_tmp15 - 1UL] = (char )'\000';
#line 12315
      tmp = fscanf(fi, "%d", & starter_mirrored);
#line 12316
      tmp = fscanf(fi, "%d", & starter_flipped);
#line 12317
      tmp = fscanf(fi, "%d", & starter_personal);
      }
      {
#line 12319
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 12321
        __cil_tmp20 = fgetc(fi);
#line 12321
        color_tag = (char )__cil_tmp20;
        }
#line 12319
        if (! (((int )color_tag == 10 || (int )color_tag == 13) && ! __cil_tmp19)) {
#line 12319
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 12325
      __cil_tmp21 = feof(fi);
      }
#line 12325
      if (! __cil_tmp21) {
#line 12325
        if ((int )color_tag == 99) {
          {
#line 12327
          tmp = fscanf(fi, "%d", & r);
#line 12328
          tmp = fscanf(fi, "%d", & g);
#line 12329
          tmp = fscanf(fi, "%d", & b);
#line 12331
          canvas_color_r = (Uint8 )r;
#line 12332
          canvas_color_g = (Uint8 )g;
#line 12333
          canvas_color_b = (Uint8 )b;
          }
        } else {
#line 12337
          canvas_color_r = (Uint8 )255;
#line 12338
          canvas_color_g = (Uint8 )255;
#line 12339
          canvas_color_b = (Uint8 )255;
        }
      } else {
#line 12337
        canvas_color_r = (Uint8 )255;
#line 12338
        canvas_color_g = (Uint8 )255;
#line 12339
        canvas_color_b = (Uint8 )255;
      }
      {
#line 12342
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 12344
        __cil_tmp26 = fgetc(fi);
#line 12344
        color_tag = (char )__cil_tmp26;
        }
#line 12342
        if (! (((int )color_tag == 10 || (int )color_tag == 13) && ! __cil_tmp25)) {
#line 12342
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 12348
      __cil_tmp27 = feof(fi);
      }
#line 12348
      if (! __cil_tmp27) {
#line 12348
        if ((int )color_tag == 84) {
          {
#line 12350
          tmp_ptr = fgets((char *)template_id, (int )sizeof(template_id), fi);
#line 12351
          __cil_tmp29 = strlen((char const   *)((char *)template_id));
#line 12351
          template_id[__cil_tmp29 - 1UL] = (char )'\000';
#line 12352
          tmp = fscanf(fi, "%d", & template_personal);
          }
        }
      }
      {
#line 12357
      __cil_tmp31 = feof(fi);
      }
#line 12357
      if (! __cil_tmp31) {
#line 12357
        if ((int )color_tag == 77) {
          {
#line 12359
          starter_modified = fgetc(fi);
          }
        }
      }
    }
    {
#line 12362
    fclose(fi);
    }
  } else {
#line 12366
    canvas_color_r = (Uint8 )255;
#line 12367
    canvas_color_g = (Uint8 )255;
#line 12368
    canvas_color_b = (Uint8 )255;
  }
#line 12371
  if (saved_id != (void *)0) {
    {
#line 12372
    free(rname);
    }
  }
  return;
}
}
#line 12379 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *load_starter_helper(char *path_and_basename , char const   *extension ,
                                        SDL_Surface *(*load_func)(char const   * ) ) 
{ 
  char *ext ;
  char fname[256] ;
  SDL_Surface *surf ;
  unsigned int i ;
  char *__cil_tmp8 ;
  SDL_Surface *__cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned int __cil_tmp11 ;
  SDL_Surface *__cil_tmp12 ;

  {
  {
#line 12386
  ext = strdup(extension);
#line 12387
  safe_snprintf((char *)fname, sizeof(fname), "%s.%s", path_and_basename, ext);
#line 12389
  surf = (*load_func)((char const   *)((char *)fname));
  }
#line 12391
  if (surf == (void *)0) {
#line 12393
    i = (unsigned int )0;
    {
#line 12393
    while (1) {
      while_continue: /* CIL Label */ ;
#line 12393
      if (! ((unsigned long )i < __cil_tmp10)) {
#line 12393
        goto while_break;
      }
#line 12395
      *(ext + i) = (char )0;
#line 12393
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 12397
    safe_snprintf((char *)fname, sizeof(fname), "%s.%sU", path_and_basename, ext);
#line 12398
    surf = (*load_func)((char const   *)((char *)fname));
    }
  }
  {
#line 12401
  free(ext);
  }
#line 12403
  return (surf);
}
}
#line 12410 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_starter(char *img_id ) 
{ 
  char *dirname___149 ;
  char fname[256] ;
  SDL_Surface *tmp_surf ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;
  SDL_Surface *__cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;
  SDL_Surface *__cil_tmp11 ;
  SDL_Surface *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;
  SDL_Surface *__cil_tmp15 ;
  int x ;
  int y ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  void (*putpixel)(SDL_Surface * , int  , int  , Uint32  ) ;
  Uint32 p ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  int any_transparency ;
  Uint32 __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  Uint32 __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  SDL_Surface *__cil_tmp35 ;
  SDL_Surface *__cil_tmp36 ;

  {
#line 12418
  if (starter_personal == 0) {
    {
#line 12419
    dirname___149 = strdup("/usr/local/share/tuxpaint/starters");
    }
  } else {
    {
#line 12421
    dirname___149 = get_fname("starters\230", 1);
    }
  }
#line 12424
  img_starter = (SDL_Surface *)((void *)0);
#line 12425
  img_starter_bkgd = (SDL_Surface *)((void *)0);
#line 12428
  tmp_surf = (SDL_Surface *)((void *)0);
#line 12431
  if (tmp_surf == (void *)0) {
    {
#line 12435
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___149, img_id);
#line 12436
    tmp_surf = load_starter_helper((char *)fname, "svg", & load_svg);
    }
  }
#line 12440
  if (tmp_surf == (void *)0) {
    {
#line 12442
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___149, img_id);
#line 12443
    tmp_surf = load_starter_helper((char *)fname, "pngt\324U", & IMG_Load);
    }
  }
#line 12446
  if (tmp_surf == (void *)0) {
    {
#line 12449
    safe_snprintf((char *)fname, sizeof(fname), "%s/%sU", dirname___149, img_id);
#line 12450
    tmp_surf = load_starter_helper((char *)fname, "kpx", & myIMG_Load);
    }
  }
#line 12454
  if (tmp_surf != (void *)0) {
    {
#line 12456
    img_starter = SDL_DisplayFormatAlpha(tmp_surf);
#line 12457
    SDL_FreeSurface(tmp_surf);
    }
  }
#line 12462
  tmp_surf = (SDL_Surface *)((void *)0);
#line 12466
  if (tmp_surf == (void *)0) {
    {
#line 12468
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back\227t\324U", dirname___149,
                  img_id);
#line 12469
    tmp_surf = load_starter_helper((char *)fname, "svg", & load_svg);
    }
  }
#line 12474
  if (tmp_surf == (void *)0) {
    {
#line 12476
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back\303s\324U", dirname___149,
                  img_id);
#line 12477
    tmp_surf = load_starter_helper((char *)fname, "jpeg", & IMG_Load);
    }
  }
#line 12480
  if (tmp_surf == (void *)0) {
    {
#line 12483
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back\227t\324U", dirname___149,
                  img_id);
#line 12484
    tmp_surf = load_starter_helper((char *)fname, "jpgt\324U", & IMG_Load);
    }
  }
#line 12488
  if (tmp_surf == (void *)0) {
    {
#line 12490
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back\226t\324U", dirname___149,
                  img_id);
#line 12491
    tmp_surf = load_starter_helper((char *)fname, "pngt\324U", & IMG_Load);
    }
  }
#line 12494
  if (tmp_surf != (void *)0) {
    {
#line 12496
    img_starter_bkgd = SDL_DisplayFormat(tmp_surf);
#line 12497
    SDL_FreeSurface(tmp_surf);
    }
  }
#line 12505
  if (img_starter != (void *)0) {
#line 12505
    if (img_starter_bkgd == (void *)0) {
#line 12509
      getpixel = getpixels[(img_starter->format)->BytesPerPixel];
#line 12510
      putpixel = putpixels[(img_starter->format)->BytesPerPixel];
#line 12515
      any_transparency = 0;
#line 12517
      y = 0;
      {
#line 12517
      while (1) {
        while_continue: /* CIL Label */ ;
#line 12517
        if (! (y < img_starter->h && ! any_transparency)) {
#line 12517
          goto while_break;
        }
#line 12519
        x = 0;
        {
#line 12519
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 12519
          if (! (x < img_starter->w && ! any_transparency)) {
#line 12519
            goto while_break___0;
          }
          {
#line 12521
          p = (*getpixel)(img_starter, x, y);
          }
#line 12524
          if ((int )a < 255) {
#line 12525
            any_transparency = 1;
          }
#line 12519
          x ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 12517
        y ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 12529
      if (! any_transparency) {
#line 12534
        y = 0;
        {
#line 12534
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 12534
          if (! (y < img_starter->h)) {
#line 12534
            goto while_break___1;
          }
#line 12536
          x = 0;
          {
#line 12536
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 12536
            if (! (x < img_starter->w)) {
#line 12536
              goto while_break___2;
            }
            {
#line 12538
            p = (*getpixel)(img_starter, x, y);
#line 12541
            __cil_tmp32 = abs((int )b - (int )g);
            }
            {
#line 12541
            __cil_tmp31 = abs((int )r - (int )b);
            }
            {
#line 12541
            __cil_tmp30 = abs((int )r - (int )g);
            }
#line 12541
            if (__cil_tmp30 < 16) {
#line 12541
              if (__cil_tmp31 < 16) {
#line 12541
                if (__cil_tmp32 < 16) {
#line 12543
                  a = (Uint8 )(255 - (((int )r + (int )g) + (int )b) / 3);
                }
              }
            }
            {
#line 12546
            p = (((((unsigned int )a & 255U) << 24) | (((unsigned int )r & 255U) << 16)) | (((unsigned int )g & 255U) << 8)) | ((unsigned int )b & 255U);
#line 12547
            (*putpixel)(img_starter, x, y, p);
            }
#line 12536
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 12534
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 12556
  if (img_starter != (void *)0) {
#line 12556
    if (img_starter->w != canvas->w) {
      {
#line 12558
      tmp_surf = img_starter;
      {
#line 12560
      img_starter = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(tmp_surf->format)->BitsPerPixel,
                                         (tmp_surf->format)->Rmask, (tmp_surf->format)->Gmask,
                                         (tmp_surf->format)->Bmask, (tmp_surf->format)->Amask);
      }
      {
#line 12567
      SDL_SetAlpha(tmp_surf, (Uint32 )16384, (Uint8 )255);
      }
      {
#line 12568
      autoscale_copy_smear_free(tmp_surf, img_starter, & NondefectiveBlit);
      }
      {
#line 12569
      SDL_SetAlpha(img_starter, (Uint32 )81920, (Uint8 )255);
      }
      }
    } else
#line 12556
    if (img_starter->h != canvas->h) {
      {
#line 12558
      tmp_surf = img_starter;
      {
#line 12560
      img_starter = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(tmp_surf->format)->BitsPerPixel,
                                         (tmp_surf->format)->Rmask, (tmp_surf->format)->Gmask,
                                         (tmp_surf->format)->Bmask, (tmp_surf->format)->Amask);
      }
      {
#line 12567
      SDL_SetAlpha(tmp_surf, (Uint32 )16384, (Uint8 )255);
      }
      {
#line 12568
      autoscale_copy_smear_free(tmp_surf, img_starter, & NondefectiveBlit);
      }
      {
#line 12569
      SDL_SetAlpha(img_starter, (Uint32 )81920, (Uint8 )255);
      }
      }
    }
  }
#line 12573
  if (img_starter_bkgd != (void *)0) {
#line 12573
    if (img_starter_bkgd->w != canvas->w) {
      {
#line 12575
      tmp_surf = img_starter_bkgd;
      {
#line 12577
      img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Bmask, (Uint32 )0);
      }
      {
#line 12582
      autoscale_copy_smear_free(tmp_surf, img_starter_bkgd, & SDL_UpperBlit);
      }
      }
    } else
#line 12573
    if (img_starter_bkgd->h != canvas->h) {
      {
#line 12575
      tmp_surf = img_starter_bkgd;
      {
#line 12577
      img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Bmask, (Uint32 )0);
      }
      {
#line 12582
      autoscale_copy_smear_free(tmp_surf, img_starter_bkgd, & SDL_UpperBlit);
      }
      }
    }
  }
  {
#line 12585
  free(dirname___149);
  }
  return;
}
}
#line 12592 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_template(char *img_id ) 
{ 
  char *dirname___150 ;
  char fname[256] ;
  SDL_Surface *tmp_surf ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;
  SDL_Surface *__cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;
  SDL_Surface *__cil_tmp11 ;
  SDL_Surface *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;

  {
#line 12600
  if (template_personal == 0) {
    {
#line 12601
    dirname___150 = strdup("/usr/local/share/tuxpaint/templates");
    }
  } else {
    {
#line 12603
    dirname___150 = get_fname("templates", 0);
    }
  }
  {
#line 12606
  img_starter = (SDL_Surface *)((void *)0);
#line 12607
  img_starter_bkgd = (SDL_Surface *)((void *)0);
#line 12610
  safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___150, img_id);
#line 12611
  tmp_surf = load_starter_helper((char *)fname, "kpx", & myIMG_Load);
  }
#line 12615
  if (tmp_surf == (void *)0) {
    {
#line 12617
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___150, img_id);
#line 12618
    tmp_surf = load_starter_helper((char *)fname, "svg", & load_svg);
    }
  }
#line 12623
  if (tmp_surf == (void *)0) {
    {
#line 12625
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___150, img_id);
#line 12626
    tmp_surf = load_starter_helper((char *)fname, "jpeg", & IMG_Load);
    }
  }
#line 12628
  if (tmp_surf == (void *)0) {
    {
#line 12631
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___150, img_id);
#line 12632
    tmp_surf = load_starter_helper((char *)fname, "jpg", & IMG_Load);
    }
  }
#line 12636
  if (tmp_surf == (void *)0) {
    {
#line 12638
    safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___150, img_id);
#line 12639
    tmp_surf = load_starter_helper((char *)fname, "png", & IMG_Load);
    }
  }
#line 12642
  if (tmp_surf != (void *)0) {
    {
#line 12644
    img_starter_bkgd = SDL_DisplayFormat(tmp_surf);
#line 12645
    SDL_FreeSurface(tmp_surf);
    }
  }
#line 12651
  if (img_starter_bkgd != (void *)0) {
#line 12651
    if (img_starter_bkgd->w != canvas->w) {
      {
#line 12653
      tmp_surf = img_starter_bkgd;
      {
#line 12655
      img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Bmask, (Uint32 )0);
      }
      {
#line 12660
      autoscale_copy_smear_free(tmp_surf, img_starter_bkgd, & SDL_UpperBlit);
      }
      }
    } else
#line 12651
    if (img_starter_bkgd->h != canvas->h) {
      {
#line 12653
      tmp_surf = img_starter_bkgd;
      {
#line 12655
      img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Bmask, (Uint32 )0);
      }
      {
#line 12660
      autoscale_copy_smear_free(tmp_surf, img_starter_bkgd, & SDL_UpperBlit);
      }
      }
    }
  }
  {
#line 12663
  free(dirname___150);
  }
  return;
}
}
#line 12671 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_current(void) 
{ 
  SDL_Surface *tmp ;
  SDL_Surface *org_surf ;
  char *fname ;
  char ftmp[1024] ;
  FILE *fi ;
  char *__cil_tmp6 ;
  FILE *__cil_tmp7 ;
  int *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  char *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;
  char *__cil_tmp15 ;
  SDL_Surface *__cil_tmp16 ;

  {
  {
#line 12680
  fname = get_fname("current_id.txt", 0);
#line 12682
  fi = fopen((char const   *)fname, "r");
  }
#line 12683
  if (fi == (void *)0) {
    {
#line 12685
    __cil_tmp8 = __errno_location();
#line 12685
    __cil_tmp9 = strerror(*__cil_tmp8);
#line 12685
    fprintf(stderr, "\nWarning: Couldn\'t determine the current image\'s ID\n%s\nThe system error that occurred was:\n%s\n\n",
            fname, __cil_tmp9);
#line 12688
    file_id[0] = (char )'\000';
#line 12689
    starter_id[0] = (char )'\000';
#line 12690
    template_id[0] = (char )'\000';
    }
  } else {
    {
#line 12694
    __cil_tmp10 = fgets((char *)file_id, (int )sizeof(file_id), fi);
    }
#line 12694
    if (__cil_tmp10) {
      {
#line 12696
      __cil_tmp11 = strlen((char const   *)((char *)file_id));
      }
#line 12696
      if (__cil_tmp11 > 0UL) {
        {
#line 12698
        __cil_tmp12 = strlen((char const   *)((char *)file_id));
#line 12698
        file_id[__cil_tmp12 - 1UL] = (char )'\000';
        }
      }
    }
    {
#line 12701
    fclose(fi);
    }
  }
  {
#line 12704
  free(fname);
  }
#line 12709
  if ((int )file_id[0] != 0) {
    {
#line 12712
    start_label_node = (struct label_node *)((void *)0);
#line 12713
    current_label_node = (struct label_node *)((void *)0);
#line 12714
    first_label_node_in_redo_stack = (struct label_node *)((void *)0);
#line 12715
    highlighted_label_node = (struct label_node *)((void *)0);
#line 12716
    label_node_to_edit = (struct label_node *)((void *)0);
#line 12717
    have_to_rec_label_node = 0;
#line 12719
    safe_snprintf((char *)ftmp, sizeof(ftmp), "saved/%s%s", (char *)file_id, ".png");
#line 12720
    fname = get_fname((char const   *)((char *)ftmp), 0);
#line 12722
    tmp = myIMG_Load_RWops((char const   *)fname);
    }
#line 12724
    if (tmp == (void *)0) {
      {
#line 12726
      __cil_tmp15 = SDL_GetError();
#line 12726
      fprintf(stderr, "\nWarning: Couldn\'t load any current image.\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              fname, __cil_tmp15);
#line 12730
      file_id[0] = (char )'\000';
#line 12731
      starter_id[0] = (char )'\000';
#line 12732
      template_id[0] = (char )'\000';
      }
    } else {
      {
#line 12736
      org_surf = SDL_DisplayFormat(tmp);
#line 12737
      autoscale_copy_smear_free(tmp, canvas, & SDL_UpperBlit);
#line 12741
      load_starter_id((char *)file_id, (FILE *)((void *)0));
      }
#line 12742
      if ((int )starter_id[0] != 0) {
        {
#line 12744
        load_starter((char *)starter_id);
        }
#line 12746
        if (starter_mirrored) {
          {
#line 12747
          mirror_starter();
          }
        }
#line 12749
        if (starter_flipped) {
          {
#line 12750
          flip_starter();
          }
        }
      } else
#line 12752
      if ((int )template_id[0] != 0) {
        {
#line 12754
        load_template((char *)template_id);
        }
      }
      {
#line 12757
      load_embedded_data(fname, org_surf);
      }
    }
    {
#line 12760
    free(fname);
    }
  }
  return;
}
}
#line 12769 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int make_directory(int dir_type , char const   *path , char const   *errmsg ) 
{ 
  char *fname ;
  int res ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;
  int *__cil_tmp8 ;
  int *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 12774
  fname = get_fname(path, dir_type);
#line 12775
  res = mkdir((char const   *)fname, (__mode_t )493);
#line 12776
  __cil_tmp8 = __errno_location();
  }
#line 12776
  if (res != 0) {
#line 12776
    if (*__cil_tmp8 != 17) {
      {
#line 12778
      __cil_tmp9 = __errno_location();
#line 12778
      __cil_tmp10 = strerror(*__cil_tmp9);
#line 12778
      fprintf(stderr, "\nError: %s:\n%s\nThe error that occurred was:\n%s\n\n", errmsg,
              fname, __cil_tmp10);
#line 12780
      free(fname);
      }
#line 12781
      return (0);
    }
  }
  {
#line 12783
  free(fname);
  }
#line 12784
  return (1);
}
}
#line 12791 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void save_current(void) 
{ 
  char *fname ;
  FILE *fi ;
  int __cil_tmp3 ;
  int *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  FILE *__cil_tmp7 ;
  int *__cil_tmp8 ;
  char *__cil_tmp9 ;
  int *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 12796
  __cil_tmp3 = make_directory(0, "\323\001 ", "Can\'t create user data directory (E001)");
  }
#line 12796
  if (! __cil_tmp3) {
    {
#line 12798
    __cil_tmp4 = __errno_location();
#line 12798
    __cil_tmp5 = strerror(*__cil_tmp4);
#line 12798
    draw_tux_text(4, (char const   *)__cil_tmp5, 0);
    }
#line 12799
    return;
  }
  {
#line 12802
  fname = get_fname("current_id.txt", 0);
#line 12804
  fi = fopen((char const   *)fname, "w");
  }
#line 12805
  if (fi == (void *)0) {
    {
#line 12807
    __cil_tmp8 = __errno_location();
#line 12807
    __cil_tmp9 = strerror(*__cil_tmp8);
#line 12807
    fprintf(stderr, "\nError: Can\'t keep track of current image.\n%s\nThe error that occurred was:\n%s\n\nt\324U",
            fname, __cil_tmp9);
#line 12811
    __cil_tmp10 = __errno_location();
#line 12811
    __cil_tmp11 = strerror(*__cil_tmp10);
#line 12811
    draw_tux_text(4, (char const   *)__cil_tmp11, 0);
    }
  } else {
    {
#line 12815
    fprintf(fi, "%s\n", (char *)file_id);
#line 12816
    fclose(fi);
    }
  }
  {
#line 12819
  free(fname);
  }
  return;
}
}
#line 12827 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt(char const   *text , char const   *btn_yes , char const   *btn_no ,
                     int ox , int oy ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 12829
  __cil_tmp6 = do_prompt_image(text, btn_yes, btn_no, (SDL_Surface *)((void *)0),
                               (SDL_Surface *)((void *)0), (SDL_Surface *)((void *)0),
                               ox, oy);
  }
#line 12829
  return (__cil_tmp6);
}
}
#line 12835 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt_snd(char const   *text , char const   *btn_yes , char const   *btn_no ,
                         int snd , int ox , int oy ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 12838
  __cil_tmp7 = do_prompt_image_flash_snd(text, btn_yes, btn_no, (SDL_Surface *)((void *)0),
                                         (SDL_Surface *)((void *)0), (SDL_Surface *)((void *)0),
                                         0, snd, ox, oy);
  }
#line 12838
  return (__cil_tmp7);
}
}
#line 12844 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt_image(char const   *text , char const   *btn_yes , char const   *btn_no ,
                           SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                           int ox , int oy ) 
{ 
  int __cil_tmp9 ;

  {
  {
#line 12848
  __cil_tmp9 = do_prompt_image_snd(text, btn_yes, btn_no, img1, img2, img3, - 1, ox,
                                   oy);
  }
#line 12848
  return (__cil_tmp9);
}
}
#line 12854 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt_image_snd(char const   *text , char const   *btn_yes , char const   *btn_no ,
                               SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                               int snd , int ox , int oy ) 
{ 
  int __cil_tmp10 ;

  {
  {
#line 12859
  __cil_tmp10 = do_prompt_image_flash_snd(text, btn_yes, btn_no, img1, img2, img3,
                                          0, snd, ox, oy);
  }
#line 12859
  return (__cil_tmp10);
}
}
#line 12865 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt_image_flash(char const   *text , char const   *btn_yes , char const   *btn_no ,
                                 SDL_Surface *img1 , SDL_Surface *img2 , SDL_Surface *img3 ,
                                 int animate , int ox , int oy ) 
{ 
  int __cil_tmp10 ;

  {
  {
#line 12870
  __cil_tmp10 = do_prompt_image_flash_snd(text, btn_yes, btn_no, img1, img2, img3,
                                          animate, - 1, ox, oy);
  }
#line 12870
  return (__cil_tmp10);
}
}
#line 12879 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_prompt_image_flash_snd(char const   *text , char const   *btn_yes ,
                                     char const   *btn_no , SDL_Surface *img1 , SDL_Surface *img2 ,
                                     SDL_Surface *img3 , int animate , int snd , int ox ,
                                     int oy ) 
{ 
  int oox ;
  int ooy ;
  int nx ;
  int ny ;
  SDL_Event event ;
  SDL_Rect dest ;
  SDL_Rect dest_back ;
  int done ;
  int ans ;
  int w ;
  int counter ;
  SDL_Color black ;
  SDLKey key ;
  SDLKey key_y ;
  SDLKey key_n ;
  char *keystr ;
  SDL_Surface *backup ;
  int i ;
  SDL_Surface *alpha_surf ;
  int img1_w ;
  int img2_w ;
  int img3_w ;
  int max_img_w ;
  int img_y ;
  int offset ;
  SDL_Surface *img1b ;
  int free_img1b ;
  int txt_left ;
  int txt_right ;
  int img_left ;
  int btn_left ;
  int txt_btn_left ;
  int txt_btn_right ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  SDL_Surface *__cil_tmp54 ;
  SDL_Surface *__cil_tmp55 ;
  SDL_Surface *__cil_tmp56 ;
  unsigned long __cil_tmp57 ;
  int __cil_tmp58 ;
  unsigned long __cil_tmp59 ;
  int __cil_tmp60 ;
  unsigned long __cil_tmp61 ;
  unsigned long __cil_tmp62 ;
  int __cil_tmp63 ;

  {
#line 12889
  black.r = (Uint8 )0;
#line 12889
  black.g = (Uint8 )0;
#line 12889
  black.b = (Uint8 )0;
  {
#line 12889
  black.unused = (Uint8 )0;
#line 12919
  motioner = 0;
#line 12919
  val_y = motioner;
#line 12919
  val_x = val_y;
#line 12920
  hatmotioner = 0;
#line 12920
  valhat_y = hatmotioner;
#line 12920
  valhat_x = valhat_y;
#line 12921
  emulate_button_pressed = 0;
#line 12923
  hide_blinking_cursor();
#line 12927
  __cil_tmp50 = dcgettext((char const   *)((void *)0), "Yes", 5);
#line 12927
  __cil_tmp51 = textdir((char const   *)__cil_tmp50);
#line 12927
  keystr = __cil_tmp51;
#line 12928
  key_y = (SDLKey )0;
#line 12929
  free(keystr);
#line 12931
  __cil_tmp52 = dcgettext((char const   *)((void *)0), "No", 5);
#line 12931
  __cil_tmp53 = textdir((char const   *)__cil_tmp52);
#line 12931
  keystr = __cil_tmp53;
#line 12932
  key_n = (SDLKey )0;
#line 12933
  free(keystr);
#line 12936
  do_setcursor(cursor_arrow);
#line 12941
  playsound(screen, 0, 15, 1, - 998, - 999);
#line 12943
  backup = SDL_CreateRGBSurface(screen->flags, screen->w, screen->h, (int )(screen->format)->BitsPerPixel,
                                (screen->format)->Rmask, (screen->format)->Gmask,
                                (screen->format)->Bmask, (screen->format)->Amask);
#line 12948
  SDL_UpperBlit(screen, (SDL_Rect *)((void *)0), backup, (SDL_Rect *)((void *)0));
#line 12950
  w = 0;
  }
  {
#line 12950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12950
    if (! (w <= (int )r_ttools.w)) {
#line 12950
      goto while_break;
    }
    {
#line 12952
    oox = ox - w;
#line 12953
    ooy = oy - w;
#line 12955
    nx = (((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + (int )r_ttools.w) - w) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2;
#line 12956
    ny = (2 + canvas->h / 2) - w;
#line 12958
    dest.x = (Sint16 )((nx * w + oox * ((int )r_ttools.w - w)) / (int )r_ttools.w);
#line 12959
    dest.y = (Sint16 )((ny * w + ooy * ((int )r_ttools.w - w)) / (int )r_ttools.w);
#line 12960
    dest.w = (Uint16 )((0 - (int )r_ttools.w * 2) + w * 2);
#line 12961
    dest.h = (Uint16 )(w * 2);
#line 12962
    SDL_FillRect(screen, & dest, ((((unsigned int )(224 - (int )((float )w / button_scale)) & 255U) << 16) | (((unsigned int )(224 - (int )((float )w / button_scale)) & 255U) << 8)) | ((unsigned int )(244 - (int )((float )w / button_scale)) & 255U));
#line 12964
    SDL_UpdateRect(screen, (Sint32 )dest.x, (Sint32 )dest.y, (Uint32 )dest.w, (Uint32 )dest.h);
    }
#line 12966
    if (w % 8 == 0) {
      {
#line 12967
      SDL_Delay((Uint32 )1);
      }
    }
#line 12969
    if (w == (int )r_ttools.w - 2) {
      {
#line 12971
      SDL_UpperBlit(backup, (SDL_Rect *)((void *)0), screen, (SDL_Rect *)((void *)0));
      }
    }
#line 12950
    w += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12975
  SDL_FreeSurface(backup);
#line 12978
  playsound(screen, 1, snd, 1, - 997, - 999);
#line 12981
  alpha_surf = SDL_CreateRGBSurface((Uint32 )65536, (0 - (int )r_ttools.w * 2) + (w - 4) * 2,
                                    (w - 4) * 2, (int )(screen->format)->BitsPerPixel,
                                    (screen->format)->Rmask, (screen->format)->Gmask,
                                    (screen->format)->Bmask, (screen->format)->Amask);
  }
#line 12988
  if (alpha_surf != (void *)0) {
    {
#line 12990
    SDL_FillRect(alpha_surf, (SDL_Rect *)((void *)0), 0U);
#line 12991
    SDL_SetAlpha(alpha_surf, (Uint32 )65536, (Uint8 )64);
#line 12993
    i = 8;
    }
    {
#line 12993
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12993
      if (! (i > 0)) {
#line 12993
        goto while_break___0;
      }
      {
#line 12995
      dest.x = (Sint16 )(((((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + (int )r_ttools.w) - (w - 4)) + i) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2);
#line 12996
      dest.y = (Sint16 )(((((float )94 / button_scale + (float )((int )r_ttools.w) / button_scale) - (float )(w - 4)) + (float )i) + (float )((int )((Sint16 )((int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)) / 2))));
#line 12997
      dest.w = (Uint16 )((0 - (int )r_ttools.w * 2) + (w - 4) * 2);
#line 12998
      dest.h = (Uint16 )((w - 4) * 2);
#line 12999
      dest.y = (Sint16 )(((canvas->h / 2 - (int )dest.h / 2) + i) + 2);
#line 13000
      SDL_UpperBlit(alpha_surf, (SDL_Rect *)((void *)0), screen, & dest);
      }
#line 12993
      i -= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 13003
    SDL_FreeSurface(alpha_surf);
    }
  }
  {
#line 13008
  w -= 6;
#line 13010
  dest.x = (Sint16 )((((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + (int )r_ttools.w) - w) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2);
#line 13010
  dest_back.x = dest.x;
#line 13011
  dest.w = (Uint16 )((0 - (int )r_ttools.w * 2) + w * 2);
#line 13011
  dest_back.w = dest.w;
#line 13012
  dest.h = (Uint16 )(w * 2);
#line 13012
  dest_back.h = dest.h;
#line 13013
  dest.y = (Sint16 )((canvas->h / 2 - (int )dest.h / 2) + 2);
#line 13013
  dest_back.y = dest.y;
#line 13014
  SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 13020
  free_img1b = 0;
#line 13021
  img1b = (SDL_Surface *)((void *)0);
  }
#line 13023
  if (img1 != (void *)0) {
#line 13025
    if ((float )img1->h > (float )64 * button_scale) {
#line 13025
      if (img2 != (void *)0) {
        {
#line 13027
        img1b = thumbnail(img1, (int )((float )80 * button_scale), (int )((float )64 * button_scale),
                          1);
#line 13028
        free_img1b = 1;
        }
      } else {
#line 13032
        img1b = img1;
      }
    } else {
#line 13032
      img1b = img1;
    }
  }
#line 13040
  img3_w = 0;
#line 13040
  img2_w = img3_w;
#line 13040
  img1_w = img2_w;
#line 13040
  offset = img1_w;
#line 13042
  if (img1b != (void *)0) {
#line 13043
    img1_w = img1b->w;
  }
#line 13044
  if (img2 != (void *)0) {
#line 13045
    img2_w = img2->w;
  }
#line 13046
  if (img3 != (void *)0) {
#line 13047
    img3_w = img3->w;
  }
#line 13049
  max_img_w = 0;
#line 13051
  if (max_img_w > 0) {
#line 13052
    offset = max_img_w + 8;
  }
#line 13057
  if (need_right_to_left == 0) {
#line 13059
    txt_left = ((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + 6) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2;
#line 13060
    txt_right = (((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) - 5) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) - offset;
#line 13061
    img_left = ((((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) - 5) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) - max_img_w) - 4;
#line 13062
    btn_left = ((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + 6) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2;
#line 13063
    txt_btn_left = (txt_left + img_yes->w) + 4;
#line 13064
    txt_btn_right = txt_right;
  } else {
#line 13068
    txt_left = (((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + 6) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + offset;
#line 13069
    txt_right = ((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) - 5) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2;
#line 13070
    img_left = (((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) + 6) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + 4;
#line 13071
    btn_left = ((((int )((Sint16 )((((int )r_tools.w - (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) + canvas->w / 2) - 4)) - 5) + (int )((Sint16 )(WINDOW_WIDTH - 640)) / 2) - img_yes->w) - 4;
#line 13072
    txt_btn_left = txt_left;
#line 13073
    txt_btn_right = btn_left;
  }
  {
#line 13076
  wordwrap_text(text, black, txt_left, (int )dest.y + 2, txt_right, 1);
#line 13081
  img_y = (int )dest_back.y + 6;
  }
#line 13083
  if (img1b != (void *)0) {
    {
#line 13085
    dest.x = (Sint16 )(img_left + (max_img_w - img1b->w) / 2);
#line 13086
    dest.y = (Sint16 )img_y;
#line 13088
    SDL_UpperBlit(img1b, (SDL_Rect *)((void *)0), screen, & dest);
    }
#line 13090
    if (! animate) {
#line 13091
      img_y = (img_y + img1b->h) + 4;
    }
  }
#line 13094
  if (! animate) {
#line 13096
    if (img2 != (void *)0) {
      {
#line 13098
      dest.x = (Sint16 )(img_left + (max_img_w - img2->w) / 2);
#line 13099
      dest.y = (Sint16 )img_y;
#line 13101
      SDL_UpperBlit(img2, (SDL_Rect *)((void *)0), screen, & dest);
#line 13103
      img_y = (img_y + img2->h) + 4;
      }
    }
#line 13106
    if (img3 != (void *)0) {
      {
#line 13108
      dest.x = (Sint16 )(img_left + (max_img_w - img3->w) / 2);
#line 13109
      dest.y = (Sint16 )img_y;
#line 13111
      SDL_UpperBlit(img3, (SDL_Rect *)((void *)0), screen, & dest);
#line 13113
      img_y = (img_y + img3->h) + 4;
      }
    }
  }
  {
#line 13120
  dest.x = (Sint16 )btn_left;
#line 13121
  dest.y = (Sint16 )((((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) - 4) - button_h);
#line 13122
  SDL_UpperBlit(img_yes, (SDL_Rect *)((void *)0), screen, & dest);
#line 13127
  wordwrap_text(btn_yes, black, txt_btn_left, (int )dest.y + 5, txt_btn_right, 1);
#line 13132
  __cil_tmp57 = strlen(btn_no);
  }
#line 13132
  if (__cil_tmp57 != 0UL) {
    {
#line 13134
    dest.x = (Sint16 )btn_left;
#line 13135
    dest.y = (Sint16 )(((int )dest.y + button_h) + 4);
#line 13136
    SDL_UpperBlit(img_no, (SDL_Rect *)((void *)0), screen, & dest);
#line 13138
    wordwrap_text(btn_no, black, txt_btn_left, (int )dest.y + 5, txt_btn_right, 1);
    }
  }
  {
#line 13144
  draw_tux_text(2, "\251", 0);
#line 13146
  SDL_Flip(screen);
#line 13148
  done = 0;
#line 13149
  counter = 0;
#line 13150
  ans = 0;
  }
  {
#line 13152
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 13154
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 13154
      __cil_tmp58 = SDL_PollEvent(& event);
      }
#line 13154
      if (! __cil_tmp58) {
#line 13154
        goto while_break___2;
      }
#line 13156
      if ((int )event.type == 12) {
#line 13158
        ans = 0;
#line 13159
        done = 1;
      } else
#line 13161
      if ((int )event.type == 1) {
        {
#line 13163
        handle_active(& event);
        }
      } else
#line 13165
      if ((int )event.type == 3) {
        {
#line 13167
        key = event.key.keysym.sym;
#line 13169
        handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 13171
      if ((int )event.type == 2) {
        {
#line 13173
        key = event.key.keysym.sym;
#line 13175
        handle_keymouse(key, (Uint8 )2, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
#line 13180
        if ((unsigned int )key == (unsigned int )key_y) {
#line 13184
          ans = 1;
#line 13185
          done = 1;
        } else
#line 13180
        if ((unsigned int )key == 13U) {
#line 13184
          ans = 1;
#line 13185
          done = 1;
        } else
#line 13187
        if ((unsigned int )key == (unsigned int )key_n) {
          _L: /* CIL Label */ 
          {
#line 13191
          __cil_tmp59 = strlen(btn_no);
          }
#line 13191
          if (__cil_tmp59 != 0UL) {
#line 13193
            ans = 0;
#line 13194
            done = 1;
          } else
#line 13198
          if ((unsigned int )key == 27U) {
#line 13203
            ans = 1;
#line 13204
            done = 1;
          }
        } else
#line 13187
        if ((unsigned int )key == 27U) {
#line 13187
          goto _L;
        }
      } else {
        {
#line 13209
        __cil_tmp60 = valid_click(event.button.button);
        }
#line 13209
        if ((int )event.type == 5) {
#line 13209
          if (__cil_tmp60) {
#line 13211
            if ((int )event.button.x >= btn_left) {
#line 13211
              if ((int )event.button.x < btn_left + img_yes->w) {
#line 13213
                if ((int )event.button.y >= (((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) - 4) - button_h) {
#line 13213
                  if ((int )event.button.y < ((((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) - 4) - button_h) + img_yes->h) {
#line 13216
                    ans = 1;
#line 13217
                    done = 1;
                  } else {
#line 13213
                    goto _L___151;
                  }
                } else {
                  _L___151: /* CIL Label */ 
                  {
#line 13219
                  __cil_tmp61 = strlen(btn_no);
                  }
#line 13219
                  if (__cil_tmp61 != 0UL) {
#line 13219
                    if ((int )event.button.y >= (((int )dest_back.y + (int )dest_back.h) - 4) - button_h) {
#line 13219
                      if ((int )event.button.y < ((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) + img_no->h) {
#line 13223
                        ans = 0;
#line 13224
                        done = 1;
                      }
                    }
                  }
                }
              }
            }
          } else {
#line 13209
            goto _L___153;
          }
        } else
        _L___153: /* CIL Label */ 
#line 13228
        if ((int )event.type == 4) {
          {
#line 13230
          __cil_tmp62 = strlen(btn_no);
          }
#line 13230
          if ((int )event.button.x >= btn_left) {
#line 13230
            if ((int )event.button.x < btn_left + img_yes->w) {
#line 13230
              if ((int )event.button.y >= (((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) - 4) - button_h) {
#line 13230
                if ((int )event.button.y < ((((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) - 4) - button_h) + img_yes->h) {
                  {
                  {
#line 13238
                  do_setcursor(cursor_hand);
                  }
                  }
                } else {
#line 13230
                  goto _L___152;
                }
              } else
              _L___152: /* CIL Label */ 
#line 13230
              if (__cil_tmp62 != 0UL) {
#line 13230
                if ((int )event.button.y >= (((int )dest_back.y + (int )dest_back.h) - 4) - button_h) {
#line 13230
                  if ((int )event.button.y < ((((int )dest_back.y + (int )dest_back.h) - 4) - button_h) + img_no->h) {
                    {
                    {
#line 13238
                    do_setcursor(cursor_hand);
                    }
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 13242
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 13242
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 13242
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
                }
              }
            } else {
              {
              {
              {
              {
              {
#line 13242
              do_setcursor(cursor_arrow);
              }
              }
              }
              }
              }
            }
          } else {
            {
            {
            {
            {
            {
#line 13242
            do_setcursor(cursor_arrow);
            }
            }
            }
            }
            }
          }
#line 13244
          oldpos_x = (int )event.button.x;
#line 13245
          oldpos_y = (int )event.button.y;
        } else
#line 13248
        if ((int )event.type == 7) {
          {
#line 13249
          handle_joyaxismotion(event, & motioner, & val_x, & val_y);
          }
        } else
#line 13251
        if ((int )event.type == 9) {
          {
#line 13252
          handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                              & old_hat_ticks);
          }
        } else
#line 13255
        if ((int )event.type == 8) {
          {
#line 13256
          handle_joyballmotion(event, oldpos_x, oldpos_y);
          }
        } else
#line 13258
        if ((int )event.type == 10) {
          {
#line 13259
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 13262
    if (motioner | hatmotioner) {
      {
#line 13263
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 13266
    SDL_Delay((Uint32 )10);
    }
#line 13268
    if (animate) {
#line 13270
      counter ++;
#line 13272
      if (counter == 5) {
        {
#line 13274
        dest.x = (Sint16 )(img_left + (max_img_w - img2->w) / 2);
#line 13275
        dest.y = (Sint16 )img_y;
#line 13277
        SDL_UpperBlit(img2, (SDL_Rect *)((void *)0), screen, & dest);
#line 13278
        SDL_Flip(screen);
        }
      } else
#line 13280
      if (counter == 10) {
#line 13282
        if (img3 != (void *)0) {
          {
#line 13284
          dest.x = (Sint16 )(img_left + (max_img_w - img3->w) / 2);
#line 13285
          dest.y = (Sint16 )img_y;
#line 13287
          SDL_UpperBlit(img3, (SDL_Rect *)((void *)0), screen, & dest);
#line 13288
          SDL_Flip(screen);
          }
        } else {
#line 13291
          counter = 15;
        }
      }
#line 13294
      if (counter == 15) {
        {
#line 13296
        dest.x = (Sint16 )(img_left + (max_img_w - img1b->w) / 2);
#line 13297
        dest.y = (Sint16 )img_y;
#line 13299
        SDL_UpperBlit(img1b, (SDL_Rect *)((void *)0), screen, & dest);
#line 13300
        SDL_Flip(screen);
#line 13302
        counter = 0;
        }
      }
    }
#line 13152
    if (! (! done)) {
#line 13152
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 13315
  update_canvas(0, 0, canvas->w, canvas->h);
  }
#line 13317
  if (free_img1b) {
    {
#line 13318
    SDL_FreeSurface(img1b);
    }
  }
#line 13320
  return (ans);
}
}
#line 13328 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void cleanup(void) 
{ 
  int i ;
  int j ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  char *lock_fname ;
  time_t zero_time ;
  FILE *fi ;
  char *__cil_tmp13 ;
  FILE *__cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 13332
  j = 0;
  {
#line 13332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13332
    if (! (j < num_stamp_groups)) {
#line 13332
      goto while_break;
    }
#line 13334
    i = 0;
    {
#line 13334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 13334
      if (! (i < num_stamps[j])) {
#line 13334
        goto while_break___0;
      }
#line 13337
      if ((*(stamp_data[j] + i))->ssnd) {
        {
#line 13339
        Mix_FreeChunk((*(stamp_data[j] + i))->ssnd);
#line 13340
        (*(stamp_data[j] + i))->ssnd = (Mix_Chunk *)((void *)0);
        }
      }
#line 13342
      if ((*(stamp_data[j] + i))->sdesc) {
        {
#line 13344
        Mix_FreeChunk((*(stamp_data[j] + i))->sdesc);
#line 13345
        (*(stamp_data[j] + i))->sdesc = (Mix_Chunk *)((void *)0);
        }
      }
#line 13348
      if ((*(stamp_data[j] + i))->stxt) {
        {
#line 13350
        free((*(stamp_data[j] + i))->stxt);
#line 13351
        (*(stamp_data[j] + i))->stxt = (char *)((void *)0);
        }
      }
      {
#line 13353
      free_surface(& (*(stamp_data[j] + i))->thumbnail);
#line 13355
      free((*(stamp_data[j] + i))->stampname);
#line 13356
      free(*(stamp_data[j] + i));
#line 13357
      *(stamp_data[j] + i) = (stamp_type *)((void *)0);
      }
#line 13334
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 13359
    free(stamp_data[j]);
    }
#line 13332
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 13361
  free_surface(& active_stamp);
#line 13363
  free_surface_array(img_brushes, num_brushes);
#line 13364
  free_surface_array(img_brushes_thumbs, num_brushes);
#line 13365
  free(brushes_frames);
#line 13366
  free(brushes_directional);
#line 13367
  free(brushes_rotate);
#line 13368
  free(brushes_spacing);
#line 13369
  free_surface_array((SDL_Surface **)img_tools, 16);
#line 13370
  free_surface_array((SDL_Surface **)img_tool_names, 16);
#line 13371
  free_surface_array((SDL_Surface **)img_title_names, 11);
#line 13372
  i = 0;
  }
  {
#line 13372
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 13372
    if (! (i < 16)) {
#line 13372
      goto while_break___1;
    }
#line 13374
    j = 0;
    {
#line 13374
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 13374
      if (! (j < num_magics[i])) {
#line 13374
        goto while_break___2;
      }
      {
#line 13376
      free_surface(& magics[i][j].img_icon);
#line 13377
      free_surface(& magics[i][j].img_name);
      }
#line 13374
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 13372
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 13380
  free_surface_array((SDL_Surface **)img_shapes, 22);
#line 13381
  free_surface_array((SDL_Surface **)img_shape_names, 22);
#line 13382
  free_surface_array((SDL_Surface **)img_fills, 4);
#line 13383
  free_surface_array((SDL_Surface **)img_fill_names, 4);
#line 13384
  free_surface_array((SDL_Surface **)img_tux, 6);
#line 13386
  free_surface(& img_openlabels_open);
#line 13387
  free_surface(& img_openlabels_slideshow);
#line 13388
  free_surface(& img_openlabels_erase);
#line 13389
  free_surface(& img_openlabels_pict_export);
#line 13390
  free_surface(& img_openlabels_back);
#line 13391
  free_surface(& img_openlabels_next);
#line 13392
  free_surface(& img_openlabels_play);
#line 13393
  free_surface(& img_openlabels_gif_export);
#line 13395
  free_surface(& img_progress);
#line 13397
  free_surface(& img_yes);
#line 13398
  free_surface(& img_no);
#line 13400
  free_surface(& img_prev);
#line 13401
  free_surface(& img_next);
#line 13403
  free_surface(& img_mirror);
#line 13404
  free_surface(& img_flip);
#line 13406
  free_surface(& img_title_on);
#line 13407
  free_surface(& img_title_off);
#line 13408
  free_surface(& img_title_large_on);
#line 13409
  free_surface(& img_title_large_off);
#line 13411
  free_surface(& img_open);
#line 13412
  free_surface(& img_erase);
#line 13413
  free_surface(& img_pict_export);
#line 13414
  free_surface(& img_back);
#line 13415
  free_surface(& img_trash);
#line 13417
  free_surface(& img_slideshow);
#line 13418
  free_surface(& img_play);
#line 13419
  free_surface(& img_gif_export);
#line 13420
  free_surface(& img_select_digits);
#line 13422
  free_surface(& img_dead40x40);
#line 13424
  free_surface(& img_printer);
#line 13425
  free_surface(& img_printer_wait);
#line 13426
  free_surface(& img_save_over);
#line 13428
  free_surface(& img_btn_up);
#line 13429
  free_surface(& img_btn_down);
#line 13430
  free_surface(& img_btn_off);
#line 13431
  free_surface(& img_btn_hold);
#line 13433
  free_surface(& img_btnsm_up);
#line 13434
  free_surface(& img_btnsm_off);
#line 13435
  free_surface(& img_btnsm_down);
#line 13436
  free_surface(& img_btnsm_hold);
#line 13438
  free_surface(& img_btn_nav);
#line 13439
  free_surface(& img_btnsm_nav);
#line 13441
  free_surface(& img_brush_anim);
#line 13442
  free_surface(& img_brush_dir);
#line 13444
  free_surface(& img_sfx);
#line 13445
  free_surface(& img_speak);
#line 13447
  free_surface(& img_cursor_up);
#line 13448
  free_surface(& img_cursor_down);
#line 13450
  free_surface(& img_cursor_starter_up);
#line 13451
  free_surface(& img_cursor_starter_down);
#line 13453
  free_surface(& img_scroll_up);
#line 13454
  free_surface(& img_scroll_down);
#line 13455
  free_surface(& img_scroll_up_off);
#line 13456
  free_surface(& img_scroll_down_off);
#line 13458
  free_surface(& img_grow);
#line 13459
  free_surface(& img_shrink);
#line 13461
  free_surface(& img_magic_paint);
#line 13462
  free_surface(& img_magic_fullscreen);
#line 13464
  free_surface(& img_shapes_center);
#line 13465
  free_surface(& img_shapes_corner);
#line 13467
  free_surface(& img_bold);
#line 13468
  free_surface(& img_italic);
#line 13470
  free_surface_array((SDL_Surface **)undo_bufs, 20);
#line 13475
  free_surface_array(img_color_btns, NUM_COLORS * 2);
#line 13476
  free(img_color_btns);
  }
#line 13479
  if (onscreen_keyboard) {
    {
#line 13481
    free_surface(& img_oskdel);
#line 13482
    free_surface(& img_osktab);
#line 13483
    free_surface(& img_oskenter);
#line 13484
    free_surface(& img_oskcapslock);
#line 13485
    free_surface(& img_oskshift);
    }
  }
  {
#line 13488
  free_surface(& screen);
#line 13489
  free_surface(& img_starter);
#line 13490
  free_surface(& img_starter_bkgd);
#line 13491
  free_surface(& canvas);
#line 13492
  free_surface(& save_canvas);
#line 13493
  free_surface(& img_cur_brush);
  }
#line 13495
  if (touched != (void *)0) {
    {
#line 13497
    free(touched);
#line 13498
    touched = (Uint8 *)((void *)0);
    }
  }
#line 13501
  if (sim_flood_touched != (void *)0) {
    {
#line 13503
    free(sim_flood_touched);
#line 13504
    sim_flood_touched = (Uint8 *)((void *)0);
    }
  }
#line 13507
  if (medium_font != (void *)0) {
    {
#line 13512
    TuxPaint_Font_CloseFont(medium_font);
#line 13513
    medium_font = (TuxPaint_Font *)((void *)0);
    }
  }
#line 13516
  if (small_font != (void *)0) {
    {
#line 13521
    TuxPaint_Font_CloseFont(small_font);
#line 13522
    small_font = (TuxPaint_Font *)((void *)0);
    }
  }
#line 13525
  if (large_font != (void *)0) {
    {
#line 13530
    TuxPaint_Font_CloseFont(large_font);
#line 13531
    large_font = (TuxPaint_Font *)((void *)0);
    }
  }
  {
#line 13535
  free(user_font_families);
  }
#line 13562
  if (use_sound) {
#line 13564
    i = 0;
    {
#line 13564
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 13564
      if (! (i < 31)) {
#line 13564
        goto while_break___3;
      }
#line 13566
      if (sounds[i]) {
        {
#line 13568
        Mix_FreeChunk(sounds[i]);
#line 13569
        sounds[i] = (Mix_Chunk *)((void *)0);
        }
      }
#line 13564
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 13573
    Mix_CloseAudio();
    }
  }
#line 13577
  i = 0;
  {
#line 13577
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 13577
    if (! (i < num_plugin_files)) {
#line 13577
      goto while_break___4;
    }
    {
#line 13578
    (*(magic_funcs[i].shutdown))(magic_api_struct);
    }
#line 13577
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 13580
  free_cursor(& cursor_hand);
#line 13581
  free_cursor(& cursor_arrow);
#line 13582
  free_cursor(& cursor_watch);
#line 13583
  free_cursor(& cursor_up);
#line 13584
  free_cursor(& cursor_down);
#line 13585
  free_cursor(& cursor_tiny);
#line 13586
  free_cursor(& cursor_crosshair);
#line 13587
  free_cursor(& cursor_brush);
#line 13588
  free_cursor(& cursor_wand);
#line 13589
  free_cursor(& cursor_insertion);
#line 13590
  free_cursor(& cursor_rotate);
#line 13592
  i = 0;
  }
  {
#line 13592
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 13592
    if (! (i < NUM_COLORS)) {
#line 13592
      goto while_break___5;
    }
    {
#line 13594
    free(*(color_hexes + i));
#line 13595
    free(*(color_names + i));
    }
#line 13592
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 13597
  free(color_hexes);
#line 13598
  free(color_names);
#line 13603
  SDL_WM_GrabInput((SDL_GrabMode )0);
  }
#line 13609
  if (ok_to_use_lockfile) {
    {
#line 13616
    lock_fname = get_fname("lockfile.dat", 0);
#line 13621
    zero_time = (time_t )0;
#line 13623
    fi = fopen((char const   *)lock_fname, "w");
    }
#line 13624
    if (fi != (void *)0) {
      {
#line 13628
      fwrite(& zero_time, sizeof(time_t ), (unsigned long )1, fi);
#line 13629
      fclose(fi);
      }
    } else {
      {
#line 13633
      __cil_tmp15 = __errno_location();
#line 13633
      __cil_tmp16 = strerror(*__cil_tmp15);
#line 13633
      fprintf(stderr, "\nWarning: I couldn\'t create the lockfile (%s)\nThe error that occurred was:\n%s\n\n",
              lock_fname, __cil_tmp16);
      }
    }
    {
#line 13638
    free(lock_fname);
    }
  }
#line 13641
  if (kbd) {
    {
#line 13642
    osk_free(kbd);
    }
  }
  {
#line 13654
  TTF_Quit();
#line 13655
  SDL_Quit();
  }
  return;
}
}
#line 13673 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void free_surface(SDL_Surface **surface_array ) 
{ 


  {
#line 13675
  if (surface_array) {
#line 13676
    if (*surface_array) {
      {
#line 13678
      SDL_FreeSurface(*surface_array);
#line 13679
      *surface_array = (SDL_Surface *)((void *)0);
      }
    }
  }
  return;
}
}
#line 13687 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void free_surface_array(SDL_Surface *surface_array[] , int count ) 
{ 
  int i ;

  {
#line 13691
  if (surface_array) {
#line 13692
    i = 0;
    {
#line 13692
    while (1) {
      while_continue: /* CIL Label */ ;
#line 13692
      if (! (i < count)) {
#line 13692
        goto while_break;
      }
      {
#line 13694
      free_surface(& surface_array[i]);
      }
#line 13692
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 13703 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_shape(int sx , int sy , int nx , int ny , int rotn , int use_brush ) 
{ 
  int side ;
  int angle_skip ;
  int init_ang ;
  int rx ;
  int ry ;
  int rmax ;
  int x1 ;
  int y1___0 ;
  int x2 ;
  int y2 ;
  int xp ;
  int yp ;
  int xv ;
  int yv ;
  int old_brush ;
  int step ;
  float a1 ;
  float a2 ;
  float rotn_rad ;
  int xx ;
  int yy ;
  int offx ;
  int offy ;
  int max_x ;
  int max_y ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  double __cil_tmp34 ;
  double __cil_tmp35 ;
  double __cil_tmp36 ;
  double __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  double __cil_tmp49 ;
  double __cil_tmp50 ;
  double __cil_tmp51 ;
  double __cil_tmp52 ;
  double __cil_tmp53 ;
  double __cil_tmp54 ;
  double __cil_tmp55 ;
  double __cil_tmp56 ;
  double __cil_tmp57 ;
  double __cil_tmp58 ;
  double __cil_tmp59 ;
  double __cil_tmp60 ;
  double __cil_tmp61 ;
  double __cil_tmp62 ;
  double __cil_tmp63 ;
  double __cil_tmp64 ;
  double __cil_tmp65 ;
  double __cil_tmp66 ;
  double __cil_tmp67 ;
  double __cil_tmp68 ;
  double __cil_tmp69 ;
  double __cil_tmp70 ;
  double __cil_tmp71 ;
  double __cil_tmp72 ;
  double __cil_tmp73 ;
  double __cil_tmp74 ;
  double __cil_tmp75 ;
  double __cil_tmp76 ;
  double __cil_tmp77 ;
  double __cil_tmp78 ;
  double __cil_tmp79 ;
  double __cil_tmp80 ;
  double __cil_tmp81 ;
  double __cil_tmp82 ;
  double __cil_tmp83 ;
  double __cil_tmp84 ;
  double __cil_tmp85 ;
  double __cil_tmp86 ;
  double __cil_tmp87 ;
  double __cil_tmp88 ;
  double __cil_tmp89 ;
  double __cil_tmp90 ;
  int __cil_tmp91 ;
  int __cil_tmp92 ;
  int __cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;

  {
  {
#line 13712
  old_brush = 0;
#line 13714
  rx = abs(nx - sx);
#line 13715
  ry = abs(ny - sy);
  }
#line 13716
  if (shape_mode == 1) {
    {
#line 13718
    __cil_tmp34 = sqrt((double )(rx * rx));
#line 13718
    rx = (int )(__cil_tmp34 / (double )2);
#line 13719
    __cil_tmp35 = sqrt((double )(ry * ry));
#line 13719
    ry = (int )(__cil_tmp35 / (double )2);
    }
  }
#line 13724
  if (shape_locked[cur_shape]) {
#line 13726
    if (rx > ry) {
#line 13727
      ry = rx;
    } else {
#line 13729
      rx = ry;
    }
  }
#line 13735
  if (rx < 15) {
#line 13735
    if (ry < 15) {
#line 13737
      rx = 15;
#line 13738
      ry = 15;
    }
  }
#line 13741
  if (rx < 2) {
#line 13742
    rx = 2;
  }
#line 13743
  if (ry < 2) {
#line 13744
    ry = 2;
  }
#line 13749
  if (use_brush) {
    {
#line 13751
    old_brush = cur_brush;
#line 13752
    cur_brush = shape_brush;
#line 13753
    render_brush();
    }
  }
#line 13759
  angle_skip = 360 / shape_sides[cur_shape];
#line 13761
  init_ang = shape_init_ang[cur_shape];
#line 13764
  if (shape_mode == 1) {
#line 13774
    max_x = 0;
#line 13775
    max_y = 0;
#line 13776
    side = 0;
    {
#line 13776
    while (1) {
      while_continue: /* CIL Label */ ;
#line 13776
      if (! (side < shape_sides[cur_shape])) {
#line 13776
        goto while_break;
      }
      {
#line 13778
      a1 = (float )(((double )(angle_skip * side + init_ang) * 3.14159265359) / (double )180);
#line 13779
      a2 = (float )(((double )(angle_skip * (side + 1) + init_ang) * 3.14159265359) / (double )180);
#line 13780
      __cil_tmp36 = cos((double )a1);
#line 13780
      x1 = (int )(__cil_tmp36 * (double )rx);
#line 13781
      __cil_tmp37 = sin((double )a1);
#line 13781
      y1___0 = (int )(- __cil_tmp37 * (double )ry);
#line 13783
      __cil_tmp38 = abs(x1);
      }
#line 13783
      if (__cil_tmp38 > max_x) {
        {
#line 13784
        max_x = abs(x1);
        }
      }
      {
#line 13785
      __cil_tmp40 = abs(y1___0);
      }
#line 13785
      if (__cil_tmp40 > max_y) {
        {
#line 13786
        max_y = abs(y1___0);
        }
      }
#line 13776
      side ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 13789
    if (max_x < rx) {
#line 13790
      rx = (rx * rx) / max_x;
    }
#line 13791
    if (max_y < ry) {
#line 13792
      ry = (ry * ry) / max_y;
    }
  }
#line 13796
  step = 1;
#line 13798
  if (dont_do_xor) {
#line 13798
    if (! use_brush) {
#line 13803
      if (shape_sides[cur_shape] > 5) {
#line 13804
        step = shape_sides[cur_shape] / 8;
      }
    }
  }
#line 13809
  if (shape_mode == 0) {
#line 13810
    offx = 0;
#line 13811
    offy = 0;
  } else {
#line 13813
    offx = (nx - sx) / 2;
#line 13814
    offy = (ny - sy) / 2;
#line 13816
    if (shape_locked[cur_shape]) {
      {
#line 13818
      __cil_tmp44 = abs(offy);
      }
      {
#line 13818
      __cil_tmp43 = abs(offx);
      }
#line 13818
      if (__cil_tmp43 > __cil_tmp44) {
#line 13820
        if (offy > 0) {
          {
#line 13821
          offy = abs(offx);
          }
        } else {
          {
#line 13823
          __cil_tmp46 = abs(offx);
#line 13823
          offy = - __cil_tmp46;
          }
        }
      } else
#line 13827
      if (offx > 0) {
        {
#line 13828
        offx = abs(offy);
        }
      } else {
        {
#line 13830
        __cil_tmp48 = abs(offy);
#line 13830
        offx = - __cil_tmp48;
        }
      }
    }
  }
#line 13835
  side = 0;
  {
#line 13835
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 13835
    if (! (side < shape_sides[cur_shape])) {
#line 13835
      goto while_break___0;
    }
    {
#line 13837
    a1 = (float )(((double )(angle_skip * side + init_ang) * 3.14159265359) / (double )180);
#line 13838
    a2 = (float )(((double )(angle_skip * (side + 1) + init_ang) * 3.14159265359) / (double )180);
#line 13840
    __cil_tmp49 = cos((double )a1);
#line 13840
    x1 = (int )(__cil_tmp49 * (double )rx);
#line 13841
    __cil_tmp50 = sin((double )a1);
#line 13841
    y1___0 = (int )(- __cil_tmp50 * (double )ry);
#line 13843
    __cil_tmp51 = cos((double )a2);
#line 13843
    x2 = (int )(__cil_tmp51 * (double )rx);
#line 13844
    __cil_tmp52 = sin((double )a2);
#line 13844
    y2 = (int )(- __cil_tmp52 * (double )ry);
#line 13846
    __cil_tmp53 = cos((double )((a1 + a2) / (float )2));
#line 13846
    xv = (int )(((__cil_tmp53 * (double )rx) * (double )shape_valley[cur_shape]) / (double )100);
#line 13847
    __cil_tmp54 = sin((double )((a1 + a2) / (float )2));
#line 13847
    yv = (int )(((- __cil_tmp54 * (double )ry) * (double )shape_valley[cur_shape]) / (double )100);
    }
#line 13851
    if (rotn != 0) {
      {
#line 13853
      rotn_rad = (float )(((double )rotn * 3.14159265359) / (double )180);
#line 13855
      __cil_tmp56 = sin((double )rotn_rad);
      }
      {
#line 13855
      __cil_tmp55 = cos((double )rotn_rad);
#line 13855
      xp = (int )((double )(x1 + offx) * __cil_tmp55 - (double )(y1___0 + offy) * __cil_tmp56);
#line 13856
      __cil_tmp58 = cos((double )rotn_rad);
      }
      {
#line 13856
      __cil_tmp57 = sin((double )rotn_rad);
#line 13856
      yp = (int )((double )(x1 + offx) * __cil_tmp57 + (double )(y1___0 + offy) * __cil_tmp58);
#line 13858
      x1 = xp - offx;
#line 13859
      y1___0 = yp - offy;
#line 13861
      __cil_tmp60 = sin((double )rotn_rad);
      }
      {
#line 13861
      __cil_tmp59 = cos((double )rotn_rad);
#line 13861
      xp = (int )((double )(x2 + offx) * __cil_tmp59 - (double )(y2 + offy) * __cil_tmp60);
#line 13862
      __cil_tmp62 = cos((double )rotn_rad);
      }
      {
#line 13862
      __cil_tmp61 = sin((double )rotn_rad);
#line 13862
      yp = (int )((double )(x2 + offx) * __cil_tmp61 + (double )(y2 + offy) * __cil_tmp62);
#line 13864
      x2 = xp - offx;
#line 13865
      y2 = yp - offy;
#line 13867
      __cil_tmp64 = sin((double )rotn_rad);
      }
      {
#line 13867
      __cil_tmp63 = cos((double )rotn_rad);
#line 13867
      xp = (int )((double )(xv + offx) * __cil_tmp63 - (double )(yv + offy) * __cil_tmp64);
#line 13868
      __cil_tmp66 = cos((double )rotn_rad);
      }
      {
#line 13868
      __cil_tmp65 = sin((double )rotn_rad);
#line 13868
      yp = (int )((double )(xv + offx) * __cil_tmp65 + (double )(yv + offy) * __cil_tmp66);
#line 13870
      xv = xp - offx;
#line 13871
      yv = yp - offy;
      }
    }
#line 13877
    x1 = (x1 + sx) + offx;
#line 13878
    y1___0 = (y1___0 + sy) + offy;
#line 13879
    x2 = (x2 + sx) + offx;
#line 13880
    y2 = (y2 + sy) + offy;
#line 13881
    xv = (xv + sx) + offx;
#line 13882
    yv = (yv + sy) + offy;
#line 13887
    if (! use_brush) {
#line 13890
      if (shape_valley[cur_shape] == 100) {
        {
#line 13891
        line_xor(x1, y1___0, x2, y2);
        }
      } else {
        {
#line 13894
        line_xor(x1, y1___0, xv, yv);
#line 13895
        line_xor(xv, yv, x2, y2);
        }
      }
    } else
#line 13900
    if (shape_valley[cur_shape] == 100) {
      {
#line 13903
      brush_draw(x1, y1___0, x2, y2, 0);
      }
    } else {
      {
#line 13907
      brush_draw(x1, y1___0, xv, yv, 0);
#line 13908
      brush_draw(xv, yv, x2, y2, 0);
      }
    }
#line 13835
    side += step;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 13914
  if (use_brush) {
#line 13914
    if (shape_filled[cur_shape]) {
#line 13914
      if (rx > 0) {
#line 13914
        if (ry > 0) {
#line 13918
          xx = 0;
          {
#line 13918
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 13918
            if (! (xx > 0)) {
#line 13918
              goto while_break___1;
            }
#line 13920
            yy = 0;
#line 13922
            side = 0;
            {
#line 13922
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 13922
              if (! (side < shape_sides[cur_shape])) {
#line 13922
                goto while_break___2;
              }
#line 13924
              a1 = (float )(((double )(angle_skip * side + init_ang) * 3.14159265359) / (double )180);
#line 13925
              a2 = (float )(((double )(angle_skip * (side + 1) + init_ang) * 3.14159265359) / (double )180);
#line 13927
              if (yy == (xx * ry) / rx) {
                {
#line 13929
                __cil_tmp67 = cos((double )a1);
#line 13929
                x1 = (int )(__cil_tmp67 * (double )xx);
#line 13930
                __cil_tmp68 = sin((double )a1);
#line 13930
                y1___0 = (int )(- __cil_tmp68 * (double )yy);
#line 13932
                __cil_tmp69 = cos((double )a2);
#line 13932
                x2 = (int )(__cil_tmp69 * (double )xx);
#line 13933
                __cil_tmp70 = sin((double )a2);
#line 13933
                y2 = (int )(- __cil_tmp70 * (double )yy);
#line 13935
                __cil_tmp71 = cos((double )((a1 + a2) / (float )2));
#line 13935
                xv = (int )(((__cil_tmp71 * (double )xx) * (double )shape_valley[cur_shape]) / (double )100);
#line 13936
                __cil_tmp72 = sin((double )((a1 + a2) / (float )2));
#line 13936
                yv = (int )(((- __cil_tmp72 * (double )yy) * (double )shape_valley[cur_shape]) / (double )100);
                }
              } else {
                {
#line 13940
                __cil_tmp73 = cos((double )a1);
#line 13940
                x1 = (int )(__cil_tmp73 * (double )yy);
#line 13941
                __cil_tmp74 = sin((double )a1);
#line 13941
                y1___0 = (int )(- __cil_tmp74 * (double )xx);
#line 13943
                __cil_tmp75 = cos((double )a2);
#line 13943
                x2 = (int )(__cil_tmp75 * (double )yy);
#line 13944
                __cil_tmp76 = sin((double )a2);
#line 13944
                y2 = (int )(- __cil_tmp76 * (double )xx);
#line 13946
                __cil_tmp77 = cos((double )((a1 + a2) / (float )2));
#line 13946
                xv = (int )(((__cil_tmp77 * (double )yy) * (double )shape_valley[cur_shape]) / (double )100);
#line 13947
                __cil_tmp78 = sin((double )((a1 + a2) / (float )2));
#line 13947
                yv = (int )(((- __cil_tmp78 * (double )xx) * (double )shape_valley[cur_shape]) / (double )100);
                }
              }
#line 13952
              if (rotn != 0) {
                {
#line 13954
                rotn_rad = (float )(((double )rotn * 3.14159265359) / (double )180);
#line 13956
                __cil_tmp80 = sin((double )rotn_rad);
                }
                {
#line 13956
                __cil_tmp79 = cos((double )rotn_rad);
#line 13956
                xp = (int )((double )(x1 + offx) * __cil_tmp79 - (double )(y1___0 + offy) * __cil_tmp80);
#line 13957
                __cil_tmp82 = cos((double )rotn_rad);
                }
                {
#line 13957
                __cil_tmp81 = sin((double )rotn_rad);
#line 13957
                yp = (int )((double )(x1 + offx) * __cil_tmp81 + (double )(y1___0 + offy) * __cil_tmp82);
#line 13959
                x1 = xp - offx;
#line 13960
                y1___0 = yp - offy;
#line 13962
                __cil_tmp84 = sin((double )rotn_rad);
                }
                {
#line 13962
                __cil_tmp83 = cos((double )rotn_rad);
#line 13962
                xp = (int )((double )(x2 + offx) * __cil_tmp83 - (double )(y2 + offy) * __cil_tmp84);
#line 13963
                __cil_tmp86 = cos((double )rotn_rad);
                }
                {
#line 13963
                __cil_tmp85 = sin((double )rotn_rad);
#line 13963
                yp = (int )((double )(x2 + offx) * __cil_tmp85 + (double )(y2 + offy) * __cil_tmp86);
#line 13965
                x2 = xp - offx;
#line 13966
                y2 = yp - offy;
#line 13968
                __cil_tmp88 = sin((double )rotn_rad);
                }
                {
#line 13968
                __cil_tmp87 = cos((double )rotn_rad);
#line 13968
                xp = (int )((double )(xv + offx) * __cil_tmp87 - (double )(yv + offy) * __cil_tmp88);
#line 13969
                __cil_tmp90 = cos((double )rotn_rad);
                }
                {
#line 13969
                __cil_tmp89 = sin((double )rotn_rad);
#line 13969
                yp = (int )((double )(xv + offx) * __cil_tmp89 + (double )(yv + offy) * __cil_tmp90);
#line 13971
                xv = xp - offx;
#line 13972
                yv = yp - offy;
                }
              }
#line 13978
              x1 = (x1 + sx) + offx;
#line 13979
              y1___0 = (y1___0 + sy) + offy;
#line 13980
              x2 = (x2 + sx) + offx;
#line 13981
              y2 = (y2 + sy) + offy;
#line 13982
              xv = (xv + sx) + offx;
#line 13983
              yv = (yv + sy) + offy;
#line 13987
              if (shape_valley[cur_shape] == 100) {
                {
#line 13988
                brush_draw(x1, y1___0, x2, y2, 0);
                }
              } else {
                {
#line 13992
                brush_draw(x1, y1___0, xv, yv, 0);
#line 13993
                brush_draw(xv, yv, x2, y2, 0);
                }
              }
#line 13922
              side ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 13997
            if (xx % 10 == 0) {
              {
#line 13998
              update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w, (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)));
              }
            }
#line 13918
            __cil_tmp92 = xx;
#line 13918
            xx --;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 14005
  if (use_brush) {
    {
#line 14007
    __cil_tmp94 = abs(ry);
    }
    {
#line 14007
    __cil_tmp93 = abs(rx);
    }
#line 14007
    if (__cil_tmp93 > __cil_tmp94) {
      {
#line 14008
      __cil_tmp95 = abs(rx);
#line 14008
      rmax = __cil_tmp95 + 20;
      }
    } else {
      {
#line 14010
      __cil_tmp96 = abs(ry);
#line 14010
      rmax = __cil_tmp96 + 20;
      }
    }
    {
#line 14012
    update_canvas((sx - rmax) + offx, (sy - rmax) + offy, (sx + rmax) + offx, (sy + rmax) + offy);
    }
  }
#line 14018
  if (use_brush) {
    {
#line 14020
    cur_brush = old_brush;
#line 14021
    render_brush();
    }
  }
  return;
}
}
#line 14030 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int shape_rotation(int ctr_x , int ctr_y , int ox , int oy ) 
{ 
  int deg ;
  double __cil_tmp6 ;

  {
  {
#line 14034
  __cil_tmp6 = atan2((double )(oy - ctr_y), (double )(ox - ctr_x));
#line 14034
  deg = (int )((__cil_tmp6 * (double )180) / 3.14159265359);
  }
#line 14036
  if (shape_reverse) {
#line 14037
    deg = (deg + 180) % 360;
  }
#line 14040
  if (shape_radius < 50) {
#line 14041
    deg = ((deg - 15) / 30) * 30;
  } else
#line 14042
  if (shape_radius < 100) {
#line 14043
    deg = ((deg - 7) / 15) * 15;
  }
#line 14058
  return (deg);
}
}
#line 14066 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int brush_rotation(int ctr_x , int ctr_y , int ox , int oy ) 
{ 
  int deg ;
  double __cil_tmp6 ;

  {
  {
#line 14070
  __cil_tmp6 = atan2((double )(oy - ctr_y), (double )(ox - ctr_x));
#line 14070
  deg = (int )((__cil_tmp6 * (double )180) / 3.14159265359);
  }
#line 14072
  return (deg);
}
}
#line 14092 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_save(int tool , int dont_show_success_results ) 
{ 
  int scroll ;
  char *fname ;
  char tmp[1024] ;
  SDL_Surface *thm ;
  FILE *fi ;
  int tmp___154 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  int *__cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  int *__cil_tmp17 ;
  char *__cil_tmp18 ;
  int __cil_tmp19 ;
  int *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  FILE *__cil_tmp23 ;
  int *__cil_tmp24 ;
  char *__cil_tmp25 ;
  int *__cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;
  FILE *__cil_tmp30 ;
  char *__cil_tmp31 ;
  SDL_Surface *__cil_tmp32 ;
  FILE *__cil_tmp33 ;
  int *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 14102
  if (disable_save) {
#line 14103
    return (0);
  }
#line 14105
  if (16 > buttons_tall * (int )gd_tools.cols) {
#line 14105
    tmp___154 = img_scroll_down->h;
  } else {
#line 14105
    tmp___154 = 0;
  }
  {
#line 14105
  scroll = tmp___154;
#line 14106
  tmp_apply_uncommited_text();
#line 14108
  SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), save_canvas, (SDL_Rect *)((void *)0));
#line 14109
  SDL_UpperBlit(label, (SDL_Rect *)((void *)0), save_canvas, (SDL_Rect *)((void *)0));
  }
#line 14111
  if (promptless_save == 2) {
    {
#line 14115
    get_new_file_id();
    }
  } else
#line 14117
  if (promptless_save == 0) {
#line 14121
    if ((int )file_id[0] != 0) {
      {
#line 14125
      __cil_tmp9 = do_prompt_image_snd("Replace the picture with your changes?", "Yes, replace the old one!",
                                       "No, save a new file!\324U", img_save_over,
                                       (SDL_Surface *)((void *)0), (SDL_Surface *)((void *)0),
                                       25, button_w + button_w / 2, (((6 * button_h + (int )r_ttools.h) + button_h / 2) - (tool_scroll * button_h) / (int )gd_tools.cols) + scroll);
      }
#line 14125
      if (__cil_tmp9 == 0) {
        {
#line 14134
        get_new_file_id();
        }
      }
#line 14136
      if (tool == 4) {
        {
        {
#line 14137
        do_render_cur_text(0);
        }
        }
      } else
#line 14136
      if (tool == 5) {
        {
        {
#line 14137
        do_render_cur_text(0);
        }
        }
      }
    } else {
      {
#line 14143
      get_new_file_id();
      }
    }
  } else
#line 14146
  if (promptless_save == 1) {
#line 14148
    if ((int )file_id[0] == 0) {
      {
#line 14149
      get_new_file_id();
      }
    }
  }
  {
#line 14155
  show_progress_bar(screen);
#line 14156
  do_setcursor(cursor_watch);
#line 14158
  __cil_tmp10 = make_directory(0, "\323\001 ", "Can\'t create user data directory (E002)");
  }
#line 14158
  if (! __cil_tmp10) {
    {
#line 14160
    fprintf(stderr, "Cannot save the any pictures! SORRY!\n\n");
#line 14161
    __cil_tmp11 = __errno_location();
#line 14161
    __cil_tmp12 = strerror(*__cil_tmp11);
#line 14161
    draw_tux_text(4, (char const   *)__cil_tmp12, 0);
    }
#line 14162
    return (0);
  }
  {
#line 14165
  show_progress_bar(screen);
#line 14170
  __cil_tmp13 = make_directory(0, "saved", "Can\'t create user data directory (for saved drawings) (E003)");
  }
#line 14170
  if (! __cil_tmp13) {
    {
#line 14172
    fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
#line 14173
    __cil_tmp14 = __errno_location();
#line 14173
    __cil_tmp15 = strerror(*__cil_tmp14);
#line 14173
    draw_tux_text(4, (char const   *)__cil_tmp15, 0);
    }
#line 14174
    return (0);
  }
  {
#line 14177
  show_progress_bar(screen);
#line 14182
  __cil_tmp16 = make_directory(0, "saved/.thumbsU", "Can\'t create user data thumbnail directory (for saved drawings\' thumbnails) (E004)");
  }
#line 14182
  if (! __cil_tmp16) {
    {
#line 14184
    fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
#line 14185
    __cil_tmp17 = __errno_location();
#line 14185
    __cil_tmp18 = strerror(*__cil_tmp17);
#line 14185
    draw_tux_text(4, (char const   *)__cil_tmp18, 0);
    }
#line 14186
    return (0);
  }
  {
#line 14189
  show_progress_bar(screen);
#line 14193
  __cil_tmp19 = make_directory(0, "saved/.label", "Can\'t create label information directory (E005)");
  }
#line 14193
  if (! __cil_tmp19) {
    {
#line 14195
    fprintf(stderr, "Cannot save label information! SORRY!\n\n");
#line 14196
    __cil_tmp20 = __errno_location();
#line 14196
    __cil_tmp21 = strerror(*__cil_tmp20);
#line 14196
    draw_tux_text(4, (char const   *)__cil_tmp21, 0);
    }
#line 14197
    return (0);
  }
  {
#line 14203
  safe_snprintf((char *)tmp, sizeof(tmp), "saved/%s%s\235t\324U", (char *)file_id,
                ".png\324U");
#line 14204
  fname = get_fname((char const   *)((char *)tmp), 0);
#line 14205
  debug((char const   *)fname);
#line 14207
  fi = fopen((char const   *)fname, "wb");
  }
#line 14208
  if (fi == (void *)0) {
    {
#line 14210
    __cil_tmp24 = __errno_location();
#line 14210
    __cil_tmp25 = strerror(*__cil_tmp24);
#line 14210
    fprintf(stderr, "\nError: Couldn\'t save the current image!\n%s\nThe system error that occurred was:\n%s\n\n\230\001",
            fname, __cil_tmp25);
#line 14214
    __cil_tmp26 = __errno_location();
#line 14214
    __cil_tmp27 = strerror(*__cil_tmp26);
#line 14214
    draw_tux_text(4, (char const   *)__cil_tmp27, 0);
    }
  } else {
    {
#line 14218
    __cil_tmp28 = do_png_save(fi, (char const   *)fname, save_canvas, 1);
    }
#line 14218
    if (! __cil_tmp28) {
      {
#line 14220
      free(fname);
      }
#line 14221
      return (0);
    }
  }
  {
#line 14225
  free(fname);
#line 14228
  show_progress_bar(screen);
#line 14235
  safe_snprintf((char *)tmp, sizeof(tmp), "saved/%s-t%s\324U", (char *)file_id, ".png\324U");
#line 14236
  fname = get_fname((char const   *)((char *)tmp), 0);
#line 14237
  fi = fopen((char const   *)fname, "r");
  }
#line 14238
  if (fi != (void *)0) {
    {
#line 14240
    fclose(fi);
    }
  } else {
    {
#line 14247
    safe_snprintf((char *)tmp, sizeof(tmp), "saved/.thumbs/%s-t%s", (char *)file_id,
                  ".png");
#line 14248
    fname = get_fname((char const   *)((char *)tmp), 0);
    }
  }
  {
#line 14251
  debug((char const   *)fname);
#line 14253
  thm = thumbnail(save_canvas, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                  (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                  0);
#line 14255
  fi = fopen((char const   *)fname, "wb");
  }
#line 14256
  if (fi == (void *)0) {
    {
#line 14258
    __cil_tmp34 = __errno_location();
#line 14258
    __cil_tmp35 = strerror(*__cil_tmp34);
#line 14258
    fprintf(stderr, "\nError: Couldn\'t save thumbnail of image!\n%s\nThe system error that occurred was:\n%s\n\n\r\232t\324U",
            fname, __cil_tmp35);
    }
  } else {
    {
#line 14263
    do_png_save(fi, (char const   *)fname, thm, 0);
    }
  }
  {
#line 14265
  SDL_FreeSurface(thm);
#line 14267
  free(fname);
#line 14294
  playsound(screen, 0, 14, 1, - 998, - 999);
  }
#line 14296
  if (! dont_show_success_results) {
    {
#line 14298
    draw_tux_text(0, tool_tips[13], 1);
#line 14299
    do_setcursor(cursor_arrow);
    }
  }
  {
#line 14302
  undo_tmp_applied_text();
  }
#line 14304
  return (1);
}
}
#line 14310 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void set_chunk_data(unsigned char **chunk_data , size_t *chunk_data_len , size_t uncompressed_size ,
                           Bytef *data , size_t dataLen ) 
{ 
  int headersLen ;
  unsigned int i ;
  char *line ;
  char *headers ;
  char *cdata ;
  size_t line_sz ;
  size_t headers_sz ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  unsigned long __cil_tmp15 ;
  void *__cil_tmp16 ;
  unsigned int __cil_tmp17 ;

  {
  {
#line 14318
  headersLen = 0;
#line 14319
  headers_sz = (size_t )256;
#line 14320
  headers = (char *)calloc(headers_sz, (unsigned long )1);
#line 14321
  line_sz = (size_t )256;
#line 14322
  line = (char *)calloc(line_sz, (unsigned long )1);
#line 14324
  safe_strncat(headers, "Tuxpaint\n\374\231t\324U", headers_sz);
#line 14325
  safe_strncat(headers, "Tuxpaint_0.9.27\n\230\001", headers_sz);
#line 14326
  safe_snprintf(line, line_sz, "%lu%sU", uncompressed_size, "\n\364\231t\324U");
#line 14327
  safe_strncat(headers, (char const   *)line, headers_sz);
#line 14328
  safe_snprintf(line, line_sz, "%lu%s", dataLen, "\n\375\231t\324U");
#line 14329
  safe_strncat(headers, (char const   *)line, headers_sz);
#line 14331
  __cil_tmp15 = strlen((char const   *)headers);
#line 14331
  headersLen = (int )__cil_tmp15;
#line 14332
  *chunk_data_len = (unsigned long )headersLen + dataLen;
#line 14334
  cdata = (char *)calloc(*chunk_data_len, sizeof(unsigned char *));
#line 14335
  strcat(cdata, (char const   *)headers);
#line 14337
  i = (unsigned int )0;
  }
  {
#line 14337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 14337
    if (! ((unsigned long )i < dataLen)) {
#line 14337
      goto while_break;
    }
#line 14338
    *(cdata + ((unsigned int )headersLen + i)) = (char )*(data + i);
#line 14337
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 14339
  *chunk_data = (unsigned char *)cdata;
#line 14341
  free(line);
#line 14342
  free(headers);
  }
  return;
}
}
#line 14348 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_png_embed_data(png_structp png_ptr ) 
{ 
  int x ;
  int y ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  png_unknown_chunk tuxpaint_chunks[5] ;
  size_t size_of_uncompressed_label_data ;
  size_t chunk_data_len ;
  unsigned char *sbk_pixs ;
  uLongf compressedLen ;
  unsigned char *chunk_data ;
  Bytef *compressed_data ;
  char *ldata ;
  FILE *lfi ;
  int list_ctr ;
  Uint32 pix ;
  int alpha_size ;
  Uint32 i ;
  struct label_node *current_node ;
  char *char_stream ;
  char *line ;
  size_t dat_size ;
  size_t char_stream_sz ;
  size_t line_sz ;
  void *__cil_tmp27 ;
  uLong __cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  uLong __cil_tmp33 ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  void *__cil_tmp40 ;
  uLong __cil_tmp41 ;
  void *__cil_tmp42 ;
  int __cil_tmp43 ;
  int __cil_tmp44 ;
  FILE *__cil_tmp45 ;
  Uint32 __cil_tmp46 ;
  TuxPaint_Font *__cil_tmp47 ;
  char *__cil_tmp48 ;
  Uint32 __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  uLong __cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  unsigned long __cil_tmp56 ;

  {
#line 14391
  list_ctr = 0;
#line 14401
  if (img_starter) {
    {
#line 14406
    sbk_pixs = (unsigned char *)malloc((unsigned long )((img_starter->h * img_starter->w) * 4));
#line 14407
    compressedLen = compressBound((uLong )((img_starter->h * img_starter->w) * 4));
#line 14409
    compressed_data = (Bytef *)malloc(compressedLen * sizeof(Bytef *));
    }
#line 14411
    if (img_starter->offset) {
      {
      {
#line 14412
      SDL_LockSurface(img_starter);
      }
      }
    } else
#line 14411
    if ((img_starter->flags & 16389U) != 0U) {
      {
      {
#line 14412
      SDL_LockSurface(img_starter);
      }
      }
    }
#line 14414
    y = 0;
    {
#line 14414
    while (1) {
      while_continue: /* CIL Label */ ;
#line 14414
      if (! (y < img_starter->h)) {
#line 14414
        goto while_break;
      }
#line 14415
      x = 0;
      {
#line 14415
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 14415
        if (! (x < img_starter->w)) {
#line 14415
          goto while_break___0;
        }
#line 14421
        if ((int )a == 0) {
#line 14423
          *(sbk_pixs + 4 * (y * img_starter->w + x)) = (unsigned char )0;
#line 14424
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 1)) = (unsigned char )0;
#line 14425
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 2)) = (unsigned char )0;
#line 14426
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 3)) = (unsigned char )0;
        } else {
#line 14430
          *(sbk_pixs + 4 * (y * img_starter->w + x)) = r;
#line 14431
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 1)) = g;
#line 14432
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 2)) = b;
#line 14433
          *(sbk_pixs + (4 * (y * img_starter->w + x) + 3)) = a;
        }
#line 14415
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 14414
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 14437
    if (img_starter->offset) {
      {
      {
#line 14438
      SDL_UnlockSurface(img_starter);
      }
      }
    } else
#line 14437
    if ((img_starter->flags & 16389U) != 0U) {
      {
      {
#line 14438
      SDL_UnlockSurface(img_starter);
      }
      }
    }
    {
#line 14440
    compress(compressed_data, & compressedLen, sbk_pixs, (uLong )((img_starter->h * img_starter->w) * 4));
#line 14441
    set_chunk_data(& chunk_data, & chunk_data_len, (size_t )((img_starter->w * img_starter->h) * 4),
                   compressed_data, compressedLen);
#line 14443
    tuxpaint_chunks[1].data = (png_byte *)chunk_data;
#line 14444
    tuxpaint_chunks[1].size = chunk_data_len;
#line 14445
    tuxpaint_chunks[1].location = (png_byte )1;
#line 14446
    tuxpaint_chunks[1].name[0] = (png_byte )'t';
#line 14447
    tuxpaint_chunks[1].name[1] = (png_byte )'p';
#line 14448
    tuxpaint_chunks[1].name[2] = (png_byte )'F';
#line 14449
    tuxpaint_chunks[1].name[3] = (png_byte )'G';
#line 14450
    tuxpaint_chunks[1].name[4] = (png_byte )'\000';
#line 14451
    png_write_chunk(png_ptr, (png_byte *)tuxpaint_chunks[1].name, tuxpaint_chunks[1].data,
                    tuxpaint_chunks[1].size);
#line 14453
    free(compressed_data);
#line 14454
    free(chunk_data);
#line 14455
    free(sbk_pixs);
    }
  }
#line 14459
  if (img_starter_bkgd) {
    {
#line 14461
    sbk_pixs = (unsigned char *)malloc((unsigned long )((img_starter_bkgd->w * img_starter_bkgd->h) * 3));
#line 14462
    compressedLen = compressBound((uLong )((img_starter_bkgd->h * img_starter_bkgd->w) * 3));
#line 14464
    compressed_data = (Bytef *)malloc(compressedLen * sizeof(Bytef *));
    }
#line 14466
    if (img_starter_bkgd->offset) {
      {
      {
#line 14467
      SDL_LockSurface(img_starter_bkgd);
      }
      }
    } else
#line 14466
    if ((img_starter_bkgd->flags & 16389U) != 0U) {
      {
      {
#line 14467
      SDL_LockSurface(img_starter_bkgd);
      }
      }
    }
#line 14469
    y = 0;
    {
#line 14469
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 14469
      if (! (y < img_starter_bkgd->h)) {
#line 14469
        goto while_break___1;
      }
#line 14470
      x = 0;
      {
#line 14470
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 14470
        if (! (x < img_starter_bkgd->w)) {
#line 14470
          goto while_break___2;
        }
#line 14475
        *(sbk_pixs + 3 * (y * img_starter_bkgd->w + x)) = r;
#line 14476
        *(sbk_pixs + (3 * (y * img_starter_bkgd->w + x) + 1)) = g;
#line 14477
        *(sbk_pixs + (3 * (y * img_starter_bkgd->w + x) + 2)) = b;
#line 14470
        x ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 14469
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 14481
    if (img_starter) {
#line 14483
      if (img_starter->offset) {
        {
        {
#line 14484
        SDL_LockSurface(img_starter);
        }
        }
      } else
#line 14483
      if ((img_starter->flags & 16389U) != 0U) {
        {
        {
#line 14484
        SDL_LockSurface(img_starter);
        }
        }
      }
#line 14485
      y = 0;
      {
#line 14485
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 14485
        if (! (y < img_starter_bkgd->h)) {
#line 14485
          goto while_break___3;
        }
#line 14486
        x = 0;
        {
#line 14486
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 14486
          if (! (x < img_starter_bkgd->w)) {
#line 14486
            goto while_break___4;
          }
#line 14491
          if ((int )a == 255) {
#line 14493
            *(sbk_pixs + 3 * (y * img_starter_bkgd->w + x)) = (unsigned char )0;
#line 14494
            *(sbk_pixs + (3 * (y * img_starter_bkgd->w + x) + 1)) = (unsigned char )0;
#line 14495
            *(sbk_pixs + (3 * (y * img_starter_bkgd->w + x) + 2)) = (unsigned char )0;
          }
#line 14486
          x ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 14485
        y ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 14498
      if (img_starter->offset) {
        {
        {
#line 14499
        SDL_UnlockSurface(img_starter);
        }
        }
      } else
#line 14498
      if ((img_starter->flags & 16389U) != 0U) {
        {
        {
#line 14499
        SDL_UnlockSurface(img_starter);
        }
        }
      }
    }
#line 14502
    if (img_starter_bkgd->offset) {
      {
      {
#line 14503
      SDL_UnlockSurface(img_starter_bkgd);
      }
      }
    } else
#line 14502
    if ((img_starter_bkgd->flags & 16389U) != 0U) {
      {
      {
#line 14503
      SDL_UnlockSurface(img_starter_bkgd);
      }
      }
    }
    {
#line 14509
    compress(compressed_data, & compressedLen, sbk_pixs, (uLong )((img_starter_bkgd->h * img_starter_bkgd->w) * 3));
#line 14511
    set_chunk_data(& chunk_data, & chunk_data_len, (size_t )((img_starter_bkgd->w * img_starter_bkgd->h) * 3),
                   compressed_data, compressedLen);
#line 14518
    tuxpaint_chunks[2].data = (png_byte *)chunk_data;
#line 14519
    tuxpaint_chunks[2].size = chunk_data_len;
#line 14520
    tuxpaint_chunks[2].location = (png_byte )1;
#line 14521
    tuxpaint_chunks[2].name[0] = (png_byte )'t';
#line 14522
    tuxpaint_chunks[2].name[1] = (png_byte )'p';
#line 14523
    tuxpaint_chunks[2].name[2] = (png_byte )'B';
#line 14524
    tuxpaint_chunks[2].name[3] = (png_byte )'G';
#line 14525
    tuxpaint_chunks[2].name[4] = (png_byte )'\000';
#line 14526
    png_write_chunk(png_ptr, (png_byte *)tuxpaint_chunks[2].name, tuxpaint_chunks[2].data,
                    tuxpaint_chunks[2].size);
#line 14528
    free(compressed_data);
#line 14529
    free(chunk_data);
#line 14530
    free(sbk_pixs);
    }
  }
  {
#line 14534
  __cil_tmp39 = are_labels();
  }
#line 14534
  if (label) {
#line 14534
    if (__cil_tmp39) {
      {
#line 14536
      sbk_pixs = (unsigned char *)malloc((unsigned long )((label->h * label->w) * 4));
#line 14537
      __cil_tmp41 = compressBound((uLong )((label->h * label->w) * 4));
#line 14537
      compressedLen = (uLongf )__cil_tmp41;
#line 14538
      compressed_data = (Bytef *)malloc(compressedLen * sizeof(Bytef *));
      }
#line 14540
      if (label->offset) {
        {
        {
#line 14541
        SDL_LockSurface(label);
        }
        }
      } else
#line 14540
      if ((label->flags & 16389U) != 0U) {
        {
        {
#line 14541
        SDL_LockSurface(label);
        }
        }
      }
#line 14542
      if (canvas->offset) {
        {
        {
#line 14543
        SDL_LockSurface(canvas);
        }
        }
      } else
#line 14542
      if ((canvas->flags & 16389U) != 0U) {
        {
        {
#line 14543
        SDL_LockSurface(canvas);
        }
        }
      }
#line 14545
      y = 0;
      {
#line 14545
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 14545
        if (! (y < label->h)) {
#line 14545
          goto while_break___5;
        }
#line 14547
        x = 0;
        {
#line 14547
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 14547
          if (! (x < label->w)) {
#line 14547
            goto while_break___6;
          }
#line 14550
          if ((int )a != 0) {
#line 14554
            *(sbk_pixs + 4 * (y * label->w + x)) = r;
#line 14555
            *(sbk_pixs + (4 * (y * label->w + x) + 1)) = g;
#line 14556
            *(sbk_pixs + (4 * (y * label->w + x) + 2)) = b;
#line 14557
            *(sbk_pixs + (4 * (y * label->w + x) + 3)) = (unsigned char )255;
          } else {
#line 14561
            *(sbk_pixs + 4 * (y * label->w + x)) = (unsigned char )0;
#line 14562
            *(sbk_pixs + (4 * (y * label->w + x) + 1)) = (unsigned char )0;
#line 14563
            *(sbk_pixs + (4 * (y * label->w + x) + 2)) = (unsigned char )0;
#line 14564
            *(sbk_pixs + (4 * (y * label->w + x) + 3)) = (unsigned char )0;
          }
#line 14547
          x ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 14545
        y ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 14569
      if (label->offset) {
        {
        {
#line 14570
        SDL_UnlockSurface(label);
        }
        }
      } else
#line 14569
      if ((label->flags & 16389U) != 0U) {
        {
        {
#line 14570
        SDL_UnlockSurface(label);
        }
        }
      }
#line 14571
      if (canvas->offset) {
        {
        {
#line 14572
        SDL_UnlockSurface(canvas);
        }
        }
      } else
#line 14571
      if ((canvas->flags & 16389U) != 0U) {
        {
        {
#line 14572
        SDL_UnlockSurface(canvas);
        }
        }
      }
      {
#line 14574
      compress(compressed_data, & compressedLen, sbk_pixs, (uLong )((canvas->h * canvas->w) * 4));
#line 14575
      set_chunk_data(& chunk_data, & chunk_data_len, (size_t )((canvas->w * canvas->h) * 4),
                     compressed_data, compressedLen);
#line 14577
      tuxpaint_chunks[3].data = chunk_data;
#line 14578
      tuxpaint_chunks[3].size = chunk_data_len;
#line 14579
      tuxpaint_chunks[3].location = (png_byte )1;
#line 14580
      tuxpaint_chunks[3].name[0] = (png_byte )'t';
#line 14581
      tuxpaint_chunks[3].name[1] = (png_byte )'p';
#line 14582
      tuxpaint_chunks[3].name[2] = (png_byte )'L';
#line 14583
      tuxpaint_chunks[3].name[3] = (png_byte )'D';
#line 14584
      tuxpaint_chunks[3].name[4] = (png_byte )'\000';
#line 14586
      png_write_chunk(png_ptr, (png_byte *)tuxpaint_chunks[3].name, tuxpaint_chunks[3].data,
                      tuxpaint_chunks[3].size);
#line 14587
      free(compressed_data);
#line 14588
      free(chunk_data);
#line 14589
      free(sbk_pixs);
#line 14595
      lfi = open_memstream(& ldata, & size_of_uncompressed_label_data);
#line 14608
      current_node = current_label_node;
      }
      {
#line 14609
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 14609
        if (! (current_node != (void *)0)) {
#line 14609
          goto while_break___7;
        }
#line 14611
        if (current_node->is_enabled) {
#line 14611
          if (current_node->save_texttool_len > 0U) {
#line 14612
            list_ctr ++;
          }
        }
#line 14613
        current_node = current_node->next_to_down_label_node;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 14616
      fprintf(lfi, "%d\n", list_ctr);
#line 14617
      fprintf(lfi, "%d\n", (int )r_canvas.w);
#line 14618
      fprintf(lfi, "%d\n\n", (int )r_canvas.h);
#line 14620
      current_node = start_label_node;
      }
      {
#line 14621
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 14621
        if (! (current_node && current_node != first_label_node_in_redo_stack)) {
#line 14621
          goto while_break___8;
        }
#line 14623
        if (current_node->is_enabled == 1) {
#line 14623
          if (current_node->save_texttool_len > 0U) {
            {
#line 14649
            fprintf(lfi, "%u\n", current_node->save_texttool_len);
#line 14651
            i = (Uint32 )0;
            }
            {
#line 14651
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 14651
              if (! (i < current_node->save_texttool_len)) {
#line 14651
                goto while_break___9;
              }
              {
#line 14653
              fprintf(lfi, "%lc", (wint_t )current_node->save_texttool_str[i]);
              }
#line 14651
              i ++;
            }
            while_break___9: /* CIL Label */ ;
            }
            {
#line 14657
            fprintf(lfi, "\n");
#line 14660
            fprintf(lfi, "%u\n", (int )current_node->save_color.r);
#line 14661
            fprintf(lfi, "%u\n", (int )current_node->save_color.g);
#line 14662
            fprintf(lfi, "%u\n", (int )current_node->save_color.b);
#line 14663
            fprintf(lfi, "%d\n", current_node->save_width);
#line 14664
            fprintf(lfi, "%d\n", current_node->save_height);
#line 14665
            fprintf(lfi, "%u\n", (int )current_node->save_x);
#line 14666
            fprintf(lfi, "%u\n", (int )current_node->save_y);
            }
#line 14668
            if (current_node->save_font_type == (void *)0) {
              {
#line 14670
              fprintf(lfi, "%d\n", current_node->save_cur_font);
#line 14671
              __cil_tmp48 = TTF_FontFaceFamilyName(__cil_tmp47->ttf_font);
#line 14671
              fprintf(lfi, "%s\n", __cil_tmp48);
              }
            } else {
              {
#line 14675
              fprintf(lfi, "%d\n", 0);
#line 14676
              fprintf(lfi, "%s\n", current_node->save_font_type);
              }
            }
            {
#line 14679
            fprintf(lfi, "%d\n", current_node->save_text_state);
#line 14680
            fprintf(lfi, "%u\n", current_node->save_text_size);
#line 14682
            SDL_LockSurface(current_node->label_node_surface);
#line 14683
            alpha_size = (int )sizeof(Uint8 );
#line 14684
            x = 0;
            }
            {
#line 14684
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 14684
              if (! (x < current_node->save_width)) {
#line 14684
                goto while_break___10;
              }
#line 14685
              y = 0;
              {
#line 14685
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 14685
                if (! (y < current_node->save_height)) {
#line 14685
                  goto while_break___11;
                }
                {
#line 14688
                pix = (*(getpixels[((current_node->label_node_surface)->format)->BytesPerPixel]))(current_node->label_node_surface,
                                                                                                  x,
                                                                                                  y);
#line 14691
                fwrite(& a, (unsigned long )alpha_size, (unsigned long )1, lfi);
                }
#line 14685
                y ++;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 14684
              x ++;
            }
            while_break___10: /* CIL Label */ ;
            }
            {
#line 14693
            SDL_UnlockSurface(current_node->label_node_surface);
#line 14694
            fprintf(lfi, "\n\n");
            }
          }
        }
#line 14696
        current_node = current_node->next_to_up_label_node;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 14710
      fclose(lfi);
#line 14712
      compressedLen = compressBound(size_of_uncompressed_label_data);
#line 14713
      compressed_data = (Bytef *)malloc(compressedLen * sizeof(Bytef *));
#line 14714
      compress((Bytef *)compressed_data, & compressedLen, (unsigned char *)ldata,
               size_of_uncompressed_label_data);
#line 14715
      set_chunk_data(& chunk_data, & chunk_data_len, size_of_uncompressed_label_data,
                     compressed_data, compressedLen);
#line 14717
      tuxpaint_chunks[4].data = chunk_data;
#line 14718
      tuxpaint_chunks[4].size = chunk_data_len;
#line 14719
      tuxpaint_chunks[4].location = (png_byte )1;
#line 14720
      tuxpaint_chunks[4].name[0] = (png_byte )'t';
#line 14721
      tuxpaint_chunks[4].name[1] = (png_byte )'p';
#line 14722
      tuxpaint_chunks[4].name[2] = (png_byte )'L';
#line 14723
      tuxpaint_chunks[4].name[3] = (png_byte )'L';
#line 14724
      tuxpaint_chunks[4].name[4] = (png_byte )'\000';
#line 14726
      png_write_chunk(png_ptr, (png_byte *)tuxpaint_chunks[4].name, tuxpaint_chunks[4].data,
                      tuxpaint_chunks[4].size);
#line 14728
      free(compressed_data);
#line 14729
      free(chunk_data);
      }
    }
  }
#line 14735
  if ((int )starter_id[0] != 0) {
    _L: /* CIL Label */ 
    _L___155: /* CIL Label */ 
    _L___156: /* CIL Label */ 
    _L___157: /* CIL Label */ 
    {
#line 14739
    line_sz = (size_t )256;
#line 14740
    line = (char *)calloc(line_sz, (unsigned long )1);
#line 14741
    char_stream = (char *)calloc(char_stream_sz, (unsigned long )1);
    }
    {
#line 14741
    char_stream_sz = (256UL + sizeof(starter_id)) + sizeof(template_id);
#line 14744
    safe_snprintf(char_stream, char_stream_sz, "%s\n", (char *)starter_id);
#line 14746
    safe_snprintf(line, line_sz, "%d %d %d\n", starter_mirrored, starter_flipped,
                  starter_personal);
#line 14747
    safe_strncat(char_stream, (char const   *)line, char_stream_sz);
#line 14749
    safe_snprintf(line, line_sz, "c%d %d %d\n", (int )canvas_color_r, (int )canvas_color_g,
                  (int )canvas_color_b);
#line 14750
    safe_strncat(char_stream, (char const   *)line, char_stream_sz);
#line 14752
    safe_snprintf(line, line_sz, "T%s\n", (char *)template_id);
#line 14753
    safe_strncat(char_stream, (char const   *)line, char_stream_sz);
#line 14755
    safe_snprintf(line, line_sz, "%d\n", template_personal);
#line 14756
    safe_strncat(char_stream, (char const   *)line, char_stream_sz);
#line 14758
    safe_snprintf(line, line_sz, "M%d\n", starter_modified);
#line 14759
    safe_strncat(char_stream, (char const   *)line, char_stream_sz);
#line 14761
    dat_size = strlen((char const   *)char_stream);
#line 14763
    set_chunk_data(& chunk_data, & chunk_data_len, dat_size, (Bytef *)char_stream,
                   dat_size);
#line 14765
    tuxpaint_chunks[4].data = chunk_data;
#line 14766
    tuxpaint_chunks[4].size = chunk_data_len;
#line 14767
    tuxpaint_chunks[4].location = (png_byte )1;
#line 14768
    tuxpaint_chunks[4].name[0] = (png_byte )'t';
#line 14769
    tuxpaint_chunks[4].name[1] = (png_byte )'p';
#line 14770
    tuxpaint_chunks[4].name[2] = (png_byte )'D';
#line 14771
    tuxpaint_chunks[4].name[3] = (png_byte )'T';
#line 14772
    tuxpaint_chunks[4].name[4] = (png_byte )'\000';
#line 14774
    png_write_chunk(png_ptr, (png_byte *)tuxpaint_chunks[4].name, tuxpaint_chunks[4].data,
                    tuxpaint_chunks[4].size);
#line 14776
    free(char_stream);
#line 14777
    free(line);
#line 14778
    free(chunk_data);
    }
  } else
#line 14735
  if ((int )template_id[0] != 0) {
#line 14735
    goto _L;
  } else
#line 14735
  if ((int )canvas_color_r != 255) {
#line 14735
    goto _L;
  } else
#line 14735
  if ((int )canvas_color_g != 255) {
#line 14735
    goto _L;
  } else
#line 14735
  if ((int )canvas_color_b != 255) {
#line 14735
    goto _L;
  }
  return;
}
}
#line 14786 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_png_save(FILE *fi , char const   *fname , SDL_Surface *surf , int embed ) 
{ 
  png_structp png_ptr ;
  png_infop info_ptr ;
  png_text text_ptr[4] ;
  unsigned char **png_rows ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  int x ;
  int y ;
  int count ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  png_structp __cil_tmp16 ;
  int *__cil_tmp17 ;
  char *__cil_tmp18 ;
  png_infop __cil_tmp19 ;
  int *__cil_tmp20 ;
  char *__cil_tmp21 ;
  jmp_buf *__cil_tmp22 ;
  int __cil_tmp23 ;
  int *__cil_tmp24 ;
  char *__cil_tmp25 ;
  int __cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;

  {
  {
#line 14795
  getpixel = getpixels[(surf->format)->BytesPerPixel];
#line 14798
  png_ptr = png_create_write_struct("1.6.37", (void *)0, (png_error_ptr )((void *)0),
                                    (png_error_ptr )((void *)0));
  }
#line 14799
  if (png_ptr == (void *)0) {
    {
#line 14801
    fclose(fi);
#line 14802
    png_destroy_write_struct(& png_ptr, (png_infopp )((void *)0));
#line 14804
    fprintf(stderr, "\nError: Couldn\'t save the image!\n%s\n\n", fname);
#line 14805
    __cil_tmp17 = __errno_location();
#line 14805
    __cil_tmp18 = strerror(*__cil_tmp17);
#line 14805
    draw_tux_text(4, (char const   *)__cil_tmp18, 0);
    }
  } else {
    {
#line 14809
    info_ptr = png_create_info_struct(png_ptr);
    }
#line 14810
    if (info_ptr == (void *)0) {
      {
#line 14812
      fclose(fi);
#line 14813
      png_destroy_write_struct(& png_ptr, (png_infopp )((void *)0));
#line 14815
      fprintf(stderr, "\nError: Couldn\'t save the image!\n%s\n\n", fname);
#line 14816
      __cil_tmp20 = __errno_location();
#line 14816
      __cil_tmp21 = strerror(*__cil_tmp20);
#line 14816
      draw_tux_text(4, (char const   *)__cil_tmp21, 0);
      }
    } else {
      {
#line 14820
      __cil_tmp22 = png_set_longjmp_fn(png_ptr, & longjmp, sizeof(jmp_buf ));
#line 14820
      __cil_tmp23 = _setjmp((struct __jmp_buf_tag *)*__cil_tmp22);
      }
#line 14820
      if (__cil_tmp23) {
        {
#line 14822
        fclose(fi);
#line 14823
        png_destroy_write_struct(& png_ptr, (png_infopp )((void *)0));
#line 14825
        fprintf(stderr, "\nError: Couldn\'t save the image!\n%s\n\n", fname);
#line 14826
        __cil_tmp24 = __errno_location();
#line 14826
        __cil_tmp25 = strerror(*__cil_tmp24);
#line 14826
        draw_tux_text(4, (char const   *)__cil_tmp25, 0);
        }
#line 14828
        return (0);
      } else {
        {
#line 14832
        png_init_io(png_ptr, fi);
#line 14834
        png_set_IHDR(png_ptr, info_ptr, (png_uint_32 )surf->w, (png_uint_32 )surf->h,
                     8, 2, 1, 0, 0);
#line 14837
        png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, 0);
#line 14841
        count = 0;
#line 14853
        text_ptr[count].key = (png_charp )"SoftwareP\232kt\324U";
#line 14854
        text_ptr[count].text = (png_charp )"Tux Paint 0.9.27 (2024-04-18)";
#line 14855
        text_ptr[count].compression = - 1;
#line 14856
        count ++;
#line 14859
        png_set_text(png_ptr, info_ptr, (png_text *)text_ptr, count);
#line 14861
        png_write_info(png_ptr, info_ptr);
        }
#line 14863
        if (embed) {
          {
#line 14864
          do_png_embed_data(png_ptr);
          }
        }
        {
#line 14868
        png_rows = (unsigned char **)malloc(sizeof(char *) * (unsigned long )surf->h);
#line 14870
        y = 0;
        }
        {
#line 14870
        while (1) {
          while_continue: /* CIL Label */ ;
#line 14870
          if (! (y < surf->h)) {
#line 14870
            goto while_break;
          }
          {
#line 14872
          *(png_rows + y) = (unsigned char *)malloc((sizeof(char ) * 3UL) * (unsigned long )surf->w);
#line 14874
          x = 0;
          }
          {
#line 14874
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 14874
            if (! (x < surf->w)) {
#line 14874
              goto while_break___0;
            }
#line 14878
            *(*(png_rows + y) + x * 3) = r;
#line 14879
            *(*(png_rows + y) + (x * 3 + 1)) = g;
#line 14880
            *(*(png_rows + y) + (x * 3 + 2)) = b;
#line 14874
            x ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 14870
          y ++;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 14884
        png_write_image(png_ptr, png_rows);
#line 14886
        y = 0;
        }
        {
#line 14886
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 14886
          if (! (y < surf->h)) {
#line 14886
            goto while_break___1;
          }
          {
#line 14887
          free(*(png_rows + y));
          }
#line 14886
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 14889
        free(png_rows);
#line 14892
        png_write_end(png_ptr, (png_info *)((void *)0));
#line 14893
        png_destroy_write_struct(& png_ptr, & info_ptr);
#line 14894
        fclose(fi);
        }
#line 14896
        return (1);
      }
    }
  }
#line 14901
  return (0);
}
}
#line 14911 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void get_new_file_id(void) 
{ 
  time_t t ;
  time_t __cil_tmp2 ;
  struct tm *__cil_tmp3 ;

  {
  {
#line 14915
  t = time((time_t *)((void *)0));
#line 14917
  __cil_tmp3 = localtime(& t);
#line 14917
  strftime((char *)file_id, sizeof(file_id), "%Y%m%d%H%M%S", __cil_tmp3);
#line 14918
  debug((char const   *)((char *)file_id));
  }
  return;
}
}
#line 14926 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_quit(int tool ) 
{ 
  int done ;
  int tmp_tool ;
  int scroll ;
  int tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 14930
  if (! no_prompt_on_quit) {
#line 14932
    if (16 > buttons_tall * (int )gd_tools.cols) {
#line 14932
      tmp = img_scroll_down->h;
    } else {
#line 14932
      tmp = 0;
    }
    {
#line 14932
    scroll = tmp;
#line 14933
    done = do_prompt_snd("Do you really want to quit?", "Yes, I\342\200\231m done!\323\001 ",
                         "No, take me back!", 25, button_w + button_w / 2, (((7 * button_h + (int )r_ttools.h) + button_h / 2) - (tool_scroll * button_h) / (int )gd_tools.cols) + scroll);
    }
  } else {
#line 14940
    done = 1;
  }
#line 14943
  if (done) {
#line 14943
    if (! been_saved) {
#line 14943
      if (! disable_save) {
        {
#line 14945
        __cil_tmp7 = do_prompt("If you quit, you\342\200\231ll lose your picture! Save it?",
                               "Yes, save it!", "No, don\342\200\231t bother saving!",
                               screen->w / 2, screen->h / 2);
        }
#line 14945
        if (autosave_on_quit) {
          _L: /* CIL Label */ 
          {
#line 14948
          __cil_tmp8 = do_save(tool, 1);
          }
#line 14948
          if (! __cil_tmp8) {
#line 14957
            done = 0;
          }
        } else
#line 14945
        if (__cil_tmp7) {
#line 14945
          goto _L;
        }
      } else {
#line 14943
        goto _L___158;
      }
    } else {
#line 14943
      goto _L___158;
    }
  } else {
    _L___158: /* CIL Label */ 
    _L___159: /* CIL Label */ 
#line 14963
    if (tool == 4) {
      {
      {
#line 14964
      do_render_cur_text(0);
      }
      }
    } else
#line 14963
    if (tool == 5) {
      {
      {
#line 14964
      do_render_cur_text(0);
      }
      }
    }
    {
#line 14969
    tmp_tool = cur_tool;
#line 14970
    cur_tool = tool;
#line 14971
    draw_tux_text(2, "\251", 0);
#line 14972
    cur_tool = tmp_tool;
    }
  }
#line 14974
  if (done) {
    {
#line 14975
    SDL_JoystickClose(joystick);
    }
  }
#line 14976
  return (done);
}
}
#line 14997 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_open(void) 
{ 
  SDL_Surface *img ;
  SDL_Surface *img1 ;
  SDL_Surface *img2 ;
  SDL_Surface *org_surf ;
  int things_alloced ;
  SDL_Surface **thumbs ;
  DIR *d ;
  struct dirent *f ;
  struct dirent2 *fs ;
  int place ;
  char *dirname___160[5] ;
  char *rfname ;
  char **d_names ;
  char **d_exts ;
  int *d_places ;
  FILE *fi ;
  char fname[256] ;
  int num_files ;
  int i ;
  int done ;
  int slideshow ;
  int update_list ;
  int want_erase ;
  int want_export ;
  int cur ;
  int which ;
  int num_files_in_dirs ;
  int j ;
  int any_saved_files ;
  SDL_Rect dest ;
  SDL_Event event ;
  SDLKey key ;
  Uint32 last_click_time ;
  int last_click_which ;
  int last_click_button ;
  int places_to_look ;
  int opened_something ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  DIR *__cil_tmp46 ;
  struct dirent *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;
  int __cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  int __cil_tmp68 ;
  SDL_Surface *__cil_tmp69 ;
  SDL_Surface *__cil_tmp70 ;
  SDL_Surface *__cil_tmp71 ;
  SDL_Surface *__cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  SDL_Surface *__cil_tmp75 ;
  char *__cil_tmp76 ;
  SDL_Surface *__cil_tmp77 ;
  SDL_Surface *__cil_tmp78 ;
  SDL_Surface *__cil_tmp79 ;
  FILE *__cil_tmp80 ;
  int *__cil_tmp81 ;
  char *__cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  char *instructions ;
  char *__cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  int __cil_tmp89 ;
  int __cil_tmp90 ;
  int __cil_tmp91 ;
  int old_which ;
  Uint32 __cil_tmp93 ;
  Uint32 __cil_tmp94 ;
  int __cil_tmp95 ;
  char *__cil_tmp96 ;
  int __cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  char *__cil_tmp103 ;
  int __cil_tmp104 ;
  int __cil_tmp105 ;
  FILE *__cil_tmp106 ;
  SDL_Surface *__cil_tmp107 ;
  char *__cil_tmp108 ;
  SDL_Surface *__cil_tmp109 ;
  int __cil_tmp110 ;
  int __cil_tmp111 ;
  int __cil_tmp112 ;

  {
#line 15001
  thumbs = (SDL_Surface **)((void *)0);
#line 15008
  d_names = (char **)((void *)0);
#line 15008
  d_exts = (char **)((void *)0);
#line 15024
  motioner = 0;
#line 15024
  val_y = motioner;
#line 15024
  val_x = val_y;
#line 15025
  hatmotioner = 0;
#line 15025
  valhat_y = hatmotioner;
#line 15025
  valhat_x = valhat_y;
#line 15026
  opened_something = 0;
  {
#line 15028
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 15030
    do_setcursor(cursor_watch);
#line 15034
    things_alloced = 32;
#line 15036
    __cil_tmp44 = malloc(sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 15036
    fs = (struct dirent2 *)__cil_tmp44;
#line 15038
    num_files = 0;
#line 15039
    cur = 0;
#line 15040
    which = 0;
#line 15041
    slideshow = 0;
#line 15042
    num_files_in_dirs = 0;
#line 15043
    any_saved_files = 0;
#line 15048
    places_to_look = 0;
    }
    {
#line 15048
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 15048
      if (! (places_to_look < 5)) {
#line 15048
        goto while_break___0;
      }
#line 15050
      if (places_to_look == 0) {
        {
#line 15054
        dirname___160[places_to_look] = get_fname("saved", 0);
        }
      } else
#line 15056
      if (places_to_look == 1) {
#line 15059
        dirname___160[places_to_look] = (char *)((void *)0);
#line 15060
        goto while_continue___0;
      } else
#line 15062
      if (places_to_look == 2) {
#line 15065
        dirname___160[places_to_look] = (char *)((void *)0);
#line 15066
        goto while_continue___0;
      } else
#line 15068
      if (places_to_look == 3) {
#line 15071
        dirname___160[places_to_look] = (char *)((void *)0);
#line 15072
        goto while_continue___0;
      } else
#line 15074
      if (places_to_look == 4) {
#line 15077
        dirname___160[places_to_look] = (char *)((void *)0);
#line 15078
        goto while_continue___0;
      }
      {
#line 15084
      d = opendir((char const   *)dirname___160[places_to_look]);
      }
#line 15086
      if (d != (void *)0) {
        {
#line 15090
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 15092
          f = readdir(d);
          }
#line 15094
          if (f != (void *)0) {
            {
#line 15096
            memcpy(& (fs + num_files_in_dirs)->f, f, sizeof(struct dirent ));
#line 15097
            (fs + num_files_in_dirs)->place = places_to_look;
#line 15099
            num_files_in_dirs ++;
            }
#line 15101
            if (places_to_look == 0) {
#line 15102
              any_saved_files = 1;
            }
#line 15104
            if (num_files_in_dirs >= things_alloced) {
              {
#line 15106
              things_alloced += 32;
#line 15109
              __cil_tmp49 = realloc(fs, sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 15109
              fs = (struct dirent2 *)__cil_tmp49;
              }
            }
          }
#line 15090
          if (! (f != (void *)0)) {
#line 15090
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 15115
        closedir(d);
        }
      }
#line 15048
      places_to_look ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 15122
    __cil_tmp51 = malloc(sizeof(SDL_Surface *) * (unsigned long )num_files_in_dirs);
#line 15122
    thumbs = (SDL_Surface **)__cil_tmp51;
#line 15123
    __cil_tmp52 = malloc(sizeof(int ) * (unsigned long )num_files_in_dirs);
#line 15123
    d_places = (int *)__cil_tmp52;
#line 15124
    __cil_tmp53 = malloc(sizeof(char *) * (unsigned long )num_files_in_dirs);
#line 15124
    d_names = (char **)__cil_tmp53;
#line 15125
    __cil_tmp54 = malloc(sizeof(char *) * (unsigned long )num_files_in_dirs);
#line 15125
    d_exts = (char **)__cil_tmp54;
#line 15130
    qsort(fs, (size_t )num_files_in_dirs, sizeof(struct dirent2 ), (int (*)(void const   * ,
                                                                            void const   * ))(& compare_dirent2s));
#line 15135
    j = 0;
    }
    {
#line 15135
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 15135
      if (! (j < num_files_in_dirs)) {
#line 15135
        goto while_break___2;
      }
      {
#line 15137
      f = & (fs + j)->f;
#line 15138
      place = (fs + j)->place;
#line 15140
      show_progress_bar(screen);
      }
#line 15142
      if (f != (void *)0) {
        {
#line 15144
        debug((char const   *)((char *)f->d_name));
#line 15146
        __cil_tmp56 = strcasestr((char const   *)((char *)f->d_name), "-back.");
        }
        {
#line 15146
        __cil_tmp55 = strcasestr((char const   *)((char *)f->d_name), "-t.");
        }
#line 15146
        if (__cil_tmp55 == (void *)0) {
#line 15146
          if (__cil_tmp56 == (void *)0) {
            {
#line 15148
            __cil_tmp58 = strcasestr((char const   *)((char *)f->d_name), ".bmp");
            }
            {
#line 15148
            __cil_tmp57 = strcasestr((char const   *)((char *)f->d_name), ".png");
            }
#line 15148
            if (__cil_tmp57 != (void *)0) {
              _L: /* CIL Label */ 
              {
#line 15152
              safe_strncpy((char *)fname, (char const   *)((char *)f->d_name), sizeof(fname));
#line 15153
              __cil_tmp59 = strcasestr((char const   *)((char *)fname), ".png");
              }
#line 15153
              if (__cil_tmp59 != (void *)0) {
                {
#line 15155
                __cil_tmp60 = strcasestr((char const   *)((char *)fname), ".png");
#line 15155
                __cil_tmp61 = strdup((char const   *)__cil_tmp60);
#line 15155
                *(d_exts + num_files) = __cil_tmp61;
#line 15156
                __cil_tmp62 = strcasestr((char const   *)((char *)fname), ".png\324U");
#line 15156
                strcpy((char *)__cil_tmp62, "\220");
                }
              }
              {
#line 15159
              __cil_tmp63 = strcasestr((char const   *)((char *)fname), ".bmp\324U");
              }
#line 15159
              if (__cil_tmp63 != (void *)0) {
                {
#line 15161
                __cil_tmp64 = strcasestr((char const   *)((char *)fname), ".bmp\324U");
#line 15161
                __cil_tmp65 = strdup((char const   *)__cil_tmp64);
#line 15161
                *(d_exts + num_files) = __cil_tmp65;
#line 15162
                __cil_tmp66 = strcasestr((char const   *)((char *)fname), ".bmp");
#line 15162
                strcpy((char *)__cil_tmp66, "\220");
                }
              }
              {
#line 15165
              *(d_names + num_files) = strdup((char const   *)((char *)fname));
#line 15166
              *(d_places + num_files) = place;
#line 15172
              __cil_tmp68 = strcmp((char const   *)*(d_names + num_files), (char const   *)((char *)file_id));
              }
#line 15172
              if (__cil_tmp68 == 0) {
#line 15174
                which = num_files;
#line 15175
                cur = (which / 4) * 4;
#line 15180
                if (cur - 8 >= 0) {
#line 15181
                  cur -= 8;
                } else
#line 15182
                if (cur - 4 >= 0) {
#line 15183
                  cur -= 4;
                }
              }
              {
#line 15189
              safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png", dirname___160[*(d_places + num_files)],
                            *(d_names + num_files));
#line 15191
              debug((char const   *)((char *)fname));
#line 15192
              img = IMG_Load((char const   *)((char *)fname));
              }
#line 15194
              if (img == (void *)0) {
                {
#line 15199
                safe_snprintf((char *)fname, sizeof(fname), "%s/%s-t.pngt\324U", dirname___160[*(d_places + num_files)],
                              *(d_names + num_files));
#line 15201
                debug((char const   *)((char *)fname));
#line 15203
                img = IMG_Load((char const   *)((char *)fname));
                }
              }
#line 15206
              if (img != (void *)0) {
                {
#line 15209
                show_progress_bar(screen);
#line 15211
                img1 = SDL_DisplayFormat(img);
#line 15212
                SDL_FreeSurface(img);
                }
#line 15216
                if (img1->w > ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
                  {
                  {
                  {
#line 15219
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 15220
                  SDL_FreeSurface(img1);
                  }
                  }
#line 15221
                  img1 = img2;
                  }
                } else
#line 15216
                if (img1->h > (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                  {
                  {
                  {
#line 15219
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 15220
                  SDL_FreeSurface(img1);
                  }
                  }
#line 15221
                  img1 = img2;
                  }
                } else
#line 15216
                if (img1->w < ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
#line 15216
                  if (img1->h < (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                    {
                    {
                    {
#line 15219
                    img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                     (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                     0);
                    }
                    }
                    {
                    {
#line 15220
                    SDL_FreeSurface(img1);
                    }
                    }
#line 15221
                    img1 = img2;
                    }
                  }
                }
#line 15224
                *(thumbs + num_files) = img1;
#line 15226
                if (*(thumbs + num_files) == (void *)0) {
                  {
#line 15228
                  fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\n",
                          (char *)fname);
                  }
                }
#line 15232
                num_files ++;
              } else {
                {
#line 15239
                __cil_tmp74 = make_directory(0, "saved", "Can\'t create user data directory (for saved drawings) (E006)");
                }
#line 15239
                if (__cil_tmp74) {
                  {
#line 15242
                  make_directory(0, "saved/.thumbsU", "Can\'t create user data thumbnail directory (for saved drawings\' thumbnails) (E007)\237t\324U");
                  }
                }
#line 15246
                if (img == (void *)0) {
                  {
#line 15248
                  safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___160[*(d_places + num_files)],
                                (char *)f->d_name);
#line 15249
                  debug((char const   *)((char *)fname));
#line 15250
                  img = myIMG_Load((char const   *)((char *)fname));
                  }
                }
                {
#line 15254
                show_progress_bar(screen);
                }
#line 15256
                if (img == (void *)0) {
                  {
#line 15258
                  __cil_tmp76 = SDL_GetError();
#line 15258
                  fprintf(stderr, "\nWarning: I can\'t open one of the saved files!\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
                          (char *)fname, __cil_tmp76);
#line 15264
                  free(*(d_names + num_files));
#line 15265
                  free(*(d_exts + num_files));
                  }
                } else {
                  {
#line 15271
                  img1 = SDL_DisplayFormatAlpha(img);
#line 15272
                  img2 = thumbnail2(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                    (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                    0, 0);
#line 15273
                  SDL_FreeSurface(img1);
#line 15275
                  show_progress_bar(screen);
#line 15277
                  *(thumbs + num_files) = SDL_DisplayFormat(img2);
#line 15278
                  SDL_FreeSurface(img2);
                  }
#line 15279
                  if (*(thumbs + num_files) == (void *)0) {
                    {
#line 15281
                    fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\n",
                            (char *)fname);
                    }
                  }
                  {
#line 15285
                  SDL_FreeSurface(img);
#line 15287
                  show_progress_bar(screen);
                  }
#line 15293
                  if (*(d_places + num_files) == 0) {
                    {
#line 15295
                    debug("Saving thumbnail for this one!");
#line 15297
                    safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png",
                                  dirname___160[*(d_places + num_files)], *(d_names + num_files));
#line 15300
                    fi = fopen((char const   *)((char *)fname), "wb");
                    }
#line 15301
                    if (fi == (void *)0) {
                      {
#line 15303
                      __cil_tmp81 = __errno_location();
#line 15303
                      __cil_tmp82 = strerror(*__cil_tmp81);
#line 15303
                      fprintf(stderr, "\nError: Couldn\'t save thumbnail of saved image!\n%s\nThe error that occurred was:\n%s\n\n",
                              (char *)fname, __cil_tmp82);
                      }
                    } else {
                      {
#line 15310
                      do_png_save(fi, (char const   *)((char *)fname), *(thumbs + num_files),
                                  0);
                      }
                    }
                    {
#line 15313
                    show_progress_bar(screen);
                    }
                  }
#line 15317
                  num_files ++;
                }
              }
            } else
#line 15148
            if (__cil_tmp58 != (void *)0) {
#line 15148
              goto _L;
            }
          }
        }
      }
#line 15135
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 15337
    if (num_files == 0) {
      {
#line 15339
      do_prompt_snd("There are no saved files!", "OK", "\230", 26, button_w / 2, ((6 * button_h + (int )r_ttools.h) + button_h / 2) - (tool_scroll * button_h) / (int )gd_tools.cols);
      }
    } else {
      {
#line 15349
      __cil_tmp86 = textdir("Choose the picture you want, then click \342\200\234Open\342\200\235.");
#line 15349
      instructions = __cil_tmp86;
#line 15350
      draw_tux_text(2, (char const   *)instructions, 1);
#line 15355
      update_list = 1;
#line 15356
      want_erase = 0;
#line 15357
      want_export = 0;
#line 15359
      done = 0;
#line 15360
      slideshow = 0;
#line 15362
      last_click_which = - 1;
#line 15363
      last_click_time = (Uint32 )0;
#line 15364
      last_click_button = - 1;
#line 15367
      do_setcursor(cursor_arrow);
      }
      {
#line 15370
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 15374
        if (update_list) {
          {
#line 15378
          dest.x = (Sint16 )r_ttools.w;
#line 15379
          dest.y = (Sint16 )0;
#line 15380
          dest.w = (Uint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w);
#line 15381
          dest.h = (Uint16 )(button_h * buttons_tall + (int )r_ttools.h);
#line 15383
          SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 15388
          i = cur;
          }
          {
#line 15388
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 15388
            if (! (i < cur + 16 && i < num_files)) {
#line 15388
              goto while_break___4;
            }
#line 15392
            dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w);
#line 15393
            dest.y = (Sint16 )(((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h);
#line 15395
            if (i == which) {
              {
#line 15397
              SDL_UpperBlit(img_cursor_down, (SDL_Rect *)((void *)0), screen, & dest);
#line 15398
              debug((char const   *)*(d_names + i));
              }
            } else {
              {
#line 15401
              SDL_UpperBlit(img_cursor_up, (SDL_Rect *)((void *)0), screen, & dest);
              }
            }
#line 15405
            dest.x = (Sint16 )((((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w) + 10) + ((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) - (*(thumbs + i))->w) / 2);
#line 15406
            dest.y = (Sint16 )(((((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h) + 10) + (((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) - (*(thumbs + i))->h) / 2);
#line 15408
            if (*(thumbs + i) != (void *)0) {
              {
#line 15409
              SDL_UpperBlit(*(thumbs + i), (SDL_Rect *)((void *)0), screen, & dest);
              }
            }
#line 15388
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 15415
          dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 15416
          dest.y = (Sint16 )0;
#line 15418
          if (cur > 0) {
            {
#line 15419
            SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
            }
          } else {
            {
#line 15421
            SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
            }
          }
#line 15423
          dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 15424
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 15426
          if (cur < num_files - 16) {
            {
#line 15427
            SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
            }
          } else {
            {
#line 15429
            SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
            }
          }
          {
#line 15434
          dest.x = (Sint16 )r_ttools.w;
#line 15435
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 15436
          SDL_UpperBlit(img_open, (SDL_Rect *)((void *)0), screen, & dest);
#line 15438
          dest.x = (Sint16 )((int )r_ttools.w + (button_w - img_openlabels_open->w) / 2);
#line 15439
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_open->h);
#line 15440
          SDL_UpperBlit(img_openlabels_open, (SDL_Rect *)((void *)0), screen, & dest);
#line 15445
          dest.x = (Sint16 )((int )r_ttools.w + button_w);
#line 15446
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
          }
#line 15447
          if (any_saved_files) {
            {
#line 15448
            SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
            }
          } else {
            {
#line 15450
            SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
            }
          }
          {
#line 15452
          dest.x = (Sint16 )((int )r_ttools.w + button_w);
#line 15453
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 15454
          SDL_UpperBlit(img_slideshow, (SDL_Rect *)((void *)0), screen, & dest);
#line 15456
          dest.x = (Sint16 )(((int )r_ttools.w + button_w) + (button_w - img_openlabels_slideshow->w) / 2);
#line 15457
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_slideshow->h);
#line 15458
          SDL_UpperBlit(img_openlabels_slideshow, (SDL_Rect *)((void *)0), screen,
                        & dest);
#line 15463
          dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w);
#line 15464
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 15465
          SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 15467
          dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) + (button_w - img_openlabels_back->w) / 2);
#line 15468
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_back->h);
#line 15469
          SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 15474
          dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) - button_w);
#line 15475
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
          }
#line 15477
          if (*(d_places + which) != 2) {
#line 15477
            if (*(d_places + which) != 1) {
              {
#line 15478
              SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
              }
            } else {
              {
              {
#line 15480
              SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
              }
              }
            }
          } else {
            {
            {
#line 15480
            SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
            }
            }
          }
          {
#line 15482
          dest.x = (Sint16 )(((((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) - button_w) + (button_w - img_pict_export->w) / 2);
#line 15483
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 15484
          SDL_UpperBlit(img_pict_export, (SDL_Rect *)((void *)0), screen, & dest);
#line 15486
          dest.x = (Sint16 )(((((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) - button_w) + (button_w - img_openlabels_pict_export->w) / 2);
#line 15487
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_pict_export->h);
#line 15488
          SDL_UpperBlit(img_openlabels_pict_export, (SDL_Rect *)((void *)0), screen,
                        & dest);
#line 15493
          dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w);
#line 15494
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
          }
#line 15496
          if (*(d_places + which) != 2) {
#line 15496
            if (*(d_places + which) != 1) {
              {
#line 15497
              SDL_UpperBlit(img_erase, (SDL_Rect *)((void *)0), screen, & dest);
              }
            } else {
              {
              {
#line 15499
              SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
              }
              }
            }
          } else {
            {
            {
#line 15499
            SDL_UpperBlit(img_btn_off, (SDL_Rect *)((void *)0), screen, & dest);
            }
            }
          }
          {
#line 15501
          dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) + (button_w - img_openlabels_erase->w) / 2);
#line 15502
          dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_erase->h);
#line 15503
          SDL_UpperBlit(img_openlabels_erase, (SDL_Rect *)((void *)0), screen, & dest);
#line 15506
          SDL_Flip(screen);
#line 15508
          update_list = 0;
          }
        }
        {
#line 15511
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 15511
          __cil_tmp88 = SDL_PollEvent(& event);
          }
#line 15511
          if (! __cil_tmp88) {
#line 15511
            goto while_break___5;
          }
#line 15513
          if ((int )event.type == 12) {
#line 15515
            done = 1;
          } else
#line 15519
          if ((int )event.type == 1) {
            {
#line 15521
            handle_active(& event);
            }
          } else
#line 15523
          if ((int )event.type == 3) {
            {
#line 15525
            key = event.key.keysym.sym;
#line 15527
            handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
            }
          } else
#line 15529
          if ((int )event.type == 2) {
            {
#line 15531
            key = event.key.keysym.sym;
#line 15533
            handle_keymouse(key, (Uint8 )2, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
            }
#line 15537
            if ((unsigned int )key == 292U) {
#line 15539
              if (which > 0) {
#line 15541
                __cil_tmp89 = which;
#line 15541
                which --;
#line 15543
                if (which < cur) {
#line 15544
                  cur -= 4;
                }
#line 15546
                update_list = 1;
              }
            } else
#line 15549
            if ((unsigned int )key == 293U) {
#line 15551
              if (which < num_files - 1) {
#line 15553
                which ++;
#line 15555
                if (which >= cur + 16) {
#line 15556
                  cur += 4;
                }
#line 15558
                update_list = 1;
              }
            } else
#line 15561
            if ((unsigned int )key == 289U) {
#line 15563
              if (which >= 0) {
#line 15565
                which -= 4;
#line 15567
                if (which < 0) {
#line 15568
                  which = 0;
                }
#line 15570
                if (which < cur) {
#line 15571
                  cur -= 4;
                }
#line 15573
                update_list = 1;
              }
            } else
#line 15576
            if ((unsigned int )key == 288U) {
#line 15578
              if (which < num_files) {
#line 15580
                which += 4;
#line 15582
                if (which >= num_files) {
#line 15583
                  which = num_files - 1;
                }
#line 15585
                if (which >= cur + 16) {
#line 15586
                  cur += 4;
                }
#line 15588
                update_list = 1;
              }
            } else
#line 15591
            if ((unsigned int )key == 13U) {
              {
#line 15595
              done = 1;
#line 15596
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
            } else
#line 15598
            if ((unsigned int )key == 27U) {
              {
#line 15602
              which = - 1;
#line 15603
              done = 1;
#line 15604
              playsound(screen, 1, 1, 1, - 999, - 999);
              }
            } else
#line 15606
            if ((unsigned int )key == 100U) {
#line 15606
              if ((unsigned int )event.key.keysym.mod & 192U) {
#line 15606
                if (*(d_places + which) != 2) {
#line 15606
                  if (*(d_places + which) != 1) {
#line 15606
                    if (! noshortcuts) {
#line 15613
                      want_erase = 1;
                    }
                  }
                }
              }
            }
          } else {
            {
#line 15616
            __cil_tmp91 = valid_click(event.button.button);
            }
#line 15616
            if ((int )event.type == 5) {
#line 15616
              if (__cil_tmp91) {
#line 15618
                if ((int )event.button.x >= (int )r_ttools.w) {
#line 15618
                  if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 15618
                    if ((int )event.button.y >= img_scroll_up->h) {
#line 15618
                      if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15623
                        old_which = which;
#line 15625
                        which = (((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur;
#line 15627
                        if (which < num_files) {
                          {
#line 15629
                          playsound(screen, 1, 2, 1, (int )event.button.x, - 999);
#line 15630
                          update_list = 1;
#line 15633
                          __cil_tmp93 = SDL_GetTicks();
                          }
#line 15633
                          if (which == last_click_which) {
#line 15633
                            if (__cil_tmp93 < last_click_time + 1000U) {
#line 15633
                              if ((int )event.button.button == last_click_button) {
#line 15638
                                done = 1;
                              }
                            }
                          }
                          {
#line 15641
                          last_click_which = which;
#line 15642
                          last_click_time = SDL_GetTicks();
#line 15643
                          last_click_button = (int )event.button.button;
                          }
                        } else {
#line 15646
                          which = old_which;
                        }
                      } else {
#line 15618
                        goto _L___177;
                      }
                    } else {
#line 15618
                      goto _L___177;
                    }
                  } else {
#line 15618
                    goto _L___177;
                  }
                } else
                _L___177: /* CIL Label */ 
                _L___178: /* CIL Label */ 
                _L___179: /* CIL Label */ 
#line 15648
                if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 15648
                  if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 15651
                    if ((int )event.button.y < img_scroll_up->h) {
#line 15655
                      if (cur > 0) {
                        {
#line 15657
                        cur -= 4;
#line 15658
                        update_list = 1;
#line 15659
                        playsound(screen, 1, 7, 1, - 998, - 999);
                        }
#line 15661
                        if (cur == 0) {
                          {
#line 15662
                          do_setcursor(cursor_arrow);
                          }
                        }
                      }
#line 15665
                      if (which >= cur + 16) {
#line 15666
                        which -= 4;
                      }
                    } else
#line 15668
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15668
                      if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_up->h) {
#line 15673
                        if (cur < num_files - 16) {
                          {
#line 15675
                          cur += 4;
#line 15676
                          update_list = 1;
#line 15677
                          playsound(screen, 1, 7, 1, - 998, - 999);
                          }
#line 15679
                          if (cur >= num_files - 16) {
                            {
#line 15680
                            do_setcursor(cursor_arrow);
                            }
                          }
                        }
#line 15683
                        if (which < cur) {
#line 15684
                          which += 4;
                        }
                      }
                    }
                  } else {
#line 15648
                    goto _L___176;
                  }
                } else
                _L___176: /* CIL Label */ 
#line 15687
                if ((int )event.button.x >= (int )r_ttools.w) {
#line 15687
                  if ((int )event.button.x < (int )r_ttools.w + button_w) {
#line 15687
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15687
                      if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                        {
#line 15693
                        done = 1;
#line 15694
                        playsound(screen, 1, 1, 1, - 997, - 999);
                        }
                      } else {
#line 15687
                        goto _L___173;
                      }
                    } else {
#line 15687
                      goto _L___173;
                    }
                  } else {
#line 15687
                    goto _L___173;
                  }
                } else
                _L___173: /* CIL Label */ 
                _L___174: /* CIL Label */ 
                _L___175: /* CIL Label */ 
#line 15696
                if ((int )event.button.x >= (int )r_ttools.w + button_w) {
#line 15696
                  if ((int )event.button.x < ((int )r_ttools.w + button_w) + button_w) {
#line 15696
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15696
                      if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
#line 15696
                        if (any_saved_files == 1) {
                          {
#line 15702
                          done = 1;
#line 15703
                          slideshow = 1;
#line 15704
                          playsound(screen, 1, 1, 1, - 997, - 999);
                          }
                        } else {
#line 15696
                          goto _L___169;
                        }
                      } else {
#line 15696
                        goto _L___169;
                      }
                    } else {
#line 15696
                      goto _L___169;
                    }
                  } else {
#line 15696
                    goto _L___169;
                  }
                } else
                _L___169: /* CIL Label */ 
                _L___170: /* CIL Label */ 
                _L___171: /* CIL Label */ 
                _L___172: /* CIL Label */ 
#line 15706
                if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 15706
                  if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 15706
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15706
                      if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                        {
#line 15713
                        which = - 1;
#line 15714
                        done = 1;
#line 15715
                        playsound(screen, 1, 1, 1, - 999, - 999);
                        }
                      } else {
#line 15706
                        goto _L___166;
                      }
                    } else {
#line 15706
                      goto _L___166;
                    }
                  } else {
#line 15706
                    goto _L___166;
                  }
                } else
                _L___166: /* CIL Label */ 
                _L___167: /* CIL Label */ 
                _L___168: /* CIL Label */ 
#line 15717
                if ((int )event.button.x >= ((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) {
#line 15717
                  if ((int )event.button.x < (WINDOW_WIDTH - button_w) - (int )r_ttoolopt.w) {
#line 15717
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15717
                      if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
#line 15717
                        if (*(d_places + which) != 2) {
#line 15717
                          if (*(d_places + which) != 1) {
#line 15725
                            want_erase = 1;
                          } else {
#line 15717
                            goto _L___161;
                          }
                        } else {
#line 15717
                          goto _L___161;
                        }
                      } else {
#line 15717
                        goto _L___161;
                      }
                    } else {
#line 15717
                      goto _L___161;
                    }
                  } else {
#line 15717
                    goto _L___161;
                  }
                } else
                _L___161: /* CIL Label */ 
                _L___162: /* CIL Label */ 
                _L___163: /* CIL Label */ 
                _L___164: /* CIL Label */ 
                _L___165: /* CIL Label */ 
#line 15727
                if ((int )event.button.x >= (((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) - button_w) {
#line 15727
                  if ((int )event.button.x < ((WINDOW_WIDTH - button_w) - button_w) - (int )r_ttoolopt.w) {
#line 15727
                    if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15727
                      if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
#line 15727
                        if (*(d_places + which) != 2) {
#line 15727
                          if (*(d_places + which) != 1) {
#line 15735
                            want_export = 1;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 15616
                goto _L___200;
              }
            } else
            _L___200: /* CIL Label */ 
#line 15738
            if ((int )event.type == 5) {
#line 15738
              if ((int )event.button.button >= 4) {
#line 15738
                if ((int )event.button.button <= 5) {
#line 15738
                  if (wheely) {
#line 15743
                    if ((int )event.button.button == 4) {
#line 15743
                      if (cur > 0) {
                        {
#line 15745
                        cur -= 4;
#line 15746
                        update_list = 1;
#line 15747
                        playsound(screen, 1, 7, 1, - 998, - 999);
                        }
#line 15749
                        if (cur == 0) {
                          {
#line 15750
                          do_setcursor(cursor_arrow);
                          }
                        }
#line 15752
                        if (which >= cur + 16) {
#line 15753
                          which -= 4;
                        }
                      } else {
#line 15743
                        goto _L___180;
                      }
                    } else
                    _L___180: /* CIL Label */ 
#line 15755
                    if ((int )event.button.button == 5) {
#line 15755
                      if (cur < num_files - 16) {
                        {
#line 15757
                        cur += 4;
#line 15758
                        update_list = 1;
#line 15759
                        playsound(screen, 1, 7, 1, - 998, - 999);
                        }
#line 15761
                        if (cur >= num_files - 16) {
                          {
#line 15762
                          do_setcursor(cursor_arrow);
                          }
                        }
#line 15764
                        if (which < cur) {
#line 15765
                          which += 4;
                        }
                      }
                    }
                  } else {
#line 15738
                    goto _L___197;
                  }
                } else {
#line 15738
                  goto _L___197;
                }
              } else {
#line 15738
                goto _L___197;
              }
            } else
            _L___197: /* CIL Label */ 
            _L___198: /* CIL Label */ 
            _L___199: /* CIL Label */ 
#line 15768
            if ((int )event.type == 4) {
#line 15772
              if ((int )event.button.y < img_scroll_up->h) {
#line 15772
                if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 15772
                  if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 15772
                    if (cur > 0) {
                      {
#line 15778
                      do_setcursor(cursor_up);
                      }
                    } else {
#line 15772
                      goto _L___194;
                    }
                  } else {
#line 15772
                    goto _L___194;
                  }
                } else {
#line 15772
                  goto _L___194;
                }
              } else
              _L___194: /* CIL Label */ 
              _L___195: /* CIL Label */ 
              _L___196: /* CIL Label */ 
#line 15780
              if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15780
                if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_up->h) {
#line 15780
                  if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 15780
                    if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 15780
                      if (cur < num_files - 16) {
                        {
#line 15787
                        do_setcursor(cursor_down);
                        }
                      } else {
#line 15780
                        goto _L___190;
                      }
                    } else {
#line 15780
                      goto _L___190;
                    }
                  } else {
#line 15780
                    goto _L___190;
                  }
                } else {
#line 15780
                  goto _L___190;
                }
              } else
              _L___190: /* CIL Label */ 
              _L___191: /* CIL Label */ 
              _L___192: /* CIL Label */ 
              _L___193: /* CIL Label */ 
#line 15789
              if ((int )event.button.x >= (int )r_ttools.w) {
#line 15789
                if ((int )event.button.x < ((int )r_ttools.w + button_w) + button_w) {
                  _L___183: /* CIL Label */ 
                  _L___187: /* CIL Label */ 
#line 15789
                  if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15789
                    if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                      {
#line 15802
                      do_setcursor(cursor_hand);
                      }
                    } else {
#line 15789
                      goto _L___181;
                    }
                  } else {
#line 15789
                    goto _L___181;
                  }
                } else {
#line 15789
                  goto _L___189;
                }
              } else
              _L___189: /* CIL Label */ 
#line 15789
              if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 15789
                if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 15789
                  goto _L___183;
                } else {
#line 15789
                  goto _L___188;
                }
              } else
              _L___188: /* CIL Label */ 
#line 15789
              if ((int )event.button.x >= (((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) - button_w) {
#line 15789
                if ((int )event.button.x < (WINDOW_WIDTH - button_w) - (int )r_ttoolopt.w) {
#line 15789
                  if (*(d_places + which) != 2) {
#line 15789
                    if (*(d_places + which) != 1) {
#line 15789
                      goto _L___183;
                    } else {
#line 15789
                      goto _L___181;
                    }
                  } else {
#line 15789
                    goto _L___181;
                  }
                } else {
#line 15789
                  goto _L___181;
                }
              } else
              _L___181: /* CIL Label */ 
              _L___182: /* CIL Label */ 
              _L___184: /* CIL Label */ 
              _L___185: /* CIL Label */ 
              _L___186: /* CIL Label */ 
#line 15804
              if ((int )event.button.x >= (int )r_ttools.w) {
#line 15804
                if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 15804
                  if ((int )event.button.y > img_scroll_up->h) {
#line 15804
                    if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 15804
                      if ((((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur < num_files) {
                        {
#line 15812
                        do_setcursor(cursor_hand);
                        }
                      } else {
                        {
                        {
                        {
                        {
                        {
#line 15818
                        do_setcursor(cursor_arrow);
                        }
                        }
                        }
                        }
                        }
                      }
                    } else {
                      {
                      {
                      {
                      {
                      {
#line 15818
                      do_setcursor(cursor_arrow);
                      }
                      }
                      }
                      }
                      }
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 15818
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 15818
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 15818
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
                }
              }
#line 15820
              oldpos_x = (int )event.button.x;
#line 15821
              oldpos_y = (int )event.button.y;
            } else
#line 15824
            if ((int )event.type == 7) {
              {
#line 15825
              handle_joyaxismotion(event, & motioner, & val_x, & val_y);
              }
            } else
#line 15827
            if ((int )event.type == 9) {
              {
#line 15828
              handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y,
                                  & hatmotioner, & old_hat_ticks);
              }
            } else
#line 15830
            if ((int )event.type == 8) {
              {
#line 15831
              handle_joyballmotion(event, oldpos_x, oldpos_y);
              }
            } else
#line 15833
            if ((int )event.type == 10) {
              {
              {
#line 15834
              handle_joybuttonupdown(event, oldpos_x, oldpos_y);
              }
              }
            } else
#line 15833
            if ((int )event.type == 11) {
              {
              {
#line 15834
              handle_joybuttonupdown(event, oldpos_x, oldpos_y);
              }
              }
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 15837
        if (motioner | hatmotioner) {
          {
#line 15838
          handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                           val_x, val_y, valhat_x, valhat_y);
          }
        }
        {
#line 15842
        SDL_Delay((Uint32 )10);
        }
#line 15844
        if (want_erase) {
          {
#line 15846
          want_erase = 0;
#line 15848
          __cil_tmp95 = do_prompt_image_snd("Erase this picture?", "Yes, erase it!",
                                            "No, don\342\200\231t erase it!", *(thumbs + which),
                                            img_popup_arrow, img_trash, 25, (((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) + 24,
                                            ((button_h * buttons_tall + (int )r_ttools.h) - button_h) + img_scroll_up->h);
          }
#line 15848
          if (__cil_tmp95) {
            {
#line 15854
            safe_snprintf((char *)fname, sizeof(fname), "saved/%s%s", *(d_names + which),
                          *(d_exts + which));
#line 15856
            rfname = get_fname((char const   *)((char *)fname), 0);
#line 15858
            __cil_tmp97 = trash(rfname);
            }
#line 15858
            if (__cil_tmp97 == 0) {
              {
#line 15860
              update_list = 1;
#line 15865
              safe_snprintf((char *)fname, sizeof(fname), "saved/.thumbs/%s-t.png",
                            *(d_names + which));
#line 15867
              free(rfname);
#line 15868
              rfname = get_fname((char const   *)((char *)fname), 0);
#line 15870
              unlink((char const   *)rfname);
#line 15875
              safe_snprintf((char *)fname, sizeof(fname), "saved/%s-t.png", *(d_names + which));
#line 15877
              free(rfname);
#line 15878
              rfname = get_fname((char const   *)((char *)fname), 0);
#line 15880
              unlink((char const   *)rfname);
#line 15885
              safe_snprintf((char *)fname, sizeof(fname), "saved/%s.dat", *(d_names + which));
#line 15887
              free(rfname);
#line 15888
              rfname = get_fname((char const   *)((char *)fname), 0);
#line 15890
              trash(rfname);
#line 15896
              free(*(d_names + which));
#line 15897
              free(*(d_exts + which));
#line 15898
              free_surface(thumbs + which);
#line 15900
              *(thumbs + which) = (SDL_Surface *)((void *)0);
#line 15902
              i = which;
              }
              {
#line 15902
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 15902
                if (! (i < num_files - 1)) {
#line 15902
                  goto while_break___6;
                }
#line 15904
                *(d_names + i) = *(d_names + (i + 1));
#line 15905
                *(d_exts + i) = *(d_exts + (i + 1));
#line 15906
                *(thumbs + i) = *(thumbs + (i + 1));
#line 15907
                *(d_places + i) = *(d_places + (i + 1));
#line 15902
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 15910
              __cil_tmp102 = num_files;
#line 15910
              num_files --;
#line 15915
              if (which >= num_files) {
#line 15916
                which = num_files - 1;
              }
#line 15921
              if (which < cur) {
#line 15921
                if (cur >= 4) {
#line 15923
                  cur -= 4;
#line 15924
                  update_list = 1;
                }
              }
#line 15930
              if (which < 0) {
                {
#line 15932
                do_prompt_snd("There are no saved files!", "OK", "\230", 26, screen->w / 2,
                              screen->h / 2);
#line 15934
                done = 1;
                }
              }
            } else {
              {
#line 15939
              perror((char const   *)rfname);
#line 15941
              do_prompt_snd("CAN\'T", "OK", "\230", 26, 0, 0);
#line 15942
              update_list = 1;
              }
            }
            {
#line 15945
            free(rfname);
            }
          } else {
#line 15949
            update_list = 1;
          }
        }
#line 15953
        if (want_export) {
          {
#line 15955
          want_export = 0;
#line 15957
          safe_snprintf((char *)fname, sizeof(fname), "saved/%s%s", *(d_names + which),
                        *(d_exts + which));
#line 15958
          rfname = get_fname((char const   *)((char *)fname), 0);
#line 15959
          __cil_tmp104 = export_pict(rfname);
          }
#line 15959
          if (__cil_tmp104) {
            {
#line 15960
            do_prompt_snd("Your picture has been exported!", "OK", "\230", 27, screen->w / 2,
                          screen->h / 2);
            }
          } else {
            {
#line 15962
            do_prompt_snd("Sorry! Your picture could not be exported!", "OK", "\230",
                          26, screen->w / 2, screen->h / 2);
            }
          }
          {
#line 15964
          draw_tux_text(2, (char const   *)instructions, 1);
#line 15965
          update_list = 1;
          }
        }
#line 15370
        if (! (! done)) {
#line 15370
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 15971
      if (! slideshow) {
#line 15975
        if (which != -1) {
#line 15979
          if (! been_saved) {
#line 15979
            if (! disable_save) {
              {
#line 15981
              __cil_tmp105 = do_prompt_image_snd("Save your picture first?\323\001 ",
                                                 "Yes, save it!", "No, don\342\200\231t bother saving!",
                                                 img_tools[13], (SDL_Surface *)((void *)0),
                                                 (SDL_Surface *)((void *)0), 25, screen->w / 2,
                                                 screen->h / 2);
              }
#line 15981
              if (__cil_tmp105) {
                {
#line 15987
                do_save(12, 1);
                }
              }
            }
          }
          {
#line 15992
          delete_label_list(& start_label_node);
#line 15993
          label_node_to_edit = (struct label_node *)((void *)0);
#line 15993
          highlighted_label_node = label_node_to_edit;
#line 15993
          first_label_node_in_redo_stack = highlighted_label_node;
#line 15993
          current_label_node = first_label_node_in_redo_stack;
#line 15993
          start_label_node = current_label_node;
#line 15995
          have_to_rec_label_node = 0;
#line 15997
          SDL_FillRect(label, (SDL_Rect *)((void *)0), 0U);
#line 16001
          safe_snprintf((char *)fname, sizeof(fname), "%s/%s%s", dirname___160[*(d_places + which)],
                        *(d_names + which), *(d_exts + which));
#line 16002
          fi = fopen((char const   *)((char *)fname), "r");
          }
#line 16003
          if (fi == (void *)0) {
            {
#line 16005
            fprintf(stderr, "\nWarning: Couldn\'t load the saved image! (1)\n%s\nThe file is missing.\n\n\n",
                    (char *)fname);
#line 16008
            do_prompt("Can\342\200\231t open that picture!", "OK", "\251", 0, 0);
            }
          }
          {
#line 16010
          fclose(fi);
#line 16012
          img = myIMG_Load((char const   *)((char *)fname));
          }
#line 16014
          if (img == (void *)0) {
            {
#line 16016
            __cil_tmp108 = SDL_GetError();
#line 16016
            fprintf(stderr, "\nWarning: Couldn\'t load the saved image! (2)\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
                    (char *)fname, __cil_tmp108);
#line 16022
            do_prompt("Can\342\200\231t open that picture!", "OK", "\251", 0, 0);
            }
          } else {
            {
#line 16026
            free_surface(& img_starter);
#line 16027
            free_surface(& img_starter_bkgd);
#line 16028
            starter_mirrored = 0;
#line 16029
            starter_flipped = 0;
#line 16030
            starter_personal = 0;
#line 16032
            org_surf = SDL_DisplayFormat(img);
#line 16034
            autoscale_copy_smear_free(img, canvas, & SDL_UpperBlit);
#line 16036
            cur_undo = 0;
#line 16037
            oldest_undo = 0;
#line 16038
            newest_undo = 0;
#line 16042
            been_saved = 1;
#line 16044
            safe_strncpy((char *)file_id, (char const   *)*(d_names + which), sizeof(file_id));
#line 16045
            starter_id[0] = (char )'\000';
#line 16046
            template_id[0] = (char )'\000';
#line 16052
            load_starter_id(*(d_names + which), (FILE *)((void *)0));
            }
#line 16054
            if ((int )starter_id[0] != 0) {
              {
#line 16056
              load_starter((char *)starter_id);
              }
#line 16058
              if (starter_mirrored) {
                {
#line 16059
                mirror_starter();
                }
              }
#line 16061
              if (starter_flipped) {
                {
#line 16062
                flip_starter();
                }
              }
            } else
#line 16064
            if ((int )template_id[0] != 0) {
              {
#line 16065
              load_template((char *)template_id);
              }
            }
            {
#line 16067
            load_embedded_data((char *)fname, org_surf);
#line 16069
            reset_avail_tools();
#line 16071
            tool_avail_bak[8] = 0;
#line 16072
            tool_avail_bak[9] = 0;
#line 16074
            opened_something = 1;
            }
          }
        }
      }
      {
#line 16080
      update_canvas(0, 0, (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w,
                    button_h * buttons_tall + (int )r_ttools.h);
#line 16082
      free(instructions);
      }
    }
    {
#line 16088
    free_surface_array(thumbs, num_files);
#line 16090
    free(thumbs);
#line 16092
    i = 0;
    }
    {
#line 16092
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 16092
      if (! (i < num_files)) {
#line 16092
        goto while_break___7;
      }
      {
#line 16094
      free(*(d_names + i));
#line 16095
      free(*(d_exts + i));
      }
#line 16092
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 16098
    i = 0;
    {
#line 16098
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 16098
      if (! (i < 5)) {
#line 16098
        goto while_break___8;
      }
#line 16099
      if (dirname___160[i] != (void *)0) {
        {
#line 16100
        free(dirname___160[i]);
        }
      }
#line 16098
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 16102
    free(d_names);
#line 16103
    free(d_exts);
#line 16104
    free(d_places);
    }
#line 16107
    if (slideshow) {
      {
#line 16109
      slideshow = do_slideshow();
      }
    }
#line 15028
    if (! slideshow) {
#line 15028
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 16114
  return (opened_something);
}
}
#line 16124 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_slideshow(void) 
{ 
  SDL_Surface *img ;
  SDL_Surface *img1 ;
  SDL_Surface *img2 ;
  int things_alloced ;
  SDL_Surface **thumbs ;
  DIR *d ;
  struct dirent *f ;
  struct dirent2 *fs ;
  char *dirname___201 ;
  char **d_names ;
  char **d_exts ;
  int *selected ;
  int num_selected ;
  FILE *fi ;
  char fname[1024] ;
  int num_files ;
  int num_files_in_dir ;
  int i ;
  int done ;
  int update_list ;
  int cur ;
  int which ;
  int j ;
  int go_back ;
  int found ;
  int speed ;
  SDL_Rect dest ;
  SDL_Event event ;
  SDLKey key ;
  char *freeme ;
  char *instructions ;
  int speeds ;
  float x_per ;
  float y_per ;
  int xx ;
  int yy ;
  SDL_Surface *btn ;
  SDL_Surface *blnk ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  int export_successful ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  DIR *__cil_tmp48 ;
  struct dirent *__cil_tmp49 ;
  int __cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  SDL_Surface *__cil_tmp69 ;
  SDL_Surface *__cil_tmp70 ;
  SDL_Surface *__cil_tmp71 ;
  SDL_Surface *__cil_tmp72 ;
  int __cil_tmp73 ;
  int __cil_tmp74 ;
  SDL_Surface *__cil_tmp75 ;
  char *__cil_tmp76 ;
  SDL_Surface *__cil_tmp77 ;
  SDL_Surface *__cil_tmp78 ;
  SDL_Surface *__cil_tmp79 ;
  FILE *__cil_tmp80 ;
  int *__cil_tmp81 ;
  char *__cil_tmp82 ;
  int __cil_tmp83 ;
  int __cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  int __cil_tmp87 ;
  int __cil_tmp88 ;
  double __cil_tmp89 ;
  double __cil_tmp90 ;
  SDL_Surface *__cil_tmp91 ;
  SDL_Surface *__cil_tmp92 ;
  SDL_Surface *__cil_tmp93 ;
  int __cil_tmp94 ;
  int __cil_tmp95 ;
  int __cil_tmp96 ;
  int __cil_tmp97 ;
  int __cil_tmp98 ;
  int __cil_tmp99 ;
  int __cil_tmp100 ;
  int __cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  int old_speed ;
  int control_sound ;
  int click_x ;
  char *__cil_tmp107 ;
  int __cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  int __cil_tmp111 ;

  {
#line 16128
  thumbs = (SDL_Surface **)((void *)0);
#line 16133
  d_names = (char **)((void *)0);
  {
#line 16133
  d_exts = (char **)((void *)0);
#line 16151
  motioner = 0;
#line 16151
  val_y = motioner;
#line 16151
  val_x = val_y;
#line 16152
  hatmotioner = 0;
#line 16152
  valhat_y = hatmotioner;
#line 16152
  valhat_x = valhat_y;
#line 16153
  do_setcursor(cursor_watch);
#line 16157
  things_alloced = 32;
#line 16159
  __cil_tmp46 = malloc(sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 16159
  fs = (struct dirent2 *)__cil_tmp46;
#line 16161
  num_files_in_dir = 0;
#line 16162
  num_files = 0;
#line 16163
  cur = 0;
#line 16164
  which = 0;
#line 16169
  dirname___201 = get_fname("saved", 0);
#line 16174
  d = opendir((char const   *)dirname___201);
  }
#line 16176
  if (d != (void *)0) {
    {
#line 16180
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 16182
      f = readdir(d);
      }
#line 16184
      if (f != (void *)0) {
        {
#line 16186
        memcpy(& (fs + num_files_in_dir)->f, f, sizeof(struct dirent ));
#line 16187
        (fs + num_files_in_dir)->place = 0;
#line 16189
        num_files_in_dir ++;
        }
#line 16191
        if (num_files_in_dir >= things_alloced) {
          {
#line 16193
          things_alloced += 32;
#line 16194
          __cil_tmp51 = realloc(fs, sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 16194
          fs = (struct dirent2 *)__cil_tmp51;
          }
        }
      }
#line 16180
      if (! (f != (void *)0)) {
#line 16180
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 16200
    closedir(d);
    }
  }
  {
#line 16206
  __cil_tmp52 = malloc(sizeof(SDL_Surface *) * (unsigned long )num_files_in_dir);
#line 16206
  thumbs = (SDL_Surface **)__cil_tmp52;
#line 16207
  __cil_tmp53 = malloc(sizeof(char *) * (unsigned long )num_files_in_dir);
#line 16207
  d_names = (char **)__cil_tmp53;
#line 16208
  __cil_tmp54 = malloc(sizeof(char *) * (unsigned long )num_files_in_dir);
#line 16208
  d_exts = (char **)__cil_tmp54;
#line 16209
  __cil_tmp55 = malloc(sizeof(int ) * (unsigned long )num_files_in_dir);
#line 16209
  selected = (int *)__cil_tmp55;
#line 16214
  qsort(fs, (size_t )num_files_in_dir, sizeof(struct dirent2 ), (int (*)(void const   * ,
                                                                         void const   * ))(& compare_dirent2s));
#line 16219
  j = 0;
  }
  {
#line 16219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 16219
    if (! (j < num_files_in_dir)) {
#line 16219
      goto while_break___0;
    }
    {
#line 16221
    f = & (fs + j)->f;
#line 16223
    show_progress_bar(screen);
    }
#line 16225
    if (f != (void *)0) {
      {
#line 16227
      debug((char const   *)((char *)f->d_name));
#line 16229
      __cil_tmp57 = strcasestr((char const   *)((char *)f->d_name), "-back.");
      }
      {
#line 16229
      __cil_tmp56 = strcasestr((char const   *)((char *)f->d_name), "-t.");
      }
#line 16229
      if (__cil_tmp56 == (void *)0) {
#line 16229
        if (__cil_tmp57 == (void *)0) {
          {
#line 16231
          __cil_tmp59 = strcasestr((char const   *)((char *)f->d_name), ".bmp");
          }
          {
#line 16231
          __cil_tmp58 = strcasestr((char const   *)((char *)f->d_name), ".png");
          }
#line 16231
          if (__cil_tmp58 != (void *)0) {
            _L: /* CIL Label */ 
            {
#line 16235
            safe_strncpy((char *)fname, (char const   *)((char *)f->d_name), sizeof(fname));
#line 16236
            __cil_tmp60 = strcasestr((char const   *)((char *)fname), ".png");
            }
#line 16236
            if (__cil_tmp60 != (void *)0) {
              {
#line 16238
              __cil_tmp61 = strcasestr((char const   *)((char *)fname), ".png");
#line 16238
              __cil_tmp62 = strdup((char const   *)__cil_tmp61);
#line 16238
              *(d_exts + num_files) = __cil_tmp62;
#line 16239
              __cil_tmp63 = strcasestr((char const   *)((char *)fname), ".png");
#line 16239
              strcpy((char *)__cil_tmp63, "\220");
              }
            }
            {
#line 16242
            __cil_tmp64 = strcasestr((char const   *)((char *)fname), ".bmp");
            }
#line 16242
            if (__cil_tmp64 != (void *)0) {
              {
#line 16244
              __cil_tmp65 = strcasestr((char const   *)((char *)fname), ".bmp");
#line 16244
              __cil_tmp66 = strdup((char const   *)__cil_tmp65);
#line 16244
              *(d_exts + num_files) = __cil_tmp66;
#line 16245
              __cil_tmp67 = strcasestr((char const   *)((char *)fname), ".bmp");
#line 16245
              strcpy((char *)__cil_tmp67, "\220");
              }
            }
            {
#line 16248
            *(d_names + num_files) = strdup((char const   *)((char *)fname));
#line 16256
            safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png", dirname___201,
                          *(d_names + num_files));
#line 16257
            debug("Loading thumbnail...");
#line 16258
            debug((char const   *)((char *)fname));
#line 16259
            img = IMG_Load((char const   *)((char *)fname));
            }
#line 16260
            if (img == (void *)0) {
              {
#line 16265
              safe_snprintf((char *)fname, sizeof(fname), "%s/%s-t.png", dirname___201,
                            *(d_names + num_files));
#line 16266
              debug((char const   *)((char *)fname));
#line 16268
              img = IMG_Load((char const   *)((char *)fname));
              }
            }
#line 16272
            if (img != (void *)0) {
              {
#line 16276
              debug("Thumbnail loaded, scaling");
#line 16277
              show_progress_bar(screen);
#line 16279
              img1 = SDL_DisplayFormat(img);
#line 16280
              SDL_FreeSurface(img);
              }
#line 16282
              if (img1 != (void *)0) {
#line 16286
                if (img1->w > ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
                  {
                  {
                  {
#line 16289
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 16290
                  SDL_FreeSurface(img1);
                  }
                  }
#line 16291
                  img1 = img2;
                  }
                } else
#line 16286
                if (img1->h > (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                  {
                  {
                  {
#line 16289
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 16290
                  SDL_FreeSurface(img1);
                  }
                  }
#line 16291
                  img1 = img2;
                  }
                } else
#line 16286
                if (img1->w < ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
#line 16286
                  if (img1->h < (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                    {
                    {
                    {
#line 16289
                    img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                     (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                     0);
                    }
                    }
                    {
                    {
#line 16290
                    SDL_FreeSurface(img1);
                    }
                    }
#line 16291
                    img1 = img2;
                    }
                  }
                }
#line 16294
                *(thumbs + num_files) = img1;
#line 16296
                if (*(thumbs + num_files) == (void *)0) {
                  {
#line 16298
                  fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\nt\324U",
                          (char *)fname);
                  }
                } else {
#line 16301
                  num_files ++;
                }
              }
            } else {
              {
#line 16309
              __cil_tmp74 = make_directory(0, "saved", "Can\'t create user data directory (for saved drawings) (E008)\324U");
              }
#line 16309
              if (__cil_tmp74) {
                {
#line 16312
                make_directory(0, "saved/.thumbs", "Can\'t create user data thumbnail directory (for saved drawings\' thumbnails) (E009)");
                }
              }
              {
#line 16315
              safe_snprintf((char *)fname, sizeof(fname), "%s/%sU", dirname___201,
                            (char *)f->d_name);
#line 16317
              debug("Loading original, to make thumbnail");
#line 16318
              debug((char const   *)((char *)fname));
#line 16319
              img = myIMG_Load((char const   *)((char *)fname));
#line 16322
              show_progress_bar(screen);
              }
#line 16325
              if (img == (void *)0) {
                {
#line 16327
                __cil_tmp76 = SDL_GetError();
#line 16327
                fprintf(stderr, "\nWarning: I can\'t open one of the saved files!\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\324U",
                        (char *)fname, __cil_tmp76);
                }
              } else {
                {
#line 16337
                img1 = SDL_DisplayFormatAlpha(img);
#line 16338
                img2 = thumbnail2(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                  (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                  0, 0);
#line 16339
                SDL_FreeSurface(img1);
#line 16341
                show_progress_bar(screen);
#line 16343
                *(thumbs + num_files) = SDL_DisplayFormat(img2);
#line 16344
                SDL_FreeSurface(img2);
#line 16346
                SDL_FreeSurface(img);
                }
#line 16348
                if (*(thumbs + num_files) == (void *)0) {
                  {
#line 16350
                  fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\nt\324U",
                          (char *)fname);
                  }
                } else {
                  {
#line 16354
                  show_progress_bar(screen);
#line 16359
                  debug("Saving thumbnail for this one!");
#line 16361
                  safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png",
                                dirname___201, *(d_names + num_files));
#line 16363
                  fi = fopen((char const   *)((char *)fname), "wb");
                  }
#line 16364
                  if (fi == (void *)0) {
                    {
#line 16366
                    __cil_tmp81 = __errno_location();
#line 16366
                    __cil_tmp82 = strerror(*__cil_tmp81);
#line 16366
                    fprintf(stderr, "\nError: Couldn\'t save thumbnail of saved image!\n%s\nThe error that occurred was:\n%s\n\n\230\001",
                            (char *)fname, __cil_tmp82);
                    }
                  } else {
                    {
#line 16372
                    do_png_save(fi, (char const   *)((char *)fname), *(thumbs + num_files),
                                0);
                    }
                  }
                  {
#line 16375
                  show_progress_bar(screen);
#line 16377
                  num_files ++;
                  }
                }
              }
            }
          } else
#line 16231
          if (__cil_tmp59 != (void *)0) {
#line 16231
            goto _L;
          }
        }
      }
    }
#line 16219
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 16392
  __cil_tmp85 = dcgettext((char const   *)((void *)0), "Choose the pictures you want, then click \342\200\234Play\342\200\235.",
                          5);
#line 16392
  __cil_tmp86 = textdir((char const   *)__cil_tmp85);
#line 16392
  instructions = __cil_tmp86;
#line 16393
  draw_tux_text(2, (char const   *)instructions, 1);
#line 16398
  update_list = 1;
#line 16400
  go_back = 0;
#line 16401
  done = 0;
#line 16404
  num_selected = 0;
#line 16405
  speed = 5;
#line 16407
  do_setcursor(cursor_arrow);
  }
  {
#line 16410
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 16414
    if (update_list) {
      {
#line 16418
      dest.x = (Sint16 )r_ttools.w;
#line 16419
      dest.y = (Sint16 )0;
#line 16420
      dest.w = (Uint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w);
#line 16421
      dest.h = (Uint16 )(button_h * buttons_tall + (int )r_ttools.h);
#line 16423
      SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 16428
      i = cur;
      }
      {
#line 16428
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 16428
        if (! (i < cur + 16 && i < num_files)) {
#line 16428
          goto while_break___2;
        }
#line 16432
        dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w);
#line 16433
        dest.y = (Sint16 )(((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h);
#line 16435
        if (i == which) {
          {
#line 16437
          SDL_UpperBlit(img_cursor_down, (SDL_Rect *)((void *)0), screen, & dest);
#line 16438
          debug((char const   *)*(d_names + i));
          }
        } else {
          {
#line 16441
          SDL_UpperBlit(img_cursor_up, (SDL_Rect *)((void *)0), screen, & dest);
          }
        }
#line 16443
        if (*(thumbs + i) != (void *)0) {
          {
#line 16445
          dest.x = (Sint16 )((((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w) + 10) + ((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) - (*(thumbs + i))->w) / 2);
#line 16446
          dest.y = (Sint16 )(((((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h) + 10) + (((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) - (*(thumbs + i))->h) / 2);
#line 16448
          SDL_UpperBlit(*(thumbs + i), (SDL_Rect *)((void *)0), screen, & dest);
          }
        }
#line 16451
        found = - 1;
#line 16453
        j = 0;
        {
#line 16453
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 16453
          if (! (j < num_selected && found == -1)) {
#line 16453
            goto while_break___3;
          }
#line 16455
          if (*(selected + j) == i) {
#line 16456
            found = j;
          }
#line 16453
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 16459
        if (found != -1) {
          {
#line 16461
          dest.x = (Sint16 )(((((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.h) + 10) + ((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) - (*(thumbs + i))->w) / 2) + (*(thumbs + i))->w);
#line 16462
          dest.y = (Sint16 )((((((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h) + 10) + (((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) - (*(thumbs + i))->h) / 2) + (*(thumbs + i))->h);
#line 16464
          draw_selection_digits((int )dest.x, (int )dest.y, found + 1);
          }
        }
#line 16428
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 16471
      dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 16472
      dest.y = (Sint16 )0;
#line 16474
      if (cur > 0) {
        {
#line 16475
        SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 16477
        SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
#line 16479
      dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 16480
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16482
      if (cur < num_files - 16) {
        {
#line 16483
        SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 16485
        SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
      {
#line 16490
      dest.x = (Sint16 )r_ttools.w;
#line 16491
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16492
      SDL_UpperBlit(img_play, (SDL_Rect *)((void *)0), screen, & dest);
#line 16494
      dest.x = (Sint16 )((int )r_ttools.w + (button_w - img_openlabels_play->w) / 2);
#line 16495
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_play->h);
#line 16496
      SDL_UpperBlit(img_openlabels_play, (SDL_Rect *)((void *)0), screen, & dest);
#line 16501
      dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w * 2);
#line 16502
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16503
      SDL_UpperBlit(img_btn_up, (SDL_Rect *)((void *)0), screen, & dest);
#line 16505
      dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w * 2) + (button_w - img_gif_export->w) / 2);
#line 16506
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16507
      SDL_UpperBlit(img_gif_export, (SDL_Rect *)((void *)0), screen, & dest);
#line 16509
      dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w * 2) + (button_w - img_openlabels_gif_export->w) / 2);
#line 16510
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_gif_export->h);
#line 16511
      SDL_UpperBlit(img_openlabels_gif_export, (SDL_Rect *)((void *)0), screen, & dest);
#line 16516
      dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w);
#line 16517
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16518
      SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 16520
      dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) + (button_w - img_openlabels_back->w) / 2);
#line 16521
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_back->h);
#line 16522
      SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 16527
      speeds = 10;
#line 16528
      x_per = (float )r_ttools.w / (float )speeds;
#line 16529
      y_per = (float )button_h / (float )speeds;
#line 16531
      i = 0;
      }
      {
#line 16531
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 16531
        if (! (i < speeds)) {
#line 16531
          goto while_break___4;
        }
        {
#line 16533
        __cil_tmp89 = ceil((double )x_per);
#line 16533
        xx = (int )__cil_tmp89;
#line 16534
        __cil_tmp90 = ceil((double )(y_per * (float )i));
#line 16534
        yy = (int )__cil_tmp90;
        }
#line 16536
        if (i <= speed) {
          {
#line 16537
          btn = thumbnail(img_btn_down, xx, yy, 0);
          }
        } else {
          {
#line 16539
          btn = thumbnail(img_btn_up, xx, yy, 0);
          }
        }
        {
#line 16541
        blnk = thumbnail(img_btn_off, xx, button_h - yy, 0);
#line 16545
        dest.x = (Sint16 )((float )((int )r_ttools.w + button_w) + (float )i * x_per);
#line 16546
        dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16547
        SDL_UpperBlit(blnk, (SDL_Rect *)((void *)0), screen, & dest);
#line 16549
        dest.x = (Sint16 )((float )((int )r_ttools.w + button_w) + (float )i * x_per);
#line 16550
        dest.y = (Sint16 )((float )(button_h * buttons_tall + (int )r_ttools.h) - y_per * (float )i);
#line 16551
        SDL_UpperBlit(btn, (SDL_Rect *)((void *)0), screen, & dest);
#line 16553
        SDL_FreeSurface(btn);
#line 16554
        SDL_FreeSurface(blnk);
        }
#line 16531
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 16557
      SDL_Flip(screen);
#line 16559
      update_list = 0;
      }
    }
    {
#line 16564
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 16564
      __cil_tmp95 = SDL_PollEvent(& event);
      }
#line 16564
      if (! __cil_tmp95) {
#line 16564
        goto while_break___5;
      }
#line 16566
      if ((int )event.type == 12) {
#line 16568
        done = 1;
      } else
#line 16572
      if ((int )event.type == 1) {
        {
#line 16574
        handle_active(& event);
        }
      } else
#line 16576
      if ((int )event.type == 3) {
        {
#line 16578
        key = event.key.keysym.sym;
#line 16580
        handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 16582
      if ((int )event.type == 2) {
        {
#line 16584
        key = event.key.keysym.sym;
#line 16587
        dest.x = (Sint16 )(button_w * 3);
#line 16588
        dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 16589
        dest.w = (Uint16 )(button_w * 2);
#line 16590
        dest.h = (Uint16 )button_h;
#line 16592
        handle_keymouse(key, (Uint8 )2, 24, & dest, (SDL_Rect *)((void *)0));
        }
#line 16594
        if ((unsigned int )key == 13U) {
          {
#line 16600
          event.type = (Uint8 )5;
#line 16601
          event.button.x = (Uint16 )(button_w * 2 + 5);
#line 16602
          event.button.y = (Uint16 )(((button_h * buttons_tall + (int )r_ttools.h) - button_h) + 5);
#line 16603
          event.button.button = (Uint8 )1;
#line 16604
          SDL_PushEvent(& event);
          }
        } else
#line 16608
        if ((unsigned int )key == 27U) {
          {
#line 16612
          go_back = 1;
#line 16613
          done = 1;
#line 16614
          playsound(screen, 1, 1, 1, - 999, - 999);
          }
        }
      } else {
        {
#line 16617
        __cil_tmp96 = valid_click(event.button.button);
        }
#line 16617
        if ((int )event.type == 5) {
#line 16617
          if (__cil_tmp96) {
#line 16619
            if ((int )event.button.x >= (int )r_ttools.w) {
#line 16619
              if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 16619
                if ((int )event.button.y >= img_scroll_up->h) {
#line 16619
                  if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16624
                    which = (((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur;
#line 16626
                    if (which < num_files) {
                      {
#line 16628
                      playsound(screen, 1, 2, 1, (int )event.button.x, - 999);
#line 16632
                      found = - 1;
#line 16633
                      i = 0;
                      }
                      {
#line 16633
                      while (1) {
                        while_continue___6: /* CIL Label */ ;
#line 16633
                        if (! (i < num_selected && found == -1)) {
#line 16633
                          goto while_break___6;
                        }
#line 16635
                        if (*(selected + i) == which) {
#line 16636
                          found = i;
                        }
#line 16633
                        i ++;
                      }
                      while_break___6: /* CIL Label */ ;
                      }
#line 16639
                      if (found == -1) {
#line 16643
                        __cil_tmp98 = num_selected;
#line 16643
                        num_selected ++;
#line 16643
                        *(selected + __cil_tmp98) = which;
                      } else {
#line 16649
                        i = found;
                        {
#line 16649
                        while (1) {
                          while_continue___7: /* CIL Label */ ;
#line 16649
                          if (! (i < num_selected - 1)) {
#line 16649
                            goto while_break___7;
                          }
#line 16650
                          *(selected + i) = *(selected + (i + 1));
#line 16649
                          i ++;
                        }
                        while_break___7: /* CIL Label */ ;
                        }
#line 16652
                        __cil_tmp100 = num_selected;
#line 16652
                        num_selected --;
                      }
#line 16655
                      update_list = 1;
                    }
                  } else {
#line 16619
                    goto _L___212;
                  }
                } else {
#line 16619
                  goto _L___212;
                }
              } else {
#line 16619
                goto _L___212;
              }
            } else
            _L___212: /* CIL Label */ 
            _L___213: /* CIL Label */ 
            _L___214: /* CIL Label */ 
#line 16658
            if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 16658
              if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 16661
                if ((int )event.button.y < img_scroll_up->h) {
#line 16665
                  if (cur > 0) {
                    {
#line 16667
                    cur -= 4;
#line 16668
                    update_list = 1;
#line 16669
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 16671
                    if (cur == 0) {
                      {
#line 16672
                      do_setcursor(cursor_arrow);
                      }
                    }
                  }
#line 16675
                  if (which >= cur + 16) {
#line 16676
                    which -= 4;
                  }
                } else
#line 16678
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16678
                  if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_down->h) {
#line 16683
                    if (cur < num_files - 16) {
                      {
#line 16685
                      cur += 4;
#line 16686
                      update_list = 1;
#line 16687
                      playsound(screen, 1, 7, 1, - 998, - 999);
                      }
#line 16689
                      if (cur >= num_files - 16) {
                        {
#line 16690
                        do_setcursor(cursor_arrow);
                        }
                      }
                    }
#line 16693
                    if (which < cur) {
#line 16694
                      which += 4;
                    }
                  }
                }
              } else {
#line 16658
                goto _L___211;
              }
            } else
            _L___211: /* CIL Label */ 
#line 16697
            if ((int )event.button.x >= (int )r_ttools.w) {
#line 16697
              if ((int )event.button.x < (int )r_ttools.w + button_w) {
#line 16697
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16697
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                    {
#line 16703
                    playsound(screen, 1, 1, 1, - 997, - 999);
                    }
#line 16708
                    if (num_selected == 0) {
#line 16710
                      i = 0;
                      {
#line 16710
                      while (1) {
                        while_continue___8: /* CIL Label */ ;
#line 16710
                        if (! (i < num_files)) {
#line 16710
                          goto while_break___8;
                        }
#line 16711
                        *(selected + i) = i;
#line 16710
                        i ++;
                      }
                      while_break___8: /* CIL Label */ ;
                      }
#line 16712
                      num_selected = num_files;
                    }
                    {
#line 16715
                    play_slideshow(selected, num_selected, dirname___201, d_names,
                                   d_exts, speed);
#line 16720
                    SDL_FillRect(screen, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 16721
                    draw_toolbar();
#line 16722
                    draw_colors((unsigned int )8);
#line 16723
                    draw_none();
#line 16726
                    __cil_tmp102 = dcgettext((char const   *)((void *)0), "Choose the pictures you want, then click \342\200\234Play\342\200\235.\324U",
                                             5);
#line 16726
                    __cil_tmp103 = textdir((char const   *)__cil_tmp102);
#line 16726
                    freeme = __cil_tmp103;
#line 16727
                    draw_tux_text(2, (char const   *)freeme, 1);
#line 16728
                    free(freeme);
#line 16730
                    SDL_Flip(screen);
#line 16732
                    update_list = 1;
                    }
                  } else {
#line 16697
                    goto _L___208;
                  }
                } else {
#line 16697
                  goto _L___208;
                }
              } else {
#line 16697
                goto _L___208;
              }
            } else
            _L___208: /* CIL Label */ 
            _L___209: /* CIL Label */ 
            _L___210: /* CIL Label */ 
#line 16734
            if ((int )event.button.x >= (int )r_ttools.w + button_w) {
#line 16734
              if ((int )event.button.x < ((int )r_ttools.w + button_w) + (int )r_ttools.w) {
#line 16734
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16734
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
#line 16742
                    old_speed = speed;
#line 16744
                    click_x = ((int )event.button.x - (int )r_ttools.w) - button_w;
#line 16745
                    speed = (10 * click_x) / (int )r_ttools.w;
#line 16747
                    control_sound = - 1;
#line 16749
                    if (speed < old_speed) {
#line 16750
                      control_sound = 21;
                    } else
#line 16751
                    if (speed > old_speed) {
#line 16752
                      control_sound = 22;
                    }
#line 16754
                    if (control_sound != -1) {
                      {
#line 16756
                      playsound(screen, 0, control_sound, 0, - 998, - 999);
#line 16758
                      update_list = 1;
                      }
                    }
                  } else {
#line 16734
                    goto _L___205;
                  }
                } else {
#line 16734
                  goto _L___205;
                }
              } else {
#line 16734
                goto _L___205;
              }
            } else
            _L___205: /* CIL Label */ 
            _L___206: /* CIL Label */ 
            _L___207: /* CIL Label */ 
#line 16761
            if ((int )event.button.x >= ((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) - button_w) {
#line 16761
              if ((int )event.button.x < (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 16761
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16761
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                    {
#line 16768
                    playsound(screen, 1, 1, 1, - 999, - 999);
                    }
#line 16770
                    if (num_selected < 2) {
                      {
#line 16775
                      freeme = textdir("Select 2 or more drawings to turn into an animated GIF.");
#line 16776
                      draw_tux_text(2, (char const   *)freeme, 1);
#line 16777
                      free(freeme);
#line 16779
                      control_drawtext_timer((Uint32 )2000, (char const   *)instructions,
                                             (Uint8 )0);
                      }
                    } else {
                      {
#line 16783
                      export_successful = export_gif(selected, num_selected, dirname___201,
                                                     d_names, d_exts, speed);
#line 16786
                      SDL_FillRect(screen, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 16787
                      draw_toolbar();
#line 16788
                      draw_colors((unsigned int )8);
#line 16789
                      draw_none();
                      }
#line 16792
                      if (export_successful) {
                        {
#line 16793
                        do_prompt_snd("Your slideshow GIF has been exported!", "OK",
                                      "\230", 27, screen->w / 2, screen->h / 2);
                        }
                      } else {
                        {
#line 16795
                        do_prompt_snd("Sorry! Your slideshow GIF could not be exported!\323\001 ",
                                      "OK\241t\324U", "\230", 26, screen->w / 2, screen->h / 2);
                        }
                      }
                      {
#line 16797
                      __cil_tmp109 = dcgettext((char const   *)((void *)0), "Choose the pictures you want, then click \342\200\234Play\342\200\235.\324U",
                                               5);
#line 16797
                      __cil_tmp110 = textdir((char const   *)__cil_tmp109);
#line 16797
                      freeme = __cil_tmp110;
#line 16798
                      draw_tux_text(2, (char const   *)freeme, 1);
#line 16799
                      free(freeme);
#line 16801
                      SDL_Flip(screen);
#line 16803
                      update_list = 1;
                      }
                    }
                  } else {
#line 16761
                    goto _L___202;
                  }
                } else {
#line 16761
                  goto _L___202;
                }
              } else {
#line 16761
                goto _L___202;
              }
            } else
            _L___202: /* CIL Label */ 
            _L___203: /* CIL Label */ 
            _L___204: /* CIL Label */ 
#line 16806
            if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 16806
              if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 16806
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16806
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                    {
#line 16813
                    go_back = 1;
#line 16814
                    done = 1;
#line 16815
                    playsound(screen, 1, 1, 1, - 999, - 999);
                    }
                  }
                }
              }
            }
          } else {
#line 16617
            goto _L___231;
          }
        } else
        _L___231: /* CIL Label */ 
#line 16818
        if ((int )event.type == 5) {
#line 16818
          if ((int )event.button.button >= 4) {
#line 16818
            if ((int )event.button.button <= 5) {
#line 16818
              if (wheely) {
#line 16822
                if ((int )event.button.button == 4) {
#line 16822
                  if (cur > 0) {
                    {
#line 16824
                    cur -= 4;
#line 16825
                    update_list = 1;
#line 16826
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 16828
                    if (cur == 0) {
                      {
#line 16829
                      do_setcursor(cursor_arrow);
                      }
                    }
#line 16831
                    if (which >= cur + 16) {
#line 16832
                      which -= 4;
                    }
                  } else {
#line 16822
                    goto _L___215;
                  }
                } else
                _L___215: /* CIL Label */ 
#line 16834
                if ((int )event.button.button == 5) {
#line 16834
                  if (cur < num_files - 16) {
                    {
#line 16836
                    cur += 4;
#line 16837
                    update_list = 1;
#line 16838
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 16840
                    if (cur >= num_files - 16) {
                      {
#line 16841
                      do_setcursor(cursor_arrow);
                      }
                    }
#line 16843
                    if (which < cur) {
#line 16844
                      which += 4;
                    }
                  }
                }
              } else {
#line 16818
                goto _L___228;
              }
            } else {
#line 16818
              goto _L___228;
            }
          } else {
#line 16818
            goto _L___228;
          }
        } else
        _L___228: /* CIL Label */ 
        _L___229: /* CIL Label */ 
        _L___230: /* CIL Label */ 
#line 16847
        if ((int )event.type == 4) {
#line 16851
          if ((int )event.button.y < img_scroll_up->h) {
#line 16851
            if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 16851
              if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 16851
                if (cur > 0) {
                  {
#line 16857
                  do_setcursor(cursor_up);
                  }
                } else {
#line 16851
                  goto _L___225;
                }
              } else {
#line 16851
                goto _L___225;
              }
            } else {
#line 16851
              goto _L___225;
            }
          } else
          _L___225: /* CIL Label */ 
          _L___226: /* CIL Label */ 
          _L___227: /* CIL Label */ 
#line 16859
          if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16859
            if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_up->h) {
#line 16859
              if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 16859
                if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 16859
                  if (cur < num_files - 16) {
                    {
#line 16866
                    do_setcursor(cursor_down);
                    }
                  } else {
#line 16859
                    goto _L___221;
                  }
                } else {
#line 16859
                  goto _L___221;
                }
              } else {
#line 16859
                goto _L___221;
              }
            } else {
#line 16859
              goto _L___221;
            }
          } else
          _L___221: /* CIL Label */ 
          _L___222: /* CIL Label */ 
          _L___223: /* CIL Label */ 
          _L___224: /* CIL Label */ 
#line 16868
          if ((int )event.button.x >= (int )r_ttools.w) {
#line 16868
            if ((int )event.button.x < ((int )r_ttools.w + button_w) + (int )r_ttools.w) {
              _L___218: /* CIL Label */ 
#line 16868
              if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16868
                if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                  {
#line 16876
                  do_setcursor(cursor_hand);
                  }
                } else {
#line 16868
                  goto _L___216;
                }
              } else {
#line 16868
                goto _L___216;
              }
            } else {
#line 16868
              goto _L___220;
            }
          } else
          _L___220: /* CIL Label */ 
#line 16868
          if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w * 2) {
#line 16868
            if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 16868
              goto _L___218;
            } else {
#line 16868
              goto _L___216;
            }
          } else
          _L___216: /* CIL Label */ 
          _L___217: /* CIL Label */ 
          _L___219: /* CIL Label */ 
#line 16878
          if ((int )event.button.x >= (int )r_ttools.w) {
#line 16878
            if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 16878
              if ((int )event.button.y > img_scroll_up->h) {
#line 16878
                if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 16878
                  if ((((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur < num_files) {
                    {
#line 16887
                    do_setcursor(cursor_hand);
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 16893
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 16893
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 16893
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
                }
              }
            } else {
              {
              {
              {
              {
              {
#line 16893
              do_setcursor(cursor_arrow);
              }
              }
              }
              }
              }
            }
          } else {
            {
            {
            {
            {
            {
#line 16893
            do_setcursor(cursor_arrow);
            }
            }
            }
            }
            }
          }
#line 16895
          oldpos_x = (int )event.button.x;
#line 16896
          oldpos_y = (int )event.button.y;
        } else
#line 16898
        if ((int )event.type == 7) {
          {
#line 16899
          handle_joyaxismotion(event, & motioner, & val_x, & val_y);
          }
        } else
#line 16901
        if ((int )event.type == 9) {
          {
#line 16902
          handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                              & old_hat_ticks);
          }
        } else
#line 16904
        if ((int )event.type == 8) {
          {
#line 16905
          handle_joyballmotion(event, oldpos_x, oldpos_y);
          }
        } else
#line 16907
        if ((int )event.type == 10) {
          {
          {
#line 16908
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        } else
#line 16907
        if ((int )event.type == 11) {
          {
          {
#line 16908
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        } else
#line 16910
        if ((int )event.type == 24) {
#line 16912
          if (event.user.code == 1) {
#line 16914
            if (event.user.data1 != (void *)0) {
              {
#line 16916
              draw_tux_text(2, (char const   *)instructions, 1);
              }
            }
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 16922
    if (motioner | hatmotioner) {
      {
#line 16923
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 16925
    SDL_Delay((Uint32 )10);
    }
#line 16410
    if (! (! done)) {
#line 16410
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 16932
  free_surface_array(thumbs, num_files);
#line 16934
  free(thumbs);
#line 16936
  i = 0;
  }
  {
#line 16936
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 16936
    if (! (i < num_files)) {
#line 16936
      goto while_break___9;
    }
    {
#line 16938
    free(*(d_names + i));
#line 16939
    free(*(d_exts + i));
    }
#line 16936
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 16942
  free(dirname___201);
#line 16944
  free(d_names);
#line 16945
  free(d_exts);
#line 16946
  free(selected);
#line 16948
  control_drawtext_timer((Uint32 )0, "\251", (Uint8 )0);
#line 16949
  free(instructions);
  }
#line 16951
  return (go_back);
}
}
#line 16967 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void play_slideshow(int *selected , int num_selected , char *dirname___0 ,
                           char **d_names , char **d_exts , int speed ) 
{ 
  int i ;
  int which ;
  int next ;
  int done ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  SDL_Surface *img ;
  char *tmp_starter_id ;
  char *tmp_template_id ;
  char *tmp_file_id ;
  int tmp_starter_mirrored ;
  int tmp_starter_flipped ;
  int tmp_starter_personal ;
  char fname[1024] ;
  SDL_Event event ;
  SDLKey key ;
  SDL_Rect dest ;
  Uint32 last_ticks ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  SDL_Surface *__cil_tmp32 ;
  Uint32 __cil_tmp33 ;
  int __cil_tmp34 ;
  Uint32 __cil_tmp35 ;
  int __cil_tmp36 ;

  {
  {
#line 16983
  motioner = 0;
#line 16983
  val_y = motioner;
#line 16983
  val_x = val_y;
#line 16984
  hatmotioner = 0;
#line 16984
  valhat_y = hatmotioner;
#line 16984
  valhat_x = valhat_y;
#line 16988
  tmp_starter_id = strdup((char const   *)((char *)starter_id));
#line 16989
  tmp_template_id = strdup((char const   *)((char *)template_id));
#line 16990
  tmp_file_id = strdup((char const   *)((char *)file_id));
#line 16991
  tmp_starter_mirrored = starter_mirrored;
#line 16992
  tmp_starter_flipped = starter_flipped;
#line 16993
  tmp_starter_personal = starter_personal;
#line 16996
  do_setcursor(cursor_tiny);
#line 16998
  done = 0;
  }
  {
#line 17000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17002
    i = 0;
    {
#line 17002
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17002
      if (! (i < num_selected && ! done)) {
#line 17002
        goto while_break___0;
      }
      {
#line 17004
      which = *(selected + i);
#line 17005
      show_progress_bar(screen);
#line 17010
      safe_snprintf((char *)fname, sizeof(fname), "%s/%s%s", dirname___0, *(d_names + which),
                    *(d_exts + which));
#line 17013
      img = myIMG_Load((char const   *)((char *)fname));
      }
#line 17015
      if (img != (void *)0) {
        {
#line 17017
        autoscale_copy_smear_free(img, screen, & SDL_UpperBlit);
#line 17019
        safe_strncpy((char *)file_id, (char const   *)*(d_names + which), sizeof(file_id));
#line 17026
        load_starter_id(*(d_names + which), (FILE *)((void *)0));
        }
#line 17028
        if ((int )starter_id[0] != 0) {
          {
#line 17030
          load_starter((char *)starter_id);
          }
#line 17032
          if (starter_mirrored) {
            {
#line 17033
            mirror_starter();
            }
          }
#line 17035
          if (starter_flipped) {
            {
#line 17036
            flip_starter();
            }
          }
        } else {
          {
#line 17039
          load_template((char *)template_id);
          }
        }
      }
      {
#line 17044
      dest.x = (Sint16 )(screen->w - button_w);
#line 17045
      dest.y = (Sint16 )(screen->h - button_h);
#line 17046
      SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 17048
      dest.x = (Sint16 )((screen->w - button_w) + (button_w - img_openlabels_back->w) / 2);
#line 17049
      dest.y = (Sint16 )(screen->h - img_openlabels_back->h);
#line 17050
      SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 17054
      dest.x = (Sint16 )0;
#line 17055
      dest.y = (Sint16 )(screen->h - button_h);
#line 17056
      SDL_UpperBlit(img_play, (SDL_Rect *)((void *)0), screen, & dest);
#line 17058
      dest.x = (Sint16 )((button_w - img_openlabels_next->w) / 2);
#line 17059
      dest.y = (Sint16 )(screen->h - img_openlabels_next->h);
#line 17060
      SDL_UpperBlit(img_openlabels_next, (SDL_Rect *)((void *)0), screen, & dest);
#line 17063
      SDL_Flip(screen);
#line 17068
      next = 0;
#line 17069
      last_ticks = SDL_GetTicks();
      }
      {
#line 17071
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 17073
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 17073
          __cil_tmp34 = SDL_PollEvent(& event);
          }
#line 17073
          if (! __cil_tmp34) {
#line 17073
            goto while_break___2;
          }
#line 17075
          if ((int )event.type == 12) {
#line 17079
            next = 1;
#line 17080
            done = 1;
          } else
#line 17082
          if ((int )event.type == 1) {
            {
#line 17084
            handle_active(& event);
            }
          } else
#line 17086
          if ((int )event.type == 2) {
            {
#line 17088
            key = event.key.keysym.sym;
#line 17090
            handle_keymouse(key, (Uint8 )2, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
            }
#line 17092
            if ((unsigned int )key == 13U) {
              {
#line 17096
              next = 1;
              {
              {
#line 17097
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
              }
              }
            } else
#line 17092
            if ((unsigned int )key == 32U) {
              {
#line 17096
              next = 1;
              {
              {
#line 17097
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
              }
              }
            } else
#line 17092
            if ((unsigned int )key == 281U) {
              {
#line 17096
              next = 1;
              {
              {
#line 17097
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
              }
              }
            } else
#line 17099
            if ((unsigned int )key == 280U) {
#line 17103
              i -= 2;
#line 17105
              if (i < -1) {
#line 17106
                i = num_selected - 2;
              }
              {
#line 17108
              next = 1;
#line 17109
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
            } else
#line 17111
            if ((unsigned int )key == 27U) {
              {
#line 17115
              next = 1;
#line 17116
              done = 1;
#line 17117
              playsound(screen, 1, 1, 1, - 999, - 999);
              }
            }
          } else
#line 17120
          if ((int )event.type == 5) {
#line 17124
            if ((int )event.button.x >= screen->w - button_w) {
#line 17124
              if ((int )event.button.y >= screen->h - button_h) {
                {
#line 17128
                next = 1;
#line 17129
                done = 1;
#line 17130
                playsound(screen, 1, 1, 1, - 999, - 999);
                }
              } else {
                {
#line 17136
                next = 1;
                {
#line 17137
                playsound(screen, 1, 1, 1, - 997, - 999);
                }
                }
              }
            } else {
              {
#line 17136
              next = 1;
              {
#line 17137
              playsound(screen, 1, 1, 1, - 997, - 999);
              }
              }
            }
          } else
#line 17140
          if ((int )event.type == 4) {
#line 17144
            if ((int )event.button.x >= screen->w - button_w) {
              _L: /* CIL Label */ 
#line 17144
              if ((int )event.button.y >= screen->h - button_h) {
                {
#line 17148
                do_setcursor(cursor_hand);
                }
              } else {
                {
                {
#line 17154
                do_setcursor(cursor_tiny);
                }
                }
              }
            } else
#line 17144
            if ((int )event.button.x < button_w) {
#line 17144
              goto _L;
            } else {
              {
              {
#line 17154
              do_setcursor(cursor_tiny);
              }
              }
            }
#line 17156
            oldpos_x = (int )event.button.x;
#line 17157
            oldpos_y = (int )event.button.y;
          } else
#line 17160
          if ((int )event.type == 7) {
            {
#line 17161
            handle_joyaxismotion(event, & motioner, & val_x, & val_y);
            }
          } else
#line 17163
          if ((int )event.type == 9) {
            {
#line 17164
            handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y,
                                & hatmotioner, & old_hat_ticks);
            }
          } else
#line 17166
          if ((int )event.type == 8) {
            {
#line 17167
            handle_joyballmotion(event, oldpos_x, oldpos_y);
            }
          } else
#line 17169
          if ((int )event.type == 10) {
            {
            {
#line 17170
            handle_joybuttonupdown(event, oldpos_x, oldpos_y);
            }
            }
          } else
#line 17169
          if ((int )event.type == 11) {
            {
            {
#line 17170
            handle_joybuttonupdown(event, oldpos_x, oldpos_y);
            }
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 17174
        if (motioner | hatmotioner) {
          {
#line 17175
          handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                           val_x, val_y, valhat_x, valhat_y);
          }
        }
        {
#line 17178
        SDL_Delay((Uint32 )10);
        }
#line 17183
        if (speed != 0) {
          {
#line 17185
          __cil_tmp35 = SDL_GetTicks();
          }
#line 17185
          if (__cil_tmp35 >= last_ticks + (unsigned int )((10 - speed) * 500)) {
#line 17186
            next = 1;
          }
        }
#line 17071
        if (! (! next)) {
#line 17071
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 17002
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 17000
    if (! (! done)) {
#line 17000
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17196
  strcpy((char *)starter_id, (char const   *)tmp_starter_id);
#line 17197
  free(tmp_starter_id);
#line 17199
  strcpy((char *)template_id, (char const   *)tmp_template_id);
#line 17200
  free(tmp_template_id);
#line 17202
  strcpy((char *)file_id, (char const   *)tmp_file_id);
#line 17203
  free(tmp_file_id);
#line 17205
  starter_mirrored = tmp_starter_mirrored;
#line 17206
  starter_flipped = tmp_starter_flipped;
#line 17207
  starter_personal = tmp_starter_personal;
  }
  return;
}
}
#line 17216 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_selection_digits(int right , int bottom , int n ) 
{ 
  SDL_Rect src ;
  SDL_Rect dest ;
  int i ;
  int v ;
  int len ;
  int place ;
  int digit_w ;
  int digit_h ;
  int x ;
  int y ;
  int __cil_tmp14 ;

  {
#line 17222
  digit_w = img_select_digits->w / 10;
#line 17223
  digit_h = img_select_digits->h;
#line 17225
  if (n > 99) {
#line 17227
    len = 3;
#line 17228
    place = 100;
  } else
#line 17230
  if (n > 9) {
#line 17232
    len = 2;
#line 17233
    place = 10;
  } else {
#line 17237
    len = 1;
#line 17238
    place = 1;
  }
#line 17241
  x = right - digit_w * len;
#line 17242
  y = bottom - digit_h;
#line 17244
  i = 0;
  {
#line 17244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17244
    if (! (i < len)) {
#line 17244
      goto while_break;
    }
    {
#line 17246
    v = (n / place) % (place * 10);
#line 17248
    src.x = (Sint16 )(digit_w * v);
#line 17249
    src.y = (Sint16 )0;
#line 17250
    src.w = (Uint16 )digit_w;
#line 17251
    src.h = (Uint16 )digit_h;
#line 17253
    dest.x = (Sint16 )x;
#line 17254
    dest.y = (Sint16 )y;
#line 17256
    SDL_UpperBlit(img_select_digits, & src, screen, & dest);
#line 17258
    x += digit_w;
#line 17259
    place /= 10;
    }
#line 17244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 17268 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void wait_for_sfx(void) 
{ 
  int __cil_tmp1 ;

  {
#line 17271
  if (use_sound) {
    {
#line 17273
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 17273
      __cil_tmp1 = Mix_Playing(- 1);
      }
#line 17273
      if (! __cil_tmp1) {
#line 17273
        goto while_break;
      }
      {
#line 17274
      SDL_Delay((Uint32 )10);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 17288 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char stiple[26]  =    "8421010842421080842121084\333\240t\324U";
#line 17309
static unsigned char *stamp_outline_data ;
#line 17310
static int stamp_outline_w ;
#line 17310
static int stamp_outline_h ;
#line 17315 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_stamp_xor(void) 
{ 
  int xx ;
  int yy ;
  int rx ;
  int ry ;
  Uint8 dummy ;
  SDL_Surface *src ;
  Uint32 (*getpixel)(SDL_Surface * , int  , int  ) ;
  unsigned char *alphabits ;
  int new_w ;
  int new_h ;
  unsigned char *outline ;
  unsigned char *old_outline_data ;
  SDL_Surface *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  unsigned char above ;
  unsigned char below ;
  unsigned char tmp ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;

  {
  {
#line 17328
  src = active_stamp;
#line 17331
  src = thumbnail(src, (int )((((unsigned int )active_stamp->w * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom),
                  (int )((((unsigned int )active_stamp->h * scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].numer + scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom) - 1U) / scaletable[(*(stamp_data[stamp_group] + cur_stamp[stamp_group]))->size].denom),
                  0);
#line 17333
  getpixel = getpixels[(src->format)->BytesPerPixel];
#line 17334
  alphabits = (unsigned char *)calloc((unsigned long )(src->w + 4), (unsigned long )(src->h + 4));
#line 17336
  SDL_LockSurface(src);
#line 17337
  yy = 0;
  }
  {
#line 17337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17337
    if (! (yy < src->h)) {
#line 17337
      goto while_break;
    }
#line 17339
    ry = yy;
#line 17340
    xx = 0;
    {
#line 17340
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17340
      if (! (xx < src->w)) {
#line 17340
        goto while_break___0;
      }
#line 17342
      rx = xx;
#line 17340
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 17337
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17347
  SDL_UnlockSurface(src);
#line 17349
  new_w = src->w + 4;
#line 17350
  new_h = src->h + 4;
#line 17351
  SDL_FreeSurface(src);
#line 17352
  outline = (unsigned char *)calloc((unsigned long )new_w, (unsigned long )new_h);
#line 17354
  yy = 1;
  }
  {
#line 17354
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 17354
    if (! (yy < new_h - 1)) {
#line 17354
      goto while_break___1;
    }
#line 17356
    xx = 1;
    {
#line 17356
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 17356
      if (! (xx < new_w - 1)) {
#line 17356
        goto while_break___2;
      }
#line 17358
      above = (unsigned char )0;
#line 17359
      below = (unsigned char )255;
#line 17362
      tmp = *(alphabits + ((xx - 1) + (yy - 1) * new_w));
#line 17363
      above |= (int )tmp;
#line 17364
      below &= (int )tmp;
#line 17365
      tmp = *(alphabits + ((xx + 1) + (yy - 1) * new_w));
#line 17366
      above |= (int )tmp;
#line 17367
      below &= (int )tmp;
#line 17369
      tmp = *(alphabits + (xx + (yy - 1) * new_w));
#line 17370
      above |= (int )tmp;
#line 17371
      below &= (int )tmp;
#line 17372
      tmp = *(alphabits + (xx + yy * new_w));
#line 17373
      above |= (int )tmp;
#line 17374
      below &= (int )tmp;
#line 17375
      tmp = *(alphabits + ((xx + 1) + yy * new_w));
#line 17376
      above |= (int )tmp;
#line 17377
      below &= (int )tmp;
#line 17378
      tmp = *(alphabits + ((xx - 1) + yy * new_w));
#line 17379
      above |= (int )tmp;
#line 17380
      below &= (int )tmp;
#line 17381
      tmp = *(alphabits + (xx + (yy + 1) * new_w));
#line 17382
      above |= (int )tmp;
#line 17383
      below &= (int )tmp;
#line 17385
      tmp = *(alphabits + ((xx - 1) + (yy + 1) * new_w));
#line 17386
      above |= (int )tmp;
#line 17387
      below &= (int )tmp;
#line 17388
      tmp = *(alphabits + ((xx + 1) + (yy + 1) * new_w));
#line 17389
      above |= (int )tmp;
#line 17390
      below &= (int )tmp;
#line 17392
      *(outline + (xx + yy * new_w)) = (unsigned char )(((int )above ^ (int )below) >> 7);
#line 17356
      xx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 17354
    yy ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 17396
  old_outline_data = stamp_outline_data;
#line 17397
  stamp_outline_data = outline;
#line 17398
  stamp_outline_w = new_w;
#line 17399
  stamp_outline_h = new_h;
#line 17400
  if (old_outline_data) {
    {
#line 17401
    free(old_outline_data);
    }
  }
  {
#line 17402
  free(alphabits);
  }
  return;
}
}
#line 17408 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void stamp_xor(int x , int y ) 
{ 
  int xx ;
  int yy ;
  int sx ;
  int sy ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 17412
  SDL_LockSurface(screen);
#line 17413
  yy = 0;
  }
  {
#line 17413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17413
    if (! (yy < stamp_outline_h)) {
#line 17413
      goto while_break;
    }
#line 17415
    xx = 0;
    {
#line 17415
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17415
      if (! (xx < stamp_outline_w)) {
#line 17415
        goto while_break___0;
      }
#line 17417
      if (! *(stamp_outline_data + (xx + yy * stamp_outline_w))) {
#line 17418
        goto while_continue___0;
      }
#line 17419
      sx = (x + xx) - stamp_outline_w / 2;
#line 17420
      sy = (y + yy) - stamp_outline_h / 2;
#line 17421
      if ((int )stiple[sx % 5 + (sy % 5) * 5] != 56) {
#line 17422
        goto while_continue___0;
      }
      {
#line 17423
      xorpixel(sx, sy);
      }
#line 17415
      xx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 17413
    yy ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17426
  SDL_UnlockSurface(screen);
  }
  return;
}
}
#line 17434 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void rgbtohsv(Uint8 r8 , Uint8 g8 , Uint8 b8 , float *h , float *s , float *v ) 
{ 
  float rgb_min ;
  float rgb_max ;
  float delta ;
  float r ;
  float g ;
  float b ;

  {
#line 17438
  r = (float )((double )((int )r8) / 255.);
#line 17439
  g = (float )((double )((int )g8) / 255.);
#line 17440
  b = (float )((double )((int )b8) / 255.);
#line 17442
  rgb_min = 0;
#line 17443
  rgb_max = 0;
#line 17444
  *v = rgb_max;
#line 17446
  delta = rgb_max - rgb_min;
#line 17448
  if (rgb_max == (float )0) {
#line 17452
    *s = (float )0;
#line 17453
    *h = (float )(- 1);
  } else {
#line 17457
    *s = delta / rgb_max;
#line 17459
    if (r == rgb_max) {
#line 17460
      *h = (g - b) / delta;
    } else
#line 17461
    if (g == rgb_max) {
#line 17462
      *h = (float )2 + (b - r) / delta;
    } else {
#line 17464
      *h = (float )4 + (r - g) / delta;
    }
#line 17466
    *h *= (float )60;
#line 17468
    if (*h < (float )0) {
#line 17469
      *h += (float )360;
    }
  }
  return;
}
}
#line 17477 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void hsvtorgb(float h , float s , float v , Uint8 *r8 , Uint8 *g8 , Uint8 *b8 ) 
{ 
  int i ;
  float f ;
  float p ;
  float q ;
  float t ;
  float r ;
  float g ;
  float b ;
  double __cil_tmp15 ;

  {
#line 17482
  if (s == (float )0) {
#line 17486
    r = v;
#line 17487
    g = v;
#line 17488
    b = v;
  } else {
    {
#line 17492
    h /= (float )60;
#line 17493
    __cil_tmp15 = floor((double )h);
#line 17493
    i = (int )__cil_tmp15;
#line 17494
    f = h - (float )i;
#line 17495
    p = v * ((float )1 - s);
#line 17496
    q = v * ((float )1 - s * f);
#line 17497
    t = v * ((float )1 - s * ((float )1 - f));
    }
#line 17499
    if (i == 0) {
#line 17501
      r = v;
#line 17502
      g = t;
#line 17503
      b = p;
    } else
#line 17505
    if (i == 1) {
#line 17507
      r = q;
#line 17508
      g = v;
#line 17509
      b = p;
    } else
#line 17511
    if (i == 2) {
#line 17513
      r = p;
#line 17514
      g = v;
#line 17515
      b = t;
    } else
#line 17517
    if (i == 3) {
#line 17519
      r = p;
#line 17520
      g = q;
#line 17521
      b = v;
    } else
#line 17523
    if (i == 4) {
#line 17525
      r = t;
#line 17526
      g = p;
#line 17527
      b = v;
    } else {
#line 17531
      r = v;
#line 17532
      g = p;
#line 17533
      b = q;
    }
  }
#line 17538
  *r8 = (Uint8 )(r * (float )255);
#line 17539
  *g8 = (Uint8 )(g * (float )255);
#line 17540
  *b8 = (Uint8 )(b * (float )255);
  return;
}
}
#line 17546 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void print_image(void) 
{ 
  int cur_time ;
  int scroll ;
  Uint32 __cil_tmp3 ;
  int tmp ;
  SDLMod __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 17550
  __cil_tmp3 = SDL_GetTicks();
#line 17550
  cur_time = (int )(__cil_tmp3 / 1000U);
  }
#line 17551
  if (16 > buttons_tall * (int )gd_tools.cols) {
#line 17551
    tmp = img_scroll_down->h;
  } else {
#line 17551
    tmp = 0;
  }
#line 17551
  scroll = tmp;
#line 17557
  if (cur_time >= last_print_time + print_delay) {
#line 17559
    if (alt_print_command_default == 1) {
#line 17560
      want_alt_printcommand = 1;
    } else
#line 17561
    if (alt_print_command_default == 2) {
#line 17562
      want_alt_printcommand = 0;
    } else {
      {
#line 17564
      __cil_tmp5 = SDL_GetModState();
#line 17564
      want_alt_printcommand = (int )((unsigned int )__cil_tmp5 & 768U);
      }
    }
    {
#line 17566
    __cil_tmp6 = do_prompt_image_snd("Print your picture now?", "Yes, print it!",
                                     "No, take me back!\261\246t\324U", img_printer,
                                     (SDL_Surface *)((void *)0), (SDL_Surface *)((void *)0),
                                     25, button_w / 2, (((7 * button_h + (int )r_ttools.h) + button_h / 2) - (tool_scroll * button_h) / (int )gd_tools.cols) + scroll);
    }
#line 17566
    if (__cil_tmp6) {
      {
#line 17573
      do_print();
#line 17575
      last_print_time = cur_time;
      }
    }
  } else {
    {
#line 17580
    do_prompt_image_snd("You can\342\200\231t print yet!", "OK", "\230\001", img_printer_wait,
                        (SDL_Surface *)((void *)0), (SDL_Surface *)((void *)0), 26,
                        0, screen->h);
    }
  }
  return;
}
}
#line 17588 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
void do_print(void) 
{ 
  char const   *pcmd ;
  FILE *pi ;
  FILE *__cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 17591
  SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), save_canvas, (SDL_Rect *)((void *)0));
#line 17592
  SDL_UpperBlit(label, (SDL_Rect *)((void *)0), save_canvas, (SDL_Rect *)((void *)0));
  }
#line 17600
  if (want_alt_printcommand) {
#line 17600
    if (! fullscreen) {
#line 17601
      pcmd = altprintcommand;
    } else {
#line 17603
      pcmd = printcommand;
    }
  } else {
#line 17603
    pcmd = printcommand;
  }
  {
#line 17605
  pi = popen(pcmd, "w");
  }
#line 17607
  if (pi == (void *)0) {
    {
#line 17609
    perror(pcmd);
    }
  } else {
    {
#line 17619
    __cil_tmp4 = do_ps_save(pi, pcmd, save_canvas, papersize, 1);
    }
#line 17619
    if (__cil_tmp4) {
      {
#line 17620
      do_prompt_snd("Your picture has been printed!", "OK", "\230", 27, screen->w / 2,
                    screen->h / 2);
      }
    } else {
      {
#line 17622
      do_prompt_snd("Sorry! Your picture could not be printed!", "OK", "\230", 26,
                    screen->w / 2, screen->h / 2);
      }
    }
  }
  return;
}
}
#line 17666 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_render_cur_text(int do_blit ) 
{ 
  int w ;
  int h ;
  SDL_Color color ;
  SDL_Surface *tmp_surf ;
  SDL_Rect dest ;
  SDL_Rect src ;
  wchar_t *str ;
  TuxPaint_Font *__cil_tmp9 ;
  int __cil_tmp10 ;
  TuxPaint_Font *__cil_tmp11 ;
  int __cil_tmp12 ;
  FriBidiParType baseDir ;
  FriBidiChar *unicodeIn ;
  FriBidiChar *unicodeOut ;
  unsigned int i ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  unsigned int __cil_tmp21 ;
  TuxPaint_Font *__cil_tmp22 ;
  SDL_Surface *__cil_tmp23 ;
  TuxPaint_Font *__cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 17670
  color.r = *(*(color_hexes + cur_color) + 0);
#line 17670
  color.g = *(*(color_hexes + cur_color) + 1);
#line 17670
  color.b = *(*(color_hexes + cur_color) + 2);
  {
#line 17670
  color.unused = (Uint8 )0;
#line 17686
  __cil_tmp9 = getfonthandle(cur_font);
#line 17686
  __cil_tmp10 = TuxPaint_Font_FontHeight(__cil_tmp9);
  }
#line 17686
  if (cursor_y > (button_h * buttons_tall + (int )r_ttools.h) - __cil_tmp10) {
    {
#line 17688
    __cil_tmp11 = getfonthandle(cur_font);
#line 17688
    __cil_tmp12 = TuxPaint_Font_FontHeight(__cil_tmp11);
#line 17688
    cursor_y = (button_h * buttons_tall + (int )r_ttools.h) - __cil_tmp12;
    }
  }
#line 17694
  if (texttool_len > 0U) {
    {
#line 17701
    baseDir = (FriBidiParType )32;
#line 17706
    __cil_tmp17 = malloc(sizeof(FriBidiChar ) * (unsigned long )(texttool_len + 1U));
#line 17706
    unicodeIn = (FriBidiChar *)__cil_tmp17;
#line 17707
    __cil_tmp18 = malloc(sizeof(FriBidiChar ) * (unsigned long )(texttool_len + 1U));
#line 17707
    unicodeOut = (FriBidiChar *)__cil_tmp18;
#line 17709
    __cil_tmp19 = malloc(sizeof(wchar_t ) * (unsigned long )(texttool_len + 1U));
#line 17709
    str = (wchar_t *)__cil_tmp19;
#line 17711
    i = (unsigned int )0;
    }
    {
#line 17711
    while (1) {
      while_continue: /* CIL Label */ ;
#line 17711
      if (! (i < texttool_len)) {
#line 17711
        goto while_break;
      }
#line 17712
      *(unicodeIn + i) = (FriBidiChar )texttool_str[i];
#line 17711
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 17714
    fribidi_log2vis(unicodeIn, (FriBidiStrIndex )texttool_len, & baseDir, unicodeOut,
                    (FriBidiStrIndex *)0, (FriBidiStrIndex *)0, (FriBidiLevel *)0);
#line 17719
    i = (unsigned int )0;
    }
    {
#line 17719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 17719
      if (! (i < texttool_len)) {
#line 17719
        goto while_break___0;
      }
#line 17720
      *(str + i) = (wchar_t )((long )*(unicodeOut + i));
#line 17719
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 17722
    *(str + texttool_len) = '\000';
#line 17724
    free(unicodeIn);
#line 17725
    free(unicodeOut);
#line 17730
    __cil_tmp22 = getfonthandle(cur_font);
#line 17730
    __cil_tmp23 = render_text_w(__cil_tmp22, str, color);
#line 17730
    tmp_surf = __cil_tmp23;
#line 17732
    w = tmp_surf->w;
#line 17733
    h = tmp_surf->h;
#line 17735
    cursor_textwidth = w;
    }
  } else {
#line 17739
    if (cur_label != 2) {
      {
#line 17741
      update_canvas_ex_r((int )old_dest.x - (int )r_ttools.w, (int )old_dest.y, (int )old_dest.x + (int )old_dest.w,
                         (int )old_dest.y + (int )old_dest.h, 0);
#line 17742
      old_dest.h = (Uint16 )0;
#line 17742
      old_dest.w = old_dest.h;
#line 17742
      old_dest.y = (Sint16 )old_dest.w;
#line 17742
      old_dest.x = old_dest.y;
#line 17745
      __cil_tmp24 = getfonthandle(cur_font);
#line 17745
      __cil_tmp25 = TuxPaint_Font_FontHeight(__cil_tmp24);
#line 17745
      update_canvas_ex_r(old_cursor_x - 1, old_cursor_y - 1, old_cursor_x + 1, (old_cursor_y + 1) + __cil_tmp25,
                         0);
#line 17751
      old_cursor_x = cursor_x;
#line 17752
      old_cursor_y = cursor_y;
#line 17753
      cursor_textwidth = 0;
      }
    }
    {
#line 17756
    SDL_Flip(screen);
    }
#line 17757
    return;
  }
#line 17762
  if (! do_blit) {
    {
#line 17764
    update_canvas_ex_r((int )old_dest.x - (int )r_ttools.w, (int )old_dest.y, (int )old_dest.x + (int )old_dest.w,
                       (int )old_dest.y + (int )old_dest.h, 0);
#line 17774
    dest.x = (Sint16 )((cursor_x - 2) + (int )r_ttools.w);
#line 17775
    dest.y = (Sint16 )(cursor_y - 2);
#line 17776
    dest.w = (Uint16 )(w + 4);
#line 17777
    dest.h = (Uint16 )(h + 4);
    }
#line 17779
    if ((int )dest.x + (int )dest.w > WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 17780
      dest.w = (Uint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )dest.x);
    }
#line 17781
    if ((int )dest.y + (int )dest.h > button_h * buttons_tall + (int )r_ttools.h) {
#line 17782
      dest.h = (Uint16 )((button_h * buttons_tall + (int )r_ttools.h) - (int )dest.y);
    }
    {
#line 17784
    SDL_FillRect(screen, & dest, 0U);
#line 17786
    old_dest.x = dest.x;
#line 17787
    old_dest.y = dest.y;
#line 17788
    old_dest.w = dest.w;
#line 17789
    old_dest.h = dest.h;
#line 17793
    dest.x = (Sint16 )(cursor_x + (int )r_ttools.w);
#line 17794
    dest.y = (Sint16 )cursor_y;
#line 17795
    dest.w = (Uint16 )w;
#line 17796
    dest.h = (Uint16 )h;
    }
#line 17798
    if ((int )dest.x + (int )dest.w > WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 17799
      dest.w = (Uint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )dest.x);
    }
#line 17800
    if ((int )dest.y + (int )dest.h > button_h * buttons_tall + (int )r_ttools.h) {
#line 17801
      dest.h = (Uint16 )((button_h * buttons_tall + (int )r_ttools.h) - (int )dest.y);
    }
#line 17803
    if (((int )*(*(color_hexes + cur_color) + 0) + (int )*(*(color_hexes + cur_color) + 1)) + (int )*(*(color_hexes + cur_color) + 2) >= 384) {
      {
#line 17807
      SDL_FillRect(screen, & dest, ((64U << 16) | (64U << 8)) | 64U);
      }
    } else {
      {
#line 17813
      SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
      }
    }
  }
#line 17820
  if (tmp_surf != (void *)0) {
#line 17822
    dest.x = (Sint16 )cursor_x;
#line 17823
    dest.y = (Sint16 )cursor_y;
#line 17825
    src.x = (Sint16 )0;
#line 17826
    src.y = (Sint16 )0;
#line 17827
    src.w = (Uint16 )tmp_surf->w;
#line 17828
    src.h = (Uint16 )tmp_surf->h;
#line 17830
    if ((int )dest.x + (int )src.w > (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) {
#line 17831
      src.w = (Uint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) - (int )dest.x);
    }
#line 17832
    if ((int )dest.y + (int )src.h > button_h * buttons_tall + (int )r_ttools.h) {
#line 17833
      src.h = (Uint16 )((button_h * buttons_tall + (int )r_ttools.h) - (int )dest.y);
    }
#line 17835
    if (do_blit) {
#line 17837
      if (label_node_to_edit) {
#line 17837
        if (cur_tool == 5) {
          {
#line 17842
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17843
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          {
          {
          {
          {
          {
#line 17844
          simply_render_node(current_label_node);
          }
          }
          }
          }
          }
          }
        } else {
#line 17837
          goto _L___233;
        }
      } else
      _L___233: /* CIL Label */ 
#line 17837
      if (label_node_to_edit) {
#line 17837
        if (old_tool == 5) {
#line 17837
          if (cur_tool == 14) {
            {
#line 17842
            have_to_rec_label_node = ! 0;
            {
            {
            {
            {
            {
#line 17843
            add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                           tmp_surf);
            }
            }
            }
            }
            }
            {
            {
            {
            {
            {
#line 17844
            simply_render_node(current_label_node);
            }
            }
            }
            }
            }
            }
          } else
#line 17837
          if (cur_tool == 13) {
            {
#line 17842
            have_to_rec_label_node = ! 0;
            {
            {
            {
            {
            {
#line 17843
            add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                           tmp_surf);
            }
            }
            }
            }
            }
            {
            {
            {
            {
            {
#line 17844
            simply_render_node(current_label_node);
            }
            }
            }
            }
            }
            }
          } else
#line 17837
          if (cur_tool == 12) {
            {
#line 17842
            have_to_rec_label_node = ! 0;
            {
            {
            {
            {
            {
#line 17843
            add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                           tmp_surf);
            }
            }
            }
            }
            }
            {
            {
            {
            {
            {
#line 17844
            simply_render_node(current_label_node);
            }
            }
            }
            }
            }
            }
          } else
#line 17837
          if (cur_tool == 11) {
            {
#line 17842
            have_to_rec_label_node = ! 0;
            {
            {
            {
            {
            {
#line 17843
            add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                           tmp_surf);
            }
            }
            }
            }
            }
            {
            {
            {
            {
            {
#line 17844
            simply_render_node(current_label_node);
            }
            }
            }
            }
            }
            }
          } else
#line 17837
          if (cur_tool == 15) {
            {
#line 17842
            have_to_rec_label_node = ! 0;
            {
            {
            {
            {
            {
#line 17843
            add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                           tmp_surf);
            }
            }
            }
            }
            }
            {
            {
            {
            {
            {
#line 17844
            simply_render_node(current_label_node);
            }
            }
            }
            }
            }
            }
          } else {
#line 17837
            goto _L;
          }
        } else {
#line 17837
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      _L___232: /* CIL Label */ 
#line 17846
      if (cur_tool == 5) {
        {
        {
        {
        {
        {
        {
#line 17851
        myblit(tmp_surf, & src, label, & dest);
        }
        }
        }
        }
        }
#line 17853
        have_to_rec_label_node = ! 0;
        {
        {
        {
        {
        {
#line 17854
        add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                       tmp_surf);
        }
        }
        }
        }
        }
        }
      } else
#line 17846
      if (old_tool == 5) {
#line 17846
        if (cur_tool == 14) {
          {
          {
          {
          {
          {
          {
#line 17851
          myblit(tmp_surf, & src, label, & dest);
          }
          }
          }
          }
          }
#line 17853
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17854
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          }
        } else
#line 17846
        if (cur_tool == 13) {
          {
          {
          {
          {
          {
          {
#line 17851
          myblit(tmp_surf, & src, label, & dest);
          }
          }
          }
          }
          }
#line 17853
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17854
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          }
        } else
#line 17846
        if (cur_tool == 12) {
          {
          {
          {
          {
          {
          {
#line 17851
          myblit(tmp_surf, & src, label, & dest);
          }
          }
          }
          }
          }
#line 17853
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17854
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          }
        } else
#line 17846
        if (cur_tool == 11) {
          {
          {
          {
          {
          {
          {
#line 17851
          myblit(tmp_surf, & src, label, & dest);
          }
          }
          }
          }
          }
#line 17853
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17854
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          }
        } else
#line 17846
        if (cur_tool == 15) {
          {
          {
          {
          {
          {
          {
#line 17851
          myblit(tmp_surf, & src, label, & dest);
          }
          }
          }
          }
          }
#line 17853
          have_to_rec_label_node = ! 0;
          {
          {
          {
          {
          {
#line 17854
          add_label_node((int )src.w, (int )src.h, (Uint16 )dest.x, (Uint16 )dest.y,
                         tmp_surf);
          }
          }
          }
          }
          }
          }
        } else {
          {
          {
#line 17859
          SDL_UpperBlit(tmp_surf, & src, canvas, & dest);
          }
          }
        }
      } else {
        {
        {
#line 17859
        SDL_UpperBlit(tmp_surf, & src, canvas, & dest);
        }
        }
      }
      {
#line 17861
      update_canvas_ex_r((int )dest.x - 2, (int )dest.y - 2, ((int )dest.x + tmp_surf->w) + 4,
                         ((int )dest.y + tmp_surf->h) + 4, 0);
      }
    } else {
      {
#line 17865
      dest.x = (Sint16 )((int )dest.x + (int )r_ttools.w);
#line 17866
      SDL_UpperBlit(tmp_surf, & src, screen, & dest);
      }
    }
  }
  {
#line 17872
  SDL_Flip(screen);
#line 17875
  free(str);
  }
#line 17877
  if (tmp_surf != (void *)0) {
    {
#line 17878
    SDL_FreeSurface(tmp_surf);
    }
  }
  return;
}
}
#line 17890 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char *uppercase(char const   *str ) 
{ 
  unsigned int i ;
  unsigned int n ;
  wchar_t *dest ;
  char *ustr ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  wint_t __cil_tmp11 ;

  {
#line 17896
  if (! only_uppercase) {
    {
#line 17897
    __cil_tmp6 = strdup(str);
    }
#line 17897
    return (__cil_tmp6);
  }
  {
#line 17901
  __cil_tmp7 = strlen(str);
#line 17901
  n = (unsigned int )(__cil_tmp7 + 1UL);
#line 17902
  dest = (wchar_t *)__builtin_alloca(sizeof(wchar_t ) * (unsigned long )n);
#line 17903
  ustr = (char *)malloc((unsigned long )(n * 2U));
#line 17905
  mbstowcs(dest, str, sizeof(wchar_t ) * (unsigned long )n);
#line 17906
  i = (unsigned int )0;
  }
  {
#line 17907
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 17909
    __cil_tmp11 = towupper((wint_t )*(dest + i));
#line 17909
    *(dest + i) = (wchar_t )__cil_tmp11;
    }
#line 17907
    if (! *(dest + __cil_tmp10)) {
#line 17907
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 17912
  wcstombs(ustr, dest, (size_t )n);
  }
#line 17917
  return (ustr);
}
}
#line 17923 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static wchar_t *uppercase_w(wchar_t *str ) 
{ 
  unsigned int n ;
  unsigned long __cil_tmp3 ;
  wchar_t *ustr ;
  void *__cil_tmp5 ;
  unsigned int i ;
  unsigned int __cil_tmp7 ;
  wint_t __cil_tmp8 ;

  {
  {
#line 17925
  __cil_tmp3 = wcslen(str);
#line 17925
  n = (unsigned int )(__cil_tmp3 + 1UL);
#line 17926
  __cil_tmp5 = malloc(sizeof(wchar_t ) * (unsigned long )n);
#line 17926
  ustr = __cil_tmp5;
#line 17928
  memcpy(ustr, str, sizeof(wchar_t ) * (unsigned long )n);
  }
#line 17930
  if (only_uppercase) {
#line 17932
    i = (unsigned int )0;
    {
#line 17934
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 17936
      __cil_tmp8 = towupper((wint_t )*(ustr + i));
#line 17936
      *(ustr + i) = (wchar_t )__cil_tmp8;
      }
#line 17934
      if (! *(ustr + __cil_tmp7)) {
#line 17934
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 17941
  return (ustr);
}
}
#line 17949 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char *textdir(char const   *str ) 
{ 
  unsigned char *dstr ;
  unsigned int i ;
  unsigned int j ;
  unsigned char c1 ;
  unsigned char c2 ;
  unsigned char c3 ;
  unsigned char c4 ;
  unsigned long __cil_tmp9 ;
  void *__cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  unsigned long __cil_tmp12 ;
  unsigned long __cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
  {
#line 17959
  __cil_tmp9 = strlen(str);
#line 17959
  __cil_tmp10 = malloc(__cil_tmp9 + 5UL);
#line 17959
  dstr = __cil_tmp10;
  }
#line 17961
  if (need_right_to_left_word) {
    {
#line 17963
    __cil_tmp11 = strlen(str);
#line 17963
    *(dstr + __cil_tmp11) = (unsigned char )'\000';
#line 17965
    i = (unsigned int )0;
    }
    {
#line 17965
    while (1) {
      while_continue: /* CIL Label */ ;
#line 17965
      if (! ((unsigned long )i < __cil_tmp12)) {
#line 17965
        goto while_break;
      }
      {
#line 17967
      __cil_tmp13 = strlen(str);
#line 17967
      j = (unsigned int )((__cil_tmp13 - (unsigned long )i) - 1UL);
#line 17969
      c1 = (unsigned char )*(str + i);
#line 17970
      c2 = (unsigned char )*(str + (i + 1U));
#line 17971
      c3 = (unsigned char )*(str + (i + 2U));
#line 17972
      c4 = (unsigned char )*(str + (i + 3U));
      }
#line 17974
      if ((int )c1 < 128) {
#line 17976
        *(dstr + j) = (unsigned char )*(str + i);
      } else
#line 17978
      if (((int )c1 & 224) == 192) {
#line 17980
        *(dstr + (j - 1U)) = c1;
#line 17981
        *(dstr + j) = c2;
#line 17982
        i ++;
      } else
#line 17984
      if (((int )c1 & 240) == 224) {
#line 17986
        *(dstr + (j - 2U)) = c1;
#line 17987
        *(dstr + (j - 1U)) = c2;
#line 17988
        *(dstr + j) = c3;
#line 17989
        i += 2U;
      } else {
#line 17993
        *(dstr + (j - 3U)) = c1;
#line 17994
        *(dstr + (j - 2U)) = c2;
#line 17995
        *(dstr + (j - 1U)) = c3;
#line 17996
        *(dstr + j) = c4;
#line 17997
        i += 3U;
      }
#line 17965
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 18003
    strcpy((char *)dstr, str);
    }
  }
#line 18010
  return ((char *)dstr);
}
}
#line 18018 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint32 scrolltimer_callback(Uint32 interval , void *param ) 
{ 


  {
#line 18021
  if (scrolling) {
    {
#line 18024
    SDL_PushEvent((SDL_Event *)param);
    }
#line 18025
    return (interval);
  } else {

#line 18030
    return ((Uint32 )0);
  }
}
}
#line 18039 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void control_drawtext_timer(Uint32 interval , char const   *text , Uint8 locale_text ) 
{ 
  static int activated ;
  static SDL_TimerID TimerID ;
  static SDL_Event drawtext_event ;
  SDL_TimerID __cil_tmp7 ;

  {
#line 18041
  activated = 0;
#line 18042
  TimerID = (SDL_TimerID )0;
#line 18048
  if (activated) {
    {
#line 18050
    SDL_RemoveTimer(TimerID);
#line 18051
    activated = 0;
#line 18052
    TimerID = (SDL_TimerID )0;
    }
  }
#line 18055
  if (interval == 0U) {
#line 18056
    return;
  }
  {
#line 18058
  drawtext_event.type = (Uint8 )24;
#line 18059
  drawtext_event.user.code = 1;
#line 18060
  drawtext_event.user.data1 = (void *)text;
#line 18061
  drawtext_event.user.data2 = (void *)((intptr_t )((int )locale_text));
#line 18066
  TimerID = SDL_AddTimer(interval, & drawtext_callback, (void *)(& drawtext_event));
#line 18067
  activated = 1;
  }
  return;
}
}
#line 18075 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint32 drawtext_callback(Uint32 interval , void *param ) 
{ 


  {
  {
#line 18078
  SDL_PushEvent((SDL_Event *)param);
  }
#line 18080
  return ((Uint32 )0);
}
}
#line 18105 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char const   *great_str(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 18107
  __cil_tmp1 = rand();
  }
#line 18107
  return (great_strs[(unsigned long )__cil_tmp1 % (sizeof(great_strs) / sizeof(char *))]);
}
}
#line 18132 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void draw_image_title(int t , SDL_Rect dest ) 
{ 


  {
  {
#line 18134
  SDL_UpperBlit(img_title_on, (SDL_Rect *)((void *)0), screen, & dest);
#line 18136
  dest.x += ((int )dest.w - (img_title_names[t])->w) / 2;
#line 18137
  dest.y += ((int )dest.h - (img_title_names[t])->h) / 2;
#line 18138
  SDL_UpperBlit(img_title_names[t], (SDL_Rect *)((void *)0), screen, & dest);
  }
  return;
}
}
#line 18148 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_keymouse(SDLKey key , Uint8 updown , int steps , SDL_Rect *area1 ,
                            SDL_Rect *area2 ) 
{ 
  int left ;
  int right ;
  int up ;
  int bottom ;
  SDL_Event event ;
  SDL_Rect r1 ;
  SDL_Rect r2 ;
  SDLMod __cil_tmp13 ;

  {
#line 18154
  if (keymouse) {
#line 18157
    r1.h = (Uint16 )0;
#line 18157
    r1.w = r1.h;
#line 18157
    r1.y = (Sint16 )r1.w;
#line 18157
    r1.x = r1.y;
#line 18158
    r2.h = (Uint16 )0;
#line 18158
    r2.w = r2.h;
#line 18158
    r2.y = (Sint16 )r2.w;
#line 18158
    r2.x = r2.y;
#line 18160
    if (area1) {
#line 18162
      r1.x = (Sint16 )0;
#line 18163
      r1.y = (Sint16 )0;
#line 18164
      r1.w = (Uint16 )((((int )area1->x - (int )r1.x) + (int )area1->w) + 5);
#line 18165
      r1.h = (Uint16 )((((int )area1->y - (int )r1.y) + (int )area1->h) + 5);
    }
#line 18168
    if (area2) {
#line 18170
      r2.x = (Sint16 )0;
#line 18171
      r2.y = (Sint16 )0;
#line 18172
      r2.w = (Uint16 )((((int )area2->x - (int )r2.x) + (int )area2->w) + 5);
#line 18173
      r2.h = (Uint16 )((((int )area2->y - (int )r2.y) + (int )area2->h) + 5);
    }
    {
#line 18177
    left = 0;
#line 18178
    right = 0;
#line 18179
    up = 0;
#line 18180
    bottom = 0;
#line 18183
    __cil_tmp13 = SDL_GetModState();
    }
#line 18183
    if (! ((unsigned int )__cil_tmp13 & 3U)) {
#line 18186
      if (area1) {
#line 18186
        if (oldpos_x > (int )r1.x) {
#line 18186
          if (oldpos_x - (int )r1.x < (int )r1.w) {
#line 18186
            if (oldpos_y > (int )r1.y) {
#line 18186
              if (oldpos_y - (int )r1.y < (int )r1.h) {
#line 18189
                left = 0;
#line 18190
                right = 0;
#line 18191
                up = 0;
#line 18192
                bottom = 0;
              } else {
#line 18186
                goto _L___238;
              }
            } else {
#line 18186
              goto _L___238;
            }
          } else {
#line 18186
            goto _L___238;
          }
        } else {
#line 18186
          goto _L___238;
        }
      } else
      _L___238: /* CIL Label */ 
      _L___239: /* CIL Label */ 
      _L___240: /* CIL Label */ 
      _L___241: /* CIL Label */ 
#line 18186
      if (area2) {
#line 18186
        if (oldpos_x > (int )r2.x) {
#line 18186
          if (oldpos_x - (int )r2.x < (int )r2.w) {
#line 18186
            if (oldpos_y > (int )r2.y) {
#line 18186
              if (oldpos_y - (int )r2.y < (int )r2.h) {
#line 18189
                left = 0;
#line 18190
                right = 0;
#line 18191
                up = 0;
#line 18192
                bottom = 0;
              } else {
#line 18186
                goto _L___234;
              }
            } else {
#line 18186
              goto _L___234;
            }
          } else {
#line 18186
            goto _L___234;
          }
        } else {
#line 18186
          goto _L___234;
        }
      } else
      _L___234: /* CIL Label */ 
      _L___235: /* CIL Label */ 
      _L___236: /* CIL Label */ 
      _L___237: /* CIL Label */ 
#line 18196
      if (area1) {
        _L: /* CIL Label */ 
#line 18198
        if (area1) {
#line 18199
          if (oldpos_y - (int )r1.y < (int )r1.h) {
#line 18199
            if (oldpos_y > (int )r1.y) {
#line 18201
              if (oldpos_x - (int )r1.x < steps) {
#line 18202
                right = 0;
              } else
#line 18203
              if ((oldpos_x - (int )r1.x) - (int )r1.w < steps) {
#line 18204
                left = 0;
              }
            }
          }
        }
#line 18207
        if (oldpos_x - (int )r1.x < (int )r1.w) {
#line 18207
          if (oldpos_x > (int )r1.x) {
#line 18209
            if (oldpos_y - (int )r1.y < steps) {
#line 18210
              bottom = 0;
            } else
#line 18211
            if ((oldpos_y - (int )r1.y) - (int )r1.h < steps) {
#line 18212
              up = 0;
            }
          }
        }
#line 18215
        if (area2) {
#line 18216
          if (oldpos_y - (int )r2.y < (int )r2.h) {
#line 18216
            if (oldpos_y > (int )r2.y) {
#line 18218
              if (oldpos_x - (int )r2.x < steps) {
#line 18219
                right = 0;
              } else
#line 18220
              if ((oldpos_x - (int )r2.x) - (int )r2.w < steps) {
#line 18221
                left = 0;
              }
            }
          }
        }
#line 18224
        if (oldpos_x - (int )r2.x < (int )r2.w) {
#line 18224
          if (oldpos_x > (int )r2.x) {
#line 18226
            if (oldpos_y - (int )r2.y < steps) {
#line 18227
              bottom = 0;
            } else
#line 18228
            if ((oldpos_y - (int )r2.y) - (int )r2.h < steps) {
#line 18229
              up = 0;
            }
          }
        }
      } else
#line 18196
      if (area2) {
#line 18196
        goto _L;
      }
    }
#line 18234
    if ((int )updown == 3) {
#line 18236
      if ((unsigned int )key == 277U) {
        {
#line 18241
        event.type = (Uint8 )6;
#line 18242
        event.button.x = (Uint16 )oldpos_x;
#line 18243
        event.button.y = (Uint16 )oldpos_y;
#line 18244
        event.button.button = (Uint8 )1;
        {
        {
        {
        {
#line 18245
        SDL_PushEvent(& event);
        }
        }
        }
        }
        }
      } else
#line 18236
      if ((unsigned int )key == 286U) {
        {
#line 18241
        event.type = (Uint8 )6;
#line 18242
        event.button.x = (Uint16 )oldpos_x;
#line 18243
        event.button.y = (Uint16 )oldpos_y;
#line 18244
        event.button.button = (Uint8 )1;
        {
        {
        {
        {
#line 18245
        SDL_PushEvent(& event);
        }
        }
        }
        }
        }
      } else
#line 18236
      if (cur_tool != 4) {
#line 18236
        if (cur_tool != 5) {
#line 18236
          if ((unsigned int )key == 32U) {
            {
#line 18241
            event.type = (Uint8 )6;
#line 18242
            event.button.x = (Uint16 )oldpos_x;
#line 18243
            event.button.y = (Uint16 )oldpos_y;
#line 18244
            event.button.button = (Uint8 )1;
            {
            {
            {
            {
#line 18245
            SDL_PushEvent(& event);
            }
            }
            }
            }
            }
          } else
#line 18236
          if ((unsigned int )key == 53U) {
            {
#line 18241
            event.type = (Uint8 )6;
#line 18242
            event.button.x = (Uint16 )oldpos_x;
#line 18243
            event.button.y = (Uint16 )oldpos_y;
#line 18244
            event.button.button = (Uint8 )1;
            {
            {
            {
            {
#line 18245
            SDL_PushEvent(& event);
            }
            }
            }
            }
            }
          } else
#line 18236
          if ((unsigned int )key == 261U) {
            {
#line 18241
            event.type = (Uint8 )6;
#line 18242
            event.button.x = (Uint16 )oldpos_x;
#line 18243
            event.button.y = (Uint16 )oldpos_y;
#line 18244
            event.button.button = (Uint8 )1;
            {
            {
            {
            {
#line 18245
            SDL_PushEvent(& event);
            }
            }
            }
            }
            }
          }
        }
      }
    } else
#line 18251
    if ((unsigned int )key == 276U) {
      {
#line 18252
      SDL_WarpMouse((Uint16 )left, (Uint16 )oldpos_y);
      }
    } else
#line 18254
    if ((unsigned int )key == 275U) {
      {
#line 18255
      SDL_WarpMouse((Uint16 )right, (Uint16 )oldpos_y);
      }
    } else
#line 18257
    if ((unsigned int )key == 273U) {
      {
#line 18258
      SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )up);
      }
    } else
#line 18260
    if ((unsigned int )key == 274U) {
      {
#line 18261
      SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )bottom);
      }
    } else
#line 18263
    if ((unsigned int )key == 277U) {
      _L___244: /* CIL Label */ 
#line 18263
      if (! button_down) {
        {
#line 18265
        event.type = (Uint8 )5;
#line 18266
        event.button.x = (Uint16 )oldpos_x;
#line 18267
        event.button.y = (Uint16 )oldpos_y;
#line 18268
        event.button.button = (Uint8 )1;
#line 18269
        SDL_PushEvent(& event);
        }
      } else {
#line 18263
        goto _L___243;
      }
    } else
#line 18263
    if ((unsigned int )key == 286U) {
#line 18263
      goto _L___244;
    } else
    _L___243: /* CIL Label */ 
#line 18272
    if (cur_tool != 4) {
#line 18272
      if (cur_tool != 5) {
#line 18274
        if (! button_down) {
#line 18274
          if ((unsigned int )key == 32U) {
            {
#line 18276
            event.type = (Uint8 )5;
#line 18277
            event.button.x = (Uint16 )oldpos_x;
#line 18278
            event.button.y = (Uint16 )oldpos_y;
#line 18279
            event.button.button = (Uint8 )1;
            {
            {
#line 18280
            SDL_PushEvent(& event);
            }
            }
            }
          } else
#line 18274
          if ((unsigned int )key == 53U) {
            {
#line 18276
            event.type = (Uint8 )5;
#line 18277
            event.button.x = (Uint16 )oldpos_x;
#line 18278
            event.button.y = (Uint16 )oldpos_y;
#line 18279
            event.button.button = (Uint8 )1;
            {
            {
#line 18280
            SDL_PushEvent(& event);
            }
            }
            }
          } else
#line 18274
          if ((unsigned int )key == 261U) {
            {
#line 18276
            event.type = (Uint8 )5;
#line 18277
            event.button.x = (Uint16 )oldpos_x;
#line 18278
            event.button.y = (Uint16 )oldpos_y;
#line 18279
            event.button.button = (Uint8 )1;
            {
            {
#line 18280
            SDL_PushEvent(& event);
            }
            }
            }
          } else {
#line 18274
            goto _L___242;
          }
        } else
        _L___242: /* CIL Label */ 
#line 18283
        if ((unsigned int )key == 49U) {
          {
          {
#line 18284
          SDL_WarpMouse((Uint16 )left, (Uint16 )bottom);
          }
          }
        } else
#line 18283
        if ((unsigned int )key == 257U) {
          {
          {
#line 18284
          SDL_WarpMouse((Uint16 )left, (Uint16 )bottom);
          }
          }
        } else
#line 18286
        if ((unsigned int )key == 51U) {
          {
          {
#line 18287
          SDL_WarpMouse((Uint16 )right, (Uint16 )bottom);
          }
          }
        } else
#line 18286
        if ((unsigned int )key == 259U) {
          {
          {
#line 18287
          SDL_WarpMouse((Uint16 )right, (Uint16 )bottom);
          }
          }
        } else
#line 18289
        if ((unsigned int )key == 55U) {
          {
          {
#line 18290
          SDL_WarpMouse((Uint16 )left, (Uint16 )up);
          }
          }
        } else
#line 18289
        if ((unsigned int )key == 263U) {
          {
          {
#line 18290
          SDL_WarpMouse((Uint16 )left, (Uint16 )up);
          }
          }
        } else
#line 18292
        if ((unsigned int )key == 57U) {
          {
          {
#line 18293
          SDL_WarpMouse((Uint16 )right, (Uint16 )up);
          }
          }
        } else
#line 18292
        if ((unsigned int )key == 265U) {
          {
          {
#line 18293
          SDL_WarpMouse((Uint16 )right, (Uint16 )up);
          }
          }
        } else
#line 18295
        if ((unsigned int )key == 50U) {
          {
          {
#line 18296
          SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )bottom);
          }
          }
        } else
#line 18295
        if ((unsigned int )key == 258U) {
          {
          {
#line 18296
          SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )bottom);
          }
          }
        } else
#line 18298
        if ((unsigned int )key == 56U) {
          {
          {
#line 18299
          SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )up);
          }
          }
        } else
#line 18298
        if ((unsigned int )key == 264U) {
          {
          {
#line 18299
          SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )up);
          }
          }
        } else
#line 18301
        if ((unsigned int )key == 54U) {
          {
          {
#line 18302
          SDL_WarpMouse((Uint16 )right, (Uint16 )oldpos_y);
          }
          }
        } else
#line 18301
        if ((unsigned int )key == 262U) {
          {
          {
#line 18302
          SDL_WarpMouse((Uint16 )right, (Uint16 )oldpos_y);
          }
          }
        } else
#line 18304
        if ((unsigned int )key == 52U) {
          {
          {
#line 18305
          SDL_WarpMouse((Uint16 )left, (Uint16 )oldpos_y);
          }
          }
        } else
#line 18304
        if ((unsigned int )key == 260U) {
          {
          {
#line 18305
          SDL_WarpMouse((Uint16 )left, (Uint16 )oldpos_y);
          }
          }
        }
      }
    }
  }
  return;
}
}
#line 18332 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_keymouse_buttons(SDLKey key , int *whicht , int *whichc , SDL_Rect real_r_tools ) 
{ 
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;

  {
  {
#line 18334
  __cil_tmp5 = hit_test(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
  }
#line 18334
  if (__cil_tmp5) {
#line 18334
    if ((unsigned int )key == 288U) {
      _L___250: /* CIL Label */ 
      _L___251: /* CIL Label */ 
      _L___252: /* CIL Label */ 
      {
#line 18337
      __cil_tmp6 = grid_hit_gd(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y,
                               & gd_tools);
#line 18337
      *whicht = tool_scroll + __cil_tmp6;
#line 18339
      __cil_tmp7 = hit_test(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
      }
#line 18339
      if ((unsigned int )key == 288U) {
#line 18339
        if (__cil_tmp7) {
#line 18341
          *whicht += 2;
#line 18342
          *whicht %= 16;
          {
#line 18343
          while (1) {
            while_continue: /* CIL Label */ ;
#line 18343
            if (! (! tool_avail[*whicht])) {
#line 18343
              goto while_break;
            }
#line 18345
            *whicht += 2;
#line 18346
            *whicht %= 16;
          }
          while_break: /* CIL Label */ ;
          }
        } else {
#line 18339
          goto _L___246;
        }
      } else {
        _L___246: /* CIL Label */ 
        {
#line 18350
        __cil_tmp8 = hit_test(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
        }
#line 18350
        if ((unsigned int )key == 289U) {
#line 18350
          if (__cil_tmp8) {
#line 18352
            *whicht -= 2;
#line 18353
            if (*whicht < 0) {
#line 18354
              *whicht += 16;
            }
            {
#line 18355
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 18355
              if (! (! tool_avail[*whicht])) {
#line 18355
                goto while_break___0;
              }
#line 18357
              *whicht -= 2;
#line 18358
              if (*whicht < 0) {
#line 18359
                *whicht += 16;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
#line 18350
            goto _L___245;
          }
        } else {
          _L___245: /* CIL Label */ 
          {
#line 18363
          __cil_tmp9 = hit_test(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
          }
#line 18363
          if ((unsigned int )key == 293U) {
#line 18363
            if (__cil_tmp9) {
#line 18365
              (*whicht) ++;
#line 18366
              *whicht %= 16;
              {
#line 18367
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 18367
                if (! (! tool_avail[*whicht])) {
#line 18367
                  goto while_break___1;
                }
#line 18369
                (*whicht) ++;
#line 18370
                *whicht %= 16;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 18363
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 18374
            __cil_tmp10 = hit_test(& real_r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
            }
#line 18374
            if ((unsigned int )key == 292U) {
#line 18374
              if (__cil_tmp10) {
                {
#line 18376
                __cil_tmp11 = grid_hit_gd(& real_r_tools, (unsigned int )oldpos_x,
                                          (unsigned int )oldpos_y, & gd_tools);
#line 18376
                *whicht = tool_scroll + __cil_tmp11;
#line 18377
                (*whicht) --;
                }
#line 18378
                if (*whicht < 0) {
#line 18379
                  *whicht += 16;
                }
                {
#line 18380
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 18380
                  if (! (! tool_avail[*whicht])) {
#line 18380
                    goto while_break___2;
                  }
#line 18382
                  (*whicht) --;
#line 18383
                  if (*whicht < 0) {
#line 18384
                    *whicht += 16;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
      {
#line 18388
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 18388
        if (! (*whicht >= tool_scroll + (2 * (int )real_r_tools.h) / button_h)) {
#line 18388
          goto while_break___3;
        }
        {
#line 18390
        tool_scroll += 2;
#line 18391
        draw_toolbar();
#line 18392
        update_screen_rect(& r_tools);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 18394
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 18394
        if (! (*whicht < tool_scroll)) {
#line 18394
          goto while_break___4;
        }
        {
#line 18396
        tool_scroll -= 2;
#line 18397
        draw_toolbar();
#line 18398
        update_screen_rect(& r_tools);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 18401
      SDL_WarpMouse((Uint16 )(button_w / 2 + (*whicht % 2) * button_w), (Uint16 )(((((int )real_r_tools.y - ((*whicht % 2) * button_w) / 2) + (*whicht * button_h) / 2) + 10) - (tool_scroll * button_h) / 2));
      }
    } else
#line 18334
    if ((unsigned int )key == 289U) {
#line 18334
      goto _L___250;
    } else
#line 18334
    if ((unsigned int )key == 292U) {
#line 18334
      goto _L___250;
    } else
#line 18334
    if ((unsigned int )key == 293U) {
#line 18334
      goto _L___250;
    } else {
#line 18334
      goto _L___249;
    }
  } else {
    _L___249: /* CIL Label */ 
    {
#line 18406
    __cil_tmp12 = hit_test(& r_colors, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
    }
#line 18406
    if ((unsigned int )key == 292U) {
#line 18406
      if (__cil_tmp12) {
        {
#line 18408
        *whichc = grid_hit_gd(& r_colors, (unsigned int )oldpos_x, (unsigned int )oldpos_y,
                              & gd_colors);
#line 18409
        (*whichc) --;
        }
#line 18410
        if (*whichc < 0) {
#line 18411
          *whichc += NUM_COLORS;
        }
        {
#line 18412
        SDL_WarpMouse((Uint16 )((button_w * 2 + *whichc * color_button_w) + 12), (Uint16 )((int )r_canvas.h + (int )r_colors.h / 2));
        }
      } else {
#line 18406
        goto _L___248;
      }
    } else {
      _L___248: /* CIL Label */ 
      {
#line 18415
      __cil_tmp14 = hit_test(& r_colors, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
      }
#line 18415
      if ((unsigned int )key == 293U) {
#line 18415
        if (__cil_tmp14) {
          {
#line 18417
          *whichc = grid_hit_gd(& r_colors, (unsigned int )oldpos_x, (unsigned int )oldpos_y,
                                & gd_colors);
#line 18418
          (*whichc) ++;
#line 18419
          *whichc %= NUM_COLORS;
#line 18420
          SDL_WarpMouse((Uint16 )((button_w * 2 + *whichc * color_button_w) + 12),
                        (Uint16 )((int )r_canvas.h + (int )r_colors.h / 2));
          }
        } else {
#line 18415
          goto _L___247;
        }
      } else
      _L___247: /* CIL Label */ 
#line 18423
      if ((unsigned int )key == 285U) {
        {
#line 18425
        __cil_tmp16 = hit_test(& r_tools, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
        }
#line 18425
        if (__cil_tmp16) {
          {
#line 18426
          SDL_WarpMouse((Uint16 )((button_w * 2 + *whichc * color_button_w) + 12),
                        (Uint16 )((int )r_canvas.h + (int )r_colors.h / 2));
          }
        } else {
          {
#line 18427
          __cil_tmp17 = hit_test(& r_colors, (unsigned int )oldpos_x, (unsigned int )oldpos_y);
          }
#line 18427
          if (__cil_tmp17) {
            {
#line 18428
            SDL_WarpMouse((Uint16 )(WINDOW_WIDTH / 2), (Uint16 )(WINDOW_HEIGHT / 2));
            }
          } else {
            {
#line 18430
            SDL_WarpMouse((Uint16 )(button_w / 2 + (*whicht % 2) * button_w), (Uint16 )(((((int )real_r_tools.y - ((*whicht % 2) * button_w) / 2) + (*whicht * button_h) / 2) + 10) - (tool_scroll * button_h) / 2));
            }
          }
        }
        {
#line 18435
        playsound(screen, 1, 1, 0, - 997, - 999);
        }
      }
    }
  }
  return;
}
}
#line 18443 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_active(SDL_Event *event ) 
{ 


  {
#line 18445
  if ((int )event->active.state & 4) {
#line 18447
    if ((int )event->active.gain == 1) {
#line 18449
      if (fullscreen) {
        {
#line 18450
        SDL_Flip(screen);
        }
      }
    }
  }
#line 18453
  if ((int )event->active.state & 6) {
#line 18455
    if ((int )event->active.gain == 1) {
#line 18457
      if (mouseaccessibility) {
        {
#line 18459
        magic_switchin(canvas);
        }
      }
    } else
#line 18462
    if (mouseaccessibility) {
#line 18462
      if (emulate_button_pressed) {
        {
#line 18464
        magic_switchout(canvas);
        }
      }
    }
  }
  return;
}
}
#line 18513 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *duplicate_surface(SDL_Surface *orig ) 
{ 
  SDL_Surface *__cil_tmp2 ;

  {
  {
#line 18531
  __cil_tmp2 = SDL_DisplayFormatAlpha(orig);
  }
#line 18531
  return (__cil_tmp2);
}
}
#line 18537 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void mirror_starter(void) 
{ 
  SDL_Surface *orig ;
  int x ;
  SDL_Rect src ;
  SDL_Rect dest ;
  SDL_Surface *__cil_tmp5 ;
  int __cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 18546
  orig = img_starter;
#line 18547
  img_starter = duplicate_surface(orig);
  }
#line 18549
  if (img_starter != (void *)0) {
#line 18551
    x = 0;
    {
#line 18551
    while (1) {
      while_continue: /* CIL Label */ ;
#line 18551
      if (! (x < orig->w)) {
#line 18551
        goto while_break;
      }
      {
#line 18553
      src.x = (Sint16 )x;
#line 18554
      src.y = (Sint16 )0;
#line 18555
      src.w = (Uint16 )1;
#line 18556
      src.h = (Uint16 )orig->h;
#line 18558
      dest.x = (Sint16 )((orig->w - x) - 1);
#line 18559
      dest.y = (Sint16 )0;
#line 18561
      SDL_UpperBlit(orig, & src, img_starter, & dest);
      }
#line 18551
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 18564
    SDL_FreeSurface(orig);
    }
  } else {
#line 18568
    img_starter = orig;
  }
#line 18574
  if (img_starter_bkgd != (void *)0) {
    {
#line 18576
    orig = img_starter_bkgd;
#line 18577
    img_starter_bkgd = duplicate_surface(orig);
    }
#line 18579
    if (img_starter_bkgd != (void *)0) {
#line 18581
      x = 0;
      {
#line 18581
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 18581
        if (! (x < orig->w)) {
#line 18581
          goto while_break___0;
        }
        {
#line 18583
        src.x = (Sint16 )x;
#line 18584
        src.y = (Sint16 )0;
#line 18585
        src.w = (Uint16 )1;
#line 18586
        src.h = (Uint16 )orig->h;
#line 18588
        dest.x = (Sint16 )((orig->w - x) - 1);
#line 18589
        dest.y = (Sint16 )0;
#line 18591
        SDL_UpperBlit(orig, & src, img_starter_bkgd, & dest);
        }
#line 18581
        x ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 18594
      SDL_FreeSurface(orig);
      }
    } else {
#line 18598
      img_starter_bkgd = orig;
    }
  }
  return;
}
}
#line 18607 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void flip_starter(void) 
{ 
  SDL_Surface *orig ;
  int y ;
  SDL_Rect src ;
  SDL_Rect dest ;
  SDL_Surface *__cil_tmp5 ;
  int __cil_tmp6 ;
  SDL_Surface *__cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 18616
  orig = img_starter;
#line 18617
  img_starter = duplicate_surface(orig);
  }
#line 18619
  if (img_starter != (void *)0) {
#line 18621
    y = 0;
    {
#line 18621
    while (1) {
      while_continue: /* CIL Label */ ;
#line 18621
      if (! (y < orig->h)) {
#line 18621
        goto while_break;
      }
      {
#line 18623
      src.x = (Sint16 )0;
#line 18624
      src.y = (Sint16 )y;
#line 18625
      src.w = (Uint16 )orig->w;
#line 18626
      src.h = (Uint16 )1;
#line 18628
      dest.x = (Sint16 )0;
#line 18629
      dest.y = (Sint16 )((orig->h - y) - 1);
#line 18631
      SDL_UpperBlit(orig, & src, img_starter, & dest);
      }
#line 18621
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 18634
    SDL_FreeSurface(orig);
    }
  } else {
#line 18638
    img_starter = orig;
  }
#line 18644
  if (img_starter_bkgd != (void *)0) {
    {
#line 18646
    orig = img_starter_bkgd;
#line 18647
    img_starter_bkgd = duplicate_surface(orig);
    }
#line 18649
    if (img_starter_bkgd != (void *)0) {
#line 18651
      y = 0;
      {
#line 18651
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 18651
        if (! (y < orig->h)) {
#line 18651
          goto while_break___0;
        }
        {
#line 18653
        src.x = (Sint16 )0;
#line 18654
        src.y = (Sint16 )y;
#line 18655
        src.w = (Uint16 )orig->w;
#line 18656
        src.h = (Uint16 )1;
#line 18658
        dest.x = (Sint16 )0;
#line 18659
        dest.y = (Sint16 )((orig->h - y) - 1);
#line 18661
        SDL_UpperBlit(orig, & src, img_starter_bkgd, & dest);
        }
#line 18651
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 18664
      SDL_FreeSurface(orig);
      }
    } else {
#line 18668
      img_starter_bkgd = orig;
    }
  }
  return;
}
}
#line 18677 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int valid_click(Uint8 button ) 
{ 


  {
#line 18679
  if ((int )button == 1) {
#line 18680
    return (1);
  } else
#line 18679
  if ((int )button == 2) {
    _L: /* CIL Label */ 
#line 18679
    if (no_button_distinction) {
#line 18680
      return (1);
    } else {
#line 18682
      return (0);
    }
  } else
#line 18679
  if ((int )button == 3) {
#line 18679
    goto _L;
  } else {
#line 18682
    return (0);
  }
}
}
#line 18689 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int in_circle_rad(int x , int y , int rad ) 
{ 


  {
#line 18691
  if ((x * x + y * y) - rad * rad < 0) {
#line 18692
    return (1);
  } else {
#line 18694
    return (0);
  }
}
}
#line 18701 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int paintsound(int size ) 
{ 


  {
#line 18703
  if (8 + size / 12 >= 11) {
#line 18704
    return (11);
  } else {
#line 18706
    return (8 + size / 12);
  }
}
}
#line 18879 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *load_svg(char const   *file ) 
{ 
  cairo_surface_t *cairo_surf ;
  cairo_t *cr ;
  RsvgHandle *rsvg_handle ;
  GError *gerr ;
  unsigned char *image ;
  int rwidth ;
  int rheight ;
  int width ;
  int height ;
  int stride ;
  float scale ;
  int bpp ;
  int btpp ;
  RsvgDimensionData dimensions ;
  SDL_Surface *sdl_surface ;
  SDL_Surface *sdl_surface_tmp ;
  Uint32 rmask ;
  Uint32 gmask ;
  Uint32 bmask ;
  Uint32 amask ;
  RsvgHandle *__cil_tmp22 ;
  float __cil_tmp23 ;
  void *__cil_tmp24 ;
  cairo_surface_t *__cil_tmp25 ;
  cairo_status_t __cil_tmp26 ;
  cairo_t *__cil_tmp27 ;
  cairo_status_t __cil_tmp28 ;
  SDL_Surface *__cil_tmp29 ;
  SDL_Surface *__cil_tmp30 ;

  {
#line 18889
  bpp = 32;
  {
#line 18889
  btpp = 4;
#line 18900
  gerr = (GError *)((void *)0);
#line 18902
  rsvg_handle = rsvg_handle_new_from_file(file, & gerr);
  }
#line 18903
  if (rsvg_handle == (void *)0) {
#line 18908
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 18911
  rsvg_handle_get_dimensions(rsvg_handle, & dimensions);
#line 18912
  rwidth = dimensions.width;
#line 18913
  rheight = dimensions.height;
#line 18922
  scale = pick_best_scape((unsigned int )rwidth, (unsigned int )rheight, (unsigned int )r_canvas.w,
                          (unsigned int )r_canvas.h);
#line 18928
  width = (int )((float )rwidth * scale);
#line 18929
  height = (int )((float )rheight * scale);
#line 18936
  stride = width * btpp;
#line 18939
  image = (unsigned char *)calloc((unsigned long )(stride * height), (unsigned long )1);
  }
#line 18940
  if (image == (void *)0) {
    {
#line 18945
    g_object_unref(rsvg_handle);
    }
#line 18946
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 18952
  cairo_surf = cairo_image_surface_create_for_data(image, (cairo_format_t )0, width,
                                                   height, stride);
#line 18954
  __cil_tmp26 = cairo_surface_status(cairo_surf);
  }
#line 18954
  if ((unsigned int )__cil_tmp26 != 0U) {
    {
#line 18959
    g_object_unref(rsvg_handle);
#line 18960
    free(image);
    }
#line 18961
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 18967
  cr = cairo_create(cairo_surf);
#line 18968
  __cil_tmp28 = cairo_status(cr);
  }
#line 18968
  if ((unsigned int )__cil_tmp28 != 0U) {
    {
#line 18973
    g_object_unref(rsvg_handle);
#line 18974
    cairo_surface_destroy(cairo_surf);
#line 18975
    free(image);
    }
#line 18976
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 18982
  cairo_scale(cr, (double )scale, (double )scale);
#line 18986
  rsvg_handle_render_cairo(rsvg_handle, cr);
#line 18989
  cairo_surface_finish(cairo_surf);
#line 18994
  rmask = (Uint32 )16711680;
#line 18995
  gmask = (Uint32 )65280;
#line 18996
  bmask = (Uint32 )255;
#line 18997
  amask = 4278190080U;
#line 19000
  sdl_surface_tmp = SDL_CreateRGBSurfaceFrom((void *)image, width, height, bpp, stride,
                                             rmask, gmask, bmask, amask);
  }
#line 19002
  if (sdl_surface_tmp == (void *)0) {
    {
#line 19007
    g_object_unref(rsvg_handle);
#line 19008
    cairo_surface_destroy(cairo_surf);
#line 19009
    free(image);
#line 19010
    cairo_destroy(cr);
    }
#line 19011
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 19015
  sdl_surface = SDL_DisplayFormatAlpha(sdl_surface_tmp);
#line 19016
  SDL_FreeSurface(sdl_surface_tmp);
  }
#line 19018
  if (sdl_surface == (void *)0) {
    {
#line 19023
    g_object_unref(rsvg_handle);
#line 19024
    cairo_surface_destroy(cairo_surf);
#line 19025
    free(image);
#line 19026
    cairo_destroy(cr);
    }
#line 19027
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 19038
  g_object_unref(rsvg_handle);
#line 19039
  cairo_surface_destroy(cairo_surf);
#line 19040
  free(image);
#line 19041
  cairo_destroy(cr);
  }
#line 19043
  return (sdl_surface);
}
}
#line 19052 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static float pick_best_scape(unsigned int orig_w , unsigned int orig_h , unsigned int max_w ,
                             unsigned int max_h ) 
{ 
  float aspect ;
  float scale ;
  float wscale ;
  float hscale ;

  {
#line 19056
  aspect = (float )orig_w / (float )orig_h;
#line 19062
  wscale = (float )max_w / (float )orig_w;
#line 19063
  hscale = (float )max_h / (float )orig_h;
#line 19071
  if (aspect >= (float )1) {
#line 19075
    scale = wscale;
#line 19082
    if ((float )orig_h * scale > (float )max_h) {
#line 19084
      scale = hscale;
    }
  } else {
#line 19096
    scale = hscale;
#line 19103
    if ((float )orig_w * scale > (float )max_w) {
#line 19105
      scale = wscale;
    }
  }
#line 19120
  return (scale);
}
}
#line 19130 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *myIMG_Load_RWops(char const   *file ) 
{ 
  SDL_Surface *surf ;
  FILE *fi ;
  SDL_RWops *data ;
  SDL_Surface *__cil_tmp5 ;
  FILE *__cil_tmp6 ;
  SDL_RWops *__cil_tmp7 ;
  SDL_Surface *__cil_tmp8 ;

  {
  {
#line 19136
  surf = IMG_Load(file);
  }
#line 19137
  if (surf != (void *)0) {
#line 19138
    return (surf);
  }
  {
#line 19141
  fi = fopen(file, "rb");
  }
#line 19142
  if (fi == (void *)0) {
#line 19143
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 19145
  data = SDL_RWFromFP(fi, 1);
  }
#line 19147
  if (data == (void *)0) {
#line 19148
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 19150
  surf = IMG_Load_RW(data, 1);
  }
#line 19151
  if (surf == (void *)0) {
#line 19152
    return ((SDL_Surface *)((void *)0));
  }
#line 19154
  return (surf);
}
}
#line 19164 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *myIMG_Load(char const   *file ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  SDL_Surface *__cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  int __cil_tmp8 ;
  SDL_Surface *__cil_tmp9 ;
  SDL_Surface *__cil_tmp10 ;

  {
  {
#line 19166
  __cil_tmp3 = strlen(file);
#line 19166
  __cil_tmp4 = strcasecmp((file + __cil_tmp3) - 4, ".kpx");
  }
  {
#line 19166
  __cil_tmp2 = strlen(file);
  }
#line 19166
  if (__cil_tmp2 > 4UL) {
#line 19166
    if (__cil_tmp4 == 0) {
      {
#line 19168
      __cil_tmp5 = load_kpx(file);
      }
#line 19168
      return (__cil_tmp5);
    } else {
#line 19166
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 19171
    __cil_tmp7 = strlen(file);
#line 19171
    __cil_tmp8 = strcasecmp((file + __cil_tmp7) - 4, ".svg");
    }
    {
#line 19171
    __cil_tmp6 = strlen(file);
    }
#line 19171
    if (__cil_tmp6 > 4UL) {
#line 19171
      if (__cil_tmp8 == 0) {
        {
#line 19173
        __cil_tmp9 = load_svg(file);
        }
#line 19173
        return (__cil_tmp9);
      } else {
        {
        {
#line 19178
        __cil_tmp10 = myIMG_Load_RWops(file);
        }
        }
#line 19178
        return (__cil_tmp10);
      }
    } else {
      {
      {
#line 19178
      __cil_tmp10 = myIMG_Load_RWops(file);
      }
      }
#line 19178
      return (__cil_tmp10);
    }
  }
}
}
#line 19185 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *load_kpx(char const   *file ) 
{ 
  SDL_RWops *data ;
  FILE *fi ;
  SDL_Surface *surf ;
  int i ;
  FILE *__cil_tmp6 ;
  int __cil_tmp7 ;
  SDL_RWops *__cil_tmp8 ;
  SDL_Surface *__cil_tmp9 ;

  {
  {
#line 19192
  fi = fopen(file, "rb");
  }
#line 19193
  if (fi == (void *)0) {
#line 19194
    return ((SDL_Surface *)((void *)0));
  }
#line 19197
  i = 0;
  {
#line 19197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19197
    if (! (i < 60)) {
#line 19197
      goto while_break;
    }
    {
#line 19198
    fgetc(fi);
    }
#line 19197
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 19200
  data = SDL_RWFromFP(fi, 1);
  }
#line 19202
  if (data == (void *)0) {
#line 19203
    return ((SDL_Surface *)((void *)0));
  }
  {
#line 19205
  surf = IMG_Load_RW(data, 1);
  }
#line 19206
  if (surf == (void *)0) {
#line 19207
    return ((SDL_Surface *)((void *)0));
  }
#line 19209
  return (surf);
}
}
#line 19216 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_magic_plugins(void) 
{ 
  int res ;
  int n ;
  int i ;
  int plc ;
  char *place ;
  int err ;
  DIR *d ;
  struct dirent *f ;
  char fname[512] ;
  char objname[512] ;
  char funcname[512] ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  DIR *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  struct dirent *__cil_tmp21 ;
  struct stat sbuf ;
  int __cil_tmp23 ;
  char *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  Uint32 __cil_tmp42 ;
  Uint32 __cil_tmp43 ;
  int __cil_tmp44 ;
  int __cil_tmp45 ;
  int j ;
  int group ;
  int idx ;
  SDL_Surface *icon_tmp ;
  int __cil_tmp50 ;
  char *__cil_tmp51 ;
  int __cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  int __cil_tmp57 ;
  int __cil_tmp58 ;
  SDL_Surface *__cil_tmp59 ;
  SDL_Surface *__cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  char *__cil_tmp65 ;
  int __cil_tmp66 ;
  int __cil_tmp67 ;

  {
#line 19227
  num_plugin_files = 0;
#line 19228
  i = 0;
  {
#line 19228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19228
    if (! (i < 16)) {
#line 19228
      goto while_break;
    }
#line 19229
    num_magics[i] = 0;
#line 19228
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 19230
  num_magics_total = 0;
#line 19232
  plc = 0;
  {
#line 19232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 19232
    if (! (plc < 2)) {
#line 19232
      goto while_break___0;
    }
#line 19234
    if (plc == 0) {
      {
#line 19235
      place = strdup("/usr/local/lib/tuxpaint/plugins/\220");
      }
    } else
#line 19236
    if (plc == 1) {
      {
#line 19237
      place = get_fname("plugins/\230", 1);
      }
    } else {
#line 19243
      goto while_continue___0;
    }
    {
#line 19253
    d = opendir((char const   *)place);
    }
#line 19255
    if (d != (void *)0) {
      {
#line 19259
      __cil_tmp16 = malloc(sizeof(magic_api ));
#line 19259
      magic_api_struct = (magic_api *)__cil_tmp16;
#line 19260
      magic_api_struct->tp_version = strdup("0.9.27");
      }
#line 19262
      if (plc == 0) {
        {
#line 19263
        magic_api_struct->data_directory = strdup("/usr/local/share/tuxpaint/");
        }
      } else
#line 19264
      if (plc == 1) {
        {
#line 19265
        magic_api_struct->data_directory = get_fname("plugins/data/", 1);
        }
      } else {
        {
#line 19271
        magic_api_struct->data_directory = strdup("./");
        }
      }
#line 19273
      magic_api_struct->update_progress_bar = & update_progress_bar;
#line 19274
      magic_api_struct->sRGB_to_linear = & magic_sRGB_to_linear;
#line 19275
      magic_api_struct->linear_to_sRGB = & magic_linear_to_sRGB;
#line 19276
      magic_api_struct->in_circle = & in_circle_rad;
#line 19277
      magic_api_struct->getpixel = & magic_getpixel;
#line 19278
      magic_api_struct->putpixel = & magic_putpixel;
#line 19279
      magic_api_struct->xorpixel = & magic_xorpixel;
#line 19280
      magic_api_struct->line = & magic_line_func;
#line 19281
      magic_api_struct->playsound = & magic_playsound;
#line 19282
      magic_api_struct->stopsound = & magic_stopsound;
#line 19283
      magic_api_struct->special_notify = & special_notify;
#line 19284
      magic_api_struct->button_down = & magic_button_down;
#line 19285
      magic_api_struct->rgbtohsv = & rgbtohsv;
#line 19286
      magic_api_struct->hsvtorgb = & hsvtorgb;
#line 19287
      magic_api_struct->canvas_w = canvas->w;
#line 19288
      magic_api_struct->canvas_h = canvas->h;
#line 19289
      magic_api_struct->scale = & magic_scale;
#line 19290
      magic_api_struct->touched = & magic_touched;
      {
#line 19293
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 19295
        f = readdir(d);
        }
#line 19297
        if (f != (void *)0) {
          {
#line 19301
          safe_snprintf((char *)fname, sizeof(fname), "%s%s", place, (char *)f->d_name);
#line 19302
          __cil_tmp23 = stat((char const   *)((char *)fname), & sbuf);
          }
#line 19302
          if (! __cil_tmp23) {
#line 19302
            if ((sbuf.st_mode & 61440U) == 32768U) {
              {
#line 19307
              safe_strncpy((char *)objname, (char const   *)((char *)f->d_name), sizeof(objname));
#line 19308
              __cil_tmp24 = strchr((char const   *)((char *)objname), '.');
#line 19308
              strcpy(__cil_tmp24, "\220");
#line 19311
              magic_handle[num_plugin_files] = SDL_LoadObject((char const   *)((char *)fname));
              }
#line 19313
              if (magic_handle[num_plugin_files] != (void *)0) {
                {
#line 19320
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "get_tool_count");
#line 19321
                magic_funcs[num_plugin_files].get_tool_count = (int (*)(magic_api * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                       (char const   *)((char *)funcname));
#line 19324
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "get_group");
#line 19325
                magic_funcs[num_plugin_files].get_group = (int (*)(magic_api * , int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                         (char const   *)((char *)funcname));
#line 19328
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "get_name\220");
#line 19329
                magic_funcs[num_plugin_files].get_name = (char *(*)(magic_api * ,
                                                                    int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                            (char const   *)((char *)funcname));
#line 19332
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "get_icon\220");
#line 19333
                magic_funcs[num_plugin_files].get_icon = (SDL_Surface *(*)(magic_api * ,
                                                                           int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                   (char const   *)((char *)funcname));
#line 19336
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "get_description");
#line 19337
                magic_funcs[num_plugin_files].get_description = (char *(*)(magic_api * ,
                                                                           int  ,
                                                                           int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                   (char const   *)((char *)funcname));
#line 19340
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "requires_colors");
#line 19341
                magic_funcs[num_plugin_files].requires_colors = (int (*)(magic_api * ,
                                                                         int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                 (char const   *)((char *)funcname));
#line 19344
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "modes");
#line 19345
                magic_funcs[num_plugin_files].modes = (int (*)(magic_api * , int  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                     (char const   *)((char *)funcname));
#line 19348
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "set_color");
#line 19349
                magic_funcs[num_plugin_files].set_color = (void (*)(magic_api * ,
                                                                    Uint8  , Uint8  ,
                                                                    Uint8  ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                              (char const   *)((char *)funcname));
#line 19352
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "init");
#line 19353
                magic_funcs[num_plugin_files].init = (int (*)(magic_api * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                             (char const   *)((char *)funcname));
#line 19356
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "api_version");
#line 19357
                magic_funcs[num_plugin_files].api_version = (Uint32 (*)(void))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                               (char const   *)((char *)funcname));
#line 19360
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "shutdown\220");
#line 19361
                magic_funcs[num_plugin_files].shutdown = (void (*)(magic_api * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                  (char const   *)((char *)funcname));
#line 19364
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "click");
#line 19365
                magic_funcs[num_plugin_files].click = (void (*)(magic_api * , int  ,
                                                                int  , SDL_Surface * ,
                                                                SDL_Surface * , int  ,
                                                                int  , SDL_Rect * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                     (char const   *)((char *)funcname));
#line 19368
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "drag");
#line 19369
                magic_funcs[num_plugin_files].drag = (void (*)(magic_api * , int  ,
                                                               SDL_Surface * , SDL_Surface * ,
                                                               int  , int  , int  ,
                                                               int  , SDL_Rect * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                    (char const   *)((char *)funcname));
#line 19372
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "release");
#line 19373
                magic_funcs[num_plugin_files].release = (void (*)(magic_api * , int  ,
                                                                  SDL_Surface * ,
                                                                  SDL_Surface * ,
                                                                  int  , int  , SDL_Rect * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                              (char const   *)((char *)funcname));
#line 19376
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "switchin\220");
#line 19377
                magic_funcs[num_plugin_files].switchin = (void (*)(magic_api * , int  ,
                                                                   int  , SDL_Surface * ,
                                                                   SDL_Surface * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                    (char const   *)((char *)funcname));
#line 19380
                safe_snprintf((char *)funcname, sizeof(funcname), "%s_%s", (char *)objname,
                              "switchout");
#line 19381
                magic_funcs[num_plugin_files].switchout = (void (*)(magic_api * ,
                                                                    int  , int  ,
                                                                    SDL_Surface * ,
                                                                    SDL_Surface * ))SDL_LoadFunction(magic_handle[num_plugin_files],
                                                                                                     (char const   *)((char *)funcname));
#line 19407
                err = 0;
                }
#line 19409
                if (magic_funcs[num_plugin_files].get_tool_count == (void *)0) {
                  {
#line 19411
                  fprintf(stderr, "Error: plugin %s is missing get_tool_count\n",
                          (char *)fname);
#line 19412
                  err = 1;
                  }
                }
#line 19414
                if (magic_funcs[num_plugin_files].get_group == (void *)0) {
                  {
#line 19416
                  fprintf(stderr, "Error: plugin %s is missing get_group\n", (char *)fname);
#line 19417
                  err = 1;
                  }
                }
#line 19419
                if (magic_funcs[num_plugin_files].get_name == (void *)0) {
                  {
#line 19421
                  fprintf(stderr, "Error: plugin %s is missing get_name\n", (char *)fname);
#line 19422
                  err = 1;
                  }
                }
#line 19424
                if (magic_funcs[num_plugin_files].get_icon == (void *)0) {
                  {
#line 19426
                  fprintf(stderr, "Error: plugin %s is missing get_icon\n", (char *)fname);
#line 19427
                  err = 1;
                  }
                }
#line 19429
                if (magic_funcs[num_plugin_files].get_description == (void *)0) {
                  {
#line 19431
                  fprintf(stderr, "Error: plugin %s is missing get_description\n",
                          (char *)fname);
#line 19432
                  err = 1;
                  }
                }
#line 19434
                if (magic_funcs[num_plugin_files].requires_colors == (void *)0) {
                  {
#line 19436
                  fprintf(stderr, "Error: plugin %s is missing requires_colors\n",
                          (char *)fname);
#line 19437
                  err = 1;
                  }
                }
#line 19439
                if (magic_funcs[num_plugin_files].modes == (void *)0) {
                  {
#line 19441
                  fprintf(stderr, "Error: plugin %s is missing modes\n", (char *)fname);
#line 19442
                  err = 1;
                  }
                }
#line 19444
                if (magic_funcs[num_plugin_files].set_color == (void *)0) {
                  {
#line 19446
                  fprintf(stderr, "Error: plugin %s is missing set_color\n", (char *)fname);
#line 19447
                  err = 1;
                  }
                }
#line 19449
                if (magic_funcs[num_plugin_files].init == (void *)0) {
                  {
#line 19451
                  fprintf(stderr, "Error: plugin %s is missing init\n", (char *)fname);
#line 19452
                  err = 1;
                  }
                }
#line 19454
                if (magic_funcs[num_plugin_files].shutdown == (void *)0) {
                  {
#line 19456
                  fprintf(stderr, "Error: plugin %s is missing shutdown\n", (char *)fname);
#line 19457
                  err = 1;
                  }
                }
#line 19459
                if (magic_funcs[num_plugin_files].click == (void *)0) {
                  {
#line 19461
                  fprintf(stderr, "Error: plugin %s is missing click\n", (char *)fname);
#line 19462
                  err = 1;
                  }
                }
#line 19464
                if (magic_funcs[num_plugin_files].release == (void *)0) {
                  {
#line 19466
                  fprintf(stderr, "Error: plugin %s is missing release\n", (char *)fname);
#line 19467
                  err = 1;
                  }
                }
#line 19469
                if (magic_funcs[num_plugin_files].switchin == (void *)0) {
                  {
#line 19471
                  fprintf(stderr, "Error: plugin %s is missing switchin\n", (char *)fname);
#line 19472
                  err = 1;
                  }
                }
#line 19474
                if (magic_funcs[num_plugin_files].switchout == (void *)0) {
                  {
#line 19476
                  fprintf(stderr, "Error: plugin %s is missing switchout\n", (char *)fname);
#line 19477
                  err = 1;
                  }
                }
#line 19479
                if (magic_funcs[num_plugin_files].drag == (void *)0) {
                  {
#line 19481
                  fprintf(stderr, "Error: plugin %s is missing drag\n", (char *)fname);
#line 19482
                  err = 1;
                  }
                }
#line 19485
                if (magic_funcs[num_plugin_files].api_version == (void *)0) {
                  {
#line 19487
                  fprintf(stderr, "Error: plugin %s is missing api_version\n\230\001",
                          (char *)fname);
#line 19488
                  err = 1;
                  }
                } else {
                  {
#line 19490
                  __cil_tmp42 = (*(magic_funcs[num_plugin_files].api_version))();
                  }
#line 19490
                  if (__cil_tmp42 != 5U) {
                    {
#line 19492
                    __cil_tmp43 = (*(magic_funcs[num_plugin_files].api_version))();
#line 19492
                    fprintf(stderr, "Warning: plugin %s uses Tux Paint \'Magic\' tool API version %x,\nbut Tux Paint needs version %x.\n",
                            (char *)fname, __cil_tmp43, 5);
#line 19495
                    err = 1;
                    }
                  }
                }
#line 19498
                if (err) {
                  {
#line 19500
                  SDL_UnloadObject(magic_handle[num_plugin_files]);
                  }
                } else {
                  {
#line 19504
                  res = (*(magic_funcs[num_plugin_files].init))(magic_api_struct);
                  }
#line 19506
                  if (res != 0) {
                    {
#line 19507
                    n = (*(magic_funcs[num_plugin_files].get_tool_count))(magic_api_struct);
                    }
                  } else {
                    {
#line 19510
                    (*(magic_funcs[num_plugin_files].shutdown))(magic_api_struct);
#line 19511
                    n = 0;
                    }
                  }
#line 19515
                  if (n == 0) {
                    {
#line 19517
                    fprintf(stderr, "Error: plugin %s failed to startup or reported 0 magic tools\n",
                            (char *)fname);
#line 19519
                    fflush(stderr);
#line 19520
                    SDL_UnloadObject(magic_handle[num_plugin_files]);
                    }
                  } else {
#line 19527
                    i = 0;
                    {
#line 19527
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 19527
                      if (! (i < n)) {
#line 19527
                        goto while_break___2;
                      }
                      {
#line 19529
                      group = (*(magic_funcs[num_plugin_files].get_group))(magic_api_struct,
                                                                           i);
                      }
#line 19530
                      if (group < 16) {
                        {
#line 19532
                        idx = num_magics[group];
#line 19534
                        magics[group][idx].idx = i;
#line 19535
                        magics[group][idx].place = plc;
#line 19536
                        magics[group][idx].handle_idx = num_plugin_files;
#line 19537
                        magics[group][idx].group = group;
#line 19538
                        magics[group][idx].name = (*(magic_funcs[num_plugin_files].get_name))(magic_api_struct,
                                                                                              i);
#line 19541
                        magics[group][idx].avail_modes = (*(magic_funcs[num_plugin_files].modes))(magic_api_struct,
                                                                                                  i);
#line 19544
                        j = 0;
                        }
                        {
#line 19544
                        while (1) {
                          while_continue___3: /* CIL Label */ ;
#line 19544
                          if (! (j < 2)) {
#line 19544
                            goto while_break___3;
                          }
#line 19546
                          magics[group][idx].tip[j] = (char *)((void *)0);
#line 19547
                          if (j) {
#line 19549
                            if (magics[group][idx].avail_modes & 2) {
                              {
#line 19550
                              magics[group][idx].tip[j] = (*(magic_funcs[num_plugin_files].get_description))(magic_api_struct,
                                                                                                             i,
                                                                                                             2);
                              }
                            }
                          } else
#line 19556
                          if (magics[group][idx].avail_modes & 1) {
                            {
#line 19557
                            magics[group][idx].tip[j] = (*(magic_funcs[num_plugin_files].get_description))(magic_api_struct,
                                                                                                           i,
                                                                                                           1);
                            }
                          } else
#line 19560
                          if (magics[group][idx].avail_modes & 8) {
                            {
#line 19561
                            magics[group][idx].tip[j] = (*(magic_funcs[num_plugin_files].get_description))(magic_api_struct,
                                                                                                           i,
                                                                                                           8);
                            }
                          } else
#line 19564
                          if (magics[group][idx].avail_modes & 4) {
                            {
#line 19565
                            magics[group][idx].tip[j] = (*(magic_funcs[num_plugin_files].get_description))(magic_api_struct,
                                                                                                           i,
                                                                                                           4);
                            }
                          }
#line 19544
                          j ++;
                        }
                        while_break___3: /* CIL Label */ ;
                        }
                        {
#line 19571
                        magics[group][idx].colors = (*(magic_funcs[num_plugin_files].requires_colors))(magic_api_struct,
                                                                                                       i);
                        }
#line 19573
                        if (magics[group][idx].avail_modes & 1) {
#line 19574
                          magics[group][idx].mode = 1;
                        } else
#line 19575
                        if (magics[group][idx].avail_modes & 8) {
#line 19576
                          magics[group][idx].mode = 8;
                        } else
#line 19577
                        if (magics[group][idx].avail_modes & 4) {
#line 19578
                          magics[group][idx].mode = 4;
                        } else {
#line 19580
                          magics[group][idx].mode = 2;
                        }
                        {
#line 19582
                        icon_tmp = (*(magic_funcs[num_plugin_files].get_icon))(magic_api_struct,
                                                                               i);
                        }
#line 19583
                        if (icon_tmp != (void *)0) {
                          {
#line 19585
                          magics[group][idx].img_icon = thumbnail(icon_tmp, (40 * button_w) / 48,
                                                                  (30 * button_h) / 48,
                                                                  1);
#line 19586
                          SDL_FreeSurface(icon_tmp);
#line 19593
                          (num_magics[group]) ++;
#line 19594
                          num_magics_total ++;
                          }
                        } else {
                          {
#line 19598
                          fprintf(stderr, "Error: plugin %s mode # %d failed to load an icon\n",
                                  (char *)fname, i);
#line 19600
                          fflush(stderr);
                          }
                        }
                      } else {
                        {
#line 19605
                        fprintf(stderr, "Error: plugin %s mode # %d reported group %d (higher than %d)\n",
                                (char *)fname, i, group, 15);
#line 19607
                        fflush(stderr);
                        }
                      }
#line 19527
                      i ++;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 19611
                    num_plugin_files ++;
                  }
                }
              } else {
                {
#line 19617
                __cil_tmp65 = SDL_GetError();
#line 19617
                fprintf(stderr, "Warning: Failed to load object %s: %s\n", (char *)fname,
                        __cil_tmp65);
#line 19618
                fflush(stderr);
                }
              }
            }
          }
        }
#line 19293
        if (! (f != (void *)0)) {
#line 19293
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 19625
      closedir(d);
      }
    }
#line 19232
    plc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 19630
  i = 0;
  {
#line 19630
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 19630
    if (! (i < 16)) {
#line 19630
      goto while_break___4;
    }
    {
#line 19631
    qsort((magic_t *)magics[i], (size_t )num_magics[i], sizeof(magic_t ), & magic_sort);
    }
#line 19630
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  return;
}
}
#line 19646 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int magic_sort(void const   *a , void const   *b ) 
{ 
  magic_t *am ;
  magic_t *bm ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 19648
  am = (magic_t *)a;
#line 19649
  bm = (magic_t *)b;
#line 19651
  __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)am->name, 5);
  }
  {
#line 19651
  __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)bm->name, 5);
#line 19651
  __cil_tmp7 = strcoll((char const   *)__cil_tmp5, (char const   *)__cil_tmp6);
  }
#line 19651
  return (__cil_tmp7);
}
}
#line 19658 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void update_progress_bar(void) 
{ 


  {
  {
#line 19660
  show_progress_bar(screen);
  }
  return;
}
}
#line 19666 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_line_func(void *mapi , int which , SDL_Surface *canvas___0 , SDL_Surface *last ,
                            int x1 , int y1___0 , int x2 , int y2 , int step , void (*cb)(void * ,
                                                                                          int  ,
                                                                                          SDL_Surface * ,
                                                                                          SDL_Surface * ,
                                                                                          int  ,
                                                                                          int  ) ) 
{ 
  int dx ;
  int dy ;
  int y ;
  float m ;
  float b ;
  int cnt ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  int __cil_tmp20 ;

  {
#line 19675
  dx = x2 - x1;
#line 19676
  dy = y2 - y1___0;
#line 19678
  cnt = step - 1;
#line 19680
  if (dx != 0) {
#line 19682
    m = (float )dy / (float )dx;
#line 19683
    b = (float )y1___0 - m * (float )x1;
#line 19685
    if (x2 >= x1) {
#line 19686
      dx = 1;
    } else {
#line 19688
      dx = - 1;
    }
    {
#line 19691
    while (1) {
      while_continue: /* CIL Label */ ;
#line 19691
      if (! (x1 != x2)) {
#line 19691
        goto while_break;
      }
#line 19693
      y1___0 = (int )(m * (float )x1 + b);
#line 19694
      y2 = (int )(m * (float )(x1 + dx) + b);
#line 19696
      if (y1___0 > y2) {
#line 19698
        y = y1___0;
        {
#line 19698
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 19698
          if (! (y >= y2)) {
#line 19698
            goto while_break___0;
          }
#line 19700
          cnt = (cnt + 1) % step;
#line 19701
          if (cnt == 0) {
            {
#line 19702
            (*cb)((void *)mapi, which, canvas___0, last, x1, y);
            }
          }
#line 19698
          __cil_tmp17 = y;
#line 19698
          y --;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 19707
        y = y1___0;
        {
#line 19707
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 19707
          if (! (y <= y2)) {
#line 19707
            goto while_break___1;
          }
#line 19709
          cnt = (cnt + 1) % step;
#line 19710
          if (cnt == 0) {
            {
#line 19711
            (*cb)((void *)mapi, which, canvas___0, last, x1, y);
            }
          }
#line 19707
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 19715
      x1 += dx;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 19720
  if (y1___0 > y2) {
#line 19722
    y = y1___0;
    {
#line 19722
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 19722
      if (! (y >= y2)) {
#line 19722
        goto while_break___2;
      }
#line 19724
      cnt = (cnt + 1) % step;
#line 19725
      if (cnt == 0) {
        {
#line 19726
        (*cb)((void *)mapi, which, canvas___0, last, x1, y);
        }
      }
#line 19722
      __cil_tmp19 = y;
#line 19722
      y --;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 19731
    y = y1___0;
    {
#line 19731
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 19731
      if (! (y <= y2)) {
#line 19731
        goto while_break___3;
      }
#line 19733
      cnt = (cnt + 1) % step;
#line 19734
      if (cnt == 0) {
        {
#line 19735
        (*cb)((void *)mapi, which, canvas___0, last, x1, y);
        }
      }
#line 19731
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 19749 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void special_notify(int flags ) 
{ 
  int tmp_int ;

  {
#line 19753
  tmp_int = cur_undo - 1;
#line 19754
  if (tmp_int < 0) {
#line 19755
    tmp_int = 19;
  }
#line 19757
  if (flags & 1) {
#line 19761
    starter_mirrored = ! starter_mirrored;
#line 19763
    if (img_starter != (void *)0) {
      {
#line 19764
      mirror_starter();
      }
    }
#line 19766
    undo_starters[tmp_int] = 1;
  }
#line 19769
  if (flags & 2) {
#line 19773
    starter_flipped = ! starter_flipped;
#line 19775
    if (img_starter != (void *)0) {
      {
#line 19776
      flip_starter();
      }
    }
#line 19778
    undo_starters[tmp_int] = 2;
  }
  return;
}
}
#line 19785 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_stopsound(void) 
{ 


  {
#line 19788
  if (mute) {
#line 19789
    return;
  } else
#line 19788
  if (! use_sound) {
#line 19789
    return;
  }
  {
#line 19791
  Mix_HaltChannel(0);
  }
  return;
}
}
#line 19798 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_playsound(Mix_Chunk *snd , int left_right , int up_down ) 
{ 
  int left ;
  int dist ;
  int __cil_tmp6 ;

  {
#line 19808
  if (snd == (void *)0) {
#line 19809
    return;
  } else
#line 19808
  if (mute) {
#line 19809
    return;
  } else
#line 19808
  if (! use_sound) {
#line 19809
    return;
  }
  {
#line 19814
  __cil_tmp6 = Mix_Playing(0);
  }
#line 19814
  if (magic_current_snd_ptr != snd) {
    {
    {
#line 19815
    Mix_PlayChannelTimed(0, snd, 0, - 1);
    }
    }
  } else
#line 19814
  if (! __cil_tmp6) {
    {
    {
#line 19815
    Mix_PlayChannelTimed(0, snd, 0, - 1);
    }
    }
  }
#line 19817
  magic_current_snd_ptr = snd;
#line 19822
  if (up_down < 0) {
#line 19823
    up_down = 0;
  } else
#line 19824
  if (up_down > 255) {
#line 19825
    up_down = 255;
  }
#line 19827
  dist = 255 - up_down;
#line 19829
  if (left_right < 0) {
#line 19830
    left_right = 0;
  } else
#line 19831
  if (left_right > 255) {
#line 19832
    left_right = 255;
  }
#line 19834
  if (use_stereo) {
#line 19836
    left = ((255 - dist) * (255 - left_right)) / 255;
  } else {
#line 19841
    left = (255 - dist) / 2;
  }
  {
#line 19844
  Mix_SetPanning(0, (Uint8 )left, (Uint8 )((255 - dist) - left));
  }
  return;
}
}
#line 19851 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint8 magic_linear_to_sRGB(float lin ) 
{ 
  unsigned char __cil_tmp2 ;

  {
  {
#line 19853
  __cil_tmp2 = linear_to_sRGB(lin);
  }
#line 19853
  return (__cil_tmp2);
}
}
#line 19859 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static float magic_sRGB_to_linear(Uint8 srgb ) 
{ 


  {
#line 19861
  return (sRGB_to_linear_table___1[srgb]);
}
}
#line 19867 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int magic_button_down(void) 
{ 


  {
#line 19869
  return (button_down || emulate_button_pressed);
}
}
#line 19875 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static SDL_Surface *magic_scale(SDL_Surface *surf , int w , int h , int aspect ) 
{ 
  SDL_Surface *__cil_tmp5 ;

  {
  {
#line 19877
  __cil_tmp5 = thumbnail2(surf, w, h, aspect, 1);
  }
#line 19877
  return (__cil_tmp5);
}
}
#line 19884 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_new_dialog(void) 
{ 
  SDL_Surface *img ;
  SDL_Surface *img1 ;
  SDL_Surface *img2 ;
  int things_alloced ;
  SDL_Surface **thumbs ;
  DIR *d ;
  struct dirent *f ;
  struct dirent2 *fs ;
  struct stat sbuf ;
  int place ;
  char *dirname___253[5] ;
  char **d_names ;
  char **d_exts ;
  int *d_places ;
  FILE *fi ;
  char fname[1024] ;
  int num_files ;
  int i ;
  int done ;
  int update_list ;
  int cur ;
  int which ;
  int num_files_in_dirs ;
  int j ;
  SDL_Rect dest ;
  SDL_Event event ;
  SDLKey key ;
  Uint32 last_click_time ;
  int last_click_which ;
  int last_click_button ;
  int places_to_look ;
  int tot ;
  int first_color ;
  int first_starter ;
  int first_template ;
  int white_in_palette ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  int skip ;
  int k ;
  void *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  DIR *__cil_tmp50 ;
  struct dirent *__cil_tmp51 ;
  int __cil_tmp52 ;
  int __cil_tmp53 ;
  void *__cil_tmp54 ;
  int __cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  int __cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  struct dirent *f2 ;
  char fname2[1024] ;
  char *__cil_tmp90 ;
  unsigned long __cil_tmp91 ;
  unsigned long __cil_tmp92 ;
  unsigned long __cil_tmp93 ;
  char *__cil_tmp94 ;
  int __cil_tmp95 ;
  char *__cil_tmp96 ;
  SDL_Surface *__cil_tmp97 ;
  SDL_Surface *__cil_tmp98 ;
  SDL_Surface *__cil_tmp99 ;
  SDL_Surface *__cil_tmp100 ;
  int __cil_tmp101 ;
  int __cil_tmp102 ;
  SDL_Surface *__cil_tmp103 ;
  SDL_Surface *__cil_tmp104 ;
  SDL_Surface *__cil_tmp105 ;
  SDL_Surface *__cil_tmp106 ;
  SDL_Surface *__cil_tmp107 ;
  char *__cil_tmp108 ;
  SDL_Surface *__cil_tmp109 ;
  SDL_Surface *__cil_tmp110 ;
  SDL_Surface *__cil_tmp111 ;
  int __cil_tmp112 ;
  int __cil_tmp113 ;
  int __cil_tmp114 ;
  int __cil_tmp115 ;
  FILE *__cil_tmp116 ;
  int *__cil_tmp117 ;
  char *__cil_tmp118 ;
  int __cil_tmp119 ;
  int __cil_tmp120 ;
  int __cil_tmp121 ;
  int __cil_tmp122 ;
  int __cil_tmp123 ;
  int __cil_tmp124 ;
  int __cil_tmp125 ;
  int __cil_tmp126 ;
  Uint32 __cil_tmp127 ;
  Uint32 __cil_tmp128 ;
  int __cil_tmp129 ;
  SDL_Surface *__cil_tmp130 ;
  char *__cil_tmp131 ;
  SDL_Surface *__cil_tmp132 ;
  char *__cil_tmp133 ;
  int __cil_tmp134 ;
  int __cil_tmp135 ;
  int __cil_tmp136 ;

  {
#line 19888
  thumbs = (SDL_Surface **)((void *)0);
#line 19895
  d_names = (char **)((void *)0);
  {
#line 19895
  d_exts = (char **)((void *)0);
#line 19914
  motioner = 0;
#line 19914
  val_y = motioner;
#line 19914
  val_x = val_y;
#line 19915
  hatmotioner = 0;
#line 19915
  valhat_y = hatmotioner;
#line 19915
  valhat_x = valhat_y;
#line 19916
  do_setcursor(cursor_watch);
#line 19920
  things_alloced = 32;
#line 19922
  __cil_tmp45 = malloc(sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 19922
  fs = (struct dirent2 *)__cil_tmp45;
#line 19924
  num_files = 0;
#line 19925
  cur = 0;
#line 19926
  which = 0;
#line 19927
  num_files_in_dirs = 0;
#line 19932
  places_to_look = 0;
  }
  {
#line 19932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19932
    if (! (places_to_look < 5)) {
#line 19932
      goto while_break;
    }
#line 19934
    if (places_to_look == 0) {
#line 19937
      dirname___253[places_to_look] = (char *)((void *)0);
#line 19938
      goto while_continue;
    } else
#line 19940
    if (places_to_look == 1) {
      {
#line 19944
      dirname___253[places_to_look] = get_fname("starters\230", 1);
      }
    } else
#line 19946
    if (places_to_look == 2) {
      {
#line 19951
      dirname___253[places_to_look] = strdup("/usr/local/share/tuxpaint/starters");
      }
    } else
#line 19953
    if (places_to_look == 3) {
      {
#line 19957
      dirname___253[places_to_look] = get_fname("templates", 1);
      }
    } else
#line 19959
    if (places_to_look == 4) {
      {
#line 19963
      dirname___253[places_to_look] = strdup("/usr/local/share/tuxpaint/templates");
      }
    }
    {
#line 19969
    d = opendir((char const   *)dirname___253[places_to_look]);
    }
#line 19971
    if (d != (void *)0) {
      {
#line 19975
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 19977
        f = readdir(d);
        }
#line 19979
        if (f != (void *)0) {
          {
#line 19981
          safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___253[places_to_look],
                        (char *)f->d_name);
#line 19982
          __cil_tmp52 = stat((char const   *)((char *)fname), & sbuf);
          }
#line 19982
          if (! __cil_tmp52) {
#line 19982
            if ((sbuf.st_mode & 61440U) == 32768U) {
              {
#line 19984
              memcpy(& (fs + num_files_in_dirs)->f, f, sizeof(struct dirent ));
#line 19985
              (fs + num_files_in_dirs)->place = places_to_look;
#line 19987
              num_files_in_dirs ++;
              }
#line 19989
              if (num_files_in_dirs >= things_alloced) {
                {
#line 19991
                things_alloced += 32;
#line 19993
                __cil_tmp54 = realloc(fs, sizeof(struct dirent2 ) * (unsigned long )things_alloced);
#line 19993
                fs = (struct dirent2 *)__cil_tmp54;
                }
              }
            }
          }
        }
#line 19975
        if (! (f != (void *)0)) {
#line 19975
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 20000
      closedir(d);
      }
    }
#line 19932
    places_to_look ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 20006
  tot = num_files_in_dirs;
#line 20009
  tot += NUM_COLORS;
#line 20011
  __cil_tmp56 = malloc(sizeof(SDL_Surface *) * (unsigned long )tot);
#line 20011
  thumbs = (SDL_Surface **)__cil_tmp56;
#line 20012
  __cil_tmp57 = malloc(sizeof(int ) * (unsigned long )tot);
#line 20012
  d_places = (int *)__cil_tmp57;
#line 20013
  __cil_tmp58 = malloc(sizeof(char *) * (unsigned long )tot);
#line 20013
  d_names = (char **)__cil_tmp58;
#line 20014
  __cil_tmp59 = malloc(sizeof(char *) * (unsigned long )tot);
#line 20014
  d_exts = (char **)__cil_tmp59;
#line 20019
  qsort(fs, (size_t )num_files_in_dirs, sizeof(struct dirent2 ), (int (*)(void const   * ,
                                                                          void const   * ))(& compare_dirent2s));
#line 20024
  white_in_palette = - 1;
  }
#line 20026
  if (! new_colors_last) {
    {
#line 20028
    first_color = 0;
#line 20029
    num_files = do_new_dialog_add_colors(thumbs, num_files, d_places, d_names, d_exts,
                                         & white_in_palette);
    }
  }
#line 20032
  first_starter = num_files;
#line 20033
  first_template = - 1;
#line 20038
  j = 0;
  {
#line 20038
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 20038
    if (! (j < num_files_in_dirs)) {
#line 20038
      goto while_break___1;
    }
#line 20040
    f = & (fs + j)->f;
#line 20041
    place = (fs + j)->place;
#line 20043
    if (place == 3) {
      _L: /* CIL Label */ 
#line 20043
      if (first_template == -1) {
#line 20044
        first_template = num_files;
      }
    } else
#line 20043
    if (place == 4) {
#line 20043
      goto _L;
    }
    {
#line 20046
    show_progress_bar(screen);
    }
#line 20048
    if (f != (void *)0) {
      {
#line 20050
      debug((char const   *)((char *)f->d_name));
#line 20052
      __cil_tmp62 = strcasestr((char const   *)((char *)f->d_name), "-back.");
      }
      {
#line 20052
      __cil_tmp61 = strcasestr((char const   *)((char *)f->d_name), "-t.");
      }
#line 20052
      if (__cil_tmp61 == (void *)0) {
#line 20052
        if (__cil_tmp62 == (void *)0) {
          {
#line 20054
          __cil_tmp67 = strcasestr((char const   *)((char *)f->d_name), ".svg");
          }
          {
#line 20054
          __cil_tmp66 = strcasestr((char const   *)((char *)f->d_name), ".jpg");
          }
          {
#line 20054
          __cil_tmp65 = strcasestr((char const   *)((char *)f->d_name), ".kpx");
          }
          {
#line 20054
          __cil_tmp64 = strcasestr((char const   *)((char *)f->d_name), ".bmp");
          }
          {
#line 20054
          __cil_tmp63 = strcasestr((char const   *)((char *)f->d_name), ".png");
          }
#line 20054
          if (__cil_tmp63 != (void *)0) {
            _L___257: /* CIL Label */ 
            _L___258: /* CIL Label */ 
            _L___259: /* CIL Label */ 
            _L___260: /* CIL Label */ 
            {
#line 20065
            safe_strncpy((char *)fname, (char const   *)((char *)f->d_name), sizeof(fname));
#line 20066
            skip = 0;
#line 20068
            __cil_tmp68 = strcasestr((char const   *)((char *)fname), ".png");
            }
#line 20068
            if (__cil_tmp68 != (void *)0) {
              {
#line 20070
              __cil_tmp69 = strcasestr((char const   *)((char *)fname), ".png");
#line 20070
              __cil_tmp70 = strdup((char const   *)__cil_tmp69);
#line 20070
              *(d_exts + num_files) = __cil_tmp70;
#line 20071
              __cil_tmp71 = strcasestr((char const   *)((char *)fname), ".png");
#line 20071
              strcpy((char *)__cil_tmp71, "\220");
              }
            }
            {
#line 20074
            __cil_tmp72 = strcasestr((char const   *)((char *)fname), ".bmp");
            }
#line 20074
            if (__cil_tmp72 != (void *)0) {
              {
#line 20076
              __cil_tmp73 = strcasestr((char const   *)((char *)fname), ".bmp");
#line 20076
              __cil_tmp74 = strdup((char const   *)__cil_tmp73);
#line 20076
              *(d_exts + num_files) = __cil_tmp74;
#line 20077
              __cil_tmp75 = strcasestr((char const   *)((char *)fname), ".bmp");
#line 20077
              strcpy((char *)__cil_tmp75, "\220");
              }
            }
            {
#line 20081
            __cil_tmp76 = strcasestr((char const   *)((char *)fname), ".svg");
            }
#line 20081
            if (__cil_tmp76 != (void *)0) {
              {
#line 20083
              __cil_tmp77 = strcasestr((char const   *)((char *)fname), ".svg");
#line 20083
              __cil_tmp78 = strdup((char const   *)__cil_tmp77);
#line 20083
              *(d_exts + num_files) = __cil_tmp78;
#line 20084
              __cil_tmp79 = strcasestr((char const   *)((char *)fname), ".svg");
#line 20084
              strcpy((char *)__cil_tmp79, "\220");
              }
            }
            {
#line 20088
            __cil_tmp80 = strcasestr((char const   *)((char *)fname), ".kpx");
            }
#line 20088
            if (__cil_tmp80 != (void *)0) {
              {
#line 20090
              __cil_tmp81 = strcasestr((char const   *)((char *)fname), ".kpx");
#line 20090
              __cil_tmp82 = strdup((char const   *)__cil_tmp81);
#line 20090
              *(d_exts + num_files) = __cil_tmp82;
#line 20091
              __cil_tmp83 = strcasestr((char const   *)((char *)fname), ".kpx");
#line 20091
              strcpy((char *)__cil_tmp83, "\220");
              }
            }
            {
#line 20094
            __cil_tmp84 = strcasestr((char const   *)((char *)fname), ".jpg");
            }
#line 20094
            if (__cil_tmp84 != (void *)0) {
              {
#line 20096
              __cil_tmp85 = strcasestr((char const   *)((char *)fname), ".jpg");
#line 20096
              __cil_tmp86 = strdup((char const   *)__cil_tmp85);
#line 20096
              *(d_exts + num_files) = __cil_tmp86;
#line 20097
              __cil_tmp87 = strcasestr((char const   *)((char *)fname), ".jpg");
#line 20097
              strcpy((char *)__cil_tmp87, "\220");
              }
            }
#line 20102
            k = 0;
            {
#line 20102
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 20102
              if (! (k < num_files_in_dirs)) {
#line 20102
                goto while_break___2;
              }
#line 20104
              if (k != j) {
                {
#line 20109
                f2 = & (fs + k)->f;
#line 20110
                safe_strncpy((char *)fname2, (char const   *)((char *)f2->d_name),
                             sizeof(fname2));
#line 20112
                __cil_tmp94 = strcasestr((char const   *)((char *)fname2), ".svg");
                }
                {
#line 20112
                __cil_tmp93 = strlen(".svg");
                }
                {
#line 20112
                __cil_tmp92 = strlen((char const   *)((char *)fname2));
                }
                {
#line 20112
                __cil_tmp91 = strlen((char const   *)((char *)fname));
                }
                {
#line 20112
                __cil_tmp90 = strstr((char const   *)((char *)fname2), (char const   *)((char *)fname));
                }
#line 20112
                if (__cil_tmp90 == (char *)fname2) {
#line 20112
                  if (__cil_tmp91 == __cil_tmp92 - __cil_tmp93) {
#line 20112
                    if (__cil_tmp94 != (void *)0) {
#line 20115
                      skip = 1;
                    }
                  }
                }
              }
#line 20102
              k ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 20120
            if (skip) {
              {
#line 20122
              free(*(d_exts + num_files));
              }
            } else {
              {
#line 20126
              *(d_names + num_files) = strdup((char const   *)((char *)fname));
#line 20127
              *(d_places + num_files) = place;
#line 20132
              safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png", dirname___253[*(d_places + num_files)],
                            *(d_names + num_files));
#line 20134
              debug((char const   *)((char *)fname));
#line 20135
              img = IMG_Load((char const   *)((char *)fname));
              }
#line 20137
              if (img == (void *)0) {
                {
#line 20142
                safe_snprintf((char *)fname, sizeof(fname), "%s/%s-t.png", dirname___253[*(d_places + num_files)],
                              *(d_names + num_files));
#line 20144
                debug((char const   *)((char *)fname));
#line 20146
                img = IMG_Load((char const   *)((char *)fname));
                }
              }
#line 20149
              if (img != (void *)0) {
                {
#line 20152
                show_progress_bar(screen);
#line 20154
                img1 = SDL_DisplayFormat(img);
#line 20155
                SDL_FreeSurface(img);
                }
#line 20160
                if (img1->w > ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
                  {
                  {
                  {
#line 20163
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 20164
                  SDL_FreeSurface(img1);
                  }
                  }
#line 20165
                  img1 = img2;
                  }
                } else
#line 20160
                if (img1->h > (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                  {
                  {
                  {
#line 20163
                  img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                   (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                   0);
                  }
                  }
                  {
                  {
#line 20164
                  SDL_FreeSurface(img1);
                  }
                  }
#line 20165
                  img1 = img2;
                  }
                } else
#line 20160
                if (img1->w < ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) {
#line 20160
                  if (img1->h < (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) {
                    {
                    {
                    {
#line 20163
                    img2 = thumbnail(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                     (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                     0);
                    }
                    }
                    {
                    {
#line 20164
                    SDL_FreeSurface(img1);
                    }
                    }
#line 20165
                    img1 = img2;
                    }
                  }
                }
#line 20168
                *(thumbs + num_files) = img1;
#line 20170
                if (*(thumbs + num_files) == (void *)0) {
                  {
#line 20172
                  fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\n",
                          (char *)fname);
                  }
                }
#line 20176
                num_files ++;
              } else {
#line 20182
                if (*(d_places + num_files) == 3) {
                  _L___254: /* CIL Label */ 
                  {
#line 20186
                  __cil_tmp102 = make_directory(0, (char const   *)dirname___253[*(d_places + num_files)],
                                                "Can\'t create user data directory (for starters/templates) (E010)\220");
                  }
#line 20186
                  if (__cil_tmp102) {
                    {
#line 20189
                    safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs", dirname___253[*(d_places + num_files)]);
#line 20190
                    make_directory(0, (char const   *)((char *)fname), "Can\'t create user data thumbnail directory (for starters/templates) (E011)");
                    }
                  }
                } else
#line 20182
                if (*(d_places + num_files) == 1) {
#line 20182
                  goto _L___254;
                }
#line 20194
                img = (SDL_Surface *)((void *)0);
#line 20196
                if (*(d_places + num_files) == 2) {
                  _L___255: /* CIL Label */ 
                  {
#line 20204
                  safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back", dirname___253[*(d_places + num_files)],
                                *(d_names + num_files));
#line 20206
                  img = load_starter_helper((char *)fname, "jpeg", & IMG_Load);
                  }
#line 20207
                  if (img == (void *)0) {
                    {
#line 20209
                    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back", dirname___253[*(d_places + num_files)],
                                  *(d_names + num_files));
#line 20211
                    img = load_starter_helper((char *)fname, "jpg", & IMG_Load);
                    }
                  }
#line 20215
                  if (img == (void *)0) {
                    {
#line 20218
                    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back", dirname___253[*(d_places + num_files)],
                                  *(d_names + num_files));
#line 20220
                    img = load_starter_helper((char *)fname, "svg", & load_svg);
                    }
                  }
#line 20224
                  if (img == (void *)0) {
                    {
#line 20227
                    safe_snprintf((char *)fname, sizeof(fname), "%s/%s-back", dirname___253[*(d_places + num_files)],
                                  *(d_names + num_files));
#line 20229
                    img = load_starter_helper((char *)fname, "png", & IMG_Load);
                    }
                  }
                } else
#line 20196
                if (*(d_places + num_files) == 1) {
#line 20196
                  goto _L___255;
                }
#line 20233
                if (img == (void *)0) {
                  {
#line 20238
                  safe_snprintf((char *)fname, sizeof(fname), "%s/%s", dirname___253[*(d_places + num_files)],
                                (char *)f->d_name);
#line 20239
                  debug((char const   *)((char *)fname));
#line 20240
                  img = myIMG_Load((char const   *)((char *)fname));
                  }
                }
                {
#line 20244
                show_progress_bar(screen);
                }
#line 20246
                if (img == (void *)0) {
                  {
#line 20248
                  __cil_tmp108 = SDL_GetError();
#line 20248
                  fprintf(stderr, "\nWarning: I can\'t open one of the saved files!\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
                          (char *)fname, __cil_tmp108);
#line 20254
                  free(*(d_names + num_files));
#line 20255
                  free(*(d_exts + num_files));
                  }
                } else {
                  {
#line 20261
                  img1 = SDL_DisplayFormatAlpha(img);
#line 20262
                  img2 = thumbnail2(img1, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                    (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                    0, 0);
#line 20263
                  SDL_FreeSurface(img1);
#line 20265
                  show_progress_bar(screen);
#line 20267
                  *(thumbs + num_files) = SDL_DisplayFormat(img2);
#line 20268
                  SDL_FreeSurface(img2);
                  }
#line 20269
                  if (*(thumbs + num_files) == (void *)0) {
                    {
#line 20271
                    fprintf(stderr, "\nError: Couldn\'t create a thumbnail of saved image!\n%s\n",
                            (char *)fname);
                    }
                  }
                  {
#line 20275
                  SDL_FreeSurface(img);
#line 20277
                  show_progress_bar(screen);
                  }
#line 20284
                  if (*(d_places + num_files) == 1) {
                    _L___256: /* CIL Label */ 
                    {
#line 20287
                    debug("Saving thumbnail for this one!");
#line 20289
                    safe_snprintf((char *)fname, sizeof(fname), "%s/.thumbs/%s-t.png",
                                  dirname___253[*(d_places + num_files)], *(d_names + num_files));
#line 20292
                    __cil_tmp115 = make_directory(0, "templates/.thumbs", "Can\'t create user data directory (for templates) (E015)");
                    }
                    {
#line 20292
                    __cil_tmp114 = make_directory(0, "starters/.thumbs\323\001 ",
                                                  "Can\'t create user data directory (for starters) (E014)");
                    }
                    {
#line 20292
                    __cil_tmp113 = make_directory(0, "templates", "Can\'t create user data directory (for templates) (E013)");
                    }
                    {
#line 20292
                    __cil_tmp112 = make_directory(0, "starters\323\001 ", "Can\'t create user data directory (for starters) (E012)");
                    }
#line 20292
                    if (! __cil_tmp112) {
                      {
                      {
                      {
                      {
#line 20296
                      fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
                      }
                      }
                      }
                      }
                    } else
#line 20292
                    if (! __cil_tmp113) {
                      {
                      {
                      {
                      {
#line 20296
                      fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
                      }
                      }
                      }
                      }
                    } else
#line 20292
                    if (! __cil_tmp114) {
                      {
                      {
                      {
                      {
#line 20296
                      fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
                      }
                      }
                      }
                      }
                    } else
#line 20292
                    if (! __cil_tmp115) {
                      {
                      {
                      {
                      {
#line 20296
                      fprintf(stderr, "Cannot save any pictures! SORRY!\n\n");
                      }
                      }
                      }
                      }
                    } else {
                      {
#line 20299
                      fi = fopen((char const   *)((char *)fname), "wb");
                      }
#line 20300
                      if (fi == (void *)0) {
                        {
#line 20302
                        __cil_tmp117 = __errno_location();
#line 20302
                        __cil_tmp118 = strerror(*__cil_tmp117);
#line 20302
                        fprintf(stderr, "\nError: Couldn\'t save thumbnail of saved image!\n%s\nThe error that occurred was:\n%s\n\n",
                                (char *)fname, __cil_tmp118);
                        }
                      } else {
                        {
#line 20310
                        do_png_save(fi, (char const   *)((char *)fname), *(thumbs + num_files),
                                    0);
                        }
                      }
                    }
                    {
#line 20314
                    show_progress_bar(screen);
                    }
                  } else
#line 20284
                  if (*(d_places + num_files) == 3) {
#line 20284
                    goto _L___256;
                  }
#line 20318
                  num_files ++;
                }
              }
            }
          } else
#line 20054
          if (__cil_tmp64 != (void *)0) {
#line 20054
            goto _L___257;
          } else
#line 20054
          if (__cil_tmp65 != (void *)0) {
#line 20054
            goto _L___257;
          } else
#line 20054
          if (__cil_tmp66 != (void *)0) {
#line 20054
            goto _L___257;
          } else
#line 20054
          if (__cil_tmp67 != (void *)0) {
#line 20054
            goto _L___257;
          }
        }
      }
    }
#line 20038
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 20334
  if (new_colors_last) {
    {
#line 20336
    first_color = num_files;
#line 20337
    num_files = do_new_dialog_add_colors(thumbs, num_files, d_places, d_names, d_exts,
                                         & white_in_palette);
    }
  }
  {
#line 20351
  draw_tux_text(2, tool_tips[11], 1);
#line 20356
  update_list = 1;
#line 20358
  done = 0;
#line 20360
  last_click_which = - 1;
#line 20361
  last_click_time = (Uint32 )0;
#line 20362
  last_click_button = - 1;
#line 20365
  do_setcursor(cursor_arrow);
  }
  {
#line 20368
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 20372
    if (update_list) {
      {
#line 20376
      dest.x = (Sint16 )r_ttools.w;
#line 20377
      dest.y = (Sint16 )0;
#line 20378
      dest.w = (Uint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w);
#line 20379
      dest.h = (Uint16 )(button_h * buttons_tall + (int )r_ttools.h);
#line 20381
      SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 20386
      i = cur;
      }
      {
#line 20386
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 20386
        if (! (i < cur + 16 && i < num_files)) {
#line 20386
          goto while_break___4;
        }
#line 20390
        dest.x = (Sint16 )((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w);
#line 20391
        dest.y = (Sint16 )(((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h);
#line 20393
        if (*(d_places + i) == 0) {
#line 20395
          if (i == which) {
            {
#line 20397
            SDL_UpperBlit(img_cursor_down, (SDL_Rect *)((void *)0), screen, & dest);
#line 20398
            debug((char const   *)*(d_names + i));
            }
          } else {
            {
#line 20401
            SDL_UpperBlit(img_cursor_up, (SDL_Rect *)((void *)0), screen, & dest);
            }
          }
        } else
#line 20405
        if (i == which) {
          {
#line 20407
          SDL_UpperBlit(img_cursor_starter_down, (SDL_Rect *)((void *)0), screen,
                        & dest);
#line 20408
          debug((char const   *)*(d_names + i));
          }
        } else {
          {
#line 20411
          SDL_UpperBlit(img_cursor_starter_up, (SDL_Rect *)((void *)0), screen, & dest);
          }
        }
#line 20416
        dest.x = (Sint16 )((((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) * ((i - cur) % 4) + (int )r_ttools.w) + 10) + ((((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20) - (*(thumbs + i))->w) / 2);
#line 20417
        dest.y = (Sint16 )(((((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4) * ((i - cur) / 4) + img_scroll_up->h) + 10) + (((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20) - (*(thumbs + i))->h) / 2);
#line 20419
        if (*(thumbs + i) != (void *)0) {
          {
#line 20420
          SDL_UpperBlit(*(thumbs + i), (SDL_Rect *)((void *)0), screen, & dest);
          }
        }
#line 20386
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 20426
      dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 20427
      dest.y = (Sint16 )0;
#line 20429
      if (cur > 0) {
        {
#line 20430
        SDL_UpperBlit(img_scroll_up, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 20432
        SDL_UpperBlit(img_scroll_up_off, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
#line 20434
      dest.x = (Sint16 )((WINDOW_WIDTH - img_scroll_up->w) / 2);
#line 20435
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 20437
      if (cur < num_files - 16) {
        {
#line 20438
        SDL_UpperBlit(img_scroll_down, (SDL_Rect *)((void *)0), screen, & dest);
        }
      } else {
        {
#line 20440
        SDL_UpperBlit(img_scroll_down_off, (SDL_Rect *)((void *)0), screen, & dest);
        }
      }
      {
#line 20445
      dest.x = (Sint16 )r_ttools.w;
#line 20446
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 20447
      SDL_UpperBlit(img_open, (SDL_Rect *)((void *)0), screen, & dest);
#line 20449
      dest.x = (Sint16 )((int )r_ttools.w + (button_w - img_openlabels_open->w) / 2);
#line 20450
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_open->h);
#line 20451
      SDL_UpperBlit(img_openlabels_open, (SDL_Rect *)((void *)0), screen, & dest);
#line 20456
      dest.x = (Sint16 )((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w);
#line 20457
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - button_h);
#line 20458
      SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 20460
      dest.x = (Sint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) + (button_w - img_openlabels_back->w) / 2);
#line 20461
      dest.y = (Sint16 )((button_h * buttons_tall + (int )r_ttools.h) - img_openlabels_back->h);
#line 20462
      SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 20465
      SDL_Flip(screen);
#line 20467
      update_list = 0;
      }
    }
    {
#line 20472
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 20472
      __cil_tmp123 = SDL_PollEvent(& event);
      }
#line 20472
      if (! __cil_tmp123) {
#line 20472
        goto while_break___5;
      }
#line 20474
      if ((int )event.type == 12) {
#line 20476
        done = 1;
      } else
#line 20480
      if ((int )event.type == 1) {
        {
#line 20482
        handle_active(& event);
        }
      } else
#line 20484
      if ((int )event.type == 3) {
        {
#line 20486
        key = event.key.keysym.sym;
#line 20488
        handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 20490
      if ((int )event.type == 2) {
        {
#line 20492
        key = event.key.keysym.sym;
#line 20494
        handle_keymouse(key, (Uint8 )2, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
#line 20498
        if ((unsigned int )key == 292U) {
#line 20500
          if (which > 0) {
#line 20502
            __cil_tmp124 = which;
#line 20502
            which --;
#line 20504
            if (which < cur) {
#line 20505
              cur -= 4;
            }
#line 20507
            update_list = 1;
          }
        } else
#line 20510
        if ((unsigned int )key == 293U) {
#line 20512
          if (which < num_files - 1) {
#line 20514
            which ++;
#line 20516
            if (which >= cur + 16) {
#line 20517
              cur += 4;
            }
#line 20519
            update_list = 1;
          }
        } else
#line 20522
        if ((unsigned int )key == 289U) {
#line 20524
          if (which >= 0) {
#line 20526
            which -= 4;
#line 20528
            if (which < 0) {
#line 20529
              which = 0;
            }
#line 20531
            if (which < cur) {
#line 20532
              cur -= 4;
            }
#line 20534
            update_list = 1;
          }
        } else
#line 20537
        if ((unsigned int )key == 288U) {
#line 20539
          if (which < num_files) {
#line 20541
            which += 4;
#line 20543
            if (which >= num_files) {
#line 20544
              which = num_files - 1;
            }
#line 20546
            if (which >= cur + 16) {
#line 20547
              cur += 4;
            }
#line 20549
            update_list = 1;
          }
        } else
#line 20552
        if ((unsigned int )key == 13U) {
          {
#line 20556
          done = 1;
#line 20557
          playsound(screen, 1, 1, 1, - 997, - 999);
          }
        } else
#line 20559
        if ((unsigned int )key == 27U) {
          {
#line 20563
          which = - 1;
#line 20564
          done = 1;
#line 20565
          playsound(screen, 1, 1, 1, - 999, - 999);
          }
        }
      } else {
        {
#line 20568
        __cil_tmp126 = valid_click(event.button.button);
        }
#line 20568
        if ((int )event.type == 5) {
#line 20568
          if (__cil_tmp126) {
#line 20570
            if ((int )event.button.x >= (int )r_ttools.w) {
#line 20570
              if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 20570
                if ((int )event.button.y >= img_scroll_up->h) {
#line 20570
                  if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20575
                    which = (((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur;
#line 20577
                    if (which < num_files) {
                      {
#line 20579
                      playsound(screen, 1, 2, 1, (int )event.button.x, - 999);
#line 20580
                      update_list = 1;
#line 20583
                      __cil_tmp127 = SDL_GetTicks();
                      }
#line 20583
                      if (which == last_click_which) {
#line 20583
                        if (__cil_tmp127 < last_click_time + 1000U) {
#line 20583
                          if ((int )event.button.button == last_click_button) {
#line 20588
                            done = 1;
                          }
                        }
                      }
                      {
#line 20591
                      last_click_which = which;
#line 20592
                      last_click_time = SDL_GetTicks();
#line 20593
                      last_click_button = (int )event.button.button;
                      }
                    }
                  } else {
#line 20570
                    goto _L___265;
                  }
                } else {
#line 20570
                  goto _L___265;
                }
              } else {
#line 20570
                goto _L___265;
              }
            } else
            _L___265: /* CIL Label */ 
            _L___266: /* CIL Label */ 
            _L___267: /* CIL Label */ 
#line 20596
            if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 20596
              if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 20599
                if ((int )event.button.y < img_scroll_up->h) {
#line 20603
                  if (cur > 0) {
                    {
#line 20605
                    cur -= 4;
#line 20606
                    update_list = 1;
#line 20607
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 20609
                    if (cur == 0) {
                      {
#line 20610
                      do_setcursor(cursor_arrow);
                      }
                    }
                  }
#line 20613
                  if (which >= cur + 16) {
#line 20614
                    which -= 4;
                  }
                } else
#line 20616
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20616
                  if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_up->h) {
#line 20621
                    if (cur < num_files - 16) {
                      {
#line 20623
                      cur += 4;
#line 20624
                      update_list = 1;
#line 20625
                      playsound(screen, 1, 7, 1, - 998, - 999);
                      }
#line 20627
                      if (cur >= num_files - 16) {
                        {
#line 20628
                        do_setcursor(cursor_arrow);
                        }
                      }
                    }
#line 20631
                    if (which < cur) {
#line 20632
                      which += 4;
                    }
                  }
                }
              } else {
#line 20596
                goto _L___264;
              }
            } else
            _L___264: /* CIL Label */ 
#line 20635
            if ((int )event.button.x >= (int )r_ttools.w) {
#line 20635
              if ((int )event.button.x < (int )r_ttools.w + button_w) {
#line 20635
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20635
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                    {
#line 20641
                    done = 1;
#line 20642
                    playsound(screen, 1, 1, 1, - 997, - 999);
                    }
                  } else {
#line 20635
                    goto _L___261;
                  }
                } else {
#line 20635
                  goto _L___261;
                }
              } else {
#line 20635
                goto _L___261;
              }
            } else
            _L___261: /* CIL Label */ 
            _L___262: /* CIL Label */ 
            _L___263: /* CIL Label */ 
#line 20644
            if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 20644
              if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 20644
                if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20644
                  if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                    {
#line 20651
                    which = - 1;
#line 20652
                    done = 1;
#line 20653
                    playsound(screen, 1, 1, 1, - 999, - 999);
                    }
                  }
                }
              }
            }
          } else {
#line 20568
            goto _L___286;
          }
        } else
        _L___286: /* CIL Label */ 
#line 20656
        if ((int )event.type == 5) {
#line 20656
          if ((int )event.button.button >= 4) {
#line 20656
            if ((int )event.button.button <= 5) {
#line 20656
              if (wheely) {
#line 20660
                if ((int )event.button.button == 4) {
#line 20660
                  if (cur > 0) {
                    {
#line 20662
                    cur -= 4;
#line 20663
                    update_list = 1;
#line 20664
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 20666
                    if (cur == 0) {
                      {
#line 20667
                      do_setcursor(cursor_arrow);
                      }
                    }
#line 20669
                    if (which >= cur + 16) {
#line 20670
                      which -= 4;
                    }
                  } else {
#line 20660
                    goto _L___268;
                  }
                } else
                _L___268: /* CIL Label */ 
#line 20672
                if ((int )event.button.button == 5) {
#line 20672
                  if (cur < num_files - 16) {
                    {
#line 20674
                    cur += 4;
#line 20675
                    update_list = 1;
#line 20676
                    playsound(screen, 1, 7, 1, - 998, - 999);
                    }
#line 20678
                    if (cur >= num_files - 16) {
                      {
#line 20679
                      do_setcursor(cursor_arrow);
                      }
                    }
#line 20681
                    if (which < cur) {
#line 20682
                      which += 4;
                    }
                  }
                }
              } else {
#line 20656
                goto _L___283;
              }
            } else {
#line 20656
              goto _L___283;
            }
          } else {
#line 20656
            goto _L___283;
          }
        } else
        _L___283: /* CIL Label */ 
        _L___284: /* CIL Label */ 
        _L___285: /* CIL Label */ 
#line 20685
        if ((int )event.type == 4) {
#line 20689
          if ((int )event.button.y < img_scroll_up->h) {
#line 20689
            if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 20689
              if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 20689
                if (cur > 0) {
                  {
#line 20695
                  do_setcursor(cursor_up);
                  }
                } else {
#line 20689
                  goto _L___280;
                }
              } else {
#line 20689
                goto _L___280;
              }
            } else {
#line 20689
              goto _L___280;
            }
          } else
          _L___280: /* CIL Label */ 
          _L___281: /* CIL Label */ 
          _L___282: /* CIL Label */ 
#line 20697
          if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20697
            if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - img_scroll_up->h) {
#line 20697
              if ((int )event.button.x >= (WINDOW_WIDTH - img_scroll_up->w) / 2) {
#line 20697
                if ((int )event.button.x <= (WINDOW_WIDTH + img_scroll_up->w) / 2) {
#line 20697
                  if (cur < num_files - 16) {
                    {
#line 20704
                    do_setcursor(cursor_down);
                    }
                  } else {
#line 20697
                    goto _L___276;
                  }
                } else {
#line 20697
                  goto _L___276;
                }
              } else {
#line 20697
                goto _L___276;
              }
            } else {
#line 20697
              goto _L___276;
            }
          } else
          _L___276: /* CIL Label */ 
          _L___277: /* CIL Label */ 
          _L___278: /* CIL Label */ 
          _L___279: /* CIL Label */ 
#line 20706
          if ((int )event.button.x >= (int )r_ttools.w) {
#line 20706
            if ((int )event.button.x < (int )r_ttools.w + button_w) {
              _L___271: /* CIL Label */ 
#line 20706
              if ((int )event.button.y >= (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20706
                if ((int )event.button.y < button_h * buttons_tall + (int )r_ttools.h) {
                  {
#line 20716
                  do_setcursor(cursor_hand);
                  }
                } else {
#line 20706
                  goto _L___269;
                }
              } else {
#line 20706
                goto _L___269;
              }
            } else {
#line 20706
              goto _L___275;
            }
          } else
          _L___275: /* CIL Label */ 
#line 20706
          if ((int )event.button.x >= (WINDOW_WIDTH - (int )r_ttoolopt.w) - button_w) {
#line 20706
            if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 20706
              if (*(d_places + which) != 2) {
#line 20706
                if (*(d_places + which) != 1) {
#line 20706
                  goto _L___271;
                } else {
#line 20706
                  goto _L___269;
                }
              } else {
#line 20706
                goto _L___269;
              }
            } else {
#line 20706
              goto _L___269;
            }
          } else
          _L___269: /* CIL Label */ 
          _L___270: /* CIL Label */ 
          _L___272: /* CIL Label */ 
          _L___273: /* CIL Label */ 
          _L___274: /* CIL Label */ 
#line 20718
          if ((int )event.button.x >= (int )r_ttools.w) {
#line 20718
            if ((int )event.button.x < WINDOW_WIDTH - (int )r_ttoolopt.w) {
#line 20718
              if ((int )event.button.y > img_scroll_up->h) {
#line 20718
                if ((int )event.button.y < (button_h * buttons_tall + (int )r_ttools.h) - button_h) {
#line 20718
                  if ((((int )event.button.x - (int )r_ttools.w) / (((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4) + (((int )event.button.y - img_scroll_up->h) / ((((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4)) * 4) + cur < num_files) {
                    {
#line 20726
                    do_setcursor(cursor_hand);
                    }
                  } else {
                    {
                    {
                    {
                    {
                    {
#line 20732
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
                  {
#line 20732
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
                {
#line 20732
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
                }
              }
            } else {
              {
              {
              {
              {
              {
#line 20732
              do_setcursor(cursor_arrow);
              }
              }
              }
              }
              }
            }
          } else {
            {
            {
            {
            {
            {
#line 20732
            do_setcursor(cursor_arrow);
            }
            }
            }
            }
            }
          }
#line 20734
          oldpos_x = (int )event.button.x;
#line 20735
          oldpos_y = (int )event.button.y;
        } else
#line 20738
        if ((int )event.type == 7) {
          {
#line 20739
          handle_joyaxismotion(event, & motioner, & val_x, & val_y);
          }
        } else
#line 20741
        if ((int )event.type == 9) {
          {
#line 20742
          handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                              & old_hat_ticks);
          }
        } else
#line 20744
        if ((int )event.type == 8) {
          {
#line 20745
          handle_joyballmotion(event, oldpos_x, oldpos_y);
          }
        } else
#line 20747
        if ((int )event.type == 10) {
          {
          {
#line 20748
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        } else
#line 20747
        if ((int )event.type == 11) {
          {
          {
#line 20748
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 20751
    if (motioner | hatmotioner) {
      {
#line 20752
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 20754
    SDL_Delay((Uint32 )10);
    }
#line 20368
    if (! (! done)) {
#line 20368
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 20761
  if (which != -1) {
#line 20765
    if (! been_saved) {
#line 20765
      if (! disable_save) {
        {
#line 20767
        __cil_tmp129 = do_prompt_image_snd("Save your picture first?\323\001 ", "Yes, save it!",
                                           "No, don\342\200\231t bother saving!",
                                           img_tools[13], (SDL_Surface *)((void *)0),
                                           (SDL_Surface *)((void *)0), 25, screen->w / 2,
                                           screen->h / 2);
        }
#line 20767
        if (__cil_tmp129) {
          {
#line 20772
          do_save(11, 1);
          }
        }
      }
    }
    {
#line 20778
    SDL_FillRect(label, (SDL_Rect *)((void *)0), 0U);
#line 20782
    delete_label_list(& start_label_node);
#line 20783
    label_node_to_edit = (struct label_node *)((void *)0);
#line 20783
    highlighted_label_node = label_node_to_edit;
#line 20783
    first_label_node_in_redo_stack = highlighted_label_node;
#line 20783
    current_label_node = first_label_node_in_redo_stack;
#line 20783
    start_label_node = current_label_node;
#line 20785
    have_to_rec_label_node = 0;
    }
#line 20787
    if (which >= first_starter) {
#line 20787
      if (first_template == -1) {
        _L___293: /* CIL Label */ 
#line 20787
        if (! new_colors_last) {
          _L___291: /* CIL Label */ 
          {
#line 20794
          safe_snprintf((char *)fname, sizeof(fname), "%s/%s%s", dirname___253[*(d_places + which)],
                        *(d_names + which), *(d_exts + which));
#line 20796
          img = myIMG_Load((char const   *)((char *)fname));
          }
#line 20798
          if (img == (void *)0) {
            {
#line 20800
            __cil_tmp131 = SDL_GetError();
#line 20800
            fprintf(stderr, "\nWarning: Couldn\'t load the saved image! (3)\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
                    (char *)fname, __cil_tmp131);
#line 20805
            do_prompt("Can\342\200\231t open that picture!", "OK", "\251", 0, 0);
            }
          } else {
            {
#line 20809
            free_surface(& img_starter);
#line 20810
            free_surface(& img_starter_bkgd);
#line 20811
            starter_mirrored = 0;
#line 20812
            starter_flipped = 0;
#line 20813
            starter_personal = 0;
#line 20814
            starter_modified = 0;
#line 20816
            autoscale_copy_smear_free(img, canvas, & SDL_UpperBlit);
#line 20818
            cur_undo = 0;
#line 20819
            oldest_undo = 0;
#line 20820
            newest_undo = 0;
#line 20825
            been_saved = 1;
#line 20827
            file_id[0] = (char )'\000';
#line 20828
            safe_strncpy((char *)starter_id, (char const   *)*(d_names + which), sizeof(starter_id));
#line 20829
            template_id[0] = (char )'\000';
            }
#line 20831
            if (*(d_places + which) == 1) {
#line 20832
              starter_personal = 1;
            } else {
#line 20834
              starter_personal = 0;
            }
            {
#line 20836
            load_starter((char *)starter_id);
#line 20838
            canvas_color_r = (Uint8 )255;
#line 20839
            canvas_color_g = (Uint8 )255;
#line 20840
            canvas_color_b = (Uint8 )255;
#line 20842
            SDL_FillRect(canvas, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 20843
            SDL_UpperBlit(img_starter_bkgd, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
#line 20844
            SDL_UpperBlit(img_starter, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
            }
          }
        } else
#line 20787
        if (which < first_color) {
#line 20787
          goto _L___291;
        } else {
#line 20787
          goto _L___290;
        }
      } else
#line 20787
      if (which < first_template) {
#line 20787
        goto _L___293;
      } else {
#line 20787
        goto _L___290;
      }
    } else
    _L___290: /* CIL Label */ 
    _L___292: /* CIL Label */ 
#line 20847
    if (first_template != -1) {
#line 20847
      if (which >= first_template) {
#line 20847
        if (! new_colors_last) {
          _L___288: /* CIL Label */ 
          {
#line 20853
          safe_snprintf((char *)fname, sizeof(fname), "%s/%s%s", dirname___253[*(d_places + which)],
                        *(d_names + which), *(d_exts + which));
#line 20854
          img = myIMG_Load((char const   *)((char *)fname));
          }
#line 20856
          if (img == (void *)0) {
            {
#line 20858
            __cil_tmp133 = SDL_GetError();
#line 20858
            fprintf(stderr, "\nWarning: Couldn\'t load the saved image! (4)\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
                    (char *)fname, __cil_tmp133);
#line 20863
            do_prompt("Can\342\200\231t open that picture!", "OK", "\251", 0, 0);
            }
          } else {
            {
#line 20867
            free_surface(& img_starter);
#line 20868
            free_surface(& img_starter_bkgd);
#line 20869
            template_personal = 0;
#line 20871
            autoscale_copy_smear_free(img, canvas, & SDL_UpperBlit);
#line 20873
            cur_undo = 0;
#line 20874
            oldest_undo = 0;
#line 20875
            newest_undo = 0;
#line 20880
            been_saved = 1;
#line 20882
            file_id[0] = (char )'\000';
#line 20883
            safe_strncpy((char *)template_id, (char const   *)*(d_names + which),
                         sizeof(template_id));
#line 20884
            starter_id[0] = (char )'\000';
            }
#line 20886
            if (*(d_places + which) == 3) {
#line 20887
              template_personal = 1;
            } else {
#line 20889
              template_personal = 0;
            }
            {
#line 20891
            load_template((char *)template_id);
#line 20893
            canvas_color_r = (Uint8 )255;
#line 20894
            canvas_color_g = (Uint8 )255;
#line 20895
            canvas_color_b = (Uint8 )255;
#line 20897
            SDL_FillRect(canvas, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 20898
            SDL_UpperBlit(img_starter_bkgd, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
            }
          }
        } else
#line 20847
        if (which < first_color) {
#line 20847
          goto _L___288;
        } else {
#line 20847
          goto _L___287;
        }
      } else {
#line 20847
        goto _L___287;
      }
    } else {
      _L___287: /* CIL Label */ 
      _L___289: /* CIL Label */ 
      {
#line 20905
      free_surface(& img_starter);
#line 20906
      free_surface(& img_starter_bkgd);
#line 20907
      starter_mirrored = 0;
#line 20908
      starter_flipped = 0;
#line 20909
      starter_personal = 0;
#line 20910
      starter_modified = 0;
#line 20912
      which -= first_color;
      }
#line 20916
      if (which == NUM_COLORS - 1) {
        {
#line 20918
        __cil_tmp134 = do_color_picker();
        }
#line 20918
        if (__cil_tmp134 == 0) {
#line 20919
          return (0);
        }
      }
#line 20925
      if (which == 0) {
#line 20927
        canvas_color_b = (Uint8 )255;
#line 20927
        canvas_color_g = canvas_color_b;
#line 20927
        canvas_color_r = canvas_color_g;
      } else
#line 20929
      if (which <= white_in_palette) {
#line 20931
        canvas_color_r = *(*(color_hexes + (which - 1)) + 0);
#line 20932
        canvas_color_g = *(*(color_hexes + (which - 1)) + 1);
#line 20933
        canvas_color_b = *(*(color_hexes + (which - 1)) + 2);
      } else {
#line 20937
        canvas_color_r = *(*(color_hexes + which) + 0);
#line 20938
        canvas_color_g = *(*(color_hexes + which) + 1);
#line 20939
        canvas_color_b = *(*(color_hexes + which) + 2);
      }
      {
#line 20942
      SDL_FillRect(canvas, (SDL_Rect *)((void *)0), ((((unsigned int )canvas_color_r & 255U) << 16) | (((unsigned int )canvas_color_g & 255U) << 8)) | ((unsigned int )canvas_color_b & 255U));
#line 20944
      cur_undo = 0;
#line 20945
      oldest_undo = 0;
#line 20946
      newest_undo = 0;
#line 20948
      been_saved = 1;
#line 20949
      reset_avail_tools();
#line 20951
      tool_avail_bak[8] = 0;
#line 20952
      tool_avail_bak[9] = 0;
#line 20954
      file_id[0] = (char )'\000';
#line 20955
      starter_id[0] = (char )'\000';
#line 20957
      playsound(screen, 1, 0, 1, - 998, - 999);
      }
    }
  }
  {
#line 20961
  update_canvas(0, 0, (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w, button_h * buttons_tall + (int )r_ttools.h);
#line 20966
  free_surface_array(thumbs, num_files);
#line 20968
  free(thumbs);
#line 20970
  i = 0;
  }
  {
#line 20970
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 20970
    if (! (i < num_files)) {
#line 20970
      goto while_break___6;
    }
#line 20972
    if (*(d_names + i) != (void *)0) {
      {
#line 20973
      free(*(d_names + i));
      }
    }
#line 20974
    if (*(d_exts + i) != (void *)0) {
      {
#line 20975
      free(*(d_exts + i));
      }
    }
#line 20970
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 20978
  i = 0;
  {
#line 20978
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 20978
    if (! (i < 5)) {
#line 20978
      goto while_break___7;
    }
#line 20979
    if (dirname___253[i] != (void *)0) {
      {
#line 20980
      free(dirname___253[i]);
      }
    }
#line 20978
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 20982
  free(d_names);
#line 20983
  free(d_exts);
#line 20984
  free(d_places);
  }
#line 20986
  return (which != -1);
}
}
#line 20993 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_new_dialog_add_colors(SDL_Surface **thumbs , int num_files , int *d_places ,
                                    char **d_names , char **d_exts , int *white_in_palette ) 
{ 
  int j ;
  int added ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  SDL_Surface *__cil_tmp12 ;
  SDL_Surface *__cil_tmp13 ;
  int __cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 21000
  j = - 1;
  {
#line 21000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21000
    if (! (j < NUM_COLORS)) {
#line 21000
      goto while_break;
    }
#line 21002
    added = 0;
#line 21004
    if (j < NUM_COLORS - 1) {
#line 21006
      if (j == -1) {
        _L: /* CIL Label */ 
        _L___294: /* CIL Label */ 
        _L___295: /* CIL Label */ 
        {
#line 21012
        *(thumbs + num_files) = SDL_CreateRGBSurface(screen->flags, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                                     (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                                     (int )(screen->format)->BitsPerPixel,
                                                     (screen->format)->Rmask, (screen->format)->Gmask,
                                                     (screen->format)->Bmask, (Uint32 )0);
        }
#line 21018
        if (*(thumbs + num_files) != (void *)0) {
#line 21020
          if (j == -1) {
#line 21022
            b = (Uint8 )255;
#line 21022
            g = b;
#line 21022
            r = g;
          } else {
#line 21026
            r = *(*(color_hexes + j) + 0);
#line 21027
            g = *(*(color_hexes + j) + 1);
#line 21028
            b = *(*(color_hexes + j) + 2);
          }
          {
#line 21030
          SDL_FillRect(*(thumbs + num_files), (SDL_Rect *)((void *)0), ((((unsigned int )r & 255U) << 16) | (((unsigned int )g & 255U) << 8)) | ((unsigned int )b & 255U));
#line 21031
          added = 1;
          }
        }
      } else
#line 21006
      if ((int )*(*(color_hexes + j) + 0) != 255) {
#line 21006
        goto _L;
      } else
#line 21006
      if ((int )*(*(color_hexes + j) + 1) != 255) {
#line 21006
        goto _L;
      } else
#line 21006
      if ((int )*(*(color_hexes + j) + 2) != 255) {
#line 21006
        goto _L;
      } else {
#line 21036
        *white_in_palette = j;
      }
    } else {
      {
#line 21043
      *(thumbs + num_files) = thumbnail(img_color_picker, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4 - 20,
                                        (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4 - 20,
                                        0);
#line 21044
      added = 1;
      }
    }
#line 21047
    if (added) {
#line 21049
      *(d_places + num_files) = - 1;
#line 21050
      *(d_names + num_files) = (char *)((void *)0);
#line 21051
      *(d_exts + num_files) = (char *)((void *)0);
#line 21053
      num_files ++;
    }
#line 21000
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 21057
  return (num_files);
}
}
#line 21065 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void reset_touched(void) 
{ 
  int x ;
  int y ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
#line 21069
  y = 0;
  {
#line 21069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21069
    if (! (y < canvas->h)) {
#line 21069
      goto while_break;
    }
#line 21071
    x = 0;
    {
#line 21071
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 21071
      if (! (x < canvas->w)) {
#line 21071
        goto while_break___0;
      }
#line 21073
      *(touched + (y * canvas->w + x)) = (Uint8 )0;
#line 21071
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 21069
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 21081 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint8 magic_touched(int x , int y ) 
{ 
  Uint8 res ;

  {
#line 21085
  if (x < 0) {
#line 21086
    return ((Uint8 )1);
  } else
#line 21085
  if (x >= canvas->w) {
#line 21086
    return ((Uint8 )1);
  } else
#line 21085
  if (y < 0) {
#line 21086
    return ((Uint8 )1);
  } else
#line 21085
  if (y >= canvas->h) {
#line 21086
    return ((Uint8 )1);
  }
#line 21088
  res = *(touched + (y * canvas->w + x));
#line 21089
  *(touched + (y * canvas->w + x)) = (Uint8 )1;
#line 21091
  return (res);
}
}
#line 21097 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_color_sel(void) 
{ 
  SDL_Surface *alpha_surf ;
  SDL_Rect dest ;
  int x ;
  int y ;
  int w ;
  int ox ;
  int oy ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  int stepx ;
  int stepy ;
  int number_of_steps ;
  int i ;
  int dx ;
  int dy ;
  int done ;
  int chose ;
  int back_left ;
  int back_top ;
  int color_sel_x ;
  int color_sel_y ;
  int want_animated_popups ;
  SDL_Surface *tmp_btn_up ;
  SDL_Surface *tmp_btn_down ;
  Uint32 (*getpixel_tmp_btn_up)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_tmp_btn_down)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_img_paintwell)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_img_color_picker)(SDL_Surface * , int  , int  ) ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  double rh ;
  double gh ;
  double bh ;
  SDL_Event event ;
  SDLKey key ;
  SDL_Rect r_color_sel ;
  SDL_Rect color_example_dest ;
  SDL_Surface *backup ;
  SDL_Rect r_color_picker ;
  SDL_Surface *__cil_tmp45 ;
  int __cil_tmp46 ;
  SDL_Surface *__cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  SDL_Surface *__cil_tmp50 ;
  SDL_Surface *__cil_tmp51 ;
  SDL_Surface *__cil_tmp52 ;
  double ru ;
  double gu ;
  double bu ;
  double rd ;
  double gd ;
  double bd ;
  double aa ;
  Uint8 a ;
  unsigned char __cil_tmp61 ;
  unsigned char __cil_tmp62 ;
  unsigned char __cil_tmp63 ;
  unsigned char __cil_tmp64 ;
  unsigned char __cil_tmp65 ;
  unsigned char __cil_tmp66 ;
  int __cil_tmp67 ;
  int __cil_tmp68 ;

  {
#line 21108
  number_of_steps = 20;
#line 21112
  color_sel_x = 0;
  {
#line 21112
  color_sel_y = 0;
#line 21113
  want_animated_popups = 1;
#line 21129
  motioner = 0;
#line 21129
  val_y = motioner;
#line 21129
  val_x = val_y;
#line 21130
  hatmotioner = 0;
#line 21130
  valhat_y = hatmotioner;
#line 21130
  valhat_x = valhat_y;
#line 21135
  hide_blinking_cursor();
#line 21137
  do_setcursor(cursor_hand);
#line 21142
  playsound(screen, 0, 15, 1, - 999, 128);
#line 21144
  backup = SDL_CreateRGBSurface(screen->flags, screen->w, screen->h, (int )(screen->format)->BitsPerPixel,
                                (screen->format)->Rmask, (screen->format)->Gmask,
                                (screen->format)->Bmask, (screen->format)->Amask);
#line 21149
  SDL_UpperBlit(screen, (SDL_Rect *)((void *)0), backup, (SDL_Rect *)((void *)0));
#line 21151
  r_color_sel.x = r_canvas.x;
#line 21152
  r_color_sel.y = (Sint16 )r_canvas.h;
#line 21153
  r_color_sel.w = r_canvas.w;
#line 21154
  r_color_sel.h = (Uint16 )button_w;
  }
#line 21157
  if (want_animated_popups) {
#line 21160
    ox = (WINDOW_WIDTH - color_button_w) - color_button_w / 2;
#line 21161
    oy = (int )r_colors.y + (int )r_colors.h / 2;
#line 21162
    dx = 0;
#line 21163
    dy = 0;
#line 21164
    w = 0;
#line 21165
    stepx = ((int )r_color_sel.x - ox) / number_of_steps;
#line 21166
    stepy = ((int )r_color_sel.y - oy) / number_of_steps;
#line 21168
    i = 0;
    {
#line 21168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 21168
      if (! (i < number_of_steps)) {
#line 21168
        goto while_break;
      }
      {
#line 21170
      w += 138 / number_of_steps;
#line 21171
      dx = i * stepx;
#line 21172
      dy = i * stepy;
#line 21175
      dest.x = (Sint16 )(ox + dx);
#line 21176
      dest.y = (Sint16 )(oy + dy);
#line 21178
      dest.w = (Uint16 )((i * (int )r_color_sel.w) / number_of_steps);
#line 21179
      dest.h = (Uint16 )((i * (int )r_color_sel.h) / number_of_steps);
#line 21181
      SDL_FillRect(screen, & dest, ((((unsigned int )(255 - w) & 255U) << 16) | (((unsigned int )(255 - w) & 255U) << 8)) | ((unsigned int )(255 - w) & 255U));
#line 21182
      SDL_UpdateRect(screen, (Sint32 )dest.x, (Sint32 )dest.y, (Uint32 )dest.w, (Uint32 )dest.h);
#line 21183
      SDL_Delay((Uint32 )2);
      }
#line 21168
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 21186
    SDL_UpperBlit(backup, (SDL_Rect *)((void *)0), screen, (SDL_Rect *)((void *)0));
    }
  }
  {
#line 21191
  alpha_surf = SDL_CreateRGBSurface((Uint32 )65536, (int )r_color_sel.w, (int )r_color_sel.h,
                                    (int )(screen->format)->BitsPerPixel, (screen->format)->Rmask,
                                    (screen->format)->Gmask, (screen->format)->Bmask,
                                    (screen->format)->Amask);
  }
#line 21198
  if (alpha_surf != (void *)0) {
    {
#line 21200
    SDL_FillRect(alpha_surf, (SDL_Rect *)((void *)0), 0U);
#line 21201
    SDL_SetAlpha(alpha_surf, (Uint32 )65536, (Uint8 )64);
#line 21203
    i = 8;
    }
    {
#line 21203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 21203
      if (! (i > 0)) {
#line 21203
        goto while_break___0;
      }
      {
#line 21205
      dest.x = (Sint16 )((int )r_color_sel.x + i);
#line 21206
      dest.y = (Sint16 )((int )r_color_sel.y + i);
#line 21207
      dest.w = r_color_sel.w;
#line 21208
      dest.h = r_color_sel.h;
#line 21210
      SDL_UpperBlit(alpha_surf, (SDL_Rect *)((void *)0), screen, & dest);
      }
#line 21203
      i -= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 21213
    SDL_FreeSurface(alpha_surf);
    }
  }
  {
#line 21220
  SDL_FillRect(screen, & r_color_sel, ((255U << 16) | (255U << 8)) | 255U);
#line 21227
  color_example_dest.x = (Sint16 )((int )r_color_sel.x + 2);
#line 21228
  color_example_dest.y = (Sint16 )((int )r_color_sel.y + 2);
#line 21229
  color_example_dest.w = (Uint16 )(((int )r_color_sel.w - button_w) - 8);
#line 21230
  color_example_dest.h = (Uint16 )((int )r_color_sel.h - 4);
#line 21233
  SDL_FillRect(screen, & color_example_dest, 0U);
#line 21235
  color_example_dest.x += 2;
#line 21236
  color_example_dest.y += 2;
#line 21237
  color_example_dest.w -= 4;
#line 21238
  color_example_dest.h -= 4;
#line 21240
  SDL_FillRect(screen, & color_example_dest, ((255U << 16) | (255U << 8)) | 255U);
#line 21242
  color_example_dest.x += 2;
#line 21243
  color_example_dest.y += 2;
#line 21244
  color_example_dest.w -= 4;
#line 21245
  color_example_dest.h -= 4;
#line 21251
  SDL_FillRect(screen, & color_example_dest, ((((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 2) & 255U));
#line 21260
  back_left = (((int )r_color_sel.x + (int )r_color_sel.w) - button_w) - 4;
#line 21261
  back_top = (int )r_color_sel.y;
#line 21263
  dest.x = (Sint16 )back_left;
#line 21264
  dest.y = (Sint16 )back_top;
#line 21266
  SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 21268
  dest.x = (Sint16 )(back_left + (img_back->w - img_openlabels_back->w) / 2);
#line 21269
  dest.y = (Sint16 )((back_top + img_back->h) - img_openlabels_back->h);
#line 21270
  SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 21275
  SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), screen, & r_canvas);
#line 21277
  SDL_Flip(screen);
#line 21282
  done = 0;
#line 21283
  chose = 0;
#line 21284
  y = 0;
#line 21284
  x = y;
#line 21285
  SDL_WarpMouse((Uint16 )((int )r_color_sel.x + (int )r_color_sel.w / 2), (Uint16 )((int )r_color_sel.y + (int )r_color_sel.h / 2));
  }
  {
#line 21287
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 21289
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 21289
      __cil_tmp48 = SDL_PollEvent(& event);
      }
#line 21289
      if (! __cil_tmp48) {
#line 21289
        goto while_break___2;
      }
#line 21291
      if ((int )event.type == 12) {
#line 21293
        chose = 0;
#line 21294
        done = 1;
      } else
#line 21296
      if ((int )event.type == 1) {
        {
#line 21298
        handle_active(& event);
        }
      } else
#line 21300
      if ((int )event.type == 3) {
        {
#line 21302
        key = event.key.keysym.sym;
#line 21304
        handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 21306
      if ((int )event.type == 2) {
        {
#line 21308
        key = event.key.keysym.sym;
#line 21310
        handle_keymouse(key, (Uint8 )2, 24, & r_color_picker, (SDL_Rect *)((void *)0));
        }
#line 21312
        if ((unsigned int )key == 27U) {
#line 21314
          chose = 0;
#line 21315
          done = 1;
        }
      } else {
        {
#line 21318
        __cil_tmp49 = valid_click(event.button.button);
        }
#line 21318
        if ((int )event.type == 6) {
#line 21318
          if (__cil_tmp49) {
#line 21320
            if ((int )event.button.x >= (int )r_canvas.x) {
#line 21320
              if ((int )event.button.x < (int )r_canvas.x + (int )r_canvas.w) {
#line 21320
                if ((int )event.button.y >= (int )r_canvas.y) {
#line 21320
                  if ((int )event.button.y < (int )r_canvas.y + (int )r_canvas.h) {
#line 21326
                    chose = 1;
#line 21327
                    done = 1;
#line 21329
                    x = (int )event.button.x - (int )r_canvas.x;
#line 21330
                    y = (int )event.button.y - (int )r_canvas.y;
#line 21332
                    color_sel_x = x;
#line 21333
                    color_sel_y = y;
                  } else {
#line 21320
                    goto _L;
                  }
                } else {
#line 21320
                  goto _L;
                }
              } else {
#line 21320
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
            _L___296: /* CIL Label */ 
            _L___297: /* CIL Label */ 
#line 21335
            if ((int )event.button.x >= back_left) {
#line 21335
              if ((int )event.button.x < back_left + img_back->w) {
#line 21335
                if ((int )event.button.y >= back_top) {
#line 21335
                  if ((int )event.button.y < back_top + img_back->h) {
#line 21341
                    chose = 0;
#line 21342
                    done = 1;
                  }
                }
              }
            }
          } else {
#line 21318
            goto _L___301;
          }
        } else
        _L___301: /* CIL Label */ 
#line 21345
        if ((int )event.type == 4) {
#line 21347
          if ((int )event.button.x >= (int )r_canvas.x) {
#line 21347
            if ((int )event.button.x < (int )r_canvas.x + (int )r_canvas.w) {
#line 21347
              if ((int )event.button.y >= (int )r_canvas.y) {
#line 21347
                if ((int )event.button.y < (int )r_canvas.y + (int )r_canvas.h) {
                  {
#line 21353
                  do_setcursor(cursor_hand);
#line 21358
                  x = (int )event.button.x - (int )r_canvas.x;
#line 21359
                  y = (int )event.button.y - (int )r_canvas.y;
#line 21361
                  getpixel_img_color_picker = getpixels[(canvas->format)->BytesPerPixel];
#line 21364
                  SDL_FillRect(screen, & color_example_dest, ((((unsigned int )r & 255U) << 16) | (((unsigned int )g & 255U) << 8)) | ((unsigned int )b & 255U));
#line 21366
                  SDL_UpdateRect(screen, (Sint32 )color_example_dest.x, (Sint32 )color_example_dest.y,
                                 (Uint32 )color_example_dest.w, (Uint32 )color_example_dest.h);
                  }
                } else {
#line 21347
                  goto _L___298;
                }
              } else {
#line 21347
                goto _L___298;
              }
            } else {
#line 21347
              goto _L___298;
            }
          } else {
            _L___298: /* CIL Label */ 
            _L___299: /* CIL Label */ 
            _L___300: /* CIL Label */ 
            {
#line 21375
            SDL_FillRect(screen, & color_example_dest, ((((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + (NUM_COLORS - 2)) + 2) & 255U));
#line 21380
            SDL_UpdateRect(screen, (Sint32 )color_example_dest.x, (Sint32 )color_example_dest.y,
                           (Uint32 )color_example_dest.w, (Uint32 )color_example_dest.h);
            }
#line 21387
            if ((int )event.button.x >= back_left) {
#line 21387
              if ((int )event.button.x < back_left + img_back->w) {
#line 21387
                if ((int )event.button.y >= back_top) {
#line 21387
                  if ((int )event.button.y < back_top + img_back->h) {
                    {
#line 21390
                    do_setcursor(cursor_hand);
                    }
                  } else {
                    {
                    {
                    {
                    {
#line 21392
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
#line 21392
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
#line 21392
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
              }
            } else {
              {
              {
              {
              {
#line 21392
              do_setcursor(cursor_arrow);
              }
              }
              }
              }
            }
          }
#line 21395
          oldpos_x = (int )event.motion.x;
#line 21396
          oldpos_y = (int )event.motion.y;
        } else
#line 21398
        if ((int )event.type == 7) {
          {
#line 21399
          handle_joyaxismotion(event, & motioner, & val_x, & val_y);
          }
        } else
#line 21401
        if ((int )event.type == 9) {
          {
#line 21402
          handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                              & old_hat_ticks);
          }
        } else
#line 21404
        if ((int )event.type == 8) {
          {
#line 21405
          handle_joyballmotion(event, oldpos_x, oldpos_y);
          }
        } else
#line 21407
        if ((int )event.type == 10) {
          {
          {
#line 21408
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        } else
#line 21407
        if ((int )event.type == 11) {
          {
          {
#line 21408
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 21411
    if (motioner | hatmotioner) {
      {
#line 21412
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 21414
    SDL_Delay((Uint32 )10);
    }
#line 21287
    if (! (! done)) {
#line 21287
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 21421
  if (chose) {
    {
#line 21423
    getpixel_img_color_picker = getpixels[(canvas->format)->BytesPerPixel];
#line 21426
    *(*(color_hexes + (NUM_COLORS - 2)) + 0) = r;
#line 21427
    *(*(color_hexes + (NUM_COLORS - 2)) + 1) = g;
#line 21428
    *(*(color_hexes + (NUM_COLORS - 2)) + 2) = b;
#line 21433
    tmp_btn_up = thumbnail(img_btn_up, color_button_w, color_button_h, 0);
#line 21434
    tmp_btn_down = thumbnail(img_btn_down, color_button_w, color_button_h, 0);
#line 21435
    img_color_btn_off = thumbnail(img_btn_off, color_button_w, color_button_h, 0);
#line 21437
    getpixel_tmp_btn_up = getpixels[(tmp_btn_up->format)->BytesPerPixel];
#line 21438
    getpixel_tmp_btn_down = getpixels[(tmp_btn_down->format)->BytesPerPixel];
#line 21439
    getpixel_img_paintwell = getpixels[(img_paintwell->format)->BytesPerPixel];
#line 21441
    rh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 2)) + 0)];
#line 21442
    gh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 2)) + 1)];
#line 21443
    bh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 2)) + 2)];
#line 21447
    SDL_LockSurface(*(img_color_btns + (NUM_COLORS - 2)));
#line 21448
    SDL_LockSurface(*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)));
#line 21450
    y = 0;
    }
    {
#line 21450
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 21450
      if (! (y < tmp_btn_up->h)) {
#line 21450
        goto while_break___3;
      }
#line 21452
      x = 0;
      {
#line 21452
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 21452
        if (! (x < tmp_btn_up->w)) {
#line 21452
          goto while_break___4;
        }
#line 21459
        ru = (double )sRGB_to_linear_table___1[r];
#line 21460
        gu = (double )sRGB_to_linear_table___1[g];
#line 21461
        bu = (double )sRGB_to_linear_table___1[b];
#line 21464
        rd = (double )sRGB_to_linear_table___1[r];
#line 21465
        gd = (double )sRGB_to_linear_table___1[g];
#line 21466
        bd = (double )sRGB_to_linear_table___1[b];
#line 21469
        aa = (double )((int )a) / 255.;
#line 21471
        if ((int )a == 255) {
          {
#line 21473
          __cil_tmp63 = linear_to_sRGB((float )(bh * aa + bu * (1. - aa)));
          }
          {
#line 21473
          __cil_tmp62 = linear_to_sRGB((float )(gh * aa + gu * (1. - aa)));
          }
          {
#line 21473
          __cil_tmp61 = linear_to_sRGB((float )(rh * aa + ru * (1. - aa)));
#line 21473
          (*(putpixels[((*(img_color_btns + (NUM_COLORS - 2)))->format)->BytesPerPixel]))(*(img_color_btns + (NUM_COLORS - 2)),
                                                                                          x,
                                                                                          y,
                                                                                          ((((unsigned int )__cil_tmp61 & 255U) << 16) | (((unsigned int )__cil_tmp62 & 255U) << 8)) | ((unsigned int )__cil_tmp63 & 255U));
#line 21479
          __cil_tmp66 = linear_to_sRGB((float )(bh * aa + bd * (1. - aa)));
          }
          {
#line 21479
          __cil_tmp65 = linear_to_sRGB((float )(gh * aa + gd * (1. - aa)));
          }
          {
#line 21479
          __cil_tmp64 = linear_to_sRGB((float )(rh * aa + rd * (1. - aa)));
#line 21479
          (*(putpixels[((*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)),
                                                                                                         x,
                                                                                                         y,
                                                                                                         ((((unsigned int )__cil_tmp64 & 255U) << 16) | (((unsigned int )__cil_tmp65 & 255U) << 8)) | ((unsigned int )__cil_tmp66 & 255U));
          }
        }
#line 21452
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 21450
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 21488
    SDL_UnlockSurface(*(img_color_btns + (NUM_COLORS - 2)));
#line 21489
    SDL_UnlockSurface(*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)));
#line 21491
    dest.x = (Sint16 )(((*(img_color_btns + (NUM_COLORS - 2)))->w - img_color_sel->w) / 2);
#line 21492
    dest.y = (Sint16 )(((*(img_color_btns + (NUM_COLORS - 2)))->h - img_color_sel->h) / 2);
#line 21493
    dest.w = (Uint16 )img_color_sel->w;
#line 21494
    dest.h = (Uint16 )img_color_sel->h;
#line 21495
    SDL_UpperBlit(img_color_sel, (SDL_Rect *)((void *)0), *(img_color_btns + (NUM_COLORS - 2)),
                  & dest);
#line 21497
    dest.x = (Sint16 )(((*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)))->w - img_color_sel->w) / 2);
#line 21498
    dest.y = (Sint16 )(((*(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)))->h - img_color_sel->h) / 2);
#line 21499
    SDL_UpperBlit(img_color_sel, (SDL_Rect *)((void *)0), *(img_color_btns + ((NUM_COLORS - 2) + NUM_COLORS)),
                  & dest);
    }
  }
#line 21502
  return (chose);
}
}
#line 21508 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int do_color_picker(void) 
{ 
  int i ;
  SDL_Surface *alpha_surf ;
  SDL_Rect dest ;
  int x ;
  int y ;
  int w ;
  int ox ;
  int oy ;
  int val_x ;
  int val_y ;
  int motioner ;
  int valhat_x ;
  int valhat_y ;
  int hatmotioner ;
  SDL_Surface *tmp_btn_up ;
  SDL_Surface *tmp_btn_down ;
  int stop ;
  Uint32 (*getpixel_tmp_btn_up)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_tmp_btn_down)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_img_paintwell)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_img_color_picker)(SDL_Surface * , int  , int  ) ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  double rh ;
  double gh ;
  double bh ;
  int done ;
  int chose ;
  SDL_Event event ;
  SDLKey key ;
  int color_picker_left ;
  int color_picker_top ;
  int back_left ;
  int back_top ;
  SDL_Rect color_example_dest ;
  SDL_Surface *backup ;
  SDL_Rect r_color_picker ;
  SDL_Rect r_final ;
  SDL_Surface *__cil_tmp40 ;
  SDL_Surface *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  SDL_Surface *__cil_tmp44 ;
  SDL_Surface *__cil_tmp45 ;
  SDL_Surface *__cil_tmp46 ;
  double ru ;
  double gu ;
  double bu ;
  double rd ;
  double gd ;
  double bd ;
  double aa ;
  Uint8 a ;
  Uint32 __cil_tmp55 ;
  Uint32 __cil_tmp56 ;
  unsigned char __cil_tmp57 ;
  unsigned char __cil_tmp58 ;
  unsigned char __cil_tmp59 ;
  unsigned char __cil_tmp60 ;
  unsigned char __cil_tmp61 ;
  unsigned char __cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;

  {
  {
#line 21537
  motioner = 0;
#line 21537
  val_y = motioner;
#line 21537
  val_x = val_y;
#line 21538
  hatmotioner = 0;
#line 21538
  valhat_y = hatmotioner;
#line 21538
  valhat_x = valhat_y;
#line 21539
  hide_blinking_cursor();
#line 21541
  do_setcursor(cursor_hand);
#line 21546
  playsound(screen, 0, 15, 1, - 999, 128);
#line 21548
  backup = SDL_CreateRGBSurface(screen->flags, screen->w, screen->h, (int )(screen->format)->BitsPerPixel,
                                (screen->format)->Rmask, (screen->format)->Gmask,
                                (screen->format)->Bmask, (screen->format)->Amask);
#line 21553
  SDL_UpperBlit(screen, (SDL_Rect *)((void *)0), backup, (SDL_Rect *)((void *)0));
#line 21555
  ox = screen->w - color_button_w / 2;
#line 21556
  oy = (int )r_colors.y + (int )r_colors.h / 2;
#line 21558
  r_final.x = (Sint16 )((((int )r_canvas.x + (int )r_canvas.w / 2) - img_color_picker->w) - 4);
#line 21559
  r_final.y = (Sint16 )(((int )r_canvas.h / 2 - img_color_picker->h / 2) - 2);
#line 21560
  r_final.w = (Uint16 )(img_color_picker->w * 2);
#line 21561
  r_final.h = (Uint16 )img_color_picker->h;
#line 21563
  stop = ((int )r_final.h / 2 + 6) + 4;
#line 21565
  w = 0;
  }
  {
#line 21565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21565
    if (! (w <= stop)) {
#line 21565
      goto while_break;
    }
    {
#line 21567
    dest.x = (Sint16 )(ox - ((ox - (int )r_final.x) * w) / stop);
#line 21568
    dest.y = (Sint16 )(oy - ((oy - (int )r_final.y) * w) / stop);
#line 21569
    dest.w = (Uint16 )(w * 4);
#line 21570
    dest.h = (Uint16 )(w * 2);
#line 21572
    SDL_FillRect(screen, & dest, ((((unsigned int )(255 - (int )((float )w / button_scale)) & 255U) << 16) | (((unsigned int )(255 - (int )((float )w / button_scale)) & 255U) << 8)) | ((unsigned int )(255 - (int )((float )w / button_scale)) & 255U));
#line 21574
    SDL_UpdateRect(screen, (Sint32 )dest.x, (Sint32 )dest.y, (Uint32 )dest.w, (Uint32 )dest.h);
    }
#line 21575
    if (w % 16 == 0) {
      {
#line 21576
      SDL_Delay((Uint32 )1);
      }
    }
#line 21565
    w += 4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 21579
  SDL_UpperBlit(backup, (SDL_Rect *)((void *)0), screen, (SDL_Rect *)((void *)0));
#line 21582
  alpha_surf = SDL_CreateRGBSurface((Uint32 )65536, (int )r_final.w + 8, (int )r_final.h + 16,
                                    (int )(screen->format)->BitsPerPixel, (screen->format)->Rmask,
                                    (screen->format)->Gmask, (screen->format)->Bmask,
                                    (screen->format)->Amask);
  }
#line 21589
  if (alpha_surf != (void *)0) {
    {
#line 21591
    SDL_FillRect(alpha_surf, (SDL_Rect *)((void *)0), 0U);
#line 21592
    SDL_SetAlpha(alpha_surf, (Uint32 )65536, (Uint8 )64);
#line 21594
    i = 8;
    }
    {
#line 21594
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 21594
      if (! (i > 0)) {
#line 21594
        goto while_break___0;
      }
      {
#line 21596
      dest.x = (Sint16 )(((int )r_final.x + i) - 4);
#line 21597
      dest.y = (Sint16 )(((int )r_final.y + i) - 4);
#line 21598
      dest.w = (Uint16 )((int )r_final.w + 8);
#line 21599
      dest.h = (Uint16 )((int )r_final.h + 16);
#line 21601
      SDL_UpperBlit(alpha_surf, (SDL_Rect *)((void *)0), screen, & dest);
      }
#line 21594
      i -= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 21604
    SDL_FreeSurface(alpha_surf);
    }
  }
  {
#line 21611
  w -= 6;
#line 21612
  dest.x = (Sint16 )((int )r_final.x - 2);
#line 21613
  dest.w = (Uint16 )((int )r_final.w + 4);
#line 21614
  dest.h = (Uint16 )(w * 2);
#line 21615
  dest.y = (Sint16 )((int )r_final.y - 2);
#line 21616
  SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 21621
  color_picker_left = (int )r_final.x;
#line 21622
  color_picker_top = (int )r_final.y;
#line 21624
  dest.x = (Sint16 )color_picker_left;
#line 21625
  dest.y = (Sint16 )color_picker_top;
#line 21627
  SDL_UpperBlit(img_color_picker, (SDL_Rect *)((void *)0), screen, & dest);
#line 21629
  r_color_picker.x = dest.x;
#line 21630
  r_color_picker.y = dest.y;
#line 21631
  r_color_picker.w = dest.w;
#line 21632
  r_color_picker.h = dest.h;
#line 21637
  dest.x = (Sint16 )((color_picker_x + color_picker_left) - 3);
#line 21638
  dest.y = (Sint16 )((color_picker_y + color_picker_top) - 1);
#line 21639
  dest.w = (Uint16 )7;
#line 21640
  dest.h = (Uint16 )3;
#line 21642
  SDL_FillRect(screen, & dest, 0U);
#line 21644
  dest.x = (Sint16 )((color_picker_x + color_picker_left) - 1);
#line 21645
  dest.y = (Sint16 )((color_picker_y + color_picker_top) - 3);
#line 21646
  dest.w = (Uint16 )3;
#line 21647
  dest.h = (Uint16 )7;
#line 21649
  SDL_FillRect(screen, & dest, 0U);
#line 21651
  dest.x = (Sint16 )((color_picker_x + color_picker_left) - 2);
#line 21652
  dest.y = (Sint16 )(color_picker_y + color_picker_top);
#line 21653
  dest.w = (Uint16 )5;
#line 21654
  dest.h = (Uint16 )1;
#line 21656
  SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 21658
  dest.x = (Sint16 )(color_picker_x + color_picker_left);
#line 21659
  dest.y = (Sint16 )((color_picker_y + color_picker_top) - 2);
#line 21660
  dest.w = (Uint16 )1;
#line 21661
  dest.h = (Uint16 )5;
#line 21663
  SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 21668
  color_example_dest.x = (Sint16 )((color_picker_left + img_color_picker->w) + 2);
#line 21669
  color_example_dest.y = (Sint16 )(color_picker_top + 2);
#line 21670
  color_example_dest.w = (Uint16 )((int )r_final.w / 2 - 2);
#line 21671
  color_example_dest.h = (Uint16 )((int )r_final.h / 2 - 4);
#line 21674
  SDL_FillRect(screen, & color_example_dest, 0U);
#line 21676
  color_example_dest.x += 2;
#line 21677
  color_example_dest.y += 2;
#line 21678
  color_example_dest.w -= 4;
#line 21679
  color_example_dest.h -= 4;
#line 21681
  SDL_FillRect(screen, & color_example_dest, ((255U << 16) | (255U << 8)) | 255U);
#line 21683
  color_example_dest.x += 2;
#line 21684
  color_example_dest.y += 2;
#line 21685
  color_example_dest.w -= 4;
#line 21686
  color_example_dest.h -= 4;
#line 21691
  SDL_FillRect(screen, & color_example_dest, ((((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 2) & 255U));
#line 21700
  back_left = ((((-192 + w * 2) - img_color_picker->w) - img_back->w) / 2 + color_picker_left) + img_color_picker->w;
#line 21702
  back_top = ((color_picker_top + img_color_picker->h) - img_back->h) - 2;
#line 21704
  dest.x = (Sint16 )back_left;
#line 21705
  dest.y = (Sint16 )back_top;
#line 21707
  SDL_UpperBlit(img_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 21709
  dest.x = (Sint16 )(back_left + (img_back->w - img_openlabels_back->w) / 2);
#line 21710
  dest.y = (Sint16 )((back_top + img_back->h) - img_openlabels_back->h);
#line 21711
  SDL_UpperBlit(img_openlabels_back, (SDL_Rect *)((void *)0), screen, & dest);
#line 21714
  SDL_Flip(screen);
#line 21719
  done = 0;
#line 21720
  chose = 0;
#line 21721
  y = 0;
#line 21721
  x = y;
#line 21722
  SDL_WarpMouse((Uint16 )(back_left + button_w / 2), (Uint16 )(back_top - button_w / 2));
  }
  {
#line 21724
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 21726
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 21726
      __cil_tmp42 = SDL_PollEvent(& event);
      }
#line 21726
      if (! __cil_tmp42) {
#line 21726
        goto while_break___2;
      }
#line 21728
      if ((int )event.type == 12) {
#line 21730
        chose = 0;
#line 21731
        done = 1;
      } else
#line 21733
      if ((int )event.type == 1) {
        {
#line 21735
        handle_active(& event);
        }
      } else
#line 21737
      if ((int )event.type == 3) {
        {
#line 21739
        key = event.key.keysym.sym;
#line 21741
        handle_keymouse(key, (Uint8 )3, 24, (SDL_Rect *)((void *)0), (SDL_Rect *)((void *)0));
        }
      } else
#line 21743
      if ((int )event.type == 2) {
        {
#line 21745
        key = event.key.keysym.sym;
#line 21747
        handle_keymouse(key, (Uint8 )2, 24, & r_color_picker, (SDL_Rect *)((void *)0));
        }
#line 21749
        if ((unsigned int )key == 27U) {
#line 21751
          chose = 0;
#line 21752
          done = 1;
        }
      } else {
        {
#line 21755
        __cil_tmp43 = valid_click(event.button.button);
        }
#line 21755
        if ((int )event.type == 6) {
#line 21755
          if (__cil_tmp43) {
#line 21757
            if ((int )event.button.x >= color_picker_left) {
#line 21757
              if ((int )event.button.x < color_picker_left + img_color_picker->w) {
#line 21757
                if ((int )event.button.y >= color_picker_top) {
#line 21757
                  if ((int )event.button.y < color_picker_top + img_color_picker->h) {
#line 21763
                    chose = 1;
#line 21764
                    done = 1;
#line 21766
                    x = (int )event.button.x - color_picker_left;
#line 21767
                    y = (int )event.button.y - color_picker_top;
#line 21769
                    color_picker_x = x;
#line 21770
                    color_picker_y = y;
                  } else {
#line 21757
                    goto _L;
                  }
                } else {
#line 21757
                  goto _L;
                }
              } else {
#line 21757
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
            _L___302: /* CIL Label */ 
            _L___303: /* CIL Label */ 
#line 21772
            if ((int )event.button.x >= back_left) {
#line 21772
              if ((int )event.button.x < back_left + img_back->w) {
#line 21772
                if ((int )event.button.y >= back_top) {
#line 21772
                  if ((int )event.button.y < back_top + img_back->h) {
#line 21778
                    chose = 0;
#line 21779
                    done = 1;
                  }
                }
              }
            }
          } else {
#line 21755
            goto _L___307;
          }
        } else
        _L___307: /* CIL Label */ 
#line 21782
        if ((int )event.type == 4) {
#line 21784
          if ((int )event.button.x >= color_picker_left) {
#line 21784
            if ((int )event.button.x < color_picker_left + img_color_picker->w) {
#line 21784
              if ((int )event.button.y >= color_picker_top) {
#line 21784
                if ((int )event.button.y < color_picker_top + img_color_picker->h) {
                  {
#line 21790
                  do_setcursor(cursor_hand);
#line 21795
                  x = (int )event.button.x - color_picker_left;
#line 21796
                  y = (int )event.button.y - color_picker_top;
#line 21798
                  getpixel_img_color_picker = getpixels[(img_color_picker->format)->BytesPerPixel];
#line 21801
                  SDL_FillRect(screen, & color_example_dest, ((((unsigned int )r & 255U) << 16) | (((unsigned int )g & 255U) << 8)) | ((unsigned int )b & 255U));
#line 21803
                  SDL_UpdateRect(screen, (Sint32 )color_example_dest.x, (Sint32 )color_example_dest.y,
                                 (Uint32 )color_example_dest.w, (Uint32 )color_example_dest.h);
                  }
                } else {
#line 21784
                  goto _L___304;
                }
              } else {
#line 21784
                goto _L___304;
              }
            } else {
#line 21784
              goto _L___304;
            }
          } else {
            _L___304: /* CIL Label */ 
            _L___305: /* CIL Label */ 
            _L___306: /* CIL Label */ 
            {
#line 21812
            SDL_FillRect(screen, & color_example_dest, ((((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 0) & 255U) << 16) | (((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 1) & 255U) << 8)) | ((unsigned int )*(*(color_hexes + (NUM_COLORS - 1)) + 2) & 255U));
#line 21817
            SDL_UpdateRect(screen, (Sint32 )color_example_dest.x, (Sint32 )color_example_dest.y,
                           (Uint32 )color_example_dest.w, (Uint32 )color_example_dest.h);
            }
#line 21824
            if ((int )event.button.x >= back_left) {
#line 21824
              if ((int )event.button.x < back_left + img_back->w) {
#line 21824
                if ((int )event.button.y >= back_top) {
#line 21824
                  if ((int )event.button.y < back_top + img_back->h) {
                    {
#line 21827
                    do_setcursor(cursor_hand);
                    }
                  } else {
                    {
                    {
                    {
                    {
#line 21829
                    do_setcursor(cursor_arrow);
                    }
                    }
                    }
                    }
                  }
                } else {
                  {
                  {
                  {
                  {
#line 21829
                  do_setcursor(cursor_arrow);
                  }
                  }
                  }
                  }
                }
              } else {
                {
                {
                {
                {
#line 21829
                do_setcursor(cursor_arrow);
                }
                }
                }
                }
              }
            } else {
              {
              {
              {
              {
#line 21829
              do_setcursor(cursor_arrow);
              }
              }
              }
              }
            }
          }
#line 21832
          oldpos_x = (int )event.motion.x;
#line 21833
          oldpos_y = (int )event.motion.y;
        } else
#line 21835
        if ((int )event.type == 7) {
          {
#line 21836
          handle_joyaxismotion(event, & motioner, & val_x, & val_y);
          }
        } else
#line 21838
        if ((int )event.type == 9) {
          {
#line 21839
          handle_joyhatmotion(event, oldpos_x, oldpos_y, & valhat_x, & valhat_y, & hatmotioner,
                              & old_hat_ticks);
          }
        } else
#line 21841
        if ((int )event.type == 8) {
          {
#line 21842
          handle_joyballmotion(event, oldpos_x, oldpos_y);
          }
        } else
#line 21844
        if ((int )event.type == 10) {
          {
          {
#line 21845
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        } else
#line 21844
        if ((int )event.type == 11) {
          {
          {
#line 21845
          handle_joybuttonupdown(event, oldpos_x, oldpos_y);
          }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 21848
    if (motioner | hatmotioner) {
      {
#line 21849
      handle_motioners(oldpos_x, oldpos_y, motioner, hatmotioner, (int )old_hat_ticks,
                       val_x, val_y, valhat_x, valhat_y);
      }
    }
    {
#line 21851
    SDL_Delay((Uint32 )10);
    }
#line 21724
    if (! (! done)) {
#line 21724
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 21858
  if (chose) {
    {
#line 21860
    getpixel_img_color_picker = getpixels[(img_color_picker->format)->BytesPerPixel];
#line 21863
    *(*(color_hexes + (NUM_COLORS - 1)) + 0) = r;
#line 21864
    *(*(color_hexes + (NUM_COLORS - 1)) + 1) = g;
#line 21865
    *(*(color_hexes + (NUM_COLORS - 1)) + 2) = b;
#line 21870
    tmp_btn_up = thumbnail(img_btn_up, color_button_w, color_button_h, 0);
#line 21871
    tmp_btn_down = thumbnail(img_btn_down, color_button_w, color_button_h, 0);
#line 21872
    img_color_btn_off = thumbnail(img_btn_off, color_button_w, color_button_h, 0);
#line 21874
    getpixel_tmp_btn_up = getpixels[(tmp_btn_up->format)->BytesPerPixel];
#line 21875
    getpixel_tmp_btn_down = getpixels[(tmp_btn_down->format)->BytesPerPixel];
#line 21876
    getpixel_img_paintwell = getpixels[(img_paintwell->format)->BytesPerPixel];
#line 21878
    rh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 1)) + 0)];
#line 21879
    gh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 1)) + 1)];
#line 21880
    bh = (double )sRGB_to_linear_table___1[*(*(color_hexes + (NUM_COLORS - 1)) + 2)];
#line 21882
    SDL_LockSurface(*(img_color_btns + (NUM_COLORS - 1)));
#line 21883
    SDL_LockSurface(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)));
#line 21885
    y = 0;
    }
    {
#line 21885
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 21885
      if (! (y < tmp_btn_up->h)) {
#line 21885
        goto while_break___3;
      }
#line 21887
      x = 0;
      {
#line 21887
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 21887
        if (! (x < tmp_btn_up->w)) {
#line 21887
          goto while_break___4;
        }
        {
#line 21894
        ru = (double )sRGB_to_linear_table___1[r];
#line 21895
        gu = (double )sRGB_to_linear_table___1[g];
#line 21896
        bu = (double )sRGB_to_linear_table___1[b];
#line 21899
        rd = (double )sRGB_to_linear_table___1[r];
#line 21900
        gd = (double )sRGB_to_linear_table___1[g];
#line 21901
        bd = (double )sRGB_to_linear_table___1[b];
#line 21904
        aa = (double )((int )a) / 255.;
#line 21906
        __cil_tmp55 = (*(getpixels[(img_color_picker_thumb->format)->BytesPerPixel]))(img_color_picker_thumb,
                                                                                      x,
                                                                                      y);
#line 21906
        (*(putpixels[((*(img_color_btns + (NUM_COLORS - 1)))->format)->BytesPerPixel]))(*(img_color_btns + (NUM_COLORS - 1)),
                                                                                        x,
                                                                                        y,
                                                                                        __cil_tmp55);
#line 21909
        __cil_tmp56 = (*(getpixels[(img_color_picker_thumb->format)->BytesPerPixel]))(img_color_picker_thumb,
                                                                                      x,
                                                                                      y);
#line 21909
        (*(putpixels[((*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)),
                                                                                                       x,
                                                                                                       y,
                                                                                                       __cil_tmp56);
        }
#line 21913
        if ((int )a == 255) {
          {
#line 21915
          __cil_tmp59 = linear_to_sRGB((float )(bh * aa + bu * (1. - aa)));
          }
          {
#line 21915
          __cil_tmp58 = linear_to_sRGB((float )(gh * aa + gu * (1. - aa)));
          }
          {
#line 21915
          __cil_tmp57 = linear_to_sRGB((float )(rh * aa + ru * (1. - aa)));
#line 21915
          (*(putpixels[((*(img_color_btns + (NUM_COLORS - 1)))->format)->BytesPerPixel]))(*(img_color_btns + (NUM_COLORS - 1)),
                                                                                          x,
                                                                                          y,
                                                                                          ((((unsigned int )__cil_tmp57 & 255U) << 16) | (((unsigned int )__cil_tmp58 & 255U) << 8)) | ((unsigned int )__cil_tmp59 & 255U));
#line 21921
          __cil_tmp62 = linear_to_sRGB((float )(bh * aa + bd * (1. - aa)));
          }
          {
#line 21921
          __cil_tmp61 = linear_to_sRGB((float )(gh * aa + gd * (1. - aa)));
          }
          {
#line 21921
          __cil_tmp60 = linear_to_sRGB((float )(rh * aa + rd * (1. - aa)));
#line 21921
          (*(putpixels[((*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)),
                                                                                                         x,
                                                                                                         y,
                                                                                                         ((((unsigned int )__cil_tmp60 & 255U) << 16) | (((unsigned int )__cil_tmp61 & 255U) << 8)) | ((unsigned int )__cil_tmp62 & 255U));
          }
        }
#line 21887
        x ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 21885
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 21930
    SDL_UnlockSurface(*(img_color_btns + (NUM_COLORS - 1)));
#line 21931
    SDL_UnlockSurface(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)));
    }
  }
  {
#line 21937
  update_canvas(0, 0, canvas->w, canvas->h);
  }
#line 21940
  return (chose);
}
}
#line 21947 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_putpixel(SDL_Surface *surface , int x , int y , Uint32 pixel ) 
{ 


  {
  {
#line 21949
  (*(putpixels[(surface->format)->BytesPerPixel]))(surface, x, y, pixel);
  }
  return;
}
}
#line 21955 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static Uint32 magic_getpixel(SDL_Surface *surface , int x , int y ) 
{ 
  Uint32 __cil_tmp4 ;

  {
  {
#line 21957
  __cil_tmp4 = (*(getpixels[(surface->format)->BytesPerPixel]))(surface, x, y);
  }
#line 21957
  return (__cil_tmp4);
}
}
#line 21963 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_xorpixel(SDL_Surface *surface , int x , int y ) 
{ 


  {
  {
#line 21965
  _xorpixel(surface, x, y);
  }
  return;
}
}
#line 21972 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_switchout(SDL_Surface *last ) 
{ 
  int was_clicking ;
  int grp ;
  int cur ;

  {
#line 21974
  was_clicking = 0;
#line 21976
  if (mouseaccessibility) {
#line 21976
    if (emulate_button_pressed) {
#line 21980
      emulate_button_pressed = 0;
#line 21981
      was_clicking = 1;
    }
  }
#line 21984
  if (cur_tool == 7) {
    {
#line 21988
    grp = magic_group;
#line 21989
    cur = cur_magic[magic_group];
#line 21991
    (*(magic_funcs[magics[grp][cur].handle_idx].switchout))(magic_api_struct, magics[grp][cur].idx,
                                                            magics[grp][cur].mode,
                                                            canvas, last);
#line 21993
    update_canvas(0, 0, canvas->w, canvas->h);
    }
#line 21995
    if (was_clicking) {
#line 21995
      if (magics[grp][cur].mode == 4) {
        {
#line 21998
        do_undo();
#line 21999
        tool_avail[9] = 0;
#line 22000
        draw_toolbar();
#line 22001
        update_screen_rect(& r_tools);
        }
      }
    }
  }
  return;
}
}
#line 22009 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void magic_switchin(SDL_Surface *last ) 
{ 
  int grp ;
  int cur ;

  {
#line 22011
  if (cur_tool == 7) {
    {
#line 22015
    grp = magic_group;
#line 22016
    cur = cur_magic[magic_group];
#line 22018
    (*(magic_funcs[magics[grp][cur].handle_idx].switchin))(magic_api_struct, magics[grp][cur].idx,
                                                           magics[grp][cur].mode,
                                                           canvas, last);
#line 22024
    redraw_tux_text();
#line 22026
    update_canvas(0, 0, canvas->w, canvas->h);
    }
  }
  return;
}
}
#line 22033 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int magic_modeint(int mode ) 
{ 


  {
#line 22035
  if (mode == 1) {
#line 22036
    return (0);
  } else
#line 22035
  if (mode == 8) {
#line 22036
    return (0);
  } else
#line 22035
  if (mode == 4) {
#line 22036
    return (0);
  } else
#line 22037
  if (mode == 2) {
#line 22038
    return (1);
  } else {
#line 22040
    return (0);
  }
}
}
#line 22046 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void add_label_node(int w , int h , Uint16 x , Uint16 y , SDL_Surface *label_node_surface ) 
{ 
  struct label_node *new_node___0 ;
  void *__cil_tmp7 ;
  struct label_node *aux_node ;
  unsigned int i ;
  int __cil_tmp10 ;

  {
  {
#line 22048
  __cil_tmp7 = malloc(sizeof(struct label_node ));
#line 22048
  new_node___0 = __cil_tmp7;
#line 22051
  i = (unsigned int )0;
#line 22053
  new_node___0->save_texttool_len = texttool_len;
  }
  {
#line 22054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22054
    if (! (i < texttool_len)) {
#line 22054
      goto while_break;
    }
#line 22056
    new_node___0->save_texttool_str[i] = texttool_str[i];
#line 22057
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 22059
  new_node___0->save_color.r = *(*(color_hexes + cur_color) + 0);
#line 22060
  new_node___0->save_color.g = *(*(color_hexes + cur_color) + 1);
#line 22061
  new_node___0->save_color.b = *(*(color_hexes + cur_color) + 2);
#line 22062
  new_node___0->save_width = w;
#line 22063
  new_node___0->save_height = h;
#line 22064
  new_node___0->save_x = x;
#line 22065
  new_node___0->save_y = y;
#line 22066
  new_node___0->save_cur_font = cur_font;
#line 22067
  new_node___0->save_text_state = text_state;
#line 22068
  new_node___0->save_text_size = text_size;
#line 22069
  new_node___0->save_undoid = 255;
#line 22071
  if (texttool_len > 0U) {
#line 22073
    new_node___0->is_enabled = ! 0;
  } else {
#line 22077
    new_node___0->is_enabled = 0;
  }
#line 22080
  new_node___0->save_font_type = (char *)((void *)0);
#line 22082
  if (label_node_to_edit) {
#line 22084
    new_node___0->disables = label_node_to_edit;
  } else {
#line 22087
    new_node___0->disables = (struct label_node *)((void *)0);
  }
#line 22089
  if (label_node_surface != (void *)0) {
#line 22091
    new_node___0->label_node_surface = label_node_surface;
#line 22092
    ((new_node___0->label_node_surface)->refcount) ++;
  } else {
#line 22095
    new_node___0->label_node_surface = (SDL_Surface *)((void *)0);
  }
#line 22098
  new_node___0->next_to_up_label_node = (struct label_node *)0;
#line 22100
  new_node___0->next_to_down_label_node = current_label_node;
#line 22101
  if (current_label_node) {
#line 22103
    aux_node = current_label_node;
#line 22104
    aux_node->next_to_up_label_node = new_node___0;
  }
#line 22107
  current_label_node = new_node___0;
#line 22109
  if (start_label_node == (void *)0) {
#line 22110
    start_label_node = current_label_node;
  }
#line 22112
  highlighted_label_node = new_node___0;
#line 22113
  if (highlighted_label_node->is_enabled == 0) {
    {
#line 22114
    cycle_highlighted_label_node();
    }
  }
  return;
}
}
#line 22121 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static struct label_node *search_label_list(struct label_node **ref_head , Uint16 x ,
                                            Uint16 y , int hover ) 
{ 
  struct label_node *current_node ;
  struct label_node *tmp_node ;
  unsigned int u ;
  int done ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  int i ;
  int j ;
  int k ;
  int __cil_tmp16 ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 22124
  tmp_node = (struct label_node *)((void *)0);
#line 22126
  done = 0;
#line 22131
  if (*ref_head == (void *)0) {
#line 22132
    return ((struct label_node *)((void *)0));
  }
#line 22134
  current_node = *ref_head;
  {
#line 22136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22136
    if (! (done != 1)) {
#line 22136
      goto while_break;
    }
#line 22138
    if ((int )x >= (int )current_node->save_x) {
#line 22140
      if ((int )y >= (int )current_node->save_y) {
#line 22142
        if ((int )x <= (int )current_node->save_x + current_node->save_width) {
#line 22144
          if ((int )y <= (int )current_node->save_y + current_node->save_height) {
#line 22146
            if (current_node->is_enabled == 1) {
#line 22148
              if (hover == 1) {
#line 22149
                return (current_node);
              }
#line 22150
              tmp_node = current_node;
#line 22151
              done = ! 0;
            }
          }
        }
      }
    }
#line 22157
    current_node = current_node->next_to_down_label_node;
#line 22158
    if (current_node == (void *)0) {
#line 22159
      current_node = current_label_node;
    }
#line 22160
    if (current_node == *ref_head) {
#line 22161
      done = ! 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 22164
  if (tmp_node != (void *)0) {
#line 22166
    select_texttool_len = tmp_node->save_texttool_len;
#line 22168
    u = (unsigned int )0;
    {
#line 22169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 22169
      if (! (u < select_texttool_len)) {
#line 22169
        goto while_break___0;
      }
#line 22171
      select_texttool_str[u] = tmp_node->save_texttool_str[u];
#line 22172
      u ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22175
    k = 0;
    {
#line 22175
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 22175
      if (! (k < NUM_COLORS)) {
#line 22175
        goto while_break___1;
      }
#line 22177
      if ((int )*(*(color_hexes + k) + 0) == (int )tmp_node->save_color.r) {
#line 22177
        if ((int )*(*(color_hexes + k) + 1) == (int )tmp_node->save_color.g) {
#line 22177
          if ((int )*(*(color_hexes + k) + 2) == (int )tmp_node->save_color.b) {
#line 22177
            if (k < NUM_COLORS - 1) {
#line 22181
              select_color = (unsigned int )k;
#line 22182
              cur_color = (unsigned int )k;
#line 22183
              goto while_break___1;
            }
          }
        }
      }
#line 22186
      if (k == NUM_COLORS - 1) {
        {
#line 22188
        cur_color = (unsigned int )(NUM_COLORS - 1);
#line 22189
        select_color = (unsigned int )(NUM_COLORS - 1);
#line 22190
        *(*(color_hexes + select_color) + 0) = tmp_node->save_color.r;
#line 22191
        *(*(color_hexes + select_color) + 1) = tmp_node->save_color.g;
#line 22192
        *(*(color_hexes + select_color) + 2) = tmp_node->save_color.b;
#line 22193
        SDL_LockSurface(*(img_color_btns + (NUM_COLORS - 1)));
#line 22194
        SDL_LockSurface(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)));
#line 22196
        j = 0;
        }
        {
#line 22196
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 22196
          if (! (j < 48)) {
#line 22196
            goto while_break___2;
          }
#line 22198
          i = 0;
          {
#line 22198
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 22198
            if (! (i < 48)) {
#line 22198
              goto while_break___3;
            }
#line 22202
            if ((int )a == 255) {
              {
#line 22204
              (*(putpixels[((*(img_color_btns + (NUM_COLORS - 1)))->format)->BytesPerPixel]))(*(img_color_btns + (NUM_COLORS - 1)),
                                                                                              i,
                                                                                              j,
                                                                                              ((((unsigned int )tmp_node->save_color.r & 255U) << 16) | (((unsigned int )tmp_node->save_color.g & 255U) << 8)) | ((unsigned int )tmp_node->save_color.b & 255U));
#line 22208
              (*(putpixels[((*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)),
                                                                                                             i,
                                                                                                             j,
                                                                                                             ((((unsigned int )tmp_node->save_color.r & 255U) << 16) | (((unsigned int )tmp_node->save_color.g & 255U) << 8)) | ((unsigned int )tmp_node->save_color.b & 255U));
              }
            }
#line 22198
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 22196
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 22215
        SDL_UnlockSurface(*(img_color_btns + (NUM_COLORS - 1)));
#line 22216
        SDL_UnlockSurface(*(img_color_btns + ((NUM_COLORS - 1) + NUM_COLORS)));
#line 22218
        draw_colors((unsigned int )2);
#line 22219
        render_brush();
        }
      }
#line 22175
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 22223
    select_width = tmp_node->save_width;
#line 22224
    select_height = tmp_node->save_height;
#line 22225
    select_x = tmp_node->save_x;
#line 22226
    select_y = tmp_node->save_y;
#line 22227
    select_cur_font = tmp_node->save_cur_font;
#line 22228
    select_text_state = tmp_node->save_text_state;
#line 22229
    select_text_size = tmp_node->save_text_size;
#line 22231
    return (tmp_node);
  }
#line 22234
  return ((struct label_node *)((void *)0));
}
}
#line 22240 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void rec_undo_label(void) 
{ 


  {
#line 22242
  if (first_label_node_in_redo_stack != (void *)0) {
    {
#line 22244
    delete_label_list(& first_label_node_in_redo_stack);
#line 22245
    first_label_node_in_redo_stack = (struct label_node *)((void *)0);
    }
  }
#line 22248
  if (coming_from_undo_or_redo) {
#line 22250
    coming_from_undo_or_redo = 0;
#line 22251
    return;
  }
#line 22262
  if (have_to_rec_label_node) {
#line 22264
    current_label_node->save_undoid = cur_undo;
#line 22265
    text_undo[cur_undo] = 1;
#line 22266
    have_to_rec_label_node = 0;
  } else {
#line 22270
    text_undo[cur_undo] = 0;
#line 22273
    if (current_label_node != (void *)0) {
#line 22273
      if (current_label_node->save_undoid == (cur_undo + 1) % 20) {
#line 22274
        current_label_node->save_undoid = 255;
      }
    }
  }
  return;
}
}
#line 22281 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_undo_label_node(void) 
{ 


  {
#line 22283
  if (text_undo[(cur_undo + 1) % 20] == 1) {
#line 22284
    if (current_label_node != (void *)0) {
#line 22286
      if (current_label_node->save_undoid == (cur_undo + 1) % 20) {
#line 22288
        if (current_label_node->disables != (void *)0) {
#line 22289
          (current_label_node->disables)->is_enabled = ! 0;
        }
#line 22291
        first_label_node_in_redo_stack = current_label_node;
#line 22292
        current_label_node = current_label_node->next_to_down_label_node;
#line 22294
        if (current_label_node == (void *)0) {
#line 22295
          start_label_node = current_label_node;
        }
        {
#line 22297
        highlighted_label_node = current_label_node;
#line 22298
        derender_node(& first_label_node_in_redo_stack);
#line 22299
        coming_from_undo_or_redo = ! 0;
        }
      }
    }
  }
#line 22302
  highlighted_label_node = current_label_node;
  return;
}
}
#line 22308 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_redo_label_node(void) 
{ 


  {
#line 22310
  if (first_label_node_in_redo_stack != (void *)0) {
#line 22310
    if (text_undo[cur_undo] == 1) {
#line 22312
      if (first_label_node_in_redo_stack->save_undoid == cur_undo) {
#line 22314
        current_label_node = first_label_node_in_redo_stack;
#line 22315
        first_label_node_in_redo_stack = current_label_node->next_to_up_label_node;
#line 22317
        if (start_label_node == (void *)0) {
#line 22318
          start_label_node = current_label_node;
        }
#line 22320
        highlighted_label_node = current_label_node;
#line 22321
        if (current_label_node->disables != (void *)0) {
          {
#line 22323
          (current_label_node->disables)->is_enabled = 0;
#line 22324
          derender_node(& current_label_node->disables);
          }
        } else {
          {
#line 22327
          simply_render_node(current_label_node);
          }
        }
#line 22329
        coming_from_undo_or_redo = ! 0;
      }
    }
  }
  return;
}
}
#line 22338 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void simply_render_node(struct label_node *node ) 
{ 
  SDL_Surface *tmp_surf ;
  SDL_Rect dest ;
  SDL_Rect src ;
  wchar_t *str ;
  wchar_t tmp_str[256] ;
  int j ;
  int w ;
  unsigned int i ;
  SDL_Color color ;
  wchar_t *__cil_tmp11 ;
  int __cil_tmp12 ;
  TuxPaint_Font *__cil_tmp13 ;
  SDL_Surface *__cil_tmp14 ;

  {
#line 22347
  if (node->label_node_surface == (void *)0) {
#line 22351
    color = node->save_color;
#line 22353
    text_state = node->save_text_state;
#line 22354
    text_size = node->save_text_size;
#line 22356
    i = (unsigned int )0;
    {
#line 22357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 22357
      if (! (i < node->save_texttool_len)) {
#line 22357
        goto while_break;
      }
#line 22359
      tmp_str[i] = node->save_texttool_str[i];
#line 22360
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 22362
    tmp_str[i] = '\000';
#line 22364
    str = uppercase_w((wchar_t *)tmp_str);
#line 22366
    text_state = node->save_text_state;
#line 22367
    text_size = node->save_text_size;
#line 22369
    j = 0;
    }
    {
#line 22369
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 22369
      if (! (j < num_font_families)) {
#line 22369
        goto while_break___0;
      }
#line 22371
      if (*(user_font_families + j)) {
#line 22371
        if ((*(user_font_families + j))->handle) {
          {
#line 22373
          TuxPaint_Font_CloseFont((*(user_font_families + j))->handle);
#line 22374
          (*(user_font_families + j))->handle = (TuxPaint_Font *)((void *)0);
          }
        }
      }
#line 22369
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 22378
    __cil_tmp13 = getfonthandle(node->save_cur_font);
#line 22378
    __cil_tmp14 = render_text_w(__cil_tmp13, str, color);
#line 22378
    tmp_surf = __cil_tmp14;
    }
#line 22379
    if (tmp_surf != (void *)0) {
#line 22381
      node->label_node_surface = tmp_surf;
    }
  }
#line 22384
  if (node->label_node_surface != (void *)0) {
#line 22386
    w = (node->label_node_surface)->w;
#line 22388
    cursor_textwidth = w;
#line 22391
    dest.x = (Sint16 )node->save_x;
#line 22392
    dest.y = (Sint16 )node->save_y;
#line 22394
    src.x = (Sint16 )0;
#line 22395
    src.y = (Sint16 )0;
#line 22396
    src.w = (Uint16 )(node->label_node_surface)->w;
#line 22397
    src.h = (Uint16 )(node->label_node_surface)->h;
#line 22399
    if ((int )dest.x + (int )src.w > (WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) {
#line 22400
      src.w = (Uint16 )(((WINDOW_WIDTH - (int )r_ttoolopt.w) - (int )r_ttools.w) - (int )dest.x);
    }
#line 22401
    if ((int )dest.y + (int )src.h > button_h * buttons_tall + (int )r_ttools.h) {
#line 22402
      src.h = (Uint16 )((button_h * buttons_tall + (int )r_ttools.h) - (int )dest.y);
    }
    {
#line 22404
    myblit(node->label_node_surface, & src, label, & dest);
#line 22406
    update_canvas((int )dest.x, (int )dest.y, (int )dest.x + (node->label_node_surface)->w,
                  (int )dest.y + (node->label_node_surface)->h);
#line 22409
    node->save_width = (node->label_node_surface)->w;
#line 22410
    node->save_height = (node->label_node_surface)->h;
    }
  }
  return;
}
}
#line 22417 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void render_all_nodes_starting_at(struct label_node **node ) 
{ 
  struct label_node *current_node ;

  {
#line 22421
  if (*node != (void *)0) {
#line 22423
    current_node = *node;
    {
#line 22424
    while (1) {
      while_continue: /* CIL Label */ ;
#line 22424
      if (! (current_node != first_label_node_in_redo_stack)) {
#line 22424
        goto while_break;
      }
#line 22426
      if (current_node->is_enabled == 1) {
        {
#line 22428
        simply_render_node(current_node);
        }
      }
#line 22430
      if (current_node->next_to_up_label_node == (void *)0) {
#line 22431
        return;
      }
#line 22432
      current_node = current_node->next_to_up_label_node;
    }
    while_break: /* CIL Label */ ;
    }
  }
  return;
}
}
#line 22441 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void derender_node(struct label_node **ref_head ) 
{ 
  SDL_Rect r_tmp_derender ;

  {
  {
#line 22445
  r_tmp_derender.w = (Uint16 )label->w;
#line 22446
  r_tmp_derender.h = (Uint16 )label->h;
#line 22447
  r_tmp_derender.x = (Sint16 )0;
#line 22448
  r_tmp_derender.y = (Sint16 )0;
#line 22450
  SDL_FillRect(label, & r_tmp_derender, 0U);
#line 22452
  render_all_nodes_starting_at(& start_label_node);
  }
  return;
}
}
#line 22458 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void delete_label_list(struct label_node **ref_head ) 
{ 
  struct label_node *current ;
  struct label_node *next ;

  {
#line 22460
  current = *ref_head;
  {
#line 22463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22463
    if (! (current != (void *)0)) {
#line 22463
      goto while_break;
    }
    {
#line 22465
    fflush(stdout);
#line 22467
    next = current->next_to_up_label_node;
    }
#line 22468
    if (current->label_node_surface) {
      {
#line 22469
      SDL_FreeSurface(current->label_node_surface);
      }
    }
    {
#line 22470
    free(current);
#line 22471
    current = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 22474
  *ref_head = (struct label_node *)((void *)0);
  return;
}
}
#line 22482 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void myblit(SDL_Surface *src_surf , SDL_Rect *src_rect , SDL_Surface *dest_surf ,
                   SDL_Rect *dest_rect ) 
{ 
  int x ;
  int y ;
  Uint8 src_r ;
  Uint8 src_g ;
  Uint8 src_b ;
  Uint8 src_a ;
  Uint8 dest_r ;
  Uint8 dest_g ;
  Uint8 dest_b ;
  Uint8 dest_a ;
  int __cil_tmp15 ;
  int __cil_tmp16 ;

  {
#line 22488
  x = (int )src_rect->x;
  {
#line 22488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22488
    if (! (x < (int )src_rect->w + (int )src_rect->x)) {
#line 22488
      goto while_break;
    }
#line 22489
    y = (int )src_rect->y;
    {
#line 22489
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 22489
      if (! (y < (int )src_rect->h + (int )src_rect->y)) {
#line 22489
        goto while_break___0;
      }
#line 22493
      if ((int )src_a != 0) {
#line 22495
        if ((int )src_a == 255) {
          {
#line 22496
          (*(putpixels[(dest_surf->format)->BytesPerPixel]))(dest_surf, x + (int )dest_rect->x,
                                                             y + (int )dest_rect->y,
                                                             (((((unsigned int )src_a & 255U) << 24) | (((unsigned int )src_r & 255U) << 16)) | (((unsigned int )src_g & 255U) << 8)) | ((unsigned int )src_b & 255U));
          }
        } else
#line 22502
        if ((int )dest_a == 0) {
          {
#line 22503
          (*(putpixels[(dest_surf->format)->BytesPerPixel]))(dest_surf, x + (int )dest_rect->x,
                                                             y + (int )dest_rect->y,
                                                             (((((unsigned int )src_a & 255U) << 24) | (((unsigned int )src_r & 255U) << 16)) | (((unsigned int )src_g & 255U) << 8)) | ((unsigned int )src_b & 255U));
          }
        } else {
          {
#line 22508
          dest_r = (Uint8 )(((int )src_r * (int )src_a) / 255 + ((((int )dest_r * (int )dest_a) * (255 - (int )src_a)) / 255) / 255);
#line 22509
          dest_g = (Uint8 )(((int )src_g * (int )src_a) / 255 + ((((int )dest_g * (int )dest_a) * (255 - (int )src_a)) / 255) / 255);
#line 22510
          dest_b = (Uint8 )(((int )src_b * (int )src_a) / 255 + ((((int )dest_b * (int )dest_a) * (255 - (int )src_a)) / 255) / 255);
#line 22511
          dest_a = (Uint8 )((int )src_a + ((int )dest_a * (255 - (int )src_a)) / 255);
#line 22512
          (*(putpixels[(dest_surf->format)->BytesPerPixel]))(dest_surf, x + (int )dest_rect->x,
                                                             y + (int )dest_rect->y,
                                                             (((((unsigned int )dest_a & 255U) << 24) | (((unsigned int )dest_r & 255U) << 16)) | (((unsigned int )dest_g & 255U) << 8)) | ((unsigned int )dest_b & 255U));
          }
        }
      }
#line 22489
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22488
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 22524 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void load_info_about_label_surface(FILE *lfi ) 
{ 
  struct label_node *new_node___0 ;
  int list_ctr ;
  int tmp_scale_w ;
  int tmp_scale_h ;
  SDL_Surface *label_node_surface ;
  SDL_Surface *label_node_surface_aux ;
  float new_text_size ;
  int k ;
  unsigned int l ;
  unsigned int tmp_pos ;
  int old_width ;
  int old_height ;
  int new_width ;
  int new_height ;
  float new_ratio ;
  float old_ratio ;
  float new_to_old_ratio ;
  int old_pos ;
  int new_pos ;
  int x ;
  int y ;
  int tmp_fscanf_return ;
  char *tmp_fgets_return ;
  Uint8 a ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  wchar_t tmp_char ;
  int __cil_tmp32 ;
  unsigned int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  int __cil_tmp40 ;
  int __cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  SDL_Surface *__cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  SDL_Surface *__cil_tmp52 ;
  int __cil_tmp53 ;
  double __cil_tmp54 ;
  int __cil_tmp55 ;
  int __cil_tmp56 ;

  {
  {
#line 22552
  SDL_FillRect(label, (SDL_Rect *)((void *)0), 0U);
#line 22556
  delete_label_list(& start_label_node);
#line 22557
  label_node_to_edit = (struct label_node *)((void *)0);
#line 22557
  highlighted_label_node = label_node_to_edit;
#line 22557
  first_label_node_in_redo_stack = highlighted_label_node;
#line 22557
  current_label_node = first_label_node_in_redo_stack;
#line 22557
  start_label_node = current_label_node;
#line 22559
  have_to_rec_label_node = 0;
  }
#line 22562
  if (lfi == (void *)0) {
#line 22563
    return;
  }
  {
#line 22564
  tmp_fscanf_return = fscanf(lfi, "%d\n", & list_ctr);
#line 22565
  tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & tmp_scale_w);
#line 22566
  tmp_fscanf_return = fscanf(lfi, "%d\n\n", & tmp_scale_h);
#line 22569
  old_width = tmp_scale_w;
#line 22570
  old_height = tmp_scale_h;
#line 22571
  new_width = (int )r_canvas.w;
#line 22572
  new_height = (int )r_canvas.h;
#line 22573
  new_ratio = (float )new_width / (float )new_height;
#line 22574
  old_ratio = (float )old_width / (float )old_height;
  }
#line 22575
  if (new_ratio < old_ratio) {
#line 22576
    new_to_old_ratio = (float )new_width / (float )old_width;
  } else {
#line 22578
    new_to_old_ratio = (float )new_height / (float )old_height;
  }
#line 22580
  k = 0;
  {
#line 22580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22580
    if (! (k < list_ctr)) {
#line 22580
      goto while_break;
    }
    {
#line 22582
    new_node___0 = (struct label_node *)malloc(sizeof(struct label_node ));
#line 22584
    tmp_fscanf_return = fscanf(lfi, "%u\nt\324U", & new_node___0->save_texttool_len);
#line 22599
    l = (unsigned int )0;
    }
    {
#line 22599
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 22599
      if (! (l < new_node___0->save_texttool_len)) {
#line 22599
        goto while_break___0;
      }
      {
#line 22601
      tmp_fscanf_return = fscanf(lfi, "%lc", & tmp_char);
#line 22602
      new_node___0->save_texttool_str[l] = tmp_char;
      }
#line 22599
      l ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 22604
    tmp_fscanf_return = fscanf(lfi, "\n");
#line 22606
    tmp_fscanf_return = fscanf(lfi, "%u\nt\324U", & l);
#line 22607
    new_node___0->save_color.r = (Uint8 )l;
#line 22608
    tmp_fscanf_return = fscanf(lfi, "%u\n", & l);
#line 22609
    new_node___0->save_color.g = (Uint8 )l;
#line 22610
    tmp_fscanf_return = fscanf(lfi, "%u\nt\324U", & l);
#line 22611
    new_node___0->save_color.b = (Uint8 )l;
#line 22612
    tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & new_node___0->save_width);
#line 22613
    tmp_fscanf_return = fscanf(lfi, "%d\n", & new_node___0->save_height);
#line 22614
    tmp_fscanf_return = fscanf(lfi, "%d\n", & tmp_pos);
#line 22615
    old_pos = (int )tmp_pos;
    }
#line 22617
    if (new_ratio < old_ratio) {
      {
#line 22619
      new_pos = (int )((float )old_pos * new_to_old_ratio);
#line 22620
      tmp_pos = (unsigned int )new_pos;
#line 22621
      new_node___0->save_x = (Uint16 )tmp_pos;
#line 22622
      tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & tmp_pos);
#line 22623
      old_pos = (int )tmp_pos;
#line 22624
      new_pos = (int )((float )old_pos * new_to_old_ratio + ((float )new_height - (float )old_height * new_to_old_ratio) / (float )2);
#line 22625
      tmp_pos = (unsigned int )new_pos;
#line 22626
      new_node___0->save_y = (Uint16 )tmp_pos;
      }
    } else {
      {
#line 22630
      new_pos = (int )((float )old_pos * new_to_old_ratio + ((float )new_width - (float )old_width * new_to_old_ratio) / (float )2);
#line 22631
      tmp_pos = (unsigned int )new_pos;
#line 22632
      new_node___0->save_x = (Uint16 )tmp_pos;
#line 22633
      tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & tmp_pos);
#line 22634
      old_pos = (int )tmp_pos;
#line 22635
      new_pos = (int )((float )old_pos * new_to_old_ratio);
#line 22636
      tmp_pos = (unsigned int )new_pos;
#line 22637
      new_node___0->save_y = (Uint16 )tmp_pos;
      }
    }
    {
#line 22644
    tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & new_node___0->save_cur_font);
#line 22645
    new_node___0->save_cur_font = 0;
#line 22647
    new_node___0->save_font_type = (char *)malloc((unsigned long )64);
#line 22648
    tmp_fgets_return = fgets(new_node___0->save_font_type, 64, lfi);
#line 22651
    tmp_fscanf_return = fscanf(lfi, "%d\nt\324U", & new_node___0->save_text_state);
#line 22652
    tmp_fscanf_return = fscanf(lfi, "%u\n", & new_node___0->save_text_size);
#line 22654
    label_node_surface = SDL_CreateRGBSurface(screen->flags, new_node___0->save_width,
                                              new_node___0->save_height, (int )(screen->format)->BitsPerPixel,
                                              (screen->format)->Rmask, (screen->format)->Gmask,
                                              (screen->format)->Bmask, 4278190080U);
#line 22661
    SDL_LockSurface(label_node_surface);
#line 22662
    x = 0;
    }
    {
#line 22662
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 22662
      if (! (x < new_node___0->save_width)) {
#line 22662
        goto while_break___1;
      }
#line 22663
      y = 0;
      {
#line 22663
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 22663
        if (! (y < new_node___0->save_height)) {
#line 22663
          goto while_break___2;
        }
        {
#line 22665
        __cil_tmp49 = fgetc(lfi);
#line 22665
        a = (Uint8 )__cil_tmp49;
#line 22666
        (*(putpixels[(label_node_surface->format)->BytesPerPixel]))(label_node_surface,
                                                                    x, y, (((((unsigned int )a & 255U) << 24) | (((unsigned int )new_node___0->save_color.r & 255U) << 16)) | (((unsigned int )new_node___0->save_color.g & 255U) << 8)) | ((unsigned int )new_node___0->save_color.b & 255U));
        }
#line 22663
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 22662
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 22672
    SDL_UnlockSurface(label_node_surface);
#line 22674
    new_text_size = (float )new_node___0->save_text_size * new_to_old_ratio;
#line 22675
    label_node_surface_aux = zoom(label_node_surface, (int )((float )label_node_surface->w * new_to_old_ratio),
                                  (int )((float )label_node_surface->h * new_to_old_ratio));
#line 22677
    SDL_FreeSurface(label_node_surface);
#line 22678
    new_node___0->label_node_surface = label_node_surface_aux;
#line 22679
    ((new_node___0->label_node_surface)->refcount) ++;
#line 22680
    SDL_FreeSurface(label_node_surface_aux);
    }
#line 22682
    if ((unsigned long )((unsigned int )new_text_size) > sizeof(text_sizes___1) / sizeof(text_sizes___1[0]) - 1UL) {
#line 22683
      new_node___0->save_text_size = (unsigned int )(sizeof(text_sizes___1) / sizeof(text_sizes___1[0]) - 1UL);
    } else
#line 22684
    if ((unsigned int )new_text_size > 0U) {
      {
#line 22685
      __cil_tmp54 = floor((double )new_text_size + 0.5);
#line 22685
      new_node___0->save_text_size = (unsigned int )__cil_tmp54;
      }
    } else {
#line 22687
      new_node___0->save_text_size = 0U;
    }
    {
#line 22690
    new_node___0->save_undoid = 255;
#line 22691
    new_node___0->is_enabled = ! 0;
#line 22692
    new_node___0->disables = (struct label_node *)((void *)0);
#line 22693
    new_node___0->next_to_down_label_node = (struct label_node *)((void *)0);
#line 22694
    new_node___0->next_to_up_label_node = (struct label_node *)((void *)0);
#line 22695
    tmp_fscanf_return = fscanf(lfi, "\n");
    }
#line 22697
    if (current_label_node == (void *)0) {
#line 22699
      current_label_node = new_node___0;
#line 22700
      start_label_node = current_label_node;
    } else {
#line 22704
      new_node___0->next_to_down_label_node = current_label_node;
#line 22705
      current_label_node->next_to_up_label_node = new_node___0;
#line 22706
      current_label_node = new_node___0;
    }
    {
#line 22709
    highlighted_label_node = current_label_node;
#line 22710
    simply_render_node(current_label_node);
    }
#line 22580
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 22713
  first_label_node_in_redo_stack = (struct label_node *)((void *)0);
#line 22714
  fclose(lfi);
  }
#line 22716
  if (font_thread_done) {
    {
#line 22717
    set_label_fonts();
    }
  }
  return;
}
}
#line 22723 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void set_label_fonts(void) 
{ 
  struct label_node *node ;
  int i ;
  char *ttffont ;
  Uint32 c ;
  TuxPaint_Font *__cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  Uint32 __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  Uint32 __cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;

  {
#line 22729
  node = current_label_node;
  {
#line 22730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22730
    if (! (node != (void *)0)) {
#line 22730
      goto while_break;
    }
#line 22732
    i = 0;
    {
#line 22732
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 22732
      if (! (i < num_font_families)) {
#line 22732
        goto while_break___0;
      }
      {
#line 22739
      ttffont = TTF_FontFaceFamilyName(__cil_tmp5->ttf_font);
#line 22740
      c = (Uint32 )0;
      }
      {
#line 22740
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 22740
        if (! ((unsigned long )c < __cil_tmp7)) {
#line 22740
          goto while_break___1;
        }
#line 22741
        if ((int )*(ttffont + c) == 10) {
#line 22742
          *(ttffont + c) = (char )'\000';
        }
#line 22740
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 22743
      c = (Uint32 )0;
      {
#line 22743
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 22743
        if (! ((unsigned long )c < __cil_tmp9)) {
#line 22743
          goto while_break___2;
        }
#line 22744
        if ((int )*(node->save_font_type + c) == 10) {
#line 22745
          *(node->save_font_type + c) = (char )'\000';
        }
#line 22743
        c ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 22752
      __cil_tmp11 = strcmp((char const   *)node->save_font_type, (char const   *)ttffont);
      }
#line 22752
      if (__cil_tmp11 == 0) {
#line 22758
        node->save_cur_font = i;
#line 22759
        goto while_break___0;
      } else {
        {
#line 22761
        __cil_tmp13 = strstr((char const   *)node->save_font_type, (char const   *)ttffont);
        }
        {
#line 22761
        __cil_tmp12 = strstr((char const   *)ttffont, (char const   *)node->save_font_type);
        }
#line 22761
        if (__cil_tmp12) {
#line 22766
          node->save_cur_font = i;
        } else
#line 22761
        if (__cil_tmp13) {
#line 22766
          node->save_cur_font = i;
        }
      }
#line 22732
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 22770
    if (node->save_cur_font > num_font_families) {
#line 22771
      node->save_cur_font = 0;
    }
    {
#line 22773
    free(node->save_font_type);
#line 22774
    node->save_font_type = (char *)((void *)0);
#line 22775
    node = node->next_to_down_label_node;
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 22783 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void tmp_apply_uncommited_text(void) 
{ 
  SDL_Surface *__cil_tmp1 ;

  {
#line 22785
  have_to_rec_label_node_back = have_to_rec_label_node;
#line 22787
  if (texttool_len > 0U) {
#line 22789
    if (cur_tool == 4) {
      {
      {
      {
      {
      {
      {
#line 22794
      canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                         (canvas->format)->Rmask, (canvas->format)->Gmask,
                                         (canvas->format)->Bmask, (Uint32 )0);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 22799
      SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 22800
      do_render_cur_text(1);
      }
      }
      }
      }
      }
      }
    } else
#line 22789
    if (old_tool == 4) {
#line 22789
      if (cur_tool == 14) {
        {
        {
        {
        {
        {
        {
#line 22794
        canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                           (canvas->format)->Rmask, (canvas->format)->Gmask,
                                           (canvas->format)->Bmask, (Uint32 )0);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22799
        SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22800
        do_render_cur_text(1);
        }
        }
        }
        }
        }
        }
      } else
#line 22789
      if (cur_tool == 13) {
        {
        {
        {
        {
        {
        {
#line 22794
        canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                           (canvas->format)->Rmask, (canvas->format)->Gmask,
                                           (canvas->format)->Bmask, (Uint32 )0);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22799
        SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22800
        do_render_cur_text(1);
        }
        }
        }
        }
        }
        }
      } else
#line 22789
      if (cur_tool == 12) {
        {
        {
        {
        {
        {
        {
#line 22794
        canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                           (canvas->format)->Rmask, (canvas->format)->Gmask,
                                           (canvas->format)->Bmask, (Uint32 )0);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22799
        SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22800
        do_render_cur_text(1);
        }
        }
        }
        }
        }
        }
      } else
#line 22789
      if (cur_tool == 11) {
        {
        {
        {
        {
        {
        {
#line 22794
        canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                           (canvas->format)->Rmask, (canvas->format)->Gmask,
                                           (canvas->format)->Bmask, (Uint32 )0);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22799
        SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22800
        do_render_cur_text(1);
        }
        }
        }
        }
        }
        }
      } else
#line 22789
      if (cur_tool == 15) {
        {
        {
        {
        {
        {
        {
#line 22794
        canvas_back = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h, (int )(canvas->format)->BitsPerPixel,
                                           (canvas->format)->Rmask, (canvas->format)->Gmask,
                                           (canvas->format)->Bmask, (Uint32 )0);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22799
        SDL_UpperBlit(canvas, (SDL_Rect *)((void *)0), canvas_back, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22800
        do_render_cur_text(1);
        }
        }
        }
        }
        }
        }
      } else {
#line 22789
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 22803
    if (cur_tool == 5) {
      {
      {
      {
      {
      {
      {
#line 22808
      do_render_cur_text(1);
      }
      }
      }
      }
      }
#line 22809
      current_label_node->save_undoid = 253;
      }
    } else
#line 22803
    if (old_tool == 5) {
#line 22803
      if (cur_tool == 14) {
        {
        {
        {
        {
        {
        {
#line 22808
        do_render_cur_text(1);
        }
        }
        }
        }
        }
#line 22809
        current_label_node->save_undoid = 253;
        }
      } else
#line 22803
      if (cur_tool == 13) {
        {
        {
        {
        {
        {
        {
#line 22808
        do_render_cur_text(1);
        }
        }
        }
        }
        }
#line 22809
        current_label_node->save_undoid = 253;
        }
      } else
#line 22803
      if (cur_tool == 12) {
        {
        {
        {
        {
        {
        {
#line 22808
        do_render_cur_text(1);
        }
        }
        }
        }
        }
#line 22809
        current_label_node->save_undoid = 253;
        }
      } else
#line 22803
      if (cur_tool == 11) {
        {
        {
        {
        {
        {
        {
#line 22808
        do_render_cur_text(1);
        }
        }
        }
        }
        }
#line 22809
        current_label_node->save_undoid = 253;
        }
      } else
#line 22803
      if (cur_tool == 15) {
        {
        {
        {
        {
        {
        {
#line 22808
        do_render_cur_text(1);
        }
        }
        }
        }
        }
#line 22809
        current_label_node->save_undoid = 253;
        }
      }
    }
  } else
#line 22812
  if (label_node_to_edit) {
#line 22812
    if (cur_tool == 5) {
      {
      {
      {
      {
      {
      {
#line 22817
      add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
      }
      }
      }
      }
      }
#line 22818
      current_label_node->is_enabled = 0;
#line 22819
      current_label_node->save_undoid = 253;
      {
      {
      {
      {
      {
#line 22821
      derender_node(& label_node_to_edit);
      }
      }
      }
      }
      }
      }
    } else {
#line 22812
      goto _L___308;
    }
  } else
  _L___308: /* CIL Label */ 
#line 22812
  if (label_node_to_edit) {
#line 22812
    if (old_tool == 5) {
#line 22812
      if (cur_tool == 14) {
        {
        {
        {
        {
        {
        {
#line 22817
        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
        }
        }
        }
        }
        }
#line 22818
        current_label_node->is_enabled = 0;
#line 22819
        current_label_node->save_undoid = 253;
        {
        {
        {
        {
        {
#line 22821
        derender_node(& label_node_to_edit);
        }
        }
        }
        }
        }
        }
      } else
#line 22812
      if (cur_tool == 13) {
        {
        {
        {
        {
        {
        {
#line 22817
        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
        }
        }
        }
        }
        }
#line 22818
        current_label_node->is_enabled = 0;
#line 22819
        current_label_node->save_undoid = 253;
        {
        {
        {
        {
        {
#line 22821
        derender_node(& label_node_to_edit);
        }
        }
        }
        }
        }
        }
      } else
#line 22812
      if (cur_tool == 12) {
        {
        {
        {
        {
        {
        {
#line 22817
        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
        }
        }
        }
        }
        }
#line 22818
        current_label_node->is_enabled = 0;
#line 22819
        current_label_node->save_undoid = 253;
        {
        {
        {
        {
        {
#line 22821
        derender_node(& label_node_to_edit);
        }
        }
        }
        }
        }
        }
      } else
#line 22812
      if (cur_tool == 11) {
        {
        {
        {
        {
        {
        {
#line 22817
        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
        }
        }
        }
        }
        }
#line 22818
        current_label_node->is_enabled = 0;
#line 22819
        current_label_node->save_undoid = 253;
        {
        {
        {
        {
        {
#line 22821
        derender_node(& label_node_to_edit);
        }
        }
        }
        }
        }
        }
      } else
#line 22812
      if (cur_tool == 15) {
        {
        {
        {
        {
        {
        {
#line 22817
        add_label_node(0, 0, (Uint16 )0, (Uint16 )0, (SDL_Surface *)((void *)0));
        }
        }
        }
        }
        }
#line 22818
        current_label_node->is_enabled = 0;
#line 22819
        current_label_node->save_undoid = 253;
        {
        {
        {
        {
        {
#line 22821
        derender_node(& label_node_to_edit);
        }
        }
        }
        }
        }
        }
      }
    }
  }
  return;
}
}
#line 22828 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void undo_tmp_applied_text(void) 
{ 
  struct label_node *aux_label_node ;

  {
#line 22832
  if (texttool_len > 0U) {
#line 22834
    if (cur_tool == 4) {
      {
      {
      {
      {
      {
      {
#line 22840
      SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 22841
      SDL_FreeSurface(canvas_back);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 22842
      do_render_cur_text(0);
      }
      }
      }
      }
      }
      }
    } else
#line 22834
    if (cur_tool == 14) {
#line 22834
      if (old_tool == 4) {
        {
        {
        {
        {
        {
        {
#line 22840
        SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22841
        SDL_FreeSurface(canvas_back);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22842
        do_render_cur_text(0);
        }
        }
        }
        }
        }
        }
      } else {
#line 22834
        goto _L___311;
      }
    } else
    _L___311: /* CIL Label */ 
#line 22834
    if (cur_tool == 13) {
#line 22834
      if (old_tool == 4) {
        {
        {
        {
        {
        {
        {
#line 22840
        SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22841
        SDL_FreeSurface(canvas_back);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22842
        do_render_cur_text(0);
        }
        }
        }
        }
        }
        }
      } else {
#line 22834
        goto _L___310;
      }
    } else
    _L___310: /* CIL Label */ 
#line 22834
    if (cur_tool == 12) {
#line 22834
      if (old_tool == 4) {
        {
        {
        {
        {
        {
        {
#line 22840
        SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22841
        SDL_FreeSurface(canvas_back);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22842
        do_render_cur_text(0);
        }
        }
        }
        }
        }
        }
      } else {
#line 22834
        goto _L___309;
      }
    } else
    _L___309: /* CIL Label */ 
#line 22834
    if (cur_tool == 11) {
#line 22834
      if (old_tool == 4) {
        {
        {
        {
        {
        {
        {
#line 22840
        SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22841
        SDL_FreeSurface(canvas_back);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22842
        do_render_cur_text(0);
        }
        }
        }
        }
        }
        }
      } else {
#line 22834
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 22834
    if (cur_tool == 15) {
#line 22834
      if (old_tool == 4) {
        {
        {
        {
        {
        {
        {
#line 22840
        SDL_UpperBlit(canvas_back, (SDL_Rect *)((void *)0), canvas, (SDL_Rect *)((void *)0));
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22841
        SDL_FreeSurface(canvas_back);
        }
        }
        }
        }
        }
        {
        {
        {
        {
        {
#line 22842
        do_render_cur_text(0);
        }
        }
        }
        }
        }
        }
      }
    }
  }
#line 22845
  if (current_label_node != (void *)0) {
#line 22845
    if (current_label_node->save_undoid == 253) {
#line 22847
      aux_label_node = current_label_node;
#line 22848
      current_label_node = current_label_node->next_to_down_label_node;
#line 22850
      if (current_label_node == (void *)0) {
#line 22851
        start_label_node = (struct label_node *)((void *)0);
      } else {
#line 22853
        current_label_node->next_to_up_label_node = first_label_node_in_redo_stack;
      }
      {
#line 22855
      derender_node(& aux_label_node);
#line 22856
      delete_label_list(& aux_label_node);
#line 22857
      have_to_rec_label_node = have_to_rec_label_node_back;
#line 22858
      do_render_cur_text(0);
      }
    }
  }
  return;
}
}
#line 22867 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void highlight_label_nodes(void) 
{ 
  int j ;
  SDL_Rect rect ;
  SDL_Rect rect1 ;
  struct label_node *aux_node ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 22873
  if (highlighted_label_node != (void *)0) {
#line 22875
    aux_node = highlighted_label_node->next_to_up_label_node;
#line 22876
    if (aux_node == first_label_node_in_redo_stack) {
#line 22877
      aux_node = start_label_node;
    }
    {
#line 22880
    while (1) {
      while_continue: /* CIL Label */ ;
#line 22880
      if (! (aux_node != highlighted_label_node)) {
#line 22880
        goto while_break;
      }
#line 22882
      if (aux_node->is_enabled) {
        {
#line 22884
        rect.x = (Sint16 )((int )aux_node->save_x + button_w * 2);
#line 22885
        rect.y = (Sint16 )aux_node->save_y;
#line 22886
        rect.w = (Uint16 )aux_node->save_width;
#line 22887
        rect.h = (Uint16 )aux_node->save_height;
#line 22889
        SDL_FillRect(screen, & rect, 0U);
#line 22891
        j = 2;
        }
        {
#line 22891
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 22891
          if (! (j < aux_node->save_height / 4)) {
#line 22891
            goto while_break___0;
          }
#line 22893
          rect1.x = (Sint16 )((int )rect.x + j);
#line 22894
          rect1.y = (Sint16 )((int )rect.y + j);
#line 22895
          rect1.w = (Uint16 )((int )rect.w - 2 * j);
#line 22896
          if ((int )rect1.w < 2) {
#line 22897
            goto while_break___0;
          }
          {
#line 22898
          rect1.h = (Uint16 )((int )rect.h - 2 * j);
#line 22899
          SDL_FillRect(screen, & rect1, (((255U << 24) | (((unsigned int )(((4 * j) * 200) / aux_node->save_height) & 255U) << 16)) | (((unsigned int )(((4 * j) * 200) / aux_node->save_height) & 255U) << 8)) | ((unsigned int )(((4 * j) * 200) / aux_node->save_height) & 255U));
#line 22906
          SDL_UpperBlit(aux_node->label_node_surface, (SDL_Rect *)((void *)0), screen,
                        & rect);
          }
#line 22891
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 22911
      aux_node = aux_node->next_to_up_label_node;
#line 22912
      if (aux_node == first_label_node_in_redo_stack) {
#line 22913
        aux_node = start_label_node;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 22916
    aux_node = highlighted_label_node;
#line 22917
    rect.x = (Sint16 )((int )aux_node->save_x + button_w * 2);
#line 22918
    rect.y = (Sint16 )aux_node->save_y;
#line 22919
    rect.w = (Uint16 )aux_node->save_width;
#line 22920
    rect.h = (Uint16 )aux_node->save_height;
#line 22921
    SDL_FillRect(screen, & rect, (255U << 24) | (255U << 16));
#line 22923
    j = 2;
    }
    {
#line 22923
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 22923
      if (! (j < aux_node->save_height / 4)) {
#line 22923
        goto while_break___1;
      }
#line 22925
      rect1.x = (Sint16 )((int )rect.x + j);
#line 22926
      rect1.y = (Sint16 )((int )rect.y + j);
#line 22927
      rect1.w = (Uint16 )((int )rect.w - 2 * j);
#line 22928
      if ((int )rect1.w < 2) {
#line 22929
        goto while_break___1;
      }
      {
#line 22930
      rect1.h = (Uint16 )((int )rect.h - 2 * j);
#line 22931
      SDL_FillRect(screen, & rect1, ((255U << 24) | (255U << 16)) | (((unsigned int )(((4 * j) * 225) / aux_node->save_height) & 255U) << 8));
#line 22935
      SDL_UpperBlit(aux_node->label_node_surface, (SDL_Rect *)((void *)0), screen,
                    & rect);
      }
#line 22923
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 22938
    SDL_Flip(screen);
    }
  }
  return;
}
}
#line 22945 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void cycle_highlighted_label_node(void) 
{ 
  struct label_node *aux_node ;

  {
#line 22949
  if (highlighted_label_node) {
#line 22951
    aux_node = highlighted_label_node->next_to_down_label_node;
#line 22952
    if (aux_node == (void *)0) {
#line 22953
      aux_node = current_label_node;
    }
#line 22954
    if (aux_node->is_enabled) {
#line 22955
      highlighted_label_node = aux_node;
    } else {
      {
#line 22957
      while (1) {
        while_continue: /* CIL Label */ ;
#line 22957
        if (! (aux_node != highlighted_label_node && aux_node->is_enabled == 0)) {
#line 22957
          goto while_break;
        }
#line 22959
        aux_node = aux_node->next_to_down_label_node;
#line 22960
        if (aux_node == (void *)0) {
#line 22961
          aux_node = current_label_node;
        }
#line 22962
        if (aux_node->is_enabled) {
#line 22963
          highlighted_label_node = aux_node;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  return;
}
}
#line 22972 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int are_labels(void) 
{ 
  struct label_node *aux_node ;

  {
#line 22976
  if (current_label_node) {
#line 22978
    aux_node = current_label_node;
    {
#line 22979
    while (1) {
      while_continue: /* CIL Label */ ;
#line 22979
      if (! aux_node) {
#line 22979
        goto while_break;
      }
#line 22981
      if (aux_node->is_enabled) {
#line 22982
        return (! 0);
      }
#line 22983
      aux_node = aux_node->next_to_down_label_node;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 22986
  return (0);
}
}
#line 22992 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int chunk_is_valid(char const   *chunk_name , png_unknown_chunk unknown ) 
{ 
  unsigned int count ;
  unsigned int fields ;
  int new_field ;
  char *control ;
  char *softwr ;
  int unc_size ;
  int comp ;
  unsigned int __cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;

  {
#line 22999
  if ((int )*(chunk_name + 0) == (int )unknown.name[0]) {
#line 22999
    if ((int )*(chunk_name + 1) == (int )unknown.name[1]) {
#line 22999
      if ((int )*(chunk_name + 2) == (int )unknown.name[2]) {
#line 22999
        if ((int )*(chunk_name + 3) == (int )unknown.name[3]) {
#line 22999
          if (50UL < unknown.size) {
#line 22999
            if (84 == (int )*(unknown.data + 0)) {
#line 22999
              if (117 == (int )*(unknown.data + 1)) {
#line 22999
                if (120 == (int )*(unknown.data + 2)) {
#line 22999
                  if (112 == (int )*(unknown.data + 3)) {
#line 22999
                    if (97 == (int )*(unknown.data + 4)) {
#line 22999
                      if (105 == (int )*(unknown.data + 5)) {
#line 22999
                        if (110 == (int )*(unknown.data + 6)) {
#line 22999
                          if (116 == (int )*(unknown.data + 7)) {
#line 22999
                            if (10 == (int )*(unknown.data + 8)) {
#line 23013
                              count = (unsigned int )9;
#line 23014
                              fields = (unsigned int )1;
#line 23015
                              new_field = 1;
                              {
#line 23016
                              while (1) {
                                while_continue: /* CIL Label */ ;
#line 23016
                                if (! (count < 50U)) {
#line 23016
                                  goto while_break;
                                }
#line 23018
                                if ((int )*(unknown.data + count) == 10) {
#line 23020
                                  if (new_field == 1) {
#line 23021
                                    return (0);
                                  }
#line 23022
                                  fields ++;
#line 23023
                                  if (fields == 4U) {
                                    {
#line 23025
                                    control = (char *)malloc((unsigned long )50);
#line 23026
                                    softwr = (char *)malloc((unsigned long )50);
#line 23027
                                    sscanf((char const   *)((char *)unknown.data),
                                           "%s\n%s\n%d\n%d\n", control, softwr, & unc_size,
                                           & comp);
#line 23028
                                    free(control);
#line 23029
                                    free(softwr);
                                    }
#line 23030
                                    if ((unsigned long )((count + (unsigned int )comp) + 1U) == unknown.size) {
#line 23031
                                      return (! 0);
                                    } else {
#line 23033
                                      return (0);
                                    }
                                  }
#line 23035
                                  new_field = 1;
                                } else {
#line 23040
                                  if (fields < 4U) {
#line 23040
                                    if (fields > 1U) {
#line 23040
                                      if (! ((((((((((int )*(unknown.data + count) == 48 || (int )*(unknown.data + count) == 49) || (int )*(unknown.data + count) == 50) || (int )*(unknown.data + count) == 51) || (int )*(unknown.data + count) == 52) || (int )*(unknown.data + count) == 53) || (int )*(unknown.data + count) == 54) || (int )*(unknown.data + count) == 55) || (int )*(unknown.data + count) == 56) || (int )*(unknown.data + count) == 57)) {
#line 23049
                                        return (0);
                                      }
                                    }
                                  }
#line 23051
                                  new_field = 0;
                                }
#line 23053
                                count ++;
                              }
                              while_break: /* CIL Label */ ;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 23057
  return (0);
}
}
#line 23063 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
Bytef *get_chunk_data(FILE *fp , char *fname , png_structp png_ptr , png_infop info_ptr ,
                      char const   *chunk_name , png_unknown_chunk unknown , int *unc_size ) 
{ 
  unsigned int i ;
  int f ;
  int count ;
  int comp ;
  int unc_err ;
  char *control ;
  char *softwr ;
  Bytef *comp_buff ;
  Bytef *unc_buff ;
  z_streamp zstp ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  int *__cil_tmp21 ;
  char *__cil_tmp22 ;
  int __cil_tmp23 ;
  unsigned int __cil_tmp24 ;
  void *__cil_tmp25 ;
  int *__cil_tmp26 ;
  char *__cil_tmp27 ;
  void *__cil_tmp28 ;
  int __cil_tmp29 ;
  int *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 23074
  control = (char *)malloc((unsigned long )50);
#line 23075
  softwr = (char *)malloc((unsigned long )50);
#line 23076
  sscanf((char const   *)((char *)unknown.data), "%s\n%s\n%d\n%d\n", control, softwr,
         unc_size, & comp);
#line 23077
  free(control);
#line 23078
  free(softwr);
#line 23079
  comp_buff = (Bytef *)malloc((unsigned long )comp * sizeof(Bytef ));
  }
#line 23081
  if (comp_buff == (void *)0) {
    {
#line 23083
    fclose(fp);
#line 23085
    png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23087
    fprintf(stderr, "\nError: Couldn\'t recover the embedded data in %s\n\nUnable to allocate memory for the compressed buffer for %s\n\n",
            fname, chunk_name);
#line 23090
    __cil_tmp21 = __errno_location();
#line 23090
    __cil_tmp22 = strerror(*__cil_tmp21);
#line 23090
    draw_tux_text(4, (char const   *)__cil_tmp22, 0);
    }
#line 23091
    return ((Bytef *)((void *)0));
  }
#line 23093
  f = 0;
#line 23094
  count = 0;
#line 23096
  i = (unsigned int )0;
  {
#line 23096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23096
    if (! ((unsigned long )i < unknown.size)) {
#line 23096
      goto while_break;
    }
#line 23098
    if (f > 3) {
#line 23100
      *(comp_buff + (i - (unsigned int )count)) = *(unknown.data + i);
    }
#line 23104
    if ((int )*(unknown.data + i) == 10) {
#line 23104
      if (f < 4) {
#line 23106
        f ++;
#line 23107
        count = (int )(i + 1U);
      }
    }
#line 23096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23111
  unc_buff = (Bytef *)malloc((unsigned long )*unc_size * sizeof(Bytef ));
  }
#line 23113
  if (unc_buff == (void *)0) {
    {
#line 23115
    fclose(fp);
#line 23117
    png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23119
    fprintf(stderr, "\nError: Couldn\'t recover the embedded data in %s\n\nUnable to allocate memory for the compressed buffer for %s\n\n",
            fname, chunk_name);
#line 23122
    __cil_tmp26 = __errno_location();
#line 23122
    __cil_tmp27 = strerror(*__cil_tmp26);
#line 23122
    draw_tux_text(4, (char const   *)__cil_tmp27, 0);
    }
#line 23123
    return ((Bytef *)((void *)0));
  }
  {
#line 23128
  zstp = (z_streamp )malloc(sizeof(z_stream ));
#line 23129
  zstp->next_in = comp_buff;
#line 23130
  zstp->avail_in = (uInt )comp;
#line 23131
  zstp->total_in = (uLong )comp;
#line 23133
  zstp->next_out = unc_buff;
#line 23134
  zstp->avail_out = (uInt )*unc_size;
#line 23135
  zstp->total_out = (uLong )0;
#line 23137
  zstp->zalloc = (alloc_func )0;
#line 23138
  zstp->zfree = (free_func )0;
#line 23139
  zstp->opaque = (voidpf )0;
#line 23141
  inflateInit_(zstp, "1.2.11", (int )sizeof(z_stream ));
#line 23142
  unc_err = inflate(zstp, 4);
#line 23143
  inflateEnd(zstp);
  }
#line 23145
  if (unc_err != 1) {
    {
#line 23147
    fprintf(stderr, "\n error %d, unc %d, comp %d\n", unc_err, *unc_size, comp);
#line 23148
    fclose(fp);
#line 23149
    png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23150
    free(comp_buff);
#line 23151
    free(unc_buff);
#line 23153
    fprintf(stderr, "Can\'t recover the embedded data in %s, error in uncompressing data from %s\n\n",
            fname, chunk_name);
#line 23154
    __cil_tmp30 = __errno_location();
#line 23154
    __cil_tmp31 = strerror(*__cil_tmp30);
#line 23154
    draw_tux_text(4, (char const   *)__cil_tmp31, 0);
    }
#line 23155
    return ((Bytef *)((void *)0));
  }
  {
#line 23158
  free(comp_buff);
  }
#line 23159
  return (unc_buff);
}
}
#line 23166 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
void load_embedded_data(char *fname , SDL_Surface *org_surf ) 
{ 
  FILE *fi ;
  FILE *fp ;
  char *control ;
  char *CHAR_PTR_TMP ;
  Bytef *unc_buff ;
  int unc_size ;
  int u ;
  int have_background ;
  int have_foreground ;
  int have_label_delta ;
  int have_label_data ;
  int ldelta ;
  int ldata ;
  int fgnd ;
  int bgnd ;
  int num_unknowns ;
  SDL_Surface *aux_surf ;
  png_structp png_ptr ;
  png_infop info_ptr ;
  png_unknown_chunkp unknowns ;
  png_uint_32 ww ;
  png_uint_32 hh ;
  png_uint_32 i ;
  png_uint_32 j ;
  FILE *__cil_tmp27 ;
  png_structp __cil_tmp28 ;
  int *__cil_tmp29 ;
  char *__cil_tmp30 ;
  png_infop __cil_tmp31 ;
  int *__cil_tmp32 ;
  char *__cil_tmp33 ;
  png_uint_32 __cil_tmp34 ;
  png_uint_32 __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  FILE *__cil_tmp38 ;
  int *__cil_tmp39 ;
  char *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  int __cil_tmp49 ;
  int __cil_tmp50 ;
  int __cil_tmp51 ;
  Bytef *__cil_tmp52 ;
  int __cil_tmp53 ;
  png_uint_32 __cil_tmp54 ;
  png_uint_32 __cil_tmp55 ;
  int __cil_tmp56 ;
  Bytef *__cil_tmp57 ;
  FILE *__cil_tmp58 ;
  int *__cil_tmp59 ;
  char *__cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  Bytef *__cil_tmp63 ;
  SDL_Surface *__cil_tmp64 ;
  int *__cil_tmp65 ;
  char *__cil_tmp66 ;
  png_uint_32 __cil_tmp67 ;
  png_uint_32 __cil_tmp68 ;
  SDL_Surface *__cil_tmp69 ;
  int __cil_tmp70 ;
  Bytef *__cil_tmp71 ;
  SDL_Surface *__cil_tmp72 ;
  int *__cil_tmp73 ;
  char *__cil_tmp74 ;
  png_uint_32 __cil_tmp75 ;
  png_uint_32 __cil_tmp76 ;
  SDL_Surface *__cil_tmp77 ;
  int __cil_tmp78 ;

  {
  {
#line 23177
  num_unknowns = 0;
#line 23192
  fp = fopen((char const   *)fname, "rb\265t\324U");
  }
#line 23193
  if (! fp) {
    {
#line 23195
    SDL_FreeSurface(org_surf);
    }
#line 23196
    return;
  }
  {
#line 23199
  png_ptr = png_create_read_struct("1.6.37", (void *)0, (png_error_ptr )((void *)0),
                                   (png_error_ptr )((void *)0));
  }
#line 23200
  if (png_ptr == (void *)0) {
    {
#line 23202
    fclose(fp);
#line 23203
    png_destroy_read_struct(& png_ptr, (png_infopp )((void *)0), (png_infopp )((void *)0));
#line 23205
    fprintf(stderr, "\nError: Couldn\'t open the image!\n%s\n\nU", fname);
#line 23206
    __cil_tmp29 = __errno_location();
#line 23206
    __cil_tmp30 = strerror(*__cil_tmp29);
#line 23206
    draw_tux_text(4, (char const   *)__cil_tmp30, 0);
#line 23207
    SDL_FreeSurface(org_surf);
    }
#line 23208
    return;
  } else {
    {
#line 23216
    info_ptr = png_create_info_struct(png_ptr);
    }
#line 23217
    if (info_ptr == (void *)0) {
      {
#line 23219
      fclose(fp);
#line 23220
      png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23222
      fprintf(stderr, "\nError: Couldn\'t open the image!\n%s\n\nU", fname);
#line 23223
      __cil_tmp32 = __errno_location();
#line 23223
      __cil_tmp33 = strerror(*__cil_tmp32);
#line 23223
      draw_tux_text(4, (char const   *)__cil_tmp33, 0);
#line 23224
      SDL_FreeSurface(org_surf);
      }
#line 23225
      return;
    }
    {
#line 23228
    png_init_io(png_ptr, fp);
#line 23230
    png_set_keep_unknown_chunks(png_ptr, 3, (png_const_bytep )((void *)0), 0);
#line 23232
    png_read_info(png_ptr, info_ptr);
#line 23234
    ww = png_get_image_width(png_ptr, info_ptr);
#line 23235
    hh = png_get_image_height(png_ptr, info_ptr);
#line 23237
    __cil_tmp36 = png_get_unknown_chunks(png_ptr, info_ptr, & unknowns);
#line 23237
    num_unknowns = (int )__cil_tmp36;
    }
#line 23242
    if (num_unknowns) {
#line 23244
      have_foreground = 0;
#line 23244
      have_background = have_foreground;
#line 23244
      have_label_data = have_background;
#line 23244
      have_label_delta = have_label_data;
#line 23245
      bgnd = 0;
#line 23245
      fgnd = bgnd;
#line 23245
      ldata = fgnd;
#line 23245
      ldelta = ldata;
#line 23253
      u = 0;
      {
#line 23253
      while (1) {
        while_continue: /* CIL Label */ ;
#line 23253
        if (! (u < num_unknowns)) {
#line 23253
          goto while_break;
        }
        {
#line 23259
        __cil_tmp37 = chunk_is_valid("tpDT", *(unknowns + u));
        }
#line 23259
        if (__cil_tmp37) {
          {
#line 23264
          fi = fmemopen((unknowns + u)->data, (unknowns + u)->size, "r\272\265t\324U");
          }
#line 23265
          if (fi == (void *)0) {
            {
#line 23267
            fclose(fp);
#line 23268
            png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23270
            fprintf(stderr, "\nError: Couldn\'t load the data embedded in %s\n\n",
                    fname);
#line 23271
            __cil_tmp39 = __errno_location();
#line 23271
            __cil_tmp40 = strerror(*__cil_tmp39);
#line 23271
            draw_tux_text(4, (char const   *)__cil_tmp40, 0);
#line 23272
            SDL_FreeSurface(org_surf);
            }
#line 23273
            return;
          }
          {
#line 23277
          control = (char *)malloc((unsigned long )50);
#line 23278
          CHAR_PTR_TMP = fgets(control, 49, fi);
#line 23279
          CHAR_PTR_TMP = fgets(control, 49, fi);
#line 23280
          CHAR_PTR_TMP = fgets(control, 49, fi);
#line 23281
          CHAR_PTR_TMP = fgets(control, 49, fi);
#line 23283
          free(control);
#line 23286
          load_starter_id((char *)((void *)0), fi);
          }
#line 23287
          if (! starter_modified) {
#line 23290
            if ((int )starter_id[0] != 0) {
              {
#line 23292
              load_starter((char *)starter_id);
              }
#line 23294
              if (img_starter) {
#line 23294
                if (starter_mirrored) {
                  {
#line 23295
                  mirror_starter();
                  }
                }
              }
#line 23297
              if (img_starter) {
#line 23297
                if (starter_flipped) {
                  {
#line 23298
                  flip_starter();
                  }
                }
              }
            } else
#line 23300
            if ((int )template_id[0] != 0) {
              {
#line 23302
              load_template((char *)template_id);
              }
            }
          }
        }
        {
#line 23307
        __cil_tmp46 = chunk_is_valid("tpBK", *(unknowns + u));
        }
#line 23307
        if (__cil_tmp46) {
#line 23308
          have_background = ! 0;
        }
        {
#line 23309
        __cil_tmp47 = chunk_is_valid("tpFG", *(unknowns + u));
        }
#line 23309
        if (__cil_tmp47) {
#line 23310
          have_foreground = ! 0;
        }
        {
#line 23311
        __cil_tmp48 = chunk_is_valid("tpLD", *(unknowns + u));
        }
#line 23311
        if (__cil_tmp48) {
#line 23312
          have_label_delta = ! 0;
        }
        {
#line 23313
        __cil_tmp49 = chunk_is_valid("tpLL", *(unknowns + u));
        }
#line 23313
        if (__cil_tmp49) {
#line 23314
          have_label_data = ! 0;
        }
#line 23253
        u ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 23318
      if (! disable_label) {
#line 23318
        if (have_label_delta) {
#line 23318
          if (have_label_data) {
#line 23320
            u = 0;
            {
#line 23320
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 23320
              if (! (u < num_unknowns)) {
#line 23320
                goto while_break___0;
              }
              {
#line 23322
              __cil_tmp51 = chunk_is_valid("tpLD", *(unknowns + u));
              }
#line 23322
              if (__cil_tmp51) {
                {
#line 23328
                unc_buff = get_chunk_data(fp, fname, png_ptr, info_ptr, "tpLD\324U",
                                          *(unknowns + u), & unc_size);
                }
#line 23329
                if (unc_buff == (void *)0) {
                  {
#line 23331
                  __cil_tmp53 = are_labels();
                  }
#line 23331
                  if (__cil_tmp53) {
                    {
#line 23333
                    delete_label_list(& start_label_node);
#line 23334
                    current_label_node = (struct label_node *)((void *)0);
#line 23334
                    start_label_node = current_label_node;
                    }
                  }
                  {
#line 23337
                  SDL_FreeSurface(org_surf);
                  }
#line 23338
                  return;
                } else {
                  {
#line 23342
                  SDL_LockSurface(org_surf);
#line 23343
                  j = (png_uint_32 )0;
                  }
                  {
#line 23343
                  while (1) {
                    while_continue___1: /* CIL Label */ ;
#line 23343
                    if (! (j < hh)) {
#line 23343
                      goto while_break___1;
                    }
#line 23344
                    i = (png_uint_32 )0;
                    {
#line 23344
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 23344
                      if (! (i < ww)) {
#line 23344
                        goto while_break___2;
                      }
#line 23346
                      if ((int )((Uint8 )*(unc_buff + (((4U * j) * ww + 4U * i) + 3U))) == 255) {
                        {
#line 23347
                        (*(putpixels[(org_surf->format)->BytesPerPixel]))(org_surf,
                                                                          (int )i,
                                                                          (int )j,
                                                                          ((((unsigned int )*(unc_buff + 4U * (j * ww + i)) & 255U) << 16) | (((unsigned int )*(unc_buff + (4U * (j * ww + i) + 1U)) & 255U) << 8)) | ((unsigned int )*(unc_buff + (4U * (j * ww + i) + 2U)) & 255U));
                        }
                      }
#line 23344
                      i ++;
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 23343
                    j ++;
                  }
                  while_break___1: /* CIL Label */ ;
                  }
                }
                {
#line 23356
                SDL_UnlockSurface(org_surf);
#line 23358
                free(unc_buff);
#line 23359
                ldelta = ! 0;
                }
              }
              {
#line 23363
              __cil_tmp56 = chunk_is_valid("tpLL", *(unknowns + u));
              }
#line 23363
              if (! disable_label) {
#line 23363
                if (__cil_tmp56) {
                  {
#line 23369
                  unc_buff = get_chunk_data(fp, fname, png_ptr, info_ptr, "tpLL",
                                            *(unknowns + u), & unc_size);
                  }
#line 23370
                  if (unc_buff == (void *)0) {
                    {
#line 23372
                    SDL_FreeSurface(org_surf);
                    }
#line 23373
                    return;
                  } else {
                    {
#line 23377
                    fi = fmemopen(unc_buff, (size_t )unc_size, "rb");
                    }
#line 23378
                    if (fi == (void *)0) {
                      {
#line 23380
                      fprintf(stderr, "Can\'t recover the label data embedded in %s, error in create file stream\n\n",
                              fname);
#line 23382
                      fclose(fp);
#line 23383
                      png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23384
                      free(unc_buff);
#line 23385
                      SDL_FreeSurface(org_surf);
#line 23387
                      __cil_tmp59 = __errno_location();
#line 23387
                      __cil_tmp60 = strerror(*__cil_tmp59);
#line 23387
                      draw_tux_text(4, (char const   *)__cil_tmp60, 0);
                      }
#line 23388
                      return;
                    } else {
                      {
#line 23391
                      load_info_about_label_surface(fi);
                      }
                    }
                  }
                  {
#line 23394
                  free(unc_buff);
#line 23395
                  ldata = ! 0;
                  }
                }
              }
#line 23320
              u ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 23403
      if (ldelta) {
#line 23403
        if (ldata) {
          {
#line 23404
          autoscale_copy_smear_free(org_surf, canvas, & SDL_UpperBlit);
          }
        } else {
          {
          {
#line 23406
          SDL_FreeSurface(org_surf);
          }
          }
        }
      } else {
        {
        {
#line 23406
        SDL_FreeSurface(org_surf);
        }
        }
      }
#line 23409
      if (have_background) {
        _L___313: /* CIL Label */ 
#line 23411
        u = 0;
        {
#line 23411
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 23411
          if (! (u < num_unknowns)) {
#line 23411
            goto while_break___3;
          }
          {
#line 23413
          __cil_tmp62 = chunk_is_valid("tpBG", *(unknowns + u));
          }
#line 23413
          if (! img_starter_bkgd) {
            _L: /* CIL Label */ 
#line 23413
            if (__cil_tmp62) {
              {
#line 23415
              unc_buff = get_chunk_data(fp, fname, png_ptr, info_ptr, "tpBG", *(unknowns + u),
                                        & unc_size);
              }
#line 23416
              if (unc_buff == (void *)0) {
#line 23417
                return;
              }
              {
#line 23418
              aux_surf = SDL_CreateRGBSurface((Uint32 )0, (int )ww, (int )hh, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Gmask, (Uint32 )0);
              }
#line 23421
              if (aux_surf == (void *)0) {
                {
#line 23427
                fclose(fp);
#line 23428
                png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23429
                free(unc_buff);
#line 23431
                __cil_tmp65 = __errno_location();
#line 23431
                __cil_tmp66 = strerror(*__cil_tmp65);
#line 23431
                draw_tux_text(4, (char const   *)__cil_tmp66, 0);
#line 23433
                free(unc_buff);
                }
#line 23434
                return;
              }
              {
#line 23436
              SDL_LockSurface(aux_surf);
#line 23441
              j = (png_uint_32 )0;
              }
              {
#line 23441
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 23441
                if (! (j < hh)) {
#line 23441
                  goto while_break___4;
                }
#line 23442
                i = (png_uint_32 )0;
                {
#line 23442
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 23442
                  if (! (i < ww)) {
#line 23442
                    goto while_break___5;
                  }
                  {
#line 23443
                  (*(putpixels[(aux_surf->format)->BytesPerPixel]))(aux_surf, (int )i,
                                                                    (int )j, ((((unsigned int )*(unc_buff + ((3U * j) * ww + 3U * i)) & 255U) << 16) | (((unsigned int )*(unc_buff + (((3U * j) * ww + 3U * i) + 1U)) & 255U) << 8)) | ((unsigned int )*(unc_buff + (((3U * j) * ww + 3U * i) + 2U)) & 255U));
                  }
#line 23442
                  i ++;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 23441
                j ++;
              }
              while_break___4: /* CIL Label */ ;
              }
              {
#line 23449
              SDL_UnlockSurface(aux_surf);
              }
#line 23451
              if (img_starter_bkgd) {
                {
#line 23452
                SDL_FreeSurface(img_starter_bkgd);
                }
              }
#line 23454
              if (aux_surf->w != canvas->w) {
                {
                {
#line 23456
                img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h,
                                                        (int )(canvas->format)->BitsPerPixel,
                                                        (canvas->format)->Rmask, (canvas->format)->Gmask,
                                                        (canvas->format)->Bmask, (Uint32 )0);
                }
                {
#line 23463
                autoscale_copy_smear_free(aux_surf, img_starter_bkgd, & SDL_UpperBlit);
                }
                }
              } else
#line 23454
              if (aux_surf->h != canvas->h) {
                {
                {
#line 23456
                img_starter_bkgd = SDL_CreateRGBSurface((Uint32 )0, canvas->w, canvas->h,
                                                        (int )(canvas->format)->BitsPerPixel,
                                                        (canvas->format)->Rmask, (canvas->format)->Gmask,
                                                        (canvas->format)->Bmask, (Uint32 )0);
                }
                {
#line 23463
                autoscale_copy_smear_free(aux_surf, img_starter_bkgd, & SDL_UpperBlit);
                }
                }
              }
              {
#line 23465
              free(unc_buff);
              }
            }
          } else
#line 23413
          if (starter_modified) {
#line 23413
            goto _L;
          }
          {
#line 23468
          __cil_tmp70 = chunk_is_valid("tpFG", *(unknowns + u));
          }
#line 23468
          if (! img_starter) {
            _L___312: /* CIL Label */ 
#line 23468
            if (__cil_tmp70) {
              {
#line 23474
              unc_buff = get_chunk_data(fp, fname, png_ptr, info_ptr, "tpFG", *(unknowns + u),
                                        & unc_size);
              }
#line 23475
              if (unc_buff == (void *)0) {
#line 23476
                return;
              }
              {
#line 23478
              aux_surf = SDL_CreateRGBSurface(canvas->flags, (int )ww, (int )hh, (int )(canvas->format)->BitsPerPixel,
                                              (canvas->format)->Rmask, (canvas->format)->Gmask,
                                              (canvas->format)->Gmask, 4278190080U);
              }
#line 23482
              if (aux_surf == (void *)0) {
                {
#line 23484
                fprintf(stderr, "Can\'t recover the foreground data embedded in %s, error in create aux image\n\n",
                        fname);
#line 23486
                fclose(fp);
#line 23487
                png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23488
                free(unc_buff);
#line 23490
                __cil_tmp73 = __errno_location();
#line 23490
                __cil_tmp74 = strerror(*__cil_tmp73);
#line 23490
                draw_tux_text(4, (char const   *)__cil_tmp74, 0);
#line 23492
                free(unc_buff);
                }
#line 23493
                return;
              }
              {
#line 23496
              SDL_LockSurface(aux_surf);
#line 23497
              j = (png_uint_32 )0;
              }
              {
#line 23497
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 23497
                if (! (j < hh)) {
#line 23497
                  goto while_break___6;
                }
#line 23498
                i = (png_uint_32 )0;
                {
#line 23498
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 23498
                  if (! (i < ww)) {
#line 23498
                    goto while_break___7;
                  }
                  {
#line 23500
                  (*(putpixels[(aux_surf->format)->BytesPerPixel]))(aux_surf, (int )i,
                                                                    (int )j, (((((unsigned int )*(unc_buff + (((4U * j) * ww + 4U * i) + 3U)) & 255U) << 24) | (((unsigned int )*(unc_buff + ((4U * j) * ww + 4U * i)) & 255U) << 16)) | (((unsigned int )*(unc_buff + (((4U * j) * ww + 4U * i) + 1U)) & 255U) << 8)) | ((unsigned int )*(unc_buff + (((4U * j) * ww + 4U * i) + 2U)) & 255U));
                  }
#line 23498
                  i ++;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 23497
                j ++;
              }
              while_break___6: /* CIL Label */ ;
              }
              {
#line 23508
              SDL_UnlockSurface(aux_surf);
              }
#line 23510
              if (img_starter) {
                {
#line 23511
                SDL_FreeSurface(img_starter);
                }
              }
              {
#line 23515
              img_starter = SDL_CreateRGBSurface(canvas->flags, canvas->w, canvas->h,
                                                 (int )(canvas->format)->BitsPerPixel,
                                                 (canvas->format)->Rmask, (canvas->format)->Gmask,
                                                 (canvas->format)->Bmask, 4278190080U);
#line 23522
              SDL_SetAlpha(aux_surf, (Uint32 )16384, (Uint8 )255);
#line 23523
              autoscale_copy_smear_free(aux_surf, img_starter, & NondefectiveBlit);
#line 23524
              SDL_SetAlpha(img_starter, (Uint32 )81920, (Uint8 )255);
#line 23526
              free(unc_buff);
              }
            }
          } else
#line 23468
          if (starter_modified) {
#line 23468
            goto _L___312;
          }
#line 23411
          u ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 23409
      if (have_foreground) {
#line 23409
        goto _L___313;
      }
    }
  }
  {
#line 23533
  png_destroy_read_struct(& png_ptr, & info_ptr, (png_infopp )((void *)0));
#line 23534
  fclose(fp);
  }
  return;
}
}
#line 23544 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void show_available_papersizes(int exitcode ) 
{ 
  FILE *fi ;
  FILE *tmp ;
  struct paper *ppr ;
  int cnt ;
  struct paper *__cil_tmp6 ;
  char const   *__cil_tmp7 ;
  int __cil_tmp8 ;
  struct paper *__cil_tmp9 ;

  {
#line 23546
  if (exitcode) {
#line 23546
    tmp = stderr;
  } else {
#line 23546
    tmp = stdout;
  }
  {
#line 23546
  fi = tmp;
#line 23550
  fprintf(fi, "Usage: %s [--papersize PAPERSIZE]\n", progname);
#line 23551
  fprintf(fi, "\n");
#line 23552
  fprintf(fi, "PAPERSIZE may be one of:\n");
#line 23554
  ppr = paperfirst();
#line 23555
  cnt = 0;
  }
  {
#line 23557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23557
    if (! (ppr != (void *)0)) {
#line 23557
      goto while_break;
    }
    {
#line 23559
    __cil_tmp7 = papername(ppr);
#line 23559
    fprintf(fi, "\t%s", __cil_tmp7);
#line 23560
    cnt ++;
    }
#line 23561
    if (cnt == 5) {
      {
#line 23563
      cnt = 0;
#line 23564
      fprintf(fi, "\n");
      }
    }
    {
#line 23567
    ppr = papernext(ppr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23570
  fprintf(fi, "\n");
  }
#line 23571
  if (cnt != 0) {
    {
#line 23572
    fprintf(fi, "\n");
    }
  }
  return;
}
}
#line 23581 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void parse_file_options(struct cfginfo *tmpcfg , char const   *filename ) 
{ 
  char str[256] ;
  char *arg ;
  FILE *fi ;
  FILE *__cil_tmp6 ;
  int line ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;
  unsigned short const   **__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  wordexp_t result ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 23585
  __cil_tmp6 = fopen(filename, "r");
#line 23585
  fi = __cil_tmp6;
  }
#line 23588
  if (! fi) {
#line 23589
    return;
  }
#line 23591
  line = 0;
  {
#line 23593
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23593
    __cil_tmp8 = fgets((char *)str, (int )sizeof(str), fi);
    }
#line 23593
    if (! __cil_tmp8) {
#line 23593
      goto while_break;
    }
    {
#line 23595
    line ++;
#line 23597
    strip_trailing_whitespace((char *)str);
    }
#line 23600
    if ((int )str[0] == 35) {
#line 23601
      goto while_continue;
    } else
#line 23600
    if ((int )str[0] == 0) {
#line 23601
      goto while_continue;
    }
    {
#line 23604
    __cil_tmp10 = __ctype_b_loc();
    }
#line 23604
    if (! ((int )*(*__cil_tmp10 + (int )*((char *)str)) & 8)) {
      {
#line 23606
      fprintf(stderr, "Warning: do not understand \'%s\' on line %d of \'%s\'\n",
              (char *)str, line, filename);
      }
#line 23608
      goto while_continue;
    }
    {
#line 23612
    arg = strchr((char const   *)((char *)str), '=');
    }
#line 23613
    if (arg) {
#line 23615
      __cil_tmp12 = arg;
#line 23615
      arg ++;
#line 23615
      *__cil_tmp12 = (char )'\000';
    } else {
      {
#line 23619
      fprintf(stderr, "Warning: do not understand \'%s\' on line %d of \'%s\'\n",
              (char *)str, line, filename);
      }
#line 23621
      goto while_continue;
    }
    {
#line 23628
    wordexp((char const   *)arg, & result, 0);
#line 23629
    arg = strdup((char const   *)*(result.we_wordv + 0));
#line 23630
    wordfree(& result);
#line 23637
    __cil_tmp15 = strdup((char const   *)arg);
#line 23637
    parse_one_option(tmpcfg, (char const   *)((char *)str), (char const   *)__cil_tmp15,
                     filename);
#line 23640
    free(arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23643
  fclose(fi);
  }
#line 23646
  if (tmpcfg->parsertmp_lang) {
#line 23646
    if (tmpcfg->parsertmp_locale) {
      {
#line 23647
      fprintf(stderr, "Warning: option \'lang=%s\' overrides option \'locale=%s\' in \'%s\'\n",
              tmpcfg->parsertmp_lang, tmpcfg->parsertmp_locale, filename);
      }
    }
  }
#line 23650
  if (tmpcfg->parsertmp_lang) {
#line 23651
    tmpcfg->parsertmp_locale = (char const   *)PARSE_CLOBBER;
  } else
#line 23652
  if (tmpcfg->parsertmp_locale) {
#line 23653
    tmpcfg->parsertmp_lang = (char const   *)PARSE_CLOBBER;
  }
  return;
}
}
#line 23659 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void parse_argv_options(struct cfginfo *tmpcfg , char *argv[] ) 
{ 
  char *str ;
  char *arg ;
  char const   *short_synonyms[16][2] ;
  int i ;
  int found ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 23663
  short_synonyms[0][0] = "-c";
#line 23663
  short_synonyms[0][1] = "copying";
#line 23663
  short_synonyms[1][0] = "-h";
#line 23663
  short_synonyms[1][1] = "help";
#line 23663
  short_synonyms[2][0] = "-u";
#line 23663
  short_synonyms[2][1] = "usage";
#line 23663
  short_synonyms[3][0] = "-v";
#line 23663
  short_synonyms[3][1] = "version";
#line 23663
  short_synonyms[4][0] = "-vv";
#line 23663
  short_synonyms[4][1] = "verbose-version";
#line 23663
  short_synonyms[5][0] = "-l";
#line 23663
  short_synonyms[5][1] = "lang";
#line 23663
  short_synonyms[6][0] = "-L";
#line 23663
  short_synonyms[6][1] = "locale";
#line 23663
  short_synonyms[7][0] = "-b";
#line 23663
  short_synonyms[7][1] = "startblank";
#line 23663
  short_synonyms[8][0] = "-f";
#line 23663
  short_synonyms[8][1] = "fullscreen";
#line 23663
  short_synonyms[9][0] = "-m";
#line 23663
  short_synonyms[9][1] = "mixedcase";
#line 23663
  short_synonyms[10][0] = "-p";
#line 23663
  short_synonyms[10][1] = "noprint";
#line 23663
  short_synonyms[11][0] = "-q";
#line 23663
  short_synonyms[11][1] = "nosound";
#line 23663
  short_synonyms[12][0] = "-s";
#line 23663
  short_synonyms[12][1] = "simpleshapes";
#line 23663
  short_synonyms[13][0] = "-w";
#line 23663
  short_synonyms[13][1] = "windowed\250";
#line 23663
  short_synonyms[14][0] = "-x";
#line 23663
  short_synonyms[14][1] = "noquit";
#line 23663
  short_synonyms[15][0] = (char const   *)((void *)0);
#line 23663
  short_synonyms[15][1] = (char const   *)((void *)0);
  {
#line 23682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23682
    argv ++;
#line 23682
    str = argv[0];
#line 23682
    if (! str) {
#line 23682
      goto while_break;
    }
#line 23684
    if ((int )*(str + 0) == 45) {
#line 23684
      if ((int )*(str + 1) != 45) {
#line 23684
        if ((int )*(str + 1) != 0) {
#line 23686
          found = 0;
#line 23688
          i = 0;
          {
#line 23688
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 23688
            if (! (short_synonyms[i][0] != (void *)0 && ! found)) {
#line 23688
              goto while_break___0;
            }
            {
#line 23690
            __cil_tmp8 = strcmp(short_synonyms[i][0], (char const   *)str);
            }
#line 23690
            if (__cil_tmp8 == 0) {
#line 23692
              if (argv[1]) {
#line 23692
                if ((int )*(argv[1] + 0) != 45) {
#line 23693
                  argv ++;
#line 23693
                  arg = argv[0];
                } else {
#line 23695
                  arg = (char *)((void *)0);
                }
              } else {
#line 23695
                arg = (char *)((void *)0);
              }
              {
#line 23696
              parse_one_option(tmpcfg, short_synonyms[i][1], (char const   *)arg,
                               (char const   *)((void *)0));
#line 23697
              found = 1;
              }
            }
#line 23688
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 23700
          if (found) {
#line 23701
            goto while_continue;
          }
        } else {
#line 23684
          goto _L;
        }
      } else {
#line 23684
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    _L___314: /* CIL Label */ 
#line 23703
    if ((int )*(str + 0) == 45) {
#line 23703
      if ((int )*(str + 1) == 45) {
#line 23703
        if ((int )*(str + 2)) {
          {
#line 23705
          str += 2;
#line 23706
          arg = strchr((char const   *)str, '=');
          }
#line 23707
          if (arg) {
#line 23708
            __cil_tmp11 = arg;
#line 23708
            arg ++;
#line 23708
            *__cil_tmp11 = (char )'\000';
          } else
#line 23709
          if (argv[1]) {
#line 23709
            if ((int )*(argv[1] + 0) != 45) {
#line 23710
              argv ++;
#line 23710
              arg = argv[0];
            }
          }
          {
#line 23711
          parse_one_option(tmpcfg, (char const   *)str, (char const   *)arg, (char const   *)((void *)0));
          }
#line 23712
          goto while_continue;
        }
      }
    }
    {
#line 23714
    fprintf(stderr, "%s is not understood\n", argv[0]);
#line 23715
    show_usage(63);
#line 23716
    exit(1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 23720
  if (tmpcfg->parsertmp_lang) {
#line 23720
    if (tmpcfg->parsertmp_locale) {
      {
#line 23722
      fprintf(stderr, "Error: command line option \'--lang=%s\' overrides option \'--locale=%s\'\n",
              tmpcfg->parsertmp_lang, tmpcfg->parsertmp_locale);
#line 23725
      exit(92);
      }
    }
  }
#line 23727
  if (tmpcfg->parsertmp_lang) {
#line 23728
    tmpcfg->parsertmp_locale = (char const   *)PARSE_CLOBBER;
  } else
#line 23729
  if (tmpcfg->parsertmp_locale) {
#line 23730
    tmpcfg->parsertmp_lang = (char const   *)PARSE_CLOBBER;
  }
  return;
}
}
#line 23737 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void tmpcfg_merge(struct cfginfo *loser , struct cfginfo *winner ) 
{ 
  int i ;
  int __cil_tmp4 ;
  char const   *cfgitem ;

  {
#line 23739
  i = (int )(sizeof(struct cfginfo ) / sizeof(char *));
  {
#line 23741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23741
    __cil_tmp4 = i;
#line 23741
    i --;
#line 23741
    if (! __cil_tmp4) {
#line 23741
      goto while_break;
    }
    {
#line 23745
    memcpy(& cfgitem, (char const   *)winner + (unsigned long )i * sizeof(char const   *),
           sizeof(cfgitem));
    }
#line 23746
    if (! cfgitem) {
#line 23747
      goto while_continue;
    }
    {
#line 23748
    memcpy((char *)loser + (unsigned long )i * sizeof(char const   *), & cfgitem,
           sizeof(cfgitem));
    }
  }
  while_break: /* CIL Label */ ;
  }
  return;
}
}
#line 23755 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void setup_config(char *argv[] ) 
{ 
  char str[128] ;
  char *picturesdir ;
  char const   *home ;
  char *__cil_tmp5 ;
  struct cfginfo tmpcfg_usr ;
  struct cfginfo tmpcfg_cmd ;
  struct cfginfo tmpcfg ;
  char *__cil_tmp9 ;
  int tmp ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  struct cfginfo tmpcfg_sys ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  char *endp1 ;
  char *endp2 ;
  int w ;
  unsigned long __cil_tmp23 ;
  int h ;
  unsigned long __cil_tmp25 ;
  int __cil_tmp26 ;
  int __cil_tmp27 ;
  float __cil_tmp28 ;
  float __cil_tmp29 ;
  float __cil_tmp30 ;
  float __cil_tmp31 ;
  float __cil_tmp32 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  int __cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  int __cil_tmp39 ;
  float __cil_tmp40 ;
  float __cil_tmp41 ;
  float __cil_tmp42 ;
  float __cil_tmp43 ;
  float __cil_tmp44 ;
  float __cil_tmp45 ;
  float __cil_tmp46 ;
  float __cil_tmp47 ;
  float __cil_tmp48 ;
  float __cil_tmp49 ;
  float __cil_tmp50 ;
  float __cil_tmp51 ;
  float __cil_tmp52 ;
  float __cil_tmp53 ;
  float __cil_tmp54 ;
  float __cil_tmp55 ;
  float __cil_tmp56 ;
  float __cil_tmp57 ;
  float __cil_tmp58 ;
  float __cil_tmp59 ;
  float __cil_tmp60 ;
  float __cil_tmp61 ;
  float __cil_tmp62 ;
  float __cil_tmp63 ;
  float __cil_tmp64 ;
  float __cil_tmp65 ;
  float __cil_tmp66 ;
  float __cil_tmp67 ;
  float __cil_tmp68 ;
  float __cil_tmp69 ;
  float __cil_tmp70 ;
  float __cil_tmp71 ;
  float __cil_tmp72 ;
  float __cil_tmp73 ;
  float __cil_tmp74 ;
  float __cil_tmp75 ;
  float __cil_tmp76 ;
  float __cil_tmp77 ;
  float __cil_tmp78 ;
  float __cil_tmp79 ;
  float __cil_tmp80 ;
  float __cil_tmp81 ;
  float __cil_tmp82 ;
  float __cil_tmp83 ;
  float __cil_tmp84 ;
  float __cil_tmp85 ;
  float __cil_tmp86 ;
  float __cil_tmp87 ;
  float __cil_tmp88 ;
  float __cil_tmp89 ;
  float __cil_tmp90 ;
  float __cil_tmp91 ;
  float __cil_tmp92 ;
  float __cil_tmp93 ;
  float __cil_tmp94 ;
  float __cil_tmp95 ;
  float __cil_tmp96 ;
  float __cil_tmp97 ;
  float __cil_tmp98 ;
  float __cil_tmp99 ;
  float __cil_tmp100 ;
  float __cil_tmp101 ;
  float __cil_tmp102 ;
  float __cil_tmp103 ;
  float __cil_tmp104 ;
  float __cil_tmp105 ;
  char *token ;
  char *__cil_tmp107 ;
  float __cil_tmp108 ;
  float __cil_tmp109 ;
  int __cil_tmp110 ;
  float __cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;

  {
  {
#line 23761
  __cil_tmp5 = getenv("HOME");
#line 23761
  home = (char const   *)__cil_tmp5;
#line 23768
  memset(& tmpcfg_usr, '\000', sizeof(tmpcfg_usr));
#line 23769
  memset(& tmpcfg_cmd, '\000', sizeof(tmpcfg_cmd));
#line 23770
  memset(& tmpcfg, '\000', sizeof(tmpcfg));
#line 23772
  parse_argv_options(& tmpcfg_cmd, argv);
  }
#line 23788
  if (! home) {
    {
#line 23791
    fprintf(stderr, "Error: You have no $HOME environment variable!\n");
#line 23792
    exit(1);
    }
  }
#line 23797
  if (tmpcfg_cmd.savedir) {
    {
#line 23798
    __cil_tmp9 = strdup(tmpcfg_cmd.savedir);
#line 23798
    savedir = (char const   *)__cil_tmp9;
    }
  } else {
    {
#line 23818
    tmp = __asprintf((char **)(& savedir), "%s/%s", home, ".tuxpaint");
    }
#line 23819
    if (tmp < 0) {
      {
#line 23821
      fprintf(stderr, "Can\'t set savedir\n");
#line 23822
      exit(91);
      }
    }
  }
#line 23828
  if (tmpcfg_cmd.exportdir) {
    {
#line 23829
    __cil_tmp12 = strdup(tmpcfg_cmd.exportdir);
#line 23829
    exportdir = (char const   *)__cil_tmp12;
    }
  } else {
    {
#line 23841
    picturesdir = get_xdg_user_dir("PICTURES\323\001 ", "Pictures\220");
#line 23843
    safe_snprintf((char *)str, sizeof(str), "%s/TuxPaint", picturesdir);
#line 23844
    free(picturesdir);
#line 23845
    __cil_tmp14 = strdup((char const   *)((char *)str));
#line 23845
    exportdir = (char const   *)__cil_tmp14;
    }
  }
  {
#line 23863
  safe_snprintf((char *)str, sizeof(str), "%s/.tuxpaintrc", home);
#line 23865
  parse_file_options(& tmpcfg_usr, (char const   *)((char *)str));
#line 23873
  tmpcfg_merge(& tmpcfg_usr, & tmpcfg_cmd);
  }
#line 23876
  if (tmpcfg_usr.parsertmp_sysconfig != (char const   *)PARSE_NO) {
    {
#line 23880
    memset(& tmpcfg_sys, '\000', sizeof(tmpcfg_sys));
#line 23893
    parse_file_options(& tmpcfg_sys, "/usr/local/etc/tuxpaint/tuxpaint.conf");
#line 23895
    tmpcfg_merge(& tmpcfg, & tmpcfg_sys);
    }
  }
  {
#line 23897
  tmpcfg_merge(& tmpcfg, & tmpcfg_usr);
  }
#line 23899
  if (tmpcfg.savedir) {
    {
#line 23901
    free((char *)savedir);
#line 23902
    savedir = tmpcfg.savedir;
    }
  }
#line 23905
  if (tmpcfg.datadir) {
#line 23905
    tmp___0 = tmpcfg.datadir;
  } else {
#line 23905
    tmp___0 = savedir;
  }
#line 23905
  datadir = tmp___0;
#line 23907
  if (tmpcfg.exportdir) {
#line 23907
    tmp___1 = tmpcfg.exportdir;
  } else {
#line 23907
    tmp___1 = exportdir;
  }
#line 23907
  exportdir = tmp___1;
#line 23909
  if (tmpcfg.parsertmp_lang == (char const   *)PARSE_CLOBBER) {
#line 23910
    tmpcfg.parsertmp_lang = (char const   *)((void *)0);
  }
#line 23911
  if (tmpcfg.parsertmp_locale == (char const   *)PARSE_CLOBBER) {
#line 23912
    tmpcfg.parsertmp_locale = (char const   *)((void *)0);
  }
  {
#line 23913
  button_label_y_nudge = setup_i18n(tmpcfg.parsertmp_lang, tmpcfg.parsertmp_locale,
                                    & num_wished_langs);
#line 23919
  __cil_tmp19 = strcmp(tmpcfg_cmd.papersize, "help");
  }
#line 23919
  if (tmpcfg_cmd.papersize) {
#line 23919
    if (! __cil_tmp19) {
      {
#line 23920
      show_available_papersizes(0);
      }
    }
  }
  {
#line 23924
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23924
    if (tmpcfg.all_locale_fonts) {
#line 23924
      all_locale_fonts = tmpcfg.all_locale_fonts == (char const   *)PARSE_YES;
    }
#line 23924
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23925
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 23925
    if (tmpcfg.autosave_on_quit) {
#line 23925
      autosave_on_quit = tmpcfg.autosave_on_quit == (char const   *)PARSE_YES;
    }
#line 23925
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 23926
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 23926
    if (tmpcfg.disable_label) {
#line 23926
      disable_label = tmpcfg.disable_label == (char const   *)PARSE_YES;
    }
#line 23926
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 23927
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 23927
    if (tmpcfg.disable_magic_controls) {
#line 23927
      disable_magic_controls = tmpcfg.disable_magic_controls == (char const   *)PARSE_YES;
    }
#line 23927
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 23928
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 23928
    if (tmpcfg.disable_shape_controls) {
#line 23928
      disable_shape_controls = tmpcfg.disable_shape_controls == (char const   *)PARSE_YES;
    }
#line 23928
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 23929
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 23929
    if (tmpcfg.disable_print) {
#line 23929
      disable_print = tmpcfg.disable_print == (char const   *)PARSE_YES;
    }
#line 23929
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 23930
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 23930
    if (tmpcfg.disable_quit) {
#line 23930
      disable_quit = tmpcfg.disable_quit == (char const   *)PARSE_YES;
    }
#line 23930
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 23931
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 23931
    if (tmpcfg.disable_save) {
#line 23931
      disable_save = tmpcfg.disable_save == (char const   *)PARSE_YES;
    }
#line 23931
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 23932
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 23932
    if (tmpcfg.disable_screensaver) {
#line 23932
      disable_screensaver = tmpcfg.disable_screensaver == (char const   *)PARSE_YES;
    }
#line 23932
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 23933
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 23933
    if (tmpcfg.disable_stamp_controls) {
#line 23933
      disable_stamp_controls = tmpcfg.disable_stamp_controls == (char const   *)PARSE_YES;
    }
#line 23933
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 23934
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 23934
    if (tmpcfg.dont_do_xor) {
#line 23934
      dont_do_xor = tmpcfg.dont_do_xor == (char const   *)PARSE_YES;
    }
#line 23934
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 23935
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 23935
    if (tmpcfg.dont_load_stamps) {
#line 23935
      dont_load_stamps = tmpcfg.dont_load_stamps == (char const   *)PARSE_YES;
    }
#line 23935
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 23936
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 23936
    if (tmpcfg.fullscreen) {
#line 23936
      fullscreen = tmpcfg.fullscreen == (char const   *)PARSE_YES;
    }
#line 23936
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 23937
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 23937
    if (tmpcfg.grab_input) {
#line 23937
      grab_input = tmpcfg.grab_input == (char const   *)PARSE_YES;
    }
#line 23937
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 23938
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 23938
    if (tmpcfg.hide_cursor) {
#line 23938
      hide_cursor = tmpcfg.hide_cursor == (char const   *)PARSE_YES;
    }
#line 23938
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 23939
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 23939
    if (tmpcfg.keymouse) {
#line 23939
      keymouse = tmpcfg.keymouse == (char const   *)PARSE_YES;
    }
#line 23939
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 23940
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 23940
    if (tmpcfg.mirrorstamps) {
#line 23940
      mirrorstamps = tmpcfg.mirrorstamps == (char const   *)PARSE_YES;
    }
#line 23940
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 23941
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 23941
    if (tmpcfg.native_screensize) {
#line 23941
      native_screensize = tmpcfg.native_screensize == (char const   *)PARSE_YES;
    }
#line 23941
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 23942
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 23942
    if (tmpcfg.new_colors_last) {
#line 23942
      new_colors_last = tmpcfg.new_colors_last == (char const   *)PARSE_YES;
    }
#line 23942
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 23943
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 23943
    if (tmpcfg.no_button_distinction) {
#line 23943
      no_button_distinction = tmpcfg.no_button_distinction == (char const   *)PARSE_YES;
    }
#line 23943
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 23944
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 23944
    if (tmpcfg.no_fancy_cursors) {
#line 23944
      no_fancy_cursors = tmpcfg.no_fancy_cursors == (char const   *)PARSE_YES;
    }
#line 23944
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
  {
#line 23945
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 23945
    if (tmpcfg.no_system_fonts) {
#line 23945
      no_system_fonts = tmpcfg.no_system_fonts == (char const   *)PARSE_YES;
    }
#line 23945
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 23946
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 23946
    if (tmpcfg.noshortcuts) {
#line 23946
      noshortcuts = tmpcfg.noshortcuts == (char const   *)PARSE_YES;
    }
#line 23946
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 23947
  while (1) {
    while_continue___22: /* CIL Label */ ;
#line 23947
    if (tmpcfg.ok_to_use_lockfile) {
#line 23947
      ok_to_use_lockfile = tmpcfg.ok_to_use_lockfile == (char const   *)PARSE_YES;
    }
#line 23947
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
  {
#line 23948
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 23948
    if (tmpcfg.only_uppercase) {
#line 23948
      only_uppercase = tmpcfg.only_uppercase == (char const   *)PARSE_YES;
    }
#line 23948
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 23949
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 23949
    if (tmpcfg.simple_shapes) {
#line 23949
      simple_shapes = tmpcfg.simple_shapes == (char const   *)PARSE_YES;
    }
#line 23949
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 23950
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 23950
    if (tmpcfg.start_blank) {
#line 23950
      start_blank = tmpcfg.start_blank == (char const   *)PARSE_YES;
    }
#line 23950
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 23951
  while (1) {
    while_continue___26: /* CIL Label */ ;
#line 23951
    if (tmpcfg.use_print_config) {
#line 23951
      use_print_config = tmpcfg.use_print_config == (char const   *)PARSE_YES;
    }
#line 23951
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
  {
#line 23952
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 23952
    if (tmpcfg.use_sound) {
#line 23952
      use_sound = tmpcfg.use_sound == (char const   *)PARSE_YES;
    }
#line 23952
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 23953
  while (1) {
    while_continue___28: /* CIL Label */ ;
#line 23953
    if (tmpcfg.use_stereo) {
#line 23953
      use_stereo = tmpcfg.use_stereo == (char const   *)PARSE_YES;
    }
#line 23953
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
  {
#line 23954
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 23954
    if (tmpcfg.wheely) {
#line 23954
      wheely = tmpcfg.wheely == (char const   *)PARSE_YES;
    }
#line 23954
    goto while_break___29;
  }
  while_break___29: /* CIL Label */ ;
  }
  {
#line 23955
  while (1) {
    while_continue___30: /* CIL Label */ ;
#line 23955
    if (tmpcfg.mouseaccessibility) {
#line 23955
      mouseaccessibility = tmpcfg.mouseaccessibility == (char const   *)PARSE_YES;
    }
#line 23955
    goto while_break___30;
  }
  while_break___30: /* CIL Label */ ;
  }
  {
#line 23956
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 23956
    if (tmpcfg.onscreen_keyboard) {
#line 23956
      onscreen_keyboard = tmpcfg.onscreen_keyboard == (char const   *)PARSE_YES;
    }
#line 23956
    goto while_break___31;
  }
  while_break___31: /* CIL Label */ ;
  }
  {
#line 23957
  while (1) {
    while_continue___32: /* CIL Label */ ;
#line 23957
    if (tmpcfg.onscreen_keyboard_disable_change) {
#line 23957
      onscreen_keyboard_disable_change = tmpcfg.onscreen_keyboard_disable_change == (char const   *)PARSE_YES;
    }
#line 23957
    goto while_break___32;
  }
  while_break___32: /* CIL Label */ ;
  }
  {
#line 23958
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 23958
    if (tmpcfg._promptless_save_over) {
#line 23958
      _promptless_save_over = tmpcfg._promptless_save_over == (char const   *)PARSE_YES;
    }
#line 23958
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 23959
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 23959
    if (tmpcfg._promptless_save_over_new) {
#line 23959
      _promptless_save_over_new = tmpcfg._promptless_save_over_new == (char const   *)PARSE_YES;
    }
#line 23959
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
  {
#line 23960
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 23960
    if (tmpcfg._promptless_save_over_ask) {
#line 23960
      _promptless_save_over_ask = tmpcfg._promptless_save_over_ask == (char const   *)PARSE_YES;
    }
#line 23960
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 23963
  if (tmpcfg.parsertmp_windowsize) {
    {
#line 23967
    __cil_tmp23 = strtoul(tmpcfg.parsertmp_windowsize, & endp1, 10);
#line 23967
    w = (int )__cil_tmp23;
#line 23968
    __cil_tmp25 = strtoul((char const   *)(endp1 + 1), & endp2, 10);
#line 23968
    h = (int )__cil_tmp25;
    }
#line 23970
    if (tmpcfg.parsertmp_windowsize == endp1) {
      {
      {
      {
      {
#line 23972
      fprintf(stderr, "Window size \'%s\' is not understood.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      {
      {
      {
#line 23973
      exit(97);
      }
      }
      }
      }
    } else
#line 23970
    if (endp1 + 1 == endp2) {
      {
      {
      {
      {
#line 23972
      fprintf(stderr, "Window size \'%s\' is not understood.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      {
      {
      {
#line 23973
      exit(97);
      }
      }
      }
      }
    } else
#line 23970
    if ((int )*endp1 != 120) {
      {
      {
      {
      {
#line 23972
      fprintf(stderr, "Window size \'%s\' is not understood.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      {
      {
      {
#line 23973
      exit(97);
      }
      }
      }
      }
    } else
#line 23970
    if ((int )*endp2) {
      {
      {
      {
      {
#line 23972
      fprintf(stderr, "Window size \'%s\' is not understood.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      {
      {
      {
#line 23973
      exit(97);
      }
      }
      }
      }
    }
#line 23975
    if (w < 500) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    } else
#line 23975
    if (w > 32000) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    } else
#line 23975
    if (h < 480) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    } else
#line 23975
    if (h > 32000) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    } else
#line 23975
    if (h > w * 3) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    } else
#line 23975
    if (w > h * 4) {
      {
      {
      {
      {
      {
      {
#line 23977
      fprintf(stderr, "Window size \'%s\' is not reasonable.\n", tmpcfg.parsertmp_windowsize);
      }
      }
      }
      }
      }
      {
      {
      {
      {
      {
#line 23978
      exit(93);
      }
      }
      }
      }
      }
      }
    }
#line 23980
    WINDOW_WIDTH = w;
#line 23981
    WINDOW_HEIGHT = h;
  }
#line 23983
  if (tmpcfg.parsertmp_fullscreen_native) {
    {
#line 23986
    __cil_tmp26 = strcmp(tmpcfg.parsertmp_fullscreen_native, "native");
    }
#line 23986
    if (! __cil_tmp26) {
#line 23987
      native_screensize = 1;
    }
    {
#line 23988
    fullscreen = strcmp(tmpcfg.parsertmp_fullscreen_native, "no");
    }
  }
#line 23990
  if (tmpcfg.button_size) {
    {
#line 23992
    __cil_tmp29 = strtof(tmpcfg.button_size, (char **)((void *)0));
    }
    {
#line 23992
    __cil_tmp28 = strtof(tmpcfg.button_size, (char **)((void *)0));
    }
#line 23992
    if (__cil_tmp28 < (float )24) {
      {
      {
#line 23994
      fprintf(stderr, "Button size (now %s) must be between 24 and 192.\n", tmpcfg.button_size);
      }
      {
#line 23995
      exit(1);
      }
      }
    } else
#line 23992
    if (__cil_tmp29 > (float )192) {
      {
      {
#line 23994
      fprintf(stderr, "Button size (now %s) must be between 24 and 192.\n", tmpcfg.button_size);
      }
      {
#line 23995
      exit(1);
      }
      }
    }
    {
#line 23997
    __cil_tmp30 = strtof(tmpcfg.button_size, (char **)((void *)0));
#line 23997
    button_scale = __cil_tmp30 / (float )48;
    }
  } else {
#line 24000
    button_scale = (float )1;
  }
#line 24001
  if (tmpcfg.colors_rows) {
    {
#line 24003
    __cil_tmp31 = strtof(tmpcfg.colors_rows, (char **)((void *)0));
    }
#line 24003
    if (__cil_tmp31 > (float )3) {
      {
#line 24005
      fprintf(stderr, "Color rows (now %s) must be between 1 and 3.\n", tmpcfg.colors_rows);
#line 24006
      exit(1);
      }
    }
    {
#line 24008
    __cil_tmp32 = strtof(tmpcfg.colors_rows, (char **)((void *)0));
#line 24008
    colors_rows = (int )__cil_tmp32;
    }
  } else {
#line 24011
    colors_rows = 1;
  }
#line 24012
  if (tmpcfg.stamp_size_override) {
    {
#line 24014
    __cil_tmp33 = strcmp(tmpcfg.stamp_size_override, "default");
    }
#line 24014
    if (! __cil_tmp33) {
#line 24015
      stamp_size_override = - 1;
    } else {
      {
#line 24019
      stamp_size_override = atoi(tmpcfg.stamp_size_override);
      }
#line 24020
      if (stamp_size_override > 10) {
#line 24021
        stamp_size_override = 10;
      }
    }
  }
#line 24025
  if (tmpcfg.rotate_orientation) {
    {
#line 24026
    __cil_tmp35 = strcmp(tmpcfg.rotate_orientation, "portrait\220");
#line 24026
    rotate_orientation = ! __cil_tmp35;
    }
  }
#line 24027
  if (tmpcfg.colorfile) {
    {
#line 24028
    safe_strncpy((char *)colorfile, tmpcfg.colorfile, sizeof(colorfile));
    }
  }
#line 24029
  if (tmpcfg.print_delay) {
    {
#line 24031
    print_delay = atoi(tmpcfg.print_delay);
#line 24032
    last_print_time = - print_delay;
    }
  }
#line 24035
  if (tmpcfg.printcommand) {
#line 24036
    printcommand = tmpcfg.printcommand;
  }
#line 24037
  if (tmpcfg.altprintcommand) {
#line 24038
    altprintcommand = tmpcfg.altprintcommand;
  }
#line 24040
  if (tmpcfg.alt_print_command_default) {
    {
#line 24043
    __cil_tmp37 = strcmp(tmpcfg.alt_print_command_default, "always");
    }
#line 24043
    if (! __cil_tmp37) {
#line 24044
      alt_print_command_default = 1;
    } else {
      {
#line 24045
      __cil_tmp38 = strcmp(tmpcfg.alt_print_command_default, "never");
      }
#line 24045
      if (! __cil_tmp38) {
#line 24046
        alt_print_command_default = 2;
      } else {
#line 24048
        alt_print_command_default = 0;
      }
    }
  }
#line 24051
  if (tmpcfg.papersize) {
#line 24052
    papersize = tmpcfg.papersize;
  }
#line 24054
  if (tmpcfg.joystick_dev) {
    {
#line 24056
    __cil_tmp39 = strcmp(tmpcfg.joystick_dev, "list");
    }
#line 24056
    if (__cil_tmp39 == 0) {
#line 24058
      joystick_dev = - 1;
    } else {
      {
#line 24062
      __cil_tmp41 = strtof(tmpcfg.joystick_dev, (char **)((void *)0));
      }
      {
#line 24062
      __cil_tmp40 = strtof(tmpcfg.joystick_dev, (char **)((void *)0));
      }
#line 24062
      if (__cil_tmp40 < (float )0) {
        {
        {
#line 24064
        fprintf(stderr, "Joystick dev (now %s) must be between 0 and 100.\n", tmpcfg.joystick_dev);
        }
        {
#line 24065
        exit(1);
        }
        }
      } else
#line 24062
      if (__cil_tmp41 > (float )100) {
        {
        {
#line 24064
        fprintf(stderr, "Joystick dev (now %s) must be between 0 and 100.\n", tmpcfg.joystick_dev);
        }
        {
#line 24065
        exit(1);
        }
        }
      }
      {
#line 24067
      __cil_tmp42 = strtof(tmpcfg.joystick_dev, (char **)((void *)0));
#line 24067
      joystick_dev = (int )__cil_tmp42;
      }
    }
  }
#line 24070
  if (tmpcfg.joystick_slowness) {
    {
#line 24072
    __cil_tmp44 = strtof(tmpcfg.joystick_slowness, (char **)((void *)0));
    }
    {
#line 24072
    __cil_tmp43 = strtof(tmpcfg.joystick_slowness, (char **)((void *)0));
    }
#line 24072
    if (__cil_tmp43 < (float )0) {
      {
      {
#line 24074
      fprintf(stderr, "Joystick slowness (now %s) must be between 0 and 500.\n", tmpcfg.joystick_slowness);
      }
      {
#line 24075
      exit(1);
      }
      }
    } else
#line 24072
    if (__cil_tmp44 > (float )500) {
      {
      {
#line 24074
      fprintf(stderr, "Joystick slowness (now %s) must be between 0 and 500.\n", tmpcfg.joystick_slowness);
      }
      {
#line 24075
      exit(1);
      }
      }
    }
    {
#line 24077
    __cil_tmp45 = strtof(tmpcfg.joystick_slowness, (char **)((void *)0));
#line 24077
    joystick_slowness = (int )__cil_tmp45;
    }
  }
#line 24079
  if (tmpcfg.joystick_lowthreshold) {
    {
#line 24081
    __cil_tmp47 = strtof(tmpcfg.joystick_lowthreshold, (char **)((void *)0));
    }
    {
#line 24081
    __cil_tmp46 = strtof(tmpcfg.joystick_lowthreshold, (char **)((void *)0));
    }
#line 24081
    if (__cil_tmp46 < (float )0) {
      {
      {
#line 24084
      fprintf(stderr, "Joystick lower threshold (now %s)  must be between 0 and 32766",
              tmpcfg.joystick_lowthreshold);
      }
      {
#line 24085
      exit(1);
      }
      }
    } else
#line 24081
    if (__cil_tmp47 > (float )32766) {
      {
      {
#line 24084
      fprintf(stderr, "Joystick lower threshold (now %s)  must be between 0 and 32766",
              tmpcfg.joystick_lowthreshold);
      }
      {
#line 24085
      exit(1);
      }
      }
    }
    {
#line 24087
    __cil_tmp48 = strtof(tmpcfg.joystick_lowthreshold, (char **)((void *)0));
#line 24087
    joystick_low_threshold = (int )__cil_tmp48;
    }
  }
#line 24089
  if (tmpcfg.joystick_maxsteps) {
    {
#line 24091
    __cil_tmp50 = strtof(tmpcfg.joystick_maxsteps, (char **)((void *)0));
    }
    {
#line 24091
    __cil_tmp49 = strtof(tmpcfg.joystick_maxsteps, (char **)((void *)0));
    }
#line 24091
    if (__cil_tmp49 < (float )1) {
      {
      {
#line 24094
      fprintf(stderr, "Joystick max steps (now %s)  must be between 1 and 7", tmpcfg.joystick_maxsteps);
      }
      {
#line 24095
      exit(1);
      }
      }
    } else
#line 24091
    if (__cil_tmp50 > (float )7) {
      {
      {
#line 24094
      fprintf(stderr, "Joystick max steps (now %s)  must be between 1 and 7", tmpcfg.joystick_maxsteps);
      }
      {
#line 24095
      exit(1);
      }
      }
    }
    {
#line 24097
    __cil_tmp51 = strtof(tmpcfg.joystick_maxsteps, (char **)((void *)0));
#line 24097
    joystick_maxsteps = (int )__cil_tmp51;
    }
  }
#line 24099
  if (tmpcfg.joystick_hat_slowness) {
    {
#line 24101
    __cil_tmp53 = strtof(tmpcfg.joystick_hat_slowness, (char **)((void *)0));
    }
    {
#line 24101
    __cil_tmp52 = strtof(tmpcfg.joystick_hat_slowness, (char **)((void *)0));
    }
#line 24101
    if (__cil_tmp52 < (float )0) {
      {
      {
#line 24103
      fprintf(stderr, "Joystick hat slowness (now %s) must be between 0 and 500.\n",
              tmpcfg.joystick_hat_slowness);
      }
      {
#line 24104
      exit(1);
      }
      }
    } else
#line 24101
    if (__cil_tmp53 > (float )500) {
      {
      {
#line 24103
      fprintf(stderr, "Joystick hat slowness (now %s) must be between 0 and 500.\n",
              tmpcfg.joystick_hat_slowness);
      }
      {
#line 24104
      exit(1);
      }
      }
    }
    {
#line 24106
    __cil_tmp54 = strtof(tmpcfg.joystick_hat_slowness, (char **)((void *)0));
#line 24106
    joystick_hat_slowness = (int )__cil_tmp54;
    }
  }
#line 24108
  if (tmpcfg.joystick_hat_timeout) {
    {
#line 24110
    __cil_tmp56 = strtof(tmpcfg.joystick_hat_timeout, (char **)((void *)0));
    }
    {
#line 24110
    __cil_tmp55 = strtof(tmpcfg.joystick_hat_timeout, (char **)((void *)0));
    }
#line 24110
    if (__cil_tmp55 < (float )0) {
      {
      {
#line 24113
      fprintf(stderr, "Joystick hat timeout (now %s)  must be between 0 and 3000",
              tmpcfg.joystick_hat_timeout);
      }
      {
#line 24114
      exit(1);
      }
      }
    } else
#line 24110
    if (__cil_tmp56 > (float )3000) {
      {
      {
#line 24113
      fprintf(stderr, "Joystick hat timeout (now %s)  must be between 0 and 3000",
              tmpcfg.joystick_hat_timeout);
      }
      {
#line 24114
      exit(1);
      }
      }
    }
    {
#line 24116
    __cil_tmp57 = strtof(tmpcfg.joystick_hat_timeout, (char **)((void *)0));
#line 24116
    joystick_hat_timeout = (Uint32 )__cil_tmp57;
    }
  }
#line 24118
  if (tmpcfg.joystick_button_escape) {
    {
#line 24120
    __cil_tmp59 = strtof(tmpcfg.joystick_button_escape, (char **)((void *)0));
    }
    {
#line 24120
    __cil_tmp58 = strtof(tmpcfg.joystick_button_escape, (char **)((void *)0));
    }
#line 24120
    if (__cil_tmp58 < (float )0) {
      {
      {
#line 24123
      fprintf(stderr, "Joystick button escape shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_escape);
      }
      {
#line 24124
      exit(1);
      }
      }
    } else
#line 24120
    if (__cil_tmp59 > (float )254) {
      {
      {
#line 24123
      fprintf(stderr, "Joystick button escape shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_escape);
      }
      {
#line 24124
      exit(1);
      }
      }
    }
    {
#line 24126
    __cil_tmp60 = strtof(tmpcfg.joystick_button_escape, (char **)((void *)0));
#line 24126
    joystick_button_escape = (int )__cil_tmp60;
    }
  }
#line 24128
  if (tmpcfg.joystick_button_selectbrushtool) {
    {
#line 24130
    __cil_tmp62 = strtof(tmpcfg.joystick_button_selectbrushtool, (char **)((void *)0));
    }
    {
#line 24130
    __cil_tmp61 = strtof(tmpcfg.joystick_button_selectbrushtool, (char **)((void *)0));
    }
#line 24130
    if (__cil_tmp61 < (float )0) {
      {
      {
#line 24134
      fprintf(stderr, "Joystick button brush tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectbrushtool);
      }
      {
#line 24136
      exit(1);
      }
      }
    } else
#line 24130
    if (__cil_tmp62 > (float )254) {
      {
      {
#line 24134
      fprintf(stderr, "Joystick button brush tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectbrushtool);
      }
      {
#line 24136
      exit(1);
      }
      }
    }
    {
#line 24138
    __cil_tmp63 = strtof(tmpcfg.joystick_button_selectbrushtool, (char **)((void *)0));
#line 24138
    joystick_button_selectbrushtool = (int )__cil_tmp63;
    }
  }
#line 24140
  if (tmpcfg.joystick_button_selectstamptool) {
    {
#line 24142
    __cil_tmp65 = strtof(tmpcfg.joystick_button_selectstamptool, (char **)((void *)0));
    }
    {
#line 24142
    __cil_tmp64 = strtof(tmpcfg.joystick_button_selectstamptool, (char **)((void *)0));
    }
#line 24142
    if (__cil_tmp64 < (float )0) {
      {
      {
#line 24146
      fprintf(stderr, "Joystick button stamp tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectstamptool);
      }
      {
#line 24148
      exit(1);
      }
      }
    } else
#line 24142
    if (__cil_tmp65 > (float )254) {
      {
      {
#line 24146
      fprintf(stderr, "Joystick button stamp tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectstamptool);
      }
      {
#line 24148
      exit(1);
      }
      }
    }
    {
#line 24150
    __cil_tmp66 = strtof(tmpcfg.joystick_button_selectstamptool, (char **)((void *)0));
#line 24150
    joystick_button_selectstamptool = (int )__cil_tmp66;
    }
  }
#line 24152
  if (tmpcfg.joystick_button_selectlinestool) {
    {
#line 24154
    __cil_tmp68 = strtof(tmpcfg.joystick_button_selectlinestool, (char **)((void *)0));
    }
    {
#line 24154
    __cil_tmp67 = strtof(tmpcfg.joystick_button_selectlinestool, (char **)((void *)0));
    }
#line 24154
    if (__cil_tmp67 < (float )0) {
      {
      {
#line 24158
      fprintf(stderr, "Joystick button lines tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectlinestool);
      }
      {
#line 24160
      exit(1);
      }
      }
    } else
#line 24154
    if (__cil_tmp68 > (float )254) {
      {
      {
#line 24158
      fprintf(stderr, "Joystick button lines tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectlinestool);
      }
      {
#line 24160
      exit(1);
      }
      }
    }
    {
#line 24162
    __cil_tmp69 = strtof(tmpcfg.joystick_button_selectlinestool, (char **)((void *)0));
#line 24162
    joystick_button_selectlinestool = (int )__cil_tmp69;
    }
  }
#line 24164
  if (tmpcfg.joystick_button_selectshapestool) {
    {
#line 24166
    __cil_tmp71 = strtof(tmpcfg.joystick_button_selectshapestool, (char **)((void *)0));
    }
    {
#line 24166
    __cil_tmp70 = strtof(tmpcfg.joystick_button_selectshapestool, (char **)((void *)0));
    }
#line 24166
    if (__cil_tmp70 < (float )0) {
      {
      {
#line 24170
      fprintf(stderr, "Joystick button shapes tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selectshapestool);
      }
      {
#line 24172
      exit(1);
      }
      }
    } else
#line 24166
    if (__cil_tmp71 > (float )254) {
      {
      {
#line 24170
      fprintf(stderr, "Joystick button shapes tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selectshapestool);
      }
      {
#line 24172
      exit(1);
      }
      }
    }
    {
#line 24174
    __cil_tmp72 = strtof(tmpcfg.joystick_button_selectshapestool, (char **)((void *)0));
#line 24174
    joystick_button_selectshapestool = (int )__cil_tmp72;
    }
  }
#line 24176
  if (tmpcfg.joystick_button_selecttexttool) {
    {
#line 24178
    __cil_tmp74 = strtof(tmpcfg.joystick_button_selecttexttool, (char **)((void *)0));
    }
    {
#line 24178
    __cil_tmp73 = strtof(tmpcfg.joystick_button_selecttexttool, (char **)((void *)0));
    }
#line 24178
    if (__cil_tmp73 < (float )0) {
      {
      {
#line 24182
      fprintf(stderr, "Joystick button text tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selecttexttool);
      }
      {
#line 24184
      exit(1);
      }
      }
    } else
#line 24178
    if (__cil_tmp74 > (float )254) {
      {
      {
#line 24182
      fprintf(stderr, "Joystick button text tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selecttexttool);
      }
      {
#line 24184
      exit(1);
      }
      }
    }
    {
#line 24186
    __cil_tmp75 = strtof(tmpcfg.joystick_button_selecttexttool, (char **)((void *)0));
#line 24186
    joystick_button_selecttexttool = (int )__cil_tmp75;
    }
  }
#line 24188
  if (tmpcfg.joystick_button_selectlabeltool) {
    {
#line 24190
    __cil_tmp77 = strtof(tmpcfg.joystick_button_selectlabeltool, (char **)((void *)0));
    }
    {
#line 24190
    __cil_tmp76 = strtof(tmpcfg.joystick_button_selectlabeltool, (char **)((void *)0));
    }
#line 24190
    if (__cil_tmp76 < (float )0) {
      {
      {
#line 24194
      fprintf(stderr, "Joystick button label tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectlabeltool);
      }
      {
#line 24196
      exit(1);
      }
      }
    } else
#line 24190
    if (__cil_tmp77 > (float )254) {
      {
      {
#line 24194
      fprintf(stderr, "Joystick button label tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectlabeltool);
      }
      {
#line 24196
      exit(1);
      }
      }
    }
    {
#line 24198
    __cil_tmp78 = strtof(tmpcfg.joystick_button_selectlabeltool, (char **)((void *)0));
#line 24198
    joystick_button_selectlabeltool = (int )__cil_tmp78;
    }
  }
#line 24200
  if (tmpcfg.joystick_button_selectmagictool) {
    {
#line 24202
    __cil_tmp80 = strtof(tmpcfg.joystick_button_selectmagictool, (char **)((void *)0));
    }
    {
#line 24202
    __cil_tmp79 = strtof(tmpcfg.joystick_button_selectmagictool, (char **)((void *)0));
    }
#line 24202
    if (__cil_tmp79 < (float )0) {
      {
      {
#line 24206
      fprintf(stderr, "Joystick button magic tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectmagictool);
      }
      {
#line 24208
      exit(1);
      }
      }
    } else
#line 24202
    if (__cil_tmp80 > (float )254) {
      {
      {
#line 24206
      fprintf(stderr, "Joystick button magic tool shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_selectmagictool);
      }
      {
#line 24208
      exit(1);
      }
      }
    }
    {
#line 24210
    __cil_tmp81 = strtof(tmpcfg.joystick_button_selectmagictool, (char **)((void *)0));
#line 24210
    joystick_button_selectmagictool = (int )__cil_tmp81;
    }
  }
#line 24212
  if (tmpcfg.joystick_button_undo) {
    {
#line 24214
    __cil_tmp83 = strtof(tmpcfg.joystick_button_undo, (char **)((void *)0));
    }
    {
#line 24214
    __cil_tmp82 = strtof(tmpcfg.joystick_button_undo, (char **)((void *)0));
    }
#line 24214
    if (__cil_tmp82 < (float )0) {
      {
      {
#line 24217
      fprintf(stderr, "Joystick button undo shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_undo);
      }
      {
#line 24218
      exit(1);
      }
      }
    } else
#line 24214
    if (__cil_tmp83 > (float )254) {
      {
      {
#line 24217
      fprintf(stderr, "Joystick button undo shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_undo);
      }
      {
#line 24218
      exit(1);
      }
      }
    }
    {
#line 24220
    __cil_tmp84 = strtof(tmpcfg.joystick_button_undo, (char **)((void *)0));
#line 24220
    joystick_button_undo = (int )__cil_tmp84;
    }
  }
#line 24222
  if (tmpcfg.joystick_button_redo) {
    {
#line 24224
    __cil_tmp86 = strtof(tmpcfg.joystick_button_redo, (char **)((void *)0));
    }
    {
#line 24224
    __cil_tmp85 = strtof(tmpcfg.joystick_button_redo, (char **)((void *)0));
    }
#line 24224
    if (__cil_tmp85 < (float )0) {
      {
      {
#line 24227
      fprintf(stderr, "Joystick button redo shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_redo);
      }
      {
#line 24228
      exit(1);
      }
      }
    } else
#line 24224
    if (__cil_tmp86 > (float )254) {
      {
      {
#line 24227
      fprintf(stderr, "Joystick button redo shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_redo);
      }
      {
#line 24228
      exit(1);
      }
      }
    }
    {
#line 24230
    __cil_tmp87 = strtof(tmpcfg.joystick_button_redo, (char **)((void *)0));
#line 24230
    joystick_button_redo = (int )__cil_tmp87;
    }
  }
#line 24232
  if (tmpcfg.joystick_button_selecterasertool) {
    {
#line 24234
    __cil_tmp89 = strtof(tmpcfg.joystick_button_selecterasertool, (char **)((void *)0));
    }
    {
#line 24234
    __cil_tmp88 = strtof(tmpcfg.joystick_button_selecterasertool, (char **)((void *)0));
    }
#line 24234
    if (__cil_tmp88 < (float )0) {
      {
      {
#line 24238
      fprintf(stderr, "Joystick button eraser tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selecterasertool);
      }
      {
#line 24240
      exit(1);
      }
      }
    } else
#line 24234
    if (__cil_tmp89 > (float )254) {
      {
      {
#line 24238
      fprintf(stderr, "Joystick button eraser tool shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_selecterasertool);
      }
      {
#line 24240
      exit(1);
      }
      }
    }
    {
#line 24242
    __cil_tmp90 = strtof(tmpcfg.joystick_button_selecterasertool, (char **)((void *)0));
#line 24242
    joystick_button_selecterasertool = (int )__cil_tmp90;
    }
  }
#line 24244
  if (tmpcfg.joystick_button_new) {
    {
#line 24246
    __cil_tmp92 = strtof(tmpcfg.joystick_button_new, (char **)((void *)0));
    }
    {
#line 24246
    __cil_tmp91 = strtof(tmpcfg.joystick_button_new, (char **)((void *)0));
    }
#line 24246
    if (__cil_tmp91 < (float )0) {
      {
      {
#line 24249
      fprintf(stderr, "Joystick button new shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_new);
      }
      {
#line 24250
      exit(1);
      }
      }
    } else
#line 24246
    if (__cil_tmp92 > (float )254) {
      {
      {
#line 24249
      fprintf(stderr, "Joystick button new shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_new);
      }
      {
#line 24250
      exit(1);
      }
      }
    }
    {
#line 24252
    __cil_tmp93 = strtof(tmpcfg.joystick_button_new, (char **)((void *)0));
#line 24252
    joystick_button_new = (int )__cil_tmp93;
    }
  }
#line 24254
  if (tmpcfg.joystick_button_open) {
    {
#line 24256
    __cil_tmp95 = strtof(tmpcfg.joystick_button_open, (char **)((void *)0));
    }
    {
#line 24256
    __cil_tmp94 = strtof(tmpcfg.joystick_button_open, (char **)((void *)0));
    }
#line 24256
    if (__cil_tmp94 < (float )0) {
      {
      {
#line 24259
      fprintf(stderr, "Joystick button open shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_open);
      }
      {
#line 24260
      exit(1);
      }
      }
    } else
#line 24256
    if (__cil_tmp95 > (float )254) {
      {
      {
#line 24259
      fprintf(stderr, "Joystick button open shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_open);
      }
      {
#line 24260
      exit(1);
      }
      }
    }
    {
#line 24262
    __cil_tmp96 = strtof(tmpcfg.joystick_button_open, (char **)((void *)0));
#line 24262
    joystick_button_open = (int )__cil_tmp96;
    }
  }
#line 24264
  if (tmpcfg.joystick_button_save) {
    {
#line 24266
    __cil_tmp98 = strtof(tmpcfg.joystick_button_save, (char **)((void *)0));
    }
    {
#line 24266
    __cil_tmp97 = strtof(tmpcfg.joystick_button_save, (char **)((void *)0));
    }
#line 24266
    if (__cil_tmp97 < (float )0) {
      {
      {
#line 24269
      fprintf(stderr, "Joystick button save shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_save);
      }
      {
#line 24270
      exit(1);
      }
      }
    } else
#line 24266
    if (__cil_tmp98 > (float )254) {
      {
      {
#line 24269
      fprintf(stderr, "Joystick button save shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_save);
      }
      {
#line 24270
      exit(1);
      }
      }
    }
    {
#line 24272
    __cil_tmp99 = strtof(tmpcfg.joystick_button_save, (char **)((void *)0));
#line 24272
    joystick_button_save = (int )__cil_tmp99;
    }
  }
#line 24274
  if (tmpcfg.joystick_button_pagesetup) {
    {
#line 24276
    __cil_tmp101 = strtof(tmpcfg.joystick_button_pagesetup, (char **)((void *)0));
    }
    {
#line 24276
    __cil_tmp100 = strtof(tmpcfg.joystick_button_pagesetup, (char **)((void *)0));
    }
#line 24276
    if (__cil_tmp100 < (float )0) {
      {
      {
#line 24279
      fprintf(stderr, "Joystick button page setup shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_pagesetup);
      }
      {
#line 24281
      exit(1);
      }
      }
    } else
#line 24276
    if (__cil_tmp101 > (float )254) {
      {
      {
#line 24279
      fprintf(stderr, "Joystick button page setup shortcurt (now %s)  must be between 0 and 254\230\001",
              tmpcfg.joystick_button_pagesetup);
      }
      {
#line 24281
      exit(1);
      }
      }
    }
    {
#line 24283
    __cil_tmp102 = strtof(tmpcfg.joystick_button_pagesetup, (char **)((void *)0));
#line 24283
    joystick_button_pagesetup = (int )__cil_tmp102;
    }
  }
#line 24285
  if (tmpcfg.joystick_button_print) {
    {
#line 24287
    __cil_tmp104 = strtof(tmpcfg.joystick_button_print, (char **)((void *)0));
    }
    {
#line 24287
    __cil_tmp103 = strtof(tmpcfg.joystick_button_print, (char **)((void *)0));
    }
#line 24287
    if (__cil_tmp103 < (float )0) {
      {
      {
#line 24290
      fprintf(stderr, "Joystick button print shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_print);
      }
      {
#line 24291
      exit(1);
      }
      }
    } else
#line 24287
    if (__cil_tmp104 > (float )254) {
      {
      {
#line 24290
      fprintf(stderr, "Joystick button print shortcurt (now %s)  must be between 0 and 254",
              tmpcfg.joystick_button_print);
      }
      {
#line 24291
      exit(1);
      }
      }
    }
    {
#line 24293
    __cil_tmp105 = strtof(tmpcfg.joystick_button_print, (char **)((void *)0));
#line 24293
    joystick_button_print = (int )__cil_tmp105;
    }
  }
#line 24295
  if (tmpcfg.joystick_buttons_ignore) {
    {
#line 24299
    token = strtok((char *)tmpcfg.joystick_buttons_ignore, ",");
    }
    {
#line 24300
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 24300
      if (! (token != (void *)0)) {
#line 24300
        goto while_break___36;
      }
      {
#line 24302
      __cil_tmp109 = strtof((char const   *)token, (char **)((void *)0));
      }
      {
#line 24302
      __cil_tmp108 = strtof((char const   *)token, (char **)((void *)0));
      }
#line 24302
      if (__cil_tmp108 < (float )0) {
        {
        {
#line 24305
        fprintf(stderr, "Joystick buttons must be between 0 and 254 (don\'t like %s)",
                tmpcfg.joystick_buttons_ignore);
        }
        {
#line 24306
        exit(1);
        }
        }
      } else
#line 24302
      if (__cil_tmp109 > (float )254) {
        {
        {
#line 24305
        fprintf(stderr, "Joystick buttons must be between 0 and 254 (don\'t like %s)",
                tmpcfg.joystick_buttons_ignore);
        }
        {
#line 24306
        exit(1);
        }
        }
      }
      {
#line 24308
      __cil_tmp111 = strtof((char const   *)token, (char **)((void *)0));
      }
      {
#line 24308
      __cil_tmp110 = joystick_buttons_ignore_len;
#line 24308
      joystick_buttons_ignore_len ++;
#line 24308
      joystick_buttons_ignore[__cil_tmp110] = (int )__cil_tmp111;
#line 24309
      token = strtok((char *)((void *)0), ",");
      }
    }
    while_break___36: /* CIL Label */ ;
    }
  }
#line 24315
  if (tmpcfg.onscreen_keyboard_layout) {
    {
#line 24317
    onscreen_keyboard_layout = strdup(tmpcfg.onscreen_keyboard_layout);
#line 24318
    onscreen_keyboard = ! 0;
    }
  }
#line 24321
  if (tmpcfg.onscreen_keyboard_disable_change) {
#line 24323
    onscreen_keyboard = ! 0;
  }
#line 24331
  if (_promptless_save_over_ask) {
#line 24333
    promptless_save = 0;
  } else
#line 24335
  if (_promptless_save_over_new) {
#line 24337
    promptless_save = 2;
  } else
#line 24339
  if (_promptless_save_over) {
#line 24341
    promptless_save = 1;
  }
  return;
}
}
#line 24349 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void chdir_to_binary(char *argv0 ) 
{ 


  {
  return;
}
}
#line 24417 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void setup_colors(void) 
{ 
  FILE *fi ;
  int i ;
  int j ;
  FILE *__cil_tmp4 ;
  int max ;
  int per ;
  char str[80] ;
  char tmp_str[80] ;
  int count ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  unsigned long __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp39 ;
  int __cil_tmp40 ;
  unsigned long __cil_tmp41 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *__cil_tmp60 ;
  int __cil_tmp61 ;
  int __cil_tmp62 ;
  char *__cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp65 ;
  void *__cil_tmp66 ;
  void *__cil_tmp67 ;
  void *__cil_tmp68 ;
  int __cil_tmp69 ;
  char *__cil_tmp70 ;
  int __cil_tmp71 ;
  void *__cil_tmp72 ;
  void *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  void *__cil_tmp76 ;
  int __cil_tmp77 ;
  void *__cil_tmp78 ;
  void *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  void *__cil_tmp82 ;
  int __cil_tmp83 ;

  {
#line 24424
  if ((int )colorfile[0] != 0) {
    {
#line 24426
    fi = fopen((char const   *)((char *)colorfile), "r");
    }
#line 24427
    if (fi == (void *)0) {
      {
#line 24429
      fprintf(stderr, "\nWarning, could not open color file. Using defaults.\n");
#line 24430
      perror((char const   *)((char *)colorfile));
#line 24431
      colorfile[0] = (char )'\000';
      }
    } else {
#line 24435
      max = 0;
#line 24435
      per = 5;
#line 24439
      NUM_COLORS = 0;
      {
#line 24441
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 24443
        __cil_tmp11 = fgets((char *)str, (int )sizeof(str), fi);
        }
#line 24443
        if (__cil_tmp11) {
          {
#line 24445
          __cil_tmp12 = feof(fi);
          }
#line 24445
          if (! __cil_tmp12) {
#line 24447
            if (NUM_COLORS + 1 > max) {
              {
#line 24449
              color_hexes = (Uint8 **)realloc(color_hexes, sizeof(Uint8 *) * (unsigned long )(max + per));
#line 24450
              color_names = (char **)realloc(color_names, sizeof(char *) * (unsigned long )(max + per));
#line 24452
              i = max;
              }
              {
#line 24452
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 24452
                if (! (i < max + per)) {
#line 24452
                  goto while_break___0;
                }
                {
#line 24453
                *(color_hexes + i) = (Uint8 *)malloc(sizeof(Uint8 ) * 3UL);
                }
#line 24452
                i ++;
              }
              while_break___0: /* CIL Label */ ;
              }
#line 24455
              max += per;
            }
            {
#line 24458
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 24458
              __cil_tmp18 = strlen((char const   *)((char *)str));
              }
              {
#line 24458
              __cil_tmp17 = strlen((char const   *)((char *)str));
              }
#line 24458
              if (! ((int )str[__cil_tmp17 - 1UL] == 10 || (int )str[__cil_tmp18 - 1UL] == 13)) {
#line 24458
                goto while_break___1;
              }
              {
#line 24459
              __cil_tmp19 = strlen((char const   *)((char *)str));
#line 24459
              str[__cil_tmp19 - 1UL] = (char )'\000';
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 24461
            if ((int )str[0] == 35) {
              {
#line 24465
              sscanf((char const   *)((char *)str + 1), "%s %n", (char *)tmp_str,
                     & count);
#line 24467
              __cil_tmp20 = strlen((char const   *)((char *)tmp_str));
              }
#line 24467
              if (__cil_tmp20 == 6UL) {
#line 24471
                if ((int )tmp_str[1] >= 48 && (int )tmp_str[1] <= 57) {
#line 24471
                  tmp___4 = (int )tmp_str[1] - 48;
                } else {
#line 24471
                  if ((int )tmp_str[1] >= 65 && (int )tmp_str[1] <= 70) {
#line 24471
                    tmp___3 = ((int )tmp_str[1] - 65) + 10;
                  } else {
#line 24471
                    if ((int )tmp_str[1] >= 97 && (int )tmp_str[1] <= 102) {
#line 24471
                      tmp___2 = ((int )tmp_str[1] - 97) + 10;
                    } else {
#line 24471
                      tmp___2 = 0;
                    }
#line 24471
                    tmp___3 = tmp___2;
                  }
#line 24471
                  tmp___4 = tmp___3;
                }
#line 24471
                if ((int )tmp_str[0] >= 48 && (int )tmp_str[0] <= 57) {
#line 24471
                  tmp___1 = (int )tmp_str[0] - 48;
                } else {
#line 24471
                  if ((int )tmp_str[0] >= 65 && (int )tmp_str[0] <= 70) {
#line 24471
                    tmp___0 = ((int )tmp_str[0] - 65) + 10;
                  } else {
#line 24471
                    if ((int )tmp_str[0] >= 97 && (int )tmp_str[0] <= 102) {
#line 24471
                      tmp = ((int )tmp_str[0] - 97) + 10;
                    } else {
#line 24471
                      tmp = 0;
                    }
#line 24471
                    tmp___0 = tmp;
                  }
#line 24471
                  tmp___1 = tmp___0;
                }
#line 24471
                *(*(color_hexes + NUM_COLORS) + 0) = (Uint8 )((tmp___1 << 4) + tmp___4);
#line 24472
                if ((int )tmp_str[3] >= 48 && (int )tmp_str[3] <= 57) {
#line 24472
                  tmp___10 = (int )tmp_str[3] - 48;
                } else {
#line 24472
                  if ((int )tmp_str[3] >= 65 && (int )tmp_str[3] <= 70) {
#line 24472
                    tmp___9 = ((int )tmp_str[3] - 65) + 10;
                  } else {
#line 24472
                    if ((int )tmp_str[3] >= 97 && (int )tmp_str[3] <= 102) {
#line 24472
                      tmp___8 = ((int )tmp_str[3] - 97) + 10;
                    } else {
#line 24472
                      tmp___8 = 0;
                    }
#line 24472
                    tmp___9 = tmp___8;
                  }
#line 24472
                  tmp___10 = tmp___9;
                }
#line 24472
                if ((int )tmp_str[2] >= 48 && (int )tmp_str[2] <= 57) {
#line 24472
                  tmp___7 = (int )tmp_str[2] - 48;
                } else {
#line 24472
                  if ((int )tmp_str[2] >= 65 && (int )tmp_str[2] <= 70) {
#line 24472
                    tmp___6 = ((int )tmp_str[2] - 65) + 10;
                  } else {
#line 24472
                    if ((int )tmp_str[2] >= 97 && (int )tmp_str[2] <= 102) {
#line 24472
                      tmp___5 = ((int )tmp_str[2] - 97) + 10;
                    } else {
#line 24472
                      tmp___5 = 0;
                    }
#line 24472
                    tmp___6 = tmp___5;
                  }
#line 24472
                  tmp___7 = tmp___6;
                }
#line 24472
                *(*(color_hexes + NUM_COLORS) + 1) = (Uint8 )((tmp___7 << 4) + tmp___10);
#line 24473
                if ((int )tmp_str[5] >= 48 && (int )tmp_str[5] <= 57) {
#line 24473
                  tmp___16 = (int )tmp_str[5] - 48;
                } else {
#line 24473
                  if ((int )tmp_str[5] >= 65 && (int )tmp_str[5] <= 70) {
#line 24473
                    tmp___15 = ((int )tmp_str[5] - 65) + 10;
                  } else {
#line 24473
                    if ((int )tmp_str[5] >= 97 && (int )tmp_str[5] <= 102) {
#line 24473
                      tmp___14 = ((int )tmp_str[5] - 97) + 10;
                    } else {
#line 24473
                      tmp___14 = 0;
                    }
#line 24473
                    tmp___15 = tmp___14;
                  }
#line 24473
                  tmp___16 = tmp___15;
                }
#line 24473
                if ((int )tmp_str[4] >= 48 && (int )tmp_str[4] <= 57) {
#line 24473
                  tmp___13 = (int )tmp_str[4] - 48;
                } else {
#line 24473
                  if ((int )tmp_str[4] >= 65 && (int )tmp_str[4] <= 70) {
#line 24473
                    tmp___12 = ((int )tmp_str[4] - 65) + 10;
                  } else {
#line 24473
                    if ((int )tmp_str[4] >= 97 && (int )tmp_str[4] <= 102) {
#line 24473
                      tmp___11 = ((int )tmp_str[4] - 97) + 10;
                    } else {
#line 24473
                      tmp___11 = 0;
                    }
#line 24473
                    tmp___12 = tmp___11;
                  }
#line 24473
                  tmp___13 = tmp___12;
                }
                {
#line 24473
                *(*(color_hexes + NUM_COLORS) + 2) = (Uint8 )((tmp___13 << 4) + tmp___16);
#line 24475
                *(color_names + NUM_COLORS) = strdup((char const   *)((char *)str + count));
#line 24476
                NUM_COLORS ++;
                }
              } else {
                {
#line 24478
                __cil_tmp41 = strlen((char const   *)((char *)tmp_str));
                }
#line 24478
                if (__cil_tmp41 == 3UL) {
#line 24482
                  if ((int )tmp_str[0] >= 48 && (int )tmp_str[0] <= 57) {
#line 24482
                    tmp___22 = (int )tmp_str[0] - 48;
                  } else {
#line 24482
                    if ((int )tmp_str[0] >= 65 && (int )tmp_str[0] <= 70) {
#line 24482
                      tmp___21 = ((int )tmp_str[0] - 65) + 10;
                    } else {
#line 24482
                      if ((int )tmp_str[0] >= 97 && (int )tmp_str[0] <= 102) {
#line 24482
                        tmp___20 = ((int )tmp_str[0] - 97) + 10;
                      } else {
#line 24482
                        tmp___20 = 0;
                      }
#line 24482
                      tmp___21 = tmp___20;
                    }
#line 24482
                    tmp___22 = tmp___21;
                  }
#line 24482
                  if ((int )tmp_str[0] >= 48 && (int )tmp_str[0] <= 57) {
#line 24482
                    tmp___19 = (int )tmp_str[0] - 48;
                  } else {
#line 24482
                    if ((int )tmp_str[0] >= 65 && (int )tmp_str[0] <= 70) {
#line 24482
                      tmp___18 = ((int )tmp_str[0] - 65) + 10;
                    } else {
#line 24482
                      if ((int )tmp_str[0] >= 97 && (int )tmp_str[0] <= 102) {
#line 24482
                        tmp___17 = ((int )tmp_str[0] - 97) + 10;
                      } else {
#line 24482
                        tmp___17 = 0;
                      }
#line 24482
                      tmp___18 = tmp___17;
                    }
#line 24482
                    tmp___19 = tmp___18;
                  }
#line 24482
                  *(*(color_hexes + NUM_COLORS) + 0) = (Uint8 )((tmp___19 << 4) + tmp___22);
#line 24483
                  if ((int )tmp_str[1] >= 48 && (int )tmp_str[1] <= 57) {
#line 24483
                    tmp___28 = (int )tmp_str[1] - 48;
                  } else {
#line 24483
                    if ((int )tmp_str[1] >= 65 && (int )tmp_str[1] <= 70) {
#line 24483
                      tmp___27 = ((int )tmp_str[1] - 65) + 10;
                    } else {
#line 24483
                      if ((int )tmp_str[1] >= 97 && (int )tmp_str[1] <= 102) {
#line 24483
                        tmp___26 = ((int )tmp_str[1] - 97) + 10;
                      } else {
#line 24483
                        tmp___26 = 0;
                      }
#line 24483
                      tmp___27 = tmp___26;
                    }
#line 24483
                    tmp___28 = tmp___27;
                  }
#line 24483
                  if ((int )tmp_str[1] >= 48 && (int )tmp_str[1] <= 57) {
#line 24483
                    tmp___25 = (int )tmp_str[1] - 48;
                  } else {
#line 24483
                    if ((int )tmp_str[1] >= 65 && (int )tmp_str[1] <= 70) {
#line 24483
                      tmp___24 = ((int )tmp_str[1] - 65) + 10;
                    } else {
#line 24483
                      if ((int )tmp_str[1] >= 97 && (int )tmp_str[1] <= 102) {
#line 24483
                        tmp___23 = ((int )tmp_str[1] - 97) + 10;
                      } else {
#line 24483
                        tmp___23 = 0;
                      }
#line 24483
                      tmp___24 = tmp___23;
                    }
#line 24483
                    tmp___25 = tmp___24;
                  }
#line 24483
                  *(*(color_hexes + NUM_COLORS) + 1) = (Uint8 )((tmp___25 << 4) + tmp___28);
#line 24484
                  if ((int )tmp_str[2] >= 48 && (int )tmp_str[2] <= 57) {
#line 24484
                    tmp___34 = (int )tmp_str[2] - 48;
                  } else {
#line 24484
                    if ((int )tmp_str[2] >= 65 && (int )tmp_str[2] <= 70) {
#line 24484
                      tmp___33 = ((int )tmp_str[2] - 65) + 10;
                    } else {
#line 24484
                      if ((int )tmp_str[2] >= 97 && (int )tmp_str[2] <= 102) {
#line 24484
                        tmp___32 = ((int )tmp_str[2] - 97) + 10;
                      } else {
#line 24484
                        tmp___32 = 0;
                      }
#line 24484
                      tmp___33 = tmp___32;
                    }
#line 24484
                    tmp___34 = tmp___33;
                  }
#line 24484
                  if ((int )tmp_str[2] >= 48 && (int )tmp_str[2] <= 57) {
#line 24484
                    tmp___31 = (int )tmp_str[2] - 48;
                  } else {
#line 24484
                    if ((int )tmp_str[2] >= 65 && (int )tmp_str[2] <= 70) {
#line 24484
                      tmp___30 = ((int )tmp_str[2] - 65) + 10;
                    } else {
#line 24484
                      if ((int )tmp_str[2] >= 97 && (int )tmp_str[2] <= 102) {
#line 24484
                        tmp___29 = ((int )tmp_str[2] - 97) + 10;
                      } else {
#line 24484
                        tmp___29 = 0;
                      }
#line 24484
                      tmp___30 = tmp___29;
                    }
#line 24484
                    tmp___31 = tmp___30;
                  }
                  {
#line 24484
                  *(*(color_hexes + NUM_COLORS) + 2) = (Uint8 )((tmp___31 << 4) + tmp___34);
#line 24486
                  *(color_names + NUM_COLORS) = strdup((char const   *)((char *)str + count));
#line 24487
                  NUM_COLORS ++;
                  }
                }
              }
            } else {
              {
#line 24494
              __cil_tmp62 = sscanf((char const   *)((char *)str), "%hu %hu %hu %n",
                                   (unsigned short *)(*(color_hexes + NUM_COLORS) + 0),
                                   (unsigned short *)(*(color_hexes + NUM_COLORS) + 1),
                                   (unsigned short *)(*(color_hexes + NUM_COLORS) + 2),
                                   & count);
              }
#line 24494
              if (__cil_tmp62 >= 3) {
                {
#line 24499
                *(color_names + NUM_COLORS) = strdup((char const   *)((char *)str + count));
#line 24500
                NUM_COLORS ++;
                }
              }
            }
          }
        }
#line 24441
        if (! (! __cil_tmp10)) {
#line 24441
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 24508
      if (NUM_COLORS < 2) {
        {
#line 24510
        fprintf(stderr, "\nWarning, not enough colors in color file. Using defaults.\n");
#line 24511
        fprintf(stderr, "%s\n", (char *)colorfile);
#line 24512
        colorfile[0] = (char )'\000';
#line 24514
        i = 0;
        }
        {
#line 24514
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 24514
          if (! (i < NUM_COLORS)) {
#line 24514
            goto while_break___2;
          }
          {
#line 24516
          free(*(color_names + i));
#line 24517
          free(*(color_hexes + i));
          }
#line 24514
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 24520
        free(color_names);
#line 24521
        free(color_hexes);
        }
      }
    }
  }
#line 24528
  if ((int )colorfile[0] == 0) {
    {
#line 24530
    NUM_COLORS = 17;
#line 24532
    color_hexes = (Uint8 **)malloc(sizeof(Uint8 *) * (unsigned long )NUM_COLORS);
#line 24533
    color_names = (char **)malloc(sizeof(char *) * (unsigned long )NUM_COLORS);
#line 24535
    i = 0;
    }
    {
#line 24535
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 24535
      if (! (i < NUM_COLORS)) {
#line 24535
        goto while_break___3;
      }
      {
#line 24537
      *(color_hexes + i) = (Uint8 *)malloc(sizeof(Uint8 *) * 3UL);
#line 24539
      j = 0;
      }
      {
#line 24539
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 24539
        if (! (j < 3)) {
#line 24539
          goto while_break___4;
        }
#line 24540
        *(*(color_hexes + i) + j) = (Uint8 )default_color_hexes[i][j];
#line 24539
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 24542
      *(color_names + i) = strdup(default_color_names[i]);
      }
#line 24535
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 24549
  __cil_tmp72 = realloc(color_hexes, sizeof(Uint8 *) * (unsigned long )(NUM_COLORS + 1));
#line 24549
  color_hexes = (Uint8 **)__cil_tmp72;
#line 24551
  __cil_tmp73 = realloc(color_names, sizeof(char *) * (unsigned long )(NUM_COLORS + 1));
#line 24551
  color_names = (char **)__cil_tmp73;
#line 24552
  __cil_tmp74 = dcgettext((char const   *)((void *)0), "Select a color from your drawing.",
                          5);
#line 24552
  __cil_tmp75 = strdup((char const   *)__cil_tmp74);
#line 24552
  *(color_names + NUM_COLORS) = __cil_tmp75;
#line 24553
  __cil_tmp76 = malloc(sizeof(Uint8 ) * 3UL);
#line 24553
  *(color_hexes + NUM_COLORS) = (Uint8 *)__cil_tmp76;
#line 24554
  *(*(color_hexes + NUM_COLORS) + 0) = (Uint8 )0;
#line 24555
  *(*(color_hexes + NUM_COLORS) + 1) = (Uint8 )0;
#line 24556
  *(*(color_hexes + NUM_COLORS) + 2) = (Uint8 )0;
#line 24557
  NUM_COLORS ++;
#line 24561
  __cil_tmp78 = realloc(color_hexes, sizeof(Uint8 *) * (unsigned long )(NUM_COLORS + 1));
#line 24561
  color_hexes = (Uint8 **)__cil_tmp78;
#line 24563
  __cil_tmp79 = realloc(color_names, sizeof(char *) * (unsigned long )(NUM_COLORS + 1));
#line 24563
  color_names = (char **)__cil_tmp79;
#line 24564
  __cil_tmp80 = dcgettext((char const   *)((void *)0), "Pick a color.", 5);
#line 24564
  __cil_tmp81 = strdup((char const   *)__cil_tmp80);
#line 24564
  *(color_names + NUM_COLORS) = __cil_tmp81;
#line 24565
  __cil_tmp82 = malloc(sizeof(Uint8 ) * 3UL);
#line 24565
  *(color_hexes + NUM_COLORS) = (Uint8 *)__cil_tmp82;
#line 24566
  *(*(color_hexes + NUM_COLORS) + 0) = (Uint8 )0;
#line 24567
  *(*(color_hexes + NUM_COLORS) + 1) = (Uint8 )0;
#line 24568
  *(*(color_hexes + NUM_COLORS) + 2) = (Uint8 )0;
#line 24569
  color_picker_x = 0;
#line 24570
  color_picker_y = 0;
#line 24571
  NUM_COLORS ++;
  }
  return;
}
}
#line 24580 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void do_lock_file(void) 
{ 
  FILE *fi ;
  char *lock_fname ;
  time_t time_lock ;
  time_t time_now ;
  char *homedirdir ;
  time_t __cil_tmp6 ;
  char *__cil_tmp7 ;
  FILE *__cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  FILE *__cil_tmp11 ;
  int *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 24589
  if (! ok_to_use_lockfile) {
#line 24590
    return;
  }
  {
#line 24594
  time_now = time((time_t *)((void *)0));
#line 24599
  lock_fname = get_fname("lockfile.dat\324U", 0);
#line 24604
  fi = fopen((char const   *)lock_fname, "r");
  }
#line 24605
  if (fi != (void *)0) {
    {
#line 24609
    __cil_tmp9 = fread(& time_lock, sizeof(time_t ), (unsigned long )1, fi);
    }
#line 24609
    if (__cil_tmp9 > 0UL) {
#line 24613
      if (time_now < time_lock + 30L) {
        {
#line 24616
        printf("You have already started tuxpaint less than 30 seconds ago.\nTo prevent multiple executions by mistake, TuxPaint will not run\nbefore 30 seconds have elapsed since it was last started.\n\nYou can also use the --nolockfile argument, see tuxpaint(1).\n\n");
#line 24622
        free(lock_fname);
#line 24624
        fclose(fi);
#line 24625
        exit(0);
        }
      }
    }
    {
#line 24629
    fclose(fi);
    }
  }
  {
#line 24636
  homedirdir = get_fname("\230", 0);
#line 24637
  mkdir((char const   *)homedirdir, (__mode_t )493);
#line 24638
  free(homedirdir);
#line 24641
  fi = fopen((char const   *)lock_fname, "w\031\272t\324U");
  }
#line 24642
  if (fi != (void *)0) {
    {
#line 24646
    fwrite(& time_now, sizeof(time_t ), (unsigned long )1, fi);
#line 24647
    fclose(fi);
    }
  } else {
    {
#line 24651
    __cil_tmp12 = __errno_location();
#line 24651
    __cil_tmp13 = strerror(*__cil_tmp12);
#line 24651
    fprintf(stderr, "\nWarning: I couldn\'t create the lockfile (%s)\nThe error that occurred was:\n%s\n\n",
            lock_fname, __cil_tmp13);
    }
  }
  {
#line 24656
  free(lock_fname);
  }
  return;
}
}
#line 24662 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int TP_EventFilter(SDL_Event *event ) 
{ 


  {
#line 24664
  if ((int )event->type == 12) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 1) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 7) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 8) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 9) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 10) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 11) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 2) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 3) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 5) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 6) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 4) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 12) {
#line 24676
    return (1);
  } else
#line 24664
  if ((int )event->type == 24) {
#line 24676
    return (1);
  }
#line 24678
  return (0);
}
}
#line 24686 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void setup(void) 
{ 
  int i ;
  char *upstr ;
  SDL_Color black ;
  char *homedirdir ;
  SDL_Surface *tmp_surf ;
  SDL_Rect dest ;
  int scale ;
  int canvas_width ;
  int canvas_height ;
  int x ;
  int y ;
  SDL_Surface *tmp_btn_up ;
  SDL_Surface *tmp_btn_down ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  SDL_Surface *tmp_imgcurup ;
  SDL_Surface *tmp_imgcurdown ;
  Uint32 init_flags ;
  char tmp_str[128] ;
  SDL_Surface *img1 ;
  Uint32 (*getpixel_tmp_btn_up)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_tmp_btn_down)(SDL_Surface * , int  , int  ) ;
  Uint32 (*getpixel_img_paintwell)(SDL_Surface * , int  , int  ) ;
  int big_title ;
  SDL_Thread *fontconfig_thread ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  char *olderr ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  int __cil_tmp32 ;
  char *__cil_tmp33 ;
  int __cil_tmp34 ;
  int __cil_tmp35 ;
  char const   *__cil_tmp36 ;
  int __cil_tmp37 ;
  SDL_Joystick *__cil_tmp38 ;
  char *__cil_tmp39 ;
  int __cil_tmp40 ;
  char *__cil_tmp41 ;
  int __cil_tmp42 ;
  SDL_RWops *__cil_tmp43 ;
  Mix_Chunk *__cil_tmp44 ;
  char *__cil_tmp45 ;
  int __cil_tmp46 ;
  char *__cil_tmp47 ;
  int tmp ;
  SDL_Surface *__cil_tmp49 ;
  char *__cil_tmp50 ;
  int set_window_pos ;
  char *__cil_tmp52 ;
  SDL_Surface *__cil_tmp53 ;
  char *__cil_tmp54 ;
  SDL_Surface *__cil_tmp55 ;
  SDL_Surface *__cil_tmp56 ;
  SDL_Surface *__cil_tmp57 ;
  SDL_Surface *__cil_tmp58 ;
  SDL_Surface *__cil_tmp59 ;
  SDL_Cursor *__cil_tmp60 ;
  SDL_Thread *__cil_tmp61 ;
  char *__cil_tmp62 ;
  int __cil_tmp63 ;
  int __cil_tmp64 ;
  TuxPaint_Font *__cil_tmp65 ;
  char *__cil_tmp66 ;
  SDL_Surface *__cil_tmp67 ;
  SDL_Surface *__cil_tmp68 ;
  SDL_Cursor *__cil_tmp69 ;
  SDL_Cursor *__cil_tmp70 ;
  SDL_Cursor *__cil_tmp71 ;
  SDL_Cursor *__cil_tmp72 ;
  SDL_Cursor *__cil_tmp73 ;
  SDL_Cursor *__cil_tmp74 ;
  SDL_Cursor *__cil_tmp75 ;
  SDL_Cursor *__cil_tmp76 ;
  SDL_Cursor *__cil_tmp77 ;
  SDL_Cursor *__cil_tmp78 ;
  SDL_Surface *__cil_tmp79 ;
  SDL_Surface *__cil_tmp80 ;
  char *__cil_tmp81 ;
  void *__cil_tmp82 ;
  void *__cil_tmp83 ;
  SDL_Surface *__cil_tmp84 ;
  SDL_Surface *__cil_tmp85 ;
  char *__cil_tmp86 ;
  int __cil_tmp87 ;
  SDL_Surface *__cil_tmp88 ;
  int __cil_tmp89 ;
  SDL_Surface *__cil_tmp90 ;
  SDL_Surface *__cil_tmp91 ;
  SDL_Surface *__cil_tmp92 ;
  SDL_Surface *__cil_tmp93 ;
  SDL_Surface *__cil_tmp94 ;
  SDL_Surface *__cil_tmp95 ;
  SDL_Surface *__cil_tmp96 ;
  SDL_Surface *__cil_tmp97 ;
  SDL_Surface *__cil_tmp98 ;
  SDL_Surface *__cil_tmp99 ;
  SDL_Surface *__cil_tmp100 ;
  SDL_Surface *__cil_tmp101 ;
  SDL_Surface *__cil_tmp102 ;
  SDL_Surface *__cil_tmp103 ;
  SDL_Surface *__cil_tmp104 ;
  SDL_Surface *__cil_tmp105 ;
  SDL_Surface *__cil_tmp106 ;
  SDL_Surface *__cil_tmp107 ;
  SDL_Surface *__cil_tmp108 ;
  SDL_Surface *__cil_tmp109 ;
  SDL_Surface *__cil_tmp110 ;
  SDL_Surface *__cil_tmp111 ;
  SDL_Surface *__cil_tmp112 ;
  SDL_Surface *__cil_tmp113 ;
  SDL_Surface *__cil_tmp114 ;
  SDL_Surface *__cil_tmp115 ;
  SDL_Surface *__cil_tmp116 ;
  SDL_Surface *__cil_tmp117 ;
  SDL_Surface *__cil_tmp118 ;
  SDL_Surface *__cil_tmp119 ;
  SDL_Surface *__cil_tmp120 ;
  SDL_Surface *__cil_tmp121 ;
  SDL_Surface *__cil_tmp122 ;
  SDL_Surface *__cil_tmp123 ;
  SDL_Surface *__cil_tmp124 ;
  SDL_Surface *__cil_tmp125 ;
  SDL_Surface *__cil_tmp126 ;
  SDL_Surface *__cil_tmp127 ;
  SDL_Surface *__cil_tmp128 ;
  SDL_Surface *__cil_tmp129 ;
  SDL_Surface *__cil_tmp130 ;
  SDL_Surface *__cil_tmp131 ;
  SDL_Surface *__cil_tmp132 ;
  SDL_Surface *__cil_tmp133 ;
  SDL_Surface *__cil_tmp134 ;
  SDL_Surface *__cil_tmp135 ;
  SDL_Surface *__cil_tmp136 ;
  SDL_Surface *__cil_tmp137 ;
  SDL_Surface *__cil_tmp138 ;
  SDL_Surface *__cil_tmp139 ;
  SDL_Surface *__cil_tmp140 ;
  SDL_Surface *__cil_tmp141 ;
  SDL_Surface *__cil_tmp142 ;
  SDL_Surface *__cil_tmp143 ;
  SDL_Surface *__cil_tmp144 ;
  SDL_Surface *__cil_tmp145 ;
  SDL_Surface *__cil_tmp146 ;
  SDL_Surface *__cil_tmp147 ;
  SDL_Surface *__cil_tmp148 ;
  SDL_Surface *__cil_tmp149 ;
  SDL_Surface *__cil_tmp150 ;
  SDL_Surface *__cil_tmp151 ;
  SDL_Surface *__cil_tmp152 ;
  SDL_Surface *__cil_tmp153 ;
  SDL_Surface *__cil_tmp154 ;
  SDL_Surface *__cil_tmp155 ;
  SDL_Surface *__cil_tmp156 ;
  SDL_Surface *__cil_tmp157 ;
  char *__cil_tmp158 ;
  TuxPaint_Font *__cil_tmp159 ;
  char *__cil_tmp160 ;
  TuxPaint_Font *__cil_tmp161 ;
  char *__cil_tmp162 ;
  SDL_Surface *aux_surf ;
  SDL_Surface *__cil_tmp164 ;
  SDL_Surface *__cil_tmp165 ;
  int __cil_tmp166 ;
  SDL_Surface *aux_surf___0 ;
  SDL_Surface *__cil_tmp168 ;
  SDL_Surface *__cil_tmp169 ;
  int __cil_tmp170 ;
  SDL_Surface *__cil_tmp171 ;
  int __cil_tmp172 ;
  SDL_Surface *__cil_tmp173 ;
  SDL_Surface *__cil_tmp174 ;
  SDL_Surface *__cil_tmp175 ;
  unsigned long __cil_tmp176 ;
  TuxPaint_Font *myfont ;
  char *td_str ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  int __cil_tmp182 ;
  char *__cil_tmp183 ;
  SDL_Surface *__cil_tmp184 ;
  SDL_Surface *__cil_tmp185 ;
  int __cil_tmp186 ;
  SDL_Surface *__cil_tmp187 ;
  SDL_Surface *__cil_tmp188 ;
  SDL_Surface *__cil_tmp189 ;
  SDL_Surface *__cil_tmp190 ;
  SDL_Surface *__cil_tmp191 ;
  SDL_Surface *__cil_tmp192 ;
  void *__cil_tmp193 ;
  SDL_Surface *__cil_tmp194 ;
  char *__cil_tmp195 ;
  int __cil_tmp196 ;
  double ru ;
  double gu ;
  double bu ;
  double rd ;
  double gd ;
  double bd ;
  double aa ;
  Uint8 a ;
  double rh ;
  double gh ;
  double bh ;
  Uint32 __cil_tmp208 ;
  Uint32 __cil_tmp209 ;
  unsigned char __cil_tmp210 ;
  unsigned char __cil_tmp211 ;
  unsigned char __cil_tmp212 ;
  unsigned char __cil_tmp213 ;
  unsigned char __cil_tmp214 ;
  unsigned char __cil_tmp215 ;
  int __cil_tmp216 ;
  int __cil_tmp217 ;
  int __cil_tmp218 ;
  int __cil_tmp219 ;
  Uint32 __cil_tmp220 ;

  {
#line 24690
  black.r = (Uint8 )0;
#line 24690
  black.g = (Uint8 )0;
#line 24690
  black.b = (Uint8 )0;
  {
#line 24690
  black.unused = (Uint8 )0;
#line 24727
  __cil_tmp27 = get_current_language();
#line 24727
  im_init(& im_data, __cil_tmp27);
#line 24730
  SDLPango_Init();
#line 24734
  putenv((char *)"SDL_VIDEO_X11_WMCLASS=TuxPaint.TuxPaint");
  }
#line 24737
  if (disable_screensaver == 0) {
    {
#line 24739
    putenv((char *)"SDL_VIDEO_ALLOW_SCREENSAVER=1U");
    }
#line 24740
    if (0) {
      {
#line 24744
      fprintf(stderr, "Note: \'allowscreensaver\' requires SDL 1.2.12 or higher\n");
      }
    }
  }
#line 24748
  if (joystick_dev != -1) {
    {
#line 24749
    do_lock_file();
    }
  }
#line 24751
  init_flags = (Uint32 )544;
#line 24752
  if (use_sound) {
#line 24753
    init_flags |= (unsigned int )16;
  }
#line 24754
  if (! fullscreen) {
#line 24755
    init_flags |= (unsigned int )1048576;
  }
  {
#line 24758
  __cil_tmp28 = SDL_Init(init_flags);
  }
#line 24758
  if (__cil_tmp28 < 0) {
    {
#line 24761
    __cil_tmp30 = SDL_GetError();
#line 24761
    __cil_tmp31 = strdup((char const   *)__cil_tmp30);
#line 24761
    olderr = __cil_tmp31;
#line 24763
    use_sound = 0;
#line 24764
    init_flags &= (unsigned int )(~ 16);
#line 24765
    __cil_tmp32 = SDL_Init(init_flags);
    }
#line 24765
    if (__cil_tmp32 >= 0) {
      {
#line 24768
      fprintf(stderr, "\nWarning: I could not initialize audio!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              olderr);
#line 24771
      free(olderr);
      }
    } else {
      {
#line 24776
      __cil_tmp33 = SDL_GetError();
#line 24776
      fprintf(stderr, "\nError: I could not initialize video and/or the timer!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              __cil_tmp33);
#line 24779
      exit(1);
      }
    }
  }
  {
#line 24785
  SDL_SetEventFilter(& TP_EventFilter);
  }
#line 24790
  if (joystick_dev == -1) {
    {
#line 24792
    __cil_tmp34 = SDL_NumJoysticks();
#line 24792
    fprintf(stderr, "%i joystick(s) were found:\nt\324U", __cil_tmp34);
#line 24794
    i = 0;
    }
    {
#line 24794
    while (1) {
      while_continue: /* CIL Label */ ;
#line 24794
      if (! (i < __cil_tmp35)) {
#line 24794
        goto while_break;
      }
      {
#line 24796
      __cil_tmp36 = SDL_JoystickName(i);
#line 24796
      fprintf(stderr, " %d: %s\n\230\001", i, __cil_tmp36);
      }
#line 24794
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 24799
    SDL_Quit();
#line 24800
    exit(0);
    }
  }
  {
#line 24803
  joystick = SDL_JoystickOpen(joystick_dev);
  }
#line 24804
  if (joystick == (void *)0) {
    {
#line 24806
    __cil_tmp39 = SDL_GetError();
#line 24806
    fprintf(stderr, "Could not open joystick device %d: %s\n", joystick_dev, __cil_tmp39);
    }
  } else {
    {
#line 24810
    SDL_JoystickEventState(1);
    }
  }
  {
#line 24826
  __cil_tmp40 = Mix_OpenAudio(44100, (Uint16 )32784, 2, 1024);
  }
#line 24826
  if (use_sound) {
#line 24826
    if (__cil_tmp40 < 0) {
      {
#line 24831
      __cil_tmp41 = SDL_GetError();
#line 24831
      fprintf(stderr, "\nWarning: I could not set up audio for 44100 Hz 16-bit stereo.\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              __cil_tmp41);
#line 24834
      use_sound = 0;
      }
    }
  }
#line 24837
  i = 31;
  {
#line 24838
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 24838
    __cil_tmp42 = i;
#line 24838
    i --;
#line 24838
    if (! (use_sound && __cil_tmp42)) {
#line 24838
      goto while_break___0;
    }
    {
#line 24840
    __cil_tmp43 = SDL_RWFromFile(sound_fnames[i], "rb");
#line 24840
    __cil_tmp44 = Mix_LoadWAV_RW(__cil_tmp43, 1);
#line 24840
    sounds[i] = __cil_tmp44;
    }
#line 24842
    if (sounds[i] == (void *)0) {
      {
#line 24844
      __cil_tmp45 = SDL_GetError();
#line 24844
      fprintf(stderr, "\nWarning: I couldn\'t open a sound file:\n%s\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              sound_fnames[i], __cil_tmp45);
#line 24847
      use_sound = 0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 24858
  SDL_EnableKeyRepeat(500, 30);
#line 24865
  __cil_tmp46 = TTF_Init();
  }
#line 24865
  if (__cil_tmp46 < 0) {
    {
#line 24867
    __cil_tmp47 = SDL_GetError();
#line 24867
    fprintf(stderr, "\nError: I could not initialize the font (TTF) library!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\235\270t\324U",
            __cil_tmp47);
#line 24871
    SDL_Quit();
#line 24872
    exit(1);
    }
  }
  {
#line 24880
  setup_colors();
#line 24885
  seticon();
#line 24887
  SDL_WM_SetCaption("Tux Paint", "Tux Paint");
  }
#line 24889
  if (hide_cursor) {
    {
#line 24890
    SDL_ShowCursor(0);
    }
  }
#line 24895
  if (rotate_orientation) {
#line 24897
    if (native_screensize) {
#line 24897
      if (fullscreen) {
        {
#line 24899
        fprintf(stderr, "Warning: Asking for native screen size overrides request to rotate orientation.\n\220");
        }
      } else {
#line 24905
        tmp = WINDOW_WIDTH;
#line 24906
        WINDOW_WIDTH = WINDOW_HEIGHT;
#line 24907
        WINDOW_HEIGHT = tmp;
      }
    } else {
#line 24905
      tmp = WINDOW_WIDTH;
#line 24906
      WINDOW_WIDTH = WINDOW_HEIGHT;
#line 24907
      WINDOW_HEIGHT = tmp;
    }
  }
#line 24913
  if (native_screensize) {
#line 24915
    if (! fullscreen) {
      {
#line 24917
      fprintf(stderr, "Warning: Asking for native screensize in a window. Ignoring.\n");
      }
    } else {
#line 24921
      WINDOW_WIDTH = 0;
#line 24922
      WINDOW_HEIGHT = 0;
    }
  }
#line 24929
  if (fullscreen) {
    {
#line 24934
    screen = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, 32, 2147483648U);
    }
#line 24937
    if (screen == (void *)0) {
      {
#line 24939
      __cil_tmp50 = SDL_GetError();
#line 24939
      fprintf(stderr, "\nWarning: I could not open the display in fullscreen mode.\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\nU",
              __cil_tmp50);
#line 24943
      fullscreen = 0;
      }
    } else
#line 24949
    if (native_screensize) {
#line 24951
      WINDOW_WIDTH = screen->w;
#line 24952
      WINDOW_HEIGHT = screen->h;
    }
  }
#line 24958
  if (! fullscreen) {
    {
#line 24960
    set_window_pos = 0;
#line 24962
    __cil_tmp52 = getenv((char const   *)((char *)"SDL_VIDEO_WINDOW_POS"));
    }
#line 24962
    if (__cil_tmp52 == (void *)0) {
      {
#line 24964
      set_window_pos = 1;
#line 24965
      putenv((char *)"SDL_VIDEO_WINDOW_POS=centert\324U");
      }
    }
    {
#line 24971
    screen = SDL_SetVideoMode(WINDOW_WIDTH, WINDOW_HEIGHT, 32, (Uint32 )0);
    }
#line 24974
    if (set_window_pos) {
      {
#line 24975
      putenv((char *)"SDL_VIDEO_WINDOW_POS=nopreft\324U");
      }
    }
  }
#line 24978
  if (screen == (void *)0) {
    {
#line 24980
    __cil_tmp54 = SDL_GetError();
#line 24980
    fprintf(stderr, "\nError: I could not open the display.\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\230",
            __cil_tmp54);
#line 24984
    cleanup();
#line 24985
    exit(1);
    }
  }
  {
#line 24991
  setup_screen_layout();
#line 24996
  img_title = loadimage("/usr/local/share/tuxpaint/images/title.png");
#line 24997
  img_title_credits = loadimage("/usr/local/share/tuxpaint/images/title-credits.png");
#line 24998
  img_progress = loadimage("/usr/local/share/tuxpaint/images/ui/progress.png");
  }
#line 25000
  if (screen->w - img_title->w >= 410) {
#line 25000
    if (((screen->h - img_progress->h) - img_title_credits->h) - 40) {
#line 25001
      big_title = 1;
    } else {
#line 25003
      big_title = 0;
    }
  } else {
#line 25003
    big_title = 0;
  }
#line 25006
  if (big_title) {
    {
#line 25007
    img_title_tuxpaint = loadimage("/usr/local/share/tuxpaint/images/title-tuxpaint-2x.png\270t\324U");
    }
  } else {
    {
#line 25009
    img_title_tuxpaint = loadimage("/usr/local/share/tuxpaint/images/title-tuxpaint.png");
    }
  }
  {
#line 25011
  SDL_FillRect(screen, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 25013
  dest.x = (Sint16 )((((WINDOW_WIDTH - img_title->w) - img_title_tuxpaint->w / 2) / 2 + img_title_tuxpaint->w / 2) + 20);
#line 25014
  dest.y = (Sint16 )(WINDOW_HEIGHT - img_title->h);
#line 25016
  SDL_UpperBlit(img_title, (SDL_Rect *)((void *)0), screen, & dest);
#line 25018
  dest.x = (Sint16 )10;
  }
#line 25019
  if (big_title) {
#line 25020
    dest.y = (Sint16 )(((WINDOW_HEIGHT - img_title_tuxpaint->h) - img_progress->h) - 40);
  } else {
#line 25022
    dest.y = (Sint16 )(((double )(WINDOW_HEIGHT - img_title->h) + (double )img_title_tuxpaint->h * 0.800000000001) + (double )7);
  }
  {
#line 25024
  SDL_UpperBlit(img_title_tuxpaint, (SDL_Rect *)((void *)0), screen, & dest);
#line 25026
  dest.x = (Sint16 )10;
#line 25027
  dest.y = (Sint16 )5;
#line 25029
  SDL_UpperBlit(img_title_credits, (SDL_Rect *)((void *)0), screen, & dest);
#line 25031
  prog_bar_ctr = 0;
#line 25032
  show_progress_bar(screen);
#line 25034
  SDL_Flip(screen);
#line 25050
  scale = 1;
#line 25061
  cursor_watch = get_cursor((unsigned char *)watch_bits___0, (unsigned char *)watch_mask_bits___0,
                            (unsigned int )32, (unsigned int )32, (unsigned int )(14 / scale),
                            (unsigned int )(14 / scale));
#line 25063
  do_setcursor(cursor_watch);
#line 25064
  show_progress_bar(screen);
#line 25072
  fontconfig_thread_done = (long )0;
#line 25079
  fontconfig_thread = SDL_CreateThread(& generate_fontconfig_cache, (void *)0);
  }
#line 25080
  if (fontconfig_thread == (void *)0) {
    {
#line 25082
    __cil_tmp62 = SDL_GetError();
#line 25082
    fprintf(stderr, "Failed to create Pango setup thread: %s\n\230", __cil_tmp62);
    }
  } else {
    {
#line 25090
    __cil_tmp63 = generate_fontconfig_cache_spinner(screen);
    }
#line 25090
    if (__cil_tmp63) {
      {
#line 25092
      fprintf(stderr, "Pango thread aborted!\n");
#line 25093
      fflush(stderr);
#line 25094
      SDL_KillThread(fontconfig_thread);
#line 25095
      SDL_Quit();
#line 25096
      exit(0);
      }
    }
  }
  {
#line 25112
  __cil_tmp64 = get_current_language();
#line 25112
  run_font_scanner(screen, lang_prefixes[__cil_tmp64]);
#line 25117
  medium_font = TuxPaint_Font_OpenFont("BitStream Vera", "/usr/local/share/tuxpaint/fonts/default_font.ttf\324U",
                                       (int )((float )(18 - only_uppercase * 3) * button_scale));
  }
#line 25120
  if (medium_font == (void *)0) {
    {
#line 25122
    __cil_tmp66 = SDL_GetError();
#line 25122
    fprintf(stderr, "\nError: Can\'t load font file: /usr/local/share/tuxpaint/fonts/default_font.ttf\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\323\272t\324U",
            __cil_tmp66);
#line 25127
    cleanup();
#line 25128
    exit(1);
    }
  }
  {
#line 25131
  safe_snprintf((char *)tmp_str, sizeof(tmp_str), "Version: %s \342\200\223 %s", "0.9.27",
                "2024-04-18");
#line 25133
  tmp_surf = render_text(medium_font, (char const   *)((char *)tmp_str), black);
#line 25134
  dest.x = (Sint16 )10;
#line 25135
  dest.y = (Sint16 )((WINDOW_HEIGHT - img_progress->h) - tmp_surf->h);
#line 25136
  SDL_UpperBlit(tmp_surf, (SDL_Rect *)((void *)0), screen, & dest);
#line 25137
  SDL_FreeSurface(tmp_surf);
#line 25143
  safe_snprintf((char *)tmp_str, sizeof(tmp_str), "\302\251 2002\342\200\2232021 Bill Kendrick et al.");
#line 25144
  tmp_surf = render_text(medium_font, (char const   *)((char *)tmp_str), black);
#line 25145
  dest.x = (Sint16 )10;
#line 25146
  dest.y = (Sint16 )((WINDOW_HEIGHT - img_progress->h) - tmp_surf->h * 2);
#line 25147
  SDL_UpperBlit(tmp_surf, (SDL_Rect *)((void *)0), screen, & dest);
#line 25148
  SDL_FreeSurface(tmp_surf);
#line 25150
  SDL_Flip(screen);
#line 25154
  reliable_write(font_socket_fd, & no_system_fonts, sizeof(no_system_fonts));
#line 25163
  cursor_arrow = get_cursor((unsigned char *)arrow_bits___0, (unsigned char *)arrow_mask_bits___0,
                            (unsigned int )32, (unsigned int )32, (unsigned int )0,
                            (unsigned int )0);
#line 25166
  cursor_hand = get_cursor((unsigned char *)hand_bits___0, (unsigned char *)hand_mask_bits___0,
                           (unsigned int )32, (unsigned int )32, (unsigned int )(12 / scale),
                           (unsigned int )(1 / scale));
#line 25168
  cursor_wand = get_cursor((unsigned char *)wand_bits___0, (unsigned char *)wand_mask_bits___0,
                           (unsigned int )32, (unsigned int )32, (unsigned int )(4 / scale),
                           (unsigned int )(4 / scale));
#line 25170
  cursor_insertion = get_cursor((unsigned char *)insertion_bits___0, (unsigned char *)insertion_mask_bits___0,
                                (unsigned int )16, (unsigned int )32, (unsigned int )(7 / scale),
                                (unsigned int )(4 / scale));
#line 25173
  cursor_brush = get_cursor((unsigned char *)brush_bits___0, (unsigned char *)brush_mask_bits___0,
                            (unsigned int )32, (unsigned int )32, (unsigned int )(4 / scale),
                            (unsigned int )(28 / scale));
#line 25175
  cursor_crosshair = get_cursor((unsigned char *)crosshair_bits___0, (unsigned char *)crosshair_mask_bits___0,
                                (unsigned int )32, (unsigned int )32, (unsigned int )(15 / scale),
                                (unsigned int )(15 / scale));
#line 25178
  cursor_rotate = get_cursor((unsigned char *)rotate_bits___0, (unsigned char *)rotate_mask_bits___0,
                             (unsigned int )32, (unsigned int )32, (unsigned int )(15 / scale),
                             (unsigned int )(15 / scale));
#line 25180
  cursor_up = get_cursor((unsigned char *)up_bits___0, (unsigned char *)up_mask_bits___0,
                         (unsigned int )32, (unsigned int )32, (unsigned int )(15 / scale),
                         (unsigned int )(1 / scale));
#line 25182
  cursor_down = get_cursor((unsigned char *)down_bits___0, (unsigned char *)down_mask_bits___0,
                           (unsigned int )32, (unsigned int )32, (unsigned int )(15 / scale),
                           (unsigned int )(30 / scale));
#line 25184
  cursor_tiny = get_cursor((unsigned char *)tiny_bits___0, (unsigned char *)tiny_mask_bits___0,
                           (unsigned int )7, (unsigned int )7, (unsigned int )3, (unsigned int )3);
#line 25189
  canvas_width = (WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w;
#line 25190
  canvas_height = button_h * buttons_tall + (int )r_ttools.h;
#line 25196
  canvas = SDL_CreateRGBSurface(screen->flags, canvas_width, canvas_height, (int )(screen->format)->BitsPerPixel,
                                (screen->format)->Rmask, (screen->format)->Gmask,
                                (screen->format)->Bmask, (Uint32 )0);
#line 25200
  save_canvas = SDL_CreateRGBSurface(screen->flags, canvas_width, canvas_height, (int )(screen->format)->BitsPerPixel,
                                     (screen->format)->Rmask, (screen->format)->Gmask,
                                     (screen->format)->Bmask, (Uint32 )0);
#line 25205
  img_starter = (SDL_Surface *)((void *)0);
#line 25206
  img_starter_bkgd = (SDL_Surface *)((void *)0);
#line 25207
  starter_mirrored = 0;
#line 25208
  starter_flipped = 0;
#line 25209
  starter_personal = 0;
#line 25210
  starter_modified = 0;
  }
#line 25212
  if (canvas == (void *)0) {
    {
#line 25214
    __cil_tmp81 = SDL_GetError();
#line 25214
    fprintf(stderr, "\nError: Can\'t build drawing canvas!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
            __cil_tmp81);
#line 25217
    cleanup();
#line 25218
    exit(1);
    }
  }
  {
#line 25221
  __cil_tmp82 = malloc(sizeof(Uint8 ) * (unsigned long )(canvas->w * canvas->h));
#line 25221
  touched = (Uint8 *)__cil_tmp82;
  }
#line 25222
  if (touched == (void *)0) {
    {
#line 25224
    fprintf(stderr, "\nError: Can\'t build drawing touch mask for Magic!\n\270t\324U");
#line 25226
    cleanup();
#line 25227
    exit(1);
    }
  }
  {
#line 25230
  __cil_tmp83 = malloc(sizeof(Uint8 ) * (unsigned long )(canvas->w * canvas->h));
#line 25230
  sim_flood_touched = (Uint8 *)__cil_tmp83;
  }
#line 25231
  if (sim_flood_touched == (void *)0) {
    {
#line 25233
    fprintf(stderr, "\nError: Can\'t build drawing touch mask for Fill!\n");
#line 25235
    cleanup();
#line 25236
    exit(1);
    }
  }
  {
#line 25239
  canvas_color_r = (Uint8 )255;
#line 25240
  canvas_color_g = (Uint8 )255;
#line 25241
  canvas_color_b = (Uint8 )255;
#line 25243
  SDL_FillRect(canvas, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 25247
  label = SDL_CreateRGBSurface(screen->flags, WINDOW_WIDTH - (int )r_ttools.w * 2,
                               (button_h * 7 + 40) + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)),
                               (int )(screen->format)->BitsPerPixel, (screen->format)->Rmask,
                               (screen->format)->Gmask, (screen->format)->Bmask, 4278190080U);
#line 25254
  SDL_FillRect(label, (SDL_Rect *)((void *)0), 0U);
#line 25258
  i = 0;
  }
  {
#line 25258
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 25258
    if (! (i < 20)) {
#line 25258
      goto while_break___1;
    }
    {
#line 25260
    undo_bufs[i] = SDL_CreateRGBSurface(screen->flags, canvas_width, canvas_height,
                                        (int )(screen->format)->BitsPerPixel, (screen->format)->Rmask,
                                        (screen->format)->Gmask, (screen->format)->Bmask,
                                        (Uint32 )0);
    }
#line 25265
    if (undo_bufs[i] == (void *)0) {
      {
#line 25267
      __cil_tmp86 = SDL_GetError();
#line 25267
      fprintf(stderr, "\nError: Can\'t build undo buffer! (%d of %d)\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              i + 1, 20, __cil_tmp86);
#line 25271
      cleanup();
#line 25272
      exit(1);
      }
    }
#line 25275
    undo_starters[i] = 0;
#line 25258
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 25282
  i = 0;
  {
#line 25282
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 25282
    if (! (i < 16)) {
#line 25282
      goto while_break___2;
    }
    {
#line 25283
    img_tools[i] = loadimagerb(tool_img_fnames[i]);
    }
#line 25282
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 25285
  img_title_on = loadimagerb("/usr/local/share/tuxpaint/images/ui/title.png\\\273t\324U");
#line 25286
  img_title_large_on = loadimagerb("/usr/local/share/tuxpaint/images/ui/title_large.png");
#line 25287
  img_title_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/no_title.png\324U");
#line 25288
  img_title_large_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/no_title_large.png");
#line 25290
  img_btn_up = loadimagerb("/usr/local/share/tuxpaint/images/ui/btn_up.png");
#line 25291
  img_btn_down = loadimagerb("/usr/local/share/tuxpaint/images/ui/btn_down.png");
#line 25292
  img_btn_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/btn_off.pngt\324U");
#line 25293
  img_btn_hold = loadimagerb("/usr/local/share/tuxpaint/images/ui/btn_hold.png");
#line 25295
  img_btnsm_up = loadimagerb("/usr/local/share/tuxpaint/images/ui/btnsm_up.png");
#line 25296
  img_btnsm_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/btnsm_off.png");
#line 25297
  img_btnsm_down = loadimagerb("/usr/local/share/tuxpaint/images/ui/btnsm_down.png");
#line 25298
  img_btnsm_hold = loadimagerb("/usr/local/share/tuxpaint/images/ui/btnsm_hold.png");
#line 25300
  img_btn_nav = loadimagerb("/usr/local/share/tuxpaint/images/ui/btn_nav.png");
#line 25301
  img_btnsm_nav = loadimagerb("/usr/local/share/tuxpaint/images/ui/btnsm_nav.pngU");
#line 25303
  img_brush_anim = loadimagerb("/usr/local/share/tuxpaint/images/ui/brush_anim.png");
#line 25304
  img_brush_dir = loadimagerb("/usr/local/share/tuxpaint/images/ui/brush_dir.png");
#line 25306
  img_sfx = loadimagerb("/usr/local/share/tuxpaint/images/tools/sfx.png\267t\324U");
#line 25307
  img_speak = loadimagerb("/usr/local/share/tuxpaint/images/tools/speak.png");
#line 25309
  img_black = SDL_CreateRGBSurface((Uint32 )65536, img_btn_off->w, img_btn_off->h,
                                   (int )(img_btn_off->format)->BitsPerPixel, (img_btn_off->format)->Rmask,
                                   (img_btn_off->format)->Gmask, (img_btn_off->format)->Bmask,
                                   (img_btn_off->format)->Amask);
#line 25314
  SDL_FillRect(img_black, (SDL_Rect *)((void *)0), 255U << 24);
#line 25316
  img_grey = SDL_CreateRGBSurface((Uint32 )65536, img_btn_off->w, img_btn_off->h,
                                  (int )(img_btn_off->format)->BitsPerPixel, (img_btn_off->format)->Rmask,
                                  (img_btn_off->format)->Gmask, (img_btn_off->format)->Bmask,
                                  (img_btn_off->format)->Amask);
#line 25321
  SDL_FillRect(img_grey, (SDL_Rect *)((void *)0), (((255U << 24) | (136U << 16)) | (136U << 8)) | 136U);
#line 25323
  show_progress_bar(screen);
#line 25325
  img_yes = loadimagerb("/usr/local/share/tuxpaint/images/ui/yes.png");
#line 25326
  img_no = loadimagerb("/usr/local/share/tuxpaint/images/ui/no.png");
#line 25328
  img_prev = loadimagerb("/usr/local/share/tuxpaint/images/ui/prev.png\220");
#line 25329
  img_next = loadimagerb("/usr/local/share/tuxpaint/images/ui/next.png\220");
#line 25331
  img_mirror = loadimagerb("/usr/local/share/tuxpaint/images/ui/mirror.png");
#line 25332
  img_flip = loadimagerb("/usr/local/share/tuxpaint/images/ui/flip.png\220");
#line 25334
  img_open = loadimagerb("/usr/local/share/tuxpaint/images/ui/open.png\220");
#line 25335
  img_erase = loadimagerb("/usr/local/share/tuxpaint/images/ui/erase.png");
#line 25336
  img_pict_export = loadimagerb("/usr/local/share/tuxpaint/images/ui/pict_export.png");
#line 25337
  img_back = loadimagerb("/usr/local/share/tuxpaint/images/ui/back.png\220");
#line 25338
  img_trash = loadimagerb("/usr/local/share/tuxpaint/images/ui/trash.png\225\273t\324U");
#line 25340
  img_slideshow = loadimagerb("/usr/local/share/tuxpaint/images/ui/slideshow.png");
#line 25341
  img_play = loadimagerb("/usr/local/share/tuxpaint/images/ui/play.png\220");
#line 25342
  img_gif_export = loadimagerb("/usr/local/share/tuxpaint/images/ui/gif_export.png");
#line 25343
  img_select_digits = loadimagerb("/usr/local/share/tuxpaint/images/ui/select_digits.png\326\267t\324U");
#line 25345
  img_popup_arrow = loadimagerb("/usr/local/share/tuxpaint/images/ui/popup_arrow.png");
#line 25347
  img_dead40x40 = loadimagerb("/usr/local/share/tuxpaint/images/ui/dead40x40.png");
#line 25349
  img_printer = loadimagerb("/usr/local/share/tuxpaint/images/ui/printer.png");
#line 25350
  img_printer_wait = loadimagerb("/usr/local/share/tuxpaint/images/ui/printer_wait.png\220");
#line 25352
  img_save_over = loadimagerb("/usr/local/share/tuxpaint/images/ui/save_over.png");
#line 25354
  img_grow = loadimagerb("/usr/local/share/tuxpaint/images/ui/grow.png\220");
#line 25355
  img_shrink = loadimagerb("/usr/local/share/tuxpaint/images/ui/shrink.png");
#line 25357
  img_magic_paint = loadimagerb("/usr/local/share/tuxpaint/images/ui/magic_paint.png");
#line 25358
  img_magic_fullscreen = loadimagerb("/usr/local/share/tuxpaint/images/ui/magic_fullscreen.png\324U");
#line 25360
  img_shapes_center = loadimagerb("/usr/local/share/tuxpaint/images/ui/shapes_center.png\236\273t\324U");
#line 25361
  img_shapes_corner = loadimagerb("/usr/local/share/tuxpaint/images/ui/shapes_corner.png\246\273t\324U");
#line 25363
  img_bold = loadimagerb("/usr/local/share/tuxpaint/images/ui/bold.png\220");
#line 25364
  img_italic = loadimagerb("/usr/local/share/tuxpaint/images/ui/italic.png\273t\324U");
#line 25366
  img_label = loadimagerb("/usr/local/share/tuxpaint/images/tools/label.png\324U");
#line 25367
  img_label_select = loadimagerb("/usr/local/share/tuxpaint/images/tools/label_select.pngt\324U");
#line 25369
  show_progress_bar(screen);
#line 25371
  tmp_imgcurup = loadimage("/usr/local/share/tuxpaint/images/ui/cursor_up_large.pngt\324U");
#line 25372
  tmp_imgcurdown = loadimage("/usr/local/share/tuxpaint/images/ui/cursor_down_large.pngU");
#line 25373
  img_cursor_up = thumbnail(tmp_imgcurup, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4,
                            (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4,
                            0);
#line 25374
  img_cursor_down = thumbnail(tmp_imgcurdown, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4,
                              (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4,
                              0);
#line 25376
  tmp_imgcurup = loadimage("/usr/local/share/tuxpaint/images/ui/cursor_starter_up.png");
#line 25377
  tmp_imgcurdown = loadimage("/usr/local/share/tuxpaint/images/ui/cursor_starter_down.png");
#line 25378
  img_cursor_starter_up = thumbnail(tmp_imgcurup, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4,
                                    (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4,
                                    0);
#line 25379
  img_cursor_starter_down = thumbnail(tmp_imgcurdown, ((WINDOW_WIDTH - (int )r_ttools.w) - (int )r_ttoolopt.w) / 4,
                                      (((button_h * buttons_tall + (int )r_ttools.h) - button_h) - button_h / 2) / 4,
                                      0);
#line 25380
  SDL_FreeSurface(tmp_imgcurup);
#line 25381
  SDL_FreeSurface(tmp_imgcurdown);
#line 25383
  show_progress_bar(screen);
#line 25385
  img_scroll_up = loadimagerb("/usr/local/share/tuxpaint/images/ui/scroll_up.pngU");
#line 25386
  img_scroll_down = loadimagerb("/usr/local/share/tuxpaint/images/ui/scroll_down.png");
#line 25388
  img_scroll_up_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/scroll_up_off.png");
#line 25389
  img_scroll_down_off = loadimagerb("/usr/local/share/tuxpaint/images/ui/scroll_down_off.png");
#line 25390
  img_color_sel = loadimagerb("/usr/local/share/tuxpaint/images/ui/csel.png\220");
  }
#line 25396
  if (onscreen_keyboard) {
    {
#line 25398
    img_oskdel = loadimagerb("/usr/local/share/tuxpaint/images/ui/osk_delete.png");
#line 25399
    img_osktab = loadimagerb("/usr/local/share/tuxpaint/images/ui/osk_tab.pngt\324U");
#line 25400
    img_oskenter = loadimagerb("/usr/local/share/tuxpaint/images/ui/osk_enter.pngU");
#line 25401
    img_oskcapslock = loadimagerb("/usr/local/share/tuxpaint/images/ui/osk_capslock.png\220");
#line 25402
    img_oskshift = loadimagerb("/usr/local/share/tuxpaint/images/ui/osk_shift.png");
    }
  }
  {
#line 25405
  show_progress_bar(screen);
#line 25409
  load_brush_dir(screen, "/usr/local/share/tuxpaint/brushes");
#line 25410
  homedirdir = get_fname("brushes", 1);
#line 25411
  load_brush_dir(screen, (char const   *)homedirdir);
  }
#line 25418
  if (num_brushes == 0) {
    {
#line 25420
    fprintf(stderr, "\nError: No brushes found in /usr/local/share/tuxpaint/brushes/\nor %s\n\n\273t\324U",
            homedirdir);
#line 25421
    cleanup();
#line 25422
    exit(1);
    }
  }
  {
#line 25425
  free(homedirdir);
#line 25430
  large_font = TuxPaint_Font_OpenFont("BitStream Vera", "/usr/local/share/tuxpaint/fonts/default_font.ttf",
                                      (int )((float )(30 - only_uppercase * 3) * button_scale));
  }
#line 25433
  if (large_font == (void *)0) {
    {
#line 25435
    __cil_tmp160 = SDL_GetError();
#line 25435
    fprintf(stderr, "\nError: Can\'t load font file: /usr/local/share/tuxpaint/fonts/default_font.ttf\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\353\301s\324U",
            __cil_tmp160);
#line 25440
    cleanup();
#line 25441
    exit(1);
    }
  }
  {
#line 25445
  small_font = TuxPaint_Font_OpenFont("BitStream Vera", "/usr/local/share/tuxpaint/fonts/default_font.ttf\324U",
                                      (int )((float )(13 - only_uppercase * 2) * button_scale));
  }
#line 25453
  if (small_font == (void *)0) {
    {
#line 25455
    __cil_tmp162 = SDL_GetError();
#line 25455
    fprintf(stderr, "\nError: Can\'t load font file: /usr/local/share/tuxpaint/fonts/default_font.ttf\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n\266\267t\324U",
            __cil_tmp162);
#line 25460
    cleanup();
#line 25461
    exit(1);
    }
  }
#line 25468
  locale_font = medium_font;
#line 25478
  if (! dont_load_stamps) {
    {
#line 25479
    load_stamps(screen);
    }
  }
  {
#line 25484
  load_magic_plugins();
#line 25486
  show_progress_bar(screen);
#line 25489
  i = 0;
  }
  {
#line 25489
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 25489
    if (! (i < 22)) {
#line 25489
      goto while_break___3;
    }
    {
#line 25491
    __cil_tmp164 = loadimage(shape_img_fnames[i]);
#line 25491
    aux_surf = __cil_tmp164;
#line 25492
    img_shapes[i] = thumbnail2(aux_surf, (aux_surf->w * button_w) / 48, (aux_surf->h * button_h) / 48,
                               0, 1);
#line 25493
    SDL_FreeSurface(aux_surf);
    }
#line 25489
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 25496
  show_progress_bar(screen);
#line 25499
  i = 0;
  }
  {
#line 25499
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 25499
    if (! (i < 4)) {
#line 25499
      goto while_break___4;
    }
    {
#line 25501
    __cil_tmp168 = loadimage(fill_img_fnames[i]);
#line 25501
    aux_surf___0 = __cil_tmp168;
#line 25502
    img_fills[i] = thumbnail2(aux_surf___0, (aux_surf___0->w * button_w) / 48, (aux_surf___0->h * button_h) / 48,
                              0, 1);
#line 25503
    SDL_FreeSurface(aux_surf___0);
    }
#line 25499
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 25506
  show_progress_bar(screen);
#line 25509
  i = 0;
  }
  {
#line 25509
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 25509
    if (! (i < 6)) {
#line 25509
      goto while_break___5;
    }
    {
#line 25510
    img_tux[i] = loadimagerb(tux_img_fnames[i]);
    }
#line 25509
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 25512
  show_progress_bar(screen);
#line 25514
  img_mouse = loadimagerb("/usr/local/share/tuxpaint/images/ui/mouse.png");
#line 25515
  img_mouse_click = loadimagerb("/usr/local/share/tuxpaint/images/ui/mouse_click.png");
#line 25517
  show_progress_bar(screen);
#line 25519
  img_color_picker = loadimagerb("/usr/local/share/tuxpaint/images/ui/color_picker.png\220");
#line 25523
  i = 0;
  }
  {
#line 25523
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 25523
    if (! (i < 11)) {
#line 25523
      goto while_break___6;
    }
    {
#line 25525
    __cil_tmp176 = strlen(title_names[i]);
    }
#line 25525
    if (__cil_tmp176 > 0UL) {
      {
#line 25527
      myfont = large_font;
#line 25528
      __cil_tmp179 = dcgettext((char const   *)((void *)0), title_names[i], 5);
#line 25528
      __cil_tmp180 = textdir((char const   *)__cil_tmp179);
#line 25528
      td_str = __cil_tmp180;
#line 25530
      __cil_tmp181 = dcgettext((char const   *)((void *)0), title_names[i], 5);
#line 25530
      __cil_tmp182 = strcmp((char const   *)__cil_tmp181, title_names[i]);
      }
#line 25530
      if (need_own_font) {
#line 25530
        if (__cil_tmp182) {
#line 25531
          myfont = locale_font;
        }
      }
      {
#line 25532
      upstr = uppercase((char const   *)td_str);
#line 25533
      free(td_str);
#line 25534
      tmp_surf = render_text(myfont, (char const   *)upstr, black);
#line 25535
      free(upstr);
#line 25536
      img_title_names[i] = thumbnail(tmp_surf, 0, tmp_surf->h, 0);
#line 25537
      SDL_FreeSurface(tmp_surf);
      }
    } else {
#line 25541
      img_title_names[i] = (SDL_Surface *)((void *)0);
    }
#line 25523
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 25552
  img1 = loadimage("/usr/local/share/tuxpaint/images/ui/paintwell.png");
#line 25553
  img_paintwell = thumbnail(img1, color_button_w, color_button_h, 0);
#line 25554
  tmp_btn_up = thumbnail(img_btn_up, color_button_w, color_button_h, 0);
#line 25555
  tmp_btn_down = thumbnail(img_btn_down, color_button_w, color_button_h, 0);
#line 25556
  img_color_btn_off = thumbnail(img_btn_off, color_button_w, color_button_h, 0);
#line 25557
  SDL_FreeSurface(img1);
#line 25559
  img_color_picker_thumb = thumbnail(img_color_picker, color_button_w, color_button_h,
                                     0);
#line 25563
  img_color_btns = (SDL_Surface **)malloc((sizeof(SDL_Surface *) * (unsigned long )NUM_COLORS) * 2UL);
#line 25565
  i = 0;
  }
  {
#line 25565
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 25565
    if (! (i < NUM_COLORS * 2)) {
#line 25565
      goto while_break___7;
    }
    {
#line 25567
    *(img_color_btns + i) = SDL_CreateRGBSurface(screen->flags, tmp_btn_up->w, tmp_btn_up->h,
                                                 (int )(screen->format)->BitsPerPixel,
                                                 (screen->format)->Rmask, (screen->format)->Gmask,
                                                 (screen->format)->Bmask, (Uint32 )0);
    }
#line 25573
    if (*(img_color_btns + i) == (void *)0) {
      {
#line 25575
      __cil_tmp195 = SDL_GetError();
#line 25575
      fprintf(stderr, "\nError: Can\'t build color button!\nThe Simple DirectMedia Layer error that occurred was:\n%s\n\n",
              __cil_tmp195);
#line 25578
      cleanup();
#line 25579
      exit(1);
      }
    }
    {
#line 25582
    SDL_LockSurface(*(img_color_btns + i));
    }
#line 25565
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 25588
  SDL_LockSurface(tmp_btn_down);
#line 25589
  SDL_LockSurface(tmp_btn_up);
#line 25591
  getpixel_tmp_btn_up = getpixels[(tmp_btn_up->format)->BytesPerPixel];
#line 25592
  getpixel_tmp_btn_down = getpixels[(tmp_btn_down->format)->BytesPerPixel];
#line 25593
  getpixel_img_paintwell = getpixels[(img_paintwell->format)->BytesPerPixel];
#line 25596
  y = 0;
  }
  {
#line 25596
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 25596
    if (! (y < tmp_btn_up->h)) {
#line 25596
      goto while_break___8;
    }
#line 25598
    x = 0;
    {
#line 25598
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 25598
      if (! (x < tmp_btn_up->w)) {
#line 25598
        goto while_break___9;
      }
#line 25606
      ru = (double )sRGB_to_linear_table___1[r];
#line 25607
      gu = (double )sRGB_to_linear_table___1[g];
#line 25608
      bu = (double )sRGB_to_linear_table___1[b];
#line 25610
      rd = (double )sRGB_to_linear_table___1[r];
#line 25611
      gd = (double )sRGB_to_linear_table___1[g];
#line 25612
      bd = (double )sRGB_to_linear_table___1[b];
#line 25614
      aa = (double )((int )a) / 255.;
#line 25616
      i = 0;
      {
#line 25616
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 25616
        if (! (i < NUM_COLORS)) {
#line 25616
          goto while_break___10;
        }
#line 25618
        rh = (double )sRGB_to_linear_table___1[*(*(color_hexes + i) + 0)];
#line 25619
        gh = (double )sRGB_to_linear_table___1[*(*(color_hexes + i) + 1)];
#line 25620
        bh = (double )sRGB_to_linear_table___1[*(*(color_hexes + i) + 2)];
#line 25622
        if (i == NUM_COLORS - 1) {
          {
#line 25624
          __cil_tmp208 = (*(getpixels[(img_color_picker_thumb->format)->BytesPerPixel]))(img_color_picker_thumb,
                                                                                         x,
                                                                                         y);
#line 25624
          (*(putpixels[((*(img_color_btns + i))->format)->BytesPerPixel]))(*(img_color_btns + i),
                                                                           x, y, __cil_tmp208);
#line 25627
          __cil_tmp209 = (*(getpixels[(img_color_picker_thumb->format)->BytesPerPixel]))(img_color_picker_thumb,
                                                                                         x,
                                                                                         y);
#line 25627
          (*(putpixels[((*(img_color_btns + (i + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + (i + NUM_COLORS)),
                                                                                          x,
                                                                                          y,
                                                                                          __cil_tmp209);
          }
        }
#line 25632
        if (i < NUM_COLORS - 1) {
          _L: /* CIL Label */ 
          {
#line 25634
          __cil_tmp212 = linear_to_sRGB((float )(bh * aa + bu * (1. - aa)));
          }
          {
#line 25634
          __cil_tmp211 = linear_to_sRGB((float )(gh * aa + gu * (1. - aa)));
          }
          {
#line 25634
          __cil_tmp210 = linear_to_sRGB((float )(rh * aa + ru * (1. - aa)));
#line 25634
          (*(putpixels[((*(img_color_btns + i))->format)->BytesPerPixel]))(*(img_color_btns + i),
                                                                           x, y, ((((unsigned int )__cil_tmp210 & 255U) << 16) | (((unsigned int )__cil_tmp211 & 255U) << 8)) | ((unsigned int )__cil_tmp212 & 255U));
#line 25639
          __cil_tmp215 = linear_to_sRGB((float )(bh * aa + bd * (1. - aa)));
          }
          {
#line 25639
          __cil_tmp214 = linear_to_sRGB((float )(gh * aa + gd * (1. - aa)));
          }
          {
#line 25639
          __cil_tmp213 = linear_to_sRGB((float )(rh * aa + rd * (1. - aa)));
#line 25639
          (*(putpixels[((*(img_color_btns + (i + NUM_COLORS)))->format)->BytesPerPixel]))(*(img_color_btns + (i + NUM_COLORS)),
                                                                                          x,
                                                                                          y,
                                                                                          ((((unsigned int )__cil_tmp213 & 255U) << 16) | (((unsigned int )__cil_tmp214 & 255U) << 8)) | ((unsigned int )__cil_tmp215 & 255U));
          }
        } else
#line 25632
        if ((int )a == 255) {
#line 25632
          goto _L;
        }
#line 25616
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 25599
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 25596
    y ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 25649
  i = 0;
  {
#line 25649
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 25649
    if (! (i < NUM_COLORS * 2)) {
#line 25649
      goto while_break___11;
    }
    {
#line 25651
    SDL_UnlockSurface(*(img_color_btns + i));
    }
#line 25652
    if (i == NUM_COLORS - 2) {
      {
#line 25654
      dest.x = (Sint16 )(((*(img_color_btns + i))->w - img_color_sel->w) / 2);
#line 25655
      dest.y = (Sint16 )(((*(img_color_btns + i))->h - img_color_sel->h) / 2);
#line 25656
      dest.w = (Uint16 )img_color_sel->w;
#line 25657
      dest.h = (Uint16 )img_color_sel->h;
      {
#line 25658
      SDL_UpperBlit(img_color_sel, (SDL_Rect *)((void *)0), *(img_color_btns + i),
                    & dest);
      }
      }
    } else
#line 25652
    if (i == 2 * NUM_COLORS - 2) {
      {
#line 25654
      dest.x = (Sint16 )(((*(img_color_btns + i))->w - img_color_sel->w) / 2);
#line 25655
      dest.y = (Sint16 )(((*(img_color_btns + i))->h - img_color_sel->h) / 2);
#line 25656
      dest.w = (Uint16 )img_color_sel->w;
#line 25657
      dest.h = (Uint16 )img_color_sel->h;
      {
#line 25658
      SDL_UpperBlit(img_color_sel, (SDL_Rect *)((void *)0), *(img_color_btns + i),
                    & dest);
      }
      }
    }
#line 25649
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 25662
  SDL_UnlockSurface(tmp_btn_up);
#line 25663
  SDL_UnlockSurface(tmp_btn_down);
#line 25664
  SDL_FreeSurface(tmp_btn_up);
#line 25665
  SDL_FreeSurface(tmp_btn_down);
#line 25669
  create_button_labels();
#line 25674
  __cil_tmp220 = SDL_GetTicks();
#line 25674
  srand(__cil_tmp220);
#line 25679
  SDL_EnableUNICODE(1);
#line 25686
  signal(13, & signal_handler);
#line 25689
  signal(10, & signal_handler);
#line 25690
  signal(12, & signal_handler);
  }
  return;
}
}
#line 25699 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void claim_to_be_ready(void) 
{ 
  SDL_Rect dest ;
  SDL_Rect src ;
  int i ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 25707
  dest.x = (Sint16 )0;
#line 25708
  dest.y = (Sint16 )(WINDOW_HEIGHT - img_progress->h);
#line 25709
  dest.h = (Uint16 )img_progress->h;
#line 25710
  dest.w = (Uint16 )WINDOW_WIDTH;
#line 25711
  SDL_FillRect(screen, & dest, ((255U << 16) | (255U << 8)) | 255U);
#line 25712
  src.h = (Uint16 )img_progress->h;
#line 25713
  src.w = (Uint16 )img_title->w;
#line 25714
  src.x = (Sint16 )0;
#line 25715
  src.y = (Sint16 )(img_title->h - img_progress->h);
#line 25716
  dest.x = (Sint16 )((((WINDOW_WIDTH - img_title->w) - img_title_tuxpaint->w / 2) / 2 + img_title_tuxpaint->w / 2) + 20);
#line 25717
  SDL_UpperBlit(img_title, & src, screen, & dest);
#line 25719
  SDL_FreeSurface(img_title);
#line 25720
  SDL_FreeSurface(img_title_credits);
#line 25721
  SDL_FreeSurface(img_title_tuxpaint);
#line 25723
  dest.x = (Sint16 )0;
#line 25724
  dest.w = (Uint16 )WINDOW_WIDTH;
#line 25725
  update_screen_rect(& dest);
#line 25727
  do_setcursor(cursor_arrow);
#line 25728
  playsound(screen, 0, 0, 1, - 998, - 999);
#line 25729
  do_wait(50);
#line 25734
  cur_undo = 0;
#line 25735
  oldest_undo = 0;
#line 25736
  newest_undo = 0;
#line 25738
  cur_tool = 0;
#line 25739
  cur_color = (unsigned int )0;
#line 25740
  colors_are_selectable = 1;
#line 25741
  cur_brush = 0;
#line 25742
  i = 0;
  }
  {
#line 25742
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25742
    if (! (i < 256)) {
#line 25742
      goto while_break;
    }
#line 25743
    cur_stamp[i] = 0;
#line 25742
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 25744
  cur_shape = 0;
#line 25745
  cur_font = 0;
#line 25746
  cur_eraser = 0;
#line 25747
  cur_fill = 0;
#line 25748
  fill_drag_started = 0;
#line 25749
  cur_label = 1;
#line 25750
  cur_select = 0;
#line 25751
  cursor_left = - 1;
#line 25752
  cursor_x = - 1;
#line 25753
  cursor_y = - 1;
#line 25754
  cursor_textwidth = 0;
#line 25756
  oldpos_x = WINDOW_WIDTH / 2;
#line 25757
  oldpos_y = WINDOW_HEIGHT / 2;
#line 25759
  SDL_WarpMouse((Uint16 )oldpos_x, (Uint16 )oldpos_y);
#line 25761
  eraser_sound = 0;
#line 25763
  img_cur_brush = (SDL_Surface *)((void *)0);
#line 25764
  render_brush();
#line 25766
  brush_scroll = 0;
#line 25767
  i = 0;
  }
  {
#line 25767
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 25767
    if (! (i < 256)) {
#line 25767
      goto while_break___0;
    }
#line 25769
    stamp_scroll[i] = 0;
#line 25767
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 25771
  stamp_group = 0;
#line 25773
  i = 0;
  {
#line 25773
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 25773
    if (! (i < 16)) {
#line 25773
      goto while_break___1;
    }
#line 25775
    magic_scroll[i] = 0;
#line 25776
    cur_magic[i] = 0;
#line 25773
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 25778
  font_scroll = 0;
#line 25779
  tool_scroll = 0;
#line 25780
  eraser_scroll = 0;
#line 25781
  fill_scroll = 0;
#line 25783
  reset_avail_tools();
  }
#line 25788
  if (start_blank == 0) {
    {
#line 25789
    load_current();
    }
  }
  {
#line 25791
  been_saved = 1;
#line 25792
  tool_avail[13] = 0;
#line 25797
  SDL_FillRect(screen, (SDL_Rect *)((void *)0), ((255U << 16) | (255U << 8)) | 255U);
#line 25799
  draw_toolbar();
#line 25800
  draw_colors((unsigned int )16);
#line 25801
  draw_brushes();
#line 25802
  update_canvas(0, 0, WINDOW_WIDTH - (int )r_ttoolopt.w, 376 + (int )((Sint16 )(((WINDOW_HEIGHT - 480) / button_h) * button_h)));
#line 25804
  SDL_Flip(screen);
#line 25806
  draw_cur_tool_tip();
  }
  return;
}
}
#line 25814 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int main(int argc , char *argv[] ) 
{ 


  {
  {
#line 25828
  progname = argv[0];
#line 25843
  chdir_to_binary(argv[0]);
#line 25844
  setup_config(argv);
  }
#line 25876
  if (disable_save) {
#line 25876
    if (autosave_on_quit) {
      {
#line 25878
      fprintf(stderr, "Warning: Autosave requested, but saving is disabled.\n");
      }
    }
  }
#line 25880
  if (disable_save) {
#line 25880
    if (promptless_save != -1) {
      {
#line 25882
      fprintf(stderr, "Warning: Save-over option specified, but saving is disabled.\n");
      }
    }
  }
#line 25885
  if (promptless_save == -1) {
#line 25887
    promptless_save = 0;
  }
  {
#line 25891
  setup();
#line 25900
  claim_to_be_ready();
#line 25902
  mainloop();
#line 25905
  save_current();
#line 25906
  wait_for_sfx();
#line 25907
  cleanup();
  }
#line 25908
  return (0);
}
}
#line 25917 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int trash(char *path ) 
{ 
  char fname[256] ;
  char trashpath[256] ;
  char dest[256] ;
  char infoname[256] ;
  char bname[256] ;
  char ext[256] ;
  char deldate[32] ;
  struct tm tim ;
  time_t now ;
  int cnt ;
  int tmp ;
  FILE *fi ;
  FILE *fo ;
  unsigned char buf[1024] ;
  size_t len ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  int __cil_tmp31 ;
  int __cil_tmp32 ;
  int __cil_tmp33 ;
  FILE *__cil_tmp34 ;
  int __cil_tmp35 ;
  FILE *__cil_tmp36 ;
  int __cil_tmp37 ;
  int __cil_tmp38 ;
  unsigned long __cil_tmp39 ;
  FILE *__cil_tmp40 ;
  time_t __cil_tmp41 ;
  struct tm *__cil_tmp42 ;
  int __cil_tmp43 ;

  {
  {
#line 25934
  debug((char const   *)path);
#line 25939
  __cil_tmp17 = __xpg_basename(path);
  }
#line 25939
  if (__cil_tmp17 == (void *)0) {
    {
#line 25941
    debug("Can\'t get basename! Deleting instead.");
#line 25942
    __cil_tmp18 = unlink((char const   *)path);
    }
#line 25942
    return (__cil_tmp18);
  }
  {
#line 25948
  __cil_tmp19 = __xpg_basename(path);
#line 25948
  safe_strncpy((char *)fname, (char const   *)__cil_tmp19, sizeof(fname));
#line 25950
  __cil_tmp20 = file_exists(path);
  }
#line 25950
  if (! __cil_tmp20) {
    {
#line 25952
    debug("Does\'t exist anyway, so skipping\220");
    }
#line 25953
    return (1);
  }
  {
#line 25960
  __cil_tmp21 = getenv("XDG_DATA_HOME");
  }
#line 25960
  if (__cil_tmp21 != (void *)0) {
    {
#line 25962
    __cil_tmp22 = getenv("XDG_DATA_HOME");
#line 25962
    safe_snprintf((char *)trashpath, sizeof(trashpath), "%s/Trash\230", __cil_tmp22);
    }
  } else {
    {
#line 25964
    __cil_tmp23 = getenv("HOME");
    }
#line 25964
    if (__cil_tmp23 != (void *)0) {
      {
#line 25966
      __cil_tmp24 = getenv("HOME");
#line 25966
      safe_snprintf((char *)trashpath, sizeof(trashpath), "%s/.local/share/Trash",
                    __cil_tmp24);
      }
    } else {
      {
#line 25970
      debug("Can\'t move to trash! Deleting instead.");
#line 25971
      __cil_tmp25 = unlink((char const   *)path);
      }
#line 25971
      return (__cil_tmp25);
    }
  }
  {
#line 25974
  mkdir((char const   *)((char *)trashpath), (__mode_t )1911);
#line 25975
  safe_snprintf((char *)dest, sizeof(dest), "%s/files\230\001", (char *)trashpath);
#line 25976
  mkdir((char const   *)((char *)dest), (__mode_t )1911);
#line 25977
  safe_snprintf((char *)dest, sizeof(dest), "%s/info", (char *)trashpath);
#line 25978
  mkdir((char const   *)((char *)dest), (__mode_t )1911);
#line 25980
  safe_snprintf((char *)dest, sizeof(dest), "%s/files/%s", (char *)trashpath, (char *)fname);
#line 25982
  safe_strncpy((char *)bname, (char const   *)((char *)fname), sizeof(bname));
#line 25983
  __cil_tmp26 = strstr((char const   *)((char *)bname), ".");
  }
#line 25983
  if (__cil_tmp26 != (void *)0) {
    {
#line 25985
    __cil_tmp27 = strstr((char const   *)((char *)bname), ".");
#line 25985
    strcpy(__cil_tmp27, "");
#line 25986
    __cil_tmp28 = strstr((char const   *)((char *)fname), ".");
#line 25986
    safe_strncpy((char *)ext, (char const   *)(__cil_tmp28 + 1), sizeof(ext));
    }
  } else {
    {
#line 25990
    debug("Filename format unfamiliar! Deleting instead.");
#line 25991
    __cil_tmp29 = unlink((char const   *)path);
    }
#line 25991
    return (__cil_tmp29);
  }
  {
#line 25994
  safe_snprintf((char *)infoname, sizeof(infoname), "%s/info/%s.trashinfo", (char *)trashpath,
                (char *)fname);
#line 25996
  cnt = 1;
  }
  {
#line 25997
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 25997
    __cil_tmp30 = file_exists((char *)dest);
    }
#line 25997
    if (! (__cil_tmp30 && cnt < 100)) {
#line 25997
      goto while_break;
    }
    {
#line 25999
    safe_snprintf((char *)fname, sizeof(fname), "%s_%d.%s\230\001", (char *)bname,
                  cnt, (char *)ext);
#line 26001
    safe_snprintf((char *)dest, sizeof(dest), "%s/files/%s", (char *)trashpath, (char *)fname);
#line 26002
    safe_snprintf((char *)infoname, sizeof(infoname), "%s/info/%s.trashinfo", (char *)trashpath,
                  (char *)fname);
#line 26003
    cnt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 26006
  if (cnt >= 100) {
    {
#line 26008
    debug("Too many identically-named files! Deleting instead.");
#line 26009
    __cil_tmp32 = unlink((char const   *)path);
    }
#line 26009
    return (__cil_tmp32);
  }
  {
#line 26012
  debug((char const   *)((char *)dest));
#line 26014
  __cil_tmp33 = rename((char const   *)path, (char const   *)((char *)dest));
  }
#line 26014
  if (__cil_tmp33 == -1) {
    {
#line 26016
    debug("Could not move to trash. Trying to copy, instead.");
#line 26018
    fi = fopen((char const   *)path, "r");
    }
#line 26019
    if (fi == (void *)0) {
      {
#line 26021
      debug("Could not open source file for copy. Deleting instead.");
#line 26022
      __cil_tmp35 = unlink((char const   *)path);
      }
#line 26022
      return (__cil_tmp35);
    }
    {
#line 26024
    fo = fopen((char const   *)((char *)dest), "w");
    }
#line 26025
    if (fo == (void *)0) {
      {
#line 26027
      debug("Could not open dest. file for copy. Deleting instead.");
#line 26028
      fclose(fi);
#line 26029
      __cil_tmp37 = unlink((char const   *)path);
      }
#line 26029
      return (__cil_tmp37);
    }
    {
#line 26031
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 26031
      __cil_tmp38 = feof(fi);
      }
#line 26031
      if (! (! __cil_tmp38)) {
#line 26031
        goto while_break___0;
      }
      {
#line 26033
      len = fread((unsigned char *)buf, sizeof(unsigned char ), sizeof(buf), fi);
      }
#line 26034
      if (len > 0UL) {
        {
#line 26036
        fwrite((unsigned char *)buf, sizeof(unsigned char ), sizeof(buf), fo);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 26039
    fclose(fi);
#line 26040
    fclose(fo);
#line 26042
    unlink((char const   *)path);
    }
  }
  {
#line 26046
  fo = fopen((char const   *)((char *)infoname), "w");
  }
#line 26047
  if (fo == (void *)0) {
    {
#line 26049
    debug("Error: Couldn\'t create info file!");
    }
#line 26050
    return (1);
  }
  {
#line 26053
  now = time((time_t *)((void *)0));
#line 26054
  tim = (struct tm )localtime(& now);
#line 26055
  strftime((char *)deldate, sizeof(deldate), "%FT%T", & tim);
#line 26057
  fprintf(fo, "[Trash Info]\n");
#line 26058
  fprintf(fo, "Path=%s\n\230\001", path);
#line 26059
  fprintf(fo, "DeletionDate=%s\n\230\001", (char *)deldate);
#line 26060
  fclose(fo);
#line 26072
  tmp = system("dbus-send / org.kde.KDirNotify.FilesAdded string:trash:/\220");
  }
#line 26087
  return (0);
}
}
#line 26095 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int file_exists(char *path ) 
{ 
  struct stat buf ;
  int res ;
  int __cil_tmp4 ;

  {
  {
#line 26100
  res = stat((char const   *)path, & buf);
  }
#line 26101
  return (res == 0);
}
}
#line 26109 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_joyaxismotion(SDL_Event event , int *motioner , int *val_x , int *val_y ) 
{ 
  int i ;
  int j ;
  int step ;
  Sint16 __cil_tmp8 ;
  Sint16 __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 26113
  if ((int )event.jaxis.which != 0) {
#line 26114
    return;
  }
  {
#line 26116
  __cil_tmp8 = SDL_JoystickGetAxis(joystick, 0);
#line 26116
  i = (int )__cil_tmp8;
#line 26117
  __cil_tmp9 = SDL_JoystickGetAxis(joystick, 1);
#line 26117
  j = (int )__cil_tmp9;
#line 26118
  step = 5000;
#line 26119
  __cil_tmp11 = abs(j);
  }
  {
#line 26119
  __cil_tmp10 = abs(i);
  }
#line 26119
  if (__cil_tmp10 < joystick_low_threshold) {
#line 26119
    if (__cil_tmp11 < joystick_low_threshold) {
#line 26121
      *motioner = 0;
#line 26122
      *val_x = 0;
#line 26123
      *val_y = 0;
    } else {
#line 26119
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 26127
    if (i > joystick_low_threshold) {
#line 26128
      *val_x = 0;
    } else
#line 26129
    if (i < - joystick_low_threshold) {
#line 26130
      *val_x = 0;
    } else {
#line 26132
      *val_x = 0;
    }
#line 26134
    if (j > joystick_low_threshold) {
#line 26135
      *val_y = 0;
    } else
#line 26136
    if (j < - joystick_low_threshold) {
#line 26137
      *val_y = 0;
    } else {
#line 26139
      *val_y = 0;
    }
#line 26141
    if (*val_x) {
#line 26143
      *motioner = ! 0;
    } else
#line 26141
    if (*val_y) {
#line 26143
      *motioner = ! 0;
    } else {
#line 26146
      *motioner = 0;
    }
  }
  return;
}
}
#line 26153 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_joyhatmotion(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ,
                                int *valhat_x , int *valhat_y , int *hatmotioner ,
                                Uint32 *old_hat_ticks___0 ) 
{ 
  Uint32 __cil_tmp8 ;

  {
#line 26156
  *hatmotioner = 1;
  {
#line 26160
  if ((int )event.jhat.value == 0) {
#line 26160
    goto case_0;
  }
#line 26165
  if ((int )event.jhat.value == 1) {
#line 26165
    goto case_1;
  }
#line 26169
  if ((int )event.jhat.value == 3) {
#line 26169
    goto case_3;
  }
#line 26173
  if ((int )event.jhat.value == 2) {
#line 26173
    goto case_2;
  }
#line 26177
  if ((int )event.jhat.value == 6) {
#line 26177
    goto case_6;
  }
#line 26181
  if ((int )event.jhat.value == 4) {
#line 26181
    goto case_4;
  }
#line 26185
  if ((int )event.jhat.value == 12) {
#line 26185
    goto case_12;
  }
#line 26189
  if ((int )event.jhat.value == 8) {
#line 26189
    goto case_8;
  }
#line 26193
  if ((int )event.jhat.value == 9) {
#line 26193
    goto case_9;
  }
#line 26158
  goto switch_break;
  case_0: /* CIL Label */ 
#line 26161
  *valhat_x = 0;
#line 26162
  *valhat_y = 0;
#line 26163
  *hatmotioner = 0;
#line 26164
  goto switch_break;
  case_1: /* CIL Label */ 
#line 26166
  *valhat_x = 0;
#line 26167
  *valhat_y = - 1;
#line 26168
  goto switch_break;
  case_3: /* CIL Label */ 
#line 26170
  *valhat_x = 1;
#line 26171
  *valhat_y = - 1;
#line 26172
  goto switch_break;
  case_2: /* CIL Label */ 
#line 26174
  *valhat_x = 1;
#line 26175
  *valhat_y = 0;
#line 26176
  goto switch_break;
  case_6: /* CIL Label */ 
#line 26178
  *valhat_x = 1;
#line 26179
  *valhat_y = 1;
#line 26180
  goto switch_break;
  case_4: /* CIL Label */ 
#line 26182
  *valhat_x = 0;
#line 26183
  *valhat_y = 1;
#line 26184
  goto switch_break;
  case_12: /* CIL Label */ 
#line 26186
  *valhat_x = - 1;
#line 26187
  *valhat_y = 1;
#line 26188
  goto switch_break;
  case_8: /* CIL Label */ 
#line 26190
  *valhat_x = - 1;
#line 26191
  *valhat_y = 0;
#line 26192
  goto switch_break;
  case_9: /* CIL Label */ 
#line 26194
  *valhat_x = - 1;
#line 26195
  *valhat_y = - 1;
#line 26196
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 26198
  if (*valhat_x) {
    {
    {
#line 26199
    SDL_WarpMouse((Uint16 )(oldpos_x___0 + *valhat_x), (Uint16 )(oldpos_y___0 + *valhat_y));
    }
    }
  } else
#line 26198
  if (*valhat_y) {
    {
    {
#line 26199
    SDL_WarpMouse((Uint16 )(oldpos_x___0 + *valhat_x), (Uint16 )(oldpos_y___0 + *valhat_y));
    }
    }
  }
  {
#line 26201
  *old_hat_ticks___0 = SDL_GetTicks();
  }
  return;
}
}
#line 26207 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_joyballmotion(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ) 
{ 
  int val_x ;
  int val_y ;

  {
  {
#line 26214
  val_x = (int )event.jball.xrel;
#line 26215
  val_y = (int )event.jball.yrel;
#line 26216
  SDL_WarpMouse((Uint16 )(oldpos_x___0 + val_x), (Uint16 )(oldpos_y___0 + val_y));
  }
  return;
}
}
#line 26222 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_motioners(int oldpos_x___0 , int oldpos_y___0 , int motioner ,
                             int hatmotioner , int old_hat_ticks___0 , int val_x ,
                             int val_y , int valhat_x , int valhat_y ) 
{ 
  int vx ;
  int vy ;
  Uint32 ticks ;
  Uint32 __cil_tmp13 ;

  {
  {
#line 26228
  ticks = SDL_GetTicks();
#line 26229
  vy = 0;
#line 26229
  vx = vy;
#line 26231
  vx = oldpos_x___0 + val_x;
#line 26232
  vy = oldpos_y___0 + val_y;
  }
#line 26235
  if (ticks - (unsigned int )old_hat_ticks___0 > joystick_hat_timeout) {
#line 26237
    vx += valhat_x;
#line 26238
    vy += valhat_y;
  }
  {
#line 26240
  SDL_WarpMouse((Uint16 )vx, (Uint16 )vy);
  }
#line 26242
  if (motioner) {
#line 26242
    if (joystick_slowness) {
      {
#line 26243
      SDL_Delay((Uint32 )joystick_slowness);
      }
    }
  }
#line 26245
  if (hatmotioner) {
#line 26245
    if (joystick_hat_slowness) {
      {
#line 26246
      SDL_Delay((Uint32 )joystick_hat_slowness);
      }
    }
  }
  return;
}
}
#line 26253 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_joybuttonupdown(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ) 
{ 


  {
  {
#line 26255
  handle_joybuttonupdownscl(event, oldpos_x___0, oldpos_y___0, r_tools);
  }
  return;
}
}
#line 26261 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static void handle_joybuttonupdownscl(SDL_Event event , int oldpos_x___0 , int oldpos_y___0 ,
                                      SDL_Rect real_r_tools ) 
{ 
  int i ;
  int ignore ;
  int eby ;
  int ts ;
  SDL_Event ev ;
  int __cil_tmp10 ;

  {
#line 26263
  ignore = 0;
#line 26267
  ev.button.x = (Uint16 )oldpos_x___0;
#line 26268
  ev.button.y = (Uint16 )oldpos_y___0;
#line 26269
  ev.button.button = (Uint8 )1;
#line 26270
  ev.button.type = (Uint8 )5;
#line 26271
  ev.button.state = (Uint8 )1;
#line 26273
  if ((int )event.type == 10) {
#line 26277
    if ((int )event.button.button == joystick_button_escape) {
#line 26279
      ev.type = (Uint8 )2;
#line 26280
      ev.key.keysym.sym = (SDLKey )27;
#line 26281
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26283
    if ((int )event.button.button == joystick_button_pagesetup) {
#line 26285
      ev.type = (Uint8 )2;
#line 26286
      ev.key.keysym.sym = (SDLKey )112;
#line 26287
      ev.key.keysym.mod = (SDLMod )195;
    } else
#line 26291
    if ((int )event.button.button == joystick_button_undo) {
#line 26293
      ev.type = (Uint8 )2;
#line 26294
      ev.key.keysym.sym = (SDLKey )122;
#line 26295
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26297
    if ((int )event.button.button == joystick_button_redo) {
#line 26299
      ev.type = (Uint8 )2;
#line 26300
      ev.key.keysym.sym = (SDLKey )114;
#line 26301
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26303
    if ((int )event.button.button == joystick_button_open) {
#line 26305
      ev.type = (Uint8 )2;
#line 26306
      ev.key.keysym.sym = (SDLKey )111;
#line 26307
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26309
    if ((int )event.button.button == joystick_button_new) {
#line 26311
      ev.type = (Uint8 )2;
#line 26312
      ev.key.keysym.sym = (SDLKey )110;
#line 26313
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26315
    if ((int )event.button.button == joystick_button_save) {
#line 26317
      ev.type = (Uint8 )2;
#line 26318
      ev.key.keysym.sym = (SDLKey )115;
#line 26319
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26321
    if ((int )event.button.button == joystick_button_print) {
#line 26323
      ev.type = (Uint8 )2;
#line 26324
      ev.key.keysym.sym = (SDLKey )112;
#line 26325
      ev.key.keysym.mod = (SDLMod )192;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectbrushtool) {
      _L: /* CIL Label */ 
      _L___315: /* CIL Label */ 
      _L___316: /* CIL Label */ 
      _L___317: /* CIL Label */ 
      _L___318: /* CIL Label */ 
      _L___319: /* CIL Label */ 
      _L___320: /* CIL Label */ 
#line 26345
      if ((int )event.button.button == joystick_button_selectbrushtool) {
#line 26347
        ev.button.x = (Uint16 )(button_w / 2);
#line 26348
        ev.button.y = (Uint16 )((int )real_r_tools.y + button_h / 2);
      } else
#line 26351
      if ((int )event.button.button == joystick_button_selectstamptool) {
#line 26353
        ev.button.x = (Uint16 )(button_w + button_w / 2);
#line 26354
        ev.button.y = (Uint16 )((int )real_r_tools.y + button_h / 2);
      } else
#line 26357
      if ((int )event.button.button == joystick_button_selectlinestool) {
#line 26359
        ev.button.x = (Uint16 )(button_w / 2);
#line 26360
        ev.button.y = (Uint16 )(((int )real_r_tools.y + button_h) + button_h / 2);
      } else
#line 26363
      if ((int )event.button.button == joystick_button_selectshapestool) {
#line 26365
        ev.button.x = (Uint16 )(button_w + button_w / 2);
#line 26366
        ev.button.y = (Uint16 )(((int )real_r_tools.y + button_h) + button_h / 2);
      } else
#line 26369
      if ((int )event.button.button == joystick_button_selecttexttool) {
#line 26371
        ev.button.x = (Uint16 )(button_w / 2);
#line 26372
        ev.button.y = (Uint16 )(((int )real_r_tools.y + 2 * button_h) + button_h / 2);
      } else
#line 26375
      if ((int )event.button.button == joystick_button_selectlabeltool) {
#line 26377
        ev.button.x = (Uint16 )(button_w + button_w / 2);
#line 26378
        ev.button.y = (Uint16 )(((int )real_r_tools.y + 2 * button_h) + button_h / 2);
      } else
#line 26381
      if ((int )event.button.button == joystick_button_selectmagictool) {
#line 26383
        ev.button.x = (Uint16 )(button_w + button_w / 2);
#line 26384
        ev.button.y = (Uint16 )(((int )real_r_tools.y + 3 * button_h) + button_h / 2);
      } else
#line 26387
      if ((int )event.button.button == joystick_button_selecterasertool) {
#line 26389
        ev.button.x = (Uint16 )(button_w / 2);
#line 26390
        ev.button.y = (Uint16 )(((int )real_r_tools.y + 5 * button_h) + button_h / 2);
      }
#line 26394
      eby = (int )ev.button.y;
#line 26395
      ts = tool_scroll;
      {
#line 26397
      while (1) {
        while_continue: /* CIL Label */ ;
#line 26397
        if (! (eby < (int )real_r_tools.y + (ts / 2) * button_h)) {
#line 26397
          goto while_break;
        }
        {
#line 26399
        ev.button.y = (Uint16 )((int )real_r_tools.y - 1);
#line 26400
        SDL_PushEvent(& ev);
#line 26401
        ts -= 2;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 26405
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 26405
        if (! (eby > ((int )real_r_tools.y + (int )real_r_tools.h) + (ts / 2) * button_h)) {
#line 26405
          goto while_break___0;
        }
        {
#line 26407
        ev.button.y = (Uint16 )(((int )real_r_tools.y + (int )real_r_tools.h) + 1);
#line 26408
        SDL_PushEvent(& ev);
#line 26409
        ts += 2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 26412
      ev.button.y = (Uint16 )(eby - (ts / 2) * button_h);
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectstamptool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectlinestool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectshapestool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selecttexttool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectlabeltool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selectmagictool) {
#line 26335
      goto _L;
    } else
#line 26335
    if ((int )event.button.button == joystick_button_selecterasertool) {
#line 26335
      goto _L;
    }
  } else {
#line 26417
    ev.button.type = (Uint8 )6;
#line 26418
    ev.button.state = (Uint8 )0;
  }
#line 26427
  i = 0;
  {
#line 26427
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 26427
    if (! (i < joystick_buttons_ignore_len && ! ignore)) {
#line 26427
      goto while_break___1;
    }
#line 26429
    if ((int )event.button.button == joystick_buttons_ignore[i]) {
#line 26431
      ignore = 1;
    }
#line 26427
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 26435
  if (! ignore) {
    {
#line 26436
    SDL_PushEvent(& ev);
    }
  }
  return;
}
}
#line 26447 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
char *get_xdg_user_dir(char const   *dir_type , char const   *fallback ) 
{ 
  FILE *fi ;
  char *config_home ;
  char *found ;
  char tmp_path[256] ;
  char config_path[256] ;
  char line[256] ;
  char search[256] ;
  char return_path[256] ;
  int found_it ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  unsigned long __cil_tmp19 ;
  unsigned long __cil_tmp20 ;
  FILE *__cil_tmp21 ;
  char *__cil_tmp22 ;
  unsigned long __cil_tmp23 ;
  unsigned long __cil_tmp24 ;
  unsigned long __cil_tmp25 ;
  char *__cil_tmp26 ;
  unsigned long __cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  unsigned long __cil_tmp30 ;
  unsigned long __cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 26453
  found_it = 0;
#line 26456
  __cil_tmp12 = getenv("XDG_CONFIG_HOME");
  }
#line 26456
  if (__cil_tmp12 != (void *)0) {
    {
#line 26457
    __cil_tmp13 = getenv("XDG_CONFIG_HOME");
#line 26457
    __cil_tmp14 = strdup((char const   *)__cil_tmp13);
#line 26457
    config_home = __cil_tmp14;
    }
  } else {
    {
#line 26462
    __cil_tmp15 = getenv("HOME");
    }
#line 26462
    if (__cil_tmp15 != (void *)0) {
      {
#line 26463
      __cil_tmp16 = getenv("HOME");
#line 26463
      safe_snprintf((char *)tmp_path, (size_t )256, "%s/.config", __cil_tmp16);
#line 26464
      config_home = strdup((char const   *)((char *)tmp_path));
      }
    } else {
      {
#line 26469
      __cil_tmp18 = strdup(fallback);
      }
#line 26469
      return (__cil_tmp18);
    }
  }
  {
#line 26473
  __cil_tmp19 = strlen((char const   *)config_home);
  }
#line 26473
  if ((int )*(config_home + (__cil_tmp19 - 1UL)) == 47) {
    {
#line 26474
    __cil_tmp20 = strlen((char const   *)config_home);
#line 26474
    *(config_home + (__cil_tmp20 - 1UL)) = (char )'\000';
    }
  }
  {
#line 26476
  safe_snprintf((char *)config_path, (size_t )256, "%s/user-dirs.dirs", config_home);
#line 26477
  free(config_home);
#line 26483
  safe_snprintf((char *)search, (size_t )256, "XDG_%s_DIR=\"\324U", dir_type);
#line 26486
  fi = fopen((char const   *)((char *)config_path), "r\'\275t\324U");
  }
#line 26487
  if (fi != (void *)0) {
    {
#line 26495
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 26495
      __cil_tmp22 = fgets((char *)line, 256, fi);
      }
#line 26495
      if (! (__cil_tmp22 && ! found_it)) {
#line 26495
        goto while_break;
      }
      {
#line 26497
      __cil_tmp24 = strlen((char const   *)((char *)line));
      }
      {
#line 26497
      __cil_tmp23 = strlen((char const   *)((char *)line));
      }
#line 26497
      if ((int )line[__cil_tmp23 - 1UL] == 10) {
        {
        {
#line 26499
        __cil_tmp25 = strlen((char const   *)((char *)line));
        }
#line 26499
        line[__cil_tmp25 - 1UL] = (char )'\000';
        }
      } else
#line 26497
      if ((int )line[__cil_tmp24 - 1UL] == 13) {
        {
        {
#line 26499
        __cil_tmp25 = strlen((char const   *)((char *)line));
        }
#line 26499
        line[__cil_tmp25 - 1UL] = (char )'\000';
        }
      }
      {
#line 26502
      __cil_tmp26 = strstr((char const   *)((char *)line), (char const   *)((char *)search));
      }
#line 26502
      if (__cil_tmp26 == (char *)line) {
        {
#line 26503
        __cil_tmp27 = strlen((char const   *)((char *)search));
#line 26503
        found = (char *)line + __cil_tmp27;
#line 26507
        __cil_tmp28 = strstr((char const   *)found, "$HOME/");
        }
#line 26507
        if (__cil_tmp28 == found) {
          {
#line 26508
          __cil_tmp29 = getenv("HOME\324U");
#line 26508
          safe_snprintf((char *)return_path, (size_t )256, "%s/%s", __cil_tmp29, found + 6);
          }
        } else {
          {
#line 26510
          safe_strncpy((char *)return_path, (char const   *)found, (size_t )256);
          }
        }
        {
#line 26514
        __cil_tmp30 = strlen((char const   *)((char *)return_path));
        }
#line 26514
        if ((int )return_path[__cil_tmp30 - 1UL] == 34) {
          {
#line 26515
          __cil_tmp31 = strlen((char const   *)((char *)return_path));
#line 26515
          return_path[__cil_tmp31 - 1UL] = (char )'\000';
          }
        }
#line 26518
        found_it = ! 0;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 26522
    fclose(fi);
    }
  }
#line 26529
  if (! found_it) {
    {
#line 26533
    __cil_tmp32 = getenv("HOME\324U");
#line 26533
    safe_snprintf((char *)return_path, (size_t )256, "%s/%sU", __cil_tmp32, fallback);
    }
  }
  {
#line 26540
  __cil_tmp33 = strdup((char const   *)((char *)return_path));
  }
#line 26540
  return (__cil_tmp33);
}
}
#line 26552 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int export_gif(int *selected , int num_selected , char *dirname___0 , char **d_names ,
                      char **d_exts , int speed ) 
{ 
  char *tmp_starter_id ;
  char *tmp_template_id ;
  char *tmp_file_id ;
  int tmp_starter_mirrored ;
  int tmp_starter_flipped ;
  int tmp_starter_personal ;
  char *gif_fname ;
  char fname[256] ;
  int i ;
  int j ;
  int done ;
  int which ;
  int x ;
  int y ;
  SDL_Surface *img ;
  int overall_w ;
  int overall_h ;
  int overall_area ;
  Uint8 *bitmap ;
  Uint8 r ;
  Uint8 g ;
  Uint8 b ;
  Uint8 a ;
  size_t pixels_size ;
  unsigned char *raw_8bit_pixels ;
  uint8_t gif_palette[768] ;
  liq_attr *liq_handle ;
  liq_image *input_image ;
  liq_result *quantization_result ;
  liq_error qtiz_status ;
  liq_palette *palette ;
  int gif_speed ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  void *__cil_tmp43 ;
  SDL_Surface *__cil_tmp44 ;
  int __cil_tmp45 ;
  int __cil_tmp46 ;
  int __cil_tmp47 ;
  int __cil_tmp48 ;
  liq_attr *__cil_tmp49 ;
  liq_image *__cil_tmp50 ;
  int __cil_tmp51 ;
  liq_error __cil_tmp52 ;
  void *__cil_tmp53 ;
  liq_palette *__cil_tmp54 ;
  int __cil_tmp55 ;
  ge_GIF *gif ;
  ge_GIF *__cil_tmp57 ;
  int __cil_tmp58 ;
  int __cil_tmp59 ;

  {
  {
#line 26576
  tmp_starter_id = strdup((char const   *)((char *)starter_id));
#line 26577
  tmp_template_id = strdup((char const   *)((char *)template_id));
#line 26578
  tmp_file_id = strdup((char const   *)((char *)file_id));
#line 26579
  tmp_starter_mirrored = starter_mirrored;
#line 26580
  tmp_starter_flipped = starter_flipped;
#line 26581
  tmp_starter_personal = starter_personal;
#line 26583
  do_setcursor(cursor_watch);
#line 26584
  show_progress_bar(screen);
#line 26586
  gif_fname = get_export_filepath("gif");
  }
#line 26587
  if (gif_fname == (void *)0) {
#line 26590
    return (0);
  }
#line 26595
  overall_w = screen->w;
#line 26596
  overall_h = screen->h;
#line 26597
  overall_area = overall_w * overall_h;
#line 26599
  if (speed == 0) {
#line 26601
    gif_speed = 1;
  }
  {
#line 26603
  gif_speed = (10 - speed) * 50;
#line 26605
  bitmap = (Uint8 *)malloc((unsigned long )((num_selected * overall_area) * 4));
  }
#line 26606
  if (bitmap != (void *)0) {
#line 26608
    done = 0;
#line 26610
    i = 0;
    {
#line 26610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 26610
      if (! (i < num_selected && ! done)) {
#line 26610
        goto while_break;
      }
      {
#line 26612
      which = *(selected + i);
#line 26613
      show_progress_bar(screen);
#line 26617
      safe_snprintf((char *)fname, sizeof(fname), "%s/%s%s", dirname___0, *(d_names + which),
                    *(d_exts + which));
#line 26620
      img = myIMG_Load((char const   *)((char *)fname));
      }
#line 26622
      if (img != (void *)0) {
        {
#line 26624
        autoscale_copy_smear_free(img, screen, & SDL_UpperBlit);
#line 26626
        safe_strncpy((char *)file_id, (char const   *)*(d_names + which), sizeof(file_id));
#line 26629
        load_starter_id(*(d_names + which), (FILE *)((void *)0));
        }
#line 26630
        if ((int )starter_id[0] != 0) {
          {
#line 26632
          load_starter((char *)starter_id);
          }
#line 26634
          if (starter_mirrored) {
            {
#line 26635
            mirror_starter();
            }
          }
#line 26637
          if (starter_flipped) {
            {
#line 26638
            flip_starter();
            }
          }
        } else {
          {
#line 26641
          load_template((char *)template_id);
          }
        }
      } else {
        {
#line 26644
        fprintf(stderr, "Error loading %s!\n", (char *)fname);
        }
      }
#line 26649
      y = 0;
      {
#line 26649
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 26649
        if (! (y < overall_h)) {
#line 26649
          goto while_break___0;
        }
#line 26650
        x = 0;
        {
#line 26650
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 26650
          if (! (x < overall_w)) {
#line 26650
            goto while_break___1;
          }
#line 26653
          *(bitmap + ((i * overall_area + y * overall_w) + x) * 4) = r;
#line 26654
          *(bitmap + (((i * overall_area + y * overall_w) + x) * 4 + 1)) = g;
#line 26655
          *(bitmap + (((i * overall_area + y * overall_w) + x) * 4 + 2)) = b;
#line 26656
          *(bitmap + (((i * overall_area + y * overall_w) + x) * 4 + 3)) = (Uint8 )255;
#line 26650
          x ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 26649
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 26660
      SDL_Flip(screen);
#line 26661
      done = export_gif_monitor_events();
      }
#line 26610
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 26665
    if (! done) {
      {
#line 26668
      liq_handle = liq_attr_create();
#line 26669
      input_image = liq_image_create_rgba(liq_handle, bitmap, overall_w, num_selected * overall_h,
                                          (double )0);
#line 26670
      liq_set_max_colors(liq_handle, 256);
#line 26672
      show_progress_bar(screen);
#line 26673
      done = export_gif_monitor_events();
#line 26676
      qtiz_status = liq_image_quantize(input_image, liq_handle, & quantization_result);
#line 26677
      done = (unsigned int )qtiz_status != 0U;
      }
#line 26682
      if (! done) {
        {
#line 26684
        pixels_size = (size_t )(num_selected * overall_area);
#line 26685
        raw_8bit_pixels = (unsigned char *)malloc(pixels_size);
#line 26686
        liq_set_dithering_level(quantization_result, (float )1.);
#line 26688
        liq_write_remapped_image(quantization_result, input_image, raw_8bit_pixels,
                                 pixels_size);
#line 26689
        palette = liq_get_palette(quantization_result);
#line 26690
        free(bitmap);
#line 26692
        j = 0;
        }
        {
#line 26692
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 26692
          if (! (j < (int )palette->count)) {
#line 26692
            goto while_break___2;
          }
#line 26693
          gif_palette[j * 3] = palette->entries[j].r;
#line 26694
          gif_palette[j * 3 + 1] = palette->entries[j].g;
#line 26695
          gif_palette[j * 3 + 2] = palette->entries[j].b;
#line 26692
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 26699
        __cil_tmp57 = ge_new_gif((char const   *)gif_fname, (uint16_t )overall_w,
                                 (uint16_t )overall_h, (uint8_t *)gif_palette, 8,
                                 0);
#line 26699
        gif = __cil_tmp57;
#line 26708
        i = 0;
        }
        {
#line 26708
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 26708
          if (! (i < num_selected && ! done)) {
#line 26708
            goto while_break___3;
          }
          {
#line 26710
          memcpy(gif->frame, raw_8bit_pixels + i * overall_area, (unsigned long )overall_area);
#line 26711
          ge_add_frame(gif, (uint16_t )gif_speed);
#line 26713
          show_progress_bar(screen);
#line 26714
          done = export_gif_monitor_events();
          }
#line 26708
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 26718
        ge_close_gif(gif);
        }
      } else {
        {
#line 26720
        fprintf(stderr, "Quantization failed\n");
#line 26721
        done = 1;
        }
      }
#line 26724
      if (done) {
        {
#line 26727
        unlink((char const   *)gif_fname);
        }
      }
    }
  } else {
#line 26734
    done = 1;
  }
  {
#line 26740
  strcpy((char *)starter_id, (char const   *)tmp_starter_id);
#line 26741
  free(tmp_starter_id);
#line 26743
  strcpy((char *)template_id, (char const   *)tmp_template_id);
#line 26744
  free(tmp_template_id);
#line 26746
  strcpy((char *)file_id, (char const   *)tmp_file_id);
#line 26747
  free(tmp_file_id);
#line 26749
  starter_mirrored = tmp_starter_mirrored;
#line 26750
  starter_flipped = tmp_starter_flipped;
#line 26751
  starter_personal = tmp_starter_personal;
#line 26754
  free(gif_fname);
  }
#line 26757
  return (! done);
}
}
#line 26768 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int export_gif_monitor_events(void) 
{ 
  int done ;
  SDL_Event event ;
  SDLKey key ;
  int __cil_tmp4 ;

  {
#line 26773
  done = 0;
  {
#line 26774
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26774
    __cil_tmp4 = SDL_PollEvent(& event);
    }
#line 26774
    if (! __cil_tmp4) {
#line 26774
      goto while_break;
    }
#line 26776
    if ((int )event.type == 12) {
#line 26778
      done = 1;
    } else
#line 26780
    if ((int )event.type == 2) {
#line 26782
      key = event.key.keysym.sym;
#line 26783
      if ((unsigned int )key == 27U) {
#line 26784
        done = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26788
  SDL_Delay((Uint32 )10);
  }
#line 26789
  return (done);
}
}
#line 26802 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static int export_pict(char *fname ) 
{ 
  FILE *fi ;
  FILE *fo ;
  size_t len ;
  unsigned char buf[1024] ;
  char *pict_fname ;
  Uint32 time_before ;
  Uint32 time_after ;
  FILE *__cil_tmp9 ;
  int *__cil_tmp10 ;
  char *__cil_tmp11 ;
  Uint32 __cil_tmp12 ;
  char *__cil_tmp13 ;
  FILE *__cil_tmp14 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  unsigned long __cil_tmp18 ;
  Uint32 __cil_tmp19 ;

  {
  {
#line 26809
  do_setcursor(cursor_watch);
#line 26810
  show_progress_bar(screen);
#line 26812
  fi = fopen((char const   *)fname, "rb");
  }
#line 26813
  if (fi == (void *)0) {
    {
#line 26815
    __cil_tmp10 = __errno_location();
#line 26815
    __cil_tmp11 = strerror(*__cil_tmp10);
#line 26815
    fprintf(stderr, "Cannot export from saved Tux Paint file \'%s\'\nThe error that occurred was:\n%s\n\n",
            fname, __cil_tmp11);
    }
#line 26816
    return (0);
  }
  {
#line 26819
  time_before = SDL_GetTicks();
#line 26820
  pict_fname = get_export_filepath("pngt\324U");
  }
#line 26821
  if (pict_fname == (void *)0) {
    {
#line 26823
    fclose(fi);
    }
#line 26824
    return (0);
  }
  {
#line 26827
  fo = fopen((char const   *)pict_fname, "wb\276t\324U");
  }
#line 26828
  if (fo == (void *)0) {
    {
#line 26830
    __cil_tmp15 = __errno_location();
#line 26830
    __cil_tmp16 = strerror(*__cil_tmp15);
#line 26830
    fprintf(stderr, "Cannot export to new file \'%s\'\nThe error that occurred was:\n%s\n\n\230\001",
            pict_fname, __cil_tmp16);
#line 26831
    free(pict_fname);
#line 26832
    fclose(fi);
    }
#line 26833
    return (0);
  }
  {
#line 26836
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26836
    __cil_tmp17 = feof(fi);
    }
#line 26836
    if (! (! __cil_tmp17)) {
#line 26836
      goto while_break;
    }
    {
#line 26838
    len = fread((unsigned char *)buf, sizeof(unsigned char ), sizeof(buf), fi);
    }
#line 26839
    if (len > 0UL) {
      {
#line 26841
      fwrite((unsigned char *)buf, sizeof(unsigned char ), sizeof(buf), fo);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26847
  fclose(fi);
#line 26848
  fclose(fo);
#line 26850
  free(pict_fname);
#line 26854
  time_after = SDL_GetTicks();
  }
#line 26855
  if (time_after - time_before < 1000U) {
    {
#line 26857
    show_progress_bar(screen);
#line 26858
    SDL_Delay((time_after + 1000U) - time_before);
    }
  }
#line 26861
  return (! 0);
}
}
#line 26879 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
static char *get_export_filepath(char const   *ext ) 
{ 
  char *rname ;
  char fname[4096] ;
  char timestamp[16] ;
  time_t t ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  time_t __cil_tmp9 ;
  struct tm *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 26887
  __cil_tmp6 = make_directory(2, "\323\001 ", "Can\'t create export directory; will try to make its parent (E016)b\276t\324U");
  }
#line 26887
  if (! __cil_tmp6) {
    {
#line 26890
    __cil_tmp7 = make_directory(3, "\323\001 ", "Can\'t create export directory parent (E016b)");
    }
#line 26890
    if (__cil_tmp7) {
      {
#line 26891
      __cil_tmp8 = make_directory(2, "\323\001 ", "Can\'t create export directory (E016c)U");
      }
#line 26891
      if (! __cil_tmp8) {
#line 26892
        return ((char *)((void *)0));
      }
    } else {
#line 26895
      return ((char *)((void *)0));
    }
  }
  {
#line 26900
  t = time((time_t *)((void *)0));
#line 26901
  __cil_tmp10 = localtime(& t);
#line 26901
  strftime((char *)timestamp, sizeof(timestamp), "%Y%m%d%H%M%S", __cil_tmp10);
#line 26902
  safe_snprintf((char *)fname, sizeof(fname), "%s.%s", (char *)timestamp, ext);
#line 26903
  rname = get_fname((char const   *)((char *)fname), 2);
#line 26904
  debug((char const   *)rname);
  }
#line 26906
  return (rname);
}
}
#line 26909 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
char *safe_strncat(char *dest , char const   *src , size_t n ) 
{ 
  char *ptr ;
  char *__cil_tmp5 ;

  {
  {
#line 26911
  ptr = strncat(dest, src, n - 1UL);
#line 26912
  *(dest + (n - 1UL)) = (char )'\000';
  }
#line 26913
  return (ptr);
}
}
#line 26916 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
char *safe_strncpy(char *dest , char const   *src , size_t n ) 
{ 
  char *ptr ;
  char *__cil_tmp5 ;

  {
  {
#line 26918
  ptr = strncpy(dest, src, n - 1UL);
#line 26919
  *(dest + (n - 1UL)) = (char )'\000';
  }
#line 26920
  return (ptr);
}
}
#line 26923 "/root/patron-artifact/pkg/tuxpaint-plugins-default_tmp/tuxpaint-0.9.27/src/tuxpaint.c"
int safe_snprintf(char *str , size_t size , char const   *format  , ...) 
{ 
  int r ;
  va_list ap ;
  int __cil_tmp6 ;

  {
  {
#line 26927
  __builtin_va_start((void *)ap, format);
#line 26928
  r = vsnprintf(str, size - 1UL, format, (void *)ap);
#line 26929
  __builtin_va_end((void *)ap);
#line 26931
  *(str + (size - 1UL)) = (char )'\000';
  }
#line 26932
  return (r);
}
}
